1:456a2ba: /**
1:456a2ba:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:456a2ba:  * contributor license agreements.  See the NOTICE file distributed with
1:456a2ba:  * this work for additional information regarding copyright ownership.
1:456a2ba:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:456a2ba:  * (the "License"); you may not use this file except in compliance with
1:456a2ba:  * the License.  You may obtain a copy of the License at
1:456a2ba:  *
1:456a2ba:  *      http://www.apache.org/licenses/LICENSE-2.0
1:456a2ba:  *
1:456a2ba:  * Unless required by applicable law or agreed to in writing, software
1:456a2ba:  * distributed under the License is distributed on an "AS IS" BASIS,
1:456a2ba:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:456a2ba:  * See the License for the specific language governing permissions and
1:456a2ba:  * limitations under the License.
1:456a2ba:  */
1:1aab71b: package org.apache.activemq.store.kahadb.disk.index;
5:456a2ba: 
1:456a2ba: import java.io.DataInput;
1:456a2ba: import java.io.DataOutput;
1:456a2ba: import java.io.IOException;
1:456a2ba: import java.io.PrintWriter;
1:456a2ba: import java.util.Arrays;
1:456a2ba: import java.util.Iterator;
1:456a2ba: import java.util.Map;
1:456a2ba: import java.util.NoSuchElementException;
1:456a2ba: import java.util.Map.Entry;
1:456a2ba: 
1:1aab71b: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex.Prefixer;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Page;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1:456a2ba: 
1:456a2ba: 
1:456a2ba: /**
1:456a2ba:  * The BTreeNode class represents a node in the BTree object graph.  It is stored in 
1:456a2ba:  * one Page of a PageFile.
1:456a2ba:  */
1:456a2ba: public final class BTreeNode<Key,Value> {
1:456a2ba: 
1:456a2ba:     // The index that this node is part of.
1:456a2ba:     private final BTreeIndex<Key,Value> index;
1:456a2ba:     // The parent node or null if this is the root node of the BTree
1:456a2ba:     private BTreeNode<Key,Value> parent;
1:456a2ba:     // The page associated with this node
1:456a2ba:     private Page<BTreeNode<Key,Value>> page;
1:456a2ba:     
1:456a2ba:     // Order list of keys in the node
1:456a2ba:     private Key[] keys;
1:456a2ba:     // Values associated with the Keys. Null if this is a branch node.
1:456a2ba:     private Value[] values;
1:456a2ba:     // nodeId pointers to children BTreeNodes. Null if this is a leaf node.
1:456a2ba:     private long[] children;
1:456a2ba:     // The next leaf node after this one.  Used for fast iteration of the entries.
1:456a2ba:     private long next = -1;
1:456a2ba:     
1:456a2ba:     private final class KeyValueEntry implements Map.Entry<Key, Value> {
1:456a2ba:         private final Key key;
1:456a2ba:         private final Value value;
1:456a2ba: 
1:456a2ba:         public KeyValueEntry(Key key, Value value) {
1:456a2ba:             this.key = key;
1:456a2ba:             this.value = value;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public Key getKey() {
1:456a2ba:             return key;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public Value getValue() {
1:456a2ba:             return value;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public Value setValue(Value value) {
1:456a2ba:             throw new UnsupportedOperationException();
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private final class BTreeIterator implements Iterator<Map.Entry<Key, Value>> {
1:456a2ba:         
1:456a2ba:         private final Transaction tx;
1:54e2e3b:         private final Key endKey;
1:456a2ba:         BTreeNode<Key,Value> current;
1:456a2ba:         int nextIndex;
1:456a2ba:         Map.Entry<Key,Value> nextEntry;
1:456a2ba: 
1:54e2e3b:         private BTreeIterator(Transaction tx, BTreeNode<Key, Value> current, int nextIndex, Key endKey) {
1:456a2ba:             this.tx = tx;
1:456a2ba:             this.current = current;
1:456a2ba:             this.nextIndex=nextIndex;
1:54e2e3b:             this.endKey = endKey;
1:54e2e3b:             if (endKey != null && endKey.equals(0l)) {
1:54e2e3b:                 Thread.dumpStack();
1:54e2e3b:             }
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         synchronized private void findNextPage() {
1:456a2ba:             if( nextEntry!=null ) {
1:456a2ba:                 return;
1:456a2ba:             }
1:456a2ba:             
1:456a2ba:             try {
1:456a2ba:                 while( current!=null ) {
1:456a2ba:                     if( nextIndex >= current.keys.length ) {
1:456a2ba:                         // we need to roll to the next leaf..
1:456a2ba:                         if( current.next >= 0 ) {
1:456a2ba:                             current = index.loadNode(tx, current.next, null);
1:9ae4119:                             assert !current.isBranch() : "Should have linked to the next leaf node.";
1:456a2ba:                             nextIndex=0;
1:456a2ba:                         } else {
1:456a2ba:                             break;
1:456a2ba:                         }
1:456a2ba:                     }  else {
1:54e2e3b:                         if (endKey != null && current.keys[nextIndex].equals(endKey)) {
1:54e2e3b:                             break;
1:54e2e3b:                         }
1:456a2ba:                         nextEntry = new KeyValueEntry(current.keys[nextIndex], current.values[nextIndex]);
1:456a2ba:                         nextIndex++;
1:456a2ba:                         break;
1:456a2ba:                     }
1:456a2ba:                     
1:456a2ba:                 }
1:456a2ba:             } catch (IOException e) {
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public boolean hasNext() {
1:456a2ba:             findNextPage();
1:456a2ba:             return nextEntry !=null;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public Entry<Key, Value> next() {
1:456a2ba:             findNextPage(); 
1:456a2ba:             if( nextEntry !=null ) {
1:456a2ba:                 Entry<Key, Value> lastEntry = nextEntry;
1:456a2ba:                 nextEntry=null;
1:456a2ba:                 return lastEntry;
1:456a2ba:             } else {
1:456a2ba:                 throw new NoSuchElementException();
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public void remove() {
1:456a2ba:             throw new UnsupportedOperationException();
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * The Marshaller is used to store and load the data in the BTreeNode into a Page.
1:456a2ba:      *  
1:456a2ba:      * @param <Key>
1:456a2ba:      * @param <Value>
1:456a2ba:      */
1:e22a37a:     static public class Marshaller<Key,Value> extends VariableMarshaller<BTreeNode<Key,Value>> {
1:456a2ba:         private final BTreeIndex<Key,Value> index;
1:456a2ba:         
1:456a2ba:         public Marshaller(BTreeIndex<Key,Value> index) {
1:456a2ba:             this.index = index;
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         public void writePayload(BTreeNode<Key,Value> node, DataOutput os) throws IOException {
1:456a2ba:             // Write the keys
1:456a2ba:             short count = (short)node.keys.length; // cast may truncate value...
1:456a2ba:             if( count != node.keys.length ) {
1:456a2ba:                 throw new IOException("Too many keys");
1:456a2ba:             }
1:456a2ba:             
1:456a2ba:             os.writeShort(count);
1:456a2ba:             for (int i = 0; i < node.keys.length; i++) {
1:456a2ba:                 index.getKeyMarshaller().writePayload(node.keys[i], os);
1:456a2ba:             }
1:456a2ba:             
1:456a2ba:             if( node.isBranch() ) {
1:456a2ba:                 // If this is a branch...
1:456a2ba:                 os.writeBoolean(true);
1:456a2ba:                 for (int i = 0; i < count+1; i++) {
1:456a2ba:                     os.writeLong(node.children[i]);
1:456a2ba:                 }
1:456a2ba:                 
1:456a2ba:             } else {
1:456a2ba:                 // If this is a leaf
1:456a2ba:                 os.writeBoolean(false);
1:456a2ba:                 for (int i = 0; i < count; i++) {
1:456a2ba:                     index.getValueMarshaller().writePayload(node.values[i], os);
1:456a2ba:                 }
1:456a2ba:                 os.writeLong(node.next);
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         @SuppressWarnings("unchecked")
1:456a2ba:         public BTreeNode<Key,Value> readPayload(DataInput is) throws IOException {
1:456a2ba:             BTreeNode<Key,Value>  node = new BTreeNode<Key,Value>(index);
1:456a2ba:             int count = is.readShort();
1:456a2ba:             
1:456a2ba:             node.keys = (Key[])new Object[count];
1:456a2ba:             for (int i = 0; i < count; i++) {
1:456a2ba:                 node.keys[i] = index.getKeyMarshaller().readPayload(is);
1:456a2ba:             }
1:456a2ba:             
1:456a2ba:             if( is.readBoolean() ) {
1:456a2ba:                 node.children = new long[count+1];
1:456a2ba:                 for (int i = 0; i < count+1; i++) {
1:456a2ba:                     node.children[i] = is.readLong();
1:456a2ba:                 }
1:456a2ba:             } else {
1:456a2ba:                 node.values = (Value[])new Object[count];
1:456a2ba:                 for (int i = 0; i < count; i++) {
1:456a2ba:                     node.values[i] = index.getValueMarshaller().readPayload(is);
1:456a2ba:                 }
1:456a2ba:                 node.next = is.readLong();
1:456a2ba:             }
1:456a2ba:             return node;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public BTreeNode(BTreeIndex<Key,Value> index) {
1:456a2ba:         this.index = index;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     public void setEmpty() {
1:456a2ba:         setLeafData(createKeyArray(0), createValueArray(0));
1:456a2ba:     }
1:456a2ba:     
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Internal (to the BTreeNode) method. Because this method is called only by
1:456a2ba:      * BTreeNode itself, no synchronization done inside of this method.
1:456a2ba:      * @throws IOException 
1:456a2ba:      */
1:456a2ba:     private BTreeNode<Key,Value> getChild(Transaction tx, int idx) throws IOException {
1:456a2ba:         if (isBranch() && idx >= 0 && idx < children.length) {
1:456a2ba:             BTreeNode<Key, Value> result = this.index.loadNode(tx, children[idx], this);
1:456a2ba:             return result;
1:456a2ba:         } else {
2:456a2ba:             return null;
1:456a2ba:         }
1:456a2ba:     }
1:9ae4119: 
1:9ae4119: 
1:9ae4119:     /**
1:9ae4119:      * Returns the right most leaf from the current btree graph.
1:9ae4119:      * @throws IOException
1:9ae4119:      */
1:9ae4119:     private BTreeNode<Key,Value> getRightLeaf(Transaction tx) throws IOException {
1:9ae4119:         BTreeNode<Key,Value> cur = this;
1:9ae4119:         while(cur.isBranch()) {
1:d93ef2a:             cur = cur.getChild(tx, cur.keys.length);
1:9ae4119:         }
1:9ae4119:         return cur;
1:9ae4119:     }
1:9ae4119: 
1:9ae4119:     /**
1:9ae4119:      * Returns the left most leaf from the current btree graph.
1:9ae4119:      * @throws IOException
1:9ae4119:      */
1:9ae4119:     private BTreeNode<Key,Value> getLeftLeaf(Transaction tx) throws IOException {
1:9ae4119:         BTreeNode<Key,Value> cur = this;
1:9ae4119:         while(cur.isBranch()) {
1:9ae4119:             cur = cur.getChild(tx, 0);
1:9ae4119:         }
1:9ae4119:         return cur;
1:9ae4119:     }
1:9ae4119: 
1:9ae4119:     /**
1:9ae4119:      * Returns the left most leaf from the current btree graph.
1:9ae4119:      * @throws IOException
1:9ae4119:      */
1:9ae4119:     private BTreeNode<Key,Value> getLeftPeer(Transaction tx, BTreeNode<Key,Value> x) throws IOException {
1:9ae4119:         BTreeNode<Key,Value> cur = x;
1:9ae4119:         while( cur.parent !=null ) {
1:9ae4119:             if( cur.parent.children[0] == cur.getPageId() ) {
1:9ae4119:                 cur = cur.parent;
1:9ae4119:             } else {
1:9ae4119:                 for( int i=0; i < cur.parent.children.length; i ++) {
1:9ae4119:                     if( cur.parent.children[i]==cur.getPageId() ) {
1:9ae4119:                         return  cur.parent.getChild(tx, i-1);
1:9ae4119:                     }
1:9ae4119:                 }
1:9ae4119:                 throw new AssertionError("page "+x+" was decendent of "+cur.getPageId());
1:9ae4119:             }
1:9ae4119:         }
1:9ae4119:         return null;
1:9ae4119:     }
1:9ae4119: 
1:456a2ba:     public Value remove(Transaction tx, Key key) throws IOException {
1:456a2ba: 
1:456a2ba:         if(isBranch()) {
1:456a2ba:             int idx = Arrays.binarySearch(keys, key);
1:456a2ba:             idx = idx < 0 ? -(idx + 1) : idx + 1;
1:456a2ba:             BTreeNode<Key, Value> child = getChild(tx, idx);
1:456a2ba:             if( child.getPageId() == index.getPageId() ) {
1:8e60ca9:                 throw new IOException("BTree corrupted: Cycle detected.");
1:456a2ba:             }
1:456a2ba:             Value rc = child.remove(tx, key);
1:456a2ba:             
1:456a2ba:             // child node is now empty.. remove it from the branch node.
1:456a2ba:             if( child.keys.length == 0 ) {
1:456a2ba:                 
1:456a2ba:                 // If the child node is a branch, promote
1:456a2ba:                 if( child.isBranch() ) {
1:456a2ba:                     // This is cause branches are never really empty.. they just go down to 1 child..
1:456a2ba:                     children[idx] = child.children[0];
1:47ee52e:                     tx.free(child.getPage());
1:456a2ba:                 } else {
1:456a2ba:                     
1:456a2ba:                     // The child was a leaf. Then we need to actually remove it from this branch node..
1:9ae4119:                     // and relink the previous leaf to skip to the next leaf.
1:456a2ba: 
1:9ae4119:                     BTreeNode<Key, Value> previousLeaf = null;
1:9ae4119:                     if( idx > 0 ) {
1:9ae4119:                         // easy if we this node hold the previous child.
1:9ae4119:                         previousLeaf = getChild(tx, idx-1).getRightLeaf(tx);
1:9ae4119:                     } else {
1:9ae4119:                         // less easy if we need to go to the parent to find the previous child.
1:9ae4119:                         BTreeNode<Key, Value> lp = getLeftPeer(tx, this);
1:9ae4119:                         if( lp!=null ) {
1:9ae4119:                             previousLeaf = lp.getRightLeaf(tx);
1:9ae4119:                         }
1:9ae4119:                         // lp will be null if there was no previous child.
1:456a2ba:                     }
1:9ae4119: 
1:9ae4119:                     if( previousLeaf !=null ) {
1:9ae4119:                         previousLeaf.next = child.next;
1:9ae4119:                         index.storeNode(tx, previousLeaf, true);
1:9ae4119:                     }
1:9ae4119: 
1:456a2ba:                     if( idx < children.length-1 ) {
1:456a2ba:                         // Delete it and key to the right.
1:456a2ba:                         setBranchData(arrayDelete(keys, idx), arrayDelete(children, idx));
1:456a2ba:                     } else {
1:456a2ba:                         // It was the last child.. Then delete it and key to the left
1:456a2ba:                         setBranchData(arrayDelete(keys, idx-1), arrayDelete(children, idx));
1:456a2ba:                     }
1:456a2ba:                     
1:456a2ba:                     // If we are the root node, and only have 1 child left.  Then 
1:456a2ba:                     // make the root be the leaf node.
1:456a2ba:                     if( children.length == 1 && parent==null ) {
1:456a2ba:                         child = getChild(tx, 0);
1:456a2ba:                         keys = child.keys;
1:456a2ba:                         children = child.children;
1:456a2ba:                         values = child.values;
1:456a2ba:                         // free up the page..
1:456a2ba:                         tx.free(child.getPage());
1:456a2ba:                     }
1:456a2ba:                     
1:456a2ba:                 }
1:456a2ba:                 index.storeNode(tx, this, true);
1:456a2ba:             }
1:456a2ba:             
1:456a2ba:             return rc;
1:456a2ba:         } else {
1:456a2ba:             int idx = Arrays.binarySearch(keys, key);
1:456a2ba:             if (idx < 0) {
1:456a2ba:                 return null;
1:456a2ba:             } else {
1:456a2ba:                 Value oldValue = values[idx];
1:456a2ba:                 setLeafData(arrayDelete(keys, idx), arrayDelete(values, idx));
1:456a2ba:                 
1:456a2ba:                 if( keys.length==0 && parent!=null) {
1:456a2ba:                     tx.free(getPage());
1:456a2ba:                 } else {
1:456a2ba:                     index.storeNode(tx, this, true);
1:456a2ba:                 }
1:456a2ba:                 
1:456a2ba:                 return oldValue;
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public Value put(Transaction tx, Key key, Value value) throws IOException {
1:456a2ba:         if (key == null) {
1:456a2ba:             throw new IllegalArgumentException("Key cannot be null");
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             return getLeafNode(tx, this, key).put(tx, key, value);
1:456a2ba:         } else {
1:456a2ba:             int idx = Arrays.binarySearch(keys, key);
1:456a2ba:             
1:456a2ba:             Value oldValue=null;
1:456a2ba:             if (idx >= 0) {
1:456a2ba:                 // Key was found... Overwrite
1:456a2ba:                 oldValue = values[idx];
1:456a2ba:                 values[idx] = value;
1:456a2ba:                 setLeafData(keys, values);
1:456a2ba:             } else {
1:456a2ba:                 // Key was not found, Insert it
1:456a2ba:                 idx = -(idx + 1);
1:456a2ba:                 setLeafData(arrayInsert(keys, key, idx), arrayInsert(values, value, idx));
1:456a2ba:             }
1:456a2ba:             
1:456a2ba:             try {
1:456a2ba:                 index.storeNode(tx, this, allowOverflow());
1:456a2ba:             } catch ( Transaction.PageOverflowIOException e ) {
1:456a2ba:                 // If we get an overflow 
1:456a2ba:                 split(tx);
1:456a2ba:             }
1:456a2ba:             
1:456a2ba:             return oldValue;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     private void promoteValue(Transaction tx, Key key, long nodeId) throws IOException {
1:456a2ba: 
1:456a2ba:         int idx = Arrays.binarySearch(keys, key);
1:456a2ba:         idx = idx < 0 ? -(idx + 1) : idx + 1;
1:456a2ba:         setBranchData(arrayInsert(keys, key, idx), arrayInsert(children, nodeId, idx + 1));
1:456a2ba: 
1:456a2ba:         try {
1:456a2ba:             index.storeNode(tx, this, allowOverflow());
1:456a2ba:         } catch ( Transaction.PageOverflowIOException e ) {
1:456a2ba:             split(tx);
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     /**
1:456a2ba:      * Internal to the BTreeNode method
1:456a2ba:      */
1:456a2ba:     private void split(Transaction tx) throws IOException {
1:456a2ba:         Key[] leftKeys;
1:456a2ba:         Key[] rightKeys;
1:456a2ba:         Value[] leftValues=null;
1:456a2ba:         Value[] rightValues=null;
1:456a2ba:         long[] leftChildren=null;
1:456a2ba:         long[] rightChildren=null;
1:456a2ba:         Key separator;
1:456a2ba: 
1:456a2ba:         int vc = keys.length;
1:456a2ba:         int pivot = vc / 2;
1:456a2ba: 
1:456a2ba:         // Split the node into two nodes
1:456a2ba:         if( isBranch() ) {
1:456a2ba: 
1:456a2ba:             leftKeys = createKeyArray(pivot);
1:456a2ba:             leftChildren = new long[leftKeys.length + 1];
1:456a2ba:             rightKeys = createKeyArray(vc - (pivot + 1));
1:456a2ba:             rightChildren = new long[rightKeys.length + 1];
1:456a2ba: 
1:456a2ba:             System.arraycopy(keys, 0, leftKeys, 0, leftKeys.length);
1:456a2ba:             System.arraycopy(children, 0, leftChildren, 0, leftChildren.length);
1:456a2ba:             System.arraycopy(keys, leftKeys.length + 1, rightKeys, 0, rightKeys.length);
1:456a2ba:             System.arraycopy(children, leftChildren.length, rightChildren, 0, rightChildren.length);
1:456a2ba: 
1:456a2ba:             // Is it a Simple Prefix BTree??
1:456a2ba:             Prefixer<Key> prefixer = index.getPrefixer();
1:456a2ba:             if(prefixer!=null) {
1:456a2ba:                 separator = prefixer.getSimplePrefix(leftKeys[leftKeys.length - 1], rightKeys[0]);
1:456a2ba:             } else {
1:456a2ba:                 separator = keys[leftKeys.length];
1:456a2ba:             }
1:456a2ba:                 
1:456a2ba:             
1:456a2ba:         } else {
1:456a2ba: 
1:456a2ba:             leftKeys = createKeyArray(pivot);
1:456a2ba:             leftValues = createValueArray(leftKeys.length);
1:456a2ba:             rightKeys = createKeyArray(vc - pivot);
1:456a2ba:             rightValues = createValueArray(rightKeys.length);
1:456a2ba: 
1:456a2ba:             System.arraycopy(keys, 0, leftKeys, 0, leftKeys.length);
1:456a2ba:             System.arraycopy(values, 0, leftValues, 0, leftValues.length);
1:456a2ba:             System.arraycopy(keys, leftKeys.length, rightKeys, 0, rightKeys.length);
1:456a2ba:             System.arraycopy(values, leftValues.length, rightValues, 0, rightValues.length);
1:456a2ba: 
1:456a2ba:             // separator = getSeparator(leftVals[leftVals.length - 1],
1:456a2ba:             // rightVals[0]);
1:456a2ba:             separator = rightKeys[0];
1:456a2ba: 
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         // Promote the pivot to the parent branch
1:456a2ba:         if (parent == null) {
1:456a2ba:             
1:456a2ba:             // This can only happen if this is the root
1:456a2ba:             BTreeNode<Key,Value> rNode = this.index.createNode(tx, this);
1:456a2ba:             BTreeNode<Key,Value> lNode = this.index.createNode(tx, this);
1:456a2ba: 
1:456a2ba:             if( isBranch() ) {
1:456a2ba:                 rNode.setBranchData(rightKeys, rightChildren);
1:456a2ba:                 lNode.setBranchData(leftKeys, leftChildren);
1:456a2ba:             } else {
1:456a2ba:                 rNode.setLeafData(rightKeys, rightValues);
1:456a2ba:                 lNode.setLeafData(leftKeys, leftValues);
1:456a2ba:                 lNode.setNext(rNode.getPageId());
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             Key[] v = createKeyArray(1);
1:456a2ba:             v[0]=separator;
1:456a2ba:             setBranchData(v, new long[] { lNode.getPageId(), rNode.getPageId() });
1:456a2ba: 
1:456a2ba:             index.storeNode(tx, this, true);
1:456a2ba:             index.storeNode(tx, rNode, true);
1:456a2ba:             index.storeNode(tx, lNode, true);
1:456a2ba:             
1:456a2ba:         } else {
1:456a2ba:             BTreeNode<Key,Value> rNode = this.index.createNode(tx, parent);
1:456a2ba:             
1:456a2ba:             if( isBranch() ) {
1:456a2ba:                 setBranchData(leftKeys, leftChildren);
1:456a2ba:                 rNode.setBranchData(rightKeys, rightChildren);
1:456a2ba:             } else {
1:456a2ba:                 rNode.setNext(next);
1:456a2ba:                 next = rNode.getPageId();
1:456a2ba:                 setLeafData(leftKeys, leftValues);
1:456a2ba:                 rNode.setLeafData(rightKeys, rightValues);
1:456a2ba:             }
1:456a2ba: 
1:456a2ba:             index.storeNode(tx, this, true);
1:456a2ba:             index.storeNode(tx, rNode, true);
1:456a2ba:             parent.promoteValue(tx, separator, rNode.getPageId());
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public void printStructure(Transaction tx, PrintWriter out, String prefix) throws IOException {
1:456a2ba:         if( prefix.length()>0 && parent == null ) {
1:456a2ba:             throw new IllegalStateException("Cycle back to root node detected.");
1:456a2ba:         }
1:8e60ca9:         if (parent == null) {
1:8e60ca9:             prefix += "|";
1:8e60ca9:             out.println(prefix + getPageId());
1:456a2ba:         }
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             for(int i=0 ; i < children.length; i++) {
1:456a2ba:                 BTreeNode<Key, Value> child = getChild(tx, i);
1:456a2ba:                 if( i == children.length-1) {
1:456a2ba:                     out.println(prefix+"\\- "+child.getPageId()+(child.isBranch()?" ("+child.children.length+")":""));
1:456a2ba:                     child.printStructure(tx, out, prefix+"   ");
1:456a2ba:                 } else {
1:456a2ba:                     out.println(prefix+"|- "+child.getPageId()+(child.isBranch()?" ("+child.children.length+")":"")+" : "+keys[i]);
1:456a2ba:                     child.printStructure(tx, out, prefix+"   ");
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     
1:456a2ba:     public int getMinLeafDepth(Transaction tx, int depth) throws IOException {
1:456a2ba:         depth++;
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             int min = Integer.MAX_VALUE;
1:456a2ba:             for(int i=0 ; i < children.length; i++) {
1:456a2ba:                 min = Math.min(min, getChild(tx, i).getMinLeafDepth(tx, depth));
1:456a2ba:             }
1:456a2ba:             return min;
1:456a2ba:         } else {
1:456a2ba: //            print(depth*2, "- "+page.getPageId());
1:456a2ba:             return depth;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public int getMaxLeafDepth(Transaction tx, int depth) throws IOException {
1:456a2ba:         depth++;
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             int v = 0;
1:456a2ba:             for(int i=0 ; i < children.length; i++) {
1:456a2ba:                 v = Math.max(v, getChild(tx, i).getMaxLeafDepth(tx, depth));
1:456a2ba:             }
1:456a2ba:             depth = v;
1:456a2ba:         } 
1:456a2ba:         return depth;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public Value get(Transaction tx, Key key) throws IOException {
1:456a2ba:         if (key == null) {
1:456a2ba:             throw new IllegalArgumentException("Key cannot be null");
1:456a2ba:         }
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             return getLeafNode(tx, this, key).get(tx, key);
1:456a2ba:         } else {
1:456a2ba:             int idx = Arrays.binarySearch(keys, key);
1:456a2ba:             if (idx < 0) {
1:456a2ba:                 return null;
1:456a2ba:             } else {
1:456a2ba:                 return values[idx];
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba:     
1:a33d668:     public boolean isEmpty(final Transaction tx) throws IOException {
1:a33d668:         return keys.length==0;
1:a33d668:     }
1:a33d668: 
1:456a2ba:     public void visit(Transaction tx, BTreeVisitor<Key, Value> visitor) throws IOException {
1:456a2ba:         if (visitor == null) {
1:456a2ba:             throw new IllegalArgumentException("Visitor cannot be null");
1:456a2ba:         }
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             for(int i=0; i < this.children.length; i++) {
1:456a2ba:                 Key key1 = null;
1:456a2ba:                 if( i!=0 ) {
1:456a2ba:                     key1 = keys[i-1];
1:456a2ba:                 }
1:456a2ba:                 Key key2 = null;
1:456a2ba:                 if( i!=this.children.length-1 ) {
1:8262ef7:                     key2 = keys[i];
1:456a2ba:                 }
1:456a2ba:                 if( visitor.isInterestedInKeysBetween(key1, key2) ) {
1:456a2ba:                     BTreeNode<Key, Value> child = getChild(tx, i);
1:456a2ba:                     child.visit(tx, visitor);
1:456a2ba:                 }
1:456a2ba:             }
1:456a2ba:         } else {
1:456a2ba:             visitor.visit(Arrays.asList(keys), Arrays.asList(values));
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     public Map.Entry<Key,Value> getFirst(Transaction tx) throws IOException {
1:456a2ba:         BTreeNode<Key, Value> node = this;
1:456a2ba:         while( node .isBranch() ) {
1:456a2ba:             node = node.getChild(tx, 0);
1:456a2ba:         }
1:456a2ba:         if( node.values.length>0 ) {
1:456a2ba:             return new KeyValueEntry(node.keys[0], node.values[0]);
1:456a2ba:         } else {
1:456a2ba:             return null;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public Map.Entry<Key,Value> getLast(Transaction tx) throws IOException {
1:456a2ba:         BTreeNode<Key, Value> node = this;
1:456a2ba:         while( node.isBranch() ) {
1:456a2ba:             node = node.getChild(tx, node.children.length-1);
1:456a2ba:         }
1:456a2ba:         if( node.values.length>0 ) {
1:456a2ba:             int idx = node.values.length-1;
1:456a2ba:             return new KeyValueEntry(node.keys[idx], node.values[idx]);
1:456a2ba:         } else {
1:456a2ba:             return null;
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     public BTreeNode<Key,Value> getFirstLeafNode(Transaction tx) throws IOException {
1:456a2ba:         BTreeNode<Key, Value> node = this;
1:456a2ba:         while( node .isBranch() ) {
1:456a2ba:             node = node.getChild(tx, 0);
1:456a2ba:         }
1:456a2ba:         return node;
1:456a2ba:     }
1:456a2ba:     
1:54e2e3b:     public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx, Key startKey, Key endKey) throws IOException {
1:456a2ba:         if (startKey == null) {
1:456a2ba:             return iterator(tx);
1:456a2ba:         }
1:456a2ba:         if( isBranch() ) {
1:54e2e3b:             return getLeafNode(tx, this, startKey).iterator(tx, startKey, endKey);
1:456a2ba:         } else {
1:456a2ba:             int idx = Arrays.binarySearch(keys, startKey);
1:456a2ba:             if (idx < 0) {
1:456a2ba:                 idx = -(idx + 1);
1:456a2ba:             }
1:54e2e3b:             return new BTreeIterator(tx, this, idx, endKey);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx) throws IOException {
1:54e2e3b:         return new BTreeIterator(tx, getFirstLeafNode(tx), 0, null);
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     public void clear(Transaction tx) throws IOException {
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             for (int i = 0; i < children.length; i++) {
1:456a2ba:                 BTreeNode<Key, Value> node = index.loadNode(tx, children[i], this);
1:456a2ba:                 node.clear(tx);
1:456a2ba:                 tx.free(node.getPage());
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:         // Reset the root node to be a leaf.
1:456a2ba:         if( parent == null ) {
1:456a2ba:             setLeafData(createKeyArray(0), createValueArray(0));
1:456a2ba:             next=-1;
1:456a2ba:             index.storeNode(tx, this, true);
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba: 
1:456a2ba:     private static <Key,Value> BTreeNode<Key, Value> getLeafNode(Transaction tx, final BTreeNode<Key, Value> node, Key key) throws IOException {
1:456a2ba:         BTreeNode<Key, Value> current = node;
1:456a2ba:         while( true ) {
1:456a2ba:             if( current.isBranch() ) {
1:456a2ba:                 int idx = Arrays.binarySearch(current.keys, key);
1:456a2ba:                 idx = idx < 0 ? -(idx + 1) : idx + 1;
1:456a2ba:                 BTreeNode<Key, Value> child = current.getChild(tx, idx);        
1:456a2ba: 
1:456a2ba:                 // A little cycle detection for sanity's sake
1:456a2ba:                 if( child == node ) {
2:456a2ba:                     throw new IOException("BTree corrupted: Cylce detected.");
1:456a2ba:                 }
1:456a2ba:                 
1:456a2ba:                 current = child;
1:456a2ba:             } else {
1:456a2ba:                 break;
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:         return current;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public boolean contains(Transaction tx, Key key) throws IOException {
1:456a2ba:         if (key == null) {
1:456a2ba:             throw new IllegalArgumentException("Key cannot be null");
1:456a2ba:         }
1:456a2ba: 
1:456a2ba:         if( isBranch() ) {
1:456a2ba:             return getLeafNode(tx, this, key).contains(tx, key);
1:456a2ba:         } else {
1:456a2ba:             int idx = Arrays.binarySearch(keys, key);
1:456a2ba:             if (idx < 0) {
1:456a2ba:                 return false;
1:456a2ba:             } else {
1:456a2ba:                 return true;
1:456a2ba:             }
1:456a2ba:         }
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba:     // Implementation methods
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba:  
1:456a2ba: 
1:456a2ba:     private boolean allowOverflow() {
1:456a2ba:         // Only allow page overflow if there are <= 3 keys in the node.  Otherwise a split will occur on overflow
1:456a2ba:         return this.keys.length<=3;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba: 
1:456a2ba:     private void setLeafData(Key[] keys, Value[] values) {
1:456a2ba:         this.keys = keys;
1:456a2ba:         this.values = values;
1:456a2ba:         this.children = null;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     private void setBranchData(Key[] keys, long[] nodeIds) {
1:456a2ba:         this.keys = keys;
1:456a2ba:         this.children = nodeIds;
1:456a2ba:         this.values = null;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     @SuppressWarnings("unchecked")
1:456a2ba:     private Key[] createKeyArray(int size) {
1:456a2ba:         return (Key[])new Object[size];
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     @SuppressWarnings("unchecked")
1:456a2ba:     private Value[] createValueArray(int size) {
1:456a2ba:         return (Value[])new Object[size];
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     @SuppressWarnings("unchecked")
1:456a2ba:     static private <T> T[] arrayDelete(T[] vals, int idx) {
1:456a2ba:         T[] newVals = (T[])new Object[vals.length - 1];
1:456a2ba:         if (idx > 0) {
1:456a2ba:             System.arraycopy(vals, 0, newVals, 0, idx);
1:456a2ba:         }
1:456a2ba:         if (idx < newVals.length) {
1:456a2ba:             System.arraycopy(vals, idx + 1, newVals, idx, newVals.length - idx);
1:456a2ba:         }
1:456a2ba:         return newVals;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     static private long[] arrayDelete(long[] vals, int idx) {
1:456a2ba:         long[] newVals = new long[vals.length - 1];
1:456a2ba:         if (idx > 0) {
1:456a2ba:             System.arraycopy(vals, 0, newVals, 0, idx);
1:456a2ba:         }
1:456a2ba:         if (idx < newVals.length) {
1:456a2ba:             System.arraycopy(vals, idx + 1, newVals, idx, newVals.length - idx);
1:456a2ba:         }
1:456a2ba:         return newVals;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     @SuppressWarnings("unchecked")
1:456a2ba:     static private <T> T[] arrayInsert(T[] vals, T val, int idx) {
1:456a2ba:         T[] newVals = (T[])new Object[vals.length + 1];
1:456a2ba:         if (idx > 0) {
1:456a2ba:             System.arraycopy(vals, 0, newVals, 0, idx);
1:456a2ba:         }
1:456a2ba:         newVals[idx] = val;
1:456a2ba:         if (idx < vals.length) {
1:456a2ba:             System.arraycopy(vals, idx, newVals, idx + 1, vals.length - idx);
1:456a2ba:         }
1:456a2ba:         return newVals;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba: 
1:456a2ba:     static private long[] arrayInsert(long[] vals, long val, int idx) {
1:456a2ba:         
1:456a2ba:         long[] newVals = new long[vals.length + 1];
1:456a2ba:         if (idx > 0) {
1:456a2ba:             System.arraycopy(vals, 0, newVals, 0, idx);
1:456a2ba:         }
1:456a2ba:         newVals[idx] = val;
1:456a2ba:         if (idx < vals.length) {
1:456a2ba:             System.arraycopy(vals, idx, newVals, idx + 1, vals.length - idx);
1:456a2ba:         }
1:456a2ba:         return newVals;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba:     // Property Accessors
1:456a2ba:     ///////////////////////////////////////////////////////////////////
1:456a2ba:     private boolean isBranch() {
1:456a2ba:         return children!=null;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public long getPageId() {
1:456a2ba:         return page.getPageId();
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public BTreeNode<Key, Value> getParent() {
1:456a2ba:         return parent;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public void setParent(BTreeNode<Key, Value> parent) {
1:456a2ba:         this.parent = parent;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public Page<BTreeNode<Key, Value>> getPage() {
1:456a2ba:         return page;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public void setPage(Page<BTreeNode<Key, Value>> page) {
1:456a2ba:         this.page = page;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public long getNext() {
1:456a2ba:         return next;
1:456a2ba:     }
1:456a2ba: 
1:456a2ba:     public void setNext(long next) {
1:456a2ba:         this.next = next;
1:456a2ba:     }
1:456a2ba:     
1:456a2ba:     @Override
1:456a2ba:     public String toString() {
1:456a2ba:         return "[BTreeNode "+(isBranch()?"branch":"leaf")+": "+Arrays.asList(keys)+"]";
1:456a2ba:     }
1:456a2ba: 
1:456a2ba: }
1:456a2ba: 
1:456a2ba: 
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:8cdb5c2
/////////////////////////////////////////////////////////////////////////
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
1:         private final Key endKey;
1:         private BTreeIterator(Transaction tx, BTreeNode<Key, Value> current, int nextIndex, Key endKey) {
1:             this.endKey = endKey;
1:             if (endKey != null && endKey.equals(0l)) {
1:                 Thread.dumpStack();
1:             }
/////////////////////////////////////////////////////////////////////////
1:                         if (endKey != null && current.keys[nextIndex].equals(endKey)) {
0:                             System.err.println("Stopping iterator on reaching: " + endKey);
1:                             break;
1:                         }
/////////////////////////////////////////////////////////////////////////
1:     public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx, Key startKey, Key endKey) throws IOException {
1:             return getLeafNode(tx, this, startKey).iterator(tx, startKey, endKey);
1:             return new BTreeIterator(tx, this, idx, endKey);
1:         return new BTreeIterator(tx, getFirstLeafNode(tx), 0, null);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.disk.index;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex.Prefixer;
1: import org.apache.activemq.store.kahadb.disk.page.Page;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
commit:715010a
commit:d93ef2a
/////////////////////////////////////////////////////////////////////////
1:             cur = cur.getChild(tx, cur.keys.length);
commit:9ae4119
/////////////////////////////////////////////////////////////////////////
1:                             assert !current.isBranch() : "Should have linked to the next leaf node.";
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Returns the right most leaf from the current btree graph.
1:      * @throws IOException
1:      */
1:     private BTreeNode<Key,Value> getRightLeaf(Transaction tx) throws IOException {
1:         BTreeNode<Key,Value> cur = this;
1:         while(cur.isBranch()) {
0:             cur = cur.getChild(tx, keys.length);
1:         }
1:         return cur;
1:     }
1: 
1:     /**
1:      * Returns the left most leaf from the current btree graph.
1:      * @throws IOException
1:      */
1:     private BTreeNode<Key,Value> getLeftLeaf(Transaction tx) throws IOException {
1:         BTreeNode<Key,Value> cur = this;
1:         while(cur.isBranch()) {
1:             cur = cur.getChild(tx, 0);
1:         }
1:         return cur;
1:     }
1: 
1:     /**
1:      * Returns the left most leaf from the current btree graph.
1:      * @throws IOException
1:      */
1:     private BTreeNode<Key,Value> getLeftPeer(Transaction tx, BTreeNode<Key,Value> x) throws IOException {
1:         BTreeNode<Key,Value> cur = x;
1:         while( cur.parent !=null ) {
1:             if( cur.parent.children[0] == cur.getPageId() ) {
1:                 cur = cur.parent;
1:             } else {
1:                 for( int i=0; i < cur.parent.children.length; i ++) {
1:                     if( cur.parent.children[i]==cur.getPageId() ) {
1:                         return  cur.parent.getChild(tx, i-1);
1:                     }
1:                 }
1:                 throw new AssertionError("page "+x+" was decendent of "+cur.getPageId());
1:             }
1:         }
1:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     // and relink the previous leaf to skip to the next leaf.
1:                     BTreeNode<Key, Value> previousLeaf = null;
1:                     if( idx > 0 ) {
1:                         // easy if we this node hold the previous child.
1:                         previousLeaf = getChild(tx, idx-1).getRightLeaf(tx);
1:                     } else {
1:                         // less easy if we need to go to the parent to find the previous child.
1:                         BTreeNode<Key, Value> lp = getLeftPeer(tx, this);
1:                         if( lp!=null ) {
1:                             previousLeaf = lp.getRightLeaf(tx);
1:                         }
1:                         // lp will be null if there was no previous child.
1: 
1:                     if( previousLeaf !=null ) {
1:                         previousLeaf.next = child.next;
1:                         index.storeNode(tx, previousLeaf, true);
1:                     }
1: 
commit:a33d668
/////////////////////////////////////////////////////////////////////////
1:     public boolean isEmpty(final Transaction tx) throws IOException {
1:         return keys.length==0;
1:     }
1: 
commit:e22a37a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.util.VariableMarshaller;
/////////////////////////////////////////////////////////////////////////
1:     static public class Marshaller<Key,Value> extends VariableMarshaller<BTreeNode<Key,Value>> {
commit:8262ef7
/////////////////////////////////////////////////////////////////////////
1:                     key2 = keys[i];
commit:456a2ba
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.index;
1: 
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.util.Arrays;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.NoSuchElementException;
1: import java.util.Map.Entry;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.kahadb.index.BTreeIndex.Prefixer;
0: import org.apache.kahadb.page.Page;
0: import org.apache.kahadb.page.Transaction;
1: 
1: 
1: /**
1:  * The BTreeNode class represents a node in the BTree object graph.  It is stored in 
1:  * one Page of a PageFile.
1:  */
1: public final class BTreeNode<Key,Value> {
1: 
1:     // The index that this node is part of.
1:     private final BTreeIndex<Key,Value> index;
1:     // The parent node or null if this is the root node of the BTree
1:     private BTreeNode<Key,Value> parent;
1:     // The page associated with this node
1:     private Page<BTreeNode<Key,Value>> page;
1:     
1:     // Order list of keys in the node
1:     private Key[] keys;
1:     // Values associated with the Keys. Null if this is a branch node.
1:     private Value[] values;
1:     // nodeId pointers to children BTreeNodes. Null if this is a leaf node.
1:     private long[] children;
1:     // The next leaf node after this one.  Used for fast iteration of the entries.
1:     private long next = -1;
1:     
1:     private final class KeyValueEntry implements Map.Entry<Key, Value> {
1:         private final Key key;
1:         private final Value value;
1: 
1:         public KeyValueEntry(Key key, Value value) {
1:             this.key = key;
1:             this.value = value;
1:         }
1: 
1:         public Key getKey() {
1:             return key;
1:         }
1: 
1:         public Value getValue() {
1:             return value;
1:         }
1: 
1:         public Value setValue(Value value) {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:     }
1: 
1:     private final class BTreeIterator implements Iterator<Map.Entry<Key, Value>> {
1:         
1:         private final Transaction tx;
1:         BTreeNode<Key,Value> current;
1:         int nextIndex;
1:         Map.Entry<Key,Value> nextEntry;
1: 
0:         private BTreeIterator(Transaction tx, BTreeNode<Key,Value> current, int nextIndex) {
1:             this.tx = tx;
1:             this.current = current;
1:             this.nextIndex=nextIndex;
1:         }
1: 
1:         synchronized private void findNextPage() {
1:             if( nextEntry!=null ) {
1:                 return;
1:             }
1:             
1:             try {
1:                 while( current!=null ) {
1:                     if( nextIndex >= current.keys.length ) {
1:                         // we need to roll to the next leaf..
1:                         if( current.next >= 0 ) {
1:                             current = index.loadNode(tx, current.next, null);
1:                             nextIndex=0;
1:                         } else {
1:                             break;
1:                         }
1:                     }  else {
1:                         nextEntry = new KeyValueEntry(current.keys[nextIndex], current.values[nextIndex]);
1:                         nextIndex++;
1:                         break;
1:                     }
1:                     
1:                 }
1:             } catch (IOException e) {
1:             }
1:         }
1: 
1:         public boolean hasNext() {
1:             findNextPage();
1:             return nextEntry !=null;
1:         }
1: 
1:         public Entry<Key, Value> next() {
1:             findNextPage(); 
1:             if( nextEntry !=null ) {
1:                 Entry<Key, Value> lastEntry = nextEntry;
1:                 nextEntry=null;
1:                 return lastEntry;
1:             } else {
1:                 throw new NoSuchElementException();
1:             }
1:         }
1: 
1:         public void remove() {
1:             throw new UnsupportedOperationException();
1:         }
1:     }
1: 
1:     /**
1:      * The Marshaller is used to store and load the data in the BTreeNode into a Page.
1:      *  
1:      * @param <Key>
1:      * @param <Value>
1:      */
0:     static public class Marshaller<Key,Value> implements org.apache.kahadb.util.Marshaller<BTreeNode<Key,Value>> {
1:         private final BTreeIndex<Key,Value> index;
1:         
1:         public Marshaller(BTreeIndex<Key,Value> index) {
1:             this.index = index;
1:         }
1: 
0:         public Class<BTreeNode<Key,Value>> getType() {
1:             return null;
1:         }
1:         
1:         public void writePayload(BTreeNode<Key,Value> node, DataOutput os) throws IOException {
1:             // Write the keys
1:             short count = (short)node.keys.length; // cast may truncate value...
1:             if( count != node.keys.length ) {
1:                 throw new IOException("Too many keys");
1:             }
1:             
1:             os.writeShort(count);
1:             for (int i = 0; i < node.keys.length; i++) {
1:                 index.getKeyMarshaller().writePayload(node.keys[i], os);
1:             }
1:             
1:             if( node.isBranch() ) {
1:                 // If this is a branch...
1:                 os.writeBoolean(true);
1:                 for (int i = 0; i < count+1; i++) {
1:                     os.writeLong(node.children[i]);
1:                 }
1:                 
1:             } else {
1:                 // If this is a leaf
1:                 os.writeBoolean(false);
1:                 for (int i = 0; i < count; i++) {
1:                     index.getValueMarshaller().writePayload(node.values[i], os);
1:                 }
1:                 os.writeLong(node.next);
1:             }
1:         }
1: 
1:         @SuppressWarnings("unchecked")
1:         public BTreeNode<Key,Value> readPayload(DataInput is) throws IOException {
1:             BTreeNode<Key,Value>  node = new BTreeNode<Key,Value>(index);
1:             int count = is.readShort();
1:             
1:             node.keys = (Key[])new Object[count];
1:             for (int i = 0; i < count; i++) {
1:                 node.keys[i] = index.getKeyMarshaller().readPayload(is);
1:             }
1:             
1:             if( is.readBoolean() ) {
1:                 node.children = new long[count+1];
1:                 for (int i = 0; i < count+1; i++) {
1:                     node.children[i] = is.readLong();
1:                 }
1:             } else {
1:                 node.values = (Value[])new Object[count];
1:                 for (int i = 0; i < count; i++) {
1:                     node.values[i] = index.getValueMarshaller().readPayload(is);
1:                 }
1:                 node.next = is.readLong();
1:             }
1:             return node;
1:         }
1:     }
1: 
1:     public BTreeNode(BTreeIndex<Key,Value> index) {
1:         this.index = index;
1:     }
1:     
1:     public void setEmpty() {
1:         setLeafData(createKeyArray(0), createValueArray(0));
1:     }
1:     
1: 
1:     /**
1:      * Internal (to the BTreeNode) method. Because this method is called only by
1:      * BTreeNode itself, no synchronization done inside of this method.
1:      * @throws IOException 
1:      */
1:     private BTreeNode<Key,Value> getChild(Transaction tx, int idx) throws IOException {
1:         if (isBranch() && idx >= 0 && idx < children.length) {
1:             BTreeNode<Key, Value> result = this.index.loadNode(tx, children[idx], this);
1:             return result;
1:         } else {
1:             return null;
1:         }
1:     }
1:    
1:     public Value remove(Transaction tx, Key key) throws IOException {
1: 
1:         if(isBranch()) {
1:             int idx = Arrays.binarySearch(keys, key);
1:             idx = idx < 0 ? -(idx + 1) : idx + 1;
1:             BTreeNode<Key, Value> child = getChild(tx, idx);
1:             if( child.getPageId() == index.getPageId() ) {
1:                 throw new IOException("BTree corrupted: Cylce detected.");
1:             }
1:             Value rc = child.remove(tx, key);
1:             
1:             // child node is now empty.. remove it from the branch node.
1:             if( child.keys.length == 0 ) {
1:                 
1:                 // If the child node is a branch, promote
1:                 if( child.isBranch() ) {
1:                     // This is cause branches are never really empty.. they just go down to 1 child..
1:                     children[idx] = child.children[0];
1:                 } else {
1:                     
1:                     // The child was a leaf. Then we need to actually remove it from this branch node..
1: 
0:                     // We need to update the previous child's next pointer to skip over the child being removed....
0:                     if( idx > 0 && children.length > 1) {
0:                         BTreeNode<Key, Value> previousChild = getChild(tx, idx-1);
0:                         previousChild.next = child.next;
0:                         index.storeNode(tx, previousChild, true);
1:                     }
1:                     
1:                     if( idx < children.length-1 ) {
1:                         // Delete it and key to the right.
1:                         setBranchData(arrayDelete(keys, idx), arrayDelete(children, idx));
1:                     } else {
1:                         // It was the last child.. Then delete it and key to the left
1:                         setBranchData(arrayDelete(keys, idx-1), arrayDelete(children, idx));
1:                     }
1:                     
1:                     // If we are the root node, and only have 1 child left.  Then 
1:                     // make the root be the leaf node.
1:                     if( children.length == 1 && parent==null ) {
1:                         child = getChild(tx, 0);
1:                         keys = child.keys;
1:                         children = child.children;
1:                         values = child.values;
1:                         // free up the page..
1:                         tx.free(child.getPage());
1:                     }
1:                     
1:                 }
1:                 index.storeNode(tx, this, true);
1:             }
1:             
1:             return rc;
1:         } else {
1:             int idx = Arrays.binarySearch(keys, key);
1:             if (idx < 0) {
1:                 return null;
1:             } else {
1:                 Value oldValue = values[idx];
1:                 setLeafData(arrayDelete(keys, idx), arrayDelete(values, idx));
1:                 
1:                 if( keys.length==0 && parent!=null) {
1:                     tx.free(getPage());
1:                 } else {
1:                     index.storeNode(tx, this, true);
1:                 }
1:                 
1:                 return oldValue;
1:             }
1:         }
1:     }
1: 
1:     public Value put(Transaction tx, Key key, Value value) throws IOException {
1:         if (key == null) {
1:             throw new IllegalArgumentException("Key cannot be null");
1:         }
1: 
1:         if( isBranch() ) {
1:             return getLeafNode(tx, this, key).put(tx, key, value);
1:         } else {
1:             int idx = Arrays.binarySearch(keys, key);
1:             
1:             Value oldValue=null;
1:             if (idx >= 0) {
1:                 // Key was found... Overwrite
1:                 oldValue = values[idx];
1:                 values[idx] = value;
1:                 setLeafData(keys, values);
1:             } else {
1:                 // Key was not found, Insert it
1:                 idx = -(idx + 1);
1:                 setLeafData(arrayInsert(keys, key, idx), arrayInsert(values, value, idx));
1:             }
1:             
1:             try {
1:                 index.storeNode(tx, this, allowOverflow());
1:             } catch ( Transaction.PageOverflowIOException e ) {
1:                 // If we get an overflow 
1:                 split(tx);
1:             }
1:             
1:             return oldValue;
1:         }
1:     }
1: 
1:     private void promoteValue(Transaction tx, Key key, long nodeId) throws IOException {
1: 
1:         int idx = Arrays.binarySearch(keys, key);
1:         idx = idx < 0 ? -(idx + 1) : idx + 1;
1:         setBranchData(arrayInsert(keys, key, idx), arrayInsert(children, nodeId, idx + 1));
1: 
1:         try {
1:             index.storeNode(tx, this, allowOverflow());
1:         } catch ( Transaction.PageOverflowIOException e ) {
1:             split(tx);
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Internal to the BTreeNode method
1:      */
1:     private void split(Transaction tx) throws IOException {
1:         Key[] leftKeys;
1:         Key[] rightKeys;
1:         Value[] leftValues=null;
1:         Value[] rightValues=null;
1:         long[] leftChildren=null;
1:         long[] rightChildren=null;
1:         Key separator;
1: 
1:         int vc = keys.length;
1:         int pivot = vc / 2;
1: 
1:         // Split the node into two nodes
1:         if( isBranch() ) {
1: 
1:             leftKeys = createKeyArray(pivot);
1:             leftChildren = new long[leftKeys.length + 1];
1:             rightKeys = createKeyArray(vc - (pivot + 1));
1:             rightChildren = new long[rightKeys.length + 1];
1: 
1:             System.arraycopy(keys, 0, leftKeys, 0, leftKeys.length);
1:             System.arraycopy(children, 0, leftChildren, 0, leftChildren.length);
1:             System.arraycopy(keys, leftKeys.length + 1, rightKeys, 0, rightKeys.length);
1:             System.arraycopy(children, leftChildren.length, rightChildren, 0, rightChildren.length);
1: 
1:             // Is it a Simple Prefix BTree??
1:             Prefixer<Key> prefixer = index.getPrefixer();
1:             if(prefixer!=null) {
1:                 separator = prefixer.getSimplePrefix(leftKeys[leftKeys.length - 1], rightKeys[0]);
1:             } else {
1:                 separator = keys[leftKeys.length];
1:             }
1:                 
1:             
1:         } else {
1: 
1:             leftKeys = createKeyArray(pivot);
1:             leftValues = createValueArray(leftKeys.length);
1:             rightKeys = createKeyArray(vc - pivot);
1:             rightValues = createValueArray(rightKeys.length);
1: 
1:             System.arraycopy(keys, 0, leftKeys, 0, leftKeys.length);
1:             System.arraycopy(values, 0, leftValues, 0, leftValues.length);
1:             System.arraycopy(keys, leftKeys.length, rightKeys, 0, rightKeys.length);
1:             System.arraycopy(values, leftValues.length, rightValues, 0, rightValues.length);
1: 
1:             // separator = getSeparator(leftVals[leftVals.length - 1],
1:             // rightVals[0]);
1:             separator = rightKeys[0];
1: 
1:         }
1: 
1:         // Promote the pivot to the parent branch
1:         if (parent == null) {
1:             
1:             // This can only happen if this is the root
1:             BTreeNode<Key,Value> rNode = this.index.createNode(tx, this);
1:             BTreeNode<Key,Value> lNode = this.index.createNode(tx, this);
1: 
1:             if( isBranch() ) {
1:                 rNode.setBranchData(rightKeys, rightChildren);
1:                 lNode.setBranchData(leftKeys, leftChildren);
1:             } else {
1:                 rNode.setLeafData(rightKeys, rightValues);
1:                 lNode.setLeafData(leftKeys, leftValues);
1:                 lNode.setNext(rNode.getPageId());
1:             }
1: 
1:             Key[] v = createKeyArray(1);
1:             v[0]=separator;
1:             setBranchData(v, new long[] { lNode.getPageId(), rNode.getPageId() });
1: 
1:             index.storeNode(tx, this, true);
1:             index.storeNode(tx, rNode, true);
1:             index.storeNode(tx, lNode, true);
1:             
1:         } else {
1:             BTreeNode<Key,Value> rNode = this.index.createNode(tx, parent);
1:             
1:             if( isBranch() ) {
1:                 setBranchData(leftKeys, leftChildren);
1:                 rNode.setBranchData(rightKeys, rightChildren);
1:             } else {
1:                 rNode.setNext(next);
1:                 next = rNode.getPageId();
1:                 setLeafData(leftKeys, leftValues);
1:                 rNode.setLeafData(rightKeys, rightValues);
1:             }
1: 
1:             index.storeNode(tx, this, true);
1:             index.storeNode(tx, rNode, true);
1:             parent.promoteValue(tx, separator, rNode.getPageId());
1:         }
1:     }
1: 
1:     public void printStructure(Transaction tx, PrintWriter out, String prefix) throws IOException {
1:         if( prefix.length()>0 && parent == null ) {
1:             throw new IllegalStateException("Cycle back to root node detected.");
1:         }
1:         
1:         if( isBranch() ) {
1:             for(int i=0 ; i < children.length; i++) {
1:                 BTreeNode<Key, Value> child = getChild(tx, i);
1:                 if( i == children.length-1) {
1:                     out.println(prefix+"\\- "+child.getPageId()+(child.isBranch()?" ("+child.children.length+")":""));
1:                     child.printStructure(tx, out, prefix+"   ");
1:                 } else {
1:                     out.println(prefix+"|- "+child.getPageId()+(child.isBranch()?" ("+child.children.length+")":"")+" : "+keys[i]);
1:                     child.printStructure(tx, out, prefix+"   ");
1:                 }
1:             }
1:         }
1:     }
1:     
1:     
1:     public int getMinLeafDepth(Transaction tx, int depth) throws IOException {
1:         depth++;
1:         if( isBranch() ) {
1:             int min = Integer.MAX_VALUE;
1:             for(int i=0 ; i < children.length; i++) {
1:                 min = Math.min(min, getChild(tx, i).getMinLeafDepth(tx, depth));
1:             }
1:             return min;
1:         } else {
1: //            print(depth*2, "- "+page.getPageId());
1:             return depth;
1:         }
1:     }
1: 
1:     public int getMaxLeafDepth(Transaction tx, int depth) throws IOException {
1:         depth++;
1:         if( isBranch() ) {
1:             int v = 0;
1:             for(int i=0 ; i < children.length; i++) {
1:                 v = Math.max(v, getChild(tx, i).getMaxLeafDepth(tx, depth));
1:             }
1:             depth = v;
1:         } 
1:         return depth;
1:     }
1: 
1:     public Value get(Transaction tx, Key key) throws IOException {
1:         if (key == null) {
1:             throw new IllegalArgumentException("Key cannot be null");
1:         }
1:         if( isBranch() ) {
1:             return getLeafNode(tx, this, key).get(tx, key);
1:         } else {
1:             int idx = Arrays.binarySearch(keys, key);
1:             if (idx < 0) {
1:                 return null;
1:             } else {
1:                 return values[idx];
1:             }
1:         }
1:     }
1:     
1:     public void visit(Transaction tx, BTreeVisitor<Key, Value> visitor) throws IOException {
1:         if (visitor == null) {
1:             throw new IllegalArgumentException("Visitor cannot be null");
1:         }
1:         if( isBranch() ) {
1:             for(int i=0; i < this.children.length; i++) {
1:                 Key key1 = null;
1:                 if( i!=0 ) {
1:                     key1 = keys[i-1];
1:                 }
1:                 Key key2 = null;
1:                 if( i!=this.children.length-1 ) {
0:                     key1 = keys[i];
1:                 }
1:                 if( visitor.isInterestedInKeysBetween(key1, key2) ) {
1:                     BTreeNode<Key, Value> child = getChild(tx, i);
1:                     child.visit(tx, visitor);
1:                 }
1:             }
1:         } else {
1:             visitor.visit(Arrays.asList(keys), Arrays.asList(values));
1:         }
1:     }
1:     
1:     public Map.Entry<Key,Value> getFirst(Transaction tx) throws IOException {
1:         BTreeNode<Key, Value> node = this;
1:         while( node .isBranch() ) {
1:             node = node.getChild(tx, 0);
1:         }
1:         if( node.values.length>0 ) {
1:             return new KeyValueEntry(node.keys[0], node.values[0]);
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     public Map.Entry<Key,Value> getLast(Transaction tx) throws IOException {
1:         BTreeNode<Key, Value> node = this;
1:         while( node.isBranch() ) {
1:             node = node.getChild(tx, node.children.length-1);
1:         }
1:         if( node.values.length>0 ) {
1:             int idx = node.values.length-1;
1:             return new KeyValueEntry(node.keys[idx], node.values[idx]);
1:         } else {
1:             return null;
1:         }
1:     }
1:     
1:     public BTreeNode<Key,Value> getFirstLeafNode(Transaction tx) throws IOException {
1:         BTreeNode<Key, Value> node = this;
1:         while( node .isBranch() ) {
1:             node = node.getChild(tx, 0);
1:         }
1:         return node;
1:     }
1:     
0:     public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx, Key startKey) throws IOException {
1:         if (startKey == null) {
1:             return iterator(tx);
1:         }
1:         if( isBranch() ) {
0:             return getLeafNode(tx, this, startKey).iterator(tx, startKey);
1:         } else {
1:             int idx = Arrays.binarySearch(keys, startKey);
1:             if (idx < 0) {
1:                 idx = -(idx + 1);
1:             }
0:             return new BTreeIterator(tx, this, idx);
1:         }
1:     }
1: 
1:     public Iterator<Map.Entry<Key,Value>> iterator(final Transaction tx) throws IOException {
0:         return new BTreeIterator(tx, getFirstLeafNode(tx), 0);
1:     }
1:     
1:     public void clear(Transaction tx) throws IOException {
1:         if( isBranch() ) {
1:             for (int i = 0; i < children.length; i++) {
1:                 BTreeNode<Key, Value> node = index.loadNode(tx, children[i], this);
1:                 node.clear(tx);
1:                 tx.free(node.getPage());
1:             }
1:         }
1:         // Reset the root node to be a leaf.
1:         if( parent == null ) {
1:             setLeafData(createKeyArray(0), createValueArray(0));
1:             next=-1;
1:             index.storeNode(tx, this, true);
1:         }
1:     }
1: 
1: 
1:     private static <Key,Value> BTreeNode<Key, Value> getLeafNode(Transaction tx, final BTreeNode<Key, Value> node, Key key) throws IOException {
1:         BTreeNode<Key, Value> current = node;
1:         while( true ) {
1:             if( current.isBranch() ) {
1:                 int idx = Arrays.binarySearch(current.keys, key);
1:                 idx = idx < 0 ? -(idx + 1) : idx + 1;
1:                 BTreeNode<Key, Value> child = current.getChild(tx, idx);        
1: 
1:                 // A little cycle detection for sanity's sake
1:                 if( child == node ) {
1:                     throw new IOException("BTree corrupted: Cylce detected.");
1:                 }
1:                 
1:                 current = child;
1:             } else {
1:                 break;
1:             }
1:         }
1:         return current;
1:     }
1: 
1:     public boolean contains(Transaction tx, Key key) throws IOException {
1:         if (key == null) {
1:             throw new IllegalArgumentException("Key cannot be null");
1:         }
1: 
1:         if( isBranch() ) {
1:             return getLeafNode(tx, this, key).contains(tx, key);
1:         } else {
1:             int idx = Arrays.binarySearch(keys, key);
1:             if (idx < 0) {
1:                 return false;
1:             } else {
1:                 return true;
1:             }
1:         }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////
1:     // Implementation methods
1:     ///////////////////////////////////////////////////////////////////
1:  
1: 
1:     private boolean allowOverflow() {
1:         // Only allow page overflow if there are <= 3 keys in the node.  Otherwise a split will occur on overflow
1:         return this.keys.length<=3;
1:     }
1: 
1: 
1:     private void setLeafData(Key[] keys, Value[] values) {
1:         this.keys = keys;
1:         this.values = values;
1:         this.children = null;
1:     }
1:     
1:     private void setBranchData(Key[] keys, long[] nodeIds) {
1:         this.keys = keys;
1:         this.children = nodeIds;
1:         this.values = null;
1:     }
1: 
1:     @SuppressWarnings("unchecked")
1:     private Key[] createKeyArray(int size) {
1:         return (Key[])new Object[size];
1:     }
1: 
1:     @SuppressWarnings("unchecked")
1:     private Value[] createValueArray(int size) {
1:         return (Value[])new Object[size];
1:     }
1:     
1:     @SuppressWarnings("unchecked")
1:     static private <T> T[] arrayDelete(T[] vals, int idx) {
1:         T[] newVals = (T[])new Object[vals.length - 1];
1:         if (idx > 0) {
1:             System.arraycopy(vals, 0, newVals, 0, idx);
1:         }
1:         if (idx < newVals.length) {
1:             System.arraycopy(vals, idx + 1, newVals, idx, newVals.length - idx);
1:         }
1:         return newVals;
1:     }
1:     
1:     static private long[] arrayDelete(long[] vals, int idx) {
1:         long[] newVals = new long[vals.length - 1];
1:         if (idx > 0) {
1:             System.arraycopy(vals, 0, newVals, 0, idx);
1:         }
1:         if (idx < newVals.length) {
1:             System.arraycopy(vals, idx + 1, newVals, idx, newVals.length - idx);
1:         }
1:         return newVals;
1:     }
1: 
1:     @SuppressWarnings("unchecked")
1:     static private <T> T[] arrayInsert(T[] vals, T val, int idx) {
1:         T[] newVals = (T[])new Object[vals.length + 1];
1:         if (idx > 0) {
1:             System.arraycopy(vals, 0, newVals, 0, idx);
1:         }
1:         newVals[idx] = val;
1:         if (idx < vals.length) {
1:             System.arraycopy(vals, idx, newVals, idx + 1, vals.length - idx);
1:         }
1:         return newVals;
1:     }
1: 
1: 
1:     static private long[] arrayInsert(long[] vals, long val, int idx) {
1:         
1:         long[] newVals = new long[vals.length + 1];
1:         if (idx > 0) {
1:             System.arraycopy(vals, 0, newVals, 0, idx);
1:         }
1:         newVals[idx] = val;
1:         if (idx < vals.length) {
1:             System.arraycopy(vals, idx, newVals, idx + 1, vals.length - idx);
1:         }
1:         return newVals;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////
1:     // Property Accessors
1:     ///////////////////////////////////////////////////////////////////
1:     private boolean isBranch() {
1:         return children!=null;
1:     }
1: 
1:     public long getPageId() {
1:         return page.getPageId();
1:     }
1: 
1:     public BTreeNode<Key, Value> getParent() {
1:         return parent;
1:     }
1: 
1:     public void setParent(BTreeNode<Key, Value> parent) {
1:         this.parent = parent;
1:     }
1: 
1:     public Page<BTreeNode<Key, Value>> getPage() {
1:         return page;
1:     }
1: 
1:     public void setPage(Page<BTreeNode<Key, Value>> page) {
1:         this.page = page;
1:     }
1: 
1:     public long getNext() {
1:         return next;
1:     }
1: 
1:     public void setNext(long next) {
1:         this.next = next;
1:     }
1:     
1:     @Override
1:     public String toString() {
1:         return "[BTreeNode "+(isBranch()?"branch":"leaf")+": "+Arrays.asList(keys)+"]";
1:     }
1: 
1: }
1: 
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:47ee52e
/////////////////////////////////////////////////////////////////////////
0:                         // free up the page..
1:                         tx.free(child.getPage());
0:                     
commit:b24dfb9
/////////////////////////////////////////////////////////////////////////
0:                     // free up the page..
0:                     tx.free(child.getPage());
commit:8e60ca9
/////////////////////////////////////////////////////////////////////////
1:                 throw new IOException("BTree corrupted: Cycle detected.");
/////////////////////////////////////////////////////////////////////////
0:                     tx.free(child.getPage());
/////////////////////////////////////////////////////////////////////////
1:         if (parent == null) {
1:             prefix += "|";
1:             out.println(prefix + getPageId());
0:         }
============================================================================