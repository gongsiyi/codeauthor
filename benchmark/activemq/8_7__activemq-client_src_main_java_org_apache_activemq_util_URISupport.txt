1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.util;
1:f812e34: 
1:d29ca2a: import java.io.UnsupportedEncodingException;
1:d29ca2a: import java.net.URI;
1:d29ca2a: import java.net.URISyntaxException;
1:d29ca2a: import java.net.URLDecoder;
1:d29ca2a: import java.net.URLEncoder;
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.Collections;
1:d29ca2a: import java.util.HashMap;
1:ecf89a6: import java.util.List;
1:d29ca2a: import java.util.Map;
14:d29ca2a: 
1:d29ca2a: /**
1:fa40250:  * Utility class that provides methods for parsing URI's
1:b0c2a40:  *
1:de7617e:  * This class can be used to split composite URI's into their component parts and is used to extract any
1:de7617e:  * URI options from each URI in order to set specific properties on Beans.
1:d29ca2a:  */
1:d29ca2a: public class URISupport {
1:f812e34: 
1:de7617e:     /**
1:de7617e:      * A composite URI can be split into one or more CompositeData object which each represent the
1:de7617e:      * individual URIs that comprise the composite one.
1:de7617e:      */
1:d29ca2a:     public static class CompositeData {
1:ecf89a6:         private String host;
1:ecf89a6:         private String scheme;
1:ecf89a6:         private String path;
1:ecf89a6:         private URI components[];
1:ecf89a6:         private Map<String, String> parameters;
1:ecf89a6:         private String fragment;
1:d29ca2a: 
1:d29ca2a:         public URI[] getComponents() {
1:d29ca2a:             return components;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public String getFragment() {
1:d29ca2a:             return fragment;
1:d29ca2a:         }
1:f812e34: 
1:ecf89a6:         public Map<String, String> getParameters() {
1:d29ca2a:             return parameters;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public String getScheme() {
1:d29ca2a:             return scheme;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public String getPath() {
1:d29ca2a:             return path;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public String getHost() {
1:d29ca2a:             return host;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public URI toURI() throws URISyntaxException {
1:d29ca2a:             StringBuffer sb = new StringBuffer();
1:f812e34:             if (scheme != null) {
1:d29ca2a:                 sb.append(scheme);
1:d29ca2a:                 sb.append(':');
1:d29ca2a:             }
1:f812e34: 
1:f812e34:             if (host != null && host.length() != 0) {
1:d29ca2a:                 sb.append(host);
1:d29ca2a:             } else {
1:d29ca2a:                 sb.append('(');
1:d29ca2a:                 for (int i = 0; i < components.length; i++) {
1:fc00993:                     if (i != 0) {
1:d29ca2a:                         sb.append(',');
1:fc00993:                     }
1:d29ca2a:                     sb.append(components[i].toString());
1:d29ca2a:                 }
1:d29ca2a:                 sb.append(')');
1:d29ca2a:             }
1:f812e34: 
1:f812e34:             if (path != null) {
1:d29ca2a:                 sb.append('/');
1:d29ca2a:                 sb.append(path);
1:d29ca2a:             }
1:f812e34:             if (!parameters.isEmpty()) {
1:d29ca2a:                 sb.append("?");
1:d29ca2a:                 sb.append(createQueryString(parameters));
1:d29ca2a:             }
1:f812e34:             if (fragment != null) {
1:d29ca2a:                 sb.append("#");
1:d29ca2a:                 sb.append(fragment);
1:d29ca2a:             }
1:d29ca2a:             return new URI(sb.toString());
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:de7617e:     /**
1:de7617e:      * Give a URI break off any URI options and store them in a Key / Value Mapping.
1:f812e34:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The URI whose query should be extracted and processed.
1:d29ca2a:      *
1:de7617e:      * @return A Mapping of the URI options.
1:f812e34:      * @throws URISyntaxException
1:de7617e:      */
1:ecf89a6:     public static Map<String, String> parseQuery(String uri) throws URISyntaxException {
1:f812e34:         try {
1:3a6a56c:             uri = uri.substring(uri.lastIndexOf("?") + 1); // get only the relevant part of the query
1:ecf89a6:             Map<String, String> rc = new HashMap<String, String>();
1:fa40250:             if (uri != null && !uri.isEmpty()) {
1:f812e34:                 String[] parameters = uri.split("&");
1:f812e34:                 for (int i = 0; i < parameters.length; i++) {
1:f812e34:                     int p = parameters[i].indexOf("=");
1:f812e34:                     if (p >= 0) {
1:f812e34:                         String name = URLDecoder.decode(parameters[i].substring(0, p), "UTF-8");
1:f812e34:                         String value = URLDecoder.decode(parameters[i].substring(p + 1), "UTF-8");
1:f812e34:                         rc.put(name, value);
1:f812e34:                     } else {
1:f812e34:                         rc.put(parameters[i], null);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:             return rc;
1:f812e34:         } catch (UnsupportedEncodingException e) {
1:f812e34:             throw (URISyntaxException)new URISyntaxException(e.toString(), "Invalid encoding").initCause(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:de7617e:      * Given a URI parse and extract any URI query options and return them as a Key / Value mapping.
1:d29ca2a:      *
1:de7617e:      * This method differs from the {@link parseQuery} method in that it handles composite URI types and
1:de7617e:      * will extract the URI options from the outermost composite URI.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The URI whose query should be extracted and processed.
1:de7617e:      *
1:de7617e:      * @return A Mapping of the URI options.
1:de7617e:      * @throws URISyntaxException
1:d29ca2a:      */
1:784b93d:     public static Map<String, String> parseParameters(URI uri) throws URISyntaxException {
1:e32c1ba:         if (!isCompositeURI(uri)) {
1:933eb2f:             return uri.getQuery() == null ? emptyMap() : parseQuery(stripPrefix(uri.getQuery(), "?"));
1:e32c1ba:         } else {
1:784b93d:             CompositeData data = URISupport.parseComposite(uri);
1:784b93d:             Map<String, String> parameters = new HashMap<String, String>();
1:784b93d:             parameters.putAll(data.getParameters());
1:986ed14:             if (parameters.isEmpty()) {
1:784b93d:                 parameters = emptyMap();
1:933eb2f:             }
1:933eb2f: 
1:784b93d:             return parameters;
1:d29ca2a:         }
1:ba4a9ed:     }
1:f812e34: 
1:de7617e:     /**
1:de7617e:      * Given a Key / Value mapping create and append a URI query value that represents the mapped entries, return the
1:de7617e:      * newly updated URI that contains the value of the given URI and the appended query value.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The source URI that will have the Map entries appended as a URI query value.
1:de7617e:      * @param queryParameters
1:de7617e:      * 		The Key / Value mapping that will be transformed into a URI query string.
1:de7617e:      *
1:de7617e:      * @return A new URI value that combines the given URI and the constructed query string.
1:de7617e:      * @throws URISyntaxException
1:de7617e:      */
1:39e63c0:     public static URI applyParameters(URI uri, Map<String, String> queryParameters) throws URISyntaxException {
1:986ed14:         return applyParameters(uri, queryParameters, "");
1:986ed14:     }
1:f812e34: 
1:de7617e:     /**
1:de7617e:      * Given a Key / Value mapping create and append a URI query value that represents the mapped entries, return the
1:de7617e:      * newly updated URI that contains the value of the given URI and the appended query value.  Each entry in the query
1:de7617e:      * string is prefixed by the supplied optionPrefix string.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The source URI that will have the Map entries appended as a URI query value.
1:de7617e:      * @param queryParameters
1:de7617e:      * 		The Key / Value mapping that will be transformed into a URI query string.
1:de7617e:      * @param optionPrefix
1:de7617e:      * 		A string value that when not null or empty is used to prefix each query option key.
1:de7617e:      *
1:de7617e:      * @return A new URI value that combines the given URI and the constructed query string.
1:de7617e:      * @throws URISyntaxException
1:de7617e:      */
1:986ed14:     public static URI applyParameters(URI uri, Map<String, String> queryParameters, String optionPrefix) throws URISyntaxException {
1:39e63c0:         if (queryParameters != null && !queryParameters.isEmpty()) {
1:39e63c0:             StringBuffer newQuery = uri.getRawQuery() != null ? new StringBuffer(uri.getRawQuery()) : new StringBuffer() ;
1:39e63c0:             for ( Map.Entry<String, String> param: queryParameters.entrySet()) {
1:986ed14:                 if (param.getKey().startsWith(optionPrefix)) {
1:986ed14:                     if (newQuery.length()!=0) {
1:986ed14:                         newQuery.append('&');
1:986ed14:                     }
1:986ed14:                     final String key = param.getKey().substring(optionPrefix.length());
1:986ed14:                     newQuery.append(key).append('=').append(param.getValue());
1:986ed14:                 }
1:39e63c0:             }
1:39e63c0:             uri = createURIWithQuery(uri, newQuery.toString());
1:39e63c0:         }
1:39e63c0:         return uri;
1:39e63c0:     }
1:d29ca2a: 
1:933eb2f:     @SuppressWarnings("unchecked")
1:933eb2f:     private static Map<String, String> emptyMap() {
1:933eb2f:         return Collections.EMPTY_MAP;
1:39e63c0:     }
1:d29ca2a: 
1:de7617e:     /**
1:de7617e:      * Removes any URI query from the given uri and return a new URI that does not contain the query portion.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The URI whose query value is to be removed.
1:de7617e:      *
1:de7617e:      * @return a new URI that does not contain a query value.
1:de7617e:      * @throws URISyntaxException
1:de7617e:      */
1:d29ca2a:     public static URI removeQuery(URI uri) throws URISyntaxException {
1:d29ca2a:         return createURIWithQuery(uri, null);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:de7617e:      * Creates a URI with the given query, removing an previous query value from the given URI.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The source URI whose existing query is replaced with the newly supplied one.
1:de7617e:      * @param query
1:de7617e:      * 		The new URI query string that should be appended to the given URI.
1:de7617e:      *
1:de7617e:      * @return a new URI that is a combination of the original URI and the given query string.
1:de7617e:      * @throws URISyntaxException
1:d29ca2a:      */
1:d29ca2a:     public static URI createURIWithQuery(URI uri, String query) throws URISyntaxException {
1:c4d8bc4:         String schemeSpecificPart = uri.getRawSchemeSpecificPart();
1:c4d8bc4:         // strip existing query if any
1:c4d8bc4:         int questionMark = schemeSpecificPart.lastIndexOf("?");
1:4f9784d:         // make sure question mark is not within parentheses
1:4f9784d:         if (questionMark < schemeSpecificPart.lastIndexOf(")")) {
1:fa40250:             questionMark = -1;
1:d29ca2a:         }
1:c4d8bc4:         if (questionMark > 0) {
1:c4d8bc4:             schemeSpecificPart = schemeSpecificPart.substring(0, questionMark);
1:4f9784d:         }
1:c4d8bc4:         if (query != null && query.length() > 0) {
1:c4d8bc4:             schemeSpecificPart += "?" + query;
1:4f9784d:         }
1:c4d8bc4:         return new URI(uri.getScheme(), schemeSpecificPart, uri.getFragment());
1:c4d8bc4:     }
1:f812e34: 
1:de7617e:     /**
1:de7617e:      * Given a composite URI, parse the individual URI elements contained within that URI and return
1:de7617e:      * a CompsoteData instance that contains the parsed URI values.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The target URI that should be parsed.
1:de7617e:      *
1:de7617e:      * @return a new CompsiteData instance representing the parsed composite URI.
1:de7617e:      * @throws URISyntaxException
1:de7617e:      */
1:d29ca2a:     public static CompositeData parseComposite(URI uri) throws URISyntaxException {
1:f812e34: 
1:d29ca2a:         CompositeData rc = new CompositeData();
1:d29ca2a:         rc.scheme = uri.getScheme();
1:c008426:         String ssp = stripPrefix(uri.getRawSchemeSpecificPart().trim(), "//").trim();
1:d29ca2a: 
1:d29ca2a:         parseComposite(uri, rc, ssp);
1:f812e34: 
1:d29ca2a:         rc.fragment = uri.getFragment();
1:d29ca2a:         return rc;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:de7617e:      * Examine a URI and determine if it is a Composite type or not.
1:de7617e:      *
1:d29ca2a:      * @param uri
1:de7617e:      * 		The URI that is to be examined.
1:de7617e:      *
1:de7617e:      * @return true if the given URI is a Compsote type.
1:de7617e:      */
1:e32c1ba:     public static boolean isCompositeURI(URI uri) {
1:79bce92:         String ssp = stripPrefix(uri.getRawSchemeSpecificPart().trim(), "//").trim();
1:d29ca2a: 
1:79bce92:         if (ssp.indexOf('(') == 0 && checkParenthesis(ssp)) {
1:e32c1ba:             return true;
1:c4d8bc4:         }
1:79bce92:         return false;
3:e32c1ba:     }
1:d29ca2a: 
1:de7617e:     /**
1:de7617e:      * Given a string and a position in that string of an open parend, find the matching close parend.
1:de7617e:      *
1:de7617e:      * @param str
1:de7617e:      * 		The string to be searched for a matching parend.
1:de7617e:      * @param first
1:de7617e:      * 		The index in the string of the opening parend whose close value is to be searched.
1:de7617e:      *
1:de7617e:      * @return the index in the string where the closing parend is located.
1:de7617e:      * @throws URISyntaxException fi the string does not contain a matching parend.
1:de7617e:      */
1:ba4a9ed:     public static int indexOfParenthesisMatch(String str, int first) throws URISyntaxException {
1:ba4a9ed:         int index = -1;
1:d29ca2a: 
1:ba4a9ed:         if (first < 0 || first > str.length()) {
1:ba4a9ed:             throw new IllegalArgumentException("Invalid position for first parenthesis: " + first);
1:ba4a9ed:         }
1:d29ca2a: 
1:ba4a9ed:         if (str.charAt(first) != '(') {
1:ba4a9ed:             throw new IllegalArgumentException("character at indicated position is not a parenthesis");
1:ba4a9ed:         }
1:d29ca2a: 
1:ba4a9ed:         int depth = 1;
1:ba4a9ed:         char[] array = str.toCharArray();
1:ba4a9ed:         for (index = first + 1; index < array.length; ++index) {
1:ba4a9ed:             char current = array[index];
1:ba4a9ed:             if (current == '(') {
1:ba4a9ed:                 depth++;
1:ba4a9ed:             } else if (current == ')') {
1:ba4a9ed:                 if (--depth == 0) {
1:ba4a9ed:                     break;
1:d29ca2a:                 }
1:ba4a9ed:             }
1:ba4a9ed:         }
1:d29ca2a: 
1:ba4a9ed:         if (depth != 0) {
1:ba4a9ed:             throw new URISyntaxException(str, "URI did not contain a matching parenthesis.");
1:ba4a9ed:         }
1:d29ca2a: 
1:ba4a9ed:         return index;
1:ba4a9ed:     }
1:d29ca2a: 
1:de7617e:     /**
1:de7617e:      * Given a composite URI and a CompositeData instance and the scheme specific part extracted from the source URI,
1:de7617e:      * parse the composite URI and populate the CompositeData object with the results.  The source URI is used only
1:de7617e:      * for logging as the ssp should have already been extracted from it and passed here.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The original source URI whose ssp is parsed into the composite data.
1:d29ca2a:      * @param rc
1:de7617e:      * 		The CompsositeData instance that will be populated from the given ssp.
1:d29ca2a:      * @param ssp
1:de7617e:      * 		The scheme specific part from the original string that is a composite or one or more URIs.
1:de7617e:      *
1:d29ca2a:      * @throws URISyntaxException
1:d29ca2a:      */
1:d29ca2a:     private static void parseComposite(URI uri, CompositeData rc, String ssp) throws URISyntaxException {
1:d29ca2a:         String componentString;
1:d29ca2a:         String params;
1:f812e34: 
1:f812e34:         if (!checkParenthesis(ssp)) {
1:d29ca2a:             throw new URISyntaxException(uri.toString(), "Not a matching number of '(' and ')' parenthesis");
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         int p;
1:ba4a9ed:         int initialParen = ssp.indexOf("(");
1:ba4a9ed:         if (initialParen == 0) {
1:d29ca2a: 
1:ba4a9ed:             rc.host = ssp.substring(0, initialParen);
1:d29ca2a:             p = rc.host.indexOf("/");
1:d29ca2a: 
1:f812e34:             if (p >= 0) {
1:d29ca2a:                 rc.path = rc.host.substring(p);
1:f812e34:                 rc.host = rc.host.substring(0, p);
1:d29ca2a:             }
1:d29ca2a: 
1:ba4a9ed:             p = indexOfParenthesisMatch(ssp, initialParen);
1:ba4a9ed:             componentString = ssp.substring(initialParen + 1, p);
1:f812e34:             params = ssp.substring(p + 1).trim();
1:f812e34: 
1:d29ca2a:         } else {
1:d29ca2a:             componentString = ssp;
1:f812e34:             params = "";
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         String components[] = splitComponents(componentString);
1:f812e34:         rc.components = new URI[components.length];
1:d29ca2a:         for (int i = 0; i < components.length; i++) {
1:d29ca2a:             rc.components[i] = new URI(components[i].trim());
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         p = params.indexOf("?");
1:f812e34:         if (p >= 0) {
1:f812e34:             if (p > 0) {
1:d29ca2a:                 rc.path = stripPrefix(params.substring(0, p), "/");
1:d29ca2a:             }
1:f812e34:             rc.parameters = parseQuery(params.substring(p + 1));
1:d29ca2a:         } else {
1:fc00993:             if (params.length() > 0) {
1:d29ca2a:                 rc.path = stripPrefix(params, "/");
1:fc00993:             }
1:933eb2f:             rc.parameters = emptyMap();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:de7617e:      * Given the inner portion of a composite URI, split and return each inner URI as a string
1:de7617e:      * element in a new String array.
1:de7617e:      *
1:986ed14:      * @param str
1:de7617e:      * 		The inner URI elements of a composite URI string.
1:de7617e:      *
1:de7617e:      * @return an array containing each inner URI from the composite one.
1:d29ca2a:      */
1:d29ca2a:     private static String[] splitComponents(String str) {
1:ecf89a6:         List<String> l = new ArrayList<String>();
1:f812e34: 
1:f812e34:         int last = 0;
1:d29ca2a:         int depth = 0;
1:d29ca2a:         char chars[] = str.toCharArray();
1:f812e34:         for (int i = 0; i < chars.length; i++) {
1:f812e34:             switch (chars[i]) {
1:d29ca2a:             case '(':
1:d29ca2a:                 depth++;
1:d29ca2a:                 break;
1:d29ca2a:             case ')':
1:d29ca2a:                 depth--;
1:d29ca2a:                 break;
1:d29ca2a:             case ',':
1:f812e34:                 if (depth == 0) {
1:52aeaa2:                     String s = str.substring(last, i);
2:d29ca2a:                     l.add(s);
1:f812e34:                     last = i + 1;
1:d29ca2a:                 }
1:74a7a8b:                 break;
1:74a7a8b:             default:
1:d29ca2a:             }
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         String s = str.substring(last);
1:fc00993:         if (s.length() != 0) {
1:f812e34:             l.add(s);
1:fc00993:         }
1:f812e34: 
1:d29ca2a:         String rc[] = new String[l.size()];
1:d29ca2a:         l.toArray(rc);
1:d29ca2a:         return rc;
1:d29ca2a:     }
1:f812e34: 
1:de7617e:     /**
1:de7617e:      * String the given prefix from the target string and return the result.
1:de7617e:      *
1:de7617e:      * @param value
1:de7617e:      * 		The string that should be trimmed of the given prefix if present.
1:de7617e:      * @param prefix
1:de7617e:      * 		The prefix to remove from the target string.
1:de7617e:      *
1:de7617e:      * @return either the original string or a new string minus the supplied prefix if present.
1:de7617e:      */
1:d29ca2a:     public static String stripPrefix(String value, String prefix) {
1:fc00993:         if (value.startsWith(prefix)) {
1:d29ca2a:             return value.substring(prefix.length());
1:fc00993:         }
1:d29ca2a:         return value;
1:d29ca2a:     }
1:f812e34: 
1:de7617e:     /**
1:de7617e:      * Strip a URI of its scheme element.
1:de7617e:      *
1:de7617e:      * @param uri
1:de7617e:      * 		The URI whose scheme value should be stripped.
1:de7617e:      *
1:de7617e:      * @return The stripped URI value.
1:de7617e:      * @throws URISyntaxException
1:de7617e:      */
1:d29ca2a:     public static URI stripScheme(URI uri) throws URISyntaxException {
1:f812e34:         return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), "//"));
1:d29ca2a:     }
1:d29ca2a: 
1:de7617e:     /**
1:de7617e:      * Given a key / value mapping, create and return a URI formatted query string that is valid and
1:de7617e:      * can be appended to a URI.
1:de7617e:      *
1:de7617e:      * @param options
1:de7617e:      * 		The Mapping that will create the new Query string.
1:de7617e:      *
1:de7617e:      * @return a URI formatted query string.
1:de7617e:      * @throws URISyntaxException
1:de7617e:      */
1:5215fc2:     public static String createQueryString(Map<String, ? extends Object> options) throws URISyntaxException {
1:d29ca2a:         try {
1:f812e34:             if (options.size() > 0) {
1:d29ca2a:                 StringBuffer rc = new StringBuffer();
1:f812e34:                 boolean first = true;
1:fa40250:                 for (String key : options.keySet()) {
1:fc00993:                     if (first) {
1:f812e34:                         first = false;
1:fc00993:                     } else {
1:d29ca2a:                         rc.append("&");
1:fc00993:                     }
1:d29ca2a:                     String value = (String)options.get(key);
1:d29ca2a:                     rc.append(URLEncoder.encode(key, "UTF-8"));
1:d29ca2a:                     rc.append("=");
1:d29ca2a:                     rc.append(URLEncoder.encode(value, "UTF-8"));
1:d29ca2a:                 }
1:d29ca2a:                 return rc.toString();
1:d29ca2a:             } else {
1:d29ca2a:                 return "";
1:d29ca2a:             }
1:d29ca2a:         } catch (UnsupportedEncodingException e) {
1:d29ca2a:             throw (URISyntaxException)new URISyntaxException(e.toString(), "Invalid encoding").initCause(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:de7617e:      * Creates a URI from the original URI and the remaining parameters.
1:de7617e:      *
1:de7617e:      * When the query options of a URI are applied to certain objects the used portion of the query options needs
1:de7617e:      * to be removed and replaced with those that remain so that other parts of the code can attempt to apply the
1:de7617e:      * remainder or give an error is unknown values were given.  This method is used to update a URI with those
1:de7617e:      * remainder values.
1:de7617e:      *
1:de7617e:      * @param originalURI
1:de7617e:      *		The URI whose current parameters are remove and replaced with the given remainder value.
1:de7617e:      * @param params
1:de7617e:      * 		The URI params that should be used to replace the current ones in the target.
1:de7617e:      *
1:de7617e:      * @return a new URI that matches the original one but has its query options replaced with the given ones.
1:d29ca2a:      * @throws URISyntaxException
1:d29ca2a:      */
1:fa40250:     public static URI createRemainingURI(URI originalURI, Map<String, String> params) throws URISyntaxException {
1:d29ca2a:         String s = createQueryString(params);
1:fc00993:         if (s.length() == 0) {
1:d29ca2a:             s = null;
1:fc00993:         }
1:d29ca2a:         return createURIWithQuery(originalURI, s);
1:d29ca2a:     }
1:d29ca2a: 
1:de7617e:     /**
1:de7617e:      * Given a URI value create and return a new URI that matches the target one but with the scheme value
1:de7617e:      * supplied to this method.
1:de7617e:      *
1:de7617e:      * @param bindAddr
1:de7617e:      * 		The URI whose scheme value should be altered.
1:de7617e:      * @param scheme
1:de7617e:      * 		The new scheme value to use for the returned URI.
1:de7617e:      *
1:de7617e:      * @return a new URI that is a copy of the original except that its scheme matches the supplied one.
1:de7617e:      * @throws URISyntaxException
1:de7617e:      */
1:fc00993:     public static URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException {
1:933eb2f:         return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr
1:933eb2f:             .getPath(), bindAddr.getQuery(), bindAddr.getFragment());
1:d29ca2a:     }
1:d29ca2a: 
1:de7617e:     /**
1:de7617e:      * Examine the supplied string and ensure that all parends appear as matching pairs.
1:de7617e:      *
1:de7617e:      * @param str
1:de7617e:      * 		The target string to examine.
4:de7617e:      *
1:de7617e:      * @return true if the target string has valid parend pairings.
1:de7617e:      */
1:f812e34:     public static boolean checkParenthesis(String str) {
1:f812e34:         boolean result = true;
1:f812e34:         if (str != null) {
1:f812e34:             int open = 0;
1:f812e34:             int closed = 0;
1:f812e34: 
1:f812e34:             int i = 0;
1:f812e34:             while ((i = str.indexOf('(', i)) >= 0) {
1:d29ca2a:                 i++;
1:d29ca2a:                 open++;
1:d29ca2a:             }
1:f812e34:             i = 0;
1:f812e34:             while ((i = str.indexOf(')', i)) >= 0) {
1:d29ca2a:                 i++;
1:d29ca2a:                 closed++;
1:d29ca2a:             }
1:d29ca2a:             result = open == closed;
1:d29ca2a:         }
2:d29ca2a:         return result;
1:d29ca2a:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:5215fc2
/////////////////////////////////////////////////////////////////////////
1:     public static String createQueryString(Map<String, ? extends Object> options) throws URISyntaxException {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     public static Map<String, String> parseParamters(URI uri) throws URISyntaxException {
1:         return uri.getQuery() == null ? emptyMap() : parseQuery(stripPrefix(uri.getQuery(), "?"));
1:     }
1: 
1:     @SuppressWarnings("unchecked")
1:     private static Map<String, String> emptyMap() {
1:         return Collections.EMPTY_MAP;
/////////////////////////////////////////////////////////////////////////
0:         return new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(),
0:                        query, uri.getFragment());
/////////////////////////////////////////////////////////////////////////
1:             rc.parameters = emptyMap();
/////////////////////////////////////////////////////////////////////////
1:         return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr
1:             .getPath(), bindAddr.getQuery(), bindAddr.getFragment());
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         private String host;
1:         private String scheme;
1:         private String path;
1:         private URI components[];
1:         private Map<String, String> parameters;
1:         private String fragment;
/////////////////////////////////////////////////////////////////////////
1:         public Map<String, String> getParameters() {
/////////////////////////////////////////////////////////////////////////
1:     public static Map<String, String> parseQuery(String uri) throws URISyntaxException {
1:             Map<String, String> rc = new HashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
0:     public static Map<String,String> parseParamters(URI uri) throws URISyntaxException {
/////////////////////////////////////////////////////////////////////////
1:         List<String> l = new ArrayList<String>();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:                     if (i != 0) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:             if (params.length() > 0) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (s.length() != 0) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (value.startsWith(prefix)) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:                     if (first) {
1:                     } else {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:         if (s.length() == 0) {
1:         }
1:     public static URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1:                 break;
1:             default:
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1:             if (scheme != null) {
1: 
1:             if (host != null && host.length() != 0) {
0:                     if (i != 0)
1: 
1:             if (path != null) {
1:             if (!parameters.isEmpty()) {
1:             if (fragment != null) {
/////////////////////////////////////////////////////////////////////////
0:     public static Map parseQuery(String uri) throws URISyntaxException {
1:         try {
0:             Map rc = new HashMap();
0:             if (uri != null) {
1:                 String[] parameters = uri.split("&");
1:                 for (int i = 0; i < parameters.length; i++) {
1:                     int p = parameters[i].indexOf("=");
1:                     if (p >= 0) {
1:                         String name = URLDecoder.decode(parameters[i].substring(0, p), "UTF-8");
1:                         String value = URLDecoder.decode(parameters[i].substring(p + 1), "UTF-8");
1:                         rc.put(name, value);
1:                     } else {
1:                         rc.put(parameters[i], null);
1:         } catch (UnsupportedEncodingException e) {
1:             throw (URISyntaxException)new URISyntaxException(e.toString(), "Invalid encoding").initCause(e);
1: 
0:         return uri.getQuery() == null ? Collections.EMPTY_MAP : parseQuery(stripPrefix(uri.getQuery(), "?"));
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (!checkParenthesis(ssp)) {
1: 
0:         if (intialParen == 0) {
1:             if (p >= 0) {
1:                 rc.host = rc.host.substring(0, p);
0:             componentString = ssp.substring(intialParen + 1, p);
1:             params = ssp.substring(p + 1).trim();
1: 
1:             params = "";
1:         rc.components = new URI[components.length];
1: 
1:         if (p >= 0) {
1:             if (p > 0) {
1:             rc.parameters = parseQuery(params.substring(p + 1));
0:             if (params.length() > 0)
/////////////////////////////////////////////////////////////////////////
1: 
1:         int last = 0;
1:         for (int i = 0; i < chars.length; i++) {
1:             switch (chars[i]) {
/////////////////////////////////////////////////////////////////////////
1:                 if (depth == 0) {
1:                     last = i + 1;
1: 
0:         if (s.length() != 0)
1:             l.add(s);
1: 
1: 
0:         if (value.startsWith(prefix))
1: 
1:         return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), "//"));
1:             if (options.size() > 0) {
1:                 boolean first = true;
0:                     if (first)
1:                         first = false;
1: 
0:                     String key = (String)iter.next();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws URISyntaxException
0:         if (s.length() == 0)
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static boolean checkParenthesis(String str) {
1:         boolean result = true;
1:         if (str != null) {
1:             int open = 0;
1:             int closed = 0;
1: 
1:             int i = 0;
1:             while ((i = str.indexOf('(', i)) >= 0) {
1:             i = 0;
1:             while ((i = str.indexOf(')', i)) >= 0) {
/////////////////////////////////////////////////////////////////////////
1: 
0:     public int indexOfParenthesisMatch(String str) {
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.util;
1: 
1: import java.io.UnsupportedEncodingException;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.net.URLDecoder;
1: import java.net.URLEncoder;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.HashMap;
0: import java.util.Iterator;
1: import java.util.Map;
1: 
1: /**
0:  * @version $Revision$
1:  */
1: public class URISupport {
1:     
1:     public static class CompositeData {
0:         String scheme;
0:         String path;
0:         URI components[];
0:         Map parameters;
0:         String fragment;
0:         public String host;
1:         
1:         public URI[] getComponents() {
1:             return components;
1:         }
1:         public String getFragment() {
1:             return fragment;
1:         }
0:         public Map getParameters() {
1:             return parameters;
1:         }
1:         public String getScheme() {
1:             return scheme;
1:         }
1:         public String getPath() {
1:             return path;
1:         }
1:         public String getHost() {
1:             return host;
1:         }
1:         
1:         public URI toURI() throws URISyntaxException {
1:             StringBuffer sb = new StringBuffer();
0:             if( scheme!=null ) {
1:                 sb.append(scheme);
1:                 sb.append(':');
1:             }
1:             
0:             if( host!=null && host.length()!=0 ) {
1:                 sb.append(host);
1:             } else {
1:                 sb.append('(');
1:                 for (int i = 0; i < components.length; i++) {
0:                     if( i!=0 )
1:                         sb.append(',');
1:                     sb.append(components[i].toString());
1:                 }
1:                 sb.append(')');
1:             }
1:             
0:             if( path !=null ) {
1:                 sb.append('/');
1:                 sb.append(path);
1:             }
0:             if(!parameters.isEmpty()) {
1:                 sb.append("?");
1:                 sb.append(createQueryString(parameters));
1:             }
0:             if( fragment!=null ) {
1:                 sb.append("#");
1:                 sb.append(fragment);
1:             }
1:             return new URI(sb.toString());
1:         }
1:     }
1: 
0:     public static Map parseQuery(String uri) throws URISyntaxException{
0:         try{
0:             Map rc=new HashMap();
0:             if(uri!=null){
0:                 String[] parameters=uri.split("&");
0:                 for(int i=0;i<parameters.length;i++){
0:                     int p=parameters[i].indexOf("=");
0:                     if(p>=0){
0:                         String name=URLDecoder.decode(parameters[i].substring(0,p),"UTF-8");
0:                         String value=URLDecoder.decode(parameters[i].substring(p+1),"UTF-8");
0:                         rc.put(name,value);
0:                     }else{
0:                         rc.put(parameters[i],null);
1:                     }
1:                 }
1:             }
1:             return rc;
0:         }catch(UnsupportedEncodingException e){
0:             throw (URISyntaxException) new URISyntaxException(e.toString(),"Invalid encoding").initCause(e);
1:         }
1:     }
1:     
0:     public static Map parseParamters(URI uri) throws URISyntaxException {
0:         return uri.getQuery()==null ? Collections.EMPTY_MAP : parseQuery(stripPrefix(uri.getQuery(), "?"));
1:     }
1: 
1:     /**
0:      * Removes any URI query from the given uri
1:      */
1:     public static URI removeQuery(URI uri) throws URISyntaxException {
1:         return createURIWithQuery(uri, null);
1:     }
1: 
1:     /**
0:      * Creates a URI with the given query
1:      */
1:     public static URI createURIWithQuery(URI uri, String query) throws URISyntaxException {
0:         return new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(), query, uri.getFragment());
1:     }
1:     
1:     public static CompositeData parseComposite(URI uri) throws URISyntaxException {
1:         
1:         CompositeData rc = new CompositeData();
1:         rc.scheme = uri.getScheme();
0:         String ssp = stripPrefix(uri.getSchemeSpecificPart().trim(), "//").trim();
1: 
1:         parseComposite(uri, rc, ssp);
1:         
1:         rc.fragment = uri.getFragment();
1:         return rc;
1:     }
1: 
1:     /**
1:      * @param uri
1:      * @param rc
1:      * @param ssp
0:      * @param p
1:      * @throws URISyntaxException
1:      */
1:     private static void parseComposite(URI uri, CompositeData rc, String ssp) throws URISyntaxException {
1:         String componentString;
1:         String params;
1:         
0:         if(!checkParenthesis(ssp)){
1:             throw new URISyntaxException(uri.toString(), "Not a matching number of '(' and ')' parenthesis");
1:         }
1:         
1:         int p;
0:         int intialParen = ssp.indexOf("(");
0:         if( intialParen==0 ) {
0:             rc.host = ssp.substring(0, intialParen);
1:             p = rc.host.indexOf("/");
0:             if( p >= 0 ) {
1:                 rc.path = rc.host.substring(p);
0:                 rc.host = rc.host.substring(0,p);
1:             }
0:             p = ssp.lastIndexOf(")");
0:             componentString = ssp.substring(intialParen+1,p);
0:             params = ssp.substring(p+1).trim();
1:             
1:         } else {
1:             componentString = ssp;
0:             params="";
1:         }
1: 
1:         String components[] = splitComponents(componentString);
0:         rc.components=new URI[components.length];
1:         for (int i = 0; i < components.length; i++) {
1:             rc.components[i] = new URI(components[i].trim());
1:         }
1:         
1:         p = params.indexOf("?");
0:         if( p >= 0 ) {
0:             if( p > 0) {
1:                 rc.path = stripPrefix(params.substring(0, p), "/");
1:             }
0:             rc.parameters = parseQuery(params.substring(p+1));
1:         } else {
0:             if( params.length() > 0 )
1:                 rc.path = stripPrefix(params, "/");
0:             rc.parameters = Collections.EMPTY_MAP;
1:         }
1:     }
1: 
1:     /**
0:      * @param componentString
0:      * @return
1:      */
1:     private static String[] splitComponents(String str) {
0:         ArrayList l = new ArrayList();
1:         
0:         int last=0;
1:         int depth = 0;
1:         char chars[] = str.toCharArray();
0:         for( int i=0; i < chars.length; i ++ ) {
0:             switch( chars[i] ) {
1:             case '(':
1:                 depth++;
1:                 break;
1:             case ')':
1:                 depth--;
1:                 break;
1:             case ',':
0:                 if( depth == 0 ) {
0:                     String s = str.substring(0, i-last);
1:                     l.add(s);
0:                     last=i+1;
1:                 }
1:             }
1:         }
1:         
1:         String s = str.substring(last);
0:         if( s.length() !=0 )
1:             l.add(s);        
1:         
1:         String rc[] = new String[l.size()];
1:         l.toArray(rc);
1:         return rc;
1:     }
1:     
1:     public static String stripPrefix(String value, String prefix) {
0:         if( value.startsWith(prefix) )
1:             return value.substring(prefix.length());
1:         return value;
1:     }
1:     
1:     public static URI stripScheme(URI uri) throws URISyntaxException {
0:         return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), "//")); 
1:     }
1: 
0:     public static String createQueryString(Map options) throws URISyntaxException {
1:         try {
0:             if(options.size()>0) {
1:                 StringBuffer rc = new StringBuffer();
0:                 boolean first=true;
0:                 for (Iterator iter = options.keySet().iterator(); iter.hasNext();) {
0:                     if( first )
0:                         first=false;
0:                     else
1:                         rc.append("&");
1:                                     
0:                     String key = (String) iter.next();
1:                     String value = (String)options.get(key);
1:                     rc.append(URLEncoder.encode(key, "UTF-8"));
1:                     rc.append("=");
1:                     rc.append(URLEncoder.encode(value, "UTF-8"));
1:                 }
1:                 return rc.toString();
1:             } else {
1:                 return "";
1:             }
1:         } catch (UnsupportedEncodingException e) {
1:             throw (URISyntaxException)new URISyntaxException(e.toString(), "Invalid encoding").initCause(e);
1:         }
1:     }
1: 
1:     /**
0:      * Creates a URI from the original URI and the remaining paramaters
1:      * @throws URISyntaxException 
1:      */
0:     public static URI createRemainingURI(URI originalURI, Map params) throws URISyntaxException {
1:         String s = createQueryString(params);
0:         if( s.length()==0 )
1:             s = null;
1:         return createURIWithQuery(originalURI, s);
1:     }
1: 
0:     static public URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException {
0:         return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr.getPath(), bindAddr.getQuery(), bindAddr.getFragment());
1:     }
1:     
0:     public static boolean checkParenthesis(String str){
0:         boolean result=true;
0:         if(str!=null){
0:             int open=0;
0:             int closed=0;
1:             
0:             int i=0;
0:             while((i=str.indexOf('(',i)) >=0 ){
1:                 i++;
1:                 open++;
1:             }
0:             i=0;
0:             while((i=str.indexOf(')',i)) >=0 ){
1:                 i++;
1:                 closed++;
1:             }
1:             result = open == closed;
1:         }
1:         return result;
1:     }
1:     
0:     public int indexOfParenthesisMatch(String str){
0:         int result = -1;
1:         
1:         return result;
1:     }
1: 
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:de7617e
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * This class can be used to split composite URI's into their component parts and is used to extract any
1:  * URI options from each URI in order to set specific properties on Beans.
1:     /**
1:      * A composite URI can be split into one or more CompositeData object which each represent the
1:      * individual URIs that comprise the composite one.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Give a URI break off any URI options and store them in a Key / Value Mapping.
1:      *
1:      * @param uri
1:      * 		The URI whose query should be extracted and processed.
1:      *
1:      * @return A Mapping of the URI options.
1:      * @throws URISyntaxException
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Given a URI parse and extract any URI query options and return them as a Key / Value mapping.
1:      *
1:      * This method differs from the {@link parseQuery} method in that it handles composite URI types and
1:      * will extract the URI options from the outermost composite URI.
1:      *
1:      * @param uri
1:      * 		The URI whose query should be extracted and processed.
1:      *
1:      * @return A Mapping of the URI options.
1:      * @throws URISyntaxException
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Given a Key / Value mapping create and append a URI query value that represents the mapped entries, return the
1:      * newly updated URI that contains the value of the given URI and the appended query value.
1:      *
1:      * @param uri
1:      * 		The source URI that will have the Map entries appended as a URI query value.
1:      * @param queryParameters
1:      * 		The Key / Value mapping that will be transformed into a URI query string.
1:      *
1:      * @return A new URI value that combines the given URI and the constructed query string.
1:      * @throws URISyntaxException
1:      */
1:     /**
1:      * Given a Key / Value mapping create and append a URI query value that represents the mapped entries, return the
1:      * newly updated URI that contains the value of the given URI and the appended query value.  Each entry in the query
1:      * string is prefixed by the supplied optionPrefix string.
1:      *
1:      * @param uri
1:      * 		The source URI that will have the Map entries appended as a URI query value.
1:      * @param queryParameters
1:      * 		The Key / Value mapping that will be transformed into a URI query string.
1:      * @param optionPrefix
1:      * 		A string value that when not null or empty is used to prefix each query option key.
1:      *
1:      * @return A new URI value that combines the given URI and the constructed query string.
1:      * @throws URISyntaxException
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * Removes any URI query from the given uri and return a new URI that does not contain the query portion.
1:      *
1:      * @param uri
1:      * 		The URI whose query value is to be removed.
1:      *
1:      * @return a new URI that does not contain a query value.
1:      * @throws URISyntaxException
1:      * Creates a URI with the given query, removing an previous query value from the given URI.
1:      *
1:      * @param uri
1:      * 		The source URI whose existing query is replaced with the newly supplied one.
1:      * @param query
1:      * 		The new URI query string that should be appended to the given URI.
1:      *
1:      * @return a new URI that is a combination of the original URI and the given query string.
1:      * @throws URISyntaxException
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Given a composite URI, parse the individual URI elements contained within that URI and return
1:      * a CompsoteData instance that contains the parsed URI values.
1:      *
1:      * @param uri
1:      * 		The target URI that should be parsed.
1:      *
1:      * @return a new CompsiteData instance representing the parsed composite URI.
1:      * @throws URISyntaxException
1:      */
1:     /**
1:      * Examine a URI and determine if it is a Composite type or not.
1:      *
1:      * @param uri
1:      * 		The URI that is to be examined.
1:      *
1:      * @return true if the given URI is a Compsote type.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Given a string and a position in that string of an open parend, find the matching close parend.
1:      *
1:      * @param str
1:      * 		The string to be searched for a matching parend.
1:      * @param first
1:      * 		The index in the string of the opening parend whose close value is to be searched.
1:      *
1:      * @return the index in the string where the closing parend is located.
1:      * @throws URISyntaxException fi the string does not contain a matching parend.
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * Given a composite URI and a CompositeData instance and the scheme specific part extracted from the source URI,
1:      * parse the composite URI and populate the CompositeData object with the results.  The source URI is used only
1:      * for logging as the ssp should have already been extracted from it and passed here.
1:      *
1:      * 		The original source URI whose ssp is parsed into the composite data.
1:      * 		The CompsositeData instance that will be populated from the given ssp.
1:      * 		The scheme specific part from the original string that is a composite or one or more URIs.
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * Given the inner portion of a composite URI, split and return each inner URI as a string
1:      * element in a new String array.
1:      *
1:      * 		The inner URI elements of a composite URI string.
1:      *
1:      * @return an array containing each inner URI from the composite one.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * String the given prefix from the target string and return the result.
1:      *
1:      * @param value
1:      * 		The string that should be trimmed of the given prefix if present.
1:      * @param prefix
1:      * 		The prefix to remove from the target string.
1:      *
1:      * @return either the original string or a new string minus the supplied prefix if present.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Strip a URI of its scheme element.
1:      *
1:      * @param uri
1:      * 		The URI whose scheme value should be stripped.
1:      *
1:      * @return The stripped URI value.
1:      * @throws URISyntaxException
1:      */
1:     /**
1:      * Given a key / value mapping, create and return a URI formatted query string that is valid and
1:      * can be appended to a URI.
1:      *
1:      * @param options
1:      * 		The Mapping that will create the new Query string.
1:      *
1:      * @return a URI formatted query string.
1:      * @throws URISyntaxException
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * Creates a URI from the original URI and the remaining parameters.
1:      * When the query options of a URI are applied to certain objects the used portion of the query options needs
1:      * to be removed and replaced with those that remain so that other parts of the code can attempt to apply the
1:      * remainder or give an error is unknown values were given.  This method is used to update a URI with those
1:      * remainder values.
1:      *
1:      * @param originalURI
1:      *		The URI whose current parameters are remove and replaced with the given remainder value.
1:      * @param params
1:      * 		The URI params that should be used to replace the current ones in the target.
1:      *
1:      * @return a new URI that matches the original one but has its query options replaced with the given ones.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Given a URI value create and return a new URI that matches the target one but with the scheme value
1:      * supplied to this method.
1:      *
1:      * @param bindAddr
1:      * 		The URI whose scheme value should be altered.
1:      * @param scheme
1:      * 		The new scheme value to use for the returned URI.
1:      *
1:      * @return a new URI that is a copy of the original except that its scheme matches the supplied one.
0:      * @throws URISyntaxException
1:      */
1:     /**
1:      * Examine the supplied string and ensure that all parends appear as matching pairs.
1:      *
1:      * @param str
1:      * 		The target string to examine.
1:      *
1:      * @return true if the target string has valid parend pairings.
1:      */
commit:79bce92
/////////////////////////////////////////////////////////////////////////
1:         String ssp = stripPrefix(uri.getRawSchemeSpecificPart().trim(), "//").trim();
0: 
1:         if (ssp.indexOf('(') == 0 && checkParenthesis(ssp)) {
1:         return false;
commit:ba4a9ed
/////////////////////////////////////////////////////////////////////////
1:     public static int indexOfParenthesisMatch(String str, int first) throws URISyntaxException {
1:         int index = -1;
0: 
1:         if (first < 0 || first > str.length()) {
1:             throw new IllegalArgumentException("Invalid position for first parenthesis: " + first);
1:         }
0: 
1:         if (str.charAt(first) != '(') {
1:             throw new IllegalArgumentException("character at indicated position is not a parenthesis");
1:         }
0: 
1:         int depth = 1;
1:         char[] array = str.toCharArray();
1:         for (index = first + 1; index < array.length; ++index) {
1:             char current = array[index];
1:             if (current == '(') {
1:                 depth++;
1:             } else if (current == ')') {
1:                 if (--depth == 0) {
1:                     break;
1:                 }
1:             }
1:         }
0: 
1:         if (depth != 0) {
1:             throw new URISyntaxException(str, "URI did not contain a matching parenthesis.");
1:         }
0: 
1:         return index;
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         int initialParen = ssp.indexOf("(");
1:         if (initialParen == 0) {
0: 
1:             rc.host = ssp.substring(0, initialParen);
0: 
0: 
1:             p = indexOfParenthesisMatch(ssp, initialParen);
1:             componentString = ssp.substring(initialParen + 1, p);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
commit:fa40250
/////////////////////////////////////////////////////////////////////////
1:  * Utility class that provides methods for parsing URI's
/////////////////////////////////////////////////////////////////////////
1:             if (uri != null && !uri.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:             questionMark = -1;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static String createQueryString(Map<String, String> options) throws URISyntaxException {
1:                 for (String key : options.keySet()) {
/////////////////////////////////////////////////////////////////////////
0:      *
1:     public static URI createRemainingURI(URI originalURI, Map<String, String> params) throws URISyntaxException {
commit:4f9784d
/////////////////////////////////////////////////////////////////////////
1:         // make sure question mark is not within parentheses
1:         if (questionMark < schemeSpecificPart.lastIndexOf(")")) {
0:         	questionMark = -1;
1:         }
1:         }
author:Gary Tully
-------------------------------------------------------------------------------
commit:986ed14
/////////////////////////////////////////////////////////////////////////
1:             if (parameters.isEmpty()) {
1:             }
1:         return applyParameters(uri, queryParameters, "");
1:     }
0: 
1:     public static URI applyParameters(URI uri, Map<String, String> queryParameters, String optionPrefix) throws URISyntaxException {
1:                 if (param.getKey().startsWith(optionPrefix)) {
1:                     if (newQuery.length()!=0) {
1:                         newQuery.append('&');
1:                     }
1:                     final String key = param.getKey().substring(optionPrefix.length());
1:                     newQuery.append(key).append('=').append(param.getValue());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param str
commit:c4d8bc4
/////////////////////////////////////////////////////////////////////////
1:         String schemeSpecificPart = uri.getRawSchemeSpecificPart();
1:         // strip existing query if any
1:         int questionMark = schemeSpecificPart.lastIndexOf("?");
1:         if (questionMark > 0) {
1:             schemeSpecificPart = schemeSpecificPart.substring(0, questionMark);
1:         }
1:         if (query != null && query.length() > 0) {
1:             schemeSpecificPart += "?" + query;
1:          }
1:         return new URI(uri.getScheme(), schemeSpecificPart, uri.getFragment());
commit:39e63c0
/////////////////////////////////////////////////////////////////////////
1:     public static URI applyParameters(URI uri, Map<String, String> queryParameters) throws URISyntaxException {
1:         if (queryParameters != null && !queryParameters.isEmpty()) {
1:             StringBuffer newQuery = uri.getRawQuery() != null ? new StringBuffer(uri.getRawQuery()) : new StringBuffer() ;
1:             for ( Map.Entry<String, String> param: queryParameters.entrySet()) {
0:                 if (newQuery.length()!=0) {
0:                     newQuery.append('&');
1:                 }
0:                 newQuery.append(param.getKey()).append('=').append(param.getValue());
1:             }
1:             uri = createURIWithQuery(uri, newQuery.toString());
1:         }
1:         return uri;
1:     }
0:     
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e32c1ba
/////////////////////////////////////////////////////////////////////////
1:         if (!isCompositeURI(uri)) {
/////////////////////////////////////////////////////////////////////////
0:         
0:     
1:     public static boolean isCompositeURI(URI uri) {
0:         if (uri.getQuery() != null) {
0:             return false;
1:         } else {
0:             String ssp = stripPrefix(uri.getRawSchemeSpecificPart().trim(), "(").trim();
0:             ssp = stripPrefix(ssp, "//").trim();
0:             try {
0:                 new URI(ssp);
0:             } catch (URISyntaxException e) {
0:                 return false;
1:             }
1:             return true;
1:         }
1:     }
commit:784b93d
/////////////////////////////////////////////////////////////////////////
1:     public static Map<String, String> parseParameters(URI uri) throws URISyntaxException {
0:         if (uri.getQuery() != null) {
0:             return uri.getQuery() == null ? emptyMap() : parseQuery(stripPrefix(uri.getQuery(), "?"));
0:         } else {
1:             CompositeData data = URISupport.parseComposite(uri);
1:             Map<String, String> parameters = new HashMap<String, String>();
1:             parameters.putAll(data.getParameters());
0:             for (URI component : data.getComponents()) {
0:                 parameters.putAll(component.getQuery() == null ? emptyMap() : parseQuery(stripPrefix(component.getQuery(), "?")));
0:             }
0:             if (parameters.isEmpty()) 
1:                 parameters = emptyMap();
0:             
1:             return parameters;
0:         }
commit:3a6a56c
/////////////////////////////////////////////////////////////////////////
1:             uri = uri.substring(uri.lastIndexOf("?") + 1); // get only the relevant part of the query
author:Robert Davies
-------------------------------------------------------------------------------
commit:c008426
/////////////////////////////////////////////////////////////////////////
1:         String ssp = stripPrefix(uri.getRawSchemeSpecificPart().trim(), "//").trim();
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:52aeaa2
/////////////////////////////////////////////////////////////////////////
1:                     String s = str.substring(last, i);
============================================================================