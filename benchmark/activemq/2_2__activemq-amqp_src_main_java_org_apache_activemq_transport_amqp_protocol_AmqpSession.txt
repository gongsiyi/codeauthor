1:10fc397: /*
1:3306467:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3306467:  * contributor license agreements.  See the NOTICE file distributed with
1:3306467:  * this work for additional information regarding copyright ownership.
1:3306467:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3306467:  * (the "License"); you may not use this file except in compliance with
1:3306467:  * the License.  You may obtain a copy of the License at
1:3306467:  *
1:3306467:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3306467:  *
1:3306467:  * Unless required by applicable law or agreed to in writing, software
1:3306467:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3306467:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3306467:  * See the License for the specific language governing permissions and
1:3306467:  * limitations under the License.
1:3306467:  */
1:3306467: package org.apache.activemq.transport.amqp.protocol;
2:3306467: 
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.COPY;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_FILTER_IDS;
1:b5c6264: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_NAME;
1:10fc397: import static org.apache.activemq.transport.amqp.AmqpSupport.LIFETIME_POLICY;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_FILTER_IDS;
1:b5c6264: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_NAME;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.createDestination;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.findFilter;
1:3306467: 
1:3306467: import java.io.IOException;
1:4a1c05b: import java.util.Arrays;
1:3306467: import java.util.HashMap;
1:4a1c05b: import java.util.List;
1:3306467: import java.util.Map;
1:3306467: 
1:3306467: import javax.jms.InvalidSelectorException;
1:3306467: 
1:3306467: import org.apache.activemq.command.ActiveMQDestination;
1:3306467: import org.apache.activemq.command.ActiveMQTempDestination;
1:3306467: import org.apache.activemq.command.ConsumerId;
1:3306467: import org.apache.activemq.command.ConsumerInfo;
1:3306467: import org.apache.activemq.command.ExceptionResponse;
1:0dd806f: import org.apache.activemq.command.LocalTransactionId;
1:3306467: import org.apache.activemq.command.ProducerId;
1:3306467: import org.apache.activemq.command.ProducerInfo;
1:3306467: import org.apache.activemq.command.RemoveInfo;
1:3306467: import org.apache.activemq.command.Response;
1:3306467: import org.apache.activemq.command.SessionId;
1:3306467: import org.apache.activemq.command.SessionInfo;
1:ed26683: import org.apache.activemq.command.TransactionId;
1:3306467: import org.apache.activemq.selector.SelectorParser;
1:3306467: import org.apache.activemq.transport.amqp.AmqpProtocolConverter;
1:3306467: import org.apache.activemq.transport.amqp.AmqpProtocolException;
1:10fc397: import org.apache.activemq.transport.amqp.AmqpSupport;
1:3306467: import org.apache.activemq.transport.amqp.ResponseHandler;
1:a35e8dc: import org.apache.activemq.util.IntrospectionSupport;
1:3306467: import org.apache.qpid.proton.amqp.DescribedType;
1:3306467: import org.apache.qpid.proton.amqp.Symbol;
1:10fc397: import org.apache.qpid.proton.amqp.messaging.DeleteOnClose;
1:3306467: import org.apache.qpid.proton.amqp.messaging.Target;
1:3306467: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
1:3306467: import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
1:3306467: import org.apache.qpid.proton.amqp.transport.AmqpError;
1:3306467: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
1:3306467: import org.apache.qpid.proton.engine.Receiver;
1:3306467: import org.apache.qpid.proton.engine.Sender;
1:3306467: import org.apache.qpid.proton.engine.Session;
1:3306467: import org.slf4j.Logger;
1:3306467: import org.slf4j.LoggerFactory;
1:3306467: 
2:3306467: /**
1:3306467:  * Wraps the AMQP Session and provides the services needed to manage the remote
1:3306467:  * peer requests for link establishment.
1:3306467:  */
1:3306467: public class AmqpSession implements AmqpResource {
1:3306467: 
1:3306467:     private static final Logger LOG = LoggerFactory.getLogger(AmqpSession.class);
1:3306467: 
1:4a1c05b:     private final Map<ConsumerId, AmqpSender> consumers = new HashMap<>();
1:3306467: 
1:3306467:     private final AmqpConnection connection;
1:3306467:     private final Session protonSession;
1:3306467:     private final SessionId sessionId;
1:3306467: 
1:ed26683:     private boolean enlisted;
1:3306467:     private long nextProducerId = 0;
1:3306467:     private long nextConsumerId = 0;
1:3306467: 
1:3306467:     /**
1:3306467:      * Create new AmqpSession instance whose parent is the given AmqpConnection.
1:3306467:      *
1:3306467:      * @param connection
1:3306467:      *        the parent connection for this session.
1:3306467:      * @param sessionId
1:3306467:      *        the ActiveMQ SessionId that is used to identify this session.
1:3306467:      * @param session
1:3306467:      *        the AMQP Session that this class manages.
1:3306467:      */
1:3306467:     public AmqpSession(AmqpConnection connection, SessionId sessionId, Session session) {
1:3306467:         this.connection = connection;
1:3306467:         this.sessionId = sessionId;
1:3306467:         this.protonSession = session;
2:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public void open() {
1:f0ebda7:         LOG.debug("Session {} opened", getSessionId());
1:3306467: 
1:3306467:         getEndpoint().setContext(this);
1:3306467:         getEndpoint().setIncomingCapacity(Integer.MAX_VALUE);
1:3306467:         getEndpoint().open();
1:3306467: 
1:3306467:         connection.sendToActiveMQ(new SessionInfo(getSessionId()));
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public void close() {
1:f0ebda7:         LOG.debug("Session {} closed", getSessionId());
1:3306467: 
1:83827f2:         connection.sendToActiveMQ(new RemoveInfo(getSessionId()), new ResponseHandler() {
1:3306467: 
1:83827f2:             @Override
1:83827f2:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:83827f2:                 getEndpoint().setContext(null);
1:83827f2:                 getEndpoint().close();
1:83827f2:                 getEndpoint().free();
1:83827f2:             }
1:83827f2:         });
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * Commits all pending work for all resources managed under this session.
1:3306467:      *
1:0dd806f:      * @param txId
1:0dd806f:      *      The specific TransactionId that is being committed.
1:0dd806f:      *
1:3306467:      * @throws Exception if an error occurs while attempting to commit work.
1:3306467:      */
1:0dd806f:     public void commit(LocalTransactionId txId) throws Exception {
1:3306467:         for (AmqpSender consumer : consumers.values()) {
1:0dd806f:             consumer.commit(txId);
1:3306467:         }
1:ed26683: 
1:ed26683:         enlisted = false;
1:3306467:     }
1:ed26683: 
1:3306467:     /**
1:3306467:      * Rolls back any pending work being down under this session.
1:3306467:      *
1:0dd806f:      * @param txId
1:0dd806f:      *      The specific TransactionId that is being rolled back.
1:0dd806f:      *
1:3306467:      * @throws Exception if an error occurs while attempting to roll back work.
1:3306467:      */
1:0dd806f:     public void rollback(LocalTransactionId txId) throws Exception {
1:3306467:         for (AmqpSender consumer : consumers.values()) {
1:0dd806f:             consumer.rollback(txId);
1:3306467:         }
1:3306467: 
1:ed26683:         enlisted = false;
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * Used to direct all Session managed Senders to push any queued Messages
1:3306467:      * out to the remote peer.
1:3306467:      *
1:3306467:      * @throws Exception if an error occurs while flushing the messages.
1:3306467:      */
1:3306467:     public void flushPendingMessages() throws Exception {
1:3306467:         for (AmqpSender consumer : consumers.values()) {
1:3306467:             consumer.pumpOutbound();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     public void createCoordinator(final Receiver protonReceiver) throws Exception {
1:3306467:         AmqpTransactionCoordinator txCoordinator = new AmqpTransactionCoordinator(this, protonReceiver);
1:3306467:         txCoordinator.flow(connection.getConfiguredReceiverCredit());
1:3306467:         txCoordinator.open();
1:3306467:     }
1:3306467: 
1:3306467:     public void createReceiver(final Receiver protonReceiver) throws Exception {
1:3306467:         org.apache.qpid.proton.amqp.transport.Target remoteTarget = protonReceiver.getRemoteTarget();
1:3306467: 
1:3306467:         ProducerInfo producerInfo = new ProducerInfo(getNextProducerId());
1:3306467:         final AmqpReceiver receiver = new AmqpReceiver(this, protonReceiver, producerInfo);
1:3306467: 
1:f0ebda7:         LOG.debug("opening new receiver {} on link: {}", producerInfo.getProducerId(), protonReceiver.getName());
1:f0ebda7: 
1:3306467:         try {
1:3306467:             Target target = (Target) remoteTarget;
1:3306467:             ActiveMQDestination destination = null;
1:3306467:             String targetNodeName = target.getAddress();
1:3306467: 
1:3306467:             if (target.getDynamic()) {
1:3306467:                 destination = connection.createTemporaryDestination(protonReceiver, target.getCapabilities());
1:10fc397: 
1:4a1c05b:                 Map<Symbol, Object> dynamicNodeProperties = new HashMap<>();
1:10fc397:                 dynamicNodeProperties.put(LIFETIME_POLICY, DeleteOnClose.getInstance());
1:10fc397: 
1:10fc397:                 // Currently we only support temporary destinations with delete on close lifetime policy.
1:3306467:                 Target actualTarget = new Target();
1:3306467:                 actualTarget.setAddress(destination.getQualifiedName());
1:10fc397:                 actualTarget.setCapabilities(AmqpSupport.getDestinationTypeSymbol(destination));
1:3306467:                 actualTarget.setDynamic(true);
1:10fc397:                 actualTarget.setDynamicNodeProperties(dynamicNodeProperties);
1:10fc397: 
1:3306467:                 protonReceiver.setTarget(actualTarget);
1:3306467:                 receiver.addCloseAction(new Runnable() {
1:3306467: 
1:3306467:                     @Override
1:3306467:                     public void run() {
1:3306467:                         connection.deleteTemporaryDestination((ActiveMQTempDestination) receiver.getDestination());
1:3306467:                     }
1:3306467:                 });
1:3306467:             } else if (targetNodeName != null && !targetNodeName.isEmpty()) {
1:3306467:                 destination = createDestination(remoteTarget);
1:b313209:                 if (destination.isTemporary()) {
1:b313209:                     String connectionId = ((ActiveMQTempDestination) destination).getConnectionId();
1:b313209:                     if (connectionId == null) {
1:b313209:                         throw new AmqpProtocolException(AmqpError.PRECONDITION_FAILED.toString(), "Not a broker created temp destination");
1:b313209:                     }
1:b313209:                 }
1:3306467:             }
1:3306467: 
1:4a1c05b:             Symbol[] remoteDesiredCapabilities = protonReceiver.getRemoteDesiredCapabilities();
1:4a1c05b:             if (remoteDesiredCapabilities != null) {
1:4a1c05b:                 List<Symbol> list = Arrays.asList(remoteDesiredCapabilities);
1:4a1c05b:                 if (list.contains(AmqpSupport.DELAYED_DELIVERY)) {
1:4a1c05b:                     protonReceiver.setOfferedCapabilities(new Symbol[] { AmqpSupport.DELAYED_DELIVERY });
1:4a1c05b:                 }
1:4a1c05b:             }
1:4a1c05b: 
1:3306467:             receiver.setDestination(destination);
1:3306467:             connection.sendToActiveMQ(producerInfo, new ResponseHandler() {
1:3306467:                 @Override
1:3306467:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:3306467:                     if (response.isException()) {
1:3306467:                         ErrorCondition error = null;
1:3306467:                         Throwable exception = ((ExceptionResponse) response).getException();
1:3306467:                         if (exception instanceof SecurityException) {
1:3306467:                             error = new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage());
1:3306467:                         } else {
1:3306467:                             error = new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage());
1:3306467:                         }
1:3306467: 
1:3306467:                         receiver.close(error);
1:3306467:                     } else {
1:3306467:                         receiver.flow(connection.getConfiguredReceiverCredit());
1:3306467:                         receiver.open();
1:3306467:                     }
1:3306467:                     pumpProtonToSocket();
1:3306467:                 }
1:3306467:             });
1:3306467: 
1:3306467:         } catch (AmqpProtocolException exception) {
1:3306467:             receiver.close(new ErrorCondition(Symbol.getSymbol(exception.getSymbolicName()), exception.getMessage()));
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     @SuppressWarnings("unchecked")
1:3306467:     public void createSender(final Sender protonSender) throws Exception {
1:3306467:         org.apache.qpid.proton.amqp.messaging.Source source = (org.apache.qpid.proton.amqp.messaging.Source) protonSender.getRemoteSource();
1:3306467: 
1:3306467:         ConsumerInfo consumerInfo = new ConsumerInfo(getNextConsumerId());
1:3306467:         final AmqpSender sender = new AmqpSender(this, protonSender, consumerInfo);
1:3306467: 
1:f0ebda7:         LOG.debug("opening new sender {} on link: {}", consumerInfo.getConsumerId(), protonSender.getName());
1:f0ebda7: 
1:3306467:         try {
1:4a1c05b:             final Map<Symbol, Object> supportedFilters = new HashMap<>();
1:3306467:             protonSender.setContext(sender);
1:3306467: 
1:3306467:             boolean noLocal = false;
1:3306467:             String selector = null;
1:3306467: 
1:3306467:             if (source != null) {
1:3306467:                 Map.Entry<Symbol, DescribedType> filter = findFilter(source.getFilter(), JMS_SELECTOR_FILTER_IDS);
1:3306467:                 if (filter != null) {
1:3306467:                     selector = filter.getValue().getDescribed().toString();
1:3306467:                     // Validate the Selector.
1:3306467:                     try {
1:3306467:                         SelectorParser.parse(selector);
1:3306467:                     } catch (InvalidSelectorException e) {
1:3306467:                         sender.close(new ErrorCondition(AmqpError.INVALID_FIELD, e.getMessage()));
1:3306467:                         return;
1:3306467:                     }
1:3306467: 
1:3306467:                     supportedFilters.put(filter.getKey(), filter.getValue());
1:3306467:                 }
1:3306467: 
1:3306467:                 filter = findFilter(source.getFilter(), NO_LOCAL_FILTER_IDS);
1:3306467:                 if (filter != null) {
1:3306467:                     noLocal = true;
1:3306467:                     supportedFilters.put(filter.getKey(), filter.getValue());
1:3306467:                 }
1:3306467:             }
1:3306467: 
1:3306467:             ActiveMQDestination destination;
1:3306467:             if (source == null) {
1:3306467:                 // Attempt to recover previous subscription
1:b5c6264:                 ConsumerInfo storedInfo = connection.lookupSubscription(protonSender.getName());
1:3306467: 
1:b5c6264:                 if (storedInfo != null) {
1:b5c6264:                     destination = storedInfo.getDestination();
1:b5c6264: 
1:3306467:                     source = new org.apache.qpid.proton.amqp.messaging.Source();
1:3306467:                     source.setAddress(destination.getQualifiedName());
1:3306467:                     source.setDurable(TerminusDurability.UNSETTLED_STATE);
1:3306467:                     source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
1:3306467:                     source.setDistributionMode(COPY);
1:b5c6264: 
1:b5c6264:                     if (storedInfo.isNoLocal()) {
1:17bcf43:                         supportedFilters.put(NO_LOCAL_NAME, AmqpNoLocalFilter.NO_LOCAL);
1:b5c6264:                     }
1:b5c6264: 
1:b5c6264:                     if (storedInfo.getSelector() != null && !storedInfo.getSelector().trim().equals("")) {
1:17bcf43:                         supportedFilters.put(JMS_SELECTOR_NAME, new AmqpJmsSelectorFilter(storedInfo.getSelector()));
1:b5c6264:                     }
1:3306467:                 } else {
1:3306467:                     sender.close(new ErrorCondition(AmqpError.NOT_FOUND, "Unknown subscription link: " + protonSender.getName()));
1:3306467:                     return;
1:b5c6264:                 }
1:3306467:             } else if (source.getDynamic()) {
1:3306467:                 destination = connection.createTemporaryDestination(protonSender, source.getCapabilities());
1:10fc397: 
1:4a1c05b:                 Map<Symbol, Object> dynamicNodeProperties = new HashMap<>();
1:10fc397:                 dynamicNodeProperties.put(LIFETIME_POLICY, DeleteOnClose.getInstance());
1:10fc397: 
1:10fc397:                 // Currently we only support temporary destinations with delete on close lifetime policy.
1:3306467:                 source = new org.apache.qpid.proton.amqp.messaging.Source();
1:3306467:                 source.setAddress(destination.getQualifiedName());
1:10fc397:                 source.setCapabilities(AmqpSupport.getDestinationTypeSymbol(destination));
1:3306467:                 source.setDynamic(true);
1:10fc397:                 source.setDynamicNodeProperties(dynamicNodeProperties);
1:10fc397: 
1:3306467:                 sender.addCloseAction(new Runnable() {
1:b5c6264: 
1:3306467:                     @Override
1:3306467:                     public void run() {
1:3306467:                         connection.deleteTemporaryDestination((ActiveMQTempDestination) sender.getDestination());
1:3306467:                     }
1:3306467:                 });
1:3306467:             } else {
1:3306467:                 destination = createDestination(source);
1:b313209:                 if (destination.isTemporary()) {
1:b313209:                     String connectionId = ((ActiveMQTempDestination) destination).getConnectionId();
1:b313209:                     if (connectionId == null) {
1:b313209:                         throw new AmqpProtocolException(AmqpError.INVALID_FIELD.toString(), "Not a broker created temp destination");
1:b313209:                     }
1:b313209:                 }
1:3306467:             }
1:3306467: 
1:3306467:             source.setFilter(supportedFilters.isEmpty() ? null : supportedFilters);
1:3306467:             protonSender.setSource(source);
1:3306467: 
1:3306467:             int senderCredit = protonSender.getRemoteCredit();
1:3306467: 
1:a35e8dc:             // Allows the options on the destination to configure the consumerInfo
1:a35e8dc:             if (destination.getOptions() != null) {
1:a35e8dc:                 Map<String, Object> options = IntrospectionSupport.extractProperties(
1:a35e8dc:                     new HashMap<String, Object>(destination.getOptions()), "consumer.");
1:a35e8dc:                 IntrospectionSupport.setProperties(consumerInfo, options);
1:a35e8dc:                 if (options.size() > 0) {
1:a35e8dc:                     String msg = "There are " + options.size()
1:a35e8dc:                         + " consumer options that couldn't be set on the consumer."
1:a35e8dc:                         + " Check the options are spelled correctly."
1:a35e8dc:                         + " Unknown parameters=[" + options + "]."
1:a35e8dc:                         + " This consumer cannot be started.";
1:a35e8dc:                     LOG.warn(msg);
1:a35e8dc:                     throw new AmqpProtocolException(AmqpError.INVALID_FIELD.toString(), msg);
1:a35e8dc:                 }
1:a35e8dc:             }
1:a35e8dc: 
1:3306467:             consumerInfo.setSelector(selector);
1:3306467:             consumerInfo.setNoRangeAcks(true);
1:3306467:             consumerInfo.setDestination(destination);
1:3306467:             consumerInfo.setPrefetchSize(senderCredit >= 0 ? senderCredit : 0);
1:3306467:             consumerInfo.setDispatchAsync(true);
1:3306467:             consumerInfo.setNoLocal(noLocal);
1:3306467: 
1:3306467:             if (source.getDistributionMode() == COPY && destination.isQueue()) {
1:3306467:                 consumerInfo.setBrowser(true);
1:3306467:             }
1:3306467: 
1:3306467:             if ((TerminusDurability.UNSETTLED_STATE.equals(source.getDurable()) ||
1:3306467:                  TerminusDurability.CONFIGURATION.equals(source.getDurable())) && destination.isTopic()) {
1:3306467:                 consumerInfo.setSubscriptionName(protonSender.getName());
1:3306467:             }
1:3306467: 
1:3306467:             connection.sendToActiveMQ(consumerInfo, new ResponseHandler() {
1:3306467:                 @Override
1:3306467:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:3306467:                     if (response.isException()) {
1:3306467:                         ErrorCondition error = null;
1:3306467:                         Throwable exception = ((ExceptionResponse) response).getException();
1:3306467:                         if (exception instanceof SecurityException) {
1:3306467:                             error = new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage());
1:3306467:                         } else if (exception instanceof InvalidSelectorException) {
1:3306467:                             error = new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage());
1:3306467:                         } else {
1:3306467:                             error = new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage());
1:3306467:                         }
1:3306467: 
1:3306467:                         sender.close(error);
1:3306467:                     } else {
1:3306467:                         sender.open();
1:3306467:                     }
1:3306467:                     pumpProtonToSocket();
1:3306467:                 }
1:3306467:             });
1:3306467: 
1:3306467:         } catch (AmqpProtocolException e) {
1:3306467:             sender.close(new ErrorCondition(Symbol.getSymbol(e.getSymbolicName()), e.getMessage()));
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * Send all pending work out to the remote peer.
1:3306467:      */
1:3306467:     public void pumpProtonToSocket() {
1:3306467:         connection.pumpProtonToSocket();
1:3306467:     }
1:3306467: 
1:3a5f127:     public void registerSender(ConsumerId consumerId, AmqpSender sender) {
1:3306467:         consumers.put(consumerId, sender);
1:3a5f127:         connection.registerSender(consumerId, sender);
1:3306467:     }
1:3306467: 
1:3306467:     public void unregisterSender(ConsumerId consumerId) {
1:3306467:         consumers.remove(consumerId);
1:3a5f127:         connection.unregisterSender(consumerId);
1:3306467:     }
1:3306467: 
1:ed26683:     public void enlist(TransactionId txId) {
1:ed26683:         if (!enlisted) {
1:ed26683:             connection.getTxCoordinator(txId).enlist(this);
1:ed26683:             enlisted = true;
1:ed26683:         }
1:ed26683:     }
1:ed26683: 
1:3306467:     //----- Configuration accessors ------------------------------------------//
1:3306467: 
1:3306467:     public AmqpConnection getConnection() {
1:3306467:         return connection;
1:3306467:     }
1:3306467: 
1:3306467:     public SessionId getSessionId() {
1:3306467:         return sessionId;
1:3306467:     }
1:3306467: 
1:3306467:     public Session getEndpoint() {
1:3306467:         return protonSession;
1:3306467:     }
1:3306467: 
1:7c41ebc:     public long getMaxFrameSize() {
1:7c41ebc:         return connection.getMaxFrameSize();
1:7c41ebc:     }
1:7c41ebc: 
1:3306467:     //----- Internal Implementation ------------------------------------------//
1:3306467: 
1:b313209:     private ConsumerId getNextConsumerId() {
1:3306467:         return new ConsumerId(sessionId, nextConsumerId++);
1:3306467:     }
1:3306467: 
1:b313209:     private ProducerId getNextProducerId() {
1:3306467:         return new ProducerId(sessionId, nextProducerId++);
1:3306467:     }
1:3306467: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:4a1c05b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ConsumerId, AmqpSender> consumers = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                 Map<Symbol, Object> dynamicNodeProperties = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:             Symbol[] remoteDesiredCapabilities = protonReceiver.getRemoteDesiredCapabilities();
1:             if (remoteDesiredCapabilities != null) {
1:                 List<Symbol> list = Arrays.asList(remoteDesiredCapabilities);
1:                 if (list.contains(AmqpSupport.DELAYED_DELIVERY)) {
1:                     protonReceiver.setOfferedCapabilities(new Symbol[] { AmqpSupport.DELAYED_DELIVERY });
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:             final Map<Symbol, Object> supportedFilters = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                 Map<Symbol, Object> dynamicNodeProperties = new HashMap<>();
commit:10fc397
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.AmqpSupport.LIFETIME_POLICY;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.AmqpSupport;
1: import org.apache.qpid.proton.amqp.messaging.DeleteOnClose;
/////////////////////////////////////////////////////////////////////////
1: 
0:                 Map<Symbol, Object> dynamicNodeProperties = new HashMap<Symbol, Object>();
1:                 dynamicNodeProperties.put(LIFETIME_POLICY, DeleteOnClose.getInstance());
1: 
1:                 // Currently we only support temporary destinations with delete on close lifetime policy.
1:                 actualTarget.setCapabilities(AmqpSupport.getDestinationTypeSymbol(destination));
1:                 actualTarget.setDynamicNodeProperties(dynamicNodeProperties);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                 Map<Symbol, Object> dynamicNodeProperties = new HashMap<Symbol, Object>();
1:                 dynamicNodeProperties.put(LIFETIME_POLICY, DeleteOnClose.getInstance());
1: 
1:                 // Currently we only support temporary destinations with delete on close lifetime policy.
1:                 source.setCapabilities(AmqpSupport.getDestinationTypeSymbol(destination));
1:                 source.setDynamicNodeProperties(dynamicNodeProperties);
1: 
commit:0dd806f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.LocalTransactionId;
/////////////////////////////////////////////////////////////////////////
1:      * @param txId
1:      *      The specific TransactionId that is being committed.
1:      *
1:     public void commit(LocalTransactionId txId) throws Exception {
1:             consumer.commit(txId);
/////////////////////////////////////////////////////////////////////////
1:      * @param txId
1:      *      The specific TransactionId that is being rolled back.
1:      *
1:     public void rollback(LocalTransactionId txId) throws Exception {
1:             consumer.rollback(txId);
commit:a35e8dc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IntrospectionSupport;
/////////////////////////////////////////////////////////////////////////
1:             // Allows the options on the destination to configure the consumerInfo
1:             if (destination.getOptions() != null) {
1:                 Map<String, Object> options = IntrospectionSupport.extractProperties(
1:                     new HashMap<String, Object>(destination.getOptions()), "consumer.");
1:                 IntrospectionSupport.setProperties(consumerInfo, options);
1:                 if (options.size() > 0) {
1:                     String msg = "There are " + options.size()
1:                         + " consumer options that couldn't be set on the consumer."
1:                         + " Check the options are spelled correctly."
1:                         + " Unknown parameters=[" + options + "]."
1:                         + " This consumer cannot be started.";
1:                     LOG.warn(msg);
1:                     throw new AmqpProtocolException(AmqpError.INVALID_FIELD.toString(), msg);
1:                 }
1:             }
1: 
commit:83827f2
/////////////////////////////////////////////////////////////////////////
1:         connection.sendToActiveMQ(new RemoveInfo(getSessionId()), new ResponseHandler() {
1:             @Override
1:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                 getEndpoint().setContext(null);
1:                 getEndpoint().close();
1:                 getEndpoint().free();
1:             }
1:         });
commit:ed26683
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
1:     private boolean enlisted;
/////////////////////////////////////////////////////////////////////////
1: 
1:         enlisted = false;
/////////////////////////////////////////////////////////////////////////
1: 
1:         enlisted = false;
/////////////////////////////////////////////////////////////////////////
1:     public void enlist(TransactionId txId) {
1:         if (!enlisted) {
1:             connection.getTxCoordinator(txId).enlist(this);
1:             enlisted = true;
1:         }
1:     }
1: 
commit:17bcf43
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         supportedFilters.put(NO_LOCAL_NAME, AmqpNoLocalFilter.NO_LOCAL);
1:                         supportedFilters.put(JMS_SELECTOR_NAME, new AmqpJmsSelectorFilter(storedInfo.getSelector()));
commit:ffcd99a
/////////////////////////////////////////////////////////////////////////
0:                         supportedFilters.put(NO_LOCAL_NAME, AmqpJmsNoLocalType.NO_LOCAL);
0:                         supportedFilters.put(JMS_SELECTOR_NAME, new AmqpJmsSelectorType(storedInfo.getSelector()));
commit:b5c6264
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_NAME;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_NAME;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.jms.provider.amqp.AmqpJmsNoLocalType;
0: import org.apache.qpid.jms.provider.amqp.AmqpJmsSelectorType;
/////////////////////////////////////////////////////////////////////////
1:                 ConsumerInfo storedInfo = connection.lookupSubscription(protonSender.getName());
1:                 if (storedInfo != null) {
1:                     destination = storedInfo.getDestination();
1: 
1: 
0:                     Map<Symbol, DescribedType> filters = new HashMap<Symbol, DescribedType>();
1:                     if (storedInfo.isNoLocal()) {
0:                         filters.put(NO_LOCAL_NAME, AmqpJmsNoLocalType.NO_LOCAL);
1:                     }
1: 
1:                     if (storedInfo.getSelector() != null && !storedInfo.getSelector().trim().equals("")) {
0:                         filters.put(JMS_SELECTOR_NAME, new AmqpJmsSelectorType(storedInfo.getSelector()));
1:                     }
1: 
0:                     if (!filters.isEmpty()) {
0:                         source.setFilter(filters);
1:                     }
commit:7c41ebc
/////////////////////////////////////////////////////////////////////////
1:     public long getMaxFrameSize() {
1:         return connection.getMaxFrameSize();
1:     }
1: 
commit:b313209
/////////////////////////////////////////////////////////////////////////
1:                 if (destination.isTemporary()) {
1:                     String connectionId = ((ActiveMQTempDestination) destination).getConnectionId();
1:                     if (connectionId == null) {
1:                         throw new AmqpProtocolException(AmqpError.PRECONDITION_FAILED.toString(), "Not a broker created temp destination");
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (destination.isTemporary()) {
1:                     String connectionId = ((ActiveMQTempDestination) destination).getConnectionId();
1:                     if (connectionId == null) {
1:                         throw new AmqpProtocolException(AmqpError.INVALID_FIELD.toString(), "Not a broker created temp destination");
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     private ConsumerId getNextConsumerId() {
1:     private ProducerId getNextProducerId() {
commit:f0ebda7
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Session {} opened", getSessionId());
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Session {} closed", getSessionId());
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("opening new receiver {} on link: {}", producerInfo.getProducerId(), protonReceiver.getName());
1: 
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("opening new sender {} on link: {}", consumerInfo.getConsumerId(), protonSender.getName());
1: 
commit:3306467
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.protocol;
1: 
1: import static org.apache.activemq.transport.amqp.AmqpSupport.COPY;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_FILTER_IDS;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_FILTER_IDS;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.createDestination;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.findFilter;
1: 
1: import java.io.IOException;
1: import java.util.HashMap;
1: import java.util.Map;
1: 
1: import javax.jms.InvalidSelectorException;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQTempDestination;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.SessionInfo;
1: import org.apache.activemq.selector.SelectorParser;
1: import org.apache.activemq.transport.amqp.AmqpProtocolConverter;
1: import org.apache.activemq.transport.amqp.AmqpProtocolException;
1: import org.apache.activemq.transport.amqp.ResponseHandler;
1: import org.apache.qpid.proton.amqp.DescribedType;
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.amqp.messaging.Target;
1: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
1: import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
1: import org.apache.qpid.proton.amqp.transport.AmqpError;
1: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
1: import org.apache.qpid.proton.engine.Receiver;
1: import org.apache.qpid.proton.engine.Sender;
1: import org.apache.qpid.proton.engine.Session;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Wraps the AMQP Session and provides the services needed to manage the remote
1:  * peer requests for link establishment.
1:  */
1: public class AmqpSession implements AmqpResource {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AmqpSession.class);
1: 
0:     private final Map<ConsumerId, AmqpSender> consumers = new HashMap<ConsumerId, AmqpSender>();
1: 
1:     private final AmqpConnection connection;
1:     private final Session protonSession;
1:     private final SessionId sessionId;
1: 
1:     private long nextProducerId = 0;
1:     private long nextConsumerId = 0;
1: 
1:     /**
1:      * Create new AmqpSession instance whose parent is the given AmqpConnection.
1:      *
1:      * @param connection
1:      *        the parent connection for this session.
1:      * @param sessionId
1:      *        the ActiveMQ SessionId that is used to identify this session.
1:      * @param session
1:      *        the AMQP Session that this class manages.
1:      */
1:     public AmqpSession(AmqpConnection connection, SessionId sessionId, Session session) {
1:         this.connection = connection;
1:         this.sessionId = sessionId;
1:         this.protonSession = session;
1:     }
1: 
1:     @Override
1:     public void open() {
0:         LOG.trace("Session {} opened", getSessionId());
1: 
1:         getEndpoint().setContext(this);
1:         getEndpoint().setIncomingCapacity(Integer.MAX_VALUE);
1:         getEndpoint().open();
1: 
1:         connection.sendToActiveMQ(new SessionInfo(getSessionId()));
1:     }
1: 
1:     @Override
1:     public void close() {
0:         LOG.trace("Session {} closed", getSessionId());
1: 
0:         getEndpoint().setContext(null);
0:         getEndpoint().close();
0:         getEndpoint().free();
1: 
0:         connection.sendToActiveMQ(new RemoveInfo(getSessionId()));
1:     }
1: 
1:     /**
1:      * Commits all pending work for all resources managed under this session.
1:      *
1:      * @throws Exception if an error occurs while attempting to commit work.
1:      */
0:     public void commit() throws Exception {
1:         for (AmqpSender consumer : consumers.values()) {
0:             consumer.commit();
1:         }
1:     }
1: 
1:     /**
1:      * Rolls back any pending work being down under this session.
1:      *
1:      * @throws Exception if an error occurs while attempting to roll back work.
1:      */
0:     public void rollback() throws Exception {
1:         for (AmqpSender consumer : consumers.values()) {
0:             consumer.rollback();
1:         }
1:     }
1: 
1:     /**
1:      * Used to direct all Session managed Senders to push any queued Messages
1:      * out to the remote peer.
1:      *
1:      * @throws Exception if an error occurs while flushing the messages.
1:      */
1:     public void flushPendingMessages() throws Exception {
1:         for (AmqpSender consumer : consumers.values()) {
1:             consumer.pumpOutbound();
1:         }
1:     }
1: 
1:     public void createCoordinator(final Receiver protonReceiver) throws Exception {
1:         AmqpTransactionCoordinator txCoordinator = new AmqpTransactionCoordinator(this, protonReceiver);
1:         txCoordinator.flow(connection.getConfiguredReceiverCredit());
1:         txCoordinator.open();
1:     }
1: 
1:     public void createReceiver(final Receiver protonReceiver) throws Exception {
1:         org.apache.qpid.proton.amqp.transport.Target remoteTarget = protonReceiver.getRemoteTarget();
1: 
1:         ProducerInfo producerInfo = new ProducerInfo(getNextProducerId());
1:         final AmqpReceiver receiver = new AmqpReceiver(this, protonReceiver, producerInfo);
1: 
1:         try {
1:             Target target = (Target) remoteTarget;
1:             ActiveMQDestination destination = null;
1:             String targetNodeName = target.getAddress();
1: 
1:             if (target.getDynamic()) {
1:                 destination = connection.createTemporaryDestination(protonReceiver, target.getCapabilities());
1:                 Target actualTarget = new Target();
1:                 actualTarget.setAddress(destination.getQualifiedName());
1:                 actualTarget.setDynamic(true);
1:                 protonReceiver.setTarget(actualTarget);
1:                 receiver.addCloseAction(new Runnable() {
1: 
1:                     @Override
1:                     public void run() {
1:                         connection.deleteTemporaryDestination((ActiveMQTempDestination) receiver.getDestination());
1:                     }
1:                 });
1:             } else if (targetNodeName != null && !targetNodeName.isEmpty()) {
1:                 destination = createDestination(remoteTarget);
1:             }
1: 
1:             receiver.setDestination(destination);
1:             connection.sendToActiveMQ(producerInfo, new ResponseHandler() {
1:                 @Override
1:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                     if (response.isException()) {
1:                         ErrorCondition error = null;
1:                         Throwable exception = ((ExceptionResponse) response).getException();
1:                         if (exception instanceof SecurityException) {
1:                             error = new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage());
1:                         } else {
1:                             error = new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage());
1:                         }
1: 
1:                         receiver.close(error);
1:                     } else {
1:                         receiver.flow(connection.getConfiguredReceiverCredit());
1:                         receiver.open();
1:                     }
1:                     pumpProtonToSocket();
1:                 }
1:             });
1: 
1:         } catch (AmqpProtocolException exception) {
1:             receiver.close(new ErrorCondition(Symbol.getSymbol(exception.getSymbolicName()), exception.getMessage()));
1:         }
1:     }
1: 
1:     @SuppressWarnings("unchecked")
1:     public void createSender(final Sender protonSender) throws Exception {
1:         org.apache.qpid.proton.amqp.messaging.Source source = (org.apache.qpid.proton.amqp.messaging.Source) protonSender.getRemoteSource();
1: 
1:         ConsumerInfo consumerInfo = new ConsumerInfo(getNextConsumerId());
1:         final AmqpSender sender = new AmqpSender(this, protonSender, consumerInfo);
1: 
1:         try {
0:             final Map<Symbol, Object> supportedFilters = new HashMap<Symbol, Object>();
1:             protonSender.setContext(sender);
1: 
1:             boolean noLocal = false;
1:             String selector = null;
1: 
1:             if (source != null) {
1:                 Map.Entry<Symbol, DescribedType> filter = findFilter(source.getFilter(), JMS_SELECTOR_FILTER_IDS);
1:                 if (filter != null) {
1:                     selector = filter.getValue().getDescribed().toString();
1:                     // Validate the Selector.
1:                     try {
1:                         SelectorParser.parse(selector);
1:                     } catch (InvalidSelectorException e) {
1:                         sender.close(new ErrorCondition(AmqpError.INVALID_FIELD, e.getMessage()));
1:                         return;
1:                     }
1: 
1:                     supportedFilters.put(filter.getKey(), filter.getValue());
1:                 }
1: 
1:                 filter = findFilter(source.getFilter(), NO_LOCAL_FILTER_IDS);
1:                 if (filter != null) {
1:                     noLocal = true;
1:                     supportedFilters.put(filter.getKey(), filter.getValue());
1:                 }
1:             }
1: 
1:             ActiveMQDestination destination;
1:             if (source == null) {
1:                 // Attempt to recover previous subscription
0:                 destination = connection.lookupSubscription(protonSender.getName());
1: 
0:                 if (destination != null) {
1:                     source = new org.apache.qpid.proton.amqp.messaging.Source();
1:                     source.setAddress(destination.getQualifiedName());
1:                     source.setDurable(TerminusDurability.UNSETTLED_STATE);
1:                     source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
1:                     source.setDistributionMode(COPY);
1:                 } else {
1:                     sender.close(new ErrorCondition(AmqpError.NOT_FOUND, "Unknown subscription link: " + protonSender.getName()));
1:                     return;
1:                 }
1:             } else if (source.getDynamic()) {
0:                 // lets create a temp dest.
1:                 destination = connection.createTemporaryDestination(protonSender, source.getCapabilities());
1:                 source = new org.apache.qpid.proton.amqp.messaging.Source();
1:                 source.setAddress(destination.getQualifiedName());
1:                 source.setDynamic(true);
1:                 sender.addCloseAction(new Runnable() {
1: 
1:                     @Override
1:                     public void run() {
1:                         connection.deleteTemporaryDestination((ActiveMQTempDestination) sender.getDestination());
1:                     }
1:                 });
1:             } else {
1:                 destination = createDestination(source);
1:             }
1: 
1:             source.setFilter(supportedFilters.isEmpty() ? null : supportedFilters);
1:             protonSender.setSource(source);
1: 
1:             int senderCredit = protonSender.getRemoteCredit();
1: 
1:             consumerInfo.setSelector(selector);
1:             consumerInfo.setNoRangeAcks(true);
1:             consumerInfo.setDestination(destination);
1:             consumerInfo.setPrefetchSize(senderCredit >= 0 ? senderCredit : 0);
1:             consumerInfo.setDispatchAsync(true);
1:             consumerInfo.setNoLocal(noLocal);
1: 
1:             if (source.getDistributionMode() == COPY && destination.isQueue()) {
1:                 consumerInfo.setBrowser(true);
1:             }
1: 
1:             if ((TerminusDurability.UNSETTLED_STATE.equals(source.getDurable()) ||
1:                  TerminusDurability.CONFIGURATION.equals(source.getDurable())) && destination.isTopic()) {
1:                 consumerInfo.setSubscriptionName(protonSender.getName());
1:             }
1: 
1:             connection.sendToActiveMQ(consumerInfo, new ResponseHandler() {
1:                 @Override
1:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                     if (response.isException()) {
1:                         ErrorCondition error = null;
1:                         Throwable exception = ((ExceptionResponse) response).getException();
1:                         if (exception instanceof SecurityException) {
1:                             error = new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage());
1:                         } else if (exception instanceof InvalidSelectorException) {
1:                             error = new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage());
1:                         } else {
1:                             error = new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage());
1:                         }
1: 
1:                         sender.close(error);
1:                     } else {
1:                         sender.open();
1:                     }
1:                     pumpProtonToSocket();
1:                 }
1:             });
1: 
1:         } catch (AmqpProtocolException e) {
1:             sender.close(new ErrorCondition(Symbol.getSymbol(e.getSymbolicName()), e.getMessage()));
1:         }
1:     }
1: 
1:     /**
1:      * Send all pending work out to the remote peer.
1:      */
1:     public void pumpProtonToSocket() {
1:         connection.pumpProtonToSocket();
1:     }
1: 
0:     public void regosterSender(ConsumerId consumerId, AmqpSender sender) {
1:         consumers.put(consumerId, sender);
0:         connection.regosterSender(consumerId, sender);
1:     }
1: 
1:     public void unregisterSender(ConsumerId consumerId) {
1:         consumers.remove(consumerId);
0:         connection.unregosterSender(consumerId);
1:     }
1: 
1:     //----- Configuration accessors ------------------------------------------//
1: 
1:     public AmqpConnection getConnection() {
1:         return connection;
1:     }
1: 
1:     public SessionId getSessionId() {
1:         return sessionId;
1:     }
1: 
1:     public Session getEndpoint() {
1:         return protonSession;
1:     }
1: 
1:     //----- Internal Implementation ------------------------------------------//
1: 
0:     protected ConsumerId getNextConsumerId() {
1:         return new ConsumerId(sessionId, nextConsumerId++);
1:     }
1: 
0:     protected ProducerId getNextProducerId() {
1:         return new ProducerId(sessionId, nextProducerId++);
1:     }
1: }
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:3a5f127
/////////////////////////////////////////////////////////////////////////
1:     public void registerSender(ConsumerId consumerId, AmqpSender sender) {
1:         connection.registerSender(consumerId, sender);
1:         connection.unregisterSender(consumerId);
============================================================================