1:740f5b3: /**
1:740f5b3:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:740f5b3:  * contributor license agreements.  See the NOTICE file distributed with
1:740f5b3:  * this work for additional information regarding copyright ownership.
1:740f5b3:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:740f5b3:  * (the "License"); you may not use this file except in compliance with
1:740f5b3:  * the License.  You may obtain a copy of the License at
1:740f5b3:  *
1:740f5b3:  *      http://www.apache.org/licenses/LICENSE-2.0
1:740f5b3:  *
1:740f5b3:  * Unless required by applicable law or agreed to in writing, software
1:740f5b3:  * distributed under the License is distributed on an "AS IS" BASIS,
1:740f5b3:  * WITHOUT WARRANTIES OR ONDITIONS OF ANY KIND, either express or implied.
1:740f5b3:  * See the License for the specific language governing permissions and
1:740f5b3:  * limitations under the License.
1:740f5b3:  */
1:740f5b3: package org.apache.activemq.usecases;
2:740f5b3: 
1:740f5b3: import static org.junit.Assert.assertEquals;
1:740f5b3: import static org.junit.Assert.assertTrue;
1:740f5b3: import static org.junit.Assert.fail;
1:740f5b3: 
1:740f5b3: import java.io.File;
1:740f5b3: import java.io.IOException;
1:740f5b3: import java.util.ArrayList;
1:740f5b3: import java.util.Vector;
1:740f5b3: import java.util.concurrent.CopyOnWriteArrayList;
1:740f5b3: import java.util.concurrent.TimeUnit;
1:c0b3961: import java.util.concurrent.atomic.AtomicBoolean;
1:740f5b3: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:740f5b3: 
1:740f5b3: import javax.jms.Connection;
1:740f5b3: import javax.jms.ConnectionFactory;
1:740f5b3: import javax.jms.JMSException;
1:740f5b3: import javax.jms.Message;
1:740f5b3: import javax.jms.MessageConsumer;
1:740f5b3: import javax.jms.MessageProducer;
1:740f5b3: import javax.jms.Session;
1:740f5b3: import javax.management.ObjectName;
1:740f5b3: 
1:740f5b3: import org.apache.activemq.ActiveMQConnectionFactory;
1:740f5b3: import org.apache.activemq.broker.BrokerFactory;
1:740f5b3: import org.apache.activemq.broker.BrokerService;
1:740f5b3: import org.apache.activemq.command.ActiveMQTopic;
1:740f5b3: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:740f5b3: import org.apache.activemq.util.Wait;
1:740f5b3: import org.junit.After;
1:740f5b3: import org.junit.Before;
1:740f5b3: import org.junit.Test;
1:740f5b3: import org.slf4j.Logger;
1:740f5b3: import org.slf4j.LoggerFactory;
1:740f5b3: 
1:740f5b3: /*
1:740f5b3:  * A cut down version of DurableSubProcessWithRestartTest that focuses on kahaDB file retention
1:740f5b3:  */
1:740f5b3: public class DurableSubDelayedUnsubscribeTest {
1:740f5b3: 
1:740f5b3:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubDelayedUnsubscribeTest.class);
1:740f5b3: 
1:740f5b3:     private static final long RUNTIME = 2 * 60 * 1000;
1:740f5b3:     private static final int CARGO_SIZE = 400; // max
1:740f5b3:     private static final int MAX_CLIENTS = 15;
1:740f5b3:     private static boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:740f5b3:     private static final Vector<Throwable> exceptions = new Vector<Throwable>();
1:740f5b3: 
1:740f5b3:     private BrokerService broker;
1:740f5b3:     private ActiveMQTopic topic;
1:740f5b3: 
1:740f5b3:     private ClientManager clientManager;
1:740f5b3:     private Server server;
1:740f5b3:     private HouseKeeper houseKeeper;
1:740f5b3: 
1:740f5b3:     private final ReentrantReadWriteLock processLock = new ReentrantReadWriteLock(true);
1:740f5b3: 
1:740f5b3:     @Test
1:740f5b3:     public void testProcess() throws Exception {
1:740f5b3: 
1:740f5b3:         server.start();
1:740f5b3:         clientManager.start();
1:740f5b3: 
1:740f5b3:         houseKeeper.start();
1:740f5b3: 
1:740f5b3:         // Sleep to
1:740f5b3:         Thread.sleep(RUNTIME);
1:740f5b3: 
1:740f5b3:         // inform message producer to stop
1:740f5b3:         server.stopped = true;
1:740f5b3: 
1:740f5b3:         // add one Subscriber to the topic that will not be unsubscribed.
1:740f5b3:         // should not have any pending messages in the kahadb store
1:740f5b3:         Client lastClient = new Client(32000, ClientType.A);
1:740f5b3:         lastClient.process(1000);
1:740f5b3: 
1:740f5b3:         // stop client manager from creating any more clients
1:740f5b3:         clientManager.stopped = true;
1:740f5b3: 
1:740f5b3:         final BrokerService brokerService = this.broker;
1:740f5b3: 
1:740f5b3:         // Wait for all client subscription to be unsubscribed or swept away.
1:c0b3961:         // Ensure we sleep longer than the housekeeper's sweep delay otherwise we can
1:c0b3961:         // miss the fact that all durables that were abandoned do finally get cleaned up.
1:740f5b3: 
1:c45523f:         // Wait for all clients to stop
1:c45523f:         Wait.waitFor(new Wait.Condition() {
1:c45523f:             public boolean isSatisified() throws Exception {
1:c45523f:                 return clientManager.getClientCount() == 0;
1:c45523f:             }
1:c45523f:         }, Client.lifetime + TimeUnit.SECONDS.toMillis(10));
1:c45523f: 
1:740f5b3:         assertTrue("should have only one inactiveSubscriber subscribed but was: " + brokerService.getAdminView().getInactiveDurableTopicSubscribers().length,
1:740f5b3:             Wait.waitFor(new Wait.Condition() {
1:740f5b3: 
1:740f5b3:                 @Override
1:740f5b3:                 public boolean isSatisified() throws Exception {
1:740f5b3:                     return brokerService.getAdminView().getInactiveDurableTopicSubscribers().length == 1;
1:740f5b3:                 }
1:c45523f:             }, houseKeeper.SWEEP_DELAY * 2));
1:740f5b3: 
1:740f5b3:         assertTrue("should be no subscribers subscribed but was: " + brokerService.getAdminView().getDurableTopicSubscribers().length,
1:740f5b3:             Wait.waitFor(new Wait.Condition() {
1:740f5b3: 
1:740f5b3:                 @Override
1:740f5b3:                 public boolean isSatisified() throws Exception {
1:740f5b3:                     return brokerService.getAdminView().getDurableTopicSubscribers().length == 0;
1:740f5b3:                 }
2:740f5b3:             }, TimeUnit.MINUTES.toMillis(3)));
1:740f5b3: 
1:740f5b3:         processLock.writeLock().lock();
1:740f5b3: 
1:740f5b3:         // check outcome.
1:740f5b3: 
1:740f5b3:         ObjectName[] subscribers = broker.getAdminView().getDurableTopicSubscribers();
1:740f5b3:         ObjectName[] inactiveSubscribers = broker.getAdminView().getInactiveDurableTopicSubscribers();
1:740f5b3:         final KahaDBPersistenceAdapter persistenceAdapter = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
1:740f5b3: 
1:740f5b3:         printDebugClientInfo(subscribers, inactiveSubscribers, persistenceAdapter);
1:740f5b3: 
1:740f5b3:         assertEquals("should have only one inactiveSubscriber subscribed", 1, broker.getAdminView().getInactiveDurableTopicSubscribers().length);
1:740f5b3:         assertEquals("should be no subscribers subscribed", 0, broker.getAdminView().getDurableTopicSubscribers().length);
1:740f5b3: 
1:740f5b3:         final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
1:740f5b3:         assertTrue("should be less than 3 journal file left but was: " + persistenceAdapter.getStore().getJournal().getFileMap().size(),
1:740f5b3:             Wait.waitFor(new Wait.Condition() {
1:740f5b3: 
1:740f5b3:                 @Override
1:740f5b3:                 public boolean isSatisified() throws Exception {
1:740f5b3:                     return pa.getStore().getJournal().getFileMap().size() <= 3;
1:740f5b3:                 }
1:740f5b3:             }, TimeUnit.MINUTES.toMillis(3)));
1:740f5b3: 
1:c0b3961:         // Be good and cleanup our mess a bit.
1:c0b3961:         this.houseKeeper.shutdown();
1:c0b3961: 
1:740f5b3:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:740f5b3: 
1:740f5b3:         LOG.info("DONE.");
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {
1:740f5b3: 
1:740f5b3:         LOG.info("====>>> START DEBUG Subscriber INFO");
1:740f5b3: 
1:740f5b3:         LOG.info("Number of subscribers subscribed as seen through JMX is" + subscribers.length);
1:740f5b3: 
1:740f5b3:         for (int i = 0; i < subscribers.length; i++) {
1:740f5b3:             LOG.info("subscribers subscribed as seen throngh JMX: " + subscribers[i]);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         LOG.info("Number of inactiveSubscribers subscribed as seen through JMX is" + inactiveSubscribers.length);
1:740f5b3: 
1:740f5b3:         for (int i = 0; i < inactiveSubscribers.length; i++) {
1:740f5b3:             LOG.info("subscribers subscribed as seen throngh JMX: " + inactiveSubscribers[i]);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         LOG.info("ClientManager.clients size is" + clientManager.clients.size());
1:740f5b3: 
1:740f5b3:         for (int i = 0; i < clientManager.clients.size(); i++) {
1:740f5b3:             LOG.info("clients is: " + clientManager.clients.get(i));
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         LOG.info("housekeep.subscriptions size is " + houseKeeper.abandonedSubscriptions.size());
1:740f5b3: 
1:740f5b3:         for (int i = 0; i < houseKeeper.abandonedSubscriptions.size(); i++) {
1:740f5b3:             LOG.info("housekeep is: " + houseKeeper.abandonedSubscriptions.get(i));
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         LOG.info("number of journal files left" + pa.getStore().getJournal().getFileMap().size());
1:740f5b3: 
1:740f5b3:         LOG.info("====>>> END DEBUG Subscriber INFO");
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     /**
1:740f5b3:      * Creates batch of messages in a transaction periodically. The last message
1:740f5b3:      * in the transaction is always a special message what contains info about
1:740f5b3:      * the whole transaction.
1:740f5b3:      * <p>
1:740f5b3:      * Notifies the clients about the created messages also.
1:740f5b3:      */
1:740f5b3:     final class Server extends Thread {
1:740f5b3: 
1:740f5b3:         public boolean stopped;
1:740f5b3:         final String url = "vm://" + DurableSubDelayedUnsubscribeTest.getName() + "?"
1:740f5b3:                 + "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&"
1:740f5b3:                 + "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&" + "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&"
1:740f5b3:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=false&" + "jms.watchTopicAdvisories=false&" + "waitForStart=200&create=false";
1:740f5b3:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:740f5b3: 
1:740f5b3:         final Object sendMutex = new Object();
1:740f5b3:         final String[] cargos = new String[500];
1:740f5b3: 
1:740f5b3:         int transRover = 0;
1:740f5b3:         int messageRover = 0;
1:740f5b3: 
1:740f5b3:         public Server() {
1:740f5b3:             super("Server");
1:740f5b3:             setDaemon(true);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         @Override
1:740f5b3:         public void run() {
1:740f5b3:             try {
2:740f5b3:                 while (true) {
1:740f5b3: 
1:740f5b3:                     if (stopped) {
1:740f5b3:                         // server should stop producing
1:740f5b3:                         break;
1:740f5b3:                     }
1:740f5b3: 
1:740f5b3:                     Thread.sleep(500);
1:740f5b3:                     processLock.readLock().lock();
1:740f5b3:                     try {
1:740f5b3:                         send();
1:740f5b3:                     } finally {
1:740f5b3:                         processLock.readLock().unlock();
1:740f5b3:                     }
1:740f5b3:                 }
1:740f5b3:             } catch (Throwable e) {
1:740f5b3:                 exit("Server.run failed", e);
1:740f5b3:             }
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public void send() throws JMSException {
1:740f5b3:             // do not create new clients now
1:740f5b3:             // ToDo: Test this case later.
1:740f5b3:             synchronized (sendMutex) {
1:740f5b3:                 int trans = ++transRover;
1:740f5b3:                 boolean relevantTrans = random(2) > 1;
1:740f5b3:                 ClientType clientType = relevantTrans ? ClientType.randomClientType() : null; // sends
1:740f5b3:                                                                                               // this
1:740f5b3:                                                                                               // types
1:740f5b3:                 int count = random(200);
1:740f5b3: 
1:740f5b3:                 LOG.info("Sending Trans[id=" + trans + ", count=" + count + ", clientType=" + clientType + "]");
1:740f5b3: 
1:740f5b3:                 Connection con = cf.createConnection();
1:740f5b3:                 Session sess = con.createSession(true, Session.SESSION_TRANSACTED);
1:740f5b3:                 MessageProducer prod = sess.createProducer(null);
1:740f5b3: 
1:740f5b3:                 for (int i = 0; i < count; i++) {
1:740f5b3:                     Message message = sess.createMessage();
1:740f5b3:                     message.setIntProperty("ID", ++messageRover);
1:740f5b3:                     message.setIntProperty("TRANS", trans);
1:740f5b3:                     String type = clientType != null ? clientType.randomMessageType() : ClientType.randomNonRelevantMessageType();
1:740f5b3:                     message.setStringProperty("TYPE", type);
1:740f5b3: 
1:740f5b3:                     if (CARGO_SIZE > 0)
1:740f5b3:                         message.setStringProperty("CARGO", getCargo(random(CARGO_SIZE)));
1:740f5b3: 
1:740f5b3:                     prod.send(topic, message);
1:740f5b3: 
1:740f5b3:                 }
1:740f5b3: 
1:740f5b3:                 Message message = sess.createMessage();
1:740f5b3:                 message.setIntProperty("ID", ++messageRover);
1:740f5b3:                 message.setIntProperty("TRANS", trans);
1:740f5b3:                 message.setBooleanProperty("COMMIT", true);
1:740f5b3:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:740f5b3:                 prod.send(topic, message);
1:740f5b3: 
1:740f5b3:                 sess.commit();
1:740f5b3:                 LOG.info("Committed Trans[id=" + trans + ", count=" + count + ", clientType=" + clientType + "], ID=" + messageRover);
1:740f5b3: 
1:740f5b3:                 sess.close();
1:740f5b3:                 con.close();
1:740f5b3:             }
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private String getCargo(int length) {
1:740f5b3:             if (length == 0)
1:740f5b3:                 return null;
1:740f5b3: 
1:740f5b3:             if (length < cargos.length) {
1:740f5b3:                 String result = cargos[length];
1:740f5b3:                 if (result == null) {
1:740f5b3:                     result = getCargoImpl(length);
1:740f5b3:                     cargos[length] = result;
1:740f5b3:                 }
1:740f5b3:                 return result;
1:740f5b3:             }
1:740f5b3:             return getCargoImpl(length);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private String getCargoImpl(int length) {
1:740f5b3:             StringBuilder sb = new StringBuilder(length);
1:740f5b3:             for (int i = length; --i >= 0;) {
1:740f5b3:                 sb.append('a');
1:740f5b3:             }
1:740f5b3:             return sb.toString();
1:740f5b3:         }
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     /**
1:740f5b3:      * Clients listen on different messages in the topic. The 'TYPE' property
1:740f5b3:      * helps the client to select the proper messages.
1:740f5b3:      */
1:740f5b3:     private enum ClientType {
1:740f5b3:         A("a", "b", "c"), B("c", "d", "e"), C("d", "e", "f"), D("g", "h");
1:740f5b3: 
1:740f5b3:         public final String[] messageTypes;
1:740f5b3: 
1:740f5b3:         public final String selector;
1:740f5b3: 
1:740f5b3:         ClientType(String... messageTypes) {
1:740f5b3:             this.messageTypes = messageTypes;
1:740f5b3: 
1:740f5b3:             StringBuilder sb = new StringBuilder("TYPE in (");
1:740f5b3:             for (int i = 0; i < messageTypes.length; i++) {
1:740f5b3:                 if (i > 0)
1:740f5b3:                     sb.append(", ");
1:740f5b3:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:740f5b3:             }
1:740f5b3:             sb.append(')');
1:740f5b3:             selector = sb.toString();
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public static ClientType randomClientType() {
1:740f5b3:             return values()[DurableSubDelayedUnsubscribeTest.random(values().length - 1)];
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public final String randomMessageType() {
1:740f5b3:             return messageTypes[DurableSubDelayedUnsubscribeTest.random(messageTypes.length - 1)];
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public static String randomNonRelevantMessageType() {
1:740f5b3:             return Integer.toString(DurableSubDelayedUnsubscribeTest.random(20));
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         @Override
1:740f5b3:         public final String toString() {
1:740f5b3:             return this.name() /* + '[' + selector + ']' */;
1:740f5b3:         }
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     /**
1:740f5b3:      * Creates new cliens.
1:740f5b3:      */
1:740f5b3:     private final class ClientManager extends Thread {
1:740f5b3: 
1:740f5b3:         private int clientRover = 0;
1:740f5b3: 
1:740f5b3:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1:740f5b3: 
1:740f5b3:         private boolean stopped;
1:740f5b3: 
1:740f5b3:         public ClientManager() {
1:740f5b3:             super("ClientManager");
1:740f5b3:             setDaemon(true);
1:740f5b3:         }
1:740f5b3: 
1:c45523f:         public int getClientCount() {
1:c45523f:             return clients.size();
1:c45523f:         }
1:c45523f: 
1:740f5b3:         @Override
1:740f5b3:         public void run() {
1:740f5b3:             try {
1:740f5b3:                 while (true) {
1:740f5b3:                     if (clients.size() < MAX_CLIENTS) {
1:740f5b3: 
1:740f5b3:                         if (stopped) {
1:740f5b3:                             // get out, don't start any more threads
1:740f5b3:                             break;
1:740f5b3:                         }
1:740f5b3:                         processLock.readLock().lock();
1:740f5b3:                         try {
1:740f5b3:                             createNewClient();
1:740f5b3:                         } finally {
1:740f5b3:                             processLock.readLock().unlock();
1:740f5b3:                         }
1:740f5b3:                     }
1:740f5b3: 
1:740f5b3:                     int size = clients.size();
1:740f5b3:                     sleepRandom(size * 3 * 1000, size * 6 * 1000);
1:740f5b3:                 }
1:740f5b3:             } catch (Throwable e) {
1:740f5b3:                 exit("ClientManager.run failed.", e);
1:740f5b3:             }
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private void createNewClient() throws JMSException {
1:740f5b3:             ClientType type = ClientType.randomClientType();
1:740f5b3: 
1:740f5b3:             Client client;
1:740f5b3:             synchronized (server.sendMutex) {
1:740f5b3:                 client = new Client(++clientRover, type);
1:740f5b3:                 clients.add(client);
1:740f5b3:             }
1:740f5b3:             client.start();
1:740f5b3: 
1:740f5b3:             LOG.info(client.toString() + " created. " + this);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public void removeClient(Client client) {
1:740f5b3:             clients.remove(client);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         @Override
1:740f5b3:         public String toString() {
1:740f5b3:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:740f5b3:             sb.append(clients.size());
1:740f5b3:             sb.append(", clients=");
1:740f5b3:             boolean sep = false;
1:740f5b3:             for (Client client : clients) {
1:740f5b3:                 if (sep)
1:740f5b3:                     sb.append(", ");
1:740f5b3:                 else
1:740f5b3:                     sep = true;
1:740f5b3:                 sb.append(client.toString());
1:740f5b3:             }
1:740f5b3:             sb.append(']');
1:740f5b3:             return sb.toString();
1:740f5b3:         }
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     /**
1:740f5b3:      * Consumes massages from a durable subscription. Goes online/offline
1:740f5b3:      * periodically. Checks the incoming messages against the sent messages of
1:740f5b3:      * the server.
1:740f5b3:      */
1:740f5b3:     private final class Client extends Thread {
1:740f5b3: 
1:740f5b3:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?" + "jms.watchTopicAdvisories=false&"
1:740f5b3:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&" + "jms.producerWindowSize=20971520&" + "jms.copyMessageOnSend=false&"
1:740f5b3:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&" + "useExponentialBackOff=true";
1:740f5b3:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:740f5b3: 
1:740f5b3:         public static final String SUBSCRIPTION_NAME = "subscription";
1:740f5b3: 
1:740f5b3:         private final int id;
1:740f5b3:         private final String conClientId;
1:740f5b3: 
1:c45523f:         public static final int lifetime = 60 * 1000;
1:740f5b3:         private final int online = 1 * 1000;
1:740f5b3:         private final int offline = 59 * 1000;
1:740f5b3: 
1:740f5b3:         private final ClientType clientType;
1:740f5b3:         private final String selector;
1:740f5b3: 
1:740f5b3:         public Client(int id, ClientType clientType) throws JMSException {
1:740f5b3:             super("Client" + id);
1:740f5b3:             setDaemon(true);
1:740f5b3: 
1:740f5b3:             this.id = id;
1:740f5b3:             conClientId = "cli" + id;
1:740f5b3:             this.clientType = clientType;
1:740f5b3:             selector = "(COMMIT = true and RELEVANT = true) or " + clientType.selector;
1:740f5b3: 
1:740f5b3:             subscribe();
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         @Override
1:740f5b3:         public void run() {
1:740f5b3:             // long end = System.currentTimeMillis() + lifetime.next();
1:740f5b3:             long end = System.currentTimeMillis() + lifetime;
1:740f5b3:             try {
1:740f5b3:                 boolean sleep = false;
1:740f5b3:                 while (true) {
1:740f5b3:                     long max = end - System.currentTimeMillis();
1:740f5b3:                     if (max <= 0)
1:740f5b3:                         break;
1:740f5b3: 
1:740f5b3:                     if (sleep)
1:740f5b3:                         Thread.sleep(offline);
1:740f5b3:                     // offline.sleepRandom();
1:740f5b3:                     else
1:740f5b3:                         sleep = true;
1:740f5b3: 
1:740f5b3:                     processLock.readLock().lock();
1:740f5b3:                     try {
1:740f5b3:                         process(online);
1:740f5b3:                     } finally {
1:740f5b3:                         processLock.readLock().unlock();
1:740f5b3:                     }
1:740f5b3:                 }
1:740f5b3: 
1:740f5b3:                 // 50% unsubscribe, 50% abondon subscription
1:740f5b3:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT) {
1:740f5b3:                     unsubscribe();
1:740f5b3:                     ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:740f5b3:                 } else {
1:740f5b3: 
1:740f5b3:                     LOG.info("Client abandon the subscription. " + this);
1:740f5b3: 
1:740f5b3:                     // housekeeper should sweep these abandoned subscriptions
1:740f5b3:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:740f5b3:                     ALLOW_SUBSCRIPTION_ABANDONMENT = false;
1:740f5b3:                 }
1:740f5b3:             } catch (Throwable e) {
1:740f5b3:                 exit(toString() + " failed.", e);
1:740f5b3:             }
1:740f5b3: 
1:740f5b3:             clientManager.removeClient(this);
1:740f5b3:             LOG.info(toString() + " DONE.");
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private void process(long processingTime) throws JMSException {
1:740f5b3:             long end = System.currentTimeMillis() + processingTime;
1:740f5b3:             long hardEnd = end + 20000; // wait to finish the transaction.
1:740f5b3:             boolean inTransaction = false;
1:740f5b3:             int transCount = 0;
1:740f5b3: 
1:740f5b3:             LOG.info(toString() + " ONLINE.");
1:740f5b3:             Connection con = openConnection();
1:740f5b3:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:740f5b3:             MessageConsumer consumer = sess.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, false);
1:740f5b3:             try {
1:740f5b3:                 do {
1:740f5b3:                     long max = end - System.currentTimeMillis();
1:740f5b3:                     if (max <= 0) {
1:740f5b3:                         if (!inTransaction)
1:740f5b3:                             break;
1:740f5b3: 
1:740f5b3:                         max = hardEnd - System.currentTimeMillis();
1:740f5b3:                         if (max <= 0)
1:740f5b3:                             exit("" + this + " failed: Transaction is not finished.");
1:740f5b3:                     }
1:740f5b3: 
1:740f5b3:                     Message message = consumer.receive(max);
1:740f5b3:                     if (message == null)
1:740f5b3:                         continue;
1:740f5b3: 
1:740f5b3:                     if (message.propertyExists("COMMIT")) {
1:740f5b3:                         message.acknowledge(); // CLIENT_ACKNOWLEDGE
1:740f5b3: 
1:740f5b3:                         LOG.info("Received Trans[id=" + message.getIntProperty("TRANS") + ", count=" + transCount + "] in " + this + ".");
1:740f5b3: 
1:740f5b3:                         inTransaction = false;
1:740f5b3:                         transCount = 0;
1:740f5b3:                     } else {
1:740f5b3:                         inTransaction = true;
1:740f5b3:                         transCount++;
1:740f5b3:                     }
1:740f5b3:                 } while (true);
1:740f5b3:             } finally {
1:740f5b3:                 sess.close();
1:740f5b3:                 con.close();
1:740f5b3:                 LOG.info(toString() + " OFFLINE.");
1:740f5b3:             }
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private Connection openConnection() throws JMSException {
1:740f5b3:             Connection con = cf.createConnection();
1:740f5b3:             con.setClientID(conClientId);
1:740f5b3:             con.start();
1:740f5b3:             return con;
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private void subscribe() throws JMSException {
1:740f5b3:             Connection con = openConnection();
1:740f5b3:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:740f5b3:             session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, true);
1:740f5b3:             session.close();
1:740f5b3:             con.close();
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private void unsubscribe() throws JMSException {
1:740f5b3:             Connection con = openConnection();
1:740f5b3:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:740f5b3:             session.unsubscribe(SUBSCRIPTION_NAME);
1:740f5b3:             session.close();
1:740f5b3:             con.close();
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         @Override
1:740f5b3:         public String toString() {
1:740f5b3:             return "Client[id=" + id + ", type=" + clientType + "]";
1:740f5b3:         }
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     /**
1:740f5b3:      * Sweeps out not-used durable subscriptions.
1:740f5b3:      */
1:740f5b3:     private final class HouseKeeper extends Thread {
1:740f5b3: 
1:c0b3961:         private final AtomicBoolean done = new AtomicBoolean();
1:c0b3961: 
1:c0b3961:         public final long SWEEP_DELAY = TimeUnit.MINUTES.toMillis(3);
1:c0b3961: 
1:740f5b3:         private HouseKeeper() {
1:740f5b3:             super("HouseKeeper");
1:740f5b3:             setDaemon(true);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1:740f5b3: 
1:c0b3961:         public void shutdown() throws Exception {
1:c0b3961:             done.set(true);
1:c0b3961: 
1:c0b3961:             // In case we are sleeping, abort the sleep.
1:c0b3961:             this.interrupt();
1:c0b3961: 
1:c0b3961:             // Wait for run to complete.
1:c0b3961:             this.join(TimeUnit.MINUTES.toMillis(SWEEP_DELAY));
1:c0b3961: 
1:c0b3961:             // Ensure all abandoned subscriptions get wiped.
1:c0b3961:             if (!abandonedSubscriptions.isEmpty()) {
1:c0b3961:                 this.sweep();
1:c0b3961:             }
1:c0b3961:         }
1:c0b3961: 
1:740f5b3:         @Override
1:740f5b3:         public void run() {
1:c0b3961:             while (!done.get()) {
1:740f5b3:                 try {
1:c0b3961:                     Thread.sleep(SWEEP_DELAY);
1:740f5b3: 
1:740f5b3:                     processLock.readLock().lock();
1:740f5b3:                     try {
1:740f5b3:                         sweep();
1:740f5b3:                     } finally {
1:740f5b3:                         processLock.readLock().unlock();
1:740f5b3:                     }
1:740f5b3:                 } catch (InterruptedException ex) {
1:740f5b3:                     break;
1:740f5b3:                 } catch (Throwable e) {
1:740f5b3:                     Exception log = new Exception("HouseKeeper failed.", e);
1:740f5b3:                     log.printStackTrace();
1:740f5b3:                 }
1:740f5b3:             }
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         private void sweep() throws Exception {
1:740f5b3:             LOG.info("Housekeeper sweeping.");
1:740f5b3: 
1:740f5b3:             int closed = 0;
1:740f5b3:             ArrayList<String> sweeped = new ArrayList<String>();
1:740f5b3:             try {
1:740f5b3:                 for (String clientId : abandonedSubscriptions) {
1:740f5b3:                     LOG.info("Sweeping out subscription of " + clientId + ".");
1:740f5b3:                     broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);
1:740f5b3:                     sweeped.add(clientId);
1:740f5b3:                     closed++;
1:740f5b3:                 }
1:740f5b3:             } catch (Exception ignored) {
1:740f5b3:                 LOG.info("Ex on destroy sub " + ignored);
1:740f5b3:             } finally {
1:740f5b3:                 abandonedSubscriptions.removeAll(sweeped);
1:740f5b3:             }
1:740f5b3: 
1:740f5b3:             LOG.info("Housekeeper sweeped out " + closed + " subscriptions.");
1:740f5b3:         }
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     public static int random(int max) {
1:740f5b3:         return (int) (Math.random() * (max + 1));
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     public static int random(int min, int max) {
1:740f5b3:         return random(max - min) + min;
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:740f5b3:         Thread.sleep(random(maxMillis));
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     public static void sleepRandom(int minMillis, int maxMillis) throws InterruptedException {
1:740f5b3:         Thread.sleep(random(minMillis, maxMillis));
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     public static final class Random {
1:740f5b3: 
1:740f5b3:         final int min;
1:740f5b3:         final int max;
1:740f5b3: 
1:740f5b3:         Random(int min, int max) {
1:740f5b3:             this.min = min;
1:740f5b3:             this.max = max;
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public int next() {
1:740f5b3:             return random(min, max);
1:740f5b3:         }
1:740f5b3: 
1:740f5b3:         public void sleepRandom() throws InterruptedException {
1:740f5b3:             DurableSubDelayedUnsubscribeTest.sleepRandom(min, max);
1:740f5b3:         }
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     public static void exit(String message) {
1:740f5b3:         exit(message, null);
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     public static void exit(String message, Throwable e) {
1:740f5b3:         Throwable cause = new RuntimeException(message, e);
1:740f5b3:         LOG.error(message, cause);
1:740f5b3:         exceptions.add(cause);
1:740f5b3:         fail(cause.toString());
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     @Before
1:740f5b3:     public void setUp() throws Exception {
1:740f5b3:         topic = new ActiveMQTopic("TopicT");
1:740f5b3:         startBroker();
1:740f5b3: 
1:740f5b3:         clientManager = new ClientManager();
1:740f5b3:         server = new Server();
1:740f5b3:         houseKeeper = new HouseKeeper();
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     @After
1:740f5b3:     public void tearDown() throws Exception {
1:740f5b3:         destroyBroker();
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     private void startBroker() throws Exception {
1:740f5b3:         startBroker(true);
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:740f5b3:         if (broker != null)
1:740f5b3:             return;
1:740f5b3: 
1:740f5b3:         broker = BrokerFactory.createBroker("broker:(vm://" + getName() + ")");
1:740f5b3:         broker.setBrokerName(getName());
1:740f5b3:         broker.setAdvisorySupport(false);
1:740f5b3:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:740f5b3: 
1:740f5b3:         File kahadbData = new File("activemq-data/" + getName() + "-kahadb");
1:740f5b3:         if (deleteAllMessages)
1:740f5b3:             delete(kahadbData);
1:740f5b3: 
1:740f5b3:         broker.setPersistent(true);
1:740f5b3:         KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();
1:740f5b3:         kahadb.setDirectory(kahadbData);
1:740f5b3:         kahadb.setJournalMaxFileLength(512 * 1024);
1:740f5b3:         broker.setPersistenceAdapter(kahadb);
1:740f5b3: 
1:740f5b3:         broker.addConnector("tcp://localhost:61656");
1:740f5b3: 
1:740f5b3:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:740f5b3:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:740f5b3:         broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);
1:740f5b3: 
1:740f5b3:         broker.start();
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     protected static String getName() {
1:740f5b3:         return "DurableSubProcessWithRestartTest";
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     private static boolean delete(File path) {
1:740f5b3:         if (path == null)
1:740f5b3:             return true;
1:740f5b3: 
1:740f5b3:         if (path.isDirectory()) {
1:740f5b3:             for (File file : path.listFiles()) {
1:740f5b3:                 delete(file);
1:740f5b3:             }
1:740f5b3:         }
1:740f5b3:         return path.delete();
1:740f5b3:     }
1:740f5b3: 
1:740f5b3:     private void destroyBroker() throws Exception {
1:740f5b3:         if (broker == null)
1:740f5b3:             return;
1:740f5b3: 
1:740f5b3:         broker.stop();
1:740f5b3:         broker = null;
1:740f5b3:     }
1:740f5b3: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c45523f
/////////////////////////////////////////////////////////////////////////
1:         // Wait for all clients to stop
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return clientManager.getClientCount() == 0;
1:             }
1:         }, Client.lifetime + TimeUnit.SECONDS.toMillis(10));
1: 
/////////////////////////////////////////////////////////////////////////
1:             }, houseKeeper.SWEEP_DELAY * 2));
/////////////////////////////////////////////////////////////////////////
1:         public int getClientCount() {
1:             return clients.size();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         public static final int lifetime = 60 * 1000;
commit:ef24cc9
commit:c0b3961
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:         // Ensure we sleep longer than the housekeeper's sweep delay otherwise we can
1:         // miss the fact that all durables that were abandoned do finally get cleaned up.
/////////////////////////////////////////////////////////////////////////
0:             }, TimeUnit.MINUTES.toMillis(houseKeeper.SWEEP_DELAY * 2)));
/////////////////////////////////////////////////////////////////////////
1:         // Be good and cleanup our mess a bit.
1:         this.houseKeeper.shutdown();
1: 
/////////////////////////////////////////////////////////////////////////
1:         private final AtomicBoolean done = new AtomicBoolean();
1: 
1:         public final long SWEEP_DELAY = TimeUnit.MINUTES.toMillis(3);
1: 
/////////////////////////////////////////////////////////////////////////
1:         public void shutdown() throws Exception {
1:             done.set(true);
1: 
1:             // In case we are sleeping, abort the sleep.
1:             this.interrupt();
1: 
1:             // Wait for run to complete.
1:             this.join(TimeUnit.MINUTES.toMillis(SWEEP_DELAY));
1: 
1:             // Ensure all abandoned subscriptions get wiped.
1:             if (!abandonedSubscriptions.isEmpty()) {
1:                 this.sweep();
1:             }
1:         }
1: 
1:             while (!done.get()) {
1:                     Thread.sleep(SWEEP_DELAY);
/////////////////////////////////////////////////////////////////////////
commit:740f5b3
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR ONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Vector;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.management.ObjectName;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.util.Wait;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /*
1:  * A cut down version of DurableSubProcessWithRestartTest that focuses on kahaDB file retention
1:  */
1: public class DurableSubDelayedUnsubscribeTest {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubDelayedUnsubscribeTest.class);
1: 
1:     private static final long RUNTIME = 2 * 60 * 1000;
1:     private static final int CARGO_SIZE = 400; // max
1:     private static final int MAX_CLIENTS = 15;
1:     private static boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:     private static final Vector<Throwable> exceptions = new Vector<Throwable>();
1: 
1:     private BrokerService broker;
1:     private ActiveMQTopic topic;
1: 
1:     private ClientManager clientManager;
1:     private Server server;
1:     private HouseKeeper houseKeeper;
1: 
1:     private final ReentrantReadWriteLock processLock = new ReentrantReadWriteLock(true);
1: 
1:     @Test
1:     public void testProcess() throws Exception {
1: 
1:         server.start();
1:         clientManager.start();
1: 
1:         houseKeeper.start();
1: 
1:         // Sleep to
1:         Thread.sleep(RUNTIME);
1: 
1:         // inform message producer to stop
1:         server.stopped = true;
1: 
1:         // add one Subscriber to the topic that will not be unsubscribed.
1:         // should not have any pending messages in the kahadb store
1:         Client lastClient = new Client(32000, ClientType.A);
1:         lastClient.process(1000);
1: 
1:         // stop client manager from creating any more clients
1:         clientManager.stopped = true;
1: 
1:         final BrokerService brokerService = this.broker;
1: 
1:         // Wait for all client subscription to be unsubscribed or swept away.
1: 
1:         assertTrue("should have only one inactiveSubscriber subscribed but was: " + brokerService.getAdminView().getInactiveDurableTopicSubscribers().length,
1:             Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return brokerService.getAdminView().getInactiveDurableTopicSubscribers().length == 1;
1:                 }
1:             }, TimeUnit.MINUTES.toMillis(3)));
1: 
1:         assertTrue("should be no subscribers subscribed but was: " + brokerService.getAdminView().getDurableTopicSubscribers().length,
1:             Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return brokerService.getAdminView().getDurableTopicSubscribers().length == 0;
1:                 }
1:             }, TimeUnit.MINUTES.toMillis(3)));
1: 
1:         processLock.writeLock().lock();
1: 
1:         // check outcome.
1: 
1:         ObjectName[] subscribers = broker.getAdminView().getDurableTopicSubscribers();
1:         ObjectName[] inactiveSubscribers = broker.getAdminView().getInactiveDurableTopicSubscribers();
1:         final KahaDBPersistenceAdapter persistenceAdapter = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
1: 
1:         printDebugClientInfo(subscribers, inactiveSubscribers, persistenceAdapter);
1: 
1:         assertEquals("should have only one inactiveSubscriber subscribed", 1, broker.getAdminView().getInactiveDurableTopicSubscribers().length);
1:         assertEquals("should be no subscribers subscribed", 0, broker.getAdminView().getDurableTopicSubscribers().length);
1: 
1:         final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
1:         assertTrue("should be less than 3 journal file left but was: " + persistenceAdapter.getStore().getJournal().getFileMap().size(),
1:             Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return pa.getStore().getJournal().getFileMap().size() <= 3;
1:                 }
1:             }, TimeUnit.MINUTES.toMillis(3)));
1: 
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1: 
1:         LOG.info("DONE.");
1:     }
1: 
1:     private void printDebugClientInfo(ObjectName[] subscribers, ObjectName[] inactiveSubscribers, final KahaDBPersistenceAdapter pa) throws IOException {
1: 
1:         LOG.info("====>>> START DEBUG Subscriber INFO");
1: 
1:         LOG.info("Number of subscribers subscribed as seen through JMX is" + subscribers.length);
1: 
1:         for (int i = 0; i < subscribers.length; i++) {
1:             LOG.info("subscribers subscribed as seen throngh JMX: " + subscribers[i]);
1:         }
1: 
1:         LOG.info("Number of inactiveSubscribers subscribed as seen through JMX is" + inactiveSubscribers.length);
1: 
1:         for (int i = 0; i < inactiveSubscribers.length; i++) {
1:             LOG.info("subscribers subscribed as seen throngh JMX: " + inactiveSubscribers[i]);
1:         }
1: 
1:         LOG.info("ClientManager.clients size is" + clientManager.clients.size());
1: 
1:         for (int i = 0; i < clientManager.clients.size(); i++) {
1:             LOG.info("clients is: " + clientManager.clients.get(i));
1:         }
1: 
1:         LOG.info("housekeep.subscriptions size is " + houseKeeper.abandonedSubscriptions.size());
1: 
1:         for (int i = 0; i < houseKeeper.abandonedSubscriptions.size(); i++) {
1:             LOG.info("housekeep is: " + houseKeeper.abandonedSubscriptions.get(i));
1:         }
1: 
1:         LOG.info("number of journal files left" + pa.getStore().getJournal().getFileMap().size());
1: 
1:         LOG.info("====>>> END DEBUG Subscriber INFO");
1:     }
1: 
1:     /**
1:      * Creates batch of messages in a transaction periodically. The last message
1:      * in the transaction is always a special message what contains info about
1:      * the whole transaction.
1:      * <p>
1:      * Notifies the clients about the created messages also.
1:      */
1:     final class Server extends Thread {
1: 
1:         public boolean stopped;
1:         final String url = "vm://" + DurableSubDelayedUnsubscribeTest.getName() + "?"
1:                 + "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&"
1:                 + "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&" + "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&"
1:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=false&" + "jms.watchTopicAdvisories=false&" + "waitForStart=200&create=false";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         final Object sendMutex = new Object();
1:         final String[] cargos = new String[500];
1: 
1:         int transRover = 0;
1:         int messageRover = 0;
1: 
1:         public Server() {
1:             super("Server");
1:             setDaemon(true);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 while (true) {
1: 
1:                     if (stopped) {
1:                         // server should stop producing
1:                         break;
1:                     }
1: 
1:                     Thread.sleep(500);
1:                     processLock.readLock().lock();
1:                     try {
1:                         send();
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 }
1:             } catch (Throwable e) {
1:                 exit("Server.run failed", e);
1:             }
1:         }
1: 
1:         public void send() throws JMSException {
1:             // do not create new clients now
1:             // ToDo: Test this case later.
1:             synchronized (sendMutex) {
1:                 int trans = ++transRover;
1:                 boolean relevantTrans = random(2) > 1;
1:                 ClientType clientType = relevantTrans ? ClientType.randomClientType() : null; // sends
1:                                                                                               // this
1:                                                                                               // types
1:                 int count = random(200);
1: 
1:                 LOG.info("Sending Trans[id=" + trans + ", count=" + count + ", clientType=" + clientType + "]");
1: 
1:                 Connection con = cf.createConnection();
1:                 Session sess = con.createSession(true, Session.SESSION_TRANSACTED);
1:                 MessageProducer prod = sess.createProducer(null);
1: 
1:                 for (int i = 0; i < count; i++) {
1:                     Message message = sess.createMessage();
1:                     message.setIntProperty("ID", ++messageRover);
1:                     message.setIntProperty("TRANS", trans);
1:                     String type = clientType != null ? clientType.randomMessageType() : ClientType.randomNonRelevantMessageType();
1:                     message.setStringProperty("TYPE", type);
1: 
1:                     if (CARGO_SIZE > 0)
1:                         message.setStringProperty("CARGO", getCargo(random(CARGO_SIZE)));
1: 
1:                     prod.send(topic, message);
1: 
1:                 }
1: 
1:                 Message message = sess.createMessage();
1:                 message.setIntProperty("ID", ++messageRover);
1:                 message.setIntProperty("TRANS", trans);
1:                 message.setBooleanProperty("COMMIT", true);
1:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:                 prod.send(topic, message);
1: 
1:                 sess.commit();
1:                 LOG.info("Committed Trans[id=" + trans + ", count=" + count + ", clientType=" + clientType + "], ID=" + messageRover);
1: 
1:                 sess.close();
1:                 con.close();
1:             }
1:         }
1: 
1:         private String getCargo(int length) {
1:             if (length == 0)
1:                 return null;
1: 
1:             if (length < cargos.length) {
1:                 String result = cargos[length];
1:                 if (result == null) {
1:                     result = getCargoImpl(length);
1:                     cargos[length] = result;
1:                 }
1:                 return result;
1:             }
1:             return getCargoImpl(length);
1:         }
1: 
1:         private String getCargoImpl(int length) {
1:             StringBuilder sb = new StringBuilder(length);
1:             for (int i = length; --i >= 0;) {
1:                 sb.append('a');
1:             }
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Clients listen on different messages in the topic. The 'TYPE' property
1:      * helps the client to select the proper messages.
1:      */
1:     private enum ClientType {
1:         A("a", "b", "c"), B("c", "d", "e"), C("d", "e", "f"), D("g", "h");
1: 
1:         public final String[] messageTypes;
1: 
1:         public final String selector;
1: 
1:         ClientType(String... messageTypes) {
1:             this.messageTypes = messageTypes;
1: 
1:             StringBuilder sb = new StringBuilder("TYPE in (");
1:             for (int i = 0; i < messageTypes.length; i++) {
1:                 if (i > 0)
1:                     sb.append(", ");
1:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:             }
1:             sb.append(')');
1:             selector = sb.toString();
1:         }
1: 
1:         public static ClientType randomClientType() {
1:             return values()[DurableSubDelayedUnsubscribeTest.random(values().length - 1)];
1:         }
1: 
1:         public final String randomMessageType() {
1:             return messageTypes[DurableSubDelayedUnsubscribeTest.random(messageTypes.length - 1)];
1:         }
1: 
1:         public static String randomNonRelevantMessageType() {
1:             return Integer.toString(DurableSubDelayedUnsubscribeTest.random(20));
1:         }
1: 
1:         @Override
1:         public final String toString() {
1:             return this.name() /* + '[' + selector + ']' */;
1:         }
1:     }
1: 
1:     /**
1:      * Creates new cliens.
1:      */
1:     private final class ClientManager extends Thread {
1: 
1:         private int clientRover = 0;
1: 
1:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1: 
1:         private boolean stopped;
1: 
1:         public ClientManager() {
1:             super("ClientManager");
1:             setDaemon(true);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 while (true) {
1:                     if (clients.size() < MAX_CLIENTS) {
1: 
1:                         if (stopped) {
1:                             // get out, don't start any more threads
1:                             break;
1:                         }
1:                         processLock.readLock().lock();
1:                         try {
1:                             createNewClient();
1:                         } finally {
1:                             processLock.readLock().unlock();
1:                         }
1:                     }
1: 
1:                     int size = clients.size();
1:                     sleepRandom(size * 3 * 1000, size * 6 * 1000);
1:                 }
1:             } catch (Throwable e) {
1:                 exit("ClientManager.run failed.", e);
1:             }
1:         }
1: 
1:         private void createNewClient() throws JMSException {
1:             ClientType type = ClientType.randomClientType();
1: 
1:             Client client;
1:             synchronized (server.sendMutex) {
1:                 client = new Client(++clientRover, type);
1:                 clients.add(client);
1:             }
1:             client.start();
1: 
1:             LOG.info(client.toString() + " created. " + this);
1:         }
1: 
1:         public void removeClient(Client client) {
1:             clients.remove(client);
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:             sb.append(clients.size());
1:             sb.append(", clients=");
1:             boolean sep = false;
1:             for (Client client : clients) {
1:                 if (sep)
1:                     sb.append(", ");
1:                 else
1:                     sep = true;
1:                 sb.append(client.toString());
1:             }
1:             sb.append(']');
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Consumes massages from a durable subscription. Goes online/offline
1:      * periodically. Checks the incoming messages against the sent messages of
1:      * the server.
1:      */
1:     private final class Client extends Thread {
1: 
1:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?" + "jms.watchTopicAdvisories=false&"
1:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&" + "jms.producerWindowSize=20971520&" + "jms.copyMessageOnSend=false&"
1:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&" + "useExponentialBackOff=true";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         public static final String SUBSCRIPTION_NAME = "subscription";
1: 
1:         private final int id;
1:         private final String conClientId;
1: 
0:         private final int lifetime = 60 * 1000;
1:         private final int online = 1 * 1000;
1:         private final int offline = 59 * 1000;
1: 
1:         private final ClientType clientType;
1:         private final String selector;
1: 
1:         public Client(int id, ClientType clientType) throws JMSException {
1:             super("Client" + id);
1:             setDaemon(true);
1: 
1:             this.id = id;
1:             conClientId = "cli" + id;
1:             this.clientType = clientType;
1:             selector = "(COMMIT = true and RELEVANT = true) or " + clientType.selector;
1: 
1:             subscribe();
1:         }
1: 
1:         @Override
1:         public void run() {
1:             // long end = System.currentTimeMillis() + lifetime.next();
1:             long end = System.currentTimeMillis() + lifetime;
1:             try {
1:                 boolean sleep = false;
1:                 while (true) {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0)
1:                         break;
1: 
1:                     if (sleep)
1:                         Thread.sleep(offline);
1:                     // offline.sleepRandom();
1:                     else
1:                         sleep = true;
1: 
1:                     processLock.readLock().lock();
1:                     try {
1:                         process(online);
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 }
1: 
1:                 // 50% unsubscribe, 50% abondon subscription
1:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT) {
1:                     unsubscribe();
1:                     ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:                 } else {
1: 
1:                     LOG.info("Client abandon the subscription. " + this);
1: 
1:                     // housekeeper should sweep these abandoned subscriptions
1:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:                     ALLOW_SUBSCRIPTION_ABANDONMENT = false;
1:                 }
1:             } catch (Throwable e) {
1:                 exit(toString() + " failed.", e);
1:             }
1: 
1:             clientManager.removeClient(this);
1:             LOG.info(toString() + " DONE.");
1:         }
1: 
1:         private void process(long processingTime) throws JMSException {
1:             long end = System.currentTimeMillis() + processingTime;
1:             long hardEnd = end + 20000; // wait to finish the transaction.
1:             boolean inTransaction = false;
1:             int transCount = 0;
1: 
1:             LOG.info(toString() + " ONLINE.");
1:             Connection con = openConnection();
1:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:             MessageConsumer consumer = sess.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, false);
1:             try {
1:                 do {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0) {
1:                         if (!inTransaction)
1:                             break;
1: 
1:                         max = hardEnd - System.currentTimeMillis();
1:                         if (max <= 0)
1:                             exit("" + this + " failed: Transaction is not finished.");
1:                     }
1: 
1:                     Message message = consumer.receive(max);
1:                     if (message == null)
1:                         continue;
1: 
1:                     if (message.propertyExists("COMMIT")) {
1:                         message.acknowledge(); // CLIENT_ACKNOWLEDGE
1: 
1:                         LOG.info("Received Trans[id=" + message.getIntProperty("TRANS") + ", count=" + transCount + "] in " + this + ".");
1: 
1:                         inTransaction = false;
1:                         transCount = 0;
1:                     } else {
1:                         inTransaction = true;
1:                         transCount++;
1:                     }
1:                 } while (true);
1:             } finally {
1:                 sess.close();
1:                 con.close();
1:                 LOG.info(toString() + " OFFLINE.");
1:             }
1:         }
1: 
1:         private Connection openConnection() throws JMSException {
1:             Connection con = cf.createConnection();
1:             con.setClientID(conClientId);
1:             con.start();
1:             return con;
1:         }
1: 
1:         private void subscribe() throws JMSException {
1:             Connection con = openConnection();
1:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, true);
1:             session.close();
1:             con.close();
1:         }
1: 
1:         private void unsubscribe() throws JMSException {
1:             Connection con = openConnection();
1:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.unsubscribe(SUBSCRIPTION_NAME);
1:             session.close();
1:             con.close();
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             return "Client[id=" + id + ", type=" + clientType + "]";
1:         }
1:     }
1: 
1:     /**
1:      * Sweeps out not-used durable subscriptions.
1:      */
1:     private final class HouseKeeper extends Thread {
1: 
1:         private HouseKeeper() {
1:             super("HouseKeeper");
1:             setDaemon(true);
1:         }
1: 
1:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1: 
1:         @Override
1:         public void run() {
1:             while (true) {
1:                 try {
0:                     Thread.sleep(3 * 60 * 1000);
1: 
1:                     processLock.readLock().lock();
1:                     try {
1:                         sweep();
1:                     } finally {
1:                         processLock.readLock().unlock();
1:                     }
1:                 } catch (InterruptedException ex) {
1:                     break;
1:                 } catch (Throwable e) {
1:                     Exception log = new Exception("HouseKeeper failed.", e);
1:                     log.printStackTrace();
1:                 }
1:             }
1:         }
1: 
1:         private void sweep() throws Exception {
1:             LOG.info("Housekeeper sweeping.");
1: 
1:             int closed = 0;
1:             ArrayList<String> sweeped = new ArrayList<String>();
1:             try {
1:                 for (String clientId : abandonedSubscriptions) {
1:                     LOG.info("Sweeping out subscription of " + clientId + ".");
1:                     broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);
1:                     sweeped.add(clientId);
1:                     closed++;
1:                 }
1:             } catch (Exception ignored) {
1:                 LOG.info("Ex on destroy sub " + ignored);
1:             } finally {
1:                 abandonedSubscriptions.removeAll(sweeped);
1:             }
1: 
1:             LOG.info("Housekeeper sweeped out " + closed + " subscriptions.");
1:         }
1:     }
1: 
1:     public static int random(int max) {
1:         return (int) (Math.random() * (max + 1));
1:     }
1: 
1:     public static int random(int min, int max) {
1:         return random(max - min) + min;
1:     }
1: 
1:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:         Thread.sleep(random(maxMillis));
1:     }
1: 
1:     public static void sleepRandom(int minMillis, int maxMillis) throws InterruptedException {
1:         Thread.sleep(random(minMillis, maxMillis));
1:     }
1: 
1:     public static final class Random {
1: 
1:         final int min;
1:         final int max;
1: 
1:         Random(int min, int max) {
1:             this.min = min;
1:             this.max = max;
1:         }
1: 
1:         public int next() {
1:             return random(min, max);
1:         }
1: 
1:         public void sleepRandom() throws InterruptedException {
1:             DurableSubDelayedUnsubscribeTest.sleepRandom(min, max);
1:         }
1:     }
1: 
1:     public static void exit(String message) {
1:         exit(message, null);
1:     }
1: 
1:     public static void exit(String message, Throwable e) {
1:         Throwable cause = new RuntimeException(message, e);
1:         LOG.error(message, cause);
1:         exceptions.add(cause);
1:         fail(cause.toString());
1:     }
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         topic = new ActiveMQTopic("TopicT");
1:         startBroker();
1: 
1:         clientManager = new ClientManager();
1:         server = new Server();
1:         houseKeeper = new HouseKeeper();
1: 
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         destroyBroker();
1:     }
1: 
1:     private void startBroker() throws Exception {
1:         startBroker(true);
1:     }
1: 
1:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:         if (broker != null)
1:             return;
1: 
1:         broker = BrokerFactory.createBroker("broker:(vm://" + getName() + ")");
1:         broker.setBrokerName(getName());
1:         broker.setAdvisorySupport(false);
1:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1: 
1:         File kahadbData = new File("activemq-data/" + getName() + "-kahadb");
1:         if (deleteAllMessages)
1:             delete(kahadbData);
1: 
1:         broker.setPersistent(true);
1:         KahaDBPersistenceAdapter kahadb = new KahaDBPersistenceAdapter();
1:         kahadb.setDirectory(kahadbData);
1:         kahadb.setJournalMaxFileLength(512 * 1024);
1:         broker.setPersistenceAdapter(kahadb);
1: 
1:         broker.addConnector("tcp://localhost:61656");
1: 
1:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);
1: 
1:         broker.start();
1:     }
1: 
1:     protected static String getName() {
1:         return "DurableSubProcessWithRestartTest";
1:     }
1: 
1:     private static boolean delete(File path) {
1:         if (path == null)
1:             return true;
1: 
1:         if (path.isDirectory()) {
1:             for (File file : path.listFiles()) {
1:                 delete(file);
1:             }
1:         }
1:         return path.delete();
1:     }
1: 
1:     private void destroyBroker() throws Exception {
1:         if (broker == null)
1:             return;
1: 
1:         broker.stop();
1:         broker = null;
1:     }
1: }
============================================================================