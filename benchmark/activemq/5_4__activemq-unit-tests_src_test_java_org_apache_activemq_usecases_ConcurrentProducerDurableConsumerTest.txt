1:eae88fe: /**
1:eae88fe:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:eae88fe:  * contributor license agreements.  See the NOTICE file distributed with
1:eae88fe:  * this work for additional information regarding copyright ownership.
1:eae88fe:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:eae88fe:  * (the "License"); you may not use this file except in compliance with
1:eae88fe:  * the License.  You may obtain a copy of the License at
1:eae88fe:  *
1:eae88fe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:eae88fe:  *
1:eae88fe:  * Unless required by applicable law or agreed to in writing, software
1:eae88fe:  * distributed under the License is distributed on an "AS IS" BASIS,
1:eae88fe:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:eae88fe:  * See the License for the specific language governing permissions and
1:eae88fe:  * limitations under the License.
2:eae88fe:  */
1:eae88fe: package org.apache.activemq.usecases;
12:eae88fe: 
1:eae88fe: import java.util.ArrayList;
1:eae88fe: import java.util.Arrays;
1:f7f294f: import java.util.Collection;
1:eae88fe: import java.util.Collections;
1:eae88fe: import java.util.HashMap;
1:eae88fe: import java.util.Iterator;
1:eae88fe: import java.util.List;
1:eae88fe: import java.util.Map;
1:fe31092: import java.util.concurrent.ConcurrentHashMap;
1:cb96783: import java.util.concurrent.CountDownLatch;
1:eae88fe: import java.util.concurrent.Executors;
1:eae88fe: import java.util.concurrent.ThreadFactory;
1:eae88fe: import java.util.concurrent.TimeUnit;
1:cb96783: import java.util.concurrent.atomic.AtomicLong;
1:f7f294f: 
1:eae88fe: import javax.jms.Connection;
1:eae88fe: import javax.jms.ConnectionFactory;
1:eae88fe: import javax.jms.DeliveryMode;
1:eae88fe: import javax.jms.Destination;
1:eae88fe: import javax.jms.JMSException;
1:cb96783: import javax.jms.Message;
1:eae88fe: import javax.jms.MessageConsumer;
1:cb96783: import javax.jms.MessageListener;
1:eae88fe: import javax.jms.MessageProducer;
1:eae88fe: import javax.jms.Session;
1:eae88fe: import javax.jms.TextMessage;
1:eae88fe: import javax.jms.TopicSubscriber;
1:f7f294f: 
1:eae88fe: import org.apache.activemq.ActiveMQConnectionFactory;
1:eae88fe: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:eae88fe: import org.apache.activemq.TestSupport;
1:eae88fe: import org.apache.activemq.broker.BrokerService;
1:eae88fe: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:eae88fe: import org.apache.activemq.broker.region.policy.PolicyMap;
1:fe31092: import org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy;
1:fe31092: import org.apache.activemq.command.MessageId;
1:eae88fe: import org.apache.activemq.util.MessageIdList;
1:eae88fe: import org.apache.activemq.util.Wait;
1:f7f294f: import org.junit.After;
1:f7f294f: import org.junit.Before;
1:f7f294f: import org.junit.Test;
1:f7f294f: import org.junit.runner.RunWith;
1:f7f294f: import org.junit.runners.Parameterized;
1:833d308: import org.junit.runners.Parameterized.Parameters;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:eae88fe: 
1:f7f294f: @RunWith(value = Parameterized.class)
1:eae88fe: public class ConcurrentProducerDurableConsumerTest extends TestSupport {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ConcurrentProducerDurableConsumerTest.class);
1:f7f294f:     private final int consumerCount = 5;
1:eae88fe:     BrokerService broker;
1:eae88fe:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
1:cb96783:     protected Map<MessageConsumer, TimedMessageListener> consumers = new HashMap<MessageConsumer, TimedMessageListener>();
1:eae88fe:     protected MessageIdList allMessagesList = new MessageIdList();
1:f7f294f:     private final int messageSize = 1024;
1:eae88fe: 
1:f7f294f:     private final TestSupport.PersistenceAdapterChoice persistenceAdapterChoice;
1:f7f294f: 
1:833d308:     @Parameters(name="{0}")
1:f7f294f:     public static Collection<TestSupport.PersistenceAdapterChoice[]> getTestParameters() {
1:833d308:         TestSupport.PersistenceAdapterChoice[] kahaDb = { TestSupport.PersistenceAdapterChoice.KahaDB };
1:833d308:         TestSupport.PersistenceAdapterChoice[] levelDb = { TestSupport.PersistenceAdapterChoice.LevelDB };
1:833d308:         TestSupport.PersistenceAdapterChoice[] mem = { TestSupport.PersistenceAdapterChoice.MEM };
1:f7f294f:         List<TestSupport.PersistenceAdapterChoice[]> choices = new ArrayList<TestSupport.PersistenceAdapterChoice[]>();
1:f7f294f:         choices.add(kahaDb);
1:f7f294f:         choices.add(levelDb);
1:f7f294f:         choices.add(mem);
1:f7f294f:         return choices;
6:eae88fe:     }
1:eae88fe: 
1:f7f294f:     public ConcurrentProducerDurableConsumerTest(TestSupport.PersistenceAdapterChoice choice) {
1:f7f294f:         this.persistenceAdapterChoice = choice;
1:f7f294f:     }
1:f7f294f: 
1:f7f294f:     @Test(timeout = 120000)
1:cb96783:     public void testSendRateWithActivatingConsumers() throws Exception {
1:eae88fe:         final Destination destination = createDestination();
1:eae88fe:         final ConnectionFactory factory = createConnectionFactory();
1:eae88fe:         startInactiveConsumers(factory, destination);
1:eae88fe: 
1:eae88fe:         Connection connection = factory.createConnection();
1:eae88fe:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:eae88fe:         MessageProducer producer = createMessageProducer(session, destination);
1:eae88fe: 
1:eae88fe:         // preload the durable consumers
1:cb96783:         double[] inactiveConsumerStats = produceMessages(destination, 500, 10, session, producer, null);
1:833d308:         LOG.info("With inactive consumers: ave: " + inactiveConsumerStats[1] + ", max: " + inactiveConsumerStats[0] + ", multiplier: "
1:833d308:             + (inactiveConsumerStats[0] / inactiveConsumerStats[1]));
1:eae88fe: 
1:cb96783:         // periodically start a durable sub that has a backlog
1:cb96783:         final int consumersToActivate = 5;
1:eae88fe:         final Object addConsumerSignal = new Object();
1:eae88fe:         Executors.newCachedThreadPool(new ThreadFactory() {
1:eae88fe:             @Override
1:eae88fe:             public Thread newThread(Runnable r) {
1:eae88fe:                 return new Thread(r, "ActivateConsumer" + this);
1:eae88fe:             }
1:eae88fe:         }).execute(new Runnable() {
1:eae88fe:             @Override
1:eae88fe:             public void run() {
1:eae88fe:                 try {
1:eae88fe:                     MessageConsumer consumer = null;
1:eae88fe:                     for (int i = 0; i < consumersToActivate; i++) {
1:cb96783:                         LOG.info("Waiting for add signal from producer...");
1:eae88fe:                         synchronized (addConsumerSignal) {
1:eae88fe:                             addConsumerSignal.wait(30 * 60 * 1000);
1:eae88fe:                         }
1:cb96783:                         TimedMessageListener listener = new TimedMessageListener();
1:eae88fe:                         consumer = createDurableSubscriber(factory.createConnection(), destination, "consumer" + (i + 1));
1:eae88fe:                         LOG.info("Created consumer " + consumer);
1:cb96783:                         consumer.setMessageListener(listener);
1:cb96783:                         consumers.put(consumer, listener);
1:eae88fe:                     }
1:eae88fe:                 } catch (Exception e) {
1:eae88fe:                     LOG.error("failed to start consumer", e);
1:eae88fe:                 }
1:eae88fe:             }
1:eae88fe:         });
1:cb96783: 
1:fe31092:         double[] statsWithActive = produceMessages(destination, 500, 10, session, producer, addConsumerSignal);
1:eae88fe: 
1:833d308:         LOG.info(" with concurrent activate, ave: " + statsWithActive[1] + ", max: " + statsWithActive[0] + ", multiplier: "
1:833d308:             + (statsWithActive[0] / statsWithActive[1]));
1:eae88fe: 
1:833d308:         while (consumers.size() < consumersToActivate) {
1:cb96783:             TimeUnit.SECONDS.sleep(2);
1:cb96783:         }
1:cb96783: 
1:cb96783:         long timeToFirstAccumulator = 0;
1:cb96783:         for (TimedMessageListener listener : consumers.values()) {
1:cb96783:             long time = listener.getFirstReceipt();
1:cb96783:             timeToFirstAccumulator += time;
1:cb96783:             LOG.info("Time to first " + time);
1:cb96783:         }
1:833d308:         LOG.info("Ave time to first message =" + timeToFirstAccumulator / consumers.size());
1:cb96783: 
1:cb96783:         for (TimedMessageListener listener : consumers.values()) {
1:fe31092:             LOG.info("Ave batch receipt time: " + listener.waitForReceivedLimit(10000) + " max receipt: " + listener.maxReceiptTime);
1:cb96783:         }
1:cb96783: 
1:cb96783:         // compare no active to active
1:833d308:         LOG.info("Ave send time with active: " + statsWithActive[1] + " as multiplier of ave with none active: " + inactiveConsumerStats[1] + ", multiplier="
1:833d308:             + (statsWithActive[1] / inactiveConsumerStats[1]));
1:cb96783: 
1:833d308:         assertTrue("Ave send time with active: " + statsWithActive[1] + " within reasonable multpler of ave with none active: " + inactiveConsumerStats[1]
1:833d308:             + ", multiplier " + (statsWithActive[1] / inactiveConsumerStats[1]), statsWithActive[1] < 15 * inactiveConsumerStats[1]);
1:eae88fe:     }
1:cb96783: 
1:eae88fe:     public void x_testSendWithInactiveAndActiveConsumers() throws Exception {
1:eae88fe:         Destination destination = createDestination();
1:eae88fe:         ConnectionFactory factory = createConnectionFactory();
1:eae88fe:         startInactiveConsumers(factory, destination);
1:eae88fe: 
1:eae88fe:         Connection connection = factory.createConnection();
1:eae88fe:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:eae88fe:         MessageProducer producer = session.createProducer(destination);
1:eae88fe:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:eae88fe: 
1:eae88fe:         final int toSend = 100;
1:eae88fe:         final int numIterations = 5;
1:eae88fe: 
1:eae88fe:         double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1:eae88fe: 
1:eae88fe:         startConsumers(factory, destination);
1:eae88fe:         LOG.info("Activated consumer");
1:eae88fe: 
1:eae88fe:         double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1:eae88fe: 
1:833d308:         LOG.info("With consumer: " + withConsumerStats[1] + " , with noConsumer: " + noConsumerStats[1] + ", multiplier: "
1:833d308:             + (withConsumerStats[1] / noConsumerStats[1]));
1:cb96783:         final int reasonableMultiplier = 15; // not so reasonable but improving
1:833d308:         assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: " + noConsumerStats[1] + ", multiplier: "
1:833d308:             + (withConsumerStats[1] / noConsumerStats[1]), withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);
1:eae88fe: 
1:eae88fe:         final int toReceive = toSend * numIterations * consumerCount * 2;
1:eae88fe:         Wait.waitFor(new Wait.Condition() {
1:f7f294f:             @Override
1:eae88fe:             public boolean isSatisified() throws Exception {
1:eae88fe:                 LOG.info("count: " + allMessagesList.getMessageCount());
1:eae88fe:                 return toReceive == allMessagesList.getMessageCount();
1:eae88fe:             }
1:eae88fe:         }, 60 * 1000);
1:eae88fe: 
1:eae88fe:         assertEquals("got all messages", toReceive, allMessagesList.getMessageCount());
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     private MessageProducer createMessageProducer(Session session, Destination destination) throws JMSException {
1:eae88fe:         MessageProducer producer = session.createProducer(destination);
1:eae88fe:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:eae88fe:         return producer;
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     private void startInactiveConsumers(ConnectionFactory factory, Destination destination) throws Exception {
1:eae88fe:         // create off line consumers
1:eae88fe:         startConsumers(factory, destination);
1:833d308:         for (Connection connection : connections) {
1:eae88fe:             connection.close();
1:eae88fe:         }
1:eae88fe:         connections.clear();
1:eae88fe:         consumers.clear();
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {
1:eae88fe:         MessageConsumer consumer;
1:eae88fe:         for (int i = 0; i < consumerCount; i++) {
1:cb96783:             TimedMessageListener list = new TimedMessageListener();
1:eae88fe:             consumer = createDurableSubscriber(factory.createConnection(), dest, "consumer" + (i + 1));
2:eae88fe:             consumer.setMessageListener(list);
2:eae88fe:             consumers.put(consumer, list);
1:eae88fe:         }
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     protected TopicSubscriber createDurableSubscriber(Connection conn, Destination dest, String name) throws Exception {
1:eae88fe:         conn.setClientID(name);
1:eae88fe:         connections.add(conn);
1:eae88fe:         conn.start();
1:eae88fe: 
1:eae88fe:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:833d308:         final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic) dest, name);
1:eae88fe: 
1:eae88fe:         return consumer;
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     /**
1:eae88fe:      * @return max and ave send time
1:eae88fe:      * @throws Exception
1:cb96783:      */
1:833d308:     private double[] produceMessages(Destination destination, final int toSend, final int numIterations, Session session, MessageProducer producer,
1:833d308:         Object addConsumerSignal) throws Exception {
1:eae88fe:         long start;
1:eae88fe:         long count = 0;
1:cb96783:         double batchMax = 0, max = 0, sum = 0;
1:833d308:         for (int i = 0; i < numIterations; i++) {
1:eae88fe:             start = System.currentTimeMillis();
1:833d308:             for (int j = 0; j < toSend; j++) {
1:cb96783:                 long singleSendstart = System.currentTimeMillis();
1:eae88fe:                 TextMessage msg = createTextMessage(session, "" + j);
1:fe31092:                 // rotate
1:833d308:                 int priority = ((int) count % 10);
1:fe31092:                 producer.send(msg, DeliveryMode.PERSISTENT, priority, 0);
1:cb96783:                 max = Math.max(max, (System.currentTimeMillis() - singleSendstart));
1:cb96783:                 if (++count % 500 == 0) {
1:eae88fe:                     if (addConsumerSignal != null) {
1:eae88fe:                         synchronized (addConsumerSignal) {
1:eae88fe:                             addConsumerSignal.notifyAll();
1:cb96783:                             LOG.info("Signalled add consumer");
1:833d308:                         }
1:eae88fe:                     }
1:eae88fe:                 }
1:833d308:                 ;
1:eae88fe:                 if (count % 5000 == 0) {
1:cb96783:                     LOG.info("Sent " + count + ", singleSendMax:" + max);
1:eae88fe:                 }
1:eae88fe: 
1:eae88fe:             }
1:eae88fe:             long duration = System.currentTimeMillis() - start;
1:cb96783:             batchMax = Math.max(batchMax, duration);
1:eae88fe:             sum += duration;
1:833d308:             LOG.info("Iteration " + i + ", sent " + toSend + ", time: " + duration + ", batchMax:" + batchMax + ", singleSendMax:" + max);
1:eae88fe:         }
1:eae88fe: 
1:cb96783:         LOG.info("Sent: " + toSend * numIterations + ", batchMax: " + batchMax + " singleSendMax: " + max);
1:833d308:         return new double[] { batchMax, sum / numIterations };
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:eae88fe:         TextMessage msg = session.createTextMessage();
1:eae88fe: 
1:eae88fe:         // Pad message text
1:eae88fe:         if (initText.length() < messageSize) {
1:eae88fe:             char[] data = new char[messageSize - initText.length()];
1:eae88fe:             Arrays.fill(data, '*');
1:eae88fe:             String str = new String(data);
1:eae88fe:             msg.setText(initText + str);
1:eae88fe: 
1:eae88fe:             // Do not pad message text
1:cb96783:         } else {
1:eae88fe:             msg.setText(initText);
1:eae88fe:         }
1:eae88fe: 
1:eae88fe:         return msg;
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     @Override
1:f7f294f:     @Before
1:f7f294f:     public void setUp() throws Exception {
1:eae88fe:         topic = true;
1:eae88fe:         super.setUp();
1:eae88fe:         broker = createBroker();
1:eae88fe:         broker.start();
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     @Override
1:f7f294f:     @After
1:f7f294f:     public void tearDown() throws Exception {
1:eae88fe:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:eae88fe:             Connection conn = iter.next();
1:eae88fe:             try {
1:eae88fe:                 conn.close();
1:eae88fe:             } catch (Throwable e) {
1:eae88fe:             }
1:eae88fe:         }
1:eae88fe:         broker.stop();
1:eae88fe:         allMessagesList.flushMessages();
1:eae88fe:         consumers.clear();
1:eae88fe:         super.tearDown();
1:eae88fe:     }
1:eae88fe: 
1:eae88fe:     protected BrokerService createBroker() throws Exception {
1:eae88fe:         BrokerService brokerService = new BrokerService();
1:eae88fe:         brokerService.setEnableStatistics(false);
1:42e51a3:         brokerService.addConnector("tcp://0.0.0.0:0");
1:eae88fe:         brokerService.setDeleteAllMessagesOnStartup(true);
1:eae88fe: 
1:eae88fe:         PolicyEntry policy = new PolicyEntry();
1:eae88fe:         policy.setPrioritizedMessages(true);
1:cb96783:         policy.setMaxPageSize(500);
1:cb96783: 
1:833d308:         StorePendingDurableSubscriberMessageStoragePolicy durableSubPending = new StorePendingDurableSubscriberMessageStoragePolicy();
1:fe31092:         durableSubPending.setImmediatePriorityDispatch(true);
1:fe31092:         durableSubPending.setUseCache(true);
1:fe31092:         policy.setPendingDurableSubscriberPolicy(durableSubPending);
1:fe31092: 
1:eae88fe:         PolicyMap policyMap = new PolicyMap();
1:eae88fe:         policyMap.setDefaultEntry(policy);
1:eae88fe:         brokerService.setDestinationPolicy(policyMap);
1:cb96783: 
1:833d308:         setPersistenceAdapter(brokerService, persistenceAdapterChoice);
1:eae88fe: 
1:eae88fe:         return brokerService;
1:cb96783:     }
1:eae88fe: 
1:f7f294f:     @Override
1:eae88fe:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
1:833d308:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString());
1:eae88fe:         ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:eae88fe:         prefetchPolicy.setAll(1);
1:eae88fe:         factory.setPrefetchPolicy(prefetchPolicy);
1:cb96783: 
1:cb96783:         factory.setDispatchAsync(true);
1:eae88fe:         return factory;
1:eae88fe:     }
1:eae88fe: 
1:cb96783:     class TimedMessageListener implements MessageListener {
1:cb96783:         final int batchSize = 1000;
1:cb96783:         CountDownLatch firstReceiptLatch = new CountDownLatch(1);
1:cb96783:         long mark = System.currentTimeMillis();
1:cb96783:         long firstReceipt = 0l;
1:cb96783:         long receiptAccumulator = 0;
1:cb96783:         long batchReceiptAccumulator = 0;
1:cb96783:         long maxReceiptTime = 0;
1:cb96783:         AtomicLong count = new AtomicLong(0);
1:fe31092:         Map<Integer, MessageIdList> messageLists = new ConcurrentHashMap<Integer, MessageIdList>(new HashMap<Integer, MessageIdList>());
1:cb96783: 
1:cb96783:         @Override
1:cb96783:         public void onMessage(Message message) {
1:cb96783:             final long current = System.currentTimeMillis();
1:cb96783:             final long duration = current - mark;
1:cb96783:             receiptAccumulator += duration;
1:fe31092:             int priority = 0;
1:fe31092:             try {
1:fe31092:                 priority = message.getJMSPriority();
1:833d308:             } catch (JMSException ignored) {
1:833d308:             }
1:fe31092:             if (!messageLists.containsKey(priority)) {
1:833d308:                 MessageIdList perPriorityList = new MessageIdList();
1:c55f6a8:                 perPriorityList.setParent(allMessagesList);
1:c55f6a8:                 messageLists.put(priority, perPriorityList);
1:fe31092:             }
1:fe31092:             messageLists.get(priority).onMessage(message);
1:cb96783:             if (count.incrementAndGet() == 1) {
1:cb96783:                 firstReceipt = duration;
1:cb96783:                 firstReceiptLatch.countDown();
1:cb96783:                 LOG.info("First receipt in " + firstReceipt + "ms");
1:cb96783:             } else if (count.get() % batchSize == 0) {
1:fe31092:                 LOG.info("Consumed " + count.get() + " in " + batchReceiptAccumulator + "ms" + ", priority:" + priority);
1:833d308:                 batchReceiptAccumulator = 0;
1:cb96783:             }
1:cb96783:             maxReceiptTime = Math.max(maxReceiptTime, duration);
1:cb96783:             receiptAccumulator += duration;
1:cb96783:             batchReceiptAccumulator += duration;
1:cb96783:             mark = current;
1:cb96783:         }
1:cb96783: 
1:cb96783:         long getMessageCount() {
1:cb96783:             return count.get();
1:cb96783:         }
1:cb96783: 
1:cb96783:         long getFirstReceipt() throws Exception {
1:cb96783:             firstReceiptLatch.await(30, TimeUnit.SECONDS);
1:cb96783:             return firstReceipt;
1:cb96783:         }
1:cb96783: 
1:cb96783:         public long waitForReceivedLimit(long limit) throws Exception {
1:833d308:             final long expiry = System.currentTimeMillis() + 30 * 60 * 1000;
1:cb96783:             while (count.get() < limit) {
1:cb96783:                 if (System.currentTimeMillis() > expiry) {
1:cb96783:                     throw new RuntimeException("Expired waiting for X messages, " + limit);
1:cb96783:                 }
1:cb96783:                 TimeUnit.SECONDS.sleep(2);
1:fe31092:                 String missing = findFirstMissingMessage();
1:fe31092:                 if (missing != null) {
1:fe31092:                     LOG.info("first missing = " + missing);
1:fe31092:                     throw new RuntimeException("We have a missing message. " + missing);
1:fe31092:                 }
1:fe31092: 
1:cb96783:             }
1:833d308:             return receiptAccumulator / (limit / batchSize);
1:cb96783:         }
1:fe31092: 
1:fe31092:         private String findFirstMissingMessage() {
1:fe31092:             MessageId current = new MessageId();
1:fe31092:             for (MessageIdList priorityList : messageLists.values()) {
1:fe31092:                 MessageId previous = null;
1:fe31092:                 for (String id : priorityList.getMessageIds()) {
1:fe31092:                     current.setValue(id);
1:fe31092:                     if (previous == null) {
1:fe31092:                         previous = current.copy();
1:fe31092:                     } else {
1:833d308:                         if (current.getProducerSequenceId() - 1 != previous.getProducerSequenceId()
1:833d308:                             && current.getProducerSequenceId() - 10 != previous.getProducerSequenceId()) {
1:833d308:                             return "Missing next after: " + previous + ", got: " + current;
1:fe31092:                         } else {
1:fe31092:                             previous = current.copy();
1:fe31092:                         }
1:fe31092:                     }
1:fe31092:                 }
1:fe31092:             }
1:fe31092:             return null;
1:fe31092:         }
1:cb96783:     }
1:eae88fe: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:833d308
/////////////////////////////////////////////////////////////////////////
1: import org.junit.runners.Parameterized.Parameters;
/////////////////////////////////////////////////////////////////////////
1:     @Parameters(name="{0}")
1:         TestSupport.PersistenceAdapterChoice[] kahaDb = { TestSupport.PersistenceAdapterChoice.KahaDB };
1:         TestSupport.PersistenceAdapterChoice[] levelDb = { TestSupport.PersistenceAdapterChoice.LevelDB };
1:         TestSupport.PersistenceAdapterChoice[] mem = { TestSupport.PersistenceAdapterChoice.MEM };
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("With inactive consumers: ave: " + inactiveConsumerStats[1] + ", max: " + inactiveConsumerStats[0] + ", multiplier: "
1:             + (inactiveConsumerStats[0] / inactiveConsumerStats[1]));
/////////////////////////////////////////////////////////////////////////
1:         LOG.info(" with concurrent activate, ave: " + statsWithActive[1] + ", max: " + statsWithActive[0] + ", multiplier: "
1:             + (statsWithActive[0] / statsWithActive[1]));
1:         while (consumers.size() < consumersToActivate) {
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Ave time to first message =" + timeToFirstAccumulator / consumers.size());
1:         LOG.info("Ave send time with active: " + statsWithActive[1] + " as multiplier of ave with none active: " + inactiveConsumerStats[1] + ", multiplier="
1:             + (statsWithActive[1] / inactiveConsumerStats[1]));
1:         assertTrue("Ave send time with active: " + statsWithActive[1] + " within reasonable multpler of ave with none active: " + inactiveConsumerStats[1]
1:             + ", multiplier " + (statsWithActive[1] / inactiveConsumerStats[1]), statsWithActive[1] < 15 * inactiveConsumerStats[1]);
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("With consumer: " + withConsumerStats[1] + " , with noConsumer: " + noConsumerStats[1] + ", multiplier: "
1:             + (withConsumerStats[1] / noConsumerStats[1]));
1:         assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: " + noConsumerStats[1] + ", multiplier: "
1:             + (withConsumerStats[1] / noConsumerStats[1]), withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);
/////////////////////////////////////////////////////////////////////////
1:         for (Connection connection : connections) {
/////////////////////////////////////////////////////////////////////////
1:         final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic) dest, name);
/////////////////////////////////////////////////////////////////////////
1:     private double[] produceMessages(Destination destination, final int toSend, final int numIterations, Session session, MessageProducer producer,
1:         Object addConsumerSignal) throws Exception {
1:         for (int i = 0; i < numIterations; i++) {
1:             for (int j = 0; j < toSend; j++) {
1:                 int priority = ((int) count % 10);
/////////////////////////////////////////////////////////////////////////
1:                 }
1:                 ;
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Iteration " + i + ", sent " + toSend + ", time: " + duration + ", batchMax:" + batchMax + ", singleSendMax:" + max);
1:         return new double[] { batchMax, sum / numIterations };
/////////////////////////////////////////////////////////////////////////
1:         StorePendingDurableSubscriberMessageStoragePolicy durableSubPending = new StorePendingDurableSubscriberMessageStoragePolicy();
/////////////////////////////////////////////////////////////////////////
1:         setPersistenceAdapter(brokerService, persistenceAdapterChoice);
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(broker.getTransportConnectors().get(0).getPublishableConnectString());
/////////////////////////////////////////////////////////////////////////
1:             } catch (JMSException ignored) {
1:             }
1:                 MessageIdList perPriorityList = new MessageIdList();
/////////////////////////////////////////////////////////////////////////
1:                 batchReceiptAccumulator = 0;
/////////////////////////////////////////////////////////////////////////
1:             final long expiry = System.currentTimeMillis() + 30 * 60 * 1000;
/////////////////////////////////////////////////////////////////////////
1:             return receiptAccumulator / (limit / batchSize);
/////////////////////////////////////////////////////////////////////////
1:                         if (current.getProducerSequenceId() - 1 != previous.getProducerSequenceId()
1:                             && current.getProducerSequenceId() - 10 != previous.getProducerSequenceId()) {
1:                             return "Missing next after: " + previous + ", got: " + current;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:f7f294f
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
1: @RunWith(value = Parameterized.class)
1:     private final int consumerCount = 5;
1:     private final int messageSize = 1024;
1:     private final TestSupport.PersistenceAdapterChoice persistenceAdapterChoice;
1: 
0:     @Parameterized.Parameters
1:     public static Collection<TestSupport.PersistenceAdapterChoice[]> getTestParameters() {
0:         TestSupport.PersistenceAdapterChoice[] kahaDb = {TestSupport.PersistenceAdapterChoice.KahaDB};
0:         TestSupport.PersistenceAdapterChoice[] levelDb = {TestSupport.PersistenceAdapterChoice.LevelDB};
0:         TestSupport.PersistenceAdapterChoice[] mem = {TestSupport.PersistenceAdapterChoice.MEM};
1:         List<TestSupport.PersistenceAdapterChoice[]> choices = new ArrayList<TestSupport.PersistenceAdapterChoice[]>();
1:         choices.add(kahaDb);
1:         choices.add(levelDb);
1:         choices.add(mem);
1:         return choices;
1:     public ConcurrentProducerDurableConsumerTest(TestSupport.PersistenceAdapterChoice choice) {
1:         this.persistenceAdapterChoice = choice;
1:     }
1: 
1:     @Test(timeout = 120000)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 };
/////////////////////////////////////////////////////////////////////////
1:     @Before
1:     public void setUp() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     @After
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             setPersistenceAdapter(brokerService, persistenceAdapterChoice);
1:     @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ef24cc9
commit:42e51a3
/////////////////////////////////////////////////////////////////////////
1:         brokerService.addConnector("tcp://0.0.0.0:0");
/////////////////////////////////////////////////////////////////////////
0: //        if (false) {
0: //            // external mysql works a lot faster
0: //            //
/////////////////////////////////////////////////////////////////////////
0:             /* add mysql bits to the pom in the testing dependencies
0:                     <dependency>
0:                         <groupId>mysql</groupId>
0:                         <artifactId>mysql-connector-java</artifactId>
0:                         <version>5.1.10</version>
0:                         <scope>test</scope>
0:                     </dependency>
0:                     <dependency>
0:                         <groupId>commons-dbcp</groupId>
0:                         <artifactId>commons-dbcp</artifactId>
0:                         <version>1.2.2</version>
0:                         <scope>test</scope>
0:                     </dependency>
0: //        } else {
0: //        }
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
0:             broker.getTransportConnectors().get(0).getPublishableConnectString());
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:77a679b
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB,  PersistenceAdapterChoice.MEM});
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
author:Gary Tully
-------------------------------------------------------------------------------
commit:c55f6a8
/////////////////////////////////////////////////////////////////////////
0:                 MessageIdList perPriorityList =  new MessageIdList();
1:                 perPriorityList.setParent(allMessagesList);
1:                 messageLists.put(priority, perPriorityList);
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy;
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
1:         double[] statsWithActive = produceMessages(destination, 500, 10, session, producer, addConsumerSignal);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Ave batch receipt time: " + listener.waitForReceivedLimit(10000) + " max receipt: " + listener.maxReceiptTime);
/////////////////////////////////////////////////////////////////////////
1:                 // rotate
0:                 int priority = ((int)count%10);
1:                 producer.send(msg, DeliveryMode.PERSISTENT, priority, 0);
/////////////////////////////////////////////////////////////////////////
0:         StorePendingDurableSubscriberMessageStoragePolicy durableSubPending =
0:                 new StorePendingDurableSubscriberMessageStoragePolicy();
1:         durableSubPending.setImmediatePriorityDispatch(true);
1:         durableSubPending.setUseCache(true);
1:         policy.setPendingDurableSubscriberPolicy(durableSubPending);
1: 
/////////////////////////////////////////////////////////////////////////
1:         Map<Integer, MessageIdList> messageLists = new ConcurrentHashMap<Integer, MessageIdList>(new HashMap<Integer, MessageIdList>());
1:             int priority = 0;
1:             try {
1:                 priority = message.getJMSPriority();
0:             } catch (JMSException ignored) {}
1:             if (!messageLists.containsKey(priority)) {
0:                 messageLists.put(priority, new MessageIdList());
1:             }
1:             messageLists.get(priority).onMessage(message);
1:                 LOG.info("Consumed " + count.get() + " in " + batchReceiptAccumulator + "ms" + ", priority:" + priority);
/////////////////////////////////////////////////////////////////////////
1:                 String missing = findFirstMissingMessage();
1:                 if (missing != null) {
1:                     LOG.info("first missing = " + missing);
1:                     throw new RuntimeException("We have a missing message. " + missing);
1:                 }
1: 
1: 
1:         private String findFirstMissingMessage() {
1:             MessageId current = new MessageId();
1:             for (MessageIdList priorityList : messageLists.values()) {
1:                 MessageId previous = null;
1:                 for (String id : priorityList.getMessageIds()) {
1:                     current.setValue(id);
1:                     if (previous == null) {
1:                         previous = current.copy();
1:                     } else {
0:                         if (current.getProducerSequenceId() - 1 != previous.getProducerSequenceId() &&
0:                             current.getProducerSequenceId() - 10 !=  previous.getProducerSequenceId()) {
0:                                 return "Missing next after: " + previous + ", got: " + current;
1:                         } else {
1:                             previous = current.copy();
1:                         }
1:                     }
1:                 }
1:             }
1:             return null;
1:         }
commit:0298440
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, /* too slow for hudson - PersistenceAdapterChoice.JDBC,*/  PersistenceAdapterChoice.MEM});
commit:cb96783
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.atomic.AtomicLong;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
/////////////////////////////////////////////////////////////////////////
0: //import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
0: //import org.apache.commons.dbcp.BasicDataSource;
0:     private int consumerCount = 5;
1:     protected Map<MessageConsumer, TimedMessageListener> consumers = new HashMap<MessageConsumer, TimedMessageListener>();
0:     public void initCombosForTestSendRateWithActivatingConsumers() throws Exception {
1:     public void testSendRateWithActivatingConsumers() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         double[] inactiveConsumerStats = produceMessages(destination, 500, 10, session, producer, null);
1:         // periodically start a durable sub that has a backlog
1:         final int consumersToActivate = 5;
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("Waiting for add signal from producer...");
1:                         TimedMessageListener listener = new TimedMessageListener();
1:                         consumer.setMessageListener(listener);
1:                         consumers.put(consumer, listener);
/////////////////////////////////////////////////////////////////////////
0:         double[] statsWithActive = produceMessages(destination, 300, 10, session, producer, addConsumerSignal);
0:         LOG.info(" with concurrent activate, ave: " + statsWithActive[1] + ", max: " + statsWithActive[0] + ", multiplier: " + (statsWithActive[0]/ statsWithActive[1]));
0:         while(consumers.size() < consumersToActivate) {
1:             TimeUnit.SECONDS.sleep(2);
1:         }
1: 
1:         long timeToFirstAccumulator = 0;
1:         for (TimedMessageListener listener : consumers.values()) {
1:             long time = listener.getFirstReceipt();
1:             timeToFirstAccumulator += time;
1:             LOG.info("Time to first " + time);
1:         }
0:         LOG.info("Ave time to first message =" + timeToFirstAccumulator/consumers.size());
1: 
1:         for (TimedMessageListener listener : consumers.values()) {
0:             LOG.info("Ave batch receipt time: " + listener.waitForReceivedLimit(5000) + " max receipt: " + listener.maxReceiptTime);
1:         }
1: 
0:         //assertTrue("max (" + statsWithActive[0] + ") within reasonable multiplier of ave (" + statsWithActive[1] + ")",
0:         //        statsWithActive[0] < 5 * statsWithActive[1]);
1: 
1:         // compare no active to active
0:         LOG.info("Ave send time with active: " + statsWithActive[1]
0:                 + " as multiplier of ave with none active: " + inactiveConsumerStats[1]
0:                 + ", multiplier=" + (statsWithActive[1]/inactiveConsumerStats[1]));
1: 
0:         assertTrue("Ave send time with active: " + statsWithActive[1]
0:                 + " within reasonable multpler of ave with none active: " + inactiveConsumerStats[1]
0:                 + ", multiplier " + (statsWithActive[1]/inactiveConsumerStats[1]),
0:                 statsWithActive[1] < 15 * inactiveConsumerStats[1]);
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
1:         final int reasonableMultiplier = 15; // not so reasonable but improving
/////////////////////////////////////////////////////////////////////////
1:             TimedMessageListener list = new TimedMessageListener();
/////////////////////////////////////////////////////////////////////////
0:                                      final int toSend,
0:                                      final int numIterations,
1:         double batchMax = 0, max = 0, sum = 0;
1:                 long singleSendstart = System.currentTimeMillis();
1:                 max = Math.max(max, (System.currentTimeMillis() - singleSendstart));
1:                 if (++count % 500 == 0) {
1:                             LOG.info("Signalled add consumer");
0:                 ;
1:                     LOG.info("Sent " + count + ", singleSendMax:" + max);
1:             batchMax = Math.max(batchMax, duration);
0:             LOG.info("Iteration " + i + ", sent " + toSend + ", time: "
0:                     + duration + ", batchMax:" + batchMax + ", singleSendMax:" + max);
1:         LOG.info("Sent: " + toSend * numIterations + ", batchMax: " + batchMax + " singleSendMax: " + max);
0:         return new double[]{batchMax, sum/numIterations};
/////////////////////////////////////////////////////////////////////////
1:         policy.setMaxPageSize(500);
1: 
0:         if (false) {
0:               // external mysql works a lot faster
0:               //
0: //            JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
0: //            BasicDataSource ds = new BasicDataSource();
0: //            com.mysql.jdbc.Driver d = new com.mysql.jdbc.Driver();
0: //            ds.setDriverClassName("com.mysql.jdbc.Driver");
0: //            ds.setUrl("jdbc:mysql://localhost/activemq?relaxAutoCommit=true");
0: //            ds.setMaxActive(200);
0: //            ds.setUsername("root");
0: //            ds.setPassword("");
0: //            ds.setPoolPreparedStatements(true);
0: //            jdbc.setDataSource(ds);
0: //            brokerService.setPersistenceAdapter(jdbc);
1: 
0: /* add mysql bits to the pom in the testing dependencies
0: <dependency>
0:     <groupId>mysql</groupId>
0:     <artifactId>mysql-connector-java</artifactId>
0:     <version>5.1.10</version>
0:     <scope>test</scope>
0: </dependency>
0: <dependency>
0:     <groupId>commons-dbcp</groupId>
0:     <artifactId>commons-dbcp</artifactId>
0:     <version>1.2.2</version>
0:     <scope>test</scope>
0: </dependency>
1:              */
1:         } else {
0:             setDefaultPersistenceAdapter(brokerService);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         factory.setDispatchAsync(true);
/////////////////////////////////////////////////////////////////////////
1:     class TimedMessageListener implements MessageListener {
1:         final int batchSize = 1000;
1:         CountDownLatch firstReceiptLatch = new CountDownLatch(1);
1:         long mark = System.currentTimeMillis();
1:         long firstReceipt = 0l;
1:         long receiptAccumulator = 0;
1:         long batchReceiptAccumulator = 0;
1:         long maxReceiptTime = 0;
1:         AtomicLong count = new AtomicLong(0);
1: 
1:         @Override
1:         public void onMessage(Message message) {
1:             final long current = System.currentTimeMillis();
1:             final long duration = current - mark;
1:             receiptAccumulator += duration;
0:             allMessagesList.onMessage(message);
1:             if (count.incrementAndGet() == 1) {
1:                 firstReceipt = duration;
1:                 firstReceiptLatch.countDown();
1:                 LOG.info("First receipt in " + firstReceipt + "ms");
1:             } else if (count.get() % batchSize == 0) {
0:                 LOG.info("Consumed " + batchSize + " in " + batchReceiptAccumulator + "ms");
0:                 batchReceiptAccumulator=0;
1:             }
1:             maxReceiptTime = Math.max(maxReceiptTime, duration);
1:             receiptAccumulator += duration;
1:             batchReceiptAccumulator += duration;
1:             mark = current;
1:         }
1: 
1:         long getMessageCount() {
1:             return count.get();
1:         }
1: 
1:         long getFirstReceipt() throws Exception {
1:             firstReceiptLatch.await(30, TimeUnit.SECONDS);
1:             return firstReceipt;
1:         }
1: 
1:         public long waitForReceivedLimit(long limit) throws Exception {
0:             final long expiry = System.currentTimeMillis() + 30*60*1000;
1:             while (count.get() < limit) {
1:                 if (System.currentTimeMillis() > expiry) {
1:                     throw new RuntimeException("Expired waiting for X messages, " + limit);
1:                 }
1:                 TimeUnit.SECONDS.sleep(2);
1:             }
0:             return receiptAccumulator/(limit/batchSize);
1:         }
1:     }
1: 
commit:eae88fe
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.TimeUnit;
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.TopicSubscriber;
0: import junit.framework.Test;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: import org.apache.activemq.TestSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.util.MessageIdList;
1: import org.apache.activemq.util.Wait;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: public class ConcurrentProducerDurableConsumerTest extends TestSupport {
0:     private static final Log LOG = LogFactory.getLog(ConcurrentProducerDurableConsumerTest.class);
0:     private int consumerCount = 1;
1:     BrokerService broker;
1:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
0:     protected Map<MessageConsumer, MessageIdList> consumers = new HashMap<MessageConsumer, MessageIdList>();
1:     protected MessageIdList allMessagesList = new MessageIdList();
0:     private int messageSize = 1024;
1: 
0:     public void testPlaceHolder() throws Exception {
1:     }
1: 
0:     public void x_initCombosForTestSendRateWithActivatingConsumers() throws Exception {
0:         addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC, PersistenceAdapterChoice.MEM});
1:     }
1: 
0:     public void x_testSendRateWithActivatingConsumers() throws Exception {
1:         final Destination destination = createDestination();
1:         final ConnectionFactory factory = createConnectionFactory();
1:         startInactiveConsumers(factory, destination);
1: 
1:         Connection connection = factory.createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = createMessageProducer(session, destination);
1: 
1:         // preload the durable consumers
0:         double[] inactiveConsumerStats = produceMessages(destination, 200, 100, session, producer, null);
0:         LOG.info("With inactive consumers: ave: " + inactiveConsumerStats[1]
0:                 + ", max: " + inactiveConsumerStats[0] + ", multiplier: " + (inactiveConsumerStats[0]/inactiveConsumerStats[1]));
1: 
0:         // periodically start a durable sub that is has a backlog
0:         final int consumersToActivate = 1;
1:         final Object addConsumerSignal = new Object();
1:         Executors.newCachedThreadPool(new ThreadFactory() {
1:             @Override
1:             public Thread newThread(Runnable r) {
1:                 return new Thread(r, "ActivateConsumer" + this);
1:             }
1:         }).execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     MessageConsumer consumer = null;
1:                     for (int i = 0; i < consumersToActivate; i++) {
0:                         LOG.info("Waiting for add signal");
1:                         synchronized (addConsumerSignal) {
1:                             addConsumerSignal.wait(30 * 60 * 1000);
1:                         }
1:                         consumer = createDurableSubscriber(factory.createConnection(), destination, "consumer" + (i + 1));
1:                         LOG.info("Created consumer " + consumer);
0:                         MessageIdList list = new MessageIdList();
0:                         list.setParent(allMessagesList);
1:                         consumer.setMessageListener(list);
1:                         consumers.put(consumer, list);
1:                     }
1:                 } catch (Exception e) {
1:                     LOG.error("failed to start consumer", e);
1:                 }
1:             }
1:         });
1: 
1: 
0:         double[] stats  = produceMessages(destination, 20, 100, session, producer, addConsumerSignal);
1: 
0:         LOG.info(" with concurrent activate, ave: " + stats[1] + ", max: " + stats[0] + ", multiplier: " + (stats[0]/stats[1]));
0:         assertTrue("max (" + stats[0] + ") within reasonable multiplier of ave (" + stats[1] + ")",
0:                 stats[0] < 5 * stats[1]);
1: 
1:     }
1: 
1: 
0:     public void x_initCombosForTestSendWithInactiveAndActiveConsumers() throws Exception {
0:         addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC, PersistenceAdapterChoice.MEM});
1:     }
1: 
1:     public void x_testSendWithInactiveAndActiveConsumers() throws Exception {
1:         Destination destination = createDestination();
1:         ConnectionFactory factory = createConnectionFactory();
1:         startInactiveConsumers(factory, destination);
1: 
1:         Connection connection = factory.createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(destination);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         final int toSend = 100;
1:         final int numIterations = 5;
1: 
1:         double[] noConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1: 
1:         startConsumers(factory, destination);
1:         LOG.info("Activated consumer");
1: 
1:         double[] withConsumerStats = produceMessages(destination, toSend, numIterations, session, producer, null);
1: 
0:         LOG.info("With consumer: " + withConsumerStats[1] + " , with noConsumer: " + noConsumerStats[1]
0:                 + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]));
0:         final int reasonableMultiplier = 4; // not so reasonable, but on slow disks it can be
0:         assertTrue("max X times as slow with consumer: " + withConsumerStats[1] + ", with no Consumer: "
0:                 + noConsumerStats[1] + ", multiplier: " + (withConsumerStats[1]/noConsumerStats[1]),
0:                 withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);
1: 
1:         final int toReceive = toSend * numIterations * consumerCount * 2;
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("count: " + allMessagesList.getMessageCount());
1:                 return toReceive == allMessagesList.getMessageCount();
1:             }
1:         }, 60 * 1000);
1: 
1:         assertEquals("got all messages", toReceive, allMessagesList.getMessageCount());
1:     }
1: 
1: 
1:     private MessageProducer createMessageProducer(Session session, Destination destination) throws JMSException {
1:         MessageProducer producer = session.createProducer(destination);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:         return producer;
1:     }
1: 
1: 
1:     private void startInactiveConsumers(ConnectionFactory factory, Destination destination) throws Exception {
1:         // create off line consumers
1:         startConsumers(factory, destination);
0:         for (Connection connection: connections) {
1:             connection.close();
1:         }
1:         connections.clear();
1:         consumers.clear();
1:     }
1: 
1: 
1:     protected void startConsumers(ConnectionFactory factory, Destination dest) throws Exception {
1:         MessageConsumer consumer;
1:         for (int i = 0; i < consumerCount; i++) {
1:             consumer = createDurableSubscriber(factory.createConnection(), dest, "consumer" + (i + 1));
0:             MessageIdList list = new MessageIdList();
0:             list.setParent(allMessagesList);
1:             consumer.setMessageListener(list);
1:             consumers.put(consumer, list);
1:         }
1:     }
1: 
1:     protected TopicSubscriber createDurableSubscriber(Connection conn, Destination dest, String name) throws Exception {
1:         conn.setClientID(name);
1:         connections.add(conn);
1:         conn.start();
1: 
1:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         final TopicSubscriber consumer = sess.createDurableSubscriber((javax.jms.Topic)dest, name);
1: 
1:         return consumer;
1:     }
1: 
1:     /**
1:      * @return max and ave send time
1:      * @throws Exception
1:      */
0:     private double[] produceMessages(Destination destination,
0:                                      int toSend,
0:                                      int numIterations,
0:                                      Session session,
0:                                      MessageProducer producer,
0:                                      Object addConsumerSignal) throws Exception {
1:         long start;
1:         long count = 0;
0:         double max = 0, sum = 0;
0:         for (int i=0; i<numIterations; i++) {
1:             start = System.currentTimeMillis();
0:             for (int j=0; j < toSend; j++) {
1:                 TextMessage msg = createTextMessage(session, "" + j);
0:                 producer.send(msg);
0:                 if (++count % 300 == 0) {
1:                     if (addConsumerSignal != null) {
1:                         synchronized (addConsumerSignal) {
1:                             addConsumerSignal.notifyAll();
0:                             LOG.info("Signaled add consumer");
1:                         }
1:                     }
1:                 }
1:                 if (count % 5000 == 0) {
0:                     LOG.info("Sent " + count);
1:                 }
1: 
1:             }
1:             long duration = System.currentTimeMillis() - start;
0:             max = Math.max(max, duration);
1:             sum += duration;
1:         }
1: 
0:         LOG.info("Sent: " + toSend * numIterations + ", max send time: " + max);
0:         return new double[]{max, sum/numIterations};
1:     }
1: 
1:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:         TextMessage msg = session.createTextMessage();
1: 
1:         // Pad message text
1:         if (initText.length() < messageSize) {
1:             char[] data = new char[messageSize - initText.length()];
1:             Arrays.fill(data, '*');
1:             String str = new String(data);
1:             msg.setText(initText + str);
1: 
1:             // Do not pad message text
0:         } else {
1:             msg.setText(initText);
1:         }
1: 
1:         return msg;
1:     }
1: 
1:     @Override
0:     protected void setUp() throws Exception {
1:         topic = true;
1:         super.setUp();
1:         broker = createBroker();
1:         broker.start();
1:     }
1: 
1:     @Override
0:     protected void tearDown() throws Exception {
1:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:             Connection conn = iter.next();
1:             try {
1:                 conn.close();
1:             } catch (Throwable e) {
1:             }
1:         }
1:         broker.stop();
1:         allMessagesList.flushMessages();
1:         consumers.clear();
1:         super.tearDown();
1:     }
1: 
1: 
1:     protected BrokerService createBroker() throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setEnableStatistics(false);
0:         brokerService.addConnector("tcp://0.0.0.0:61616");
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1: 
1:         PolicyEntry policy = new PolicyEntry();
1:         policy.setPrioritizedMessages(true);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setDefaultEntry(policy);
1:         brokerService.setDestinationPolicy(policyMap);
1: 
0:         //setPersistenceAdapter(brokerService, PersistenceAdapterChoice.JDBC);
0:         setDefaultPersistenceAdapter(brokerService);
1:         return brokerService;
1:     }
1: 
1:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
1:         ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:         prefetchPolicy.setAll(1);
1:         factory.setPrefetchPolicy(prefetchPolicy);
1:         return factory;
1:     }
1: 
0:     public static Test suite() {
0:         return suite(ConcurrentProducerDurableConsumerTest.class);
1:     }
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ConcurrentProducerDurableConsumerTest.class);
============================================================================