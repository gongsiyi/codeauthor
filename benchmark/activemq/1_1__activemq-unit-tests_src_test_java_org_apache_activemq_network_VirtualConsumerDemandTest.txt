1:cc81680: /**
1:cc81680:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:cc81680:  * contributor license agreements.  See the NOTICE file distributed with
1:cc81680:  * this work for additional information regarding copyright ownership.
1:cc81680:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:cc81680:  * (the "License"); you may not use this file except in compliance with
1:cc81680:  * the License.  You may obtain a copy of the License at
1:cc81680:  *
1:cc81680:  *      http://www.apache.org/licenses/LICENSE-2.0
1:cc81680:  *
1:cc81680:  * Unless required by applicable law or agreed to in writing, software
1:cc81680:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cc81680:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cc81680:  * See the License for the specific language governing permissions and
1:cc81680:  * limitations under the License.
1:cc81680:  */
1:cc81680: package org.apache.activemq.network;
13:cc81680: 
1:cc81680: import static org.junit.Assert.assertEquals;
1:cc81680: import static org.junit.Assert.assertNotNull;
1:cc81680: import static org.junit.Assert.assertNull;
1:cc81680: import static org.junit.Assert.assertTrue;
1:cc81680: 
1:cc81680: import java.lang.reflect.Field;
1:cc81680: import java.net.URI;
1:cc81680: import java.util.Arrays;
1:cc81680: import java.util.Collection;
1:e73ab34: import java.util.List;
1:cc81680: import java.util.Set;
1:cc81680: import java.util.concurrent.ConcurrentMap;
1:cc81680: 
1:cc81680: import javax.jms.JMSException;
1:cc81680: import javax.jms.Message;
1:cc81680: import javax.jms.MessageConsumer;
1:cc81680: import javax.jms.MessageProducer;
1:cc81680: import javax.jms.Session;
1:cc81680: 
1:cc81680: import org.apache.activemq.ActiveMQConnectionFactory;
1:cc81680: import org.apache.activemq.advisory.AdvisoryBroker;
1:cc81680: import org.apache.activemq.advisory.AdvisorySupport;
1:cc81680: import org.apache.activemq.broker.BrokerPlugin;
1:cc81680: import org.apache.activemq.broker.BrokerService;
1:e73ab34: import org.apache.activemq.broker.TransportConnector;
1:cc81680: import org.apache.activemq.broker.region.DestinationInterceptor;
1:cc81680: import org.apache.activemq.broker.region.DestinationStatistics;
1:cc81680: import org.apache.activemq.broker.region.virtual.CompositeQueue;
1:cc81680: import org.apache.activemq.broker.region.virtual.CompositeTopic;
1:cc81680: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1:cc81680: import org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor;
1:cc81680: import org.apache.activemq.command.ActiveMQDestination;
1:cc81680: import org.apache.activemq.command.ActiveMQMessage;
1:cc81680: import org.apache.activemq.command.ActiveMQQueue;
1:cc81680: import org.apache.activemq.command.ActiveMQTopic;
1:cc81680: import org.apache.activemq.command.ConsumerInfo;
1:cc81680: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationBroker;
1:cc81680: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationPlugin;
1:cc81680: import org.apache.activemq.util.Wait;
1:cc81680: import org.junit.After;
1:cc81680: import org.junit.Assume;
1:cc81680: import org.junit.Before;
1:cc81680: import org.junit.Test;
1:cc81680: import org.junit.runner.RunWith;
1:cc81680: import org.junit.runners.Parameterized;
1:cc81680: import org.junit.runners.Parameterized.Parameters;
1:cc81680: import org.slf4j.Logger;
1:cc81680: import org.slf4j.LoggerFactory;
1:cc81680: 
1:cc81680: import com.google.common.collect.Lists;
1:cc81680: 
1:cc81680: /**
1:cc81680:  * This test is to show that dynamicallyIncludedDestinations will work properly
1:cc81680:  * when a network of brokers is configured to treat Virtual Destinations (Virtual topic and composite destination)
1:cc81680:  * as demand.
1:cc81680:  */
1:cc81680: @RunWith(Parameterized.class)
1:09054fc: public class VirtualConsumerDemandTest extends DynamicNetworkTestSupport {
1:cc81680: 
1:cc81680:     protected static final int MESSAGE_COUNT = 10;
1:cc81680:     private static final Logger LOG = LoggerFactory.getLogger(VirtualConsumerDemandTest.class);
1:cc81680: 
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * test params
1:cc81680:      */
1:cc81680:     @Parameters
1:cc81680:     public static Collection<Object[]> data() {
1:cc81680:         return Arrays.asList(new Object[][] {
1:cc81680:                 //not duplex, useVirtualDestSubsOnCreation
1:cc81680:                 {false, true},
1:cc81680:                 //duplex
1:cc81680:                 {true, false},
1:cc81680:                 {true, true},
1:cc81680:                 {false, false}
3:cc81680:         });
11:cc81680:     }
1:09054fc: 
1:cc81680: 
1:cc81680:     protected JavaRuntimeConfigurationBroker runtimeBroker;
1:cc81680:     protected String consumerName = "durableSubs";
1:cc81680:     protected String testQueueName = "include.test.foo";
1:cc81680: 
1:cc81680:     private final boolean isDuplex;
1:cc81680:     private final boolean isUseVirtualDestSubsOnCreation;
1:cc81680: 
1:cc81680: 
1:cc81680:     public VirtualConsumerDemandTest(boolean isDuplex, boolean isUseVirtualDestSubsOnCreation) {
1:cc81680:        // Assume.assumeTrue(
1:cc81680:         super();
1:cc81680:         this.isDuplex = isDuplex;
1:cc81680:         this.isUseVirtualDestSubsOnCreation = isUseVirtualDestSubsOnCreation;
1:cc81680:     }
1:cc81680: 
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that the creation of a virtual topic will cause demand
1:cc81680:      * even without a consumer for the case of useVirtualDestSubsOnCreation == true
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:56baba9:     public void testVirtualTopics() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
2:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer("VirtualTopic.>");
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar"));
1:56baba9:         MessageProducer includedProducer2 = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar2"));
1:56baba9:         MessageProducer includedProducer3 = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar3"));
17:cc81680:         Thread.sleep(2000);
2:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar")).getDestinationStatistics();
1:56baba9:         final DestinationStatistics destinationStatistics2 = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar2")).getDestinationStatistics();
1:56baba9: 
1:56baba9:         //No queue destination on the remote side so should not forward
1:56baba9:         final DestinationStatistics destinationStatistics3 = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar3")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         //this will create the destination so messages accumulate
1:cc81680:         final DestinationStatistics remoteStats = remoteBroker.getDestination(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar")).getDestinationStatistics();
1:56baba9:         final DestinationStatistics remoteStats2 = remoteBroker.getDestination(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar2")).getDestinationStatistics();
1:56baba9: 
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:56baba9:         waitForConsumerCount(destinationStatistics2, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:56baba9:         includedProducer2.send(localSession.createTextMessage("test2"));
1:56baba9:         includedProducer3.send(localSession.createTextMessage("test3"));
1:cc81680: 
1:cc81680:         //assert statistics
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:56baba9:         waitForDispatchFromLocalBroker(destinationStatistics2, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:56baba9:         assertLocalBrokerStatistics(destinationStatistics2, 1);
1:cc81680:         assertEquals("remote dest messages", 1, remoteStats.getMessages().getCount());
1:56baba9:         assertEquals("remote dest messages", 1, remoteStats2.getMessages().getCount());
1:cc81680: 
1:56baba9:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:56baba9:         assertAdvisoryBrokerCounts(1,2,2);
1:56baba9: 
1:56baba9:         //should not have forwarded for 3rd topic
1:56baba9:         Thread.sleep(1000);
1:56baba9:         assertEquals("local broker dest stat dispatched", 0, destinationStatistics3.getDispatched().getCount());
1:cc81680:     }
1:cc81680: 
1:cc81680: 
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that the creation of a virtual topic with a consumer will cause
1:cc81680:      * demand regardless of useVirtualDestSubsOnCreation
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testVirtualTopicWithConsumer() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:        //use just the default virtual topic setup
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer("VirtualTopic.>");
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar"));
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar"));
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 1);
1:cc81680: 
1:cc81680:         if (isUseVirtualDestSubsOnCreation) {
1:cc81680:             assertAdvisoryBrokerCounts(1,2,1);
1:cc81680:         } else {
1:cc81680:             assertAdvisoryBrokerCounts(1,1,0);
1:cc81680:         }
1:cc81680:     }
1:cc81680: 
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that when a consumer goes offline for a virtual topic, that messages still flow
1:cc81680:      * to that queue if isUseVirtualDestSubsOnCreation is true
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testVirtualTopicWithConsumerGoOffline() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680:         //use just the default virtual topic setup
1:cc81680:         doSetUp(true, null);
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer("VirtualTopic.>");
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar"));
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar"));
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         //assert a message was forwarded
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         //close the consumer and send a second message
1:cc81680:         bridgeConsumer.close();
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         //check that the message was forwarded
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 2);
1:cc81680: 
1:cc81680:         //make sure that the message can be received
1:cc81680:         MessageConsumer bridgeConsumer2 = remoteSession.createConsumer(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar"));
1:cc81680:         assertNotNull(bridgeConsumer2.receive(5000));
1:cc81680: 
1:cc81680:         //should be 4 advisories...1 or the virtual destination creation to a queue,
1:cc81680:         //2 for new consumers, and 1 for a closed consumer
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 4);
1:cc81680:         assertAdvisoryBrokerCounts(1,2,1);
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * This test shows that if isUseVirtualDestSubsOnCreation is true,
1:cc81680:      * the creation of a composite destination that forwards to a Queue will create
1:cc81680:      * a virtual consumer and cause demand so that the queue will accumulate messages
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testDynamicFlow() throws Exception {
1:e73ab34:         testDynamicFlow(false);
1:e73ab34:     }
1:e73ab34: 
1:e73ab34:     @Test(timeout = 60 * 1000)
1:e73ab34:     public void testDynamicFlowForceDurable() throws Exception {
1:e73ab34:         testDynamicFlow(true);
1:e73ab34:     }
1:e73ab34: 
1:e73ab34:     protected void testDynamicFlow(boolean forceDurable) throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680: 
1:e73ab34:         doSetUp(true, null, true, forceDurable);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
2:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:0c846cf:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:e73ab34:         assertNCDurableSubsCount(localBroker, included, forceDurable ? 1 : 0);
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:cc81680: 
2:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
2:cc81680:         assertAdvisoryBrokerCounts(1,1,1);
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that dynamic flow works for virtual destinations when a second composite
1:95f58fa:      * topic is included that forwards to the same queue, but is excluded from
1:95f58fa:      * being forwarded from the remote broker
1:95f58fa:      *
1:95f58fa:      * @throws Exception
1:95f58fa:      */
1:95f58fa:     @Test(timeout = 60 * 1000)
1:95f58fa:     public void testSecondNonIncludedCompositeTopicForwardSameQueue() throws Exception {
1:95f58fa:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:95f58fa: 
1:95f58fa:         doSetUp(true, null);
1:95f58fa: 
1:95f58fa:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:95f58fa: 
1:95f58fa:         //configure a composite topic that isn't included
1:95f58fa:         CompositeTopic compositeTopic = createCompositeTopic("include.test.bar2",
1:95f58fa:                 new ActiveMQQueue("include.test.bar.bridge"));
1:95f58fa: 
1:95f58fa:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:95f58fa: 
1:95f58fa:         Thread.sleep(2000);
1:95f58fa: 
1:95f58fa:         //add one that is included
1:95f58fa:         CompositeTopic compositeTopic2 = createCompositeTopic(testTopicName,
1:95f58fa:                 new ActiveMQQueue("include.test.bar.bridge"));
1:95f58fa: 
1:95f58fa:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic, compositeTopic2}, true);
1:95f58fa: 
1:95f58fa:         Thread.sleep(2000);
1:95f58fa:         MessageProducer includedProducer = localSession.createProducer(included);
1:95f58fa:         Message test = localSession.createTextMessage("test");
1:95f58fa: 
1:95f58fa:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:95f58fa:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:95f58fa:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:95f58fa: 
1:95f58fa:         waitForConsumerCount(destinationStatistics, 1);
1:95f58fa: 
1:95f58fa:         includedProducer.send(test);
1:95f58fa: 
1:95f58fa:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:95f58fa:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:95f58fa:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:95f58fa: 
1:95f58fa:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:95f58fa:         assertAdvisoryBrokerCounts(2,2,2);
1:95f58fa: 
1:95f58fa:     }
1:95f58fa: 
1:95f58fa:     /**
1:95f58fa:      * Test that dynamic flow works for virtual destinations when a second composite
1:3ef6a9f:      * topic is included, but is excluded from
1:cc81680:      * being forwarded from the remote broker
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testSecondNonIncludedCompositeTopic() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:0c846cf: 
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a composite topic that isn't included
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic("include.test.bar2",
1:3ef6a9f:                 new ActiveMQQueue("include.test.bar.bridge2"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:0c846cf:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         //add one that is included
1:cc81680:         CompositeTopic compositeTopic2 = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic, compositeTopic2}, true);
1:cc81680: 
1:0c846cf:         Thread.sleep(2000);
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:3ef6a9f:         assertAdvisoryBrokerCounts(2,1,1);
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that no messages are forwarded when isUseVirtualDestSubsOnCreation is false
1:cc81680:      * and there are no consumers
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testNoUseVirtualDestinationSubscriptionsOnCreation() throws Exception {
1:cc81680:         Assume.assumeTrue(!isUseVirtualDestSubsOnCreation);
1:cc81680: 
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:0c846cf:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:0c846cf:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 0);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 0);
1:cc81680:         assertEquals("remote dest messages", 0, remoteDestStatistics.getMessages().getCount());
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 0);
1:cc81680:         assertAdvisoryBrokerCounts(1,0,0);
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that messages still flow when updating a composite topic to remove 1 of the
1:cc81680:      * forwarded destinations, but keep the other one
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testTwoTargetsRemove1() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680: 
1:cc81680:         doSetUp(true, null);
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"),
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge2"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:0c846cf:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge2")).getDestinationStatistics();
1:cc81680: 
1:0c846cf:         Thread.sleep(2000);
1:cc81680:         //two advisory messages sent for each target when destinations are created
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:cc81680:         assertAdvisoryBrokerCounts(1,2,2);
1:cc81680: 
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:cc81680:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1:cc81680: 
1:cc81680:         compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 2);
1:cc81680: 
1:cc81680:         assertEquals("remote dest messages", 2, remoteDestStatistics.getMessages().getCount());
1:cc81680:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1:cc81680: 
1:cc81680:         //We delete 2, and re-add 1 target queue
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 3);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,1);
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that messages still flow after removing one of the destinations that is a target
1:cc81680:      * but the other one sticks around
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testTwoTargetsRemove1Destination() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680: 
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"),
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge2"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:3ef6a9f:         Thread.sleep(1000);
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge2")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:cc81680:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1:cc81680: 
1:cc81680:         remoteBroker.removeDestination(new ActiveMQQueue("include.test.bar.bridge2"));
1:cc81680:         Thread.sleep(2000);
1:cc81680:         //2 for each target queue destination in the virtual subscription
1:cc81680:         //1 for the removal of a queue
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 3);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         //make sure messages are still forwarded even after 1 target was deleted
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 2);
1:cc81680: 
1:cc81680:         assertEquals("remote dest messages", 2, remoteDestStatistics.getMessages().getCount());
1:cc81680: 
1:cc81680:         //1 because a send causes the queue to be recreated again which sends a new demand advisory
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:cc81680:         assertAdvisoryBrokerCounts(1,2,2);
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:a2781e3:      * This tests that having 2 composite destinations (1 included for dynamic flow and 1 not)
1:a2781e3:      * will allow messages to flow and that deleting 1 destination dosen't clear out the virtual
1:a2781e3:      * consumer map except for what should be cleared.
1:a2781e3:      *
1:a2781e3:      */
1:a2781e3:     @Test(timeout = 60 * 1000)
1:a2781e3:     public void testTwoCompositeTopicsRemove1() throws Exception {
1:a2781e3:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:a2781e3: 
1:a2781e3:         doSetUp(true, null);
1:a2781e3: 
1:a2781e3:         //configure a virtual destination that forwards messages from topic testQueueName
1:a2781e3:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:a2781e3:         CompositeTopic compositeTopic1 = createCompositeTopic(testTopicName,
1:a2781e3:                 new ActiveMQQueue("include.test.bar.bridge"));
1:a2781e3:         CompositeTopic compositeTopic2 = createCompositeTopic(testTopicName + 2,
1:a2781e3:                 new ActiveMQQueue("include.test.bar.bridge2"));
1:a2781e3: 
1:a2781e3:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic1, compositeTopic2}, true);
1:a2781e3: 
1:a2781e3:         MessageProducer includedProducer = localSession.createProducer(included);
1:a2781e3:         Message test = localSession.createTextMessage("test");
1:a2781e3:         Thread.sleep(1000);
1:a2781e3: 
1:a2781e3:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:a2781e3:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:a2781e3:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:a2781e3: 
1:a2781e3:         waitForConsumerCount(destinationStatistics, 1);
1:a2781e3: 
1:a2781e3:         includedProducer.send(test);
1:a2781e3: 
1:a2781e3:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:a2781e3:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:a2781e3:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:a2781e3: 
1:a2781e3:         //verify there are 2 virtual destinations but only 1 consumer and broker dest
1:a2781e3:         assertAdvisoryBrokerCounts(2,1,1);
1:a2781e3:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic1}, true);
1:a2781e3:         Thread.sleep(2000);
1:a2781e3:         //verify there is is only 1 virtual dest after deletion
1:a2781e3:         assertAdvisoryBrokerCounts(1,1,1);
1:a2781e3: 
1:a2781e3:         includedProducer.send(test);
1:a2781e3: 
1:a2781e3:         //make sure messages are still forwarded even after 1 composite topic was deleted
1:a2781e3:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:a2781e3:         assertLocalBrokerStatistics(destinationStatistics, 2);
1:a2781e3:         assertEquals("remote dest messages", 2, remoteDestStatistics.getMessages().getCount());
1:a2781e3: 
1:a2781e3:     }
1:a2781e3: 
1:a2781e3:     /**
1:cc81680:      * Test that demand is destroyed after removing both targets from the composite Topic
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testTwoTargetsRemoveBoth() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"),
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge2"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:3ef6a9f:         Thread.sleep(1000);
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge2")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:cc81680:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1:cc81680: 
1:cc81680:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {}, true);
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:cc81680:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1:cc81680: 
1:cc81680:         //2 for each target queue destination in the virtual subscription
1:cc81680:         //2 for the removal of the virtual destination, which requires 2 advisories because there are 2 targets
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 4);
1:cc81680:         assertAdvisoryBrokerCounts(0,0,0);
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that dynamic flow works when the destination is created before the
1:cc81680:      * virtual destination has been added to the broker
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testDestinationAddedFirst() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:3ef6a9f:         Thread.sleep(1000);
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680: 
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,1);
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * This test shows that a consumer listening on the target of a composite destination will create
1:cc81680:      * a virtual consumer and cause demand so that the consumer will receive messages, regardless
1:cc81680:      * of whether isUseVirtualDestSubsOnCreation is true or false
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testWithConsumer() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:3ef6a9f:         Thread.sleep(1000);
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680: 
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
3:cc81680:         Wait.waitFor(new Wait.Condition() {
3:cc81680:             @Override
3:cc81680:             public boolean isSatisified() throws Exception {
1:cc81680:                 //should only be 1 because of conduit subs even though there is 2 consumers
1:cc81680:                 //for the case where isUseVirtualDestSubsOnCreation is true,
1:cc81680:                 //1 for the composite destination creation and 1 for the actual consumer
1:cc81680:                 return 1 == destinationStatistics.getConsumers().getCount();
1:cc81680:             }
1:cc81680:         });
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         //if isUseVirtualDestSubsOnCreation is true we should have
1:cc81680:         //two advisory consumer messages, else 1
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 1);
1:cc81680:         if (isUseVirtualDestSubsOnCreation) {
1:cc81680:             assertAdvisoryBrokerCounts(1,2,1);
1:cc81680:         } else {
1:cc81680:             assertAdvisoryBrokerCounts(1,1,0);
1:cc81680:         }
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that demand still exists when only 1 of 2 consumers is removed from the
1:cc81680:      * destination
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testWith2ConsumersRemove1() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:3ef6a9f:         Thread.sleep(1000);
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680: 
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680:         MessageConsumer bridgeConsumer2 = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:cc81680:         //should only be 1 because of conduit subs even though there is 2 consumers
1:cc81680:         //for the case where isUseVirtualDestSubsOnCreation is true,
1:cc81680:         //1 for the composite destination creation and 1 for the actual consumer
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertTrue(bridgeConsumer.receive(5000) != null || bridgeConsumer2.receive(5000) != null);
1:cc81680: 
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         bridgeConsumer2.close();
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         //make sure the message is still forwarded
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 2);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 4, 3);
1:cc81680:         if (isUseVirtualDestSubsOnCreation) {
1:cc81680:             assertAdvisoryBrokerCounts(1,2,1);
1:cc81680:         } else {
1:cc81680:             assertAdvisoryBrokerCounts(1,1,0);
1:cc81680:         }
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that demand is removed after both consumers are removed when
1:cc81680:      * isUseVirtualDestSubsOnCreation is false
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testWith2ConsumersRemoveBoth() throws Exception {
1:cc81680:         Assume.assumeTrue(!isUseVirtualDestSubsOnCreation);
1:cc81680: 
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to queue "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:cc81680:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:3ef6a9f:         Thread.sleep(1000);
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680: 
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680:         MessageConsumer bridgeConsumer2 = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:cc81680:         //should only be 1 because of conduit subs even though there is 2 consumers
1:cc81680:         //for the case where isUseVirtualDestSubsOnCreation is true,
1:cc81680:         //1 for the composite destination creation and 1 for the actual consumer
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680:         assertAdvisoryBrokerCounts(1,2,0);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680:         assertTrue(bridgeConsumer.receive(5000) != null || bridgeConsumer2.receive(5000) != null);
1:cc81680: 
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         bridgeConsumer.close();
1:cc81680:         bridgeConsumer2.close();
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         //in this test, virtual destinations don't cause demand, only consumers on them
1:cc81680:         //so we should have 2 create and 2 destroy
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 4);
1:cc81680:         assertAdvisoryBrokerCounts(1,0,0);
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Show that messages won't be send for an excluded destination
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testExcluded() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages to an excluded destination
1:09054fc:         CompositeTopic compositeTopic = createCompositeTopic("exclude.test.bar",
1:09054fc:                 new ActiveMQQueue("exclude.test.bar.bridge"));
1:cc81680: 
1:cc81680:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(excluded);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:3ef6a9f:         Thread.sleep(1000);
1:cc81680: 
1:09054fc:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("exclude.test.bar.bridge"));
1:0c846cf:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(excluded).getDestinationStatistics();
1:cc81680:         assertEquals("broker consumer count", 0, destinationStatistics.getConsumers().getCount());
1:cc81680: 
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 0);
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 0);
1:cc81680:         if (isUseVirtualDestSubsOnCreation) {
1:cc81680:             assertAdvisoryBrokerCounts(1,2,1);
1:cc81680:         } else {
1:cc81680:             assertAdvisoryBrokerCounts(1,1,0);
1:cc81680:         }
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that demand will be created when using a composite queue instead of a composite topic
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testSourceQueue() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getQueueVirtualDestinationAdvisoryConsumer(testQueueName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from queue testQueueName
1:cc81680:         //to topic "include.test.foo.bridge"
1:cc81680:         CompositeQueue compositeQueue = createCompositeQueue(testQueueName,
1:cc81680:                 new ActiveMQQueue("include.test.foo.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeQueue}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQQueue(testQueueName));
1:0c846cf:         Thread.sleep(2000);
1:3ef6a9f:         Message test = localSession.createTextMessage("test");
1:3ef6a9f: 
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQQueue(testQueueName)).getDestinationStatistics();
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.foo.bridge"));
1:cc81680:         waitForConsumerCount(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         final DestinationStatistics remoteStats = remoteBroker.getDestination(new ActiveMQQueue(testQueueName)).getDestinationStatistics();
1:cc81680: 
1:cc81680:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         //should only be 1 because of conduit subs
1:cc81680:         assertEquals("broker consumer count", 1, destinationStatistics.getConsumers().getCount());
1:cc81680: 
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:cc81680: 
1:cc81680:         //check remote stats - confirm the message isn't on the remote queue and was forwarded only
1:cc81680:         //since that's how the composite queue was set up
1:cc81680:         assertEquals("message count", 0, remoteStats.getMessages().getCount());
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 1);
1:cc81680:         if (isUseVirtualDestSubsOnCreation) {
1:cc81680:             assertAdvisoryBrokerCounts(1,2,1);
1:cc81680:         } else {
1:cc81680:             assertAdvisoryBrokerCounts(1,1,0);
1:cc81680:         }
1:cc81680:     }
1:cc81680: 
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that the demand will be removed if the virtual destination is deleted
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testFlowRemoved() throws Exception {
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:cc81680:         doSetUp(true, new VirtualDestination[] {compositeTopic});
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //sleep to allow the route to be set up
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         //remove the virtual destinations after startup
1:cc81680:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         //assert that no message was received
1:cc81680:         //by the time we get here, there is no more virtual destinations so this won't
1:cc81680:         //trigger demand
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 0);
1:cc81680:         assertAdvisoryBrokerCounts(0,0,0);
1:cc81680:     }
1:cc81680: 
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testReplay() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680: 
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:e73ab34:         doSetUp(true, new VirtualDestination[] {compositeTopic}, false, false);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         //start the local broker after establishing the virtual topic to test replay
1:cc81680:         localBroker.addNetworkConnector(connector);
1:cc81680:         connector.start();
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         //there should be an extra advisory because of replay
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,1);
1:cc81680:     }
1:cc81680: 
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testReplayWithConsumer() throws Exception {
1:cc81680: 
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:e73ab34:         doSetUp(true, new VirtualDestination[] {compositeTopic}, false, false);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         //start the local broker after establishing the virtual topic to test replay
1:cc81680:         localBroker.addNetworkConnector(connector);
1:cc81680:         connector.start();
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         //with isUseVirtualDestSubsOnCreation is true, there should be 4 advisories (2 replay)
1:cc81680:         //with !isUseVirtualDestSubsOnCreation, there should be 2 advisories (1 replay)
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 4, 2);
1:cc81680:         if (isUseVirtualDestSubsOnCreation) {
1:cc81680:             assertAdvisoryBrokerCounts(1,2,1);
1:cc81680:         } else {
1:cc81680:             assertAdvisoryBrokerCounts(1,1,0);
1:cc81680:         }
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that the demand will be removed if the virtual destination is deleted
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testRemovedIfNoConsumer() throws Exception {
1:cc81680:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:cc81680: 
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge"));
1:cc81680: 
1:cc81680:         doSetUp(true, new VirtualDestination[] {compositeTopic});
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680: 
1:cc81680:         //destination creation will trigger the advisory since the virtual topic exists
1:cc81680:         final DestinationStatistics destinationStatistics =
1:cc81680:                 localBroker.getDestination(new ActiveMQQueue(testQueueName)).getDestinationStatistics();
1:cc81680:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:cc81680:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,1);
1:cc81680: 
1:cc81680:         //remove the virtual destinations after startup, will trigger a remove advisory
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         assertEquals("broker consumer count", 0, destinationStatistics.getConsumers().getCount());
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 0);
1:cc81680:         assertEquals("remote dest messages", 0, remoteDestStatistics.getMessages().getCount());
1:cc81680: 
1:cc81680:         //one add and one remove advisory
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:cc81680:         assertAdvisoryBrokerCounts(0,0,0);
1:cc81680:     }
1:cc81680: 
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that demand is created when the target of the compositeTopic is another topic
1:cc81680:      * and a consumer comes online
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testToTopic() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to topic "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQTopic("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQTopic("include.test.bar.bridge"));
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,0);
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that demand is NOT created when the target of the compositeTopic is another topic
1:cc81680:      * and there are no consumers since the existience of a topic shouldn't case demand without
1:cc81680:      * a consumer or durable on it
1:cc81680:      *
1:cc81680:      * @throws Exception
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testToTopicNoConsumer() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to topic "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQTopic("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(excluded).getDestinationStatistics();
1:cc81680:         assertEquals("broker consumer count", 0, destinationStatistics.getConsumers().getCount());
1:cc81680:         assertLocalBrokerStatistics(destinationStatistics, 0);
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 0);
1:cc81680:         assertAdvisoryBrokerCounts(1,0,0);
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that demand will be created because of the existing of a durable subscription
1:cc81680:      * created on a topic that is the target of a compositeTopic
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testToTopicWithDurable() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to topic "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQTopic("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680: 
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createDurableSubscriber(
1:cc81680:                 new ActiveMQTopic("include.test.bar.bridge"), "sub1");
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680:         assertNotNull(bridgeConsumer.receive(5000));
1:cc81680: 
1:cc81680:         Wait.waitFor(new Wait.Condition() {
1:cc81680:             @Override
1:cc81680:             public boolean isSatisified() throws Exception {
1:cc81680:                 return 1 == destinationStatistics.getDequeues().getCount();
1:cc81680:             }
1:cc81680:         });
1:cc81680: 
1:cc81680:         assertEquals("broker dest stat dispatched", 1, destinationStatistics.getDispatched().getCount());
1:cc81680:         assertEquals("broker dest stat dequeues", 1, destinationStatistics.getDequeues().getCount());
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,0);
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     /**
1:cc81680:      * Test that messages still flow to the durable subscription on the forwarded
1:cc81680:      * destination even if it is offline
1:cc81680:      */
1:cc81680:     @Test(timeout = 60 * 1000)
1:cc81680:     public void testToTopicWithDurableOffline() throws Exception {
1:cc81680:         doSetUp(true, null);
1:cc81680: 
1:cc81680:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1:cc81680: 
1:cc81680:         //configure a virtual destination that forwards messages from topic testQueueName
1:cc81680:         //to topic "include.test.bar.bridge"
1:cc81680:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:cc81680:                 new ActiveMQTopic("include.test.bar.bridge"));
1:cc81680: 
1:0c846cf:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:cc81680: 
1:cc81680:         MessageProducer includedProducer = localSession.createProducer(included);
1:cc81680:         Thread.sleep(2000);
1:cc81680:         Message test = localSession.createTextMessage("test");
1:cc81680: 
1:cc81680:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:cc81680: 
1:cc81680:         //create a durable subscription and go offline
1:cc81680:         MessageConsumer bridgeConsumer = remoteSession.createDurableSubscriber(
1:cc81680:                 new ActiveMQTopic("include.test.bar.bridge"), "sub1");
1:cc81680:         bridgeConsumer.close();
1:cc81680:         Thread.sleep(2000);
1:cc81680:         includedProducer.send(test);
1:cc81680: 
1:cc81680:         Wait.waitFor(new Wait.Condition() {
1:cc81680:             @Override
1:cc81680:             public boolean isSatisified() throws Exception {
1:cc81680:                 return 1 == destinationStatistics.getDequeues().getCount() &&
1:cc81680:                         destinationStatistics.getDispatched().getCount() == 1;
1:cc81680:             }
1:cc81680:         });
1:cc81680: 
1:cc81680:         //offline durable should still get receive the message over the bridge and ack
1:cc81680:         assertEquals("broker dest stat dispatched", 1, destinationStatistics.getDispatched().getCount());
1:cc81680:         assertEquals("broker dest stat dequeues", 1, destinationStatistics.getDequeues().getCount());
1:cc81680: 
1:cc81680:         //reconnect to receive the message
1:cc81680:         MessageConsumer bridgeConsumer2 = remoteSession.createDurableSubscriber(
1:cc81680:                 new ActiveMQTopic("include.test.bar.bridge"), "sub1");
1:cc81680:         assertNotNull(bridgeConsumer2.receive(5000));
1:cc81680: 
1:cc81680:         Thread.sleep(2000);
1:cc81680:         //make sure stats did not change
1:cc81680:         assertEquals("broker dest stat dispatched", 1, destinationStatistics.getDispatched().getCount());
1:cc81680:         assertEquals("broker dest stat dequeues", 1, destinationStatistics.getDequeues().getCount());
1:cc81680: 
1:cc81680:         assertRemoteAdvisoryCount(advisoryConsumer, 3);
1:cc81680:         assertAdvisoryBrokerCounts(1,1,0);
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     @Before
1:cc81680:     public void setUp() throws Exception {
1:cc81680: 
1:cc81680:     }
1:cc81680: 
1:cc81680:     @After
1:cc81680:     public void tearDown() throws Exception {
1:cc81680:         doTearDown();
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected void doSetUp(boolean deleteAllMessages,
1:cc81680:             VirtualDestination[] remoteVirtualDests) throws Exception {
1:e73ab34:         doSetUp(deleteAllMessages, remoteVirtualDests, true, false);
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected void doSetUp(boolean deleteAllMessages,
1:e73ab34:             VirtualDestination[] remoteVirtualDests, boolean startNetworkConnector, boolean forceDurable) throws Exception {
1:cc81680:         remoteBroker = createRemoteBroker(isUseVirtualDestSubsOnCreation, remoteVirtualDests);
1:cc81680:         remoteBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:cc81680:         remoteBroker.start();
1:cc81680:         remoteBroker.waitUntilStarted();
1:e73ab34:         localBroker = createLocalBroker(startNetworkConnector, forceDurable);
1:cc81680:         localBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:cc81680:         localBroker.start();
1:cc81680:         localBroker.waitUntilStarted();
1:cc81680:         URI localURI = localBroker.getVmConnectorURI();
1:cc81680:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(localURI);
1:cc81680:         fac.setAlwaysSyncSend(true);
1:cc81680:         fac.setDispatchAsync(false);
1:cc81680:         localConnection = fac.createConnection();
1:cc81680:         localConnection.setClientID("clientId");
1:cc81680:         localConnection.start();
1:cc81680:         URI remoteURI = remoteBroker.getVmConnectorURI();
1:cc81680:         fac = new ActiveMQConnectionFactory(remoteURI);
1:cc81680:         remoteConnection = fac.createConnection();
1:cc81680:         remoteConnection.setClientID("clientId");
1:cc81680:         remoteConnection.start();
1:cc81680:         included = new ActiveMQTopic(testTopicName);
1:cc81680:         excluded = new ActiveMQTopic("exclude.test.bar");
1:cc81680:         localSession = localConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:cc81680:         remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:cc81680:     }
1:cc81680: 
1:cc81680: 
1:cc81680:     protected NetworkConnector connector;
1:e73ab34:     protected BrokerService createLocalBroker(boolean startNetworkConnector, boolean forceDurable) throws Exception {
1:cc81680:         BrokerService brokerService = new BrokerService();
1:cc81680:         brokerService.setMonitorConnectionSplits(true);
1:cc81680:         brokerService.setDataDirectoryFile(tempFolder.newFolder());
1:cc81680:         brokerService.setBrokerName("localBroker");
1:cc81680: 
1:e73ab34:         List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:e73ab34:         URI remoteURI = transportConnectors.get(0).getConnectUri();
1:e73ab34:         String uri = "static:(" + remoteURI + ")";
1:e73ab34:         connector = new DiscoveryNetworkConnector(new URI(uri));
1:cc81680:         connector.setName("networkConnector");
1:cc81680:         connector.setDynamicOnly(false);
1:cc81680:         connector.setDecreaseNetworkConsumerPriority(false);
1:cc81680:         connector.setConduitSubscriptions(true);
1:cc81680:         connector.setDuplex(isDuplex);
1:cc81680:         connector.setUseVirtualDestSubs(true);
1:cc81680:         connector.setDynamicallyIncludedDestinations(Lists.newArrayList(new ActiveMQQueue(testQueueName),
1:e73ab34:                 new ActiveMQTopic(testTopicName + (forceDurable ? "?forceDurable=true" : "")), new ActiveMQTopic("VirtualTopic.>")));
1:cc81680:         connector.setExcludedDestinations(Lists.newArrayList(new ActiveMQQueue("exclude.test.foo"),
1:cc81680:                 new ActiveMQTopic("exclude.test.bar")));
1:cc81680: 
1:cc81680:         if (startNetworkConnector) {
2:cc81680:             brokerService.addNetworkConnector(connector);
1:cc81680:         }
1:cc81680: 
1:e73ab34:         brokerService.addConnector("tcp://localhost:0");
1:cc81680: 
1:cc81680:         return brokerService;
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected AdvisoryBroker remoteAdvisoryBroker;
1:cc81680:     protected BrokerService createRemoteBroker(boolean isUsevirtualDestinationSubscriptionsOnCreation,
1:cc81680:             VirtualDestination[] remoteVirtualDests) throws Exception {
1:cc81680:         BrokerService brokerService = new BrokerService();
1:cc81680:         brokerService.setBrokerName("remoteBroker");
1:cc81680:         brokerService.setUseJmx(false);
1:cc81680:         brokerService.setDataDirectoryFile(tempFolder.newFolder());
1:cc81680:         brokerService.setPlugins(new BrokerPlugin[] {new JavaRuntimeConfigurationPlugin()});
1:cc81680:         brokerService.setUseVirtualDestSubs(true);
1:cc81680:         brokerService.setUseVirtualDestSubsOnCreation(isUsevirtualDestinationSubscriptionsOnCreation);
1:cc81680: 
1:cc81680:         //apply interceptor before getting the broker, which will cause it to be built
1:cc81680:         if (remoteVirtualDests != null) {
1:cc81680:             VirtualDestinationInterceptor interceptor = new VirtualDestinationInterceptor();
1:cc81680:             interceptor.setVirtualDestinations(remoteVirtualDests);
1:cc81680:             brokerService.setDestinationInterceptors(new DestinationInterceptor[]{interceptor});
1:cc81680:         }
1:cc81680: 
1:cc81680:         runtimeBroker = (JavaRuntimeConfigurationBroker)
1:cc81680:                 brokerService.getBroker().getAdaptor(JavaRuntimeConfigurationBroker.class);
1:cc81680:         remoteAdvisoryBroker = (AdvisoryBroker)
1:cc81680:                 brokerService.getBroker().getAdaptor(AdvisoryBroker.class);
1:cc81680: 
1:e73ab34:         brokerService.addConnector("tcp://localhost:0");
1:cc81680: 
1:cc81680:         return brokerService;
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected CompositeTopic createCompositeTopic(String name, ActiveMQDestination...forwardTo) {
1:cc81680:         CompositeTopic compositeTopic = new CompositeTopic();
1:cc81680:         compositeTopic.setName(name);
1:cc81680:         compositeTopic.setForwardOnly(true);
1:cc81680:         compositeTopic.setForwardTo( Lists.newArrayList(forwardTo));
1:cc81680: 
1:cc81680:         return compositeTopic;
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected CompositeQueue createCompositeQueue(String name, ActiveMQDestination...forwardTo) {
1:cc81680:         CompositeQueue compositeQueue = new CompositeQueue();
1:cc81680:         compositeQueue.setName(name);
1:cc81680:         compositeQueue.setForwardOnly(true);
1:cc81680:         compositeQueue.setForwardTo( Lists.newArrayList(forwardTo));
1:cc81680: 
1:cc81680:         return compositeQueue;
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected MessageConsumer getVirtualDestinationAdvisoryConsumer(String topic) throws JMSException {
1:cc81680:         return remoteSession.createConsumer(AdvisorySupport.getVirtualDestinationConsumerAdvisoryTopic(
1:cc81680:                 new ActiveMQTopic(topic)));
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected MessageConsumer getQueueVirtualDestinationAdvisoryConsumer(String queue) throws JMSException {
1:cc81680:         return remoteSession.createConsumer(AdvisorySupport.getVirtualDestinationConsumerAdvisoryTopic(
1:cc81680:                 new ActiveMQQueue(queue)));
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected void assertRemoteAdvisoryCount(final MessageConsumer advisoryConsumer, final int count) throws JMSException {
1:cc81680:         int available = 0;
1:cc81680:         ActiveMQMessage message = null;
1:cc81680:         while ((message = (ActiveMQMessage) advisoryConsumer.receive(1000)) != null) {
1:cc81680:             available++;
1:a2781e3:             LOG.info("advisory data structure: {}", message.getDataStructure());
1:cc81680:         }
1:cc81680:         assertEquals(count, available);
1:cc81680:     }
1:cc81680: 
1:cc81680:     protected void assertRemoteAdvisoryCount(final MessageConsumer advisoryConsumer,
1:cc81680:             final int isSubOnCreationCount, final int isNotSubOnCreationCount) throws JMSException {
1:cc81680:         if (isUseVirtualDestSubsOnCreation) {
1:cc81680:             assertRemoteAdvisoryCount(advisoryConsumer, isSubOnCreationCount);
1:cc81680:         } else {
1:cc81680:             assertRemoteAdvisoryCount(advisoryConsumer, isNotSubOnCreationCount);
1:cc81680:         }
1:cc81680:     }
1:cc81680: 
1:cc81680:     @SuppressWarnings("unchecked")
1:cc81680:     protected void assertAdvisoryBrokerCounts(int virtualDestinationsCount,
1:cc81680:             int virtualDestinationConsumersCount, int brokerConsumerDestsCount) throws Exception {
1:cc81680: 
1:cc81680:         Field virtualDestinationsField = AdvisoryBroker.class.getDeclaredField("virtualDestinations");
1:cc81680:         Field virtualDestinationConsumersField = AdvisoryBroker.class.getDeclaredField("virtualDestinationConsumers");
1:cc81680:         Field brokerConsumerDestsField = AdvisoryBroker.class.getDeclaredField("brokerConsumerDests");
1:cc81680: 
1:cc81680:         virtualDestinationsField.setAccessible(true);
1:cc81680:         virtualDestinationConsumersField.setAccessible(true);
1:cc81680:         brokerConsumerDestsField.setAccessible(true);
1:cc81680: 
1:cc81680:         Set<VirtualDestination> virtualDestinations = (Set<VirtualDestination>)
1:cc81680:                 virtualDestinationsField.get(remoteAdvisoryBroker);
1:cc81680: 
1:cc81680:         ConcurrentMap<ConsumerInfo, VirtualDestination> virtualDestinationConsumers =
1:cc81680:                 (ConcurrentMap<ConsumerInfo, VirtualDestination>)
1:cc81680:                     virtualDestinationConsumersField.get(remoteAdvisoryBroker);
1:cc81680: 
1:cc81680:         ConcurrentMap<Object, ConsumerInfo> brokerConsumerDests =
1:cc81680:                 (ConcurrentMap<Object, ConsumerInfo>)
1:cc81680:                 brokerConsumerDestsField.get(remoteAdvisoryBroker);
1:cc81680: 
1:cc81680:         assertEquals(virtualDestinationsCount, virtualDestinations.size());
1:cc81680:         assertEquals(virtualDestinationConsumersCount, virtualDestinationConsumers.size());
1:cc81680:         assertEquals(brokerConsumerDestsCount, brokerConsumerDests.size());
1:cc81680:     }
1:cc81680: 
1:cc81680: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:56baba9
/////////////////////////////////////////////////////////////////////////
1:     public void testVirtualTopics() throws Exception {
1:         MessageProducer includedProducer2 = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar2"));
1:         MessageProducer includedProducer3 = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar3"));
1:         final DestinationStatistics destinationStatistics2 = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar2")).getDestinationStatistics();
1: 
1:         //No queue destination on the remote side so should not forward
1:         final DestinationStatistics destinationStatistics3 = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar3")).getDestinationStatistics();
1:         final DestinationStatistics remoteStats2 = remoteBroker.getDestination(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar2")).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics2, 1);
1:         includedProducer2.send(localSession.createTextMessage("test2"));
1:         includedProducer3.send(localSession.createTextMessage("test3"));
1:         waitForDispatchFromLocalBroker(destinationStatistics2, 1);
1:         assertLocalBrokerStatistics(destinationStatistics2, 1);
1:         assertEquals("remote dest messages", 1, remoteStats2.getMessages().getCount());
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:         assertAdvisoryBrokerCounts(1,2,2);
1: 
1:         //should not have forwarded for 3rd topic
1:         Thread.sleep(1000);
1:         assertEquals("local broker dest stat dispatched", 0, destinationStatistics3.getDispatched().getCount());
commit:e73ab34
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.TransportConnector;
/////////////////////////////////////////////////////////////////////////
1:         testDynamicFlow(false);
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
1:     public void testDynamicFlowForceDurable() throws Exception {
1:         testDynamicFlow(true);
1:     }
1: 
1:     protected void testDynamicFlow(boolean forceDurable) throws Exception {
1:         doSetUp(true, null, true, forceDurable);
/////////////////////////////////////////////////////////////////////////
1:         assertNCDurableSubsCount(localBroker, included, forceDurable ? 1 : 0);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         doSetUp(true, new VirtualDestination[] {compositeTopic}, false, false);
/////////////////////////////////////////////////////////////////////////
1:         doSetUp(true, new VirtualDestination[] {compositeTopic}, false, false);
/////////////////////////////////////////////////////////////////////////
1:         doSetUp(deleteAllMessages, remoteVirtualDests, true, false);
1:             VirtualDestination[] remoteVirtualDests, boolean startNetworkConnector, boolean forceDurable) throws Exception {
1:         localBroker = createLocalBroker(startNetworkConnector, forceDurable);
/////////////////////////////////////////////////////////////////////////
1:     protected BrokerService createLocalBroker(boolean startNetworkConnector, boolean forceDurable) throws Exception {
1:         List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:         URI remoteURI = transportConnectors.get(0).getConnectUri();
1:         String uri = "static:(" + remoteURI + ")";
1:         connector = new DiscoveryNetworkConnector(new URI(uri));
/////////////////////////////////////////////////////////////////////////
1:                 new ActiveMQTopic(testTopicName + (forceDurable ? "?forceDurable=true" : "")), new ActiveMQTopic("VirtualTopic.>")));
/////////////////////////////////////////////////////////////////////////
1:         brokerService.addConnector("tcp://localhost:0");
/////////////////////////////////////////////////////////////////////////
1:         brokerService.addConnector("tcp://localhost:0");
commit:b1c4b18
/////////////////////////////////////////////////////////////////////////
commit:a2781e3
/////////////////////////////////////////////////////////////////////////
1:      * This tests that having 2 composite destinations (1 included for dynamic flow and 1 not)
1:      * will allow messages to flow and that deleting 1 destination dosen't clear out the virtual
1:      * consumer map except for what should be cleared.
1:      *
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testTwoCompositeTopicsRemove1() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:         CompositeTopic compositeTopic1 = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1:         CompositeTopic compositeTopic2 = createCompositeTopic(testTopicName + 2,
1:                 new ActiveMQQueue("include.test.bar.bridge2"));
1: 
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic1, compositeTopic2}, true);
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Message test = localSession.createTextMessage("test");
1:         Thread.sleep(1000);
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1: 
1:         //verify there are 2 virtual destinations but only 1 consumer and broker dest
1:         assertAdvisoryBrokerCounts(2,1,1);
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic1}, true);
1:         Thread.sleep(2000);
1:         //verify there is is only 1 virtual dest after deletion
1:         assertAdvisoryBrokerCounts(1,1,1);
1: 
1:         includedProducer.send(test);
1: 
1:         //make sure messages are still forwarded even after 1 composite topic was deleted
1:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:         assertLocalBrokerStatistics(destinationStatistics, 2);
1:         assertEquals("remote dest messages", 2, remoteDestStatistics.getMessages().getCount());
1: 
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("advisory data structure: {}", message.getDataStructure());
commit:95f58fa
/////////////////////////////////////////////////////////////////////////
1:      * topic is included that forwards to the same queue, but is excluded from
1:      * being forwarded from the remote broker
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testSecondNonIncludedCompositeTopicForwardSameQueue() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a composite topic that isn't included
1:         CompositeTopic compositeTopic = createCompositeTopic("include.test.bar2",
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1: 
1:         Thread.sleep(2000);
1: 
1:         //add one that is included
1:         CompositeTopic compositeTopic2 = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic, compositeTopic2}, true);
1: 
1:         Thread.sleep(2000);
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:         assertAdvisoryBrokerCounts(2,2,2);
1: 
1:     }
1: 
1:     /**
1:      * Test that dynamic flow works for virtual destinations when a second composite
commit:09054fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class VirtualConsumerDemandTest extends DynamicNetworkTestSupport {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         CompositeTopic compositeTopic = createCompositeTopic("exclude.test.bar",
1:                 new ActiveMQQueue("exclude.test.bar.bridge"));
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("exclude.test.bar.bridge"));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3ef6a9f
/////////////////////////////////////////////////////////////////////////
1:      * topic is included, but is excluded from
/////////////////////////////////////////////////////////////////////////
1:                 new ActiveMQQueue("include.test.bar.bridge2"));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertAdvisoryBrokerCounts(2,1,1);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(1000);
/////////////////////////////////////////////////////////////////////////
1:         Message test = localSession.createTextMessage("test");
1: 
commit:0c846cf
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic, compositeTopic2}, true);
1: 
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeQueue}, true);
1:         Thread.sleep(2000);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
/////////////////////////////////////////////////////////////////////////
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
commit:cc81680
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
1: 
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
1: 
0: import java.io.File;
1: import java.lang.reflect.Field;
1: import java.net.URI;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentMap;
1: 
0: import javax.jms.Connection;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.advisory.AdvisoryBroker;
1: import org.apache.activemq.advisory.AdvisorySupport;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.DestinationInterceptor;
1: import org.apache.activemq.broker.region.DestinationStatistics;
1: import org.apache.activemq.broker.region.virtual.CompositeQueue;
1: import org.apache.activemq.broker.region.virtual.CompositeTopic;
1: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1: import org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationBroker;
1: import org.apache.activemq.plugin.java.JavaRuntimeConfigurationPlugin;
1: import org.apache.activemq.util.Wait;
1: import org.junit.After;
1: import org.junit.Assume;
1: import org.junit.Before;
0: import org.junit.Rule;
1: import org.junit.Test;
0: import org.junit.rules.TemporaryFolder;
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
1: import org.junit.runners.Parameterized.Parameters;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import com.google.common.collect.Lists;
1: 
1: /**
1:  * This test is to show that dynamicallyIncludedDestinations will work properly
1:  * when a network of brokers is configured to treat Virtual Destinations (Virtual topic and composite destination)
1:  * as demand.
1:  */
1: @RunWith(Parameterized.class)
0: public class VirtualConsumerDemandTest {
1: 
1:     protected static final int MESSAGE_COUNT = 10;
1:     private static final Logger LOG = LoggerFactory.getLogger(VirtualConsumerDemandTest.class);
1: 
1: 
1:     /**
1:      * test params
1:      */
1:     @Parameters
1:     public static Collection<Object[]> data() {
1:         return Arrays.asList(new Object[][] {
1:                 //not duplex, useVirtualDestSubsOnCreation
1:                 {false, true},
1:                 //duplex
1:                 {true, false},
1:                 {true, true},
1:                 {false, false}
1:         });
1:     }
1: 
0:     protected Connection localConnection;
0:     protected Connection remoteConnection;
0:     protected BrokerService localBroker;
0:     protected BrokerService remoteBroker;
1:     protected JavaRuntimeConfigurationBroker runtimeBroker;
0:     protected Session localSession;
0:     protected Session remoteSession;
0:     protected ActiveMQTopic included;
0:     protected ActiveMQTopic excluded;
1:     protected String consumerName = "durableSubs";
0:     protected String testTopicName = "include.test.bar";
1:     protected String testQueueName = "include.test.foo";
1: 
1:     private final boolean isDuplex;
1:     private final boolean isUseVirtualDestSubsOnCreation;
1: 
0:     @Rule
0:     public TemporaryFolder tempFolder = new TemporaryFolder(new File("target"));
1: 
1: 
1:     public VirtualConsumerDemandTest(boolean isDuplex, boolean isUseVirtualDestSubsOnCreation) {
1:        // Assume.assumeTrue(
1:         super();
1:         this.isDuplex = isDuplex;
1:         this.isUseVirtualDestSubsOnCreation = isUseVirtualDestSubsOnCreation;
1:     }
1: 
1: 
1:     /**
1:      * Test that the creation of a virtual topic will cause demand
1:      * even without a consumer for the case of useVirtualDestSubsOnCreation == true
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
0:     public void testVirtualTopic() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer("VirtualTopic.>");
1: 
1:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar"));
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar")).getDestinationStatistics();
1: 
1:         //this will create the destination so messages accumulate
1:         final DestinationStatistics remoteStats = remoteBroker.getDestination(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar")).getDestinationStatistics();
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         //assert statistics
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:         assertEquals("remote dest messages", 1, remoteStats.getMessages().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:         assertAdvisoryBrokerCounts(1,1,1);
1:     }
1: 
1: 
1: 
1:     /**
1:      * Test that the creation of a virtual topic with a consumer will cause
1:      * demand regardless of useVirtualDestSubsOnCreation
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testVirtualTopicWithConsumer() throws Exception {
1:         doSetUp(true, null);
1: 
1:        //use just the default virtual topic setup
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer("VirtualTopic.>");
1: 
1:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar"));
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar")).getDestinationStatistics();
1: 
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar"));
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 1);
1: 
1:         if (isUseVirtualDestSubsOnCreation) {
1:             assertAdvisoryBrokerCounts(1,2,1);
1:         } else {
1:             assertAdvisoryBrokerCounts(1,1,0);
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Test that when a consumer goes offline for a virtual topic, that messages still flow
1:      * to that queue if isUseVirtualDestSubsOnCreation is true
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testVirtualTopicWithConsumerGoOffline() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:         //use just the default virtual topic setup
1:         doSetUp(true, null);
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer("VirtualTopic.>");
1: 
1:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQTopic("VirtualTopic.include.test.bar"));
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQTopic("VirtualTopic.include.test.bar")).getDestinationStatistics();
1: 
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar"));
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         //assert a message was forwarded
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         //close the consumer and send a second message
1:         bridgeConsumer.close();
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1: 
1:         //check that the message was forwarded
1:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:         assertLocalBrokerStatistics(destinationStatistics, 2);
1: 
1:         //make sure that the message can be received
1:         MessageConsumer bridgeConsumer2 = remoteSession.createConsumer(new ActiveMQQueue("Consumer.cons1.VirtualTopic.include.test.bar"));
1:         assertNotNull(bridgeConsumer2.receive(5000));
1: 
1:         //should be 4 advisories...1 or the virtual destination creation to a queue,
1:         //2 for new consumers, and 1 for a closed consumer
1:         assertRemoteAdvisoryCount(advisoryConsumer, 4);
1:         assertAdvisoryBrokerCounts(1,2,1);
1:     }
1: 
1:     /**
1:      * This test shows that if isUseVirtualDestSubsOnCreation is true,
1:      * the creation of a composite destination that forwards to a Queue will create
1:      * a virtual consumer and cause demand so that the queue will accumulate messages
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testDynamicFlow() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:         assertAdvisoryBrokerCounts(1,1,1);
1:     }
1: 
1: 
1:     /**
1:      * Test that dynamic flow works for virtual destinations when a second composite
0:      * topic is included that forwards to the same queue, but is excluded from
1:      * being forwarded from the remote broker
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testSecondNonIncludedCompositeTopic() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a composite topic that isn't included
1:         CompositeTopic compositeTopic = createCompositeTopic("include.test.bar2",
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         Thread.sleep(2000);
1: 
1:         //add one that is included
1:         CompositeTopic compositeTopic2 = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic, compositeTopic2});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
0:         assertAdvisoryBrokerCounts(2,2,2);
1: 
1:     }
1: 
1:     /**
1:      * Test that no messages are forwarded when isUseVirtualDestSubsOnCreation is false
1:      * and there are no consumers
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testNoUseVirtualDestinationSubscriptionsOnCreation() throws Exception {
1:         Assume.assumeTrue(!isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         includedProducer.send(test);
1:         Thread.sleep(2000);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 0);
1:         assertLocalBrokerStatistics(destinationStatistics, 0);
1:         assertEquals("remote dest messages", 0, remoteDestStatistics.getMessages().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 0);
1:         assertAdvisoryBrokerCounts(1,0,0);
1: 
1:     }
1: 
1: 
1:     /**
1:      * Test that messages still flow when updating a composite topic to remove 1 of the
1:      * forwarded destinations, but keep the other one
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testTwoTargetsRemove1() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"),
1:                 new ActiveMQQueue("include.test.bar.bridge2"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge2")).getDestinationStatistics();
1: 
1:         Thread.sleep(2000);
1:         //two advisory messages sent for each target when destinations are created
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:         assertAdvisoryBrokerCounts(1,2,2);
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1: 
1:         compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1:         Thread.sleep(2000);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:         assertLocalBrokerStatistics(destinationStatistics, 2);
1: 
1:         assertEquals("remote dest messages", 2, remoteDestStatistics.getMessages().getCount());
1:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1: 
1:         //We delete 2, and re-add 1 target queue
1:         assertRemoteAdvisoryCount(advisoryConsumer, 3);
1:         assertAdvisoryBrokerCounts(1,1,1);
1: 
1:     }
1: 
1:     /**
1:      * Test that messages still flow after removing one of the destinations that is a target
1:      * but the other one sticks around
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testTwoTargetsRemove1Destination() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"),
1:                 new ActiveMQQueue("include.test.bar.bridge2"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge2")).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1: 
1:         remoteBroker.removeDestination(new ActiveMQQueue("include.test.bar.bridge2"));
1:         Thread.sleep(2000);
1:         //2 for each target queue destination in the virtual subscription
1:         //1 for the removal of a queue
1:         assertRemoteAdvisoryCount(advisoryConsumer, 3);
1:         assertAdvisoryBrokerCounts(1,1,1);
1: 
1:         includedProducer.send(test);
1: 
1:         //make sure messages are still forwarded even after 1 target was deleted
1:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:         assertLocalBrokerStatistics(destinationStatistics, 2);
1: 
1:         assertEquals("remote dest messages", 2, remoteDestStatistics.getMessages().getCount());
1: 
1:         //1 because a send causes the queue to be recreated again which sends a new demand advisory
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:         assertAdvisoryBrokerCounts(1,2,2);
1: 
1:     }
1: 
1:     /**
1:      * Test that demand is destroyed after removing both targets from the composite Topic
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testTwoTargetsRemoveBoth() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge" and "include.test.bar.bridge2"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"),
1:                 new ActiveMQQueue("include.test.bar.bridge2"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics2 = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge2")).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1: 
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {}, true);
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1: 
1:         Thread.sleep(2000);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1:         assertEquals("remote2 dest messages", 1, remoteDestStatistics2.getMessages().getCount());
1: 
1:         //2 for each target queue destination in the virtual subscription
1:         //2 for the removal of the virtual destination, which requires 2 advisories because there are 2 targets
1:         assertRemoteAdvisoryCount(advisoryConsumer, 4);
1:         assertAdvisoryBrokerCounts(0,0,0);
1:     }
1: 
1:     /**
1:      * Test that dynamic flow works when the destination is created before the
1:      * virtual destination has been added to the broker
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testDestinationAddedFirst() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1: 
1:         Thread.sleep(2000);
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic}, true);
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1: 
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1:         assertEquals("remote dest messages", 1, remoteDestStatistics.getMessages().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:         assertAdvisoryBrokerCounts(1,1,1);
1:     }
1: 
1:     /**
1:      * This test shows that a consumer listening on the target of a composite destination will create
1:      * a virtual consumer and cause demand so that the consumer will receive messages, regardless
1:      * of whether isUseVirtualDestSubsOnCreation is true or false
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testWithConsumer() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1: 
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 //should only be 1 because of conduit subs even though there is 2 consumers
1:                 //for the case where isUseVirtualDestSubsOnCreation is true,
1:                 //1 for the composite destination creation and 1 for the actual consumer
1:                 return 1 == destinationStatistics.getConsumers().getCount();
1:             }
1:         });
1: 
1:         includedProducer.send(test);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1: 
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         //if isUseVirtualDestSubsOnCreation is true we should have
1:         //two advisory consumer messages, else 1
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 1);
1:         if (isUseVirtualDestSubsOnCreation) {
1:             assertAdvisoryBrokerCounts(1,2,1);
1:         } else {
1:             assertAdvisoryBrokerCounts(1,1,0);
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Test that demand still exists when only 1 of 2 consumers is removed from the
1:      * destination
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testWith2ConsumersRemove1() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1: 
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:         MessageConsumer bridgeConsumer2 = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         //should only be 1 because of conduit subs even though there is 2 consumers
1:         //for the case where isUseVirtualDestSubsOnCreation is true,
1:         //1 for the composite destination creation and 1 for the actual consumer
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertTrue(bridgeConsumer.receive(5000) != null || bridgeConsumer2.receive(5000) != null);
1: 
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         bridgeConsumer2.close();
1: 
1:         includedProducer.send(test);
1: 
1:         //make sure the message is still forwarded
1:         waitForDispatchFromLocalBroker(destinationStatistics, 2);
1:         assertLocalBrokerStatistics(destinationStatistics, 2);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 4, 3);
1:         if (isUseVirtualDestSubsOnCreation) {
1:             assertAdvisoryBrokerCounts(1,2,1);
1:         } else {
1:             assertAdvisoryBrokerCounts(1,1,0);
1:         }
1:     }
1: 
1:     /**
1:      * Test that demand is removed after both consumers are removed when
1:      * isUseVirtualDestSubsOnCreation is false
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testWith2ConsumersRemoveBoth() throws Exception {
1:         Assume.assumeTrue(!isUseVirtualDestSubsOnCreation);
1: 
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to queue "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1: 
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:         MessageConsumer bridgeConsumer2 = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         //should only be 1 because of conduit subs even though there is 2 consumers
1:         //for the case where isUseVirtualDestSubsOnCreation is true,
1:         //1 for the composite destination creation and 1 for the actual consumer
1:         waitForConsumerCount(destinationStatistics, 1);
1:         assertAdvisoryBrokerCounts(1,2,0);
1: 
1:         includedProducer.send(test);
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1:         assertTrue(bridgeConsumer.receive(5000) != null || bridgeConsumer2.receive(5000) != null);
1: 
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         bridgeConsumer.close();
1:         bridgeConsumer2.close();
1: 
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1:         Thread.sleep(2000);
1: 
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         //in this test, virtual destinations don't cause demand, only consumers on them
1:         //so we should have 2 create and 2 destroy
1:         assertRemoteAdvisoryCount(advisoryConsumer, 4);
1:         assertAdvisoryBrokerCounts(1,0,0);
1: 
1:     }
1: 
1:     /**
1:      * Show that messages won't be send for an excluded destination
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testExcluded() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages to an excluded destination
0:         CompositeTopic compositeTopic = createCompositeTopic("excluded.test.bar",
0:                 new ActiveMQQueue("excluded.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(excluded);
0:         // allow for consumer infos to perculate arround
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1: 
0:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("excluded.test.bar.bridge"));
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1:         assertNull(bridgeConsumer.receive(5000));
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(excluded).getDestinationStatistics();
1:         assertEquals("broker consumer count", 0, destinationStatistics.getConsumers().getCount());
1: 
1:         assertLocalBrokerStatistics(destinationStatistics, 0);
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 0);
1:         if (isUseVirtualDestSubsOnCreation) {
1:             assertAdvisoryBrokerCounts(1,2,1);
1:         } else {
1:             assertAdvisoryBrokerCounts(1,1,0);
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Test that demand will be created when using a composite queue instead of a composite topic
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testSourceQueue() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getQueueVirtualDestinationAdvisoryConsumer(testQueueName);
1: 
1:         //configure a virtual destination that forwards messages from queue testQueueName
1:         //to topic "include.test.foo.bridge"
1:         CompositeQueue compositeQueue = createCompositeQueue(testQueueName,
1:                 new ActiveMQQueue("include.test.foo.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeQueue});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(new ActiveMQQueue(testQueueName));
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(new ActiveMQQueue(testQueueName)).getDestinationStatistics();
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.foo.bridge"));
1:         waitForConsumerCount(destinationStatistics, 1);
1: 
1:         includedProducer.send(test);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         final DestinationStatistics remoteStats = remoteBroker.getDestination(new ActiveMQQueue(testQueueName)).getDestinationStatistics();
1: 
1:         waitForDispatchFromLocalBroker(destinationStatistics, 1);
1: 
1:         //should only be 1 because of conduit subs
1:         assertEquals("broker consumer count", 1, destinationStatistics.getConsumers().getCount());
1: 
1:         assertLocalBrokerStatistics(destinationStatistics, 1);
1: 
1:         //check remote stats - confirm the message isn't on the remote queue and was forwarded only
1:         //since that's how the composite queue was set up
1:         assertEquals("message count", 0, remoteStats.getMessages().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 1);
1:         if (isUseVirtualDestSubsOnCreation) {
1:             assertAdvisoryBrokerCounts(1,2,1);
1:         } else {
1:             assertAdvisoryBrokerCounts(1,1,0);
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Test that the demand will be removed if the virtual destination is deleted
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testFlowRemoved() throws Exception {
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         doSetUp(true, new VirtualDestination[] {compositeTopic});
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //sleep to allow the route to be set up
1:         Thread.sleep(2000);
1: 
1:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1: 
1:         Thread.sleep(2000);
1: 
1:         //remove the virtual destinations after startup
1:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {}, true);
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         //assert that no message was received
1:         //by the time we get here, there is no more virtual destinations so this won't
1:         //trigger demand
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1:         assertNull(bridgeConsumer.receive(5000));
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2, 0);
1:         assertAdvisoryBrokerCounts(0,0,0);
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
1:     public void testReplay() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         doSetUp(true, new VirtualDestination[] {compositeTopic}, false);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         Thread.sleep(2000);
1: 
1:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1: 
1:         Thread.sleep(2000);
1: 
1:         //start the local broker after establishing the virtual topic to test replay
1:         localBroker.addNetworkConnector(connector);
1:         connector.start();
1: 
1:         Thread.sleep(2000);
1: 
1:         //there should be an extra advisory because of replay
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:         assertAdvisoryBrokerCounts(1,1,1);
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
1:     public void testReplayWithConsumer() throws Exception {
1: 
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
0:         doSetUp(true, new VirtualDestination[] {compositeTopic}, false);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         Thread.sleep(2000);
1: 
1:         remoteBroker.getBroker().addDestination(remoteBroker.getAdminConnectionContext(),
1:                 new ActiveMQQueue("include.test.bar.bridge"), false);
1: 
1:         Thread.sleep(2000);
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Message test = localSession.createTextMessage("test");
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQQueue("include.test.bar.bridge"));
1:         Thread.sleep(2000);
1: 
1:         //start the local broker after establishing the virtual topic to test replay
1:         localBroker.addNetworkConnector(connector);
1:         connector.start();
1: 
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         //with isUseVirtualDestSubsOnCreation is true, there should be 4 advisories (2 replay)
1:         //with !isUseVirtualDestSubsOnCreation, there should be 2 advisories (1 replay)
1:         assertRemoteAdvisoryCount(advisoryConsumer, 4, 2);
1:         if (isUseVirtualDestSubsOnCreation) {
1:             assertAdvisoryBrokerCounts(1,2,1);
1:         } else {
1:             assertAdvisoryBrokerCounts(1,1,0);
1:         }
1:     }
1: 
1:     /**
1:      * Test that the demand will be removed if the virtual destination is deleted
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testRemovedIfNoConsumer() throws Exception {
1:         Assume.assumeTrue(isUseVirtualDestSubsOnCreation);
1: 
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQQueue("include.test.bar.bridge"));
1: 
1:         doSetUp(true, new VirtualDestination[] {compositeTopic});
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         Thread.sleep(2000);
1: 
1:         //destination creation will trigger the advisory since the virtual topic exists
1:         final DestinationStatistics destinationStatistics =
1:                 localBroker.getDestination(new ActiveMQQueue(testQueueName)).getDestinationStatistics();
1:         final DestinationStatistics remoteDestStatistics = remoteBroker.getDestination(
1:                 new ActiveMQQueue("include.test.bar.bridge")).getDestinationStatistics();
1: 
1:         Thread.sleep(2000);
1:         assertAdvisoryBrokerCounts(1,1,1);
1: 
1:         //remove the virtual destinations after startup, will trigger a remove advisory
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1:         includedProducer.send(test);
1: 
1:         assertEquals("broker consumer count", 0, destinationStatistics.getConsumers().getCount());
1:         assertLocalBrokerStatistics(destinationStatistics, 0);
1:         assertEquals("remote dest messages", 0, remoteDestStatistics.getMessages().getCount());
1: 
1:         //one add and one remove advisory
1:         assertRemoteAdvisoryCount(advisoryConsumer, 2);
1:         assertAdvisoryBrokerCounts(0,0,0);
1:     }
1: 
1: 
1:     /**
1:      * Test that demand is created when the target of the compositeTopic is another topic
1:      * and a consumer comes online
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testToTopic() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to topic "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQTopic("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         MessageConsumer bridgeConsumer = remoteSession.createConsumer(new ActiveMQTopic("include.test.bar.bridge"));
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:         assertAdvisoryBrokerCounts(1,1,0);
1:     }
1: 
1:     /**
1:      * Test that demand is NOT created when the target of the compositeTopic is another topic
1:      * and there are no consumers since the existience of a topic shouldn't case demand without
1:      * a consumer or durable on it
1:      *
1:      * @throws Exception
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testToTopicNoConsumer() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to topic "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQTopic("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1:         includedProducer.send(test);
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(excluded).getDestinationStatistics();
1:         assertEquals("broker consumer count", 0, destinationStatistics.getConsumers().getCount());
1:         assertLocalBrokerStatistics(destinationStatistics, 0);
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 0);
1:         assertAdvisoryBrokerCounts(1,0,0);
1:     }
1: 
1:     /**
1:      * Test that demand will be created because of the existing of a durable subscription
1:      * created on a topic that is the target of a compositeTopic
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testToTopicWithDurable() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to topic "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQTopic("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1: 
1:         MessageConsumer bridgeConsumer = remoteSession.createDurableSubscriber(
1:                 new ActiveMQTopic("include.test.bar.bridge"), "sub1");
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1:         assertNotNull(bridgeConsumer.receive(5000));
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 1 == destinationStatistics.getDequeues().getCount();
1:             }
1:         });
1: 
1:         assertEquals("broker dest stat dispatched", 1, destinationStatistics.getDispatched().getCount());
1:         assertEquals("broker dest stat dequeues", 1, destinationStatistics.getDequeues().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 1);
1:         assertAdvisoryBrokerCounts(1,1,0);
1: 
1:     }
1: 
1:     /**
1:      * Test that messages still flow to the durable subscription on the forwarded
1:      * destination even if it is offline
1:      */
1:     @Test(timeout = 60 * 1000)
1:     public void testToTopicWithDurableOffline() throws Exception {
1:         doSetUp(true, null);
1: 
1:         MessageConsumer advisoryConsumer = getVirtualDestinationAdvisoryConsumer(testTopicName);
1: 
1:         //configure a virtual destination that forwards messages from topic testQueueName
1:         //to topic "include.test.bar.bridge"
1:         CompositeTopic compositeTopic = createCompositeTopic(testTopicName,
1:                 new ActiveMQTopic("include.test.bar.bridge"));
1: 
0:         runtimeBroker.setVirtualDestinations(new VirtualDestination[] {compositeTopic});
1: 
1:         MessageProducer includedProducer = localSession.createProducer(included);
1:         Thread.sleep(2000);
1:         Message test = localSession.createTextMessage("test");
1: 
1:         final DestinationStatistics destinationStatistics = localBroker.getDestination(included).getDestinationStatistics();
1: 
1:         //create a durable subscription and go offline
1:         MessageConsumer bridgeConsumer = remoteSession.createDurableSubscriber(
1:                 new ActiveMQTopic("include.test.bar.bridge"), "sub1");
1:         bridgeConsumer.close();
1:         Thread.sleep(2000);
1:         includedProducer.send(test);
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return 1 == destinationStatistics.getDequeues().getCount() &&
1:                         destinationStatistics.getDispatched().getCount() == 1;
1:             }
1:         });
1: 
1:         //offline durable should still get receive the message over the bridge and ack
1:         assertEquals("broker dest stat dispatched", 1, destinationStatistics.getDispatched().getCount());
1:         assertEquals("broker dest stat dequeues", 1, destinationStatistics.getDequeues().getCount());
1: 
1:         //reconnect to receive the message
1:         MessageConsumer bridgeConsumer2 = remoteSession.createDurableSubscriber(
1:                 new ActiveMQTopic("include.test.bar.bridge"), "sub1");
1:         assertNotNull(bridgeConsumer2.receive(5000));
1: 
1:         Thread.sleep(2000);
1:         //make sure stats did not change
1:         assertEquals("broker dest stat dispatched", 1, destinationStatistics.getDispatched().getCount());
1:         assertEquals("broker dest stat dequeues", 1, destinationStatistics.getDequeues().getCount());
1: 
1:         assertRemoteAdvisoryCount(advisoryConsumer, 3);
1:         assertAdvisoryBrokerCounts(1,1,0);
1: 
1:     }
1: 
1:     @Before
1:     public void setUp() throws Exception {
1: 
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         doTearDown();
1:     }
1: 
0:     protected void doTearDown() throws Exception {
0:         if (localConnection != null) {
0:             localConnection.close();
1:         }
0:         if (remoteConnection != null) {
0:             remoteConnection.close();
1:         }
0:         if (localBroker != null) {
0:             localBroker.stop();
1:         }
0:         if (remoteBroker != null) {
0:             remoteBroker.stop();
1:         }
1:     }
1: 
1: 
1:     protected void doSetUp(boolean deleteAllMessages,
1:             VirtualDestination[] remoteVirtualDests) throws Exception {
0:         doSetUp(deleteAllMessages, remoteVirtualDests, true);
1:     }
1: 
1:     protected void doSetUp(boolean deleteAllMessages,
0:             VirtualDestination[] remoteVirtualDests, boolean startNetworkConnector) throws Exception {
1:         remoteBroker = createRemoteBroker(isUseVirtualDestSubsOnCreation, remoteVirtualDests);
1:         remoteBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:         remoteBroker.start();
1:         remoteBroker.waitUntilStarted();
0:         localBroker = createLocalBroker(startNetworkConnector);
1:         localBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:         localBroker.start();
1:         localBroker.waitUntilStarted();
1:         URI localURI = localBroker.getVmConnectorURI();
1:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(localURI);
1:         fac.setAlwaysSyncSend(true);
1:         fac.setDispatchAsync(false);
1:         localConnection = fac.createConnection();
1:         localConnection.setClientID("clientId");
1:         localConnection.start();
1:         URI remoteURI = remoteBroker.getVmConnectorURI();
1:         fac = new ActiveMQConnectionFactory(remoteURI);
1:         remoteConnection = fac.createConnection();
1:         remoteConnection.setClientID("clientId");
1:         remoteConnection.start();
1:         included = new ActiveMQTopic(testTopicName);
1:         excluded = new ActiveMQTopic("exclude.test.bar");
1:         localSession = localConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:     }
1: 
1: 
1:     protected NetworkConnector connector;
0:     protected BrokerService createLocalBroker(boolean startNetworkConnector) throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setMonitorConnectionSplits(true);
1:         brokerService.setDataDirectoryFile(tempFolder.newFolder());
1:         brokerService.setBrokerName("localBroker");
1: 
0:         connector = new DiscoveryNetworkConnector(new URI("static:(tcp://localhost:61617)"));
1:         connector.setName("networkConnector");
1:         connector.setDynamicOnly(false);
1:         connector.setDecreaseNetworkConsumerPriority(false);
1:         connector.setConduitSubscriptions(true);
1:         connector.setDuplex(isDuplex);
1:         connector.setUseVirtualDestSubs(true);
1:         connector.setDynamicallyIncludedDestinations(Lists.newArrayList(new ActiveMQQueue(testQueueName),
0:                 new ActiveMQTopic(testTopicName), new ActiveMQTopic("VirtualTopic.>")));
1:         connector.setExcludedDestinations(Lists.newArrayList(new ActiveMQQueue("exclude.test.foo"),
1:                 new ActiveMQTopic("exclude.test.bar")));
1: 
1:         if (startNetworkConnector) {
1:             brokerService.addNetworkConnector(connector);
1:         }
1: 
0:         brokerService.addConnector("tcp://localhost:61616");
1: 
1:         return brokerService;
1:     }
1: 
1:     protected AdvisoryBroker remoteAdvisoryBroker;
1:     protected BrokerService createRemoteBroker(boolean isUsevirtualDestinationSubscriptionsOnCreation,
1:             VirtualDestination[] remoteVirtualDests) throws Exception {
1:         BrokerService brokerService = new BrokerService();
1:         brokerService.setBrokerName("remoteBroker");
1:         brokerService.setUseJmx(false);
1:         brokerService.setDataDirectoryFile(tempFolder.newFolder());
1:         brokerService.setPlugins(new BrokerPlugin[] {new JavaRuntimeConfigurationPlugin()});
1:         brokerService.setUseVirtualDestSubs(true);
1:         brokerService.setUseVirtualDestSubsOnCreation(isUsevirtualDestinationSubscriptionsOnCreation);
1: 
1:         //apply interceptor before getting the broker, which will cause it to be built
1:         if (remoteVirtualDests != null) {
1:             VirtualDestinationInterceptor interceptor = new VirtualDestinationInterceptor();
1:             interceptor.setVirtualDestinations(remoteVirtualDests);
1:             brokerService.setDestinationInterceptors(new DestinationInterceptor[]{interceptor});
1:         }
1: 
1:         runtimeBroker = (JavaRuntimeConfigurationBroker)
1:                 brokerService.getBroker().getAdaptor(JavaRuntimeConfigurationBroker.class);
1:         remoteAdvisoryBroker = (AdvisoryBroker)
1:                 brokerService.getBroker().getAdaptor(AdvisoryBroker.class);
1: 
0:         NetworkConnector connector = new DiscoveryNetworkConnector(new URI("static:(tcp://localhost:61616)"));
1:         brokerService.addNetworkConnector(connector);
1: 
0:         brokerService.addConnector("tcp://localhost:61617");
1: 
1: 
1: 
1:         return brokerService;
1:     }
1: 
1:     protected CompositeTopic createCompositeTopic(String name, ActiveMQDestination...forwardTo) {
1:         CompositeTopic compositeTopic = new CompositeTopic();
1:         compositeTopic.setName(name);
1:         compositeTopic.setForwardOnly(true);
1:         compositeTopic.setForwardTo( Lists.newArrayList(forwardTo));
1: 
1:         return compositeTopic;
1:     }
1: 
1:     protected CompositeQueue createCompositeQueue(String name, ActiveMQDestination...forwardTo) {
1:         CompositeQueue compositeQueue = new CompositeQueue();
1:         compositeQueue.setName(name);
1:         compositeQueue.setForwardOnly(true);
1:         compositeQueue.setForwardTo( Lists.newArrayList(forwardTo));
1: 
1:         return compositeQueue;
1:     }
1: 
0:     protected void waitForConsumerCount(final DestinationStatistics destinationStatistics, final int count) throws Exception {
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 //should only be 1 for the composite destination creation
0:                 return count == destinationStatistics.getConsumers().getCount();
1:             }
1:         });
1:     }
1: 
0:     protected void waitForDispatchFromLocalBroker(final DestinationStatistics destinationStatistics, final int count) throws Exception {
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return count == destinationStatistics.getDequeues().getCount() &&
0:                        count == destinationStatistics.getDispatched().getCount() &&
0:                        count == destinationStatistics.getForwards().getCount();
1:             }
1:         });
1:     }
1: 
1:     protected MessageConsumer getVirtualDestinationAdvisoryConsumer(String topic) throws JMSException {
1:         return remoteSession.createConsumer(AdvisorySupport.getVirtualDestinationConsumerAdvisoryTopic(
1:                 new ActiveMQTopic(topic)));
1:     }
1: 
1:     protected MessageConsumer getQueueVirtualDestinationAdvisoryConsumer(String queue) throws JMSException {
1:         return remoteSession.createConsumer(AdvisorySupport.getVirtualDestinationConsumerAdvisoryTopic(
1:                 new ActiveMQQueue(queue)));
1:     }
1: 
0:     protected void assertLocalBrokerStatistics(final DestinationStatistics localStatistics, final int count) {
0:         assertEquals("local broker dest stat dispatched", count, localStatistics.getDispatched().getCount());
0:         assertEquals("local broker dest stat dequeues", count, localStatistics.getDequeues().getCount());
0:         assertEquals("local broker dest stat forwards", count, localStatistics.getForwards().getCount());
1:     }
1: 
1:     protected void assertRemoteAdvisoryCount(final MessageConsumer advisoryConsumer, final int count) throws JMSException {
1:         int available = 0;
1:         ActiveMQMessage message = null;
1:         while ((message = (ActiveMQMessage) advisoryConsumer.receive(1000)) != null) {
1:             available++;
0:             LOG.debug("advisory data structure: {}", message.getDataStructure());
1:         }
1:         assertEquals(count, available);
1:     }
1: 
1:     protected void assertRemoteAdvisoryCount(final MessageConsumer advisoryConsumer,
1:             final int isSubOnCreationCount, final int isNotSubOnCreationCount) throws JMSException {
1:         if (isUseVirtualDestSubsOnCreation) {
1:             assertRemoteAdvisoryCount(advisoryConsumer, isSubOnCreationCount);
1:         } else {
1:             assertRemoteAdvisoryCount(advisoryConsumer, isNotSubOnCreationCount);
1:         }
1:     }
1: 
1:     @SuppressWarnings("unchecked")
1:     protected void assertAdvisoryBrokerCounts(int virtualDestinationsCount,
1:             int virtualDestinationConsumersCount, int brokerConsumerDestsCount) throws Exception {
1: 
1:         Field virtualDestinationsField = AdvisoryBroker.class.getDeclaredField("virtualDestinations");
1:         Field virtualDestinationConsumersField = AdvisoryBroker.class.getDeclaredField("virtualDestinationConsumers");
1:         Field brokerConsumerDestsField = AdvisoryBroker.class.getDeclaredField("brokerConsumerDests");
1: 
1:         virtualDestinationsField.setAccessible(true);
1:         virtualDestinationConsumersField.setAccessible(true);
1:         brokerConsumerDestsField.setAccessible(true);
1: 
1:         Set<VirtualDestination> virtualDestinations = (Set<VirtualDestination>)
1:                 virtualDestinationsField.get(remoteAdvisoryBroker);
1: 
1:         ConcurrentMap<ConsumerInfo, VirtualDestination> virtualDestinationConsumers =
1:                 (ConcurrentMap<ConsumerInfo, VirtualDestination>)
1:                     virtualDestinationConsumersField.get(remoteAdvisoryBroker);
1: 
1:         ConcurrentMap<Object, ConsumerInfo> brokerConsumerDests =
1:                 (ConcurrentMap<Object, ConsumerInfo>)
1:                 brokerConsumerDestsField.get(remoteAdvisoryBroker);
1: 
1:         assertEquals(virtualDestinationsCount, virtualDestinations.size());
1:         assertEquals(virtualDestinationConsumersCount, virtualDestinationConsumers.size());
1:         assertEquals(brokerConsumerDestsCount, brokerConsumerDests.size());
1:     }
1: 
1: }
============================================================================