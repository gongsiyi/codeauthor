1:d7f34d9: /**
1:d7f34d9:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:d7f34d9:  * contributor license agreements.  See the NOTICE file distributed with
1:d7f34d9:  * this work for additional information regarding copyright ownership.
1:d7f34d9:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:d7f34d9:  * (the "License"); you may not use this file except in compliance with
1:d7f34d9:  * the License.  You may obtain a copy of the License at
1:d7f34d9:  *
1:d7f34d9:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d7f34d9:  *
1:d7f34d9:  * Unless required by applicable law or agreed to in writing, software
1:d7f34d9:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d7f34d9:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7f34d9:  * See the License for the specific language governing permissions and
1:d7f34d9:  * limitations under the License.
1:d7f34d9:  */
4:d7f34d9: 
1:d7f34d9: package org.apache.activemq.broker.region;
1:d7f34d9: 
1:d7f34d9: import java.io.IOException;
1:d7f34d9: import java.util.List;
1:d7f34d9: import java.util.Vector;
1:d7f34d9: import java.util.concurrent.CountDownLatch;
1:d7f34d9: import java.util.concurrent.TimeUnit;
1:d7f34d9: import java.util.concurrent.atomic.AtomicLong;
1:d7f34d9: 
1:d7f34d9: import javax.jms.InvalidSelectorException;
1:d7f34d9: import javax.management.ObjectName;
1:d7f34d9: 
1:d7f34d9: import junit.framework.TestCase;
1:d7f34d9: 
1:d7f34d9: import org.apache.activemq.broker.BrokerService;
1:d7f34d9: import org.apache.activemq.broker.ConnectionContext;
1:d7f34d9: import org.apache.activemq.broker.ProducerBrokerExchange;
1:eece576: import org.apache.activemq.broker.region.SubscriptionStatistics;
1:d7f34d9: import org.apache.activemq.command.ActiveMQDestination;
1:d7f34d9: import org.apache.activemq.command.ActiveMQQueue;
1:d7f34d9: import org.apache.activemq.command.ActiveMQTextMessage;
1:d7f34d9: import org.apache.activemq.command.ConsumerInfo;
1:d7f34d9: import org.apache.activemq.command.Message;
1:d7f34d9: import org.apache.activemq.command.MessageAck;
1:d7f34d9: import org.apache.activemq.command.MessageDispatchNotification;
1:d7f34d9: import org.apache.activemq.command.MessageId;
1:d7f34d9: import org.apache.activemq.command.MessagePull;
1:d7f34d9: import org.apache.activemq.command.ProducerInfo;
1:d7f34d9: import org.apache.activemq.command.Response;
1:d7f34d9: import org.apache.activemq.filter.MessageEvaluationContext;
1:07ec890: import org.apache.activemq.management.CountStatisticImpl;
1:d7f34d9: import org.apache.activemq.state.ProducerState;
1:d7f34d9: import org.apache.activemq.store.MessageStore;
1:37c2a95: import org.apache.activemq.store.PersistenceAdapter;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:d7f34d9: 
1:d7f34d9: /**
1:d7f34d9:  * @author gtully
1:d7f34d9:  * @see https://issues.apache.org/activemq/browse/AMQ-2020
1:d7f34d9:  **/
1:d7f34d9: public class QueueDuplicatesFromStoreTest extends TestCase {
1:8bf987b:     private static final Logger LOG = LoggerFactory
1:8bf987b:             .getLogger(QueueDuplicatesFromStoreTest.class);
1:d7f34d9: 
1:d7f34d9:     ActiveMQQueue destination = new ActiveMQQueue("queue-"
1:d7f34d9:             + QueueDuplicatesFromStoreTest.class.getSimpleName());
1:d7f34d9:     BrokerService brokerService;
1:d7f34d9: 
1:d7f34d9:     final static String mesageIdRoot = "11111:22222:";
1:d7f34d9:     final int messageBytesSize = 256;
1:d7f34d9:     final String text = new String(new byte[messageBytesSize]);
1:d7f34d9: 
1:d7f34d9:     final int ackStartIndex = 100;
1:d7f34d9:     final int ackWindow = 50;
1:d7f34d9:     final int ackBatchSize = 50;
1:d7f34d9:     final int fullWindow = 200;
1:21541da:     protected int count = 5000;
1:d7f34d9: 
1:1982d54:     @Override
1:d7f34d9:     public void setUp() throws Exception {
1:37c2a95:         brokerService = createBroker();
1:d7f34d9:         brokerService.setUseJmx(false);
1:d7f34d9:         brokerService.deleteAllMessages();
1:1982d54:         brokerService.start();
2:d7f34d9:     }
1:d7f34d9: 
1:37c2a95:     protected BrokerService createBroker() throws Exception {
1:37c2a95:         return new BrokerService();
1:37c2a95:     }
1:37c2a95: 
1:1982d54:     @Override
1:1982d54:     public void tearDown() throws Exception {
1:d7f34d9:         brokerService.stop();
1:d7f34d9:     }
1:d7f34d9: 
1:d7f34d9:     public void testNoDuplicateAfterCacheFullAndAckedWithLargeAuditDepth() throws Exception {
1:d7f34d9:         doTestNoDuplicateAfterCacheFullAndAcked(1024*10);
1:d7f34d9:     }
1:d7f34d9: 
1:d7f34d9:     public void testNoDuplicateAfterCacheFullAndAckedWithSmallAuditDepth() throws Exception {
1:d7f34d9:         doTestNoDuplicateAfterCacheFullAndAcked(512);
1:d7f34d9:     }
1:d7f34d9: 
1:d7f34d9:     public void doTestNoDuplicateAfterCacheFullAndAcked(final int auditDepth) throws Exception {
1:37c2a95:         final PersistenceAdapter persistenceAdapter =  brokerService.getPersistenceAdapter();
1:1982d54:         final MessageStore queueMessageStore =
1:eece576:                 persistenceAdapter.createQueueMessageStore(destination);
1:d7f34d9:         final ConnectionContext contextNotInTx = new ConnectionContext();
1:d7f34d9:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:d7f34d9:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:d7f34d9:         consumerInfo.setExclusive(true);
1:d7f34d9:         final Queue queue = new Queue(brokerService, destination,
1:c808beb:                 queueMessageStore, destinationStatistics, brokerService.getTaskRunnerFactory());
1:d7f34d9: 
1:d7f34d9:         // a workaround for this issue
1:d7f34d9:         // queue.setUseCache(false);
1:d7f34d9:         queue.systemUsage.getMemoryUsage().setLimit(1024 * 1024 * 10);
1:d7f34d9:         queue.setMaxAuditDepth(auditDepth);
1:d7f34d9:         queue.initialize();
1:d7f34d9:         queue.start();
1:1982d54: 
1:d7f34d9: 
1:d7f34d9:         ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:d7f34d9:         ProducerInfo producerInfo = new ProducerInfo();
1:d7f34d9:         ProducerState producerState = new ProducerState(producerInfo);
1:d7f34d9:         producerExchange.setProducerState(producerState);
1:d7f34d9:         producerExchange.setConnectionContext(contextNotInTx);
1:d7f34d9: 
1:d7f34d9:         final CountDownLatch receivedLatch = new CountDownLatch(count);
1:d7f34d9:         final AtomicLong ackedCount = new AtomicLong(0);
1:d7f34d9:         final AtomicLong enqueueCounter = new AtomicLong(0);
1:d7f34d9:         final Vector<String> errors = new Vector<String>();
1:1982d54: 
1:d7f34d9:         // populate the queue store, exceed memory limit so that cache is disabled
1:d7f34d9:         for (int i = 0; i < count; i++) {
1:d7f34d9:             Message message = getMessage(i);
1:d7f34d9:             queue.send(producerExchange, message);
1:d7f34d9:         }
1:37c2a95: 
1:37c2a95:         assertEquals("store count is correct", count, queueMessageStore.getMessageCount());
1:1982d54: 
1:d7f34d9:         // pull from store in small windows
1:d7f34d9:         Subscription subscription = new Subscription() {
1:d7f34d9: 
1:eece576:             private SubscriptionStatistics subscriptionStatistics = new SubscriptionStatistics();
1:eece576: 
1:1982d54:             @Override
1:d7f34d9:             public void add(MessageReference node) throws Exception {
1:d7f34d9:                 if (enqueueCounter.get() != node.getMessageId().getProducerSequenceId()) {
1:d7f34d9:                     errors.add("Not in sequence at: " + enqueueCounter.get() + ", received: "
1:d7f34d9:                             + node.getMessageId().getProducerSequenceId());
1:d7f34d9:                 }
1:d7f34d9:                 assertEquals("is in order", enqueueCounter.get(), node
1:d7f34d9:                         .getMessageId().getProducerSequenceId());
1:d7f34d9:                 receivedLatch.countDown();
1:d7f34d9:                 enqueueCounter.incrementAndGet();
1:d7f34d9:                 node.decrementReferenceCount();
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public void add(ConnectionContext context, Destination destination)
1:d7f34d9:                     throws Exception {
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public int countBeforeFull() {
1:d7f34d9:                 if (isFull()) {
1:d7f34d9:                     return 0;
1:d7f34d9:                 } else {
1:d7f34d9:                     return fullWindow - (int) (enqueueCounter.get() - ackedCount.get());
1:d7f34d9:                 }
1:d7f34d9:             }
1:07ec890: 
1:734fb7d:             @Override
1:d7f34d9:             public void destroy() {
1:d7f34d9:             };
1:d7f34d9: 
1:07ec890:             @Override
1:d7f34d9:             public void gc() {
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public ConsumerInfo getConsumerInfo() {
1:d7f34d9:                 return consumerInfo;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public ConnectionContext getContext() {
1:07ec890:                 return null;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public long getDequeueCounter() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public long getDispatchedCounter() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public int getDispatchedQueueSize() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public long getEnqueueCounter() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public int getInFlightSize() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public int getInFlightUsage() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public ObjectName getObjectName() {
2:d7f34d9:                 return null;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public int getPendingQueueSize() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:734fb7d:             public long getPendingMessageSize() {
1:734fb7d:                 return 0;
1:734fb7d:             }
1:734fb7d: 
1:734fb7d:             @Override
1:d7f34d9:             public int getPrefetchSize() {
1:d7f34d9:                 return 0;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public String getSelector() {
1:d7f34d9:                 return null;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean isBrowser() {
2:d7f34d9:                 return false;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean isFull() {
1:d7f34d9:                 return (enqueueCounter.get() - ackedCount.get()) >= fullWindow;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean isHighWaterMark() {
1:d7f34d9:                 return false;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean isLowWaterMark() {
1:d7f34d9:                 return false;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean isRecoveryRequired() {
1:d7f34d9:                 return false;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean matches(MessageReference node,
1:d7f34d9:                     MessageEvaluationContext context) throws IOException {
1:d7f34d9:                 return true;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean matches(ActiveMQDestination destination) {
1:d7f34d9:                 return true;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public void processMessageDispatchNotification(
1:d7f34d9:                     MessageDispatchNotification mdn) throws Exception {
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public Response pullMessage(ConnectionContext context,
1:d7f34d9:                     MessagePull pull) throws Exception {
1:d7f34d9:                 return null;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:94b404d:             public boolean isWildcard() {
1:94b404d:                 return false;
1:94b404d:             }
1:94b404d: 
1:94b404d:             @Override
1:d7f34d9:             public List<MessageReference> remove(ConnectionContext context,
1:d7f34d9:                     Destination destination) throws Exception {
1:d7f34d9:                 return null;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public void setObjectName(ObjectName objectName) {
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public void setSelector(String selector)
1:d7f34d9:                     throws InvalidSelectorException,
1:d7f34d9:                     UnsupportedOperationException {
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public void updateConsumerPrefetch(int newPrefetch) {
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public boolean addRecoveredMessage(ConnectionContext context,
1:d7f34d9:                     MessageReference message) throws Exception {
1:d7f34d9:                 return false;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public ActiveMQDestination getActiveMQDestination() {
1:d7f34d9:                 return destination;
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:d7f34d9:             public void acknowledge(ConnectionContext context, MessageAck ack)
1:d7f34d9:                     throws Exception {
1:d7f34d9:             }
1:d7f34d9: 
1:1982d54:             @Override
1:1982d54:             public int getCursorMemoryHighWaterMark(){
1:1982d54:                 return 0;
1:1982d54:             }
1:d7f34d9: 
1:1982d54:             @Override
1:1982d54:             public void setCursorMemoryHighWaterMark(
1:1982d54:                     int cursorMemoryHighWaterMark) {
1:1982d54:             }
1:1b6d397: 
1:1982d54:             @Override
1:1b6d397:             public boolean isSlowConsumer() {
1:1b6d397:                 return false;
1:1b6d397:             }
1:306f8a0: 
1:1982d54:             @Override
1:306f8a0:             public void unmatched(MessageReference node) throws IOException {
1:306f8a0:             }
1:1982d54: 
1:1982d54:             @Override
1:1982d54:             public long getTimeOfLastMessageAck() {
1:1982d54:                 return 0;
1:07ec890:             }
1:d7f34d9: 
1:1982d54:             @Override
1:6683eb6:             public long getConsumedCount() {
1:6683eb6:                 return 0;
1:6683eb6:             }
1:6683eb6: 
1:1982d54:             @Override
1:6683eb6:             public void incrementConsumedCount(){
1:6683eb6: 
1:6683eb6:             }
1:6683eb6: 
1:734fb7d:             @Override
1:6683eb6:             public void resetConsumedCount(){
1:eece576: 
1:1982d54:             }
1:6683eb6: 
1:eece576:             @Override
1:eece576:             public SubscriptionStatistics getSubscriptionStatistics() {
1:eece576:                 return subscriptionStatistics;
1:eece576:             }
1:4605503: 
1:4605503:             @Override
1:4605503:             public long getInFlightMessageSize() {
1:4605503:                 return subscriptionStatistics.getInflightMessageSize().getTotalSize();
1:4605503:             }
1:d7f34d9:         };
1:d7f34d9: 
1:d7f34d9:         queue.addSubscription(contextNotInTx, subscription);
1:d7f34d9:         int removeIndex = 0;
1:d7f34d9:         do {
1:d7f34d9:             // Simulate periodic acks in small but recent windows
1:d7f34d9:             long receivedCount = enqueueCounter.get();
1:d7f34d9:             if (receivedCount > ackStartIndex) {
1:d7f34d9:                 if (receivedCount >= removeIndex + ackWindow) {
1:d7f34d9:                     for (int j = 0; j < ackBatchSize; j++, removeIndex++) {
1:d7f34d9:                         ackedCount.incrementAndGet();
1:d7f34d9:                         MessageAck ack = new MessageAck();
1:d7f34d9:                         ack.setLastMessageId(new MessageId(mesageIdRoot
1:d7f34d9:                                 + removeIndex));
1:d7f34d9:                         ack.setMessageCount(1);
1:d7f34d9:                         queue.removeMessage(contextNotInTx, subscription,
1:d7f34d9:                                 new IndirectMessageReference(
1:d7f34d9:                                         getMessage(removeIndex)), ack);
1:1421317:                         queue.wakeup();
1:d7f34d9: 
1:d7f34d9:                     }
1:d7f34d9:                     if (removeIndex % 1000 == 0) {
1:d7f34d9:                         LOG.info("acked: " + removeIndex);
1:d7f34d9:                         persistenceAdapter.checkpoint(true);
1:d7f34d9:                     }
1:d7f34d9:                 }
1:d7f34d9:             }
1:d7f34d9: 
1:d7f34d9:         } while (!receivedLatch.await(0, TimeUnit.MILLISECONDS) && errors.isEmpty());
1:d7f34d9: 
1:d7f34d9:         assertTrue("There are no errors: " + errors, errors.isEmpty());
1:d7f34d9:         assertEquals(count, enqueueCounter.get());
1:d7f34d9:         assertEquals("store count is correct", count - removeIndex,
1:d7f34d9:                 queueMessageStore.getMessageCount());
1:d7f34d9:     }
1:d7f34d9: 
1:d7f34d9:     private Message getMessage(int i) throws Exception {
1:d7f34d9:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:d7f34d9:         message.setMessageId(new MessageId(mesageIdRoot + i));
1:d7f34d9:         message.setDestination(destination);
1:d7f34d9:         message.setPersistent(true);
1:d7f34d9:         message.setResponseRequired(true);
1:d7f34d9:         message.setText("Msg:" + i + " " + text);
1:d7f34d9:         assertEquals(message.getMessageId().getProducerSequenceId(), i);
1:d7f34d9:         return message;
1:d7f34d9:     }
1:d7f34d9: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:             public long getPendingMessageSize() {
1:                 return 0;
1:             }
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
commit:4605503
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
1:             public long getInFlightMessageSize() {
1:                 return subscriptionStatistics.getInflightMessageSize().getTotalSize();
1:             }
commit:eece576
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.SubscriptionStatistics;
/////////////////////////////////////////////////////////////////////////
1:                 persistenceAdapter.createQueueMessageStore(destination);
/////////////////////////////////////////////////////////////////////////
1:             private SubscriptionStatistics subscriptionStatistics = new SubscriptionStatistics();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
1:             public SubscriptionStatistics getSubscriptionStatistics() {
1:                 return subscriptionStatistics;
1:             }
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:94b404d
/////////////////////////////////////////////////////////////////////////
1:             public boolean isWildcard() {
1:                 return false;
1:             }
1: 
1:             @Override
author:rajdavies
-------------------------------------------------------------------------------
commit:6683eb6
/////////////////////////////////////////////////////////////////////////
1:             public long getConsumedCount() {
1:                 return 0;
1:             }
1: 
1:             public void incrementConsumedCount(){
1: 
1:             }
1: 
1:             public void resetConsumedCount(){
1: 
author:Rob Davies
-------------------------------------------------------------------------------
commit:07ec890
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.management.CountStatisticImpl;
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
0:             public CountStatisticImpl getConsumedCount() {
1:                 return null;
1:             }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:1982d54
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         brokerService.start();
1:     @Override
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         final MessageStore queueMessageStore =
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             @Override
1:             public int getCursorMemoryHighWaterMark(){
1:                 return 0;
1:             }
1:             @Override
1:             public void setCursorMemoryHighWaterMark(
1:                     int cursorMemoryHighWaterMark) {
1:             }
1:             @Override
1:             @Override
1: 
1:             @Override
1:             public long getTimeOfLastMessageAck() {
1:                 return 0;
1:             }
commit:ef24cc9
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:30f531d
/////////////////////////////////////////////////////////////////////////
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:21541da
/////////////////////////////////////////////////////////////////////////
1:     protected int count = 5000;
commit:306f8a0
/////////////////////////////////////////////////////////////////////////
1: 
1:             public void unmatched(MessageReference node) throws IOException {
1:             }
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
0: 			        int cursorMemoryHighWaterMark) {				
1: 
1:             public boolean isSlowConsumer() {
1:                 return false;
1:             }
commit:c808beb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:                 queueMessageStore, destinationStatistics, brokerService.getTaskRunnerFactory());
commit:1421317
/////////////////////////////////////////////////////////////////////////
1:                         queue.wakeup();
commit:37c2a95
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0:     protected int count = 20000;
1:         brokerService = createBroker();
1:     protected BrokerService createBroker() throws Exception {
1:         return new BrokerService();
1:     }
1: 
0: 	public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         final PersistenceAdapter persistenceAdapter =  brokerService.getPersistenceAdapter();
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("store count is correct", count, queueMessageStore.getMessageCount());
1:         
/////////////////////////////////////////////////////////////////////////
commit:d7f34d9
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.broker.region;
1: 
1: import java.io.IOException;
1: import java.util.List;
1: import java.util.Vector;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import javax.jms.InvalidSelectorException;
1: import javax.management.ObjectName;
1: 
1: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.ProducerBrokerExchange;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatchNotification;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.MessagePull;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.filter.MessageEvaluationContext;
1: import org.apache.activemq.state.ProducerState;
1: import org.apache.activemq.store.MessageStore;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
1:  * @author gtully
1:  * @see https://issues.apache.org/activemq/browse/AMQ-2020
1:  **/
1: public class QueueDuplicatesFromStoreTest extends TestCase {
0:     private static final Log LOG = LogFactory
0:             .getLog(QueueDuplicatesFromStoreTest.class);
1: 
1:     ActiveMQQueue destination = new ActiveMQQueue("queue-"
1:             + QueueDuplicatesFromStoreTest.class.getSimpleName());
1:     BrokerService brokerService;
1: 
1:     final static String mesageIdRoot = "11111:22222:";
1:     final int messageBytesSize = 256;
1:     final String text = new String(new byte[messageBytesSize]);
1: 
1:     final int ackStartIndex = 100;
1:     final int ackWindow = 50;
1:     final int ackBatchSize = 50;
1:     final int fullWindow = 200;
0:     final int count = 20000;
1: 
1:     public void setUp() throws Exception {
0:         brokerService = new BrokerService();
1:         brokerService.setUseJmx(false);
1:         brokerService.deleteAllMessages();
0:         brokerService.start();        
1:     }
1: 
0:     public void tearDown() throws Exception {
1:         brokerService.stop();
1:     }
1: 
1:     public void testNoDuplicateAfterCacheFullAndAckedWithLargeAuditDepth() throws Exception {
1:         doTestNoDuplicateAfterCacheFullAndAcked(1024*10);
1:     }
1: 
1:     public void testNoDuplicateAfterCacheFullAndAckedWithSmallAuditDepth() throws Exception {
1:         doTestNoDuplicateAfterCacheFullAndAcked(512);
1:     }
1: 
1:     public void doTestNoDuplicateAfterCacheFullAndAcked(final int auditDepth) throws Exception {
0:         final AMQPersistenceAdapter persistenceAdapter = 
0:             (AMQPersistenceAdapter) brokerService.getPersistenceAdapter();
0:         final MessageStore queueMessageStore = 
0:             persistenceAdapter.createQueueMessageStore(destination);
1:         final ConnectionContext contextNotInTx = new ConnectionContext();
1:         final ConsumerInfo consumerInfo = new ConsumerInfo();
1:         final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:         consumerInfo.setExclusive(true);
1:         final Queue queue = new Queue(brokerService, destination,
0:                 queueMessageStore, destinationStatistics, null);
1: 
1:         // a workaround for this issue
1:         // queue.setUseCache(false);
1:         queue.systemUsage.getMemoryUsage().setLimit(1024 * 1024 * 10);
1:         queue.setMaxAuditDepth(auditDepth);
1:         queue.initialize();
1:         queue.start();
1:        
1: 
1:         ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:         ProducerInfo producerInfo = new ProducerInfo();
1:         ProducerState producerState = new ProducerState(producerInfo);
1:         producerExchange.setProducerState(producerState);
1:         producerExchange.setConnectionContext(contextNotInTx);
1: 
1:         final CountDownLatch receivedLatch = new CountDownLatch(count);
1:         final AtomicLong ackedCount = new AtomicLong(0);
1:         final AtomicLong enqueueCounter = new AtomicLong(0);
1:         final Vector<String> errors = new Vector<String>();
1:                 
1:         // populate the queue store, exceed memory limit so that cache is disabled
1:         for (int i = 0; i < count; i++) {
1:             Message message = getMessage(i);
1:             queue.send(producerExchange, message);
1:         }
1:         
0:         assertEquals("store count is correct", count, queueMessageStore
0:                 .getMessageCount());
1: 
1:         // pull from store in small windows
1:         Subscription subscription = new Subscription() {
1: 
1:             public void add(MessageReference node) throws Exception {
1:                 if (enqueueCounter.get() != node.getMessageId().getProducerSequenceId()) {
1:                     errors.add("Not in sequence at: " + enqueueCounter.get() + ", received: "
1:                             + node.getMessageId().getProducerSequenceId());
1:                 }
1:                 assertEquals("is in order", enqueueCounter.get(), node
1:                         .getMessageId().getProducerSequenceId());
1:                 receivedLatch.countDown();
1:                 enqueueCounter.incrementAndGet();
1:                 node.decrementReferenceCount();
1:             }
1: 
1:             public void add(ConnectionContext context, Destination destination)
1:                     throws Exception {
1:             }
1: 
1:             public int countBeforeFull() {
1:                 if (isFull()) {
1:                     return 0;
1:                 } else {
1:                     return fullWindow - (int) (enqueueCounter.get() - ackedCount.get());
1:                 }
1:             }
1: 
1:             public void destroy() {
1:             };
1: 
1:             public void gc() {
1:             }
1: 
1:             public ConsumerInfo getConsumerInfo() {
1:                 return consumerInfo;
1:             }
1: 
1:             public ConnectionContext getContext() {
1:                 return null;
1:             }
1: 
1:             public long getDequeueCounter() {
1:                 return 0;
1:             }
1: 
1:             public long getDispatchedCounter() {
1:                 return 0;
1:             }
1: 
1:             public int getDispatchedQueueSize() {
1:                 return 0;
1:             }
1: 
1:             public long getEnqueueCounter() {
1:                 return 0;
1:             }
1: 
1:             public int getInFlightSize() {
1:                 return 0;
1:             }
1: 
1:             public int getInFlightUsage() {
1:                 return 0;
1:             }
1: 
1:             public ObjectName getObjectName() {
1:                 return null;
1:             }
1: 
1:             public int getPendingQueueSize() {
1:                 return 0;
1:             }
1: 
1:             public int getPrefetchSize() {
1:                 return 0;
1:             }
1: 
1:             public String getSelector() {
1:                 return null;
1:             }
1: 
1:             public boolean isBrowser() {
1:                 return false;
1:             }
1: 
1:             public boolean isFull() {
1:                 return (enqueueCounter.get() - ackedCount.get()) >= fullWindow;
1:             }
1: 
1:             public boolean isHighWaterMark() {
1:                 return false;
1:             }
1: 
1:             public boolean isLowWaterMark() {
1:                 return false;
1:             }
1: 
1:             public boolean isRecoveryRequired() {
1:                 return false;
1:             }
1: 
0:             public boolean isSlave() {
1:                 return false;
1:             }
1: 
1:             public boolean matches(MessageReference node,
1:                     MessageEvaluationContext context) throws IOException {
1:                 return true;
1:             }
1: 
1:             public boolean matches(ActiveMQDestination destination) {
1:                 return true;
1:             }
1: 
1:             public void processMessageDispatchNotification(
1:                     MessageDispatchNotification mdn) throws Exception {
1:             }
1: 
1:             public Response pullMessage(ConnectionContext context,
1:                     MessagePull pull) throws Exception {
1:                 return null;
1:             }
1: 
1:             public List<MessageReference> remove(ConnectionContext context,
1:                     Destination destination) throws Exception {
1:                 return null;
1:             }
1: 
1:             public void setObjectName(ObjectName objectName) {
1:             }
1: 
1:             public void setSelector(String selector)
1:                     throws InvalidSelectorException,
1:                     UnsupportedOperationException {
1:             }
1: 
1:             public void updateConsumerPrefetch(int newPrefetch) {
1:             }
1: 
1:             public boolean addRecoveredMessage(ConnectionContext context,
1:                     MessageReference message) throws Exception {
1:                 return false;
1:             }
1: 
1:             public ActiveMQDestination getActiveMQDestination() {
1:                 return destination;
1:             }
1: 
1:             public void acknowledge(ConnectionContext context, MessageAck ack)
1:                     throws Exception {
1:             }
1:         };
1: 
1:         queue.addSubscription(contextNotInTx, subscription);
1:         int removeIndex = 0;
1:         do {
1:             // Simulate periodic acks in small but recent windows
1:             long receivedCount = enqueueCounter.get();
1:             if (receivedCount > ackStartIndex) {
1:                 if (receivedCount >= removeIndex + ackWindow) {
1:                     for (int j = 0; j < ackBatchSize; j++, removeIndex++) {
1:                         ackedCount.incrementAndGet();
1:                         MessageAck ack = new MessageAck();
1:                         ack.setLastMessageId(new MessageId(mesageIdRoot
1:                                 + removeIndex));
1:                         ack.setMessageCount(1);
1:                         queue.removeMessage(contextNotInTx, subscription,
1:                                 new IndirectMessageReference(
1:                                         getMessage(removeIndex)), ack);
1: 
1:                     }
1:                     if (removeIndex % 1000 == 0) {
1:                         LOG.info("acked: " + removeIndex);
1:                         persistenceAdapter.checkpoint(true);
0:                         persistenceAdapter.cleanup();
1:                     }
1:                 }
1:             }
1: 
1:         } while (!receivedLatch.await(0, TimeUnit.MILLISECONDS) && errors.isEmpty());
1: 
1:         assertTrue("There are no errors: " + errors, errors.isEmpty());
1:         assertEquals(count, enqueueCounter.get());
1:         assertEquals("store count is correct", count - removeIndex,
1:                 queueMessageStore.getMessageCount());
1:     }
1: 
1:     private Message getMessage(int i) throws Exception {
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         message.setMessageId(new MessageId(mesageIdRoot + i));
1:         message.setDestination(destination);
1:         message.setPersistent(true);
1:         message.setResponseRequired(true);
1:         message.setText("Msg:" + i + " " + text);
1:         assertEquals(message.getMessageId().getProducerSequenceId(), i);
1:         return message;
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory
1:             .getLogger(QueueDuplicatesFromStoreTest.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:785454a
/////////////////////////////////////////////////////////////////////////
0: 
0: 			public int getCursorMemoryHighWaterMark(){
0: 				return 0;
0: 			}
0: 
0: 			public void setCursorMemoryHighWaterMark(
0: 					int cursorMemoryHighWaterMark) {				
0: 			}
============================================================================