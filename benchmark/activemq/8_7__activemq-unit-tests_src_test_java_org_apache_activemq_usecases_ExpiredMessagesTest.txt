1:461af7c: /**
1:461af7c:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:461af7c:  * contributor license agreements.  See the NOTICE file distributed with
1:461af7c:  * this work for additional information regarding copyright ownership.
1:461af7c:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:461af7c:  * (the "License"); you may not use this file except in compliance with
1:461af7c:  * the License.  You may obtain a copy of the License at
1:461af7c:  *
1:461af7c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:461af7c:  *
1:461af7c:  * Unless required by applicable law or agreed to in writing, software
1:461af7c:  * distributed under the License is distributed on an "AS IS" BASIS,
1:461af7c:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:461af7c:  * See the License for the specific language governing permissions and
1:461af7c:  * limitations under the License.
1:461af7c:  */
1:461af7c: package org.apache.activemq.usecases;
1:b0a38ff: 
1:57b8927: import junit.framework.Test;
1:570dbb4: 
1:461af7c: import org.apache.activemq.ActiveMQConnectionFactory;
1:41a1007: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:461af7c: import org.apache.activemq.CombinationTestSupport;
1:cdb38b3: import org.apache.activemq.broker.BrokerPlugin;
1:cdb38b3: import org.apache.activemq.broker.BrokerPluginSupport;
1:461af7c: import org.apache.activemq.broker.BrokerService;
1:cdb38b3: import org.apache.activemq.broker.ConnectionContext;
1:59653a5: import org.apache.activemq.broker.region.DestinationStatistics;
1:cdb38b3: import org.apache.activemq.broker.region.MessageReference;
1:687badb: import org.apache.activemq.broker.region.Subscription;
1:687badb: import org.apache.activemq.broker.region.TopicSubscription;
1:7a59d28: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:7a59d28: import org.apache.activemq.broker.region.policy.PolicyMap;
1:dbe847e: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
1:461af7c: import org.apache.activemq.command.ActiveMQDestination;
1:461af7c: import org.apache.activemq.command.ActiveMQQueue;
1:687badb: import org.apache.activemq.command.ActiveMQTopic;
1:570dbb4: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
1:ca242f4: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:b0a38ff: 
1:b2fca26: import javax.jms.*;
1:570dbb4: 
1:687badb: import java.util.List;
1:cdb38b3: import java.util.concurrent.TimeUnit;
1:b2fca26: import java.util.concurrent.atomic.AtomicLong;
1:b2fca26: 
1:b2fca26: import static org.apache.activemq.TestSupport.getDestination;
1:687badb: import static org.apache.activemq.TestSupport.getDestinationConsumers;
1:b2fca26: import static org.apache.activemq.TestSupport.getDestinationStatistics;
1:b2fca26: 
1:461af7c: public class ExpiredMessagesTest extends CombinationTestSupport {
1:4743a20: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ExpiredMessagesTest.class);
1:b0a38ff: 
1:461af7c:     BrokerService broker;
1:461af7c:     Connection connection;
1:461af7c:     Session session;
1:461af7c:     MessageProducer producer;
1:461af7c:     MessageConsumer consumer;
1:687badb:     private ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
1:687badb:     private boolean useTextMessage = true;
1:687badb:     private boolean useVMCursor = true;
1:687badb:     private boolean deleteAllMessages = true;
1:687badb:     private boolean usePrefetchExtension = true;
1:687badb:     private String brokerUri;
1:b0a38ff: 
1:461af7c:     public static Test suite() {
1:461af7c:         return suite(ExpiredMessagesTest.class);
8:461af7c:     }
1:cdb38b3: 
1:461af7c:     public static void main(String[] args) {
1:461af7c:         junit.textui.TestRunner.run(suite());
1:461af7c:     }
1:687badb: 
1:570dbb4:     @Override
1:b0a38ff:     protected void setUp() throws Exception {
1:687badb: 
1:461af7c:     }
1:687badb: 
1:4743a20:     @Override
1:570dbb4:     protected void tearDown() throws Exception {
1:687badb:         if (null != producer) {
1:687badb:             producer.close();
1:687badb:         }
1:687badb:         if (null != consumer) {
1:687badb:             consumer.close();
1:687badb:         }
1:687badb:         session.close();
1:570dbb4:         connection.stop();
1:570dbb4:         broker.stop();
1:570dbb4:         broker.waitUntilStopped();
1:687badb:     }
1:687badb: 
1:b0a38ff:     public void testExpiredMessages() throws Exception {
1:687badb:         final ActiveMQDestination destination = new ActiveMQQueue("test");
3:687badb:         final int numMessagesToSend = 10000;
1:687badb: 
2:687badb:         buildBroker(destination);
1:687badb: 
1:687badb:         final DestinationStatistics view = verifyMessageExpirationOnDestination(destination, numMessagesToSend);
1:687badb: 
1:687badb:         verifyDestinationDlq(destination, numMessagesToSend, view);
1:687badb:     }
1:687badb: 
1:41a1007:     public void testClientAckInflight_onTopic_withPrefetchExtension() throws Exception {
1:687badb:         usePrefetchExtension = true;
1:41a1007:         doTestClientAckInflight_onTopic_checkPrefetchExtension();
1:41a1007:     }
1:687badb: 
1:41a1007:     public void testClientAckInflight_onTopic_withOutPrefetchExtension() throws Exception {
1:41a1007:         usePrefetchExtension = false;
1:41a1007:         doTestClientAckInflight_onTopic_checkPrefetchExtension();
1:41a1007:     }
1:41a1007: 
1:41a1007:     public void doTestClientAckInflight_onTopic_checkPrefetchExtension() throws Exception {
1:41a1007:         final ActiveMQDestination destination = new ActiveMQTopic("test");
1:687badb:         buildBroker(destination);
1:687badb: 
1:41a1007:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:41a1007:                 "failover://"+brokerUri);
1:41a1007:         ActiveMQPrefetchPolicy prefetchTwo = new ActiveMQPrefetchPolicy();
1:41a1007:         prefetchTwo.setAll(6);
1:41a1007:         factory.setPrefetchPolicy(prefetchTwo);
1:41a1007:         connection = factory.createConnection();
1:41a1007:         connection.start();
1:41a1007:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:41a1007: 
1:41a1007:         MessageConsumer consumer = session.createConsumer(destination);
1:41a1007: 
1:41a1007:         produce(10, destination);
1:41a1007: 
1:41a1007:         Message m = null;
1:41a1007:         for (int i=0; i<5; i++) {
1:41a1007:             m = consumer.receive(4000);
1:41a1007:         }
1:41a1007:         assertNotNull(m);
1:687badb: 
2:687badb:         final List<Subscription> subscriptions = getDestinationConsumers(broker, destination);
1:687badb: 
1:687badb:         assertTrue("prefetch extension was not incremented",
1:41a1007:                 subscriptions.stream().
1:41a1007:                         filter(s -> s instanceof TopicSubscription).
1:41a1007:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
1:41a1007:                         allMatch(e -> usePrefetchExtension ? e > 1 : e == 0));
1:687badb: 
1:41a1007:         m.acknowledge();
1:687badb: 
1:41a1007:         assertTrue("prefetch extension was not incremented",
2:687badb:                 subscriptions.stream().
2:687badb:                         filter(s -> s instanceof TopicSubscription).
2:687badb:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
1:687badb:                         allMatch(e -> e == 0));
1:41a1007: 
1:687badb:     }
1:687badb: 
1:687badb: 
1:cdb38b3:     public void testReceiveTimeoutRespectedWithExpiryProcessing() throws Exception {
1:cdb38b3:         final ActiveMQDestination destination = new ActiveMQQueue("test");
1:cdb38b3:         broker = new BrokerService();
1:cdb38b3:         broker.setBrokerName("localhost");
1:cdb38b3:         broker.setDestinations(new ActiveMQDestination[]{destination});
1:cdb38b3:         broker.setPersistenceAdapter(new MemoryPersistenceAdapter());
1:cdb38b3: 
1:cdb38b3:         PolicyEntry defaultPolicy = new PolicyEntry();
1:cdb38b3:         defaultPolicy.setExpireMessagesPeriod(1000);
1:cdb38b3:         defaultPolicy.setMaxExpirePageSize(2000);
1:cdb38b3:         PolicyMap policyMap = new PolicyMap();
1:cdb38b3:         policyMap.setDefaultEntry(defaultPolicy);
1:cdb38b3:         broker.setDestinationPolicy(policyMap);
1:cdb38b3:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:cdb38b3:         broker.addConnector("tcp://localhost:0");
1:cdb38b3:         broker.setPlugins(new BrokerPlugin[] { new BrokerPluginSupport() {
1:cdb38b3:             @Override
1:cdb38b3:             public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription, Throwable poisonCause) {
1:cdb38b3:                 try {
1:cdb38b3:                     LOG.info("Sleeping before delegation on sendToDeadLetterQueue");
1:cdb38b3:                     TimeUnit.SECONDS.sleep(1);
1:cdb38b3:                 } catch (Exception ignored) {}
1:cdb38b3:                 return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);
1:cdb38b3:             }
1:cdb38b3:         }});
1:cdb38b3:         broker.start();
1:cdb38b3:         broker.waitUntilStarted();
1:cdb38b3: 
1:cdb38b3:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:cdb38b3:                 "vm://localhost");
1:cdb38b3:         ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:cdb38b3:         prefetchPolicy.setAll(0);
1:cdb38b3:         factory.setPrefetchPolicy(prefetchPolicy);
1:cdb38b3:         connection = factory.createConnection();
1:cdb38b3:         connection.start();
1:cdb38b3:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:cdb38b3:         producer = session.createProducer(destination);
1:cdb38b3:         producer.setTimeToLive(1000);
1:cdb38b3:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:cdb38b3: 
1:cdb38b3:         for (int i=0;i<10; i++) {
1:cdb38b3:             producer.send(session.createTextMessage("RTR"), DeliveryMode.PERSISTENT, 0, 2000);
1:cdb38b3:         }
1:cdb38b3: 
1:cdb38b3:         consumer = session.createConsumer(new ActiveMQQueue("another-test"));
1:cdb38b3: 
1:cdb38b3:         for (int i=0; i<10; i++) {
1:cdb38b3:             long timeStamp = System.currentTimeMillis();
1:cdb38b3:             consumer.receive(1000);
1:cdb38b3:             long duration = System.currentTimeMillis() - timeStamp;
1:cdb38b3:             LOG.info("Duration: " + i + " : " + duration);
1:cdb38b3:             assertTrue("Delay about 500: " + i + ", actual: " + duration, duration < 1500);
1:cdb38b3:         }
1:cdb38b3:     }
1:cdb38b3: 
1:cdb38b3: 
1:41a1007:     private void produce(int num, ActiveMQDestination destination) throws Exception {
1:41a1007:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:41a1007:                 "failover://"+brokerUri);
1:41a1007:         Connection connection = factory.createConnection();
1:41a1007:         connection.start();
1:41a1007:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:41a1007:         producer = session.createProducer(destination);
1:41a1007:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:41a1007:         int i = 0;
1:41a1007:         while (i++ < num) {
1:41a1007:             Message message = useTextMessage ? session
1:41a1007:                     .createTextMessage("test") : session
1:41a1007:                     .createObjectMessage("test");
1:41a1007:             producer.send(message);
1:41a1007:         }
1:41a1007:         connection.close();
1:41a1007:     }
1:41a1007: 
1:41a1007: 
1:687badb:     private void buildBroker(ActiveMQDestination destination) throws Exception {
1:687badb:         broker = createBroker(deleteAllMessages, usePrefetchExtension, 100, destination);
1:687badb:         brokerUri = broker.getTransportConnectors().get(0).getPublishableConnectString();
1:687badb:     }
1:687badb: 
1:687badb:     public void testRecoverExpiredMessages() throws Exception {
1:687badb:         final ActiveMQDestination destination = new ActiveMQQueue("test");
1:687badb: 
1:687badb:         buildBroker(destination);
1:687badb: 
1:687badb:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:687badb:                 "failover://"+brokerUri);
1:687badb:         connection = factory.createConnection();
1:687badb:         connection.start();
1:687badb:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:687badb:         producer = session.createProducer(destination);
1:687badb:         producer.setTimeToLive(2000);
1:687badb:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:687badb: 
1:687badb:         Thread producingThread = new Thread("Producing Thread") {
1:687badb:             @Override
1:687badb:             public void run() {
1:687badb:                 try {
1:687badb:                     int i = 0;
1:687badb:                     while (i++ < 1000) {
1:687badb:                         Message message = useTextMessage ? session
1:687badb:                                 .createTextMessage("test") : session
1:687badb:                                 .createObjectMessage("test");
1:687badb:                         producer.send(message);
1:687badb:                     }
1:687badb:                 } catch (Throwable ex) {
1:687badb:                     ex.printStackTrace();
1:687badb:                 }
1:687badb:             }
1:687badb:         };
1:687badb: 
1:687badb:         producingThread.start();
1:687badb:         producingThread.join();
1:687badb: 
1:687badb:         DestinationStatistics view = getDestinationStatistics(broker, destination);
1:687badb:         LOG.info("Stats: size: " + view.getMessages().getCount() + ", enqueues: "
1:687badb:                 + view.getEnqueues().getCount() + ", dequeues: "
1:687badb:                 + view.getDequeues().getCount() + ", dispatched: "
1:687badb:                 + view.getDispatched().getCount() + ", inflight: "
1:687badb:                 + view.getInflight().getCount() + ", expiries: "
1:687badb:                 + view.getExpired().getCount());
1:687badb: 
1:687badb:         LOG.info("stopping broker");
1:687badb:         broker.stop();
1:687badb:         broker.waitUntilStopped();
1:687badb: 
1:687badb:         Thread.sleep(5000);
1:687badb: 
1:687badb:         LOG.info("recovering broker");
1:687badb:         final boolean deleteAllMessages = false;
1:687badb:         final boolean usePrefetchExtension = true;
1:687badb:         broker = createBroker(deleteAllMessages, usePrefetchExtension, 5000, destination);
1:687badb: 
1:687badb:         Wait.waitFor(new Wait.Condition() {
1:687badb:             @Override
1:687badb:             public boolean isSatisified() throws Exception {
1:687badb:                 DestinationStatistics view = getDestinationStatistics(broker, destination);
1:687badb:                 LOG.info("Stats: size: " + view.getMessages().getCount() + ", enqueues: "
1:687badb:                         + view.getEnqueues().getCount() + ", dequeues: "
1:687badb:                         + view.getDequeues().getCount() + ", dispatched: "
1:687badb:                         + view.getDispatched().getCount() + ", inflight: "
1:687badb:                         + view.getInflight().getCount() + ", expiries: "
1:687badb:                         + view.getExpired().getCount());
1:687badb: 
1:687badb:                 return view.getMessages().getCount() == 0;
1:687badb:             }
1:687badb:         });
1:687badb: 
1:687badb:         view = getDestinationStatistics(broker, destination);
1:687badb:         assertEquals("Expect empty queue, QueueSize: ", 0, view.getMessages().getCount());
1:687badb:         assertEquals("all dequeues were expired", view.getDequeues().getCount(), view.getExpired().getCount());
1:687badb:     }
1:687badb: 
1:687badb:     private DestinationStatistics verifyMessageExpirationOnDestination(ActiveMQDestination destination, final int numMessagesToSend) throws Exception {
1:b0a38ff:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(brokerUri);
1:b0a38ff:         connection = factory.createConnection();
1:b0a38ff:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:b0a38ff:         producer = session.createProducer(destination);
1:b0a38ff:         producer.setTimeToLive(100);
1:b0a38ff:         consumer = session.createConsumer(destination);
1:b0a38ff:         connection.start();
1:b0a38ff:         final AtomicLong received = new AtomicLong();
1:570dbb4: 
1:b0a38ff:         Thread consumerThread = new Thread("Consumer Thread") {
1:4743a20:             @Override
2:461af7c:             public void run() {
1:b0a38ff:                 long start = System.currentTimeMillis();
2:461af7c:                 try {
1:b0a38ff:                     long end = System.currentTimeMillis();
1:b0a38ff:                     while (end - start < 3000) {
1:b0a38ff:                         if (consumer.receive(1000) != null) {
1:b0a38ff:                             received.incrementAndGet();
1:570dbb4:                         }
1:b0a38ff:                         Thread.sleep(100);
1:b0a38ff:                         end = System.currentTimeMillis();
1:b0a38ff:                     }
2:461af7c:                 } catch (Throwable ex) {
2:461af7c:                     ex.printStackTrace();
1:b0a38ff:                 }
1:b0a38ff:             }
1:b0a38ff:         };
1:b0a38ff: 
1:b0a38ff:         consumerThread.start();
1:b0a38ff: 
1:b0a38ff:         Thread producingThread = new Thread("Producing Thread") {
1:4743a20:             @Override
1:b0a38ff:             public void run() {
1:b0a38ff:                 try {
1:b0a38ff:                     int i = 0;
1:b0a38ff:                     while (i++ < numMessagesToSend) {
1:b0a38ff:                         producer.send(session.createTextMessage("test"));
1:b0a38ff:                     }
1:b0a38ff:                 } catch (Throwable ex) {
1:b0a38ff:                     ex.printStackTrace();
1:b0a38ff:                 }
1:b0a38ff:             }
1:b0a38ff:         };
1:b0a38ff: 
1:b0a38ff:         producingThread.start();
1:b0a38ff: 
1:461af7c:         consumerThread.join();
1:461af7c:         producingThread.join();
1:b0a38ff: 
1:5619cd0:         final DestinationStatistics view = getDestinationStatistics(broker, destination);
1:b0a38ff: 
1:ca242f4:         // wait for all to inflight to expire
1:ca242f4:         assertTrue("all inflight messages expired ", Wait.waitFor(new Wait.Condition() {
1:4743a20:             @Override
1:7b700ee:             public boolean isSatisified() throws Exception {
1:59653a5:                 return view.getInflight().getCount() == 0;
1:b0a38ff:             }
1:7b700ee:         }));
1:59653a5:         assertEquals("Wrong inFlightCount: ", 0, view.getInflight().getCount());
1:b0a38ff: 
1:59653a5:         LOG.info("Stats: received: "  + received.get() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:59653a5:                 + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:b0a38ff: 
1:ca242f4:         // wait for all sent to get delivered and expire
1:ca242f4:         assertTrue("all sent messages expired ", Wait.waitFor(new Wait.Condition() {
1:4743a20:             @Override
1:2a238f7:             public boolean isSatisified() throws Exception {
1:59653a5:                 long oldEnqueues = view.getEnqueues().getCount();
1:ca242f4:                 Thread.sleep(200);
1:59653a5:                 LOG.info("Stats: received: "  + received.get() + ", size= " + view.getMessages().getCount() + ", enqueues: " + view.getDequeues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:59653a5:                         + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:59653a5:                 return oldEnqueues == view.getEnqueues().getCount();
1:b0a38ff:             }
1:ca242f4:         }, 60*1000));
1:b0a38ff: 
1:b0a38ff: 
1:59653a5:         LOG.info("Stats: received: "  + received.get() + ", size= " + view.getMessages().getCount() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:59653a5:                 + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:b0a38ff: 
1:59653a5:         assertTrue("got at least what did not expire", received.get() >= view.getDequeues().getCount() - view.getExpired().getCount());
1:b0a38ff: 
1:59653a5:         assertTrue("all messages expired - queue size gone to zero " + view.getMessages().getCount(), Wait.waitFor(new Wait.Condition() {
1:4743a20:             @Override
1:a1bd85e:             public boolean isSatisified() throws Exception {
1:59653a5:                 LOG.info("Stats: received: "  + received.get() + ", size= " + view.getMessages().getCount() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:59653a5:                         + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:59653a5:                 return view.getMessages().getCount() == 0;
1:461af7c:             }
2:ca242f4:         }));
1:687badb:         return view;
1:687badb:     }
1:b0a38ff: 
1:687badb:     private void verifyDestinationDlq(ActiveMQDestination destination, int numMessagesToSend, DestinationStatistics view) throws Exception {
1:59653a5:         final long expiredBeforeEnqueue = numMessagesToSend - view.getEnqueues().getCount();
1:59653a5:         final long totalExpiredCount = view.getExpired().getCount() + expiredBeforeEnqueue;
1:b0a38ff: 
1:5619cd0:         final DestinationStatistics dlqView = getDestinationStatistics(broker, dlqDestination);
1:59653a5:         LOG.info("DLQ stats: size= " + dlqView.getMessages().getCount() + ", enqueues: " + dlqView.getDequeues().getCount() + ", dequeues: " + dlqView.getDequeues().getCount()
1:59653a5:                 + ", dispatched: " + dlqView.getDispatched().getCount() + ", inflight: " + dlqView.getInflight().getCount() + ", expiries: " + dlqView.getExpired().getCount());
1:b0a38ff: 
1:2a238f7:         Wait.waitFor(new Wait.Condition() {
1:4743a20:             @Override
3:ca242f4:             public boolean isSatisified() throws Exception {
1:59653a5:                 return totalExpiredCount == dlqView.getMessages().getCount();
1:461af7c:             }
1:2a238f7:         });
1:59653a5:         assertEquals("dlq contains all expired", totalExpiredCount, dlqView.getMessages().getCount());
1:b0a38ff: 
1:ce18ec8:         // memory check
1:5619cd0:         assertEquals("memory usage is back to duck egg", 0, getDestination(broker, destination).getMemoryUsage().getPercentUsage());
1:26807cd:         assertTrue("memory usage is increased ", 0 < getDestination(broker, dlqDestination).getMemoryUsage().getUsage());
1:b0a38ff: 
1:57b8927:         // verify DLQ
1:a1bd85e:         MessageConsumer dlqConsumer = createDlqConsumer(connection);
1:57b8927:         final DLQListener dlqListener = new DLQListener();
1:57b8927:         dlqConsumer.setMessageListener(dlqListener);
1:b0a38ff: 
1:57b8927:         Wait.waitFor(new Wait.Condition() {
1:4743a20:             @Override
1:57b8927:             public boolean isSatisified() throws Exception {
1:57b8927:                 return totalExpiredCount == dlqListener.count;
1:57b8927:             }
1:57b8927:         }, 60 * 1000);
1:b0a38ff: 
1:57b8927:         assertEquals("dlq returned all expired", dlqListener.count, totalExpiredCount);
1:b0a38ff:     }
1:b0a38ff: 
1:57b8927:     class DLQListener implements MessageListener {
1:b0a38ff: 
1:57b8927:         int count = 0;
1:b0a38ff: 
1:4743a20:         @Override
1:57b8927:         public void onMessage(Message message) {
1:57b8927:             count++;
1:57b8927:         }
1:b0a38ff: 
1:57b8927:     };
1:b0a38ff: 
1:b0a38ff:     private MessageConsumer createDlqConsumer(Connection connection) throws Exception {
1:b0a38ff:         return connection.createSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(dlqDestination);
1:461af7c:     }
1:b0a38ff: 
1:a1bd85e:     public void initCombosForTestRecoverExpiredMessages() {
1:b0a38ff:         addCombinationValues("useVMCursor", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:b0a38ff:     }
1:b0a38ff: 
1:687badb:     private BrokerService createBroker(boolean deleteAllMessages, boolean usePrefetchExtension, long expireMessagesPeriod, ActiveMQDestination destination) throws Exception {
1:b0a38ff:         BrokerService broker = new BrokerService();
1:461af7c:         broker.setBrokerName("localhost");
1:98a0f39:         broker.setDestinations(new ActiveMQDestination[]{destination});
1:570dbb4:         broker.setPersistenceAdapter(new MemoryPersistenceAdapter());
1:b0a38ff: 
1:dbe847e:         PolicyEntry defaultPolicy = new PolicyEntry();
1:dbe847e:         if (useVMCursor) {
1:dbe847e:             defaultPolicy.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
1:461af7c:         }
1:dbe847e:         defaultPolicy.setExpireMessagesPeriod(expireMessagesPeriod);
1:ca242f4:         defaultPolicy.setMaxExpirePageSize(1200);
1:687badb:         defaultPolicy.setUsePrefetchExtension(usePrefetchExtension);
1:dbe847e:         PolicyMap policyMap = new PolicyMap();
1:dbe847e:         policyMap.setDefaultEntry(defaultPolicy);
1:dbe847e:         broker.setDestinationPolicy(policyMap);
1:dbe847e:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:b0a38ff:         broker.addConnector("tcp://localhost:0");
1:461af7c:         broker.start();
1:461af7c:         broker.waitUntilStarted();
1:dbe847e:         return broker;
1:b0a38ff:     }
1:b0a38ff: 
1:461af7c: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:cdb38b3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerPluginSupport;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.MessageReference;
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testReceiveTimeoutRespectedWithExpiryProcessing() throws Exception {
1:         final ActiveMQDestination destination = new ActiveMQQueue("test");
1:         broker = new BrokerService();
1:         broker.setBrokerName("localhost");
1:         broker.setDestinations(new ActiveMQDestination[]{destination});
1:         broker.setPersistenceAdapter(new MemoryPersistenceAdapter());
1: 
1:         PolicyEntry defaultPolicy = new PolicyEntry();
1:         defaultPolicy.setExpireMessagesPeriod(1000);
1:         defaultPolicy.setMaxExpirePageSize(2000);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setDefaultEntry(defaultPolicy);
1:         broker.setDestinationPolicy(policyMap);
1:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:         broker.addConnector("tcp://localhost:0");
1:         broker.setPlugins(new BrokerPlugin[] { new BrokerPluginSupport() {
1:             @Override
1:             public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference messageReference, Subscription subscription, Throwable poisonCause) {
1:                 try {
1:                     LOG.info("Sleeping before delegation on sendToDeadLetterQueue");
1:                     TimeUnit.SECONDS.sleep(1);
1:                 } catch (Exception ignored) {}
1:                 return super.sendToDeadLetterQueue(context, messageReference, subscription, poisonCause);
1:             }
1:         }});
1:         broker.start();
1:         broker.waitUntilStarted();
1: 
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:                 "vm://localhost");
1:         ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:         prefetchPolicy.setAll(0);
1:         factory.setPrefetchPolicy(prefetchPolicy);
1:         connection = factory.createConnection();
1:         connection.start();
1:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         producer.setTimeToLive(1000);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         for (int i=0;i<10; i++) {
1:             producer.send(session.createTextMessage("RTR"), DeliveryMode.PERSISTENT, 0, 2000);
1:         }
1: 
1:         consumer = session.createConsumer(new ActiveMQQueue("another-test"));
1: 
1:         for (int i=0; i<10; i++) {
1:             long timeStamp = System.currentTimeMillis();
1:             consumer.receive(1000);
1:             long duration = System.currentTimeMillis() - timeStamp;
1:             LOG.info("Duration: " + i + " : " + duration);
1:             assertTrue("Delay about 500: " + i + ", actual: " + duration, duration < 1500);
1:         }
1:     }
1: 
1: 
commit:41a1007
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
/////////////////////////////////////////////////////////////////////////
1:     public void testClientAckInflight_onTopic_withPrefetchExtension() throws Exception {
1:         doTestClientAckInflight_onTopic_checkPrefetchExtension();
1:     }
1:     public void testClientAckInflight_onTopic_withOutPrefetchExtension() throws Exception {
1:         usePrefetchExtension = false;
1:         doTestClientAckInflight_onTopic_checkPrefetchExtension();
1:     }
1: 
1:     public void doTestClientAckInflight_onTopic_checkPrefetchExtension() throws Exception {
1:         final ActiveMQDestination destination = new ActiveMQTopic("test");
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:                 "failover://"+brokerUri);
1:         ActiveMQPrefetchPolicy prefetchTwo = new ActiveMQPrefetchPolicy();
1:         prefetchTwo.setAll(6);
1:         factory.setPrefetchPolicy(prefetchTwo);
1:         connection = factory.createConnection();
1:         connection.start();
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         produce(10, destination);
1: 
1:         Message m = null;
1:         for (int i=0; i<5; i++) {
1:             m = consumer.receive(4000);
1:         }
1:         assertNotNull(m);
1:                 subscriptions.stream().
1:                         filter(s -> s instanceof TopicSubscription).
1:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
1:                         allMatch(e -> usePrefetchExtension ? e > 1 : e == 0));
1:         m.acknowledge();
1:         assertTrue("prefetch extension was not incremented",
1: 
1:     private void produce(int num, ActiveMQDestination destination) throws Exception {
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:                 "failover://"+brokerUri);
1:         Connection connection = factory.createConnection();
1:         connection.start();
1:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:         int i = 0;
1:         while (i++ < num) {
1:             Message message = useTextMessage ? session
1:                     .createTextMessage("test") : session
1:                     .createObjectMessage("test");
1:             producer.send(message);
1:         }
1:         connection.close();
1:     }
1: 
1: 
commit:6cc2c11
/////////////////////////////////////////////////////////////////////////
commit:26807cd
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("memory usage is increased ", 0 < getDestination(broker, dlqDestination).getMemoryUsage().getUsage());
author:Vasco Veloso
-------------------------------------------------------------------------------
commit:687badb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.broker.region.TopicSubscription;
1: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import static org.apache.activemq.TestSupport.getDestinationConsumers;
/////////////////////////////////////////////////////////////////////////
1:     private ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
1:     private boolean useTextMessage = true;
1:     private boolean useVMCursor = true;
1:     private boolean deleteAllMessages = true;
1:     private boolean usePrefetchExtension = true;
1:     private String brokerUri;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (null != producer) {
1:             producer.close();
1:         }
1:         if (null != consumer) {
1:             consumer.close();
1:         }
1:         session.close();
1:         final ActiveMQDestination destination = new ActiveMQQueue("test");
1:         final int numMessagesToSend = 10000;
1:         buildBroker(destination);
1: 
1:         final DestinationStatistics view = verifyMessageExpirationOnDestination(destination, numMessagesToSend);
1: 
1:         verifyDestinationDlq(destination, numMessagesToSend, view);
1:     }
1: 
0:     public void testExpiredMessages_onTopic_withPrefetchExtension() throws Exception {
0:         final ActiveMQDestination destination = new ActiveMQTopic("test");
1:         final int numMessagesToSend = 10000;
1: 
1:         usePrefetchExtension = true;
1: 
1:         buildBroker(destination);
1: 
0:         verifyMessageExpirationOnDestination(destination, numMessagesToSend);
0:         // We don't check the DLQ because non-persistent messages on topics are discarded instead.
1: 
1:         final List<Subscription> subscriptions = getDestinationConsumers(broker, destination);
1: 
1:         assertTrue("prefetch extension was not incremented",
1:             subscriptions.stream().
1:                 filter(s -> s instanceof TopicSubscription).
1:                 mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
0:                 allMatch(e -> e > 0));
1:     }
1: 
0:     public void testExpiredMessages_onTopic_withoutPrefetchExtension() throws Exception {
0:         final ActiveMQDestination destination = new ActiveMQTopic("test");
1:         final int numMessagesToSend = 10000;
1: 
0:         usePrefetchExtension = false;
1: 
1:         buildBroker(destination);
1: 
0:         verifyMessageExpirationOnDestination(destination, numMessagesToSend);
0:         // We don't check the DLQ because non-persistent messages on topics are discarded instead.
1: 
1:         final List<Subscription> subscriptions = getDestinationConsumers(broker, destination);
1: 
0:         assertTrue("prefetch extension was incremented",
1:                 subscriptions.stream().
1:                         filter(s -> s instanceof TopicSubscription).
1:                         mapToInt(s -> ((TopicSubscription)s).getPrefetchExtension().get()).
1:                         allMatch(e -> e == 0));
1:     }
1: 
1:     private void buildBroker(ActiveMQDestination destination) throws Exception {
1:         broker = createBroker(deleteAllMessages, usePrefetchExtension, 100, destination);
1:         brokerUri = broker.getTransportConnectors().get(0).getPublishableConnectString();
1:     }
1: 
1:     public void testRecoverExpiredMessages() throws Exception {
1:         final ActiveMQDestination destination = new ActiveMQQueue("test");
1: 
1:         buildBroker(destination);
1: 
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:                 "failover://"+brokerUri);
1:         connection = factory.createConnection();
1:         connection.start();
1:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         producer.setTimeToLive(2000);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1: 
1:         Thread producingThread = new Thread("Producing Thread") {
1:             @Override
1:             public void run() {
1:                 try {
1:                     int i = 0;
1:                     while (i++ < 1000) {
1:                         Message message = useTextMessage ? session
1:                                 .createTextMessage("test") : session
1:                                 .createObjectMessage("test");
1:                         producer.send(message);
1:                     }
1:                 } catch (Throwable ex) {
1:                     ex.printStackTrace();
1:                 }
1:             }
1:         };
1: 
1:         producingThread.start();
1:         producingThread.join();
1: 
1:         DestinationStatistics view = getDestinationStatistics(broker, destination);
1:         LOG.info("Stats: size: " + view.getMessages().getCount() + ", enqueues: "
1:                 + view.getEnqueues().getCount() + ", dequeues: "
1:                 + view.getDequeues().getCount() + ", dispatched: "
1:                 + view.getDispatched().getCount() + ", inflight: "
1:                 + view.getInflight().getCount() + ", expiries: "
1:                 + view.getExpired().getCount());
1: 
1:         LOG.info("stopping broker");
1:         broker.stop();
1:         broker.waitUntilStopped();
1: 
1:         Thread.sleep(5000);
1: 
1:         LOG.info("recovering broker");
1:         final boolean deleteAllMessages = false;
1:         final boolean usePrefetchExtension = true;
1:         broker = createBroker(deleteAllMessages, usePrefetchExtension, 5000, destination);
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 DestinationStatistics view = getDestinationStatistics(broker, destination);
1:                 LOG.info("Stats: size: " + view.getMessages().getCount() + ", enqueues: "
1:                         + view.getEnqueues().getCount() + ", dequeues: "
1:                         + view.getDequeues().getCount() + ", dispatched: "
1:                         + view.getDispatched().getCount() + ", inflight: "
1:                         + view.getInflight().getCount() + ", expiries: "
1:                         + view.getExpired().getCount());
1: 
1:                 return view.getMessages().getCount() == 0;
1:             }
1:         });
1: 
1:         view = getDestinationStatistics(broker, destination);
1:         assertEquals("Expect empty queue, QueueSize: ", 0, view.getMessages().getCount());
1:         assertEquals("all dequeues were expired", view.getDequeues().getCount(), view.getExpired().getCount());
1:     }
1: 
1:     private DestinationStatistics verifyMessageExpirationOnDestination(ActiveMQDestination destination, final int numMessagesToSend) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return view;
1:     }
1:     private void verifyDestinationDlq(ActiveMQDestination destination, int numMessagesToSend, DestinationStatistics view) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     private BrokerService createBroker(boolean deleteAllMessages, boolean usePrefetchExtension, long expireMessagesPeriod, ActiveMQDestination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         defaultPolicy.setUsePrefetchExtension(usePrefetchExtension);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:570dbb4
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected void tearDown() throws Exception {
1:         connection.stop();
1:         broker.stop();
1:         broker.waitUntilStopped();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         broker.setPersistenceAdapter(new MemoryPersistenceAdapter());
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b2fca26
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.leveldb.LevelDBStore;
1: import javax.jms.*;
0: import java.io.File;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import static org.apache.activemq.TestSupport.getDestination;
1: import static org.apache.activemq.TestSupport.getDestinationStatistics;
1: 
/////////////////////////////////////////////////////////////////////////
0:         LevelDBStore adaptor = new LevelDBStore();
commit:bfbe90b
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.activemq.TestSupport.getDestination;
0: import static org.apache.activemq.TestSupport.getDestinationStatistics;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:ef24cc9
commit:b0a38ff
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected String brokerUri;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void setUp() throws Exception {
0:         brokerUri = broker.getTransportConnectors().get(0).getPublishableConnectString();
1: 
1:     public void testExpiredMessages() throws Exception {
1: 
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(brokerUri);
1:         connection = factory.createConnection();
1:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(destination);
1:         producer.setTimeToLive(100);
1:         consumer = session.createConsumer(destination);
1:         connection.start();
1:         final AtomicLong received = new AtomicLong();
1: 
1:         Thread consumerThread = new Thread("Consumer Thread") {
1:                 long start = System.currentTimeMillis();
1:                     long end = System.currentTimeMillis();
1:                     while (end - start < 3000) {
1:                         if (consumer.receive(1000) != null) {
1:                             received.incrementAndGet();
1:                         }
1:                         Thread.sleep(100);
1:                         end = System.currentTimeMillis();
1:                     }
0:                     consumer.close();
1:         };
1: 
1:         consumerThread.start();
1: 
0:         final int numMessagesToSend = 10000;
1:         Thread producingThread = new Thread("Producing Thread") {
1:             public void run() {
1:                 try {
1:                     int i = 0;
1:                     while (i++ < numMessagesToSend) {
1:                         producer.send(session.createTextMessage("test"));
1:                     }
0:                     producer.close();
1:                 } catch (Throwable ex) {
1:                     ex.printStackTrace();
1:                 }
1:             }
1:         };
1: 
1:         producingThread.start();
1: 
1: 
1:             }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
0:         assertTrue("memory usage is increased ", 0 < getDestination(broker, dlqDestination).getMemoryUsage().getPercentUsage());
1: 
1: 
1: 
1:     }
1: 
1: 
1: 
1: 
1:     private MessageConsumer createDlqConsumer(Connection connection) throws Exception {
1:         return connection.createSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(dlqDestination);
1:         addCombinationValues("useVMCursor", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:     }
1: 
0:     public void testRecoverExpiredMessages() throws Exception {
0:                 "failover://"+brokerUri);
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("Stats: size: " + view.getMessages().getCount() + ", enqueues: "
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:     private BrokerService createBroker(boolean deleteAllMessages, long expireMessagesPeriod) throws Exception {
1:         BrokerService broker = new BrokerService();
1: 
/////////////////////////////////////////////////////////////////////////
1:         broker.addConnector("tcp://localhost:0");
1:     }
0: 
0: 
0:     protected void tearDown() throws Exception {
0:         connection.stop();
0:         broker.stop();
0:         broker.waitUntilStopped();
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ExpiredMessagesTest.class);
commit:57b8927
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.util.concurrent.atomic.AtomicLong;
0: 
0: import javax.jms.Connection;
0: import javax.jms.DeliveryMode;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.management.InstanceNotFoundException;
0: import javax.management.ObjectName;
0: 
1: import junit.framework.Test;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // verify DLQ
1:         final DLQListener dlqListener = new DLQListener();
1:         dlqConsumer.setMessageListener(dlqListener);
0:         
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return totalExpiredCount == dlqListener.count;
1:             }
1:         }, 60 * 1000);
0:         
1:         assertEquals("dlq returned all expired", dlqListener.count, totalExpiredCount);
1:     class DLQListener implements MessageListener {
0:         
1:         int count = 0;
0:         
1:         public void onMessage(Message message) {
1:             count++;
1:         }
0:         
1:     };
0:     
/////////////////////////////////////////////////////////////////////////
0:         adaptor.setDirectory(new File("target/expiredtest-data/"));
commit:461af7c
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
0: 
0: import javax.jms.Connection;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.management.MBeanServer;
0: import javax.management.MBeanServerInvocationHandler;
0: import javax.management.ObjectName;
0: 
0: import junit.framework.Test;
0: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.CombinationTestSupport;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTopic;
0: 
0: 
0: 
1: public class ExpiredMessagesTest extends CombinationTestSupport {
0: 
1: 	BrokerService broker;
1: 	Connection connection;
1: 	Session session;
1: 	MessageProducer producer;
1: 	MessageConsumer consumer;
0: 	public ActiveMQDestination destination;
0: 	
1:     public static Test suite() {
1:         return suite(ExpiredMessagesTest.class);
1:     }
0: 
1:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
0: 	
0: 	protected void setUp() throws Exception {
0: 		broker = new BrokerService();
1: 		broker.setBrokerName("localhost");
0: 		broker.setDataDirectory("data/");
0: 		broker.setUseJmx(true);
0: 		broker.deleteAllMessages();
0: 		broker.addConnector("tcp://localhost:61616");
1: 		broker.start();
1: 		broker.waitUntilStarted();
1: 	}
0: 	
0:     public void initCombosForTestExpiredMessages() {
0:         addCombinationValues("destination", new Object[] {new ActiveMQQueue("test"), new ActiveMQTopic("test")});
1:     }
0: 	
0: 	public void testExpiredMessages() throws Exception {
0: 		
0: 		ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
0: 		connection = factory.createConnection();
0: 		session = connection.createSession(false, session.AUTO_ACKNOWLEDGE);
0: 		producer = session.createProducer(destination);
0: 		producer.setTimeToLive(100);
0: 		consumer = session.createConsumer(destination);
0: 		connection.start();
0: 		
0: 		Thread consumerThread = new Thread("Consumer Thread") {
1: 			public void run() {
0: 				long start = System.currentTimeMillis();
1: 				try {
0: 					long end = System.currentTimeMillis();
0: 					while (end - start < 3000) {
0: 						consumer.receive(1000);
0: 						Thread.sleep(100);
0: 						end = System.currentTimeMillis();
1: 					}
1: 				} catch (Throwable ex) {
1: 					ex.printStackTrace();
1: 				}
1: 			}
0: 		};
0: 		
0:         consumerThread.start();
0: 		
0: 		
0: 		Thread producingThread = new Thread("Producing Thread") {
1:             public void run() {
1:                 try {
0:                 	int i = 0;
0:                 	while (i++ < 30000) {
0:                 		producer.send(session.createTextMessage("test"));
1:                 	}
1:                 } catch (Throwable ex) {
1:                     ex.printStackTrace();
1:                 }
1:             }
0: 		};
0: 		
0: 		producingThread.start();
0: 		
1:         consumerThread.join();
1:         producingThread.join();
0:         
0:         DestinationViewMBean view = createView(destination);
0:         
0:         assertTrue("Wrong inFlightCount: " + view.getInFlightCount(), (view.getDispatchCount() - view.getDequeueCount()) - view.getInFlightCount() < 5);
1: 	}
0: 	
0: 	protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
0: 		 MBeanServer mbeanServer = broker.getManagementContext().getMBeanServer();
0: 		 String domain = "org.apache.activemq";
0: 		 ObjectName name;
0: 		if (destination.isQueue()) {
0: 			name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination=test");
0: 		} else {
0: 			name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination=test");
1: 		}
0: 		return (DestinationViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, name, DestinationViewMBean.class, true);
1: 	}
0: 
0: 	protected void tearDown() throws Exception {
0: 		connection.stop();
0: 		broker.stop();
0: 		broker.waitUntilStopped();
1: 	}
0: 
0: 	
0: 
0: 	
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.activemq.TestSupport.getDestination;
0: import static org.apache.activemq.TestSupport.getDestinationStatistics;
0: 
/////////////////////////////////////////////////////////////////////////
1:         final DestinationStatistics view = getDestinationStatistics(broker, destination);
/////////////////////////////////////////////////////////////////////////
1:         final DestinationStatistics dlqView = getDestinationStatistics(broker, dlqDestination);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("memory usage is back to duck egg", 0, getDestination(broker, destination).getMemoryUsage().getPercentUsage());
0:         assertTrue("memory usage is increased ", 0 < getDestination(broker, dlqDestination).getMemoryUsage().getPercentUsage());    
/////////////////////////////////////////////////////////////////////////
0:         DestinationStatistics view = getDestinationStatistics(broker, destination);
/////////////////////////////////////////////////////////////////////////
0:                 DestinationStatistics view = getDestinationStatistics(broker, destination);
/////////////////////////////////////////////////////////////////////////
0:         view = getDestinationStatistics(broker, destination);
/////////////////////////////////////////////////////////////////////////
commit:59653a5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.DestinationStatistics;
0: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
0:         final DestinationStatistics view = this.getDestinationStatistics(destination);
0: 
1:                 return view.getInflight().getCount() == 0;
1:         assertEquals("Wrong inFlightCount: ", 0, view.getInflight().getCount());
1:         LOG.info("Stats: received: "  + received.get() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:                 + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:                 long oldEnqueues = view.getEnqueues().getCount();
1:                 LOG.info("Stats: received: "  + received.get() + ", size= " + view.getMessages().getCount() + ", enqueues: " + view.getDequeues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:                         + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:                 return oldEnqueues == view.getEnqueues().getCount();
1:         LOG.info("Stats: received: "  + received.get() + ", size= " + view.getMessages().getCount() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:                 + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:         assertTrue("got at least what did not expire", received.get() >= view.getDequeues().getCount() - view.getExpired().getCount());
1:         assertTrue("all messages expired - queue size gone to zero " + view.getMessages().getCount(), Wait.waitFor(new Wait.Condition() {
1:                 LOG.info("Stats: received: "  + received.get() + ", size= " + view.getMessages().getCount() + ", enqueues: " + view.getEnqueues().getCount() + ", dequeues: " + view.getDequeues().getCount()
1:                         + ", dispatched: " + view.getDispatched().getCount() + ", inflight: " + view.getInflight().getCount() + ", expiries: " + view.getExpired().getCount());
1:                 return view.getMessages().getCount() == 0;
1:         final long expiredBeforeEnqueue = numMessagesToSend - view.getEnqueues().getCount();
1:         final long totalExpiredCount = view.getExpired().getCount() + expiredBeforeEnqueue;
0:         final DestinationStatistics dlqView = getDestinationStatistics(dlqDestination);
1:         LOG.info("DLQ stats: size= " + dlqView.getMessages().getCount() + ", enqueues: " + dlqView.getDequeues().getCount() + ", dequeues: " + dlqView.getDequeues().getCount()
1:                 + ", dispatched: " + dlqView.getDispatched().getCount() + ", inflight: " + dlqView.getInflight().getCount() + ", expiries: " + dlqView.getExpired().getCount());
1:                 return totalExpiredCount == dlqView.getMessages().getCount();
1:         assertEquals("dlq contains all expired", totalExpiredCount, dlqView.getMessages().getCount());
0:         assertEquals("memory usage is back to duck egg", 0, this.getDestination(destination).getMemoryUsage().getPercentUsage());
0:         assertTrue("memory usage is increased ", 0 < this.getDestination(dlqDestination).getMemoryUsage().getPercentUsage());    
/////////////////////////////////////////////////////////////////////////
0:         DestinationStatistics view = getDestinationStatistics(destination);
0:         LOG.info("Stats: size: " + view.getMessages().getCount() + ", enqueues: " 
0:                 + view.getEnqueues().getCount() + ", dequeues: "
0:                 + view.getDequeues().getCount() + ", dispatched: "
0:                 + view.getDispatched().getCount() + ", inflight: "
0:                 + view.getInflight().getCount() + ", expiries: "
0:                 + view.getExpired().getCount());
/////////////////////////////////////////////////////////////////////////
0:                 DestinationStatistics view = getDestinationStatistics(destination);
0:                 LOG.info("Stats: size: " + view.getMessages().getCount() + ", enqueues: "
0:                         + view.getEnqueues().getCount() + ", dequeues: "
0:                         + view.getDequeues().getCount() + ", dispatched: "
0:                         + view.getDispatched().getCount() + ", inflight: "
0:                         + view.getInflight().getCount() + ", expiries: "
0:                         + view.getExpired().getCount());
0:                     
0:                 return view.getMessages().getCount() == 0;
0:         view = getDestinationStatistics(destination);
0:         assertEquals("Expect empty queue, QueueSize: ", 0, view.getMessages().getCount());
0:         assertEquals("all dequeues were expired", view.getDequeues().getCount(), view.getExpired().getCount());
/////////////////////////////////////////////////////////////////////////
0: 	}
0:     
0:     private DestinationStatistics getDestinationStatistics(ActiveMQDestination destination) {
0:         DestinationStatistics result = null;
0:         org.apache.activemq.broker.region.Destination dest = getDestination(destination);
0:         if (dest != null) {
0:             result = dest.getDestinationStatistics();
0:         return result;
0:     }
0:     
0:     private org.apache.activemq.broker.region.Destination getDestination(ActiveMQDestination destination) {
0:         org.apache.activemq.broker.region.Destination result = null;
0:         RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
0:         for (org.apache.activemq.broker.region.Destination dest : regionBroker.getQueueRegion().getDestinationMap().values()) {
0:             if (dest.getName().equals(destination.getPhysicalName())) {
0:                 result = dest;
0:                 break;
0:             }
0:         }
0:         return result;
commit:7b700ee
/////////////////////////////////////////////////////////////////////////
0:             }        
/////////////////////////////////////////////////////////////////////////
0:         final DestinationViewMBean view = (DestinationViewMBean) 
0:             broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
0:         
0:         assertTrue("validation: Mbean view for " + destination + " exists", Wait.waitFor(new Wait.Condition() {            
1:             public boolean isSatisified() throws Exception {
0:                 boolean mbeanExists = false;
0:                 try {
0:                     view.getConsumerCount();
0:                     mbeanExists = true;
0:                 } catch (Exception notFoundExpectedOnSlowMachines) {
0:                 }
0:                 return mbeanExists;
0:             }   
1:         }));
0:         return view;
commit:98a0f39
/////////////////////////////////////////////////////////////////////////
1:         broker.setDestinations(new ActiveMQDestination[]{destination});
commit:b85b71e
/////////////////////////////////////////////////////////////////////////
0:                 } catch (Exception notFoundExpectedOnSlowMachines) {
commit:2a238f7
/////////////////////////////////////////////////////////////////////////
0: import javax.management.InstanceNotFoundException;
/////////////////////////////////////////////////////////////////////////
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 boolean result = false;
0:                 try {
0:                     DestinationViewMBean view = createView(destination);
0:                     LOG.info("Stats: size: " + view.getQueueSize() + ", enqueues: "
0:                             + view.getDequeueCount() + ", dequeues: "
0:                             + view.getDequeueCount() + ", dispatched: "
0:                             + view.getDispatchCount() + ", inflight: "
0:                             + view.getInFlightCount() + ", expiries: "
0:                             + view.getExpiredCount());
0:                     result = view.getQueueSize() == 0;
0:                 } catch (InstanceNotFoundException expectedOnSlowMachines) {
0:                 }
0:                 return result;
0:             }
1:         });
0:         
0:         view = createView(destination);
0:         assertEquals("Expect empty queue, QueueSize: ", 0, view.getQueueSize());
commit:ce18ec8
/////////////////////////////////////////////////////////////////////////
1:         // memory check
0:         assertEquals("memory usage is back to duck egg", 0, view.getMemoryPercentUsage());
0:         assertTrue("memory usage is increased ", 0 < dlqView.getMemoryPercentUsage());    
0:         
commit:3536b1e
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Stats: received: "  + received.get() + ", size= " + view.getQueueSize() + ", enqueues: " + view.getDequeueCount() + ", dequeues: " + view.getDequeueCount()
0:                         + ", dispatched: " + view.getDispatchCount() + ", inflight: " + view.getInFlightCount() + ", expiries: " + view.getExpiredCount());
/////////////////////////////////////////////////////////////////////////
0: 	
commit:a1bd85e
/////////////////////////////////////////////////////////////////////////
0:     BrokerService broker;
0:     Connection connection;
0:     Session session;
0:     MessageProducer producer;
0:     MessageConsumer consumer;
0:     public ActiveMQDestination destination = new ActiveMQQueue("test");
0:     public ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
/////////////////////////////////////////////////////////////////////////
0: 		final int numMessagesToSend = 10000;
0:                 	while (i++ < numMessagesToSend) {
/////////////////////////////////////////////////////////////////////////
0:         
0:         final long expiredBeforeEnqueue = numMessagesToSend - view.getEnqueueCount();
0:         final long totalExpiredCount = view.getExpiredCount() + expiredBeforeEnqueue;
0:         
0:         final DestinationViewMBean dlqView = createView(dlqDestination);
0:         LOG.info("DLQ stats: size= " + dlqView.getQueueSize() + ", enqueues: " + dlqView.getDequeueCount() + ", dequeues: " + dlqView.getDequeueCount()
0:                 + ", dispatched: " + dlqView.getDispatchCount() + ", inflight: " + dlqView.getInFlightCount() + ", expiries: " + dlqView.getExpiredCount());
0:         
0:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return totalExpiredCount == dlqView.getQueueSize();
0:             }
0:         });
0:         assertEquals("dlq contains all expired", totalExpiredCount, dlqView.getQueueSize());
0:         
0:         // verify DQL
1:         MessageConsumer dlqConsumer = createDlqConsumer(connection);
0:         int count = 0;
0:         while (dlqConsumer.receive(4000) != null) {
0:             count++;
0:         }
0:         assertEquals("dlq returned all expired", count, totalExpiredCount);
0: 	private MessageConsumer createDlqConsumer(Connection connection) throws Exception {
0: 	    return connection.createSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(dlqDestination);
0:     }
0: 
1:     public void initCombosForTestRecoverExpiredMessages() {
/////////////////////////////////////////////////////////////////////////
0: 			name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination=" + destination.getPhysicalName());
0: 			name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination=" + destination.getPhysicalName());
commit:ca242f4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
0:                 	while (i++ < 10000) {
/////////////////////////////////////////////////////////////////////////
0:         final DestinationViewMBean view = createView(destination);
1:         // wait for all to inflight to expire
1:         assertTrue("all inflight messages expired ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return view.getInFlightCount() == 0;
0:             }           
1:         }));
0:         
0:         LOG.info("Stats: received: "  + received.get() + ", enqueues: " + view.getDequeueCount() + ", dequeues: " + view.getDequeueCount()
0:                 + ", dispatched: " + view.getDispatchCount() + ", inflight: " + view.getInFlightCount() + ", expiries: " + view.getExpiredCount());
0:         
1:         // wait for all sent to get delivered and expire
1:         assertTrue("all sent messages expired ", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 long oldEnqueues = view.getEnqueueCount();
1:                 Thread.sleep(200);
0:                 LOG.info("Stats: received: "  + received.get() + ", size= " + view.getQueueSize() + ", enqueues: " + view.getDequeueCount() + ", dequeues: " + view.getDequeueCount()
0:                         + ", dispatched: " + view.getDispatchCount() + ", inflight: " + view.getInFlightCount() + ", expiries: " + view.getExpiredCount());
0:                 return oldEnqueues == view.getEnqueueCount();
0:             }           
1:         }, 60*1000));
0:         
0: 
0:         LOG.info("Stats: received: "  + received.get() + ", size= " + view.getQueueSize() + ", enqueues: " + view.getDequeueCount() + ", dequeues: " + view.getDequeueCount()
0:                 + ", dispatched: " + view.getDispatchCount() + ", inflight: " + view.getInFlightCount() + ", expiries: " + view.getExpiredCount());
0:         
0:         assertTrue("got at least what did not expire", received.get() >= view.getDequeueCount() - view.getExpiredCount());
0:         
0:         assertTrue("all messages expired - queue size gone to zero " + view.getQueueSize(), Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
0:                 return view.getQueueSize() == 0;
0:             }
1:         }));
/////////////////////////////////////////////////////////////////////////
1:         defaultPolicy.setMaxExpirePageSize(1200);
commit:dbe847e
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import javax.jms.DeliveryMode;
0: import javax.jms.Message;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0:     public boolean useTextMessage = true;
0:     public boolean useVMCursor = true;
0:     
/////////////////////////////////////////////////////////////////////////
0:         final boolean deleteAllMessages = true;
0:         broker = createBroker(deleteAllMessages, 100);
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(2000);
0:                 
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public void initCombosForTestRecoverExpiredMessages() {
0: 	    addCombinationValues("useVMCursor", new Object[] {Boolean.TRUE, Boolean.FALSE});
0: 	}
0: 	
0: 	public void testRecoverExpiredMessages() throws Exception {
0: 
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
0:                 "failover://tcp://localhost:61616");
0:         connection = factory.createConnection();
0:         connection.start();
0:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         producer = session.createProducer(destination);
0:         producer.setTimeToLive(2000);
0:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
0: 
0:         Thread producingThread = new Thread("Producing Thread") {
0:             public void run() {
0:                 try {
0:                     int i = 0;
0:                     while (i++ < 1000) {
0:                         Message message = useTextMessage ? session
0:                                 .createTextMessage("test") : session
0:                                 .createObjectMessage("test");
0:                         producer.send(message);
0:                     }
0:                     producer.close();
0:                 } catch (Throwable ex) {
0:                     ex.printStackTrace();
0:                 }
0:             }
0:         };
0: 
0:         producingThread.start();
0:         producingThread.join();
0: 
0:         DestinationViewMBean view = createView(destination);
0:         LOG.info("Stats: size: " + view.getQueueSize() + ", enqueues: "
0:                 + view.getDequeueCount() + ", dequeues: "
0:                 + view.getDequeueCount() + ", dispatched: "
0:                 + view.getDispatchCount() + ", inflight: "
0:                 + view.getInFlightCount() + ", expiries: "
0:                 + view.getExpiredCount());
0: 
0:         LOG.info("stopping broker");
0:         broker.stop();
0:         broker.waitUntilStopped();
0: 
0:         Thread.sleep(5000);
0: 
0:         LOG.info("recovering broker");
0:         final boolean deleteAllMessages = false;
0:         broker = createBroker(deleteAllMessages, 5000);
0:         
0:         view = createView(destination);
0:         LOG.info("Stats: size: " + view.getQueueSize() + ", enqueues: "
0:                 + view.getDequeueCount() + ", dequeues: "
0:                 + view.getDequeueCount() + ", dispatched: "
0:                 + view.getDispatchCount() + ", inflight: "
0:                 + view.getInFlightCount() + ", expiries: "
0:                 + view.getExpiredCount());
0: 
0:         long expiry = System.currentTimeMillis() + 30000;
0:         while (view.getQueueSize() > 0 && System.currentTimeMillis() < expiry) {
0:             Thread.sleep(500);
0:         }
0:         LOG.info("Stats: size: " + view.getQueueSize() + ", enqueues: "
0:                 + view.getDequeueCount() + ", dequeues: "
0:                 + view.getDequeueCount() + ", dispatched: "
0:                 + view.getDispatchCount() + ", inflight: "
0:                 + view.getInFlightCount() + ", expiries: "
0:                 + view.getExpiredCount());
0:         assertEquals("Wrong QueueSize: ", 0, view.getQueueSize());
0:         assertEquals("all dequeues were expired", view.getDequeueCount(), view.getExpiredCount());
0:     }
0: 
0: 	private BrokerService createBroker(boolean deleteAllMessages, long expireMessagesPeriod) throws Exception {
0: 	    BrokerService broker = new BrokerService();
0:         broker.setBrokerName("localhost");
0:         AMQPersistenceAdapter adaptor = new AMQPersistenceAdapter();
0:         adaptor.setDirectory(new File("data/"));
0:         adaptor.setForceRecoverReferenceStore(true);
0:         broker.setPersistenceAdapter(adaptor);
0:         
1:         PolicyEntry defaultPolicy = new PolicyEntry();
1:         if (useVMCursor) {
1:             defaultPolicy.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
0:         }
1:         defaultPolicy.setExpireMessagesPeriod(expireMessagesPeriod);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setDefaultEntry(defaultPolicy);
1:         broker.setDestinationPolicy(policyMap);
1:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
0:         broker.addConnector("tcp://localhost:61616");
0:         broker.start();
0:         broker.waitUntilStarted();
1:         return broker;
0:     }
0: 
0:     protected DestinationViewMBean createView(ActiveMQDestination destination) throws Exception {
commit:7a59d28
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
0:         broker = new BrokerService();
0:         broker.setBrokerName("localhost");
0:         broker.setDataDirectory("data/");
0:         broker.setUseJmx(true);
0:         broker.deleteAllMessages();
0: 
0:         PolicyEntry defaultPolicy = new PolicyEntry();
0:         defaultPolicy.setExpireMessagesPeriod(100);
0:         PolicyMap policyMap = new PolicyMap();
0:         policyMap.setDefaultEntry(defaultPolicy);
0:         broker.setDestinationPolicy(policyMap);
0: 
0:         broker.addConnector("tcp://localhost:61616");
0:         broker.start();
0:         broker.waitUntilStarted();
0:     }
/////////////////////////////////////////////////////////////////////////
0: 					consumer.close();
/////////////////////////////////////////////////////////////////////////
0:                 	producer.close();
/////////////////////////////////////////////////////////////////////////
0:         session.close();
0:         Thread.sleep(5000);
0:         
0:         long expiry = System.currentTimeMillis() + 30000;
0:         while (view.getInFlightCount() > 0 && System.currentTimeMillis() < expiry) {
0:             Thread.sleep(500);
0:         }
0:         LOG.info("Stats: received: "  + received.get() + ", enqueues: " + view.getDequeueCount() + ", dequeues: " + view.getDequeueCount()
0:                 + ", dispatched: " + view.getDispatchCount() + ", inflight: " + view.getInFlightCount() + ", expiries: " + view.getExpiredCount());
0:         assertEquals("Wrong inFlightCount: ", 0, view.getInFlightCount());
/////////////////////////////////////////////////////////////////////////
commit:c688b78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicLong;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(ExpiredMessagesTest.class);
0:     
0: 	public ActiveMQDestination destination = new ActiveMQQueue("test");
/////////////////////////////////////////////////////////////////////////
0: 		final AtomicLong received = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
0: 						if (consumer.receive(1000) != null) {
0: 						    received.incrementAndGet();
0: 						}
/////////////////////////////////////////////////////////////////////////
0:         DestinationViewMBean view = createView(destination);
0:         LOG.info("Stats: received: "  + received.get() + ", enqueues: " + view.getDequeueCount() + ", dequeues: " + view.getDequeueCount()
0:                 + ", dispatched: " + view.getDispatchCount() + ", inflight: " + view.getInFlightCount() + ", expiries: " + view.getExpiredCount());
0:         
0:         assertEquals("got what did not expire", received.get(), view.getDequeueCount() - view.getExpiredCount());
0:         //assertEquals("Wrong inFlightCount: " + view.getInFlightCount(), view.getDispatchCount() - view.getDequeueCount(), view.getInFlightCount());
commit:a707594
/////////////////////////////////////////////////////////////////////////
0: 		session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("Wrong inFlightCount: " + view.getInFlightCount(), view.getDispatchCount() - view.getDequeueCount(), view.getInFlightCount());
author:Robert Davies
-------------------------------------------------------------------------------
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.util.concurrent.atomic.AtomicLong;
0: import javax.jms.Connection;
0: import javax.jms.DeliveryMode;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.management.ObjectName;
0: import junit.framework.Test;
/////////////////////////////////////////////////////////////////////////
0:         String domain = "org.apache.activemq";
0:         ObjectName name;
0:         if (destination.isQueue()) {
0:             name = new ObjectName(domain + ":BrokerName=localhost,Type=Queue,Destination="
0:                     + destination.getPhysicalName());
0:         } else {
0:             name = new ObjectName(domain + ":BrokerName=localhost,Type=Topic,Destination="
0:                     + destination.getPhysicalName());
0:         }
0:         return (DestinationViewMBean) broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class,
0:                 true);
0:     }
============================================================================