1:a88906f: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:a88906f:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a88906f:  *
1:a88906f:  * Unless required by applicable law or agreed to in writing, software
1:a88906f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a88906f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a88906f:  * See the License for the specific language governing permissions and
1:a88906f:  * limitations under the License.
1:a88906f:  */
1:a88906f: package org.apache.activemq.tool;
1:540dd5c: 
1:b656266: import java.io.BufferedReader;
1:b656266: import java.io.File;
1:b656266: import java.io.FileNotFoundException;
1:b656266: import java.io.FileReader;
1:b656266: import java.io.IOException;
1:540dd5c: import java.util.Arrays;
1:a072126: import java.util.Set;
1:b656266: 
1:540dd5c: import javax.jms.ConnectionFactory;
1:540dd5c: import javax.jms.DeliveryMode;
1:540dd5c: import javax.jms.Destination;
1:540dd5c: import javax.jms.JMSException;
1:540dd5c: import javax.jms.MessageProducer;
1:540dd5c: import javax.jms.TextMessage;
1:a072126: 
1:46bc26c: import org.apache.activemq.command.ActiveMQDestination;
1:a88906f: import org.apache.activemq.tool.properties.JmsClientProperties;
1:540dd5c: import org.apache.activemq.tool.properties.JmsProducerProperties;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:540dd5c: 
1:a88906f: public class JmsProducerClient extends AbstractJmsMeasurableClient {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JmsProducerClient.class);
12:a88906f: 
1:a88906f:     protected JmsProducerProperties client;
1:a88906f:     protected MessageProducer jmsProducer;
1:a88906f:     protected TextMessage jmsTextMessage;
1:a88906f: 
1:a88906f:     public JmsProducerClient(ConnectionFactory factory) {
1:a88906f:         this(new JmsProducerProperties(), factory);
7:a88906f:     }
1:b656266: 
1:a88906f:     public JmsProducerClient(JmsProducerProperties clientProps, ConnectionFactory factory) {
1:a88906f:         super(factory);
1:a88906f:         this.client = clientProps;
1:a88906f:     }
1:576230b: 
1:a88906f:     public void sendMessages() throws JMSException {
1:a88906f:         // Send a specific number of messages
1:a88906f:         if (client.getSendType().equalsIgnoreCase(JmsProducerProperties.COUNT_BASED_SENDING)) {
1:e47e0e0:             long sendCount = client.getSendCount();
1:e47e0e0:             sendCountBasedMessages(sendCount);
1:a88906f:         // Send messages for a specific duration
2:a88906f:         } else {
1:e47e0e0:             long sendDuration = client.getSendDuration();
1:e47e0e0:             sendTimeBasedMessages(sendDuration);
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void sendMessages(int destCount) throws JMSException {
1:a88906f:         this.destCount = destCount;
1:a88906f:         sendMessages();
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void sendMessages(int destIndex, int destCount) throws JMSException {
1:a88906f:         this.destIndex = destIndex;
1:a88906f:         sendMessages(destCount);
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void sendCountBasedMessages(long messageCount) throws JMSException {
1:a88906f:         // Parse through different ways to send messages
1:a88906f:         // Avoided putting the condition inside the loop to prevent effect on performance
1:6dd47bb:         Destination[] dest = createDestinations(destCount);
1:a88906f: 
1:a88906f:         // Create a producer, if none is created.
1:a88906f:         if (getJmsProducer() == null) {
1:a88906f:             if (dest.length == 1) {
1:a88906f:                 createJmsProducer(dest[0]);
1:a88906f:             } else {
1:a88906f:                 createJmsProducer();
1:a88906f:             }
1:a88906f:         }
1:b656266:         try {
1:a88906f:             getConnection().start();
1:b656266:             if (client.getMsgFileName() != null) {
1:e47e0e0:                 LOG.info("Starting to publish " +
1:e47e0e0:                     messageCount +
1:e47e0e0:                     " messages from file " +
1:e47e0e0:                     client.getMsgFileName()
1:e47e0e0:                 );
1:b656266:             } else {
1:e47e0e0:                 LOG.info("Starting to publish " +
1:e47e0e0:                     messageCount +
1:e47e0e0:                     " messages of size " +
1:e47e0e0:                     client.getMessageSize() +
1:e47e0e0:                     " byte(s)."
1:e47e0e0:                 );
1:b656266:             }
1:b656266: 
1:a88906f:             // Send one type of message only, avoiding the creation of different messages on sending
1:a88906f:             if (!client.isCreateNewMsg()) {
1:a88906f:                 // Create only a single message
1:a88906f:                 createJmsTextMessage();
1:a88906f: 
1:a88906f:                 // Send to more than one actual destination
1:a88906f:                 if (dest.length > 1) {
1:a88906f:                     for (int i = 0; i < messageCount; i++) {
1:a88906f:                         for (int j = 0; j < dest.length; j++) {
1:a88906f:                             getJmsProducer().send(dest[j], getJmsTextMessage());
1:a88906f:                             incThroughput();
1:576230b:                             sleep();
1:459be2d:                             commitTxIfNecessary();
1:b656266:                         }
1:a88906f:                     }
1:a88906f:                     // Send to only one actual destination
1:b656266:                 } else {
1:a88906f:                     for (int i = 0; i < messageCount; i++) {
1:a88906f:                         getJmsProducer().send(getJmsTextMessage());
1:a88906f:                         incThroughput();
1:576230b:                         sleep();
1:459be2d:                         commitTxIfNecessary();
1:a88906f:                     }
1:a88906f:                 }
1:a88906f: 
1:a88906f:                 // Send different type of messages using indexing to identify each one.
1:a88906f:                 // Message size will vary. Definitely slower, since messages properties
1:a88906f:                 // will be set individually each send.
1:a88906f:             } else {
1:a88906f:                 // Send to more than one actual destination
1:a88906f:                 if (dest.length > 1) {
1:a88906f:                     for (int i = 0; i < messageCount; i++) {
1:a88906f:                         for (int j = 0; j < dest.length; j++) {
1:a88906f:                             getJmsProducer().send(dest[j], createJmsTextMessage("Text Message [" + i + "]"));
1:a88906f:                             incThroughput();
1:576230b:                             sleep();
1:459be2d:                             commitTxIfNecessary();
1:a88906f:                         }
1:a88906f:                     }
1:a88906f: 
1:a88906f:                     // Send to only one actual destination
1:a88906f:                 } else {
1:a88906f:                     for (int i = 0; i < messageCount; i++) {
1:a88906f:                         getJmsProducer().send(createJmsTextMessage("Text Message [" + i + "]"));
1:a88906f:                         incThroughput();
1:576230b:                         sleep();
1:459be2d:                         commitTxIfNecessary();
1:a88906f:                     }
1:a88906f:                 }
1:a88906f:             }
1:a88906f:         } finally {
1:e47e0e0:             LOG.info("Finished sending");
1:a88906f:             getConnection().close();
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public void sendTimeBasedMessages(long duration) throws JMSException {
1:a88906f:         long endTime = System.currentTimeMillis() + duration;
1:a88906f:         // Parse through different ways to send messages
1:a88906f:         // Avoided putting the condition inside the loop to prevent effect on performance
1:a88906f: 
1:6dd47bb:         Destination[] dest = createDestinations(destCount);
1:a88906f: 
1:a88906f:         // Create a producer, if none is created.
1:a88906f:         if (getJmsProducer() == null) {
1:a88906f:             if (dest.length == 1) {
1:a88906f:                 createJmsProducer(dest[0]);
1:a88906f:             } else {
1:a88906f:                 createJmsProducer();
1:a88906f:             }
1:a88906f:         }
1:a88906f: 
1:576230b:         try {
1:a88906f:             getConnection().start();
1:b656266:             if (client.getMsgFileName() != null) {
1:e47e0e0:                 LOG.info("Starting to publish messages from file " +
1:e47e0e0:                         client.getMsgFileName() +
1:e47e0e0:                         " for " +
1:e47e0e0:                         duration +
1:e47e0e0:                         " ms");
1:b656266:             } else {
1:e47e0e0:                 LOG.info("Starting to publish " +
1:e47e0e0:                         client.getMessageSize() +
1:e47e0e0:                         " byte(s) messages for " +
1:e47e0e0:                         duration +
1:e47e0e0:                         " ms");
1:b656266:             }
1:a88906f:             // Send one type of message only, avoiding the creation of different messages on sending
1:a88906f:             if (!client.isCreateNewMsg()) {
1:a88906f:                 // Create only a single message
1:a88906f:                 createJmsTextMessage();
1:b656266: 
1:a88906f:                 // Send to more than one actual destination
1:a88906f:                 if (dest.length > 1) {
1:5b1412d:                     while (System.currentTimeMillis() - endTime < 0) {
1:a88906f:                         for (int j = 0; j < dest.length; j++) {
1:a88906f:                             getJmsProducer().send(dest[j], getJmsTextMessage());
1:a88906f:                             incThroughput();
1:576230b:                             sleep();
1:459be2d:                             commitTxIfNecessary();
1:b656266:                         }
1:a88906f:                     }
1:a88906f:                     // Send to only one actual destination
1:a88906f:                 } else {
1:5b1412d:                     while (System.currentTimeMillis() - endTime < 0) {
1:a88906f:                         getJmsProducer().send(getJmsTextMessage());
1:a88906f:                         incThroughput();
1:576230b:                         sleep();
1:459be2d:                         commitTxIfNecessary();
1:a88906f:                     }
1:a88906f:                 }
1:a88906f: 
1:a88906f:                 // Send different type of messages using indexing to identify each one.
1:a88906f:                 // Message size will vary. Definitely slower, since messages properties
1:a88906f:                 // will be set individually each send.
1:a88906f:             } else {
1:a88906f:                 // Send to more than one actual destination
1:a88906f:                 long count = 1;
1:a88906f:                 if (dest.length > 1) {
1:5b1412d:                     while (System.currentTimeMillis() - endTime < 0) {
1:a88906f:                         for (int j = 0; j < dest.length; j++) {
1:a88906f:                             getJmsProducer().send(dest[j], createJmsTextMessage("Text Message [" + count++ + "]"));
1:a88906f:                             incThroughput();
1:576230b:                             sleep();
1:459be2d:                             commitTxIfNecessary();
1:a88906f:                         }
1:a88906f:                     }
1:a88906f: 
1:a88906f:                     // Send to only one actual destination
1:a88906f:                 } else {
1:5b1412d:                     while (System.currentTimeMillis() - endTime < 0) {
1:a88906f: 
1:a88906f:                         getJmsProducer().send(createJmsTextMessage("Text Message [" + count++ + "]"));
1:a88906f:                         incThroughput();
1:576230b:                         sleep();
1:459be2d:                         commitTxIfNecessary();
1:a88906f:                     }
1:a88906f:                 }
1:a88906f:             }
1:a88906f:         } finally {
1:e47e0e0:             LOG.info("Finished sending");
1:a88906f:             getConnection().close();
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     public MessageProducer createJmsProducer() throws JMSException {
1:a88906f:         jmsProducer = getSession().createProducer(null);
1:a88906f:         if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {
1:540dd5c:             LOG.info("Creating producer to possible multiple destinations with persistent delivery.");
1:a88906f:             jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:a88906f:         } else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {
1:540dd5c:             LOG.info("Creating producer to possible multiple destinations with non-persistent delivery.");
1:a88906f:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:a88906f:         } else {
1:540dd5c:             LOG.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
1:a88906f:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:a88906f:         }
1:a88906f:         return jmsProducer;
1:a88906f:     }
1:a88906f: 
1:a88906f:     public MessageProducer createJmsProducer(Destination dest) throws JMSException {
1:a88906f:         jmsProducer = getSession().createProducer(dest);
1:a88906f:         if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {
1:540dd5c:             LOG.info("Creating producer to: " + dest.toString() + " with persistent delivery.");
1:a88906f:             jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:a88906f:         } else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {
1:540dd5c:             LOG.info("Creating  producer to: " + dest.toString() + " with non-persistent delivery.");
1:a88906f:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:a88906f:         } else {
1:540dd5c:             LOG.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
1:a88906f:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:a88906f:         }
1:a88906f:         return jmsProducer;
1:a88906f:     }
1:a88906f: 
1:a88906f:     public MessageProducer getJmsProducer() {
1:a88906f:         return jmsProducer;
1:a88906f:     }
1:a88906f: 
1:a88906f:     public TextMessage createJmsTextMessage() throws JMSException {
1:e47e0e0:         if (client.getMsgFileName() != null) {
1:e47e0e0:             return loadJmsMessage();
1:e47e0e0:         } else {
1:b656266:           return createJmsTextMessage(client.getMessageSize());
1:e47e0e0:         }
1:b656266:     }
1:a88906f: 
1:a88906f:     public TextMessage createJmsTextMessage(int size) throws JMSException {
1:a88906f:         jmsTextMessage = getSession().createTextMessage(buildText("", size));
1:e47e0e0: 
1:a072126:         // support for adding message headers
1:a072126:         Set<String> headerKeys = this.client.getHeaderKeys();
1:a072126:         for (String key : headerKeys) {
1:e47e0e0:             jmsTextMessage.setObjectProperty(key, this.client.getHeaderValue(key));
1:a072126:         }
1:e47e0e0: 
1:b656266:         return jmsTextMessage;
1:b656266:     }
1:b656266: 
1:a88906f:     public TextMessage createJmsTextMessage(String text) throws JMSException {
1:a88906f:         jmsTextMessage = getSession().createTextMessage(buildText(text, client.getMessageSize()));
2:a88906f:         return jmsTextMessage;
1:a88906f:     }
1:a072126: 
1:a88906f:     public TextMessage getJmsTextMessage() {
1:a88906f:         return jmsTextMessage;
1:a88906f:     }
1:a88906f: 
1:e47e0e0:     @Override
1:a88906f:     public JmsClientProperties getClient() {
1:a88906f:         return client;
1:a88906f:     }
1:a88906f: 
1:e47e0e0:     @Override
1:a88906f:     public void setClient(JmsClientProperties clientProps) {
1:a88906f:         client = (JmsProducerProperties)clientProps;
1:a88906f:     }
1:a88906f: 
1:46bc26c:     @Override
1:46bc26c:     protected Destination createTemporaryDestination(String destName) throws JMSException {
1:46bc26c:         String simpleName = getSimpleName(destName);
1:46bc26c:         byte destinationType = getDestinationType(destName);
1:46bc26c: 
1:46bc26c:         // when we produce to temp destinations, we publish to them as
1:46bc26c:         // though they were normal queues or topics
1:46bc26c:         if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {
1:46bc26c:             LOG.info("Creating queue: {}", destName);
1:46bc26c:             return getSession().createQueue(simpleName);
1:46bc26c:         } else if (destinationType == ActiveMQDestination.TEMP_TOPIC_TYPE) {
1:46bc26c:             LOG.info("Creating topic: {}", destName);
1:46bc26c:             return getSession().createTopic(simpleName);
1:46bc26c:         } else {
1:46bc26c:             throw new IllegalArgumentException("Unrecognized destination type: " + destinationType);
1:46bc26c:         }
1:46bc26c:     }
1:46bc26c: 
1:a88906f:     protected String buildText(String text, int size) {
1:a88906f:         byte[] data = new byte[size - text.length()];
1:a88906f:         Arrays.fill(data, (byte) 0);
1:a88906f:         return text + new String(data);
1:576230b:     }
1:e47e0e0: 
1:576230b:     protected void sleep() {
1:576230b:         if (client.getSendDelay() > 0) {
1:e47e0e0:             try {
1:e47e0e0:                 LOG.trace("Sleeping for " + client.getSendDelay() + " milliseconds");
1:e47e0e0:                 Thread.sleep(client.getSendDelay());
1:e47e0e0:             } catch (java.lang.InterruptedException ex) {
1:e47e0e0:                 LOG.warn(ex.getMessage());
1:e47e0e0:             }
1:576230b:         }
1:576230b:     }
1:e47e0e0: 
1:b656266:     /**
1:b656266:      * loads the message to be sent from the specified TextFile
1:b656266:      */
1:b656266:     protected TextMessage loadJmsMessage() throws JMSException {
1:e47e0e0:         try {
1:e47e0e0:             // couple of sanity checks upfront
1:e47e0e0:             if (client.getMsgFileName() == null) {
1:e47e0e0:                 throw new JMSException("Invalid filename specified.");
1:e47e0e0:             }
1:e47e0e0: 
1:e47e0e0:             File f = new File(client.getMsgFileName());
1:e47e0e0:             if (f.isDirectory()) {
1:e47e0e0:                 throw new JMSException("Cannot load from " +
1:e47e0e0:                         client.getMsgFileName() +
1:e47e0e0:                         " as it is a directory not a text file.");
1:e47e0e0:             }
1:e47e0e0: 
1:e47e0e0:             // try to load file
1:e47e0e0:             StringBuffer payload = new StringBuffer();
1:12b26b6:             try(FileReader fr = new FileReader(f);
1:12b26b6:                 BufferedReader br = new BufferedReader(fr)) {
1:12b26b6:                 String tmp = null;
1:12b26b6:                 while ((tmp = br.readLine()) != null) {
1:12b26b6:                     payload.append(tmp);
1:12b26b6:                 }
1:e47e0e0:             }
1:e47e0e0:             jmsTextMessage = getSession().createTextMessage(payload.toString());
1:e47e0e0:             return jmsTextMessage;
1:e47e0e0:         } catch (FileNotFoundException ex) {
1:e47e0e0:             throw new JMSException(ex.getMessage());
1:e47e0e0:         } catch (IOException iox) {
1:e47e0e0:             throw new JMSException(iox.getMessage());
1:e47e0e0:         }
1:b656266:     }
1:b656266: }
============================================================================
author:giliva
-------------------------------------------------------------------------------
commit:5b1412d
/////////////////////////////////////////////////////////////////////////
1:                     while (System.currentTimeMillis() - endTime < 0) {
/////////////////////////////////////////////////////////////////////////
1:                     while (System.currentTimeMillis() - endTime < 0) {
/////////////////////////////////////////////////////////////////////////
1:                     while (System.currentTimeMillis() - endTime < 0) {
/////////////////////////////////////////////////////////////////////////
1:                     while (System.currentTimeMillis() - endTime < 0) {
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:12b26b6
/////////////////////////////////////////////////////////////////////////
1:             try(FileReader fr = new FileReader(f);
1:                 BufferedReader br = new BufferedReader(fr)) {
1:                 String tmp = null;
1:                 while ((tmp = br.readLine()) != null) {
1:                     payload.append(tmp);
1:                 }
author:Timothy Bish
-------------------------------------------------------------------------------
commit:46bc26c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected Destination createTemporaryDestination(String destName) throws JMSException {
1:         String simpleName = getSimpleName(destName);
1:         byte destinationType = getDestinationType(destName);
1: 
1:         // when we produce to temp destinations, we publish to them as
1:         // though they were normal queues or topics
1:         if (destinationType == ActiveMQDestination.TEMP_QUEUE_TYPE) {
1:             LOG.info("Creating queue: {}", destName);
1:             return getSession().createQueue(simpleName);
1:         } else if (destinationType == ActiveMQDestination.TEMP_TOPIC_TYPE) {
1:             LOG.info("Creating topic: {}", destName);
1:             return getSession().createTopic(simpleName);
1:         } else {
1:             throw new IllegalArgumentException("Unrecognized destination type: " + destinationType);
1:         }
1:     }
1: 
commit:6dd47bb
/////////////////////////////////////////////////////////////////////////
1:         Destination[] dest = createDestinations(destCount);
/////////////////////////////////////////////////////////////////////////
1:         Destination[] dest = createDestinations(destCount);
commit:e47e0e0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             long sendCount = client.getSendCount();
1:             sendCountBasedMessages(sendCount);
1:             long sendDuration = client.getSendDuration();
1:             sendTimeBasedMessages(sendDuration);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Starting to publish " +
1:                     messageCount +
1:                     " messages from file " +
1:                     client.getMsgFileName()
1:                 );
1:                 LOG.info("Starting to publish " +
1:                     messageCount +
1:                     " messages of size " +
1:                     client.getMessageSize() +
1:                     " byte(s)."
1:                 );
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Finished sending");
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Starting to publish messages from file " +
1:                         client.getMsgFileName() +
1:                         " for " +
1:                         duration +
1:                         " ms");
1:                 LOG.info("Starting to publish " +
1:                         client.getMessageSize() +
1:                         " byte(s) messages for " +
1:                         duration +
1:                         " ms");
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Finished sending");
/////////////////////////////////////////////////////////////////////////
1:         if (client.getMsgFileName() != null) {
1:             return loadJmsMessage();
1:         } else {
1:         }
1: 
1:             jmsTextMessage.setObjectProperty(key, this.client.getHeaderValue(key));
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:             try {
1:                 LOG.trace("Sleeping for " + client.getSendDelay() + " milliseconds");
1:                 Thread.sleep(client.getSendDelay());
1:             } catch (java.lang.InterruptedException ex) {
1:                 LOG.warn(ex.getMessage());
1:             }
1: 
1:         try {
1:             // couple of sanity checks upfront
1:             if (client.getMsgFileName() == null) {
1:                 throw new JMSException("Invalid filename specified.");
1:             }
1: 
1:             File f = new File(client.getMsgFileName());
1:             if (f.isDirectory()) {
1:                 throw new JMSException("Cannot load from " +
1:                         client.getMsgFileName() +
1:                         " as it is a directory not a text file.");
1:             }
1: 
1:             // try to load file
0:             BufferedReader br = new BufferedReader(new FileReader(f));
1:             StringBuffer payload = new StringBuffer();
0:             String tmp = null;
0:             while ((tmp = br.readLine()) != null) {
0:                 payload.append(tmp);
1:             }
0:             br.close();
1:             jmsTextMessage = getSession().createTextMessage(payload.toString());
1:             return jmsTextMessage;
1:         } catch (FileNotFoundException ex) {
1:             throw new JMSException(ex.getMessage());
1:         } catch (IOException iox) {
1:             throw new JMSException(iox.getMessage());
1:         }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:87e878b
commit:b656266
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.FileNotFoundException;
1: import java.io.FileReader;
1: import java.io.IOException;
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (client.getMsgFileName() != null) {
0:             	LOG.info("Starting to publish " +
0:             		messageCount + 
0:             		" messages from file " + 
0:             		client.getMsgFileName()
0:             	);
1:             } else {
0:             	LOG.info("Starting to publish " +
0:             		messageCount +
0:             		" messages of size " +
0:             		client.getMessageSize() + 
0:             		" byte(s)." 
0:             	);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (client.getMsgFileName() != null) {
0:             	LOG.info("Starting to publish messages from file " + 
0:             			client.getMsgFileName() + 
0:             			" for " +
0:             			duration + 
0:             			" ms");
1:             } else {
0:             	LOG.info("Starting to publish " + 
0:             			client.getMessageSize() + 
0:             			" byte(s) messages for " + 
0:             			duration + 
0:             			" ms");
1:             }
/////////////////////////////////////////////////////////////////////////
0:     	if (client.getMsgFileName() != null) {
0:     		return loadJmsMessage();
1:     	} else {
1:           return createJmsTextMessage(client.getMessageSize());
1:     	}
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * loads the message to be sent from the specified TextFile
1:      */
1:     protected TextMessage loadJmsMessage() throws JMSException {
1:     	try {
0:     		// couple of sanity checks upfront 
0:     		if (client.getMsgFileName() == null) {
0:     			throw new JMSException("Invalid filename specified.");
1:     		}
1:     		
0:     		File f = new File(client.getMsgFileName());
0:     		if (f.isDirectory()) {
0:     			throw new JMSException("Cannot load from " + 
0:     					client.getMsgFileName() + 
0:     					" as it is a directory not a text file.");
1:     		} 
1:     		
0:     		// try to load file
0:     		BufferedReader br = new BufferedReader(new FileReader(f));
0:     		StringBuffer payload = new StringBuffer();
0:     		String tmp = null;
0:     		while ((tmp = br.readLine()) != null) {
0:     			payload.append(tmp);
1:     		}
0:     		jmsTextMessage = getSession().createTextMessage(payload.toString());
1:     		return jmsTextMessage;
1:     		
0:     	} catch (FileNotFoundException ex) {
0:     		throw new JMSException(ex.getMessage());
0:     	} catch (IOException iox) {
0:     		throw new JMSException(iox.getMessage());
1:     	}
1:     }
commit:576230b
/////////////////////////////////////////////////////////////////////////
1:                             sleep();
/////////////////////////////////////////////////////////////////////////
1:                         sleep();
/////////////////////////////////////////////////////////////////////////
1:                             sleep();
/////////////////////////////////////////////////////////////////////////
1:                         sleep();
/////////////////////////////////////////////////////////////////////////
1:                             sleep();
/////////////////////////////////////////////////////////////////////////
1:                         sleep();
/////////////////////////////////////////////////////////////////////////
1:                             sleep();
/////////////////////////////////////////////////////////////////////////
1:                         sleep();
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected void sleep() {
1:         if (client.getSendDelay() > 0) {
1:         	try {
0:         		LOG.trace("Sleeping for " + client.getSendDelay() + " milliseconds");
0:         		Thread.sleep(client.getSendDelay());
0:         	} catch (java.lang.InterruptedException ex) {
0:         		LOG.warn(ex.getMessage());
1:         	}
1:         }
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:459be2d
/////////////////////////////////////////////////////////////////////////
1:                             commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                         commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                             commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                         commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                             commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                         commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                             commitTxIfNecessary();
/////////////////////////////////////////////////////////////////////////
1:                         commitTxIfNecessary();
commit:a072126
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:         
1:         // support for adding message headers
1:         Set<String> headerKeys = this.client.getHeaderKeys();
1:         for (String key : headerKeys) {
0:         	jmsTextMessage.setObjectProperty(key, this.client.getHeaderValue(key));
1:         }
1:         
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JmsProducerClient.class);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: 
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.MessageProducer;
1: import javax.jms.TextMessage;
1: 
1: import org.apache.activemq.tool.properties.JmsProducerProperties;
0:     private static final Log LOG = LogFactory.getLog(JmsProducerClient.class);
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Starting to publish " + client.getMessageSize() + " byte(s) of " + messageCount + " messages...");
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Starting to publish " + client.getMessageSize() + " byte(s) messages for " + duration + " ms");
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Creating producer to possible multiple destinations with persistent delivery.");
1:             LOG.info("Creating producer to possible multiple destinations with non-persistent delivery.");
1:             LOG.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Creating producer to: " + dest.toString() + " with persistent delivery.");
1:             LOG.info("Creating  producer to: " + dest.toString() + " with non-persistent delivery.");
1:             LOG.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a88906f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.tool;
1: 
0: import org.apache.activemq.tool.properties.JmsProducerProperties;
1: import org.apache.activemq.tool.properties.JmsClientProperties;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import javax.jms.ConnectionFactory;
0: import javax.jms.MessageProducer;
0: import javax.jms.TextMessage;
0: import javax.jms.JMSException;
0: import javax.jms.Destination;
0: import javax.jms.DeliveryMode;
0: import java.util.Arrays;
1: 
1: public class JmsProducerClient extends AbstractJmsMeasurableClient {
0:     private static final Log log = LogFactory.getLog(JmsProducerClient.class);
1: 
1:     protected JmsProducerProperties client;
1:     protected MessageProducer jmsProducer;
1:     protected TextMessage jmsTextMessage;
1: 
1:     public JmsProducerClient(ConnectionFactory factory) {
1:         this(new JmsProducerProperties(), factory);
1:     }
1: 
1:     public JmsProducerClient(JmsProducerProperties clientProps, ConnectionFactory factory) {
1:         super(factory);
1:         this.client = clientProps;
1:     }
1: 
1:     public void sendMessages() throws JMSException {
1:         // Send a specific number of messages
1:         if (client.getSendType().equalsIgnoreCase(JmsProducerProperties.COUNT_BASED_SENDING)) {
0:             sendCountBasedMessages(client.getSendCount());
1: 
1:         // Send messages for a specific duration
1:         } else {
0:             sendTimeBasedMessages(client.getSendDuration());
1:         }
1:     }
1: 
1:     public void sendMessages(int destCount) throws JMSException {
1:         this.destCount = destCount;
1:         sendMessages();
1:     }
1: 
1:     public void sendMessages(int destIndex, int destCount) throws JMSException {
1:         this.destIndex = destIndex;
1:         sendMessages(destCount);
1:     }
1: 
1:     public void sendCountBasedMessages(long messageCount) throws JMSException {
1:         // Parse through different ways to send messages
1:         // Avoided putting the condition inside the loop to prevent effect on performance
0:         Destination[] dest = createDestination(destIndex, destCount);
1: 
1:         // Create a producer, if none is created.
1:         if (getJmsProducer() == null) {
1:             if (dest.length == 1) {
1:                 createJmsProducer(dest[0]);
1:             } else {
1:                 createJmsProducer();
1:             }
1:         }
0:         try {
1:             getConnection().start();
0:             log.info("Starting to publish " + client.getMessageSize() + " byte(s) of " + messageCount + " messages...");
1: 
1:             // Send one type of message only, avoiding the creation of different messages on sending
1:             if (!client.isCreateNewMsg()) {
1:                 // Create only a single message
1:                 createJmsTextMessage();
1: 
1:                 // Send to more than one actual destination
1:                 if (dest.length > 1) {
1:                     for (int i = 0; i < messageCount; i++) {
1:                         for (int j = 0; j < dest.length; j++) {
1:                             getJmsProducer().send(dest[j], getJmsTextMessage());
1:                             incThroughput();
1:                         }
1:                     }
1:                     // Send to only one actual destination
1:                 } else {
1:                     for (int i = 0; i < messageCount; i++) {
1:                         getJmsProducer().send(getJmsTextMessage());
1:                         incThroughput();
1:                     }
1:                 }
1: 
1:                 // Send different type of messages using indexing to identify each one.
1:                 // Message size will vary. Definitely slower, since messages properties
1:                 // will be set individually each send.
1:             } else {
1:                 // Send to more than one actual destination
1:                 if (dest.length > 1) {
1:                     for (int i = 0; i < messageCount; i++) {
1:                         for (int j = 0; j < dest.length; j++) {
1:                             getJmsProducer().send(dest[j], createJmsTextMessage("Text Message [" + i + "]"));
1:                             incThroughput();
1:                         }
1:                     }
1: 
1:                     // Send to only one actual destination
1:                 } else {
1:                     for (int i = 0; i < messageCount; i++) {
1:                         getJmsProducer().send(createJmsTextMessage("Text Message [" + i + "]"));
1:                         incThroughput();
1:                     }
1:                 }
1:             }
1:         } finally {
1:             getConnection().close();
1:         }
1:     }
1: 
1:     public void sendTimeBasedMessages(long duration) throws JMSException {
1:         long endTime = System.currentTimeMillis() + duration;
1:         // Parse through different ways to send messages
1:         // Avoided putting the condition inside the loop to prevent effect on performance
1: 
0:         Destination[] dest = createDestination(destIndex, destCount);
1: 
1:         // Create a producer, if none is created.
1:         if (getJmsProducer() == null) {
1:             if (dest.length == 1) {
1:                 createJmsProducer(dest[0]);
1:             } else {
1:                 createJmsProducer();
1:             }
1:         }
1: 
0:         try {
1:             getConnection().start();
0:             log.info("Starting to publish " + client.getMessageSize() + " byte(s) messages for " + duration + " ms");
1: 
1:             // Send one type of message only, avoiding the creation of different messages on sending
1:             if (!client.isCreateNewMsg()) {
1:                 // Create only a single message
1:                 createJmsTextMessage();
1: 
1:                 // Send to more than one actual destination
1:                 if (dest.length > 1) {
0:                     while (System.currentTimeMillis() < endTime) {
1:                         for (int j = 0; j < dest.length; j++) {
1:                             getJmsProducer().send(dest[j], getJmsTextMessage());
1:                             incThroughput();
1:                         }
1:                     }
1:                     // Send to only one actual destination
1:                 } else {
0:                     while (System.currentTimeMillis() < endTime) {
1:                         getJmsProducer().send(getJmsTextMessage());
1:                         incThroughput();
1:                     }
1:                 }
1: 
1:                 // Send different type of messages using indexing to identify each one.
1:                 // Message size will vary. Definitely slower, since messages properties
1:                 // will be set individually each send.
1:             } else {
1:                 // Send to more than one actual destination
1:                 long count = 1;
1:                 if (dest.length > 1) {
0:                     while (System.currentTimeMillis() < endTime) {
1:                         for (int j = 0; j < dest.length; j++) {
1:                             getJmsProducer().send(dest[j], createJmsTextMessage("Text Message [" + count++ + "]"));
1:                             incThroughput();
1:                         }
1:                     }
1: 
1:                     // Send to only one actual destination
1:                 } else {
0:                     while (System.currentTimeMillis() < endTime) {
1: 
1:                         getJmsProducer().send(createJmsTextMessage("Text Message [" + count++ + "]"));
1:                         incThroughput();
1:                     }
1:                 }
1:             }
1:         } finally {
1:             getConnection().close();
1:         }
1:     }
1: 
1:     public MessageProducer createJmsProducer() throws JMSException {
1:         jmsProducer = getSession().createProducer(null);
1:         if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {
0:             log.info("Creating producer to possible multiple destinations with persistent delivery.");
1:             jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:         } else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {
0:             log.info("Creating producer to possible multiple destinations with non-persistent delivery.");
1:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         } else {
0:             log.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
1:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         }
1:         return jmsProducer;
1:     }
1: 
1:     public MessageProducer createJmsProducer(Destination dest) throws JMSException {
1:         jmsProducer = getSession().createProducer(dest);
1:         if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {
0:             log.info("Creating producer to: " + dest.toString() + " with persistent delivery.");
1:             jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:         } else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {
0:             log.info("Creating  producer to: " + dest.toString() + " with non-persistent delivery.");
1:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         } else {
0:             log.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
1:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         }
1:         return jmsProducer;
1:     }
1: 
1:     public MessageProducer getJmsProducer() {
1:         return jmsProducer;
1:     }
1: 
1:     public TextMessage createJmsTextMessage() throws JMSException {
0:         return createJmsTextMessage(client.getMessageSize());
1:     }
1: 
1:     public TextMessage createJmsTextMessage(int size) throws JMSException {
1:         jmsTextMessage = getSession().createTextMessage(buildText("", size));
1:         return jmsTextMessage;
1:     }
1: 
1:     public TextMessage createJmsTextMessage(String text) throws JMSException {
1:         jmsTextMessage = getSession().createTextMessage(buildText(text, client.getMessageSize()));
1:         return jmsTextMessage;
1:     }
1: 
1:     public TextMessage getJmsTextMessage() {
1:         return jmsTextMessage;
1:     }
1: 
1:     public JmsClientProperties getClient() {
1:         return client;
1:     }
1: 
1:     public void setClient(JmsClientProperties clientProps) {
1:         client = (JmsProducerProperties)clientProps;
1:     }
1: 
1:     protected String buildText(String text, int size) {
1:         byte[] data = new byte[size - text.length()];
1:         Arrays.fill(data, (byte) 0);
1:         return text + new String(data);
1:     }
1: }
author:James Strachan
-------------------------------------------------------------------------------
commit:dd55c21
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:f1c6e4c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.tool.properties.JmsProducerProperties;
0: import org.apache.activemq.tool.properties.JmsClientProperties;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.MessageProducer;
0: import javax.jms.TextMessage;
0: import javax.jms.JMSException;
0: import javax.jms.Destination;
0: import javax.jms.DeliveryMode;
0: public class JmsProducerClient extends AbstractJmsMeasurableClient {
0:     protected JmsProducerProperties client;
0:     public JmsProducerClient(ConnectionFactory factory) {
0:         this(new JmsProducerProperties(), factory);
0:     }
0: 
0:     public JmsProducerClient(JmsProducerProperties clientProps, ConnectionFactory factory) {
0:         super(factory);
0:         this.client = clientProps;
0:     }
0:         if (client.getSendType().equalsIgnoreCase(JmsProducerProperties.COUNT_BASED_SENDING)) {
0:             sendCountBasedMessages(client.getSendCount());
0:         // Send messages for a specific duration
0:             sendTimeBasedMessages(client.getSendDuration());
0:     public void sendMessages(int destCount) throws JMSException {
0:         this.destCount = destCount;
0:         sendMessages();
0:     }
0: 
0:     public void sendMessages(int destIndex, int destCount) throws JMSException {
0:         this.destIndex = destIndex;
0:         sendMessages(destCount);
0:     }
0: 
0:         Destination[] dest = createDestination(destIndex, destCount);
/////////////////////////////////////////////////////////////////////////
0:             log.info("Starting to publish " + client.getMessageSize() + " byte(s) of " + messageCount + " messages...");
0: 
0:             if (!client.isCreateNewMsg()) {
0:                 // Create only a single message
0:                 createJmsTextMessage();
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Destination[] dest = createDestination(destIndex, destCount);
/////////////////////////////////////////////////////////////////////////
0:             log.info("Starting to publish " + client.getMessageSize() + " byte(s) messages for " + duration + " ms");
0:             if (!client.isCreateNewMsg()) {
0:                 // Create only a single message
0:                 createJmsTextMessage();
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {
0:             log.info("Creating producer to possible multiple destinations with persistent delivery.");
0:         } else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {
0:             log.info("Creating producer to possible multiple destinations with non-persistent delivery.");
/////////////////////////////////////////////////////////////////////////
0:         if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_PERSISTENT)) {
0:             log.info("Creating producer to: " + dest.toString() + " with persistent delivery.");
0:         } else if (client.getDeliveryMode().equalsIgnoreCase(JmsProducerProperties.DELIVERY_MODE_NON_PERSISTENT)) {
0:             log.info("Creating  producer to: " + dest.toString() + " with non-persistent delivery.");
/////////////////////////////////////////////////////////////////////////
0:         return createJmsTextMessage(client.getMessageSize());
/////////////////////////////////////////////////////////////////////////
0:         jmsTextMessage = getSession().createTextMessage(buildText(text, client.getMessageSize()));
/////////////////////////////////////////////////////////////////////////
0:     public JmsClientProperties getClient() {
0:         return client;
0:     }
0: 
0:     public void setClient(JmsClientProperties clientProps) {
0:         client = (JmsProducerProperties)clientProps;
0:     }
0: 
commit:2fa8814
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.*;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static final String DELIVERY_MODE_PERSISTENT = "persistent";
0:     public static final String DELIVERY_MODE_NON_PERSISTENT = "nonpersistent";
0:     protected String deliveryMode = DELIVERY_MODE_NON_PERSISTENT;
/////////////////////////////////////////////////////////////////////////
0:         if (getDeliveryMode().equalsIgnoreCase(DELIVERY_MODE_PERSISTENT)) {
0:             jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
0:         } else if (getDeliveryMode().equalsIgnoreCase(DELIVERY_MODE_NON_PERSISTENT)) {
0:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:         } else {
0:             log.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
0:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:         }
0:         if (getDeliveryMode().equalsIgnoreCase(DELIVERY_MODE_PERSISTENT)) {
0:             jmsProducer.setDeliveryMode(DeliveryMode.PERSISTENT);
0:         } else if (getDeliveryMode().equalsIgnoreCase(DELIVERY_MODE_NON_PERSISTENT)) {
0:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:         } else {
0:             log.warn("Unknown deliveryMode value. Defaulting to non-persistent.");
0:             jmsProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public String getDeliveryMode() {
0:         return deliveryMode;
0:     }
0: 
0:     public void setDeliveryMode(String deliveryMode) {
0:         this.deliveryMode = deliveryMode;
0:     }
0: 
commit:a38f71d
/////////////////////////////////////////////////////////////////////////
0:         String[] options = new String[16];
/////////////////////////////////////////////////////////////////////////
0:         options[15] = "-Dfactory.asyncSend=true";
commit:5f5bff6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import javax.jms.MessageProducer;
0: import javax.jms.TextMessage;
0: import java.util.Properties;
0: public class JmsProducerClient extends JmsPerformanceSupport {
0:     private static final Log log = LogFactory.getLog(JmsProducerClient.class);
0:     private static final String PREFIX_CONFIG_PRODUCER = "producer.";
0:     public  static final String TIME_BASED_SENDING  = "time";
0:     public  static final String COUNT_BASED_SENDING = "count";
0:     protected Properties      jmsProducerSettings = new Properties();
0:     protected MessageProducer jmsProducer;
0:     protected TextMessage     jmsTextMessage;
0:     protected int    messageSize  = 1024;          // Send 1kb messages by default
0:     protected long   sendCount    = 1000000;       // Send a million messages by default
0:     protected long   sendDuration = 5 * 60 * 1000; // Send for 5 mins by default
0:     protected String sendType     = TIME_BASED_SENDING;
0:     public void sendMessages() throws JMSException {
0:         if (listener != null) {
0:             listener.onConfigEnd(this);
0:         }
0:         // Send a specific number of messages
0:         if (sendType.equalsIgnoreCase(COUNT_BASED_SENDING)) {
0:             sendCountBasedMessages(getSendCount());
0:         // Send messages for a specific duration
0:             sendTimeBasedMessages(getSendDuration());
0:         Destination[] dest = createDestination();
0: 
0:         // Create a producer, if none is created.
0:         if (getJmsProducer() == null) {
0:             if (dest.length == 1) {
0:                 createJmsProducer(dest[0]);
0:             } else {
0:                 createJmsProducer();
0:             }
0:         }
0:             if (listener != null) {
0:                 listener.onPublishStart(this);
0:             }
0:             if (getJmsTextMessage() != null) {
0:                             getJmsProducer().send(dest[j], getJmsTextMessage());
0:                         getJmsProducer().send(getJmsTextMessage());
/////////////////////////////////////////////////////////////////////////
0:                             getJmsProducer().send(dest[j], createJmsTextMessage("Text Message [" + i + "]"));
0:                         getJmsProducer().send(createJmsTextMessage("Text Message [" + i + "]"));
0:             if (listener != null) {
0:                 listener.onPublishEnd(this);
0:             }
/////////////////////////////////////////////////////////////////////////
0:         Destination[] dest = createDestination();
0: 
0:         // Create a producer, if none is created.
0:         if (getJmsProducer() == null) {
0:             if (dest.length == 1) {
0:                 createJmsProducer(dest[0]);
0:             } else {
0:                 createJmsProducer();
0:             }
0:         }
0: 
0:             if (listener != null) {
0:                 listener.onPublishStart(this);
0:             }
0:             // Send one type of message only, avoiding the creation of different messages on sending
0:             if (getJmsTextMessage() != null) {
0:                             getJmsProducer().send(dest[j], getJmsTextMessage());
0:                         getJmsProducer().send(getJmsTextMessage());
/////////////////////////////////////////////////////////////////////////
0:                             getJmsProducer().send(dest[j], createJmsTextMessage("Text Message [" + count++ + "]"));
0: 
0:                         getJmsProducer().send(createJmsTextMessage("Text Message [" + count++ + "]"));
0:             if (listener != null) {
0:                 listener.onPublishEnd(this);
0:             }
0:     public Properties getJmsProducerSettings() {
0:         return jmsProducerSettings;
0:     }
0:     public void setJmsProducerSettings(Properties jmsProducerSettings) {
0:         this.jmsProducerSettings = jmsProducerSettings;
0:         ReflectionUtil.configureClass(this, jmsProducerSettings);
0:     }
0:     public MessageProducer createJmsProducer() throws JMSException {
0:         jmsProducer = getSession().createProducer(null);
0:         return jmsProducer;
0:     }
0: 
0:     public MessageProducer createJmsProducer(Destination dest) throws JMSException {
0:         jmsProducer = getSession().createProducer(dest);
0:         return jmsProducer;
0:     }
0: 
0:     public MessageProducer getJmsProducer() {
0:         return jmsProducer;
0:     }
0: 
0:     public TextMessage createJmsTextMessage() throws JMSException {
0:         return createJmsTextMessage(getMessageSize());
0:     }
0: 
0:     public TextMessage createJmsTextMessage(int size) throws JMSException {
0:         jmsTextMessage = getSession().createTextMessage(buildText("", size));
0:         return jmsTextMessage;
0:     }
0: 
0:     public TextMessage createJmsTextMessage(String text) throws JMSException {
0:         jmsTextMessage = getSession().createTextMessage(buildText(text, getMessageSize()));
0:         return jmsTextMessage;
0:     }
0: 
0:     public TextMessage getJmsTextMessage() {
0:         return jmsTextMessage;
0:     }
0: 
0:     protected String buildText(String text, int size) {
0:         byte[] data = new byte[size - text.length()];
0:         Arrays.fill(data, (byte)0);
0:         return text + new String(data);
0:     }
0: 
0:     public int getMessageSize() {
0:         return messageSize;
0:     }
0: 
0:     public void setMessageSize(int messageSize) {
0:         this.messageSize = messageSize;
0:     }
0: 
0:     public long getSendCount() {
0:         return sendCount;
0:     }
0: 
0:     public void setSendCount(long sendCount) {
0:         this.sendCount = sendCount;
0:     }
0: 
0:     public long getSendDuration() {
0:         return sendDuration;
0:     }
0: 
0:     public void setSendDuration(long sendDuration) {
0:         this.sendDuration = sendDuration;
0:     }
0: 
0:     public String getSendType() {
0:         return sendType;
0:     }
0: 
0:     public void setSendType(String sendType) {
0:         this.sendType = sendType;
0:     }
0: 
0:     public Properties getSettings() {
0:         Properties allSettings = new Properties(jmsProducerSettings);
0:         allSettings.putAll(super.getSettings());
0:         return allSettings;
0:     }
0: 
0:     public void setSettings(Properties settings) {
0:         super.setSettings(settings);
0:         ReflectionUtil.configureClass(this, jmsProducerSettings);
0:     }
0: 
0:     public void setProperty(String key, String value) {
0:         if (key.startsWith(PREFIX_CONFIG_PRODUCER)) {
0:             jmsProducerSettings.setProperty(key, value);
0:         } else {
0:             super.setProperty(key, value);
0:     }
0:     public static void main(String[] args) throws JMSException {
0:         String[] options = new String[17];
0:         options[0] = "-Dsampler.duration=60000";     // 1 min
0:         options[1] = "-Dsampler.interval=5000";      // 5 secs
0:         options[2] = "-Dsampler.rampUpTime=10000";   // 10 secs
0:         options[3] = "-Dsampler.rampDownTime=10000"; // 10 secs
0:         options[4] = "-Dclient.spiClass=org.apache.activemq.tool.spi.ActiveMQPojoSPI";
0:         options[5] = "-Dclient.sessTransacted=false";
0:         options[6] = "-Dclient.sessAckMode=autoAck";
0:         options[7] = "-Dclient.destName=topic://FOO.BAR.TEST";
0:         options[8] = "-Dclient.destCount=1";
0:         options[9] = "-Dclient.destComposite=false";
0: 
0:         options[10] = "-Dproducer.messageSize=1024";
0:         options[11] = "-Dproducer.sendCount=1000";     // 1000 messages
0:         options[12] = "-Dproducer.sendDuration=60000"; // 1 min
0:         options[13] = "-Dproducer.sendType=time";
0: 
0:         options[14] = "-Dfactory.brokerUrl=tcp://localhost:61616";
0:         options[15] = "-Dfactory.clientID=producerSampleClient";
0:         options[16] = "-Dfactory.asyncSend=true";
0: 
0:         args = options;
0: 
0:         Properties samplerSettings  = new Properties();
0:         Properties producerSettings = new Properties();
0: 
0:         for (int i=0; i<args.length; i++) {
0:             // Get property define options only
0:             if (args[i].startsWith("-D")) {
0:                 String propDefine = args[i].substring("-D".length());
0:                 int  index = propDefine.indexOf("=");
0:                 String key = propDefine.substring(0, index);
0:                 String val = propDefine.substring(index+1);
0:                 if (key.startsWith("sampler.")) {
0:                     samplerSettings.setProperty(key, val);
0:                 } else {
0:                     producerSettings.setProperty(key, val);
0:             }
0: 
0:         JmsProducerClient client = new JmsProducerClient();
0:         client.setSettings(producerSettings);
0: 
0:         PerfMeasurementTool sampler = new PerfMeasurementTool();
0:         sampler.setSamplerSettings(samplerSettings);
0:         sampler.registerClient(client);
0:         sampler.startSampler();
0: 
0:         client.setPerfEventListener(sampler);
0: 
0:         // This will reuse only a single message every send, which will improve performance
0:         client.createJmsTextMessage();
0:         client.sendMessages();
commit:3a92ec3
/////////////////////////////////////////////////////////////////////////
0:         final long duration     = 1 * 60 * 1000;
0:         long rampUpTime   = 5 * 1000;
0:         long rampDownTime = 5 * 1000;
0:         long interval     = 1000;
0: 
0:         PerfMeasurementTool tool = new PerfMeasurementTool();
0:         tool.setDuration(duration);
0:         tool.setInterval(interval);
0:         tool.setRampUpTime(rampUpTime);
0:         tool.setRampDownTime(rampDownTime);
0: 
0:         JmsProducerClient[] client = new JmsProducerClient[10];
0:         for (int i=0; i<10; i++) {
0:             client[i] = new JmsProducerClient("org.apache.activemq.ActiveMQConnectionFactory", "tcp://localhost:61616", "topic://TEST.FOO");
0:             client[i].addConfigParam("factory.asyncSend", "true");
0:             client[i].setPerfEventListener(new PerfEventAdapter());
0:             client[i].createProducer();
0:             tool.registerClient(client[i]);
0:         }
0: 
0:         tool.startSampler();
0: 
0:         for (int i=0; i<10; i++) {
0:             final JmsProducerClient p = client[i];
0:             Thread t = new Thread(new Runnable() {
0:                 public void run() {
0:                     try {
0:                         p.sendTimeBasedMessages(duration);
0:                     } catch (JMSException e) {
0:                         e.printStackTrace();
0:                     }
0:                 }
0:             });
0:             t.start();
0: 
0:         }
commit:29eef80
/////////////////////////////////////////////////////////////////////////
0:         listener.onConfigStart(this);
/////////////////////////////////////////////////////////////////////////
0:         listener.onConfigEnd(this);
/////////////////////////////////////////////////////////////////////////
0:                     listener.onPublishStart(this);
0:                             incThroughput();
0:                     listener.onPublishEnd(this);
0:                     listener.onPublishStart(this);
0:                         incThroughput();
0:                     listener.onPublishEnd(this);
/////////////////////////////////////////////////////////////////////////
0:                     listener.onPublishStart(this);
0:                             incThroughput();
0:                     listener.onPublishEnd(this);
0:                     listener.onPublishStart(this);
0:                         incThroughput();
0:                     listener.onPublishEnd(this);
/////////////////////////////////////////////////////////////////////////
0:                     listener.onPublishStart(this);
0:                             incThroughput();
0:                     listener.onPublishEnd(this);
0:                     listener.onPublishStart(this);
0:                         incThroughput();
0:                     listener.onPublishEnd(this);
/////////////////////////////////////////////////////////////////////////
0:                     listener.onPublishStart(this);
0:                             incThroughput();
0:                     listener.onPublishEnd(this);
0:                     listener.onPublishStart(this);
0:                         incThroughput();
0:                     listener.onPublishEnd(this);
commit:8afd2f6
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.apache.activemq.tool;
0: 
0: import javax.jms.ConnectionFactory;
0: import javax.jms.TextMessage;
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import java.util.Map;
0: import java.util.Arrays;
0: 
0: public class JmsProducerClient extends JmsPerfClientSupport {
0: 
0:     private ConnectionFactory factory = null;
0:     private String factoryClass = "";
0:     private String brokerUrl = "";
0:     private String[] destName  = null;
0: 
0:     private Destination[] dest  = null;
0:     private TextMessage message = null;
0: 
0:     public JmsProducerClient(ConnectionFactory factory, String destName) {
0:         this.factory  = factory;
0:         this.destName = new String[] {destName};
0:     }
0: 
0:     public JmsProducerClient(String factoryClass, String brokerUrl, String destName) {
0:         this.factoryClass = factoryClass;
0:         this.brokerUrl    = brokerUrl;
0:         this.destName     = new String[] {destName};
0:     }
0: 
0:     public JmsProducerClient(String brokerUrl, String destName) {
0:         this.brokerUrl = brokerUrl;
0:         this.destName  = new String[] {destName};
0:     }
0: 
0:     public JmsProducerClient(ConnectionFactory factory, String[] destName) {
0:         this.factory  = factory;
0:         this.destName = destName;
0:     }
0: 
0:     public JmsProducerClient(String factoryClass, String brokerUrl, String[] destName) {
0:         this.factoryClass = factoryClass;
0:         this.brokerUrl    = brokerUrl;
0:         this.destName     = destName;
0:     }
0: 
0:     public JmsProducerClient(String brokerUrl, String[] destName) {
0:         this.brokerUrl = brokerUrl;
0:         this.destName  = destName;
0:     }
0: 
0:     public void createProducer() throws JMSException {
0:         createProducer(0);
0:     }
0: 
0:     public void createProducer(Map settings) throws JMSException {
0:         createProducer(0, settings);
0:     }
0: 
0:     public void createProducer(int messageSize, Map settings) throws JMSException {
0:         addConfigParam(settings);
0:         createProducer(messageSize);
0:     }
0: 
0:     public void createProducer(int messageSize) throws JMSException {
0: 
0:         listener.onConfigStart();
0: 
0:         // Create connection factory
0:         if (factory != null) {
0:             createConnectionFactory(factory);
0:         } else if (factoryClass != null) {
0:             createConnectionFactory(factoryClass, brokerUrl);
0:         } else {
0:             createConnectionFactory(brokerUrl);
0:         }
0:         createConnectionFactory(brokerUrl);
0: 
0: 
0:         // Create destinations
0:         dest = new Destination[destName.length];
0:         for (int i=0; i<destName.length; i++) {
0:             if (destName[i].startsWith("topic://")) {
0:                 dest[i] = createTopic(destName[i].substring("topic://".length()));
0:             } else if (destName[i].startsWith("queue://")) {
0:                 dest[i] = createQueue(destName[i].substring("queue://".length()));
0:             } else {
0:                 dest[i] = createQueue(destName[i]);
0:             }
0:         }
0: 
0:         // Create actual message producer
0:         if (dest.length > 1) {
0:             createMessageProducer(null);
0:         } else {
0:             createMessageProducer(dest[0]);
0:         }
0: 
0:         // Create message to sent
0:         if (messageSize > 0) {
0:             byte[] val = new byte[messageSize];
0:             Arrays.fill(val, (byte)0);
0:             String buff = new String(val);
0:             message = createTextMessage(buff);
0:         }
0: 
0:         listener.onConfigEnd();
0:     }
0: 
0:     public void sendCountBasedMessages(long messageCount) throws JMSException {
0:         // Parse through different ways to send messages
0:         // Avoided putting the condition inside the loop to prevent effect on performance
0:         try {
0:             getConnection().start();
0:             // Send one type of message only, avoiding the creation of different messages on sending
0:             if (message != null) {
0:                 // Send to more than one actual destination
0:                 if (dest.length > 1) {
0:                     listener.onPublishStart();
0:                     for (int i=0; i<messageCount; i++) {
0:                         for (int j=0; j<dest.length; j++) {
0:                             getMessageProducer().send(dest[j], message);
0:                         }
0:                     }
0:                     listener.onPublishEnd();
0:                 // Send to only one actual destination
0:                 } else {
0:                     listener.onPublishStart();
0:                     for (int i=0; i<messageCount; i++) {
0:                         getMessageProducer().send(message);
0:                     }
0:                     listener.onPublishEnd();
0:                 }
0: 
0:             // Send different type of messages using indexing to identify each one.
0:             // Message size will vary. Definitely slower, since messages properties
0:             // will be set individually each send.
0:             } else {
0:                 // Send to more than one actual destination
0:                 if (dest.length > 1) {
0:                     listener.onPublishStart();
0:                     for (int i=0; i<messageCount; i++) {
0:                         for (int j=0; j<dest.length; j++) {
0:                             getMessageProducer().send(dest[j], createTextMessage("Text Message [" + i + "]"));
0:                         }
0:                     }
0:                     listener.onPublishEnd();
0: 
0:                 // Send to only one actual destination
0:                 } else {
0:                     listener.onPublishStart();
0:                     for (int i=0; i<messageCount; i++) {
0:                         getMessageProducer().send(createTextMessage("Text Message [" + i + "]"));
0:                     }
0:                     listener.onPublishEnd();
0:                 }
0:             }
0:         } finally {
0:             getConnection().close();
0:         }
0:     }
0: 
0:     public void sendTimeBasedMessages(long duration) throws JMSException {
0:         long endTime   = System.currentTimeMillis() + duration;
0:         // Parse through different ways to send messages
0:         // Avoided putting the condition inside the loop to prevent effect on performance
0: 
0:         // Send one type of message only, avoiding the creation of different messages on sending
0:         try {
0:             getConnection().start();
0: 
0:             if (message != null) {
0:                 // Send to more than one actual destination
0:                 if (dest.length > 1) {
0:                     listener.onPublishStart();
0:                     while (System.currentTimeMillis() < endTime) {
0:                         for (int j=0; j<dest.length; j++) {
0:                             getMessageProducer().send(dest[j], message);
0:                         }
0:                     }
0:                     listener.onPublishEnd();
0:                 // Send to only one actual destination
0:                 } else {
0:                     listener.onPublishStart();
0:                     while (System.currentTimeMillis() < endTime) {
0:                         getMessageProducer().send(message);
0:                     }
0:                     listener.onPublishEnd();
0:                 }
0: 
0:             // Send different type of messages using indexing to identify each one.
0:             // Message size will vary. Definitely slower, since messages properties
0:             // will be set individually each send.
0:             } else {
0:                 // Send to more than one actual destination
0:                 long count = 1;
0:                 if (dest.length > 1) {
0:                     listener.onPublishStart();
0:                     while (System.currentTimeMillis() < endTime) {
0:                         for (int j=0; j<dest.length; j++) {
0:                             getMessageProducer().send(dest[j], createTextMessage("Text Message [" + count++ + "]"));
0:                         }
0:                     }
0:                     listener.onPublishEnd();
0: 
0:                 // Send to only one actual destination
0:                 } else {
0:                     listener.onPublishStart();
0:                     while (System.currentTimeMillis() < endTime) {
0:                         getMessageProducer().send(createTextMessage("Text Message [" + count++ + "]"));
0:                     }
0:                     listener.onPublishEnd();
0:                 }
0:             }
0:         } finally {
0:             getConnection().close();
0:         }
0:     }
0: 
0:     public static void main(String[] args) throws Exception {
0:         JmsProducerClient prod = new JmsProducerClient("org.apache.activemq.ActiveMQConnectionFactory", "tcp://localhost:61616", "topic://TEST.FOO");
0:         prod.setPerfEventListener(new PerfEventAdapter());
0:         prod.createProducer();
0:         prod.sendTimeBasedMessages(2000);
0:     }
0: }
author:Frederick G. Oconer
-------------------------------------------------------------------------------
commit:4fb36fe
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.MessageProducer;
0: import javax.jms.TextMessage;
0: import java.util.Properties;
0:     public static final String TIME_BASED_SENDING = "time";
0:     public static final String COUNT_BASED_SENDING = "count";
0:     protected Properties jmsProducerSettings = new Properties();
0:     protected TextMessage jmsTextMessage;
0:     protected int messageSize = 1024;          // Send 1kb messages by default
0:     protected long sendCount = 1000000;       // Send a million messages by default
0:     protected long sendDuration = 5 * 60 * 1000; // Send for 5 mins by default
0:     protected String sendType = TIME_BASED_SENDING;
/////////////////////////////////////////////////////////////////////////
0:             // Send messages for a specific duration
/////////////////////////////////////////////////////////////////////////
0:                     for (int i = 0; i < messageCount; i++) {
0:                         for (int j = 0; j < dest.length; j++) {
0:                     // Send to only one actual destination
0:                     for (int i = 0; i < messageCount; i++) {
0:                 // Send different type of messages using indexing to identify each one.
0:                 // Message size will vary. Definitely slower, since messages properties
0:                 // will be set individually each send.
0:                     for (int i = 0; i < messageCount; i++) {
0:                         for (int j = 0; j < dest.length; j++) {
0:                     // Send to only one actual destination
0:                     for (int i = 0; i < messageCount; i++) {
/////////////////////////////////////////////////////////////////////////
0:         long endTime = System.currentTimeMillis() + duration;
/////////////////////////////////////////////////////////////////////////
0:                         for (int j = 0; j < dest.length; j++) {
0:                     // Send to only one actual destination
/////////////////////////////////////////////////////////////////////////
0:                 // Send different type of messages using indexing to identify each one.
0:                 // Message size will vary. Definitely slower, since messages properties
0:                 // will be set individually each send.
0:                         for (int j = 0; j < dest.length; j++) {
0:                     // Send to only one actual destination
/////////////////////////////////////////////////////////////////////////
0:         Arrays.fill(data, (byte) 0);
/////////////////////////////////////////////////////////////////////////
0:         Properties samplerSettings = new Properties();
0:         for (int i = 0; i < args.length; i++) {
0:             int index = args[i].indexOf("=");
0:             String key = args[i].substring(0, index);
0:             String val = args[i].substring(index + 1);
0:             if (key.startsWith("sampler.")) {
0:                 samplerSettings.setProperty(key, val);
0:             } else {
0:                 producerSettings.setProperty(key, val);
0: 
commit:264f0a3
/////////////////////////////////////////////////////////////////////////
0:         /*String[] options = new String[16];
/////////////////////////////////////////////////////////////////////////
0:         args = options;*/
============================================================================