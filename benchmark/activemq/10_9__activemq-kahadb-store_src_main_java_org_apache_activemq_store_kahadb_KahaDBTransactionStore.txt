2:27262c8: /**
1:27262c8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:27262c8:  * contributor license agreements.  See the NOTICE file distributed with
1:27262c8:  * this work for additional information regarding copyright ownership.
1:27262c8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:27262c8:  * (the "License"); you may not use this file except in compliance with
1:27262c8:  * the License.  You may obtain a copy of the License at
1:d40f398:  *
1:27262c8:  *      http://www.apache.org/licenses/LICENSE-2.0
2:1595378:  *
1:27262c8:  * Unless required by applicable law or agreed to in writing, software
1:27262c8:  * distributed under the License is distributed on an "AS IS" BASIS,
1:27262c8:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:27262c8:  * See the License for the specific language governing permissions and
1:27262c8:  * limitations under the License.
2:27262c8:  */
1:27262c8: package org.apache.activemq.store.kahadb;
1:8e61f51: 
1:27262c8: import java.io.DataInputStream;
1:27262c8: import java.io.IOException;
1:27262c8: import java.util.ArrayList;
1:6da08b2: import java.util.Collections;
1:27262c8: import java.util.Iterator;
1:27262c8: import java.util.List;
1:27262c8: import java.util.Map;
1:27262c8: import java.util.concurrent.CancellationException;
1:27262c8: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:27262c8: import java.util.concurrent.ExecutionException;
1:27262c8: import java.util.concurrent.Future;
1:d40f398: 
1:27262c8: import org.apache.activemq.broker.ConnectionContext;
1:27262c8: import org.apache.activemq.command.Message;
1:27262c8: import org.apache.activemq.command.MessageAck;
1:88c1084: import org.apache.activemq.command.MessageId;
1:27262c8: import org.apache.activemq.command.TransactionId;
1:27262c8: import org.apache.activemq.command.XATransactionId;
1:27262c8: import org.apache.activemq.protobuf.Buffer;
1:27262c8: import org.apache.activemq.store.AbstractMessageStore;
1:ad1f751: import org.apache.activemq.store.ListenableFuture;
1:27262c8: import org.apache.activemq.store.MessageStore;
1:27262c8: import org.apache.activemq.store.ProxyMessageStore;
1:27262c8: import org.apache.activemq.store.ProxyTopicMessageStore;
1:27262c8: import org.apache.activemq.store.TopicMessageStore;
1:27262c8: import org.apache.activemq.store.TransactionRecoveryListener;
1:27262c8: import org.apache.activemq.store.TransactionStore;
1:27262c8: import org.apache.activemq.store.kahadb.MessageDatabase.Operation;
1:27262c8: import org.apache.activemq.store.kahadb.data.KahaCommitCommand;
1:27262c8: import org.apache.activemq.store.kahadb.data.KahaPrepareCommand;
1:27262c8: import org.apache.activemq.store.kahadb.data.KahaRollbackCommand;
1:27262c8: import org.apache.activemq.store.kahadb.data.KahaTransactionInfo;
1:27262c8: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
21:27262c8: 
1:27262c8: /**
1:27262c8:  * Provides a TransactionStore implementation that can create transaction aware
1:27262c8:  * MessageStore objects from non transaction aware MessageStore objects.
1:b0c2a40:  *
1:d40f398:  *
1:27262c8:  */
1:27262c8: public class KahaDBTransactionStore implements TransactionStore {
1:8bf987b:     static final Logger LOG = LoggerFactory.getLogger(KahaDBTransactionStore.class);
1:9ef4259:     ConcurrentMap<Object, Tx> inflightTransactions = new ConcurrentHashMap<Object, Tx>();
1:27262c8:     private final KahaDBStore theStore;
1:27262c8: 
1:27262c8:     public KahaDBTransactionStore(KahaDBStore theStore) {
1:27262c8:         this.theStore = theStore;
7:27262c8:     }
1:27262c8: 
1:ec9975c:     private WireFormat wireFormat(){
1:ec9975c:       return this.theStore.wireFormat;
1:ec9975c:     }
1:ec9975c: 
1:27262c8:     public class Tx {
1:6da08b2:         private final List<AddMessageCommand> messages = Collections.synchronizedList(new ArrayList<AddMessageCommand>());
1:1595378: 
1:6da08b2:         private final List<RemoveMessageCommand> acks = Collections.synchronizedList(new ArrayList<RemoveMessageCommand>());
1:27262c8: 
1:27262c8:         public void add(AddMessageCommand msg) {
1:27262c8:             messages.add(msg);
1:27262c8:         }
1:27262c8: 
1:27262c8:         public void add(RemoveMessageCommand ack) {
1:27262c8:             acks.add(ack);
1:27262c8:         }
1:27262c8: 
1:27262c8:         public Message[] getMessages() {
1:27262c8:             Message rc[] = new Message[messages.size()];
1:27262c8:             int count = 0;
1:1595378:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:27262c8:                 AddMessageCommand cmd = iter.next();
1:27262c8:                 rc[count++] = cmd.getMessage();
1:27262c8:             }
1:27262c8:             return rc;
1:27262c8:         }
1:27262c8: 
1:27262c8:         public MessageAck[] getAcks() {
1:27262c8:             MessageAck rc[] = new MessageAck[acks.size()];
1:27262c8:             int count = 0;
1:1595378:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:27262c8:                 RemoveMessageCommand cmd = iter.next();
1:27262c8:                 rc[count++] = cmd.getMessageAck();
1:27262c8:             }
1:27262c8:             return rc;
1:27262c8:         }
1:8e61f51: 
1:27262c8:         /**
1:27262c8:          * @return true if something to commit
1:1595378:          * @throws IOException
1:27262c8:          */
1:27262c8:         public List<Future<Object>> commit() throws IOException {
1:27262c8:             List<Future<Object>> results = new ArrayList<Future<Object>>();
1:27262c8:             // Do all the message adds.
1:1595378:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:27262c8:                 AddMessageCommand cmd = iter.next();
1:27262c8:                 results.add(cmd.run());
1:8e61f51: 
1:27262c8:             }
1:27262c8:             // And removes..
1:1595378:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:27262c8:                 RemoveMessageCommand cmd = iter.next();
1:27262c8:                 cmd.run();
1:27262c8:                 results.add(cmd.run());
1:27262c8:             }
1:d40f398: 
1:27262c8:             return results;
1:27262c8:         }
1:27262c8:     }
1:1595378: 
1:27262c8:     public abstract class AddMessageCommand {
1:27262c8:         private final ConnectionContext ctx;
1:27262c8:         AddMessageCommand(ConnectionContext ctx) {
1:27262c8:             this.ctx = ctx;
1:27262c8:         }
1:27262c8:         abstract Message getMessage();
1:27262c8:         Future<Object> run() throws IOException {
1:27262c8:             return run(this.ctx);
1:27262c8:         }
1:27262c8:         abstract Future<Object> run(ConnectionContext ctx) throws IOException;
1:27262c8:     }
1:8e61f51: 
1:27262c8:     public abstract class RemoveMessageCommand {
1:8e61f51: 
1:27262c8:         private final ConnectionContext ctx;
1:27262c8:         RemoveMessageCommand(ConnectionContext ctx) {
1:27262c8:             this.ctx = ctx;
1:27262c8:         }
1:27262c8:         abstract MessageAck getMessageAck();
1:27262c8:         Future<Object> run() throws IOException {
1:27262c8:             return run(this.ctx);
1:27262c8:         }
1:27262c8:         abstract Future<Object> run(ConnectionContext context) throws IOException;
1:27262c8:     }
1:8e61f51: 
1:27262c8:     public MessageStore proxy(MessageStore messageStore) {
1:27262c8:         return new ProxyMessageStore(messageStore) {
1:9ef4259:             @Override
1:27262c8:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:27262c8:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:27262c8:             }
1:8e61f51: 
1:27262c8:             @Override
1:d40f398:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
1:d40f398:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:d40f398:             }
1:d40f398: 
1:d40f398:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:27262c8:                 return KahaDBTransactionStore.this.asyncAddQueueMessage(context, getDelegate(), message);
1:d40f398:             }
1:d40f398: 
1:d40f398:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
1:d40f398:                 return KahaDBTransactionStore.this.asyncAddQueueMessage(context, getDelegate(), message);
1:d40f398:             }
1:d40f398: 
1:d40f398:             @Override
1:27262c8:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:27262c8:                 KahaDBTransactionStore.this.removeMessage(context, getDelegate(), ack);
1:27262c8:             }
1:8e61f51: 
1:27262c8:             @Override
1:27262c8:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:27262c8:                 KahaDBTransactionStore.this.removeAsyncMessage(context, getDelegate(), ack);
1:27262c8:             }
1:27262c8:         };
1:27262c8:     }
1:88c1084: 
1:27262c8:     public TopicMessageStore proxy(TopicMessageStore messageStore) {
1:27262c8:         return new ProxyTopicMessageStore(messageStore) {
1:88c1084:             @Override
1:27262c8:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:d40f398:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:27262c8:             }
1:8e61f51: 
1:27262c8:             @Override
1:d40f398:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
1:27262c8:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:27262c8:             }
1:8e61f51: 
1:27262c8:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
1:1999d94:                 return KahaDBTransactionStore.this.asyncAddTopicMessage(context, getDelegate(), message);
1:d40f398:             }
1:d40f398: 
1:d40f398:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
1:d40f398:                 return KahaDBTransactionStore.this.asyncAddTopicMessage(context, getDelegate(), message);
1:27262c8:             }
1:27262c8: 
1:27262c8:             @Override
1:27262c8:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:27262c8:                 KahaDBTransactionStore.this.removeMessage(context, getDelegate(), ack);
1:27262c8:             }
1:27262c8: 
1:27262c8:             @Override
1:27262c8:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:27262c8:                 KahaDBTransactionStore.this.removeAsyncMessage(context, getDelegate(), ack);
1:27262c8:             }
1:27262c8: 
1:27262c8:             @Override
1:88c1084:             public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
1:1595378:                             MessageId messageId, MessageAck ack) throws IOException {
1:1595378:                 KahaDBTransactionStore.this.acknowledge(context, (TopicMessageStore)getDelegate(), clientId,
1:88c1084:                         subscriptionName, messageId, ack);
1:88c1084:             }
1:88c1084: 
1:27262c8:         };
1:27262c8:     }
1:27262c8: 
1:27262c8:     /**
1:1595378:      * @throws IOException
1:27262c8:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:27262c8:      */
1:9ef4259:     @Override
1:27262c8:     public void prepare(TransactionId txid) throws IOException {
1:27262c8:         KahaTransactionInfo info = getTransactionInfo(txid);
1:4ce57a6:         if (txid.isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
1:1595378:             theStore.store(new KahaPrepareCommand().setTransactionInfo(info), true, null, null);
1:4ce57a6:         } else {
1:4ce57a6:             Tx tx = inflightTransactions.remove(txid);
1:4ce57a6:             if (tx != null) {
1:1595378:                theStore.store(new KahaPrepareCommand().setTransactionInfo(info), true, null, null);
1:46e2e6e:             }
1:4ce57a6:         }
1:4ce57a6:     }
1:27262c8: 
1:27262c8:     public Tx getTx(Object txid) {
1:8e61f51:         Tx tx = inflightTransactions.get(txid);
1:27262c8:         if (tx == null) {
1:6da08b2:             synchronized (inflightTransactions) {
1:6da08b2:                 tx = inflightTransactions.get(txid);
1:6da08b2:                 if (tx == null) {
1:6da08b2:                     tx = new Tx();
1:6da08b2:                     inflightTransactions.put(txid, tx);
1:6da08b2:                 }
1:6da08b2:             }
1:8e61f51:         }
1:27262c8:         return tx;
1:27262c8:     }
1:27262c8: 
1:9ef4259:     @Override
1:54e2e3b:     public void commit(TransactionId txid, boolean wasPrepared, final Runnable preCommit, Runnable postCommit)
1:27262c8:             throws IOException {
1:27262c8:         if (txid != null) {
1:7a5abeb:             if (!txid.isXATransaction() && theStore.isConcurrentStoreAndDispatchTransactions()) {
1:54e2e3b:                 if (preCommit != null) {
1:54e2e3b:                     preCommit.run();
1:54e2e3b:                 }
1:27262c8:                 Tx tx = inflightTransactions.remove(txid);
1:8e61f51:                 if (tx != null) {
1:27262c8:                     List<Future<Object>> results = tx.commit();
1:27262c8:                     boolean doneSomething = false;
1:27262c8:                     for (Future<Object> result : results) {
1:27262c8:                         try {
1:27262c8:                             result.get();
1:27262c8:                         } catch (InterruptedException e) {
1:37b7d9c:                             theStore.brokerService.handleIOException(new IOException(e.getMessage()));
1:27262c8:                         } catch (ExecutionException e) {
1:37b7d9c:                             theStore.brokerService.handleIOException(new IOException(e.getMessage()));
1:1595378:                         }catch(CancellationException e) {
1:27262c8:                         }
1:27262c8:                         if (!result.isCancelled()) {
1:27262c8:                             doneSomething = true;
1:27262c8:                         }
1:27262c8:                     }
1:27262c8:                     if (postCommit != null) {
1:27262c8:                         postCommit.run();
1:27262c8:                     }
1:27262c8:                     if (doneSomething) {
1:27262c8:                         KahaTransactionInfo info = getTransactionInfo(txid);
1:79ba2a7:                         theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, null);
1:8e61f51:                     }
1:1595378:                 }else {
1:27262c8:                     //The Tx will be null for failed over clients - lets run their post commits
1:27262c8:                     if (postCommit != null) {
1:27262c8:                         postCommit.run();
1:27262c8:                     }
1:27262c8:                 }
1:27262c8: 
1:8e61f51:             } else {
1:27262c8:                 KahaTransactionInfo info = getTransactionInfo(txid);
1:27262c8:                 if (preCommit != null) {
1:27262c8:                     preCommit.run();
1:27262c8:                 }
1:54e2e3b:                 theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, postCommit);
1:cfe099d:                 forgetRecoveredAcks(txid, false);
1:27262c8:             }
1:1595378:         }else {
1:1595378:            LOG.error("Null transaction passed on commit");
1:27262c8:         }
1:27262c8:     }
1:27262c8: 
1:27262c8:     /**
1:1595378:      * @throws IOException
1:27262c8:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:27262c8:      */
1:9ef4259:     @Override
1:27262c8:     public void rollback(TransactionId txid) throws IOException {
1:1aa6cbc:         if (txid.isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
1:27262c8:             KahaTransactionInfo info = getTransactionInfo(txid);
1:79ba2a7:             theStore.store(new KahaRollbackCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, null);
1:cfe099d:             forgetRecoveredAcks(txid, true);
1:8e61f51:         } else {
1:7a5abeb:             inflightTransactions.remove(txid);
1:8e61f51:         }
1:8e61f51:     }
1:27262c8: 
1:cfe099d:     protected void forgetRecoveredAcks(TransactionId txid, boolean isRollback) throws IOException {
1:101e711:         if (txid.isXATransaction()) {
1:101e711:             XATransactionId xaTid = ((XATransactionId) txid);
1:cfe099d:             theStore.forgetRecoveredAcks(xaTid.getPreparedAcks(), isRollback);
1:101e711:         }
1:101e711:     }
1:101e711: 
1:27262c8:     @Override
1:27262c8:     public void start() throws Exception {
1:8e61f51:     }
1:27262c8: 
1:9ef4259:     @Override
1:27262c8:     public void stop() throws Exception {
1:27262c8:     }
1:27262c8: 
1:9ef4259:     @Override
1:27262c8:     public synchronized void recover(TransactionRecoveryListener listener) throws IOException {
1:b1d7a78:         for (Map.Entry<TransactionId, List<Operation>> entry : theStore.preparedTransactions.entrySet()) {
1:27262c8:             XATransactionId xid = (XATransactionId) entry.getKey();
1:27262c8:             ArrayList<Message> messageList = new ArrayList<Message>();
1:27262c8:             ArrayList<MessageAck> ackList = new ArrayList<MessageAck>();
1:27262c8: 
1:27262c8:             for (Operation op : entry.getValue()) {
1:54e2e3b:                 if (op.getClass() == MessageDatabase.AddOperation.class) {
1:54e2e3b:                     MessageDatabase.AddOperation addOp = (MessageDatabase.AddOperation) op;
1:ec9975c:                     Message msg = (Message) wireFormat().unmarshal(new DataInputStream(addOp.getCommand().getMessage()
1:27262c8:                             .newInput()));
1:27262c8:                     messageList.add(msg);
3:27262c8:                 } else {
1:54e2e3b:                     MessageDatabase.RemoveOperation rmOp = (MessageDatabase.RemoveOperation) op;
1:27262c8:                     Buffer ackb = rmOp.getCommand().getAck();
1:ec9975c:                     MessageAck ack = (MessageAck) wireFormat().unmarshal(new DataInputStream(ackb.newInput()));
1:27262c8:                     ackList.add(ack);
1:27262c8:                 }
1:27262c8:             }
1:27262c8: 
1:27262c8:             Message[] addedMessages = new Message[messageList.size()];
1:27262c8:             MessageAck[] acks = new MessageAck[ackList.size()];
1:27262c8:             messageList.toArray(addedMessages);
1:27262c8:             ackList.toArray(acks);
1:101e711:             xid.setPreparedAcks(ackList);
1:101e711:             theStore.trackRecoveredAcks(ackList);
1:27262c8:             listener.recover(xid, addedMessages, acks);
1:27262c8:         }
1:27262c8:     }
1:27262c8: 
1:27262c8:     /**
1:27262c8:      * @param message
4:27262c8:      * @throws IOException
1:27262c8:      */
1:27262c8:     void addMessage(ConnectionContext context, final MessageStore destination, final Message message)
1:27262c8:             throws IOException {
1:27262c8: 
1:27262c8:         if (message.getTransactionId() != null) {
1:8e61f51:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
1:7a5abeb:                 destination.addMessage(context, message);
1:27262c8:             } else {
1:27262c8:                 Tx tx = getTx(message.getTransactionId());
1:27262c8:                 tx.add(new AddMessageCommand(context) {
1:27262c8:                     @Override
1:27262c8:                     public Message getMessage() {
1:27262c8:                         return message;
1:27262c8:                     }
1:27262c8:                     @Override
1:2030097:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:27262c8:                         destination.addMessage(ctx, message);
1:7a5abeb:                         return AbstractMessageStore.FUTURE;
1:27262c8:                     }
1:8e61f51: 
1:27262c8:                 });
1:27262c8:             }
1:27262c8:         } else {
1:27262c8:             destination.addMessage(context, message);
1:27262c8:         }
1:27262c8:     }
1:8e61f51: 
1:ad1f751:     ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, final MessageStore destination, final Message message)
1:27262c8:             throws IOException {
1:8e61f51: 
1:27262c8:         if (message.getTransactionId() != null) {
1:7a5abeb:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
1:27262c8:                 destination.addMessage(context, message);
2:27262c8:                 return AbstractMessageStore.FUTURE;
1:27262c8:             } else {
1:27262c8:                 Tx tx = getTx(message.getTransactionId());
1:27262c8:                 tx.add(new AddMessageCommand(context) {
1:27262c8:                     @Override
1:27262c8:                     public Message getMessage() {
1:27262c8:                         return message;
1:27262c8:                     }
1:27262c8:                     @Override
1:27262c8:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:27262c8:                         return destination.asyncAddQueueMessage(ctx, message);
1:27262c8:                     }
1:27262c8: 
1:27262c8:                 });
1:27262c8:                 return AbstractMessageStore.FUTURE;
1:27262c8:             }
1:27262c8:         } else {
2:27262c8:             return destination.asyncAddQueueMessage(context, message);
1:27262c8:         }
1:27262c8:     }
1:27262c8: 
1:ad1f751:     ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, final MessageStore destination, final Message message)
1:27262c8:             throws IOException {
1:27262c8: 
1:27262c8:         if (message.getTransactionId() != null) {
1:1595378:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()==false) {
1:7a5abeb:                 destination.addMessage(context, message);
1:7a5abeb:                 return AbstractMessageStore.FUTURE;
1:27262c8:             } else {
1:27262c8:                 Tx tx = getTx(message.getTransactionId());
1:27262c8:                 tx.add(new AddMessageCommand(context) {
1:27262c8:                     @Override
1:27262c8:                     public Message getMessage() {
1:27262c8:                         return message;
1:27262c8:                     }
1:27262c8:                     @Override
1:27262c8:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:27262c8:                         return destination.asyncAddTopicMessage(ctx, message);
1:27262c8:                     }
1:27262c8: 
1:27262c8:                 });
1:27262c8:                 return AbstractMessageStore.FUTURE;
1:27262c8:             }
1:27262c8:         } else {
2:27262c8:             return destination.asyncAddTopicMessage(context, message);
1:27262c8:         }
1:27262c8:     }
1:27262c8: 
1:27262c8:     /**
1:27262c8:      * @param ack
1:27262c8:      * @throws IOException
1:27262c8:      */
1:27262c8:     final void removeMessage(ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:27262c8:             throws IOException {
1:27262c8: 
1:27262c8:         if (ack.isInTransaction()) {
1:1595378:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {
1:2030097:                 destination.removeMessage(context, ack);
1:27262c8:             } else {
1:27262c8:                 Tx tx = getTx(ack.getTransactionId());
1:27262c8:                 tx.add(new RemoveMessageCommand(context) {
1:9ef4259:                     @Override
1:27262c8:                     public MessageAck getMessageAck() {
1:27262c8:                         return ack;
1:88c1084:                     }
1:27262c8: 
1:9ef4259:                     @Override
1:27262c8:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:27262c8:                         destination.removeMessage(ctx, ack);
1:27262c8:                         return AbstractMessageStore.FUTURE;
1:27262c8:                     }
1:27262c8:                 });
1:27262c8:             }
1:27262c8:         } else {
2:27262c8:             destination.removeMessage(context, ack);
1:27262c8:         }
1:27262c8:     }
1:27262c8: 
1:27262c8:     final void removeAsyncMessage(ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:27262c8:             throws IOException {
1:27262c8: 
1:27262c8:         if (ack.isInTransaction()) {
1:1595378:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()==false) {
1:2398a3a:                 destination.removeAsyncMessage(context, ack);
1:27262c8:             } else {
1:27262c8:                 Tx tx = getTx(ack.getTransactionId());
1:27262c8:                 tx.add(new RemoveMessageCommand(context) {
1:27262c8:                     @Override
1:27262c8:                     public MessageAck getMessageAck() {
1:27262c8:                         return ack;
1:27262c8:                     }
1:27262c8: 
1:27262c8:                     @Override
1:27262c8:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:27262c8:                         destination.removeMessage(ctx, ack);
1:27262c8:                         return AbstractMessageStore.FUTURE;
1:27262c8:                     }
1:27262c8:                 });
1:27262c8:             }
1:27262c8:         } else {
2:27262c8:             destination.removeAsyncMessage(context, ack);
1:27262c8:         }
1:27262c8:     }
1:27262c8: 
1:88c1084:     final void acknowledge(ConnectionContext context, final TopicMessageStore destination, final String clientId, final String subscriptionName,
1:88c1084:                            final MessageId messageId, final MessageAck ack) throws IOException {
1:88c1084: 
1:88c1084:         if (ack.isInTransaction()) {
1:1595378:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {
1:88c1084:                 destination.acknowledge(context, clientId, subscriptionName, messageId, ack);
1:88c1084:             } else {
1:88c1084:                 Tx tx = getTx(ack.getTransactionId());
1:88c1084:                 tx.add(new RemoveMessageCommand(context) {
1:27262c8:                     @Override
1:88c1084:                     public MessageAck getMessageAck() {
1:88c1084:                         return ack;
1:88c1084:                     }
1:88c1084: 
1:27262c8:                     @Override
1:88c1084:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:88c1084:                         destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);
1:88c1084:                         return AbstractMessageStore.FUTURE;
1:88c1084:                     }
1:88c1084:                 });
1:88c1084:             }
1:88c1084:         } else {
1:88c1084:             destination.acknowledge(context, clientId, subscriptionName, messageId, ack);
1:88c1084:         }
1:27262c8:     }
1:88c1084: 
1:88c1084: 
1:27262c8:     private KahaTransactionInfo getTransactionInfo(TransactionId txid) {
1:21fe8ca:         return TransactionIdConversion.convert(theStore.getTransactionIdTransformer().transform(txid));
1:27262c8:     }
1:27262c8: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:6da08b2
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1:         private final List<AddMessageCommand> messages = Collections.synchronizedList(new ArrayList<AddMessageCommand>());
1:         private final List<RemoveMessageCommand> acks = Collections.synchronizedList(new ArrayList<RemoveMessageCommand>());
/////////////////////////////////////////////////////////////////////////
1:             synchronized (inflightTransactions) {
1:                 tx = inflightTransactions.get(txid);
1:                 if (tx == null) {
1:                     tx = new Tx();
1:                     inflightTransactions.put(txid, tx);
1:                 }
1:             }
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void commit(TransactionId txid, boolean wasPrepared, final Runnable preCommit, Runnable postCommit)
/////////////////////////////////////////////////////////////////////////
1:                 if (preCommit != null) {
1:                     preCommit.run();
1:                 }
1:                 theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, postCommit);
/////////////////////////////////////////////////////////////////////////
1:                 if (op.getClass() == MessageDatabase.AddOperation.class) {
1:                     MessageDatabase.AddOperation addOp = (MessageDatabase.AddOperation) op;
1:                     MessageDatabase.RemoveOperation rmOp = (MessageDatabase.RemoveOperation) op;
commit:ad1f751
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.ListenableFuture;
/////////////////////////////////////////////////////////////////////////
1:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
1:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, final MessageStore destination, final Message message)
/////////////////////////////////////////////////////////////////////////
1:     ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, final MessageStore destination, final Message message)
commit:79ba2a7
/////////////////////////////////////////////////////////////////////////
1:                         theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, null);
/////////////////////////////////////////////////////////////////////////
0:                 theStore.store(new KahaCommitCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), preCommit, postCommit);
/////////////////////////////////////////////////////////////////////////
1:             theStore.store(new KahaRollbackCommand().setTransactionInfo(info), theStore.isEnableJournalDiskSyncs(), null, null);
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1:                 forgetRecoveredAcks(txid, false);
/////////////////////////////////////////////////////////////////////////
1:             forgetRecoveredAcks(txid, true);
1:     protected void forgetRecoveredAcks(TransactionId txid, boolean isRollback) throws IOException {
1:             theStore.forgetRecoveredAcks(xaTid.getPreparedAcks(), isRollback);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:     ConcurrentMap<Object, Tx> inflightTransactions = new ConcurrentHashMap<Object, Tx>();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                     @Override
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:21fe8ca
/////////////////////////////////////////////////////////////////////////
1:         return TransactionIdConversion.convert(theStore.getTransactionIdTransformer().transform(txid));
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
1:     private WireFormat wireFormat(){
1:       return this.theStore.wireFormat;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     Message msg = (Message) wireFormat().unmarshal(new DataInputStream(addOp.getCommand().getMessage()
1:                     MessageAck ack = (MessageAck) wireFormat().unmarshal(new DataInputStream(ackb.newInput()));
commit:c5cf038
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:d40f398
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
1:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
1:                 return KahaDBTransactionStore.this.asyncAddQueueMessage(context, getDelegate(), message);
1:             }
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
1:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
1:                 return KahaDBTransactionStore.this.asyncAddTopicMessage(context, getDelegate(), message);
1:             }
1: 
1:             @Override
author:Gary Tully
-------------------------------------------------------------------------------
commit:2398a3a
/////////////////////////////////////////////////////////////////////////
1:                 destination.removeAsyncMessage(context, ack);
commit:2030097
/////////////////////////////////////////////////////////////////////////
1:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                 destination.removeMessage(context, ack);
commit:1595378
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * 
/////////////////////////////////////////////////////////////////////////
1: 
1:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:          * @throws IOException
1:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:             
/////////////////////////////////////////////////////////////////////////
1:                             MessageId messageId, MessageAck ack) throws IOException {
1:                 KahaDBTransactionStore.this.acknowledge(context, (TopicMessageStore)getDelegate(), clientId,
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException
1:             theStore.store(new KahaPrepareCommand().setTransactionInfo(info), true, null, null);
1:                theStore.store(new KahaPrepareCommand().setTransactionInfo(info), true, null, null);
/////////////////////////////////////////////////////////////////////////
1:                         }catch(CancellationException e) {
/////////////////////////////////////////////////////////////////////////
0:                         theStore.store(new KahaCommitCommand().setTransactionInfo(info), true, null, null);
1:                 }else {
/////////////////////////////////////////////////////////////////////////
0:                 theStore.store(new KahaCommitCommand().setTransactionInfo(info), true, preCommit, postCommit);
0:                 forgetRecoveredAcks(txid);
1:         }else {
1:            LOG.error("Null transaction passed on commit");
1:      * @throws IOException
0:             theStore.store(new KahaRollbackCommand().setTransactionInfo(info), false, null, null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()==false) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {
/////////////////////////////////////////////////////////////////////////
1:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()==false) {
/////////////////////////////////////////////////////////////////////////
1:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {
/////////////////////////////////////////////////////////////////////////
0:         return theStore.getTransactionIdTransformer().transform(txid);
commit:c6ed5ff
/////////////////////////////////////////////////////////////////////////
commit:101e711
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     forgetRecoveredAcks(txid);
/////////////////////////////////////////////////////////////////////////
0:             forgetRecoveredAcks(txid);
0:     protected void forgetRecoveredAcks(TransactionId txid) throws IOException {
1:         if (txid.isXATransaction()) {
1:             XATransactionId xaTid = ((XATransactionId) txid);
0:             theStore.forgetRecoveredAcks(xaTid.getPreparedAcks());
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             xid.setPreparedAcks(ackList);
1:             theStore.trackRecoveredAcks(ackList);
commit:88c1084
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
1: 
1:             @Override
1:             public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
0:                             MessageId messageId, MessageAck ack) throws IOException {
0:                 KahaDBTransactionStore.this.acknowledge(context, (TopicMessageStore)getDelegate(), clientId,
1:                         subscriptionName, messageId, ack);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     final void acknowledge(ConnectionContext context, final TopicMessageStore destination, final String clientId, final String subscriptionName,
1:                            final MessageId messageId, final MessageAck ack) throws IOException {
1: 
1:         if (ack.isInTransaction()) {
0:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {
1:                 destination.acknowledge(context, clientId, subscriptionName, messageId, ack);
1:             } else {
1:                 Tx tx = getTx(ack.getTransactionId());
1:                 tx.add(new RemoveMessageCommand(context) {
1:                     public MessageAck getMessageAck() {
1:                         return ack;
1:                     }
1: 
1:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:                         destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);
1:                         return AbstractMessageStore.FUTURE;
1:                     }
1:                 });
1:             }
1:         } else {
1:             destination.acknowledge(context, clientId, subscriptionName, messageId, ack);
1:         }
1:     }
1: 
1: 
commit:46e2e6e
/////////////////////////////////////////////////////////////////////////
0:                 // ensure message order w.r.t to cursor and store for setBatch()
0:                 synchronized (this) {
0:                     theStore.store(new KahaCommitCommand().setTransactionInfo(info), true, preCommit, postCommit);
1:                 }
commit:0af6b06
/////////////////////////////////////////////////////////////////////////
commit:b1d7a78
/////////////////////////////////////////////////////////////////////////
1:         for (Map.Entry<TransactionId, List<Operation>> entry : theStore.preparedTransactions.entrySet()) {
author:Willem Ning Jiang
-------------------------------------------------------------------------------
commit:4ce57a6
/////////////////////////////////////////////////////////////////////////
1:         if (txid.isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
0:             for (Journal journal : theStore.getJournalManager().getJournals()) {
1:         } else {
1:             Tx tx = inflightTransactions.remove(txid);
1:             if (tx != null) {
0:                 for (Journal journal : theStore.getJournalManager().getJournals(tx.destinations)) {
0:                     theStore.store(journal, new KahaPrepareCommand().setTransactionInfo(info), true, null, null);
1:                 }
1:             }
author:Robert Davies
-------------------------------------------------------------------------------
commit:8e61f51
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.journal.Journal;
/////////////////////////////////////////////////////////////////////////
0:         private final HashSet<ActiveMQDestination> destinations = new HashSet<ActiveMQDestination>();
0:             destinations.add(msg.getMessage().getDestination());
0:             destinations.add(ack.getMessageAck().getDestination());
0:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext(); ) {
0:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext(); ) {
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                                     MessageId messageId, MessageAck ack) throws IOException {
0:                 KahaDBTransactionStore.this.acknowledge(context, (TopicMessageStore) getDelegate(), clientId,
/////////////////////////////////////////////////////////////////////////
1:         Tx tx = inflightTransactions.get(txid);
1:         if (tx != null) {
0:             for (Journal journal : theStore.getJournalManager().getJournals(tx.destinations)) {
0:                 theStore.store(journal, new KahaPrepareCommand().setTransactionInfo(info), true, null, null);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:                         } catch (CancellationException e) {
/////////////////////////////////////////////////////////////////////////
0:                         for (Journal journal : theStore.getJournalManager().getJournals(tx.destinations)) {
0:                             theStore.store(journal, new KahaCommitCommand().setTransactionInfo(info), true, null, null);
1:                         }
1:                 } else {
/////////////////////////////////////////////////////////////////////////
0:                     for (Journal journal : theStore.getJournalManager().getJournals()) {
0:                         theStore.store(journal, new KahaCommitCommand().setTransactionInfo(info), true, preCommit, postCommit);
1:                     }
1:         } else {
0:             LOG.error("Null transaction passed on commit");
0:             for (Journal journal : theStore.getJournalManager().getJournals()) {
0:                 theStore.store(journal, new KahaRollbackCommand().setTransactionInfo(info), false, null, null);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
/////////////////////////////////////////////////////////////////////////
0:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
/////////////////////////////////////////////////////////////////////////
0:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
commit:ddb2c91
/////////////////////////////////////////////////////////////////////////
commit:1999d94
/////////////////////////////////////////////////////////////////////////
1:                 return KahaDBTransactionStore.this.asyncAddTopicMessage(context, getDelegate(), message);
commit:37b7d9c
/////////////////////////////////////////////////////////////////////////
1:                             theStore.brokerService.handleIOException(new IOException(e.getMessage()));
1:                             theStore.brokerService.handleIOException(new IOException(e.getMessage()));
commit:7a5abeb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     static final Log LOG = LogFactory.getLog(KahaDBTransactionStore.class);
/////////////////////////////////////////////////////////////////////////
1:             if (!txid.isXATransaction() && theStore.isConcurrentStoreAndDispatchTransactions()) {
/////////////////////////////////////////////////////////////////////////
0:         }else {
0:            LOG.error("Null transaction passed on commit");
/////////////////////////////////////////////////////////////////////////
0:         if (txid.isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()) {
1:             inflightTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
/////////////////////////////////////////////////////////////////////////
0:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
1:                 destination.addMessage(context, message);
1:                 return AbstractMessageStore.FUTURE;
/////////////////////////////////////////////////////////////////////////
0:             if (message.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()==false) {
1:                 destination.addMessage(context, message);
1:                 return AbstractMessageStore.FUTURE;
/////////////////////////////////////////////////////////////////////////
0:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()== false) {
/////////////////////////////////////////////////////////////////////////
0:             if (ack.getTransactionId().isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions()==false) {
commit:27262c8
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.kahadb;
1: 
1: import java.io.DataInputStream;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.CancellationException;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ExecutionException;
1: import java.util.concurrent.Future;
0: import javax.transaction.xa.XAException;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.XATransactionId;
0: import org.apache.activemq.openwire.OpenWireFormat;
1: import org.apache.activemq.protobuf.Buffer;
1: import org.apache.activemq.store.AbstractMessageStore;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.ProxyMessageStore;
1: import org.apache.activemq.store.ProxyTopicMessageStore;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionRecoveryListener;
1: import org.apache.activemq.store.TransactionStore;
0: import org.apache.activemq.store.kahadb.MessageDatabase.AddOpperation;
1: import org.apache.activemq.store.kahadb.MessageDatabase.Operation;
0: import org.apache.activemq.store.kahadb.MessageDatabase.RemoveOpperation;
1: import org.apache.activemq.store.kahadb.data.KahaCommitCommand;
1: import org.apache.activemq.store.kahadb.data.KahaPrepareCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRollbackCommand;
1: import org.apache.activemq.store.kahadb.data.KahaTransactionInfo;
1: import org.apache.activemq.wireformat.WireFormat;
1: 
1: /**
1:  * Provides a TransactionStore implementation that can create transaction aware
1:  * MessageStore objects from non transaction aware MessageStore objects.
0:  * 
0:  * @version $Revision: 1.4 $
1:  */
1: public class KahaDBTransactionStore implements TransactionStore {
1: 
0:     ConcurrentHashMap<Object, Tx> inflightTransactions = new ConcurrentHashMap<Object, Tx>();
0:     private final WireFormat wireFormat = new OpenWireFormat();
1:     private final KahaDBStore theStore;
1: 
1:     public KahaDBTransactionStore(KahaDBStore theStore) {
1:         this.theStore = theStore;
1:     }
1: 
1:     public class Tx {
0:         private final ArrayList<AddMessageCommand> messages = new ArrayList<AddMessageCommand>();
1: 
0:         private final ArrayList<RemoveMessageCommand> acks = new ArrayList<RemoveMessageCommand>();
1: 
1:         public void add(AddMessageCommand msg) {
1:             messages.add(msg);
1:         }
1: 
1:         public void add(RemoveMessageCommand ack) {
1:             acks.add(ack);
1:         }
1: 
1:         public Message[] getMessages() {
1:             Message rc[] = new Message[messages.size()];
1:             int count = 0;
0:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:                 AddMessageCommand cmd = iter.next();
1:                 rc[count++] = cmd.getMessage();
1:             }
1:             return rc;
1:         }
1: 
1:         public MessageAck[] getAcks() {
1:             MessageAck rc[] = new MessageAck[acks.size()];
1:             int count = 0;
0:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:                 RemoveMessageCommand cmd = iter.next();
1:                 rc[count++] = cmd.getMessageAck();
1:             }
1:             return rc;
1:         }
1: 
1:         /**
1:          * @return true if something to commit
1:          * @throws IOException
1:          */
1:         public List<Future<Object>> commit() throws IOException {
1:             List<Future<Object>> results = new ArrayList<Future<Object>>();
1:             // Do all the message adds.
0:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:                 AddMessageCommand cmd = iter.next();
1:                 results.add(cmd.run());
1: 
1:             }
1:             // And removes..
0:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:                 RemoveMessageCommand cmd = iter.next();
1:                 cmd.run();
1:                 results.add(cmd.run());
1:             }
1:             
1:             return results;
1:         }
1:     }
1: 
1:     public abstract class AddMessageCommand {
1:         private final ConnectionContext ctx;
1:         AddMessageCommand(ConnectionContext ctx) {
1:             this.ctx = ctx;
1:         }
1:         abstract Message getMessage();
1:         Future<Object> run() throws IOException {
1:             return run(this.ctx);
1:         }
1:         abstract Future<Object> run(ConnectionContext ctx) throws IOException;
1:     }
1: 
1:     public abstract class RemoveMessageCommand {
1: 
1:         private final ConnectionContext ctx;
1:         RemoveMessageCommand(ConnectionContext ctx) {
1:             this.ctx = ctx;
1:         }
1:         abstract MessageAck getMessageAck();
1:         Future<Object> run() throws IOException {
1:             return run(this.ctx);
1:         }
1:         abstract Future<Object> run(ConnectionContext context) throws IOException;
1:     }
1: 
1:     public MessageStore proxy(MessageStore messageStore) {
1:         return new ProxyMessageStore(messageStore) {
1:             @Override
1:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:                 return KahaDBTransactionStore.this.asyncAddQueueMessage(context, getDelegate(), message);
1:             }
1: 
1:             @Override
1:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:                 KahaDBTransactionStore.this.removeMessage(context, getDelegate(), ack);
1:             }
1: 
1:             @Override
1:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:                 KahaDBTransactionStore.this.removeAsyncMessage(context, getDelegate(), ack);
1:             }
1:         };
1:     }
1: 
1:     public TopicMessageStore proxy(TopicMessageStore messageStore) {
1:         return new ProxyTopicMessageStore(messageStore) {
1:             @Override
1:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:                 KahaDBTransactionStore.this.addMessage(context, getDelegate(), send);
1:             }
1: 
1:             @Override
0:             public Future<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
0:                 KahaDBTransactionStore.this.asyncAddTopicMessage(context, getDelegate(), message);
1:                 return AbstractMessageStore.FUTURE;
1:             }
1: 
1:             @Override
1:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:                 KahaDBTransactionStore.this.removeMessage(context, getDelegate(), ack);
1:             }
1: 
1:             @Override
1:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:                 KahaDBTransactionStore.this.removeAsyncMessage(context, getDelegate(), ack);
1:             }
1:         };
1:     }
1: 
1:     /**
1:      * @throws IOException
1:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:      */
1:     public void prepare(TransactionId txid) throws IOException {
0:         inflightTransactions.remove(txid);
1:         KahaTransactionInfo info = getTransactionInfo(txid);
0:         theStore.store(new KahaPrepareCommand().setTransactionInfo(info), true, null, null);
1:     }
1: 
1:     public Tx getTx(Object txid) {
0:         Tx tx = inflightTransactions.get(txid);
1:         if (tx == null) {
0:             tx = new Tx();
0:             inflightTransactions.put(txid, tx);
1:         }
1:         return tx;
1:     }
1: 
1:     /**
0:      * @throws XAException
0:      * @see org.apache.activemq.store.TransactionStore#commit(org.apache.activemq.service.Transaction)
1:      */
0:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit, Runnable postCommit)
1:             throws IOException {
1:         if (txid != null) {
0:             if (!txid.isXATransaction()) {
1:                 if (preCommit != null) {
1:                     preCommit.run();
1:                 }
1:                 Tx tx = inflightTransactions.remove(txid);
0:                 if (tx != null) {
1:                     List<Future<Object>> results = tx.commit();
1:                     boolean doneSomething = false;
1:                     for (Future<Object> result : results) {
1:                         try {
1:                             result.get();
1:                         } catch (InterruptedException e) {
0:                             theStore.brokerService.handleIOException(new IOException(e));
1:                         } catch (ExecutionException e) {
0:                             theStore.brokerService.handleIOException(new IOException(e));
0:                         }catch(CancellationException e) {
1:                         }
1:                         if (!result.isCancelled()) {
1:                             doneSomething = true;
1:                         }
1:                     }
1:                    
1:                     if (postCommit != null) {
1:                         postCommit.run();
1:                     }
1:                     if (doneSomething) {
1:                         KahaTransactionInfo info = getTransactionInfo(txid);
0:                         theStore.store(new KahaCommitCommand().setTransactionInfo(info), true, null, null);
1:                     }
0:                 }else {
1:                     //The Tx will be null for failed over clients - lets run their post commits
1:                     if (postCommit != null) {
1:                         postCommit.run();
1:                     }
1:                 }
1: 
1:             } else {
1:                 KahaTransactionInfo info = getTransactionInfo(txid);
0:                 theStore.store(new KahaCommitCommand().setTransactionInfo(info), true, preCommit, postCommit);
1:             }
1: 
1:         }
1:     }
1: 
1:     /**
1:      * @throws IOException
1:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:      */
1:     public void rollback(TransactionId txid) throws IOException {
0:         if (txid.isXATransaction()) {
1:             KahaTransactionInfo info = getTransactionInfo(txid);
0:             theStore.store(new KahaRollbackCommand().setTransactionInfo(info), false, null, null);
1:         } else {
0:             Object result = inflightTransactions.remove(txid);
1:         }
1:     }
1: 
1:     public void start() throws Exception {
1:     }
1: 
1:     public void stop() throws Exception {
1:     }
1: 
1:     public synchronized void recover(TransactionRecoveryListener listener) throws IOException {
0:         // All the inflight transactions get rolled back..
0:         // inflightTransactions.clear();
0:         for (Map.Entry<TransactionId, ArrayList<Operation>> entry : theStore.preparedTransactions.entrySet()) {
1:             XATransactionId xid = (XATransactionId) entry.getKey();
1:             ArrayList<Message> messageList = new ArrayList<Message>();
1:             ArrayList<MessageAck> ackList = new ArrayList<MessageAck>();
1: 
1:             for (Operation op : entry.getValue()) {
0:                 if (op.getClass() == AddOpperation.class) {
0:                     AddOpperation addOp = (AddOpperation) op;
0:                     Message msg = (Message) wireFormat.unmarshal(new DataInputStream(addOp.getCommand().getMessage()
1:                             .newInput()));
1:                     messageList.add(msg);
1:                 } else {
0:                     RemoveOpperation rmOp = (RemoveOpperation) op;
1:                     Buffer ackb = rmOp.getCommand().getAck();
0:                     MessageAck ack = (MessageAck) wireFormat.unmarshal(new DataInputStream(ackb.newInput()));
1:                     ackList.add(ack);
1:                 }
1:             }
1: 
1:             Message[] addedMessages = new Message[messageList.size()];
1:             MessageAck[] acks = new MessageAck[ackList.size()];
1:             messageList.toArray(addedMessages);
1:             ackList.toArray(acks);
1:             listener.recover(xid, addedMessages, acks);
1:         }
1:     }
1: 
1:     /**
1:      * @param message
1:      * @throws IOException
1:      */
1:     void addMessage(ConnectionContext context, final MessageStore destination, final Message message)
1:             throws IOException {
1: 
1:         if (message.getTransactionId() != null) {
0:             if (message.getTransactionId().isXATransaction()) {
1:                 destination.addMessage(context, message);
1:             } else {
1:                 Tx tx = getTx(message.getTransactionId());
1:                 tx.add(new AddMessageCommand(context) {
1:                     @Override
1:                     public Message getMessage() {
1:                         return message;
1:                     }
1:                     @Override
1:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:                         destination.addMessage(ctx, message);
1:                         return AbstractMessageStore.FUTURE;
1:                     }
1: 
1:                 });
1:             }
1:         } else {
1:             destination.addMessage(context, message);
1:         }
1:     }
1: 
0:     Future<Object> asyncAddQueueMessage(ConnectionContext context, final MessageStore destination, final Message message)
1:             throws IOException {
1: 
1:         if (message.getTransactionId() != null) {
0:             if (message.getTransactionId().isXATransaction()) {
1:                 return destination.asyncAddQueueMessage(context, message);
1:             } else {
1:                 Tx tx = getTx(message.getTransactionId());
1:                 tx.add(new AddMessageCommand(context) {
1:                     @Override
1:                     public Message getMessage() {
1:                         return message;
1:                     }
1:                     @Override
1:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:                         return destination.asyncAddQueueMessage(ctx, message);
1:                     }
1: 
1:                 });
1:                 return AbstractMessageStore.FUTURE;
1:             }
1:         } else {
1:             return destination.asyncAddQueueMessage(context, message);
1:         }
1:     }
1: 
0:     Future<Object> asyncAddTopicMessage(ConnectionContext context, final MessageStore destination, final Message message)
1:             throws IOException {
1: 
1:         if (message.getTransactionId() != null) {
0:             if (message.getTransactionId().isXATransaction()) {
1:                 return destination.asyncAddTopicMessage(context, message);
1:             } else {
1:                 Tx tx = getTx(message.getTransactionId());
1:                 tx.add(new AddMessageCommand(context) {
1:                     @Override
1:                     public Message getMessage() {
1:                         return message;
1:                     }
1:                     @Override
0:                     public Future run(ConnectionContext ctx) throws IOException {
1:                         return destination.asyncAddTopicMessage(ctx, message);
1:                     }
1: 
1:                 });
1:                 return AbstractMessageStore.FUTURE;
1:             }
1:         } else {
1:             return destination.asyncAddTopicMessage(context, message);
1:         }
1:     }
1: 
1:     /**
1:      * @param ack
1:      * @throws IOException
1:      */
1:     final void removeMessage(ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:             throws IOException {
1: 
1:         if (ack.isInTransaction()) {
0:             if (ack.getTransactionId().isXATransaction()) {
1:                 destination.removeMessage(context, ack);
1:             } else {
1:                 Tx tx = getTx(ack.getTransactionId());
1:                 tx.add(new RemoveMessageCommand(context) {
1:                     @Override
1:                     public MessageAck getMessageAck() {
1:                         return ack;
1:                     }
1: 
1:                     @Override
1:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:                         destination.removeMessage(ctx, ack);
1:                         return AbstractMessageStore.FUTURE;
1:                     }
1:                 });
1:             }
1:         } else {
1:             destination.removeMessage(context, ack);
1:         }
1:     }
1: 
1:     final void removeAsyncMessage(ConnectionContext context, final MessageStore destination, final MessageAck ack)
1:             throws IOException {
1: 
1:         if (ack.isInTransaction()) {
0:             if (ack.getTransactionId().isXATransaction()) {
1:                 destination.removeAsyncMessage(context, ack);
1:             } else {
1:                 Tx tx = getTx(ack.getTransactionId());
1:                 tx.add(new RemoveMessageCommand(context) {
1:                     @Override
1:                     public MessageAck getMessageAck() {
1:                         return ack;
1:                     }
1: 
1:                     @Override
1:                     public Future<Object> run(ConnectionContext ctx) throws IOException {
1:                         destination.removeMessage(ctx, ack);
1:                         return AbstractMessageStore.FUTURE;
1:                     }
1:                 });
1:             }
1:         } else {
1:             destination.removeAsyncMessage(context, ack);
1:         }
1:     }
1: 
1:     private KahaTransactionInfo getTransactionInfo(TransactionId txid) {
0:         return theStore.createTransactionInfo(txid);
1:     }
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     static final Logger LOG = LoggerFactory.getLogger(KahaDBTransactionStore.class);
commit:1aa6cbc
/////////////////////////////////////////////////////////////////////////
1:         if (txid.isXATransaction() || theStore.isConcurrentStoreAndDispatchTransactions() == false) {
============================================================================