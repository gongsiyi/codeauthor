1:61da1fa: /**
1:61da1fa:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:61da1fa:  * contributor license agreements.  See the NOTICE file distributed with
1:61da1fa:  * this work for additional information regarding copyright ownership.
1:61da1fa:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:61da1fa:  * (the "License"); you may not use this file except in compliance with
1:61da1fa:  * the License.  You may obtain a copy of the License at
1:61da1fa:  *
1:61da1fa:  * http://www.apache.org/licenses/LICENSE-2.0
1:61da1fa:  *
1:61da1fa:  * Unless required by applicable law or agreed to in writing, software
1:61da1fa:  * distributed under the License is distributed on an "AS IS" BASIS,
1:61da1fa:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:61da1fa:  * See the License for the specific language governing permissions and
1:61da1fa:  * limitations under the License.
1:61da1fa:  */
1:61da1fa: package org.apache.activemq.usecases;
6:61da1fa: 
1:61da1fa: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1:61da1fa: import org.apache.activemq.broker.BrokerPlugin;
1:61da1fa: import org.apache.activemq.broker.BrokerService;
1:61da1fa: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1:61da1fa: import org.apache.activemq.broker.jmx.VirtualDestinationSelectorCacheViewMBean;
1:61da1fa: import org.apache.activemq.broker.region.Destination;
1:61da1fa: import org.apache.activemq.broker.region.DestinationInterceptor;
1:61da1fa: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1:61da1fa: import org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor;
1:61da1fa: import org.apache.activemq.broker.region.virtual.VirtualTopic;
1:61da1fa: import org.apache.activemq.command.ActiveMQDestination;
1:61da1fa: import org.apache.activemq.command.ActiveMQQueue;
1:61da1fa: import org.apache.activemq.command.ActiveMQTopic;
1:61da1fa: import org.apache.activemq.network.NetworkConnector;
1:61da1fa: import org.apache.activemq.plugin.SubQueueSelectorCacheBrokerPlugin;
1:61da1fa: import org.apache.activemq.store.kahadb.KahaDBStore;
1:61da1fa: import org.apache.activemq.util.MessageIdList;
1:61da1fa: import org.apache.activemq.util.ProducerThread;
1:61da1fa: import org.apache.activemq.util.Wait;
1:61da1fa: import org.slf4j.Logger;
1:61da1fa: import org.slf4j.LoggerFactory;
1:61da1fa: 
1:61da1fa: import javax.jms.*;
1:61da1fa: import javax.management.MalformedObjectNameException;
1:61da1fa: import javax.management.ObjectName;
1:61da1fa: import java.io.File;
1:61da1fa: import java.io.IOException;
1:61da1fa: import java.net.URI;
1:61da1fa: import java.util.*;
1:61da1fa: import java.util.concurrent.atomic.AtomicInteger;
1:61da1fa: 
1:61da1fa: import static org.apache.activemq.TestSupport.getDestination;
1:61da1fa: 
1:61da1fa: /**
1:61da1fa:  * @author <a href="http://www.christianposta.com/blog">Christian Posta</a>
1:61da1fa:  */
1:61da1fa: public class TwoBrokerVirtualTopicSelectorAwareForwardingTest extends
1:61da1fa:         JmsMultipleBrokersTestSupport {
1:61da1fa: 
1:61da1fa:     private static final Logger LOG = LoggerFactory.getLogger(TwoBrokerVirtualTopicSelectorAwareForwardingTest.class);
1:61da1fa: 
1:61da1fa:     private static final String PERSIST_SELECTOR_CACHE_FILE_BASEPATH = "./target/selectorCache-";
1:61da1fa: 
1:61da1fa:     public void testJMX() throws Exception {
1:61da1fa:         clearSelectorCacheFiles();
1:61da1fa:         // borkerA is local and brokerB is remote
1:61da1fa:         bridgeAndConfigureBrokers("BrokerA", "BrokerB");
1:61da1fa:         startAllBrokers();
1:61da1fa:         waitForBridgeFormation();
1:61da1fa: 
1:61da1fa:         createConsumer("BrokerB", createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:61da1fa:                 "foo = 'bar'");
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1:61da1fa: 
1:61da1fa:         String testQueue = "queue://Consumer.B.VirtualTopic.tempTopic";
1:61da1fa:         VirtualDestinationSelectorCacheViewMBean cache = getVirtualDestinationSelectorCacheMBean(brokerA);
1:61da1fa:         Set<String> selectors = cache.selectorsForDestination(testQueue);
1:61da1fa: 
1:61da1fa:         assertEquals(1, selectors.size());
1:61da1fa:         assertTrue(selectors.contains("foo = 'bar'"));
1:61da1fa: 
1:61da1fa:         boolean removed = cache.deleteSelectorForDestination(testQueue, "foo = 'bar'");
1:61da1fa:         assertTrue(removed);
1:61da1fa: 
1:61da1fa:         selectors = cache.selectorsForDestination(testQueue);
1:61da1fa:         assertEquals(0, selectors.size());
1:61da1fa: 
1:61da1fa:         createConsumer("BrokerB", createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:61da1fa:                 "ceposta = 'redhat'");
1:61da1fa: 
1:61da1fa: 
2:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa: 
1:61da1fa:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1:61da1fa: 
2:61da1fa:             @Override
2:61da1fa:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return dest.getConsumers().size() == 2;
3:61da1fa:             }
1:61da1fa:         }, 500);
1:61da1fa: 
1:61da1fa:         selectors = cache.selectorsForDestination(testQueue);
1:61da1fa:         assertEquals(1, selectors.size());
1:61da1fa:         cache.deleteAllSelectorsForDestination(testQueue);
1:61da1fa:         selectors = cache.selectorsForDestination(testQueue);
1:61da1fa:         assertEquals(0, selectors.size());
1:61da1fa: 
1:5ee9a34:     }
1:61da1fa: 
1:5ee9a34:     public void testMessageLeaks() throws Exception {
1:61da1fa:         clearSelectorCacheFiles();
1:61da1fa:         startAllBrokers();
1:61da1fa: 
1:61da1fa:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1:61da1fa: 
1:61da1fa:         // Create the remote virtual topic consumer with selector
1:61da1fa:         ActiveMQDestination consumerQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1:61da1fa:         // create it so that the queue is there and messages don't get lost
1:61da1fa:         MessageConsumer consumer1 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'AAPL'");
1:61da1fa:         MessageConsumer consumer2 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'AAPL'");
1:61da1fa: 
1:61da1fa:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:61da1fa:         ProducerThreadTester producerTester = createProducerTester("BrokerA", virtualTopic);
1:61da1fa:         producerTester.setRunIndefinitely(true);
1:61da1fa:         producerTester.setSleep(5);
1:61da1fa:         producerTester.addMessageProperty("AAPL");
1:61da1fa:         producerTester.addMessageProperty("VIX");
1:61da1fa:         producerTester.start();
1:61da1fa: 
1:61da1fa:         int currentCount = producerTester.getSentCount();
1:61da1fa:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1:61da1fa: 
1:61da1fa:         // let some messages get sent
1:61da1fa:         Thread.sleep(2000);
1:61da1fa: 
1:61da1fa:         MessageIdList consumer1Messages = getConsumerMessages("BrokerA", consumer1);
1:61da1fa:         consumer1Messages.waitForMessagesToArrive(50, 1000);
1:61da1fa: 
1:61da1fa:         // switch one of the consumers to SYMBOL = 'VIX'
1:61da1fa:         consumer1.close();
1:61da1fa:         consumer1 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'VIX'");
1:61da1fa: 
1:61da1fa:         // wait till new consumer is on board
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
1:ed1622d:                 return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                         .getConsumers().size() == 2;
1:61da1fa:             }
1:61da1fa:         });
1:61da1fa: 
1:61da1fa:         currentCount = producerTester.getSentCount();
1:61da1fa:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1:61da1fa: 
1:61da1fa:         // let some messages get sent
1:61da1fa:         Thread.sleep(2000);
1:61da1fa: 
1:61da1fa:         // switch the other consumer to SYMBOL = 'VIX'
1:61da1fa:         consumer2.close();
1:61da1fa:         consumer2 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'VIX'");
1:61da1fa: 
1:61da1fa:         // wait till new consumer is on board
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
2:61da1fa:                 return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                         .getConsumers().size() == 2;
1:61da1fa:             }
1:61da1fa:         });
1:61da1fa: 
1:61da1fa:         currentCount = producerTester.getSentCount();
1:61da1fa:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1:61da1fa: 
1:61da1fa:         // let some messages get sent
1:61da1fa:         Thread.sleep(2000);
1:61da1fa: 
1:61da1fa:         currentCount = producerTester.getSentCount();
1:61da1fa:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // make sure if there are messages that are orphaned in the queue that this number doesn't
1:61da1fa:         // grow...
1:61da1fa:         final long currentDepth = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount();
1:61da1fa: 
1:61da1fa:         LOG.info(">>>>> Orphaned messages? " + currentDepth);
1:61da1fa: 
1:61da1fa:         // wait 5s to see if we can get a growth in the depth of the queue
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                         .getDestinationStatistics().getMessages().getCount() > currentDepth;
1:61da1fa:             }
1:ed1622d:         }, 5000);
1:61da1fa: 
1:61da1fa:         // stop producers
1:61da1fa:         producerTester.setRunning(false);
1:61da1fa:         producerTester.join();
1:61da1fa: 
1:61da1fa:         // pause to let consumers catch up
1:61da1fa:         Thread.sleep(1000);
1:61da1fa: 
1:61da1fa:         assertTrue(brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount() <= currentDepth);
1:61da1fa: 
1:61da1fa: 
1:61da1fa:     }
1:61da1fa: 
1:5ee9a34:     private ProducerThreadTester createProducerTester(String brokerName, javax.jms.Destination destination) throws Exception {
1:61da1fa:         BrokerItem brokerItem = brokers.get(brokerName);
1:61da1fa: 
1:61da1fa:         Connection conn = brokerItem.createConnection();
1:61da1fa:         conn.start();
1:61da1fa:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:61da1fa:         ProducerThreadTester rc = new ProducerThreadTester(sess, destination);
1:61da1fa:         rc.setPersistent(persistentDelivery);
1:61da1fa:         return rc;
1:61da1fa:     }
1:61da1fa: 
1:5ee9a34:     public void testSelectorConsumptionWithNoMatchAtHeadOfQueue() throws Exception {
1:61da1fa:         clearSelectorCacheFiles();
1:61da1fa:         startAllBrokers();
1:61da1fa: 
1:61da1fa:         BrokerService brokerA = brokers.get("BrokerA").broker;
1:61da1fa: 
1:61da1fa:         // Create the remote virtual topic consumer with selector
1:61da1fa:         ActiveMQDestination consumerQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1:61da1fa: 
1:61da1fa:         // create it so that the queue is there and messages don't get lost
1:61da1fa:         MessageConsumer selectingConsumer = establishConsumer("BrokerA", consumerQueue);
1:61da1fa: 
1:61da1fa:         // send messages with NO selection criteria first, and then with a property to be selected
1:61da1fa:         // this should put messages at the head of the queue that don't match selection
1:61da1fa:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 1);
1:61da1fa: 
1:61da1fa:         // close the consumer w/out consuming any messages; they'll be marked redelivered
1:61da1fa:         selectingConsumer.close();
1:61da1fa: 
1:61da1fa:         selectingConsumer = createConsumer("BrokerA", consumerQueue, "foo = 'bar'");
1:61da1fa: 
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "bar"));
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         MessageIdList selectingConsumerMessages = getConsumerMessages("BrokerA", selectingConsumer);
1:61da1fa:         selectingConsumerMessages.waitForMessagesToArrive(1, 1000L);
1:61da1fa: 
1:61da1fa:         assertEquals(1, selectingConsumerMessages.getMessageCount());
1:61da1fa:         selectingConsumerMessages.waitForMessagesToArrive(10, 1000L);
1:61da1fa:         assertEquals(1, selectingConsumerMessages.getMessageCount());
1:61da1fa: 
1:61da1fa:         // assert broker A stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 2, 1, 5000);
1:61da1fa:         assertEquals(1, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getConsumers().size());
1:61da1fa:         assertEquals(2, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(1, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(1, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa: 
1:61da1fa:     }
1:61da1fa: 
1:5ee9a34:     private MessageConsumer establishConsumer(String broker, ActiveMQDestination consumerQueue) throws Exception {
1:61da1fa:         BrokerItem item = brokers.get(broker);
1:61da1fa:         Connection c = item.createConnection();
1:61da1fa:         c.start();
1:61da1fa:         Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:61da1fa:         return s.createConsumer(consumerQueue);
1:61da1fa:     }
1:61da1fa: 
1:5ee9a34:     public void testSelectorsAndNonSelectors() throws Exception {
1:61da1fa:         clearSelectorCacheFiles();
1:61da1fa:         // borkerA is local and brokerB is remote
1:61da1fa:         bridgeAndConfigureBrokers("BrokerA", "BrokerB");
1:61da1fa:         startAllBrokers();
1:61da1fa:         waitForBridgeFormation();
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1:61da1fa:         final BrokerService brokerB = brokers.get("BrokerB").broker;
1:61da1fa: 
1:61da1fa:         // Create the remote virtual topic consumer with selector
1:61da1fa:         ActiveMQDestination consumerBQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1:61da1fa: 
1:61da1fa:         MessageConsumer selectingConsumer = createConsumer("BrokerB", consumerBQueue, "foo = 'bar'");
1:61da1fa:         MessageConsumer nonSelectingConsumer = createConsumer("BrokerB", consumerBQueue);
1:61da1fa: 
1:61da1fa:         // let advisories propogate
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1:61da1fa: 
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return dest.getConsumers().size() == 2;
1:61da1fa:             }
1:61da1fa:         }, 500);
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         Destination destination = getDestination(brokerB, consumerBQueue);
1:61da1fa:         assertEquals(2, destination.getConsumers().size());
1:61da1fa: 
1:61da1fa:         // publisher publishes to this
1:61da1fa:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 10, asMap("foo", "bar"));
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 10);
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         MessageIdList selectingConsumerMessages = getConsumerMessages("BrokerB", selectingConsumer);
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         MessageIdList nonSelectingConsumerMessages = getConsumerMessages("BrokerB", nonSelectingConsumer);
1:61da1fa: 
1:61da1fa:         // we only expect half of the messages that get sent with the selector, because they get load balanced
1:61da1fa:         selectingConsumerMessages.waitForMessagesToArrive(5, 1000L);
1:61da1fa:         assertEquals(5, selectingConsumerMessages.getMessageCount());
1:61da1fa: 
1:61da1fa:         nonSelectingConsumerMessages.waitForMessagesToArrive(15, 1000L);
1:61da1fa:         assertEquals(15, nonSelectingConsumerMessages.getMessageCount());
1:61da1fa: 
1:61da1fa:         // assert broker A stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
1:61da1fa:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(0, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa: 
1:61da1fa:         // assert broker B stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
1:61da1fa:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         //now let's close the consumer without the selector
1:61da1fa:         nonSelectingConsumer.close();
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // let advisories propogate
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1:61da1fa: 
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return dest.getConsumers().size() == 1;
1:61da1fa:             }
1:61da1fa:         }, 500);
1:61da1fa: 
1:61da1fa:         // and let's send messages with a selector that doesnt' match
1:61da1fa:         selectingConsumerMessages.flushMessages();
1:61da1fa: 
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 10, asMap("ceposta", "redhat"));
1:61da1fa: 
1:61da1fa:         selectingConsumerMessages = getConsumerMessages("BrokerB", selectingConsumer);
1:61da1fa:         selectingConsumerMessages.waitForMessagesToArrive(1, 1000L);
1:5ee9a34:         assertEquals(0, selectingConsumerMessages.getMessageCount());
1:61da1fa: 
1:61da1fa:         // assert broker A stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
1:61da1fa:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(0, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa: 
1:61da1fa:         // assert broker B stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
1:61da1fa:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa: 
1:61da1fa:         // now lets disconect the selecting consumer for a sec and send messages with a selector that DOES match
1:61da1fa:         selectingConsumer.close();
1:61da1fa: 
1:61da1fa:         // let advisories propogate
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1:61da1fa: 
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return dest.getConsumers().size() == 0;
1:61da1fa:             }
1:61da1fa:         }, 500);
1:61da1fa: 
1:61da1fa:         selectingConsumerMessages.flushMessages();
1:61da1fa: 
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 10, asMap("foo", "bar"));
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // assert broker A stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
1:61da1fa:         assertEquals(30, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(10, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:ed1622d: 
1:61da1fa:         // assert broker B stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
1:61da1fa:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:ed1622d: 
1:61da1fa:         selectingConsumer = createConsumer("BrokerB", consumerBQueue, "foo = 'bar'");
1:61da1fa:         selectingConsumerMessages = getConsumerMessages("BrokerB", selectingConsumer);
1:61da1fa:         selectingConsumerMessages.waitForMessagesToArrive(10);
1:61da1fa:         assertEquals(10, selectingConsumerMessages.getMessageCount());
1:61da1fa: 
1:61da1fa:         // let advisories propogate
1:ed1622d:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1:61da1fa: 
1:ed1622d:             @Override
1:ed1622d:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return dest.getConsumers().size() == 1;
1:ed1622d:             }
1:61da1fa:         }, 500);
1:61da1fa: 
1:61da1fa:         // assert broker A stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 30, 30, 5000);
1:61da1fa:         assertEquals(30, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(30, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(0, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa: 
1:61da1fa:         // assert broker B stats
1:5ee9a34:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 30, 30, 5000);
1:61da1fa:         assertEquals(30, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa:         assertEquals(30, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getDequeues().getCount());
1:61da1fa:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa: 
1:61da1fa: 
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public VirtualDestinationSelectorCacheViewMBean getVirtualDestinationSelectorCacheMBean(BrokerService broker)
1:61da1fa:             throws MalformedObjectNameException {
1:61da1fa:         ObjectName objectName = BrokerMBeanSupport
1:61da1fa:                 .createVirtualDestinationSelectorCacheName(broker.getBrokerObjectName(), "plugin", "virtualDestinationCache");
1:5ee9a34:         return (VirtualDestinationSelectorCacheViewMBean) broker.getManagementContext()
1:61da1fa:                 .newProxyInstance(objectName, VirtualDestinationSelectorCacheViewMBean.class, true);
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public void testSelectorAwareForwarding() throws Exception {
1:61da1fa:         clearSelectorCacheFiles();
1:61da1fa:         // borkerA is local and brokerB is remote
1:61da1fa:         bridgeAndConfigureBrokers("BrokerA", "BrokerB");
1:61da1fa:         startAllBrokers();
1:61da1fa:         waitForBridgeFormation();
1:61da1fa: 
1:61da1fa:         final BrokerService brokerB = brokers.get("BrokerB").broker;
1:61da1fa:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1:61da1fa: 
1:61da1fa:         // Create the remote virtual topic consumer with selector
1:61da1fa:         MessageConsumer remoteConsumer = createConsumer("BrokerB",
1:61da1fa:                 createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:61da1fa:                 "foo = 'bar'");
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // let advisories propogate
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1:61da1fa: 
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return dest.getConsumers().size() == 1;
1:61da1fa:             }
1:61da1fa:         }, 500);
1:61da1fa: 
1:61da1fa:         ActiveMQQueue queueB = new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic");
1:61da1fa:         Destination destination = getDestination(brokers.get("BrokerB").broker, queueB);
1:61da1fa:         assertEquals(1, destination.getConsumers().size());
1:61da1fa: 
1:61da1fa:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:61da1fa:         assertNull(getDestination(brokers.get("BrokerA").broker, virtualTopic));
1:61da1fa:         assertNull(getDestination(brokers.get("BrokerB").broker, virtualTopic));
1:61da1fa: 
1:61da1fa:         // send two types of messages, one unwanted and the other wanted
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "bar"));
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 1, asMap("ceposta", "redhat"));
1:61da1fa: 
1:61da1fa:         MessageIdList msgsB = getConsumerMessages("BrokerB", remoteConsumer);
1:61da1fa:         // wait for the wanted one to arrive at the remote consumer
1:61da1fa:         msgsB.waitForMessagesToArrive(1);
1:61da1fa: 
1:61da1fa:         // ensure we don't get any more messages
1:61da1fa:         msgsB.waitForMessagesToArrive(1, 1000);
1:61da1fa: 
1:61da1fa:         // remote consumer should only get one of the messages
1:61da1fa:         assertEquals(1, msgsB.getMessageCount());
1:61da1fa: 
1:61da1fa:         // and the enqueue count for the remote queue should only be 1
1:61da1fa:         assertEquals(1, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // now let's remove the consumer on broker B and recreate it with new selector
1:61da1fa:         remoteConsumer.close();
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // now let's shut down broker A and clear its persistent selector cache
1:61da1fa:         brokerA.stop();
1:61da1fa:         brokerA.waitUntilStopped();
1:61da1fa:         deleteSelectorCacheFile("BrokerA");
1:61da1fa: 
1:61da1fa:         assertEquals(0, destination.getConsumers().size());
1:61da1fa: 
1:61da1fa:         remoteConsumer = createConsumer("BrokerB",
1:61da1fa:                 createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:61da1fa:                 "ceposta = 'redhat'");
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         assertEquals(1, destination.getConsumers().size());
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // now let's start broker A back up
1:61da1fa:         brokerA.start(true);
1:61da1fa:         brokerA.waitUntilStarted();
1:61da1fa: 
1:61da1fa:         System.out.println(brokerA.getNetworkConnectors());
1:61da1fa: 
1:61da1fa:         // give a sec to let advisories propogate
1:61da1fa:         // let advisories propogate
1:61da1fa:         Wait.waitFor(new Wait.Condition() {
1:61da1fa:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1:61da1fa: 
1:61da1fa:             @Override
1:61da1fa:             public boolean isSatisified() throws Exception {
1:61da1fa:                 return dest.getConsumers().size() == 1;
1:61da1fa:             }
1:61da1fa:         }, 500);
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // send two types of messages, one unwanted and the other wanted
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "bar"));
1:61da1fa:         sendMessages("BrokerB", virtualTopic, 1, asMap("foo", "bar"));
1:61da1fa:         sendMessages("BrokerA", virtualTopic, 1, asMap("ceposta", "redhat"));
1:61da1fa:         sendMessages("BrokerB", virtualTopic, 1, asMap("ceposta", "redhat"));
1:61da1fa: 
1:61da1fa:         // lets get messages on consumer B
1:61da1fa:         msgsB = getConsumerMessages("BrokerB", remoteConsumer);
1:61da1fa:         msgsB.waitForMessagesToArrive(2);
1:61da1fa: 
1:61da1fa:         // ensure we don't get any more messages
1:61da1fa:         msgsB.waitForMessagesToArrive(1, 1000);
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // remote consumer should only get 10 of the messages
1:61da1fa:         assertEquals(2, msgsB.getMessageCount());
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         // queue should be drained
1:61da1fa:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getMessages().getCount());
1:61da1fa:         // and the enqueue count for the remote queue should only be 1
1:61da1fa:         assertEquals(3, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:61da1fa:                 .getDestinationStatistics().getEnqueues().getCount());
1:61da1fa: 
1:61da1fa: 
1:61da1fa:     }
1:61da1fa: 
1:3c2ed93:     public void testSelectorNoMatchInCache() throws Exception {
1:3c2ed93:         clearSelectorCacheFiles();
1:3c2ed93: 
1:3c2ed93:         // have the cache ignoreWildcardSelectors
1:3c2ed93:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1:3c2ed93:         ((SubQueueSelectorCacheBrokerPlugin)brokerA.getPlugins()[0]).setIgnoreWildcardSelectors(true);
1:3c2ed93: 
1:3c2ed93:         startAllBrokers();
1:3c2ed93: 
1:3c2ed93:         ActiveMQDestination consumerBQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1:3c2ed93: 
1:3c2ed93:         MessageConsumer nonMatchingConsumer = createConsumer("BrokerA", consumerBQueue, "foo = 'bar%'");
1:3c2ed93: 
1:3c2ed93:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:3c2ed93:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "notBar"));
1:3c2ed93:     }
1:3c2ed93: 
1:61da1fa:     private HashMap<String, Object> asMap(String key, Object value) {
1:5ee9a34:         HashMap<String, Object> rc = new HashMap<String, Object>(1);
1:61da1fa:         rc.put(key, value);
1:61da1fa:         return rc;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa: 
1:61da1fa:     private void bridgeAndConfigureBrokers(String local, String remote)
1:61da1fa:             throws Exception {
1:61da1fa:         NetworkConnector bridge = bridgeBrokers(local, remote, false, 1, false);
1:61da1fa:         bridge.setDecreaseNetworkConsumerPriority(true);
1:61da1fa:         bridge.setDuplex(true);
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     public void setUp() throws Exception {
1:61da1fa:         super.setAutoFail(true);
1:61da1fa:         super.setUp();
1:61da1fa:         String options = new String(
1:61da1fa:                 "?useJmx=false&deleteAllMessagesOnStartup=true");
1:61da1fa:         createAndConfigureBroker(new URI(
1:61da1fa:                 "broker:(tcp://localhost:61616)/BrokerA" + options));
1:61da1fa:         createAndConfigureBroker(new URI(
1:61da1fa:                 "broker:(tcp://localhost:61617)/BrokerB" + options));
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     private void clearSelectorCacheFiles() {
1:61da1fa:         String[] brokerNames = new String[]{"BrokerA", "BrokerB"};
1:61da1fa:         for (String brokerName : brokerNames) {
1:61da1fa:             deleteSelectorCacheFile(brokerName);
1:61da1fa:         }
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     private void deleteSelectorCacheFile(String brokerName) {
1:61da1fa:         File brokerPersisteFile = new File(PERSIST_SELECTOR_CACHE_FILE_BASEPATH + brokerName);
1:61da1fa: 
1:61da1fa:         if (brokerPersisteFile.exists()) {
1:61da1fa:             brokerPersisteFile.delete();
1:61da1fa:         }
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     private BrokerService createAndConfigureBroker(URI uri) throws Exception {
1:61da1fa:         BrokerService broker = createBroker(uri);
1:61da1fa:         broker.setUseJmx(true);
1:61da1fa:         // Make topics "selectorAware"
1:61da1fa:         VirtualTopic virtualTopic = new VirtualTopic();
1:61da1fa:         virtualTopic.setSelectorAware(true);
1:61da1fa:         VirtualDestinationInterceptor interceptor = new VirtualDestinationInterceptor();
1:5ee9a34:         interceptor.setVirtualDestinations(new VirtualDestination[]{virtualTopic});
1:5ee9a34:         broker.setDestinationInterceptors(new DestinationInterceptor[]{interceptor});
1:61da1fa:         configurePersistenceAdapter(broker);
1:61da1fa: 
1:61da1fa:         SubQueueSelectorCacheBrokerPlugin selectorCacheBrokerPlugin = new SubQueueSelectorCacheBrokerPlugin();
1:61da1fa:         selectorCacheBrokerPlugin.setSingleSelectorPerDestination(true);
1:61da1fa:         File persisteFile = new File(PERSIST_SELECTOR_CACHE_FILE_BASEPATH + broker.getBrokerName());
1:61da1fa:         selectorCacheBrokerPlugin.setPersistFile(persisteFile);
1:61da1fa:         broker.setPlugins(new BrokerPlugin[]{selectorCacheBrokerPlugin});
1:61da1fa:         return broker;
1:61da1fa:     }
1:61da1fa: 
1:61da1fa:     protected void configurePersistenceAdapter(BrokerService broker)
1:61da1fa:             throws IOException {
1:61da1fa:         File dataFileDir = new File("target/test-amq-data/kahadb/"
1:61da1fa:                 + broker.getBrokerName());
1:61da1fa:         KahaDBStore kaha = new KahaDBStore();
1:61da1fa:         kaha.setDirectory(dataFileDir);
1:61da1fa:         broker.setPersistenceAdapter(kaha);
1:61da1fa:     }
1:61da1fa: 
1:5ee9a34:     /**
1:5ee9a34:      * Typically used before asserts to give producers and consumers some time to finish their tasks
1:5ee9a34:      * before the final state is tested.
1:5ee9a34:      *
1:5ee9a34:      * @param broker BrokerService on which the destinations are looked up
1:5ee9a34:      * @param destinationName
1:5ee9a34:      * @param topic true if the destination is a Topic, false if it is a Queue
1:5ee9a34:      * @param numEnqueueMsgs expected number of enqueued messages in the destination
1:5ee9a34:      * @param numDequeueMsgs expected number of dequeued messages in the destination
1:5ee9a34:      * @param waitTime number of milliseconds to wait for completion
1:5ee9a34:      * @throws Exception
1:5ee9a34:      */
1:5ee9a34:     private void waitForMessagesToBeConsumed(final BrokerService broker, final String destinationName,
1:5ee9a34:                                              final boolean topic, final int numEnqueueMsgs, final int numDequeueMsgs, int waitTime) throws Exception {
1:5ee9a34:         final ActiveMQDestination destination;
1:5ee9a34:         if (topic) {
1:5ee9a34:             destination = new ActiveMQTopic(destinationName);
1:5ee9a34:         } else {
1:5ee9a34:             destination = new ActiveMQQueue(destinationName);
1:5ee9a34:         }
1:5ee9a34: 
1:5ee9a34:         Wait.waitFor(new Wait.Condition() {
1:5ee9a34:             @Override
1:5ee9a34:             public boolean isSatisified() throws Exception {
1:5ee9a34: 
1:5ee9a34:                 return broker.getDestination(destination)
1:5ee9a34:                         .getDestinationStatistics().getEnqueues().getCount() == numEnqueueMsgs;
1:5ee9a34:             }
1:5ee9a34:         }, waitTime);
1:5ee9a34: 
1:5ee9a34:         Wait.waitFor(new Wait.Condition() {
1:5ee9a34:             @Override
1:5ee9a34:             public boolean isSatisified() throws Exception {
1:5ee9a34: 
1:5ee9a34:                 return broker.getDestination(destination)
1:5ee9a34:                         .getDestinationStatistics().getDequeues().getCount() == numDequeueMsgs;
1:5ee9a34:             }
1:5ee9a34:         }, waitTime);
1:5ee9a34:     }
1:5ee9a34: 
1:5ee9a34: 
1:61da1fa:     class ProducerThreadTester extends ProducerThread {
1:61da1fa: 
1:61da1fa:         private Set<String> selectors = new LinkedHashSet<String>();
1:61da1fa:         private Map<String, AtomicInteger> selectorCounts = new HashMap<String, AtomicInteger>();
1:61da1fa:         private Random rand = new Random(System.currentTimeMillis());
1:61da1fa: 
1:61da1fa: 
1:61da1fa:         public ProducerThreadTester(Session session, javax.jms.Destination destination) {
1:61da1fa:             super(session, destination);
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:         @Override
1:61da1fa:         protected Message createMessage(int i) throws Exception {
1:61da1fa:             TextMessage msg = createTextMessage(this.session, "Message-" + i);
1:61da1fa:             if (selectors.size() > 0) {
1:61da1fa:                 String value = getRandomKey();
1:61da1fa:                 msg.setStringProperty("SYMBOL", value);
1:61da1fa:                 AtomicInteger currentCount = selectorCounts.get(value);
1:61da1fa:                 currentCount.incrementAndGet();
1:61da1fa:             }
1:61da1fa: 
1:61da1fa:             return msg;
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:         @Override
1:61da1fa:         public void resetCounters() {
1:61da1fa:             super.resetCounters();
1:61da1fa:             for (String key : selectorCounts.keySet()) {
1:61da1fa:                 selectorCounts.put(key, new AtomicInteger(0));
1:61da1fa:             }
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:         private String getRandomKey() {
1:61da1fa:             ArrayList<String> keys = new ArrayList(selectors);
1:61da1fa:             return keys.get(rand.nextInt(keys.size()));
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:         public void addMessageProperty(String value) {
1:61da1fa:             if (!this.selectors.contains(value)) {
1:61da1fa:                 selectors.add(value);
1:61da1fa:                 selectorCounts.put(value, new AtomicInteger(0));
1:61da1fa:             }
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:         public int getCountForProperty(String key) {
1:61da1fa:             return selectorCounts.get(key).get();
1:61da1fa:         }
1:61da1fa: 
1:61da1fa:     }
1:61da1fa: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:3c2ed93
/////////////////////////////////////////////////////////////////////////
1:     public void testSelectorNoMatchInCache() throws Exception {
1:         clearSelectorCacheFiles();
1: 
1:         // have the cache ignoreWildcardSelectors
1:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1:         ((SubQueueSelectorCacheBrokerPlugin)brokerA.getPlugins()[0]).setIgnoreWildcardSelectors(true);
1: 
1:         startAllBrokers();
1: 
1:         ActiveMQDestination consumerBQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1: 
1:         MessageConsumer nonMatchingConsumer = createConsumer("BrokerA", consumerBQueue, "foo = 'bar%'");
1: 
1:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "notBar"));
1:     }
1: 
commit:5ee9a34
/////////////////////////////////////////////////////////////////////////
1:     public void testMessageLeaks() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     private ProducerThreadTester createProducerTester(String brokerName, javax.jms.Destination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testSelectorConsumptionWithNoMatchAtHeadOfQueue() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 2, 1, 5000);
/////////////////////////////////////////////////////////////////////////
1:     private MessageConsumer establishConsumer(String broker, ActiveMQDestination consumerQueue) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testSelectorsAndNonSelectors() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
/////////////////////////////////////////////////////////////////////////
1:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, selectingConsumerMessages.getMessageCount());
1:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
/////////////////////////////////////////////////////////////////////////
1:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
/////////////////////////////////////////////////////////////////////////
1:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
/////////////////////////////////////////////////////////////////////////
1:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 20, 20, 5000);
/////////////////////////////////////////////////////////////////////////
1:         waitForMessagesToBeConsumed(brokerA, "Consumer.B.VirtualTopic.tempTopic", false, 30, 30, 5000);
1:         waitForMessagesToBeConsumed(brokerB, "Consumer.B.VirtualTopic.tempTopic", false, 30, 30, 5000);
/////////////////////////////////////////////////////////////////////////
1:         return (VirtualDestinationSelectorCacheViewMBean) broker.getManagementContext()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String, Object> rc = new HashMap<String, Object>(1);
/////////////////////////////////////////////////////////////////////////
1:         interceptor.setVirtualDestinations(new VirtualDestination[]{virtualTopic});
1:         broker.setDestinationInterceptors(new DestinationInterceptor[]{interceptor});
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Typically used before asserts to give producers and consumers some time to finish their tasks
1:      * before the final state is tested.
1:      *
1:      * @param broker BrokerService on which the destinations are looked up
1:      * @param destinationName
1:      * @param topic true if the destination is a Topic, false if it is a Queue
1:      * @param numEnqueueMsgs expected number of enqueued messages in the destination
1:      * @param numDequeueMsgs expected number of dequeued messages in the destination
1:      * @param waitTime number of milliseconds to wait for completion
1:      * @throws Exception
1:      */
1:     private void waitForMessagesToBeConsumed(final BrokerService broker, final String destinationName,
1:                                              final boolean topic, final int numEnqueueMsgs, final int numDequeueMsgs, int waitTime) throws Exception {
1:         final ActiveMQDestination destination;
1:         if (topic) {
1:             destination = new ActiveMQTopic(destinationName);
1:         } else {
1:             destination = new ActiveMQQueue(destinationName);
1:         }
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1: 
1:                 return broker.getDestination(destination)
1:                         .getDestinationStatistics().getEnqueues().getCount() == numEnqueueMsgs;
1:             }
1:         }, waitTime);
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1: 
1:                 return broker.getDestination(destination)
1:                         .getDestinationStatistics().getDequeues().getCount() == numDequeueMsgs;
1:             }
1:         }, waitTime);
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: }
commit:ed1622d
/////////////////////////////////////////////////////////////////////////
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
0:                         .getDestinationStatistics().getEnqueues().getCount() == 30;
1:             }
1:         }, 5000);
1: 
author:Christian Posta
-------------------------------------------------------------------------------
commit:61da1fa
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1: import org.apache.activemq.broker.jmx.VirtualDestinationSelectorCacheViewMBean;
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.DestinationInterceptor;
1: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1: import org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor;
1: import org.apache.activemq.broker.region.virtual.VirtualTopic;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.plugin.SubQueueSelectorCacheBrokerPlugin;
1: import org.apache.activemq.store.kahadb.KahaDBStore;
1: import org.apache.activemq.util.MessageIdList;
1: import org.apache.activemq.util.ProducerThread;
1: import org.apache.activemq.util.Wait;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: import javax.jms.*;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
1: import java.io.File;
1: import java.io.IOException;
1: import java.net.URI;
1: import java.util.*;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import static org.apache.activemq.TestSupport.getDestination;
1: 
1: /**
1:  * @author <a href="http://www.christianposta.com/blog">Christian Posta</a>
1:  */
1: public class TwoBrokerVirtualTopicSelectorAwareForwardingTest extends
1:         JmsMultipleBrokersTestSupport {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(TwoBrokerVirtualTopicSelectorAwareForwardingTest.class);
1: 
1:     private static final String PERSIST_SELECTOR_CACHE_FILE_BASEPATH = "./target/selectorCache-";
1: 
1:     public void testJMX() throws Exception {
1:         clearSelectorCacheFiles();
1:         // borkerA is local and brokerB is remote
1:         bridgeAndConfigureBrokers("BrokerA", "BrokerB");
1:         startAllBrokers();
1:         waitForBridgeFormation();
1: 
1:         createConsumer("BrokerB", createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:                 "foo = 'bar'");
1: 
1: 
1:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1: 
1:         String testQueue = "queue://Consumer.B.VirtualTopic.tempTopic";
1:         VirtualDestinationSelectorCacheViewMBean cache = getVirtualDestinationSelectorCacheMBean(brokerA);
1:         Set<String> selectors = cache.selectorsForDestination(testQueue);
1: 
1:         assertEquals(1, selectors.size());
1:         assertTrue(selectors.contains("foo = 'bar'"));
1: 
1:         boolean removed = cache.deleteSelectorForDestination(testQueue, "foo = 'bar'");
1:         assertTrue(removed);
1: 
1:         selectors = cache.selectorsForDestination(testQueue);
1:         assertEquals(0, selectors.size());
1: 
1:         createConsumer("BrokerB", createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:                 "ceposta = 'redhat'");
1: 
1: 
1:         Wait.waitFor(new Wait.Condition() {
1: 
1:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return dest.getConsumers().size() == 2;
1:             }
1:         }, 500);
1: 
1:         selectors = cache.selectorsForDestination(testQueue);
1:         assertEquals(1, selectors.size());
1:         cache.deleteAllSelectorsForDestination(testQueue);
1:         selectors = cache.selectorsForDestination(testQueue);
1:         assertEquals(0, selectors.size());
1: 
1:     }
1: 
0:     public void testMessageLeaks() throws Exception{
1:         clearSelectorCacheFiles();
1:         startAllBrokers();
1: 
1:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1: 
1:         // Create the remote virtual topic consumer with selector
1:         ActiveMQDestination consumerQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1:         // create it so that the queue is there and messages don't get lost
1:         MessageConsumer consumer1 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'AAPL'");
1:         MessageConsumer consumer2 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'AAPL'");
1: 
1:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:         ProducerThreadTester producerTester = createProducerTester("BrokerA", virtualTopic);
1:         producerTester.setRunIndefinitely(true);
1:         producerTester.setSleep(5);
1:         producerTester.addMessageProperty("AAPL");
1:         producerTester.addMessageProperty("VIX");
1:         producerTester.start();
1: 
1:         int currentCount = producerTester.getSentCount();
1:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1: 
1:         // let some messages get sent
1:         Thread.sleep(2000);
1: 
1:         MessageIdList consumer1Messages = getConsumerMessages("BrokerA", consumer1);
1:         consumer1Messages.waitForMessagesToArrive(50, 1000);
1: 
1:         // switch one of the consumers to SYMBOL = 'VIX'
1:         consumer1.close();
1:         consumer1 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'VIX'");
1: 
1:         // wait till new consumer is on board
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                         .getConsumers().size() == 2;
1:             }
1:         });
1: 
1:         currentCount = producerTester.getSentCount();
1:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1: 
1:         // let some messages get sent
1:         Thread.sleep(2000);
1: 
1:         // switch the other consumer to SYMBOL = 'VIX'
1:         consumer2.close();
1:         consumer2 = createConsumer("BrokerA", consumerQueue, "SYMBOL = 'VIX'");
1: 
1:         // wait till new consumer is on board
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                         .getConsumers().size() == 2;
1:             }
1:         });
1: 
1:         currentCount = producerTester.getSentCount();
1:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1: 
1:         // let some messages get sent
1:         Thread.sleep(2000);
1: 
1:         currentCount = producerTester.getSentCount();
1:         LOG.info(">>>> currently sent: total=" + currentCount + ", AAPL=" + producerTester.getCountForProperty("AAPL") + ", VIX=" + producerTester.getCountForProperty("VIX"));
1: 
1: 
1:         // make sure if there are messages that are orphaned in the queue that this number doesn't
1:         // grow...
1:         final long currentDepth = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount();
1: 
1:         LOG.info(">>>>> Orphaned messages? " + currentDepth);
1: 
1:         // wait 5s to see if we can get a growth in the depth of the queue
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                         .getDestinationStatistics().getMessages().getCount() > currentDepth;
1:             }
0:         }, 5000);
1: 
1:         // stop producers
1:         producerTester.setRunning(false);
1:         producerTester.join();
1: 
1:         // pause to let consumers catch up
1:         Thread.sleep(1000);
1: 
1:         assertTrue(brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount() <= currentDepth);
1: 
1: 
1:     }
1: 
0:     private ProducerThreadTester createProducerTester(String brokerName, javax.jms.Destination destination) throws Exception{
1:         BrokerItem brokerItem = brokers.get(brokerName);
1: 
1:         Connection conn = brokerItem.createConnection();
1:         conn.start();
1:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         ProducerThreadTester rc = new ProducerThreadTester(sess, destination);
1:         rc.setPersistent(persistentDelivery);
1:         return rc;
1:     }
1: 
0:     public void testSelectorConsumptionWithNoMatchAtHeadOfQueue() throws Exception{
1:         clearSelectorCacheFiles();
1:         startAllBrokers();
1: 
1:         BrokerService brokerA = brokers.get("BrokerA").broker;
1: 
1:         // Create the remote virtual topic consumer with selector
1:         ActiveMQDestination consumerQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1: 
1:         // create it so that the queue is there and messages don't get lost
1:         MessageConsumer selectingConsumer = establishConsumer("BrokerA", consumerQueue);
1: 
1:         // send messages with NO selection criteria first, and then with a property to be selected
1:         // this should put messages at the head of the queue that don't match selection
1:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:         sendMessages("BrokerA", virtualTopic, 1);
1: 
1:         // close the consumer w/out consuming any messages; they'll be marked redelivered
1:         selectingConsumer.close();
1: 
1:         selectingConsumer = createConsumer("BrokerA", consumerQueue, "foo = 'bar'");
1: 
1:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "bar"));
1: 
1: 
1:         MessageIdList selectingConsumerMessages = getConsumerMessages("BrokerA", selectingConsumer);
1:         selectingConsumerMessages.waitForMessagesToArrive(1, 1000L);
1: 
1:         assertEquals(1, selectingConsumerMessages.getMessageCount());
1:         selectingConsumerMessages.waitForMessagesToArrive(10, 1000L);
1:         assertEquals(1, selectingConsumerMessages.getMessageCount());
1: 
1:         // assert broker A stats
1:         assertEquals(1, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getConsumers().size());
1:         assertEquals(2, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(1, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(1, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1:     }
1: 
0:     private MessageConsumer establishConsumer(String broker, ActiveMQDestination consumerQueue) throws Exception{
1:         BrokerItem item = brokers.get(broker);
1:         Connection c = item.createConnection();
1:         c.start();
1:         Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         return s.createConsumer(consumerQueue);
1:     }
1: 
0:     public void testSelectorsAndNonSelectors() throws Exception{
1:         clearSelectorCacheFiles();
1:         // borkerA is local and brokerB is remote
1:         bridgeAndConfigureBrokers("BrokerA", "BrokerB");
1:         startAllBrokers();
1:         waitForBridgeFormation();
1: 
1: 
1:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1:         final BrokerService brokerB = brokers.get("BrokerB").broker;
1: 
1:         // Create the remote virtual topic consumer with selector
1:         ActiveMQDestination consumerBQueue = createDestination("Consumer.B.VirtualTopic.tempTopic", false);
1: 
1:         MessageConsumer selectingConsumer = createConsumer("BrokerB", consumerBQueue, "foo = 'bar'");
1:         MessageConsumer nonSelectingConsumer = createConsumer("BrokerB", consumerBQueue);
1: 
1:         // let advisories propogate
1:         Wait.waitFor(new Wait.Condition() {
1:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return dest.getConsumers().size() == 2;
1:             }
1:         }, 500);
1: 
1: 
1:         Destination destination = getDestination(brokerB, consumerBQueue);
1:         assertEquals(2, destination.getConsumers().size());
1: 
1:         // publisher publishes to this
1:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:         sendMessages("BrokerA", virtualTopic, 10, asMap("foo", "bar"));
1:         sendMessages("BrokerA", virtualTopic, 10);
1: 
1: 
1:         MessageIdList selectingConsumerMessages = getConsumerMessages("BrokerB", selectingConsumer);
1: 
1: 
1:         MessageIdList nonSelectingConsumerMessages = getConsumerMessages("BrokerB", nonSelectingConsumer);
1: 
1:         // we only expect half of the messages that get sent with the selector, because they get load balanced
1:         selectingConsumerMessages.waitForMessagesToArrive(5, 1000L);
1:         assertEquals(5, selectingConsumerMessages.getMessageCount());
1: 
1:         nonSelectingConsumerMessages.waitForMessagesToArrive(15, 1000L);
1:         assertEquals(15, nonSelectingConsumerMessages.getMessageCount());
1: 
1:         // assert broker A stats
1:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(0, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1:         // assert broker B stats
1:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1: 
1:         //now let's close the consumer without the selector
1:         nonSelectingConsumer.close();
1: 
1: 
1:         // let advisories propogate
1:         Wait.waitFor(new Wait.Condition() {
1:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return dest.getConsumers().size() == 1;
1:             }
1:         }, 500);
1: 
1:         // and let's send messages with a selector that doesnt' match
1:         selectingConsumerMessages.flushMessages();
1: 
1:         sendMessages("BrokerA", virtualTopic, 10, asMap("ceposta", "redhat"));
1: 
1:         selectingConsumerMessages = getConsumerMessages("BrokerB", selectingConsumer);
1:         selectingConsumerMessages.waitForMessagesToArrive(1, 1000L);
0:         assertEquals(0, selectingConsumerMessages.getMessageCount()) ;
1: 
1:         // assert broker A stats
1:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(0, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1:         // assert broker B stats
1:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1:         // now lets disconect the selecting consumer for a sec and send messages with a selector that DOES match
1:         selectingConsumer.close();
1: 
1:         // let advisories propogate
1:         Wait.waitFor(new Wait.Condition() {
1:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return dest.getConsumers().size() == 0;
1:             }
1:         }, 500);
1: 
1:         selectingConsumerMessages.flushMessages();
1: 
1:         sendMessages("BrokerA", virtualTopic, 10, asMap("foo", "bar"));
1: 
1: 
1:         // assert broker A stats
1:         assertEquals(30, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(20, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(10, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1:         // assert broker B stats
1:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(20, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1:         selectingConsumer = createConsumer("BrokerB", consumerBQueue, "foo = 'bar'");
1:         selectingConsumerMessages = getConsumerMessages("BrokerB", selectingConsumer);
1:         selectingConsumerMessages.waitForMessagesToArrive(10);
1:         assertEquals(10, selectingConsumerMessages.getMessageCount());
1: 
1:         // let advisories propogate
1:         Wait.waitFor(new Wait.Condition() {
1:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return dest.getConsumers().size() == 1;
1:             }
1:         }, 500);
1: 
1:         // assert broker A stats
1:         assertEquals(30, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(30, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(0, brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1:         // assert broker B stats
1:         assertEquals(30, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals(30, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getDequeues().getCount());
1:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1: 
1: 
1:     }
1: 
1:     public VirtualDestinationSelectorCacheViewMBean getVirtualDestinationSelectorCacheMBean(BrokerService broker)
1:             throws MalformedObjectNameException {
1:         ObjectName objectName = BrokerMBeanSupport
1:                 .createVirtualDestinationSelectorCacheName(broker.getBrokerObjectName(), "plugin", "virtualDestinationCache");
0:         return (VirtualDestinationSelectorCacheViewMBean)broker.getManagementContext()
1:                 .newProxyInstance(objectName, VirtualDestinationSelectorCacheViewMBean.class, true);
1:     }
1: 
1:     public void testSelectorAwareForwarding() throws Exception {
1:         clearSelectorCacheFiles();
1:         // borkerA is local and brokerB is remote
1:         bridgeAndConfigureBrokers("BrokerA", "BrokerB");
1:         startAllBrokers();
1:         waitForBridgeFormation();
1: 
1:         final BrokerService brokerB = brokers.get("BrokerB").broker;
1:         final BrokerService brokerA = brokers.get("BrokerA").broker;
1: 
1:         // Create the remote virtual topic consumer with selector
1:         MessageConsumer remoteConsumer = createConsumer("BrokerB",
1:                 createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:                 "foo = 'bar'");
1: 
1: 
1:         // let advisories propogate
1:         Wait.waitFor(new Wait.Condition() {
1:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return dest.getConsumers().size() == 1;
1:             }
1:         }, 500);
1: 
1:         ActiveMQQueue queueB = new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic");
1:         Destination destination = getDestination(brokers.get("BrokerB").broker, queueB);
1:         assertEquals(1, destination.getConsumers().size());
1: 
1:         ActiveMQTopic virtualTopic = new ActiveMQTopic("VirtualTopic.tempTopic");
1:         assertNull(getDestination(brokers.get("BrokerA").broker, virtualTopic));
1:         assertNull(getDestination(brokers.get("BrokerB").broker, virtualTopic));
1: 
1:         // send two types of messages, one unwanted and the other wanted
1:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "bar"));
1:         sendMessages("BrokerA", virtualTopic, 1, asMap("ceposta", "redhat"));
1: 
1:         MessageIdList msgsB = getConsumerMessages("BrokerB", remoteConsumer);
1:         // wait for the wanted one to arrive at the remote consumer
1:         msgsB.waitForMessagesToArrive(1);
1: 
1:         // ensure we don't get any more messages
1:         msgsB.waitForMessagesToArrive(1, 1000);
1: 
1:         // remote consumer should only get one of the messages
1:         assertEquals(1, msgsB.getMessageCount());
1: 
1:         // and the enqueue count for the remote queue should only be 1
1:         assertEquals(1, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1: 
1: 
1:         // now let's remove the consumer on broker B and recreate it with new selector
1:         remoteConsumer.close();
1: 
1: 
1: 
1: 
1:         // now let's shut down broker A and clear its persistent selector cache
1:         brokerA.stop();
1:         brokerA.waitUntilStopped();
1:         deleteSelectorCacheFile("BrokerA");
1: 
1:         assertEquals(0, destination.getConsumers().size());
1: 
1:         remoteConsumer = createConsumer("BrokerB",
1:                 createDestination("Consumer.B.VirtualTopic.tempTopic", false),
1:                 "ceposta = 'redhat'");
1: 
1: 
1:         assertEquals(1, destination.getConsumers().size());
1: 
1: 
1:         // now let's start broker A back up
1:         brokerA.start(true);
1:         brokerA.waitUntilStarted();
1: 
1:         System.out.println(brokerA.getNetworkConnectors());
1: 
1:         // give a sec to let advisories propogate
1:         // let advisories propogate
1:         Wait.waitFor(new Wait.Condition() {
1:             Destination dest = brokerA.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"));
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return dest.getConsumers().size() == 1;
1:             }
1:         }, 500);
1: 
1: 
1:         // send two types of messages, one unwanted and the other wanted
1:         sendMessages("BrokerA", virtualTopic, 1, asMap("foo", "bar"));
1:         sendMessages("BrokerB", virtualTopic, 1, asMap("foo", "bar"));
1:         sendMessages("BrokerA", virtualTopic, 1, asMap("ceposta", "redhat"));
1:         sendMessages("BrokerB", virtualTopic, 1, asMap("ceposta", "redhat"));
1: 
1:         // lets get messages on consumer B
1:         msgsB = getConsumerMessages("BrokerB", remoteConsumer);
1:         msgsB.waitForMessagesToArrive(2);
1: 
1:         // ensure we don't get any more messages
1:         msgsB.waitForMessagesToArrive(1, 1000);
1: 
1: 
1:         // remote consumer should only get 10 of the messages
1:         assertEquals(2, msgsB.getMessageCount());
1: 
1: 
1:         // queue should be drained
1:         assertEquals(0, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getMessages().getCount());
1:         // and the enqueue count for the remote queue should only be 1
1:         assertEquals(3, brokerB.getDestination(new ActiveMQQueue("Consumer.B.VirtualTopic.tempTopic"))
1:                 .getDestinationStatistics().getEnqueues().getCount());
1: 
1: 
1:     }
1: 
1:     private HashMap<String, Object> asMap(String key, Object value) {
0:         HashMap<String, Object> rc = new HashMap<String,Object>(1);
1:         rc.put(key, value);
1:         return rc;
1:     }
1: 
1: 
1: 
1:     private void bridgeAndConfigureBrokers(String local, String remote)
1:             throws Exception {
1:         NetworkConnector bridge = bridgeBrokers(local, remote, false, 1, false);
1:         bridge.setDecreaseNetworkConsumerPriority(true);
1:         bridge.setDuplex(true);
1:     }
1: 
1:     public void setUp() throws Exception {
1:         super.setAutoFail(true);
1:         super.setUp();
1:         String options = new String(
1:                 "?useJmx=false&deleteAllMessagesOnStartup=true");
1:         createAndConfigureBroker(new URI(
1:                 "broker:(tcp://localhost:61616)/BrokerA" + options));
1:         createAndConfigureBroker(new URI(
1:                 "broker:(tcp://localhost:61617)/BrokerB" + options));
1:     }
1: 
1:     private void clearSelectorCacheFiles() {
1:         String[] brokerNames = new String[]{"BrokerA", "BrokerB"};
1:         for (String brokerName : brokerNames) {
1:             deleteSelectorCacheFile(brokerName);
1:         }
1:     }
1: 
1:     private void deleteSelectorCacheFile(String brokerName) {
1:         File brokerPersisteFile = new File(PERSIST_SELECTOR_CACHE_FILE_BASEPATH + brokerName);
1: 
1:         if (brokerPersisteFile.exists()) {
1:             brokerPersisteFile.delete();
1:         }
1:     }
1: 
1:     private BrokerService createAndConfigureBroker(URI uri) throws Exception {
1:         BrokerService broker = createBroker(uri);
1:         broker.setUseJmx(true);
1:         // Make topics "selectorAware"
1:         VirtualTopic virtualTopic = new VirtualTopic();
1:         virtualTopic.setSelectorAware(true);
1:         VirtualDestinationInterceptor interceptor = new VirtualDestinationInterceptor();
0:         interceptor
0:                 .setVirtualDestinations(new VirtualDestination[] { virtualTopic });
0:         broker.setDestinationInterceptors(new DestinationInterceptor[] { interceptor });
1:         configurePersistenceAdapter(broker);
1: 
1:         SubQueueSelectorCacheBrokerPlugin selectorCacheBrokerPlugin = new SubQueueSelectorCacheBrokerPlugin();
1:         selectorCacheBrokerPlugin.setSingleSelectorPerDestination(true);
1:         File persisteFile = new File(PERSIST_SELECTOR_CACHE_FILE_BASEPATH + broker.getBrokerName());
1:         selectorCacheBrokerPlugin.setPersistFile(persisteFile);
1:         broker.setPlugins(new BrokerPlugin[]{selectorCacheBrokerPlugin});
1:         return broker;
1:     }
1: 
1:     protected void configurePersistenceAdapter(BrokerService broker)
1:             throws IOException {
1:         File dataFileDir = new File("target/test-amq-data/kahadb/"
1:                 + broker.getBrokerName());
1:         KahaDBStore kaha = new KahaDBStore();
1:         kaha.setDirectory(dataFileDir);
1:         broker.setPersistenceAdapter(kaha);
1:     }
1: 
1:     class ProducerThreadTester extends ProducerThread {
1: 
1:         private Set<String> selectors = new LinkedHashSet<String>();
1:         private Map<String, AtomicInteger> selectorCounts = new HashMap<String, AtomicInteger>();
1:         private Random rand = new Random(System.currentTimeMillis());
1: 
1: 
1:         public ProducerThreadTester(Session session, javax.jms.Destination destination) {
1:             super(session, destination);
1:         }
1: 
1:         @Override
1:         protected Message createMessage(int i) throws Exception {
1:             TextMessage msg = createTextMessage(this.session, "Message-" + i);
1:             if (selectors.size() > 0) {
1:                 String value = getRandomKey();
1:                 msg.setStringProperty("SYMBOL", value);
1:                 AtomicInteger currentCount = selectorCounts.get(value);
1:                 currentCount.incrementAndGet();
1:             }
1: 
1:             return msg;
1:         }
1: 
1:         @Override
1:         public void resetCounters() {
1:             super.resetCounters();
1:             for (String key : selectorCounts.keySet()) {
1:                 selectorCounts.put(key, new AtomicInteger(0));
1:             }
1:         }
1: 
1:         private String getRandomKey() {
1:             ArrayList<String> keys = new ArrayList(selectors);
1:             return keys.get(rand.nextInt(keys.size()));
1:         }
1: 
1:         public void addMessageProperty(String value) {
1:             if (!this.selectors.contains(value)) {
1:                 selectors.add(value);
1:                 selectorCounts.put(value, new AtomicInteger(0));
1:             }
1:         }
1: 
1:         public int getCountForProperty(String key) {
1:             return selectorCounts.get(key).get();
1:         }
1: 
1:     }
1: }
============================================================================