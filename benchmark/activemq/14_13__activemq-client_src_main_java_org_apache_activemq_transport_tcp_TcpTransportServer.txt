1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:0fffe21:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0fffe21:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.transport.tcp;
1:1773e2c: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.net.InetAddress;
1:26bb18b: import java.net.InetSocketAddress;
1:d29ca2a: import java.net.ServerSocket;
1:d29ca2a: import java.net.Socket;
1:3332220: import java.net.SocketException;
1:d29ca2a: import java.net.SocketTimeoutException;
1:d29ca2a: import java.net.URI;
1:d29ca2a: import java.net.URISyntaxException;
1:d29ca2a: import java.net.UnknownHostException;
1:ff99872: import java.nio.channels.ClosedChannelException;
1:e957937: import java.nio.channels.SelectionKey;
1:934a30a: import java.nio.channels.Selector;
1:e957937: import java.nio.channels.ServerSocketChannel;
1:e957937: import java.nio.channels.SocketChannel;
1:d29ca2a: import java.util.HashMap;
1:934a30a: import java.util.Iterator;
1:934a30a: import java.util.Set;
1:3d10acc: import java.util.concurrent.BlockingQueue;
1:3d10acc: import java.util.concurrent.LinkedBlockingQueue;
1:3d10acc: import java.util.concurrent.TimeUnit;
1:3f9b6ed: import java.util.concurrent.atomic.AtomicInteger;
1:f812e34: 
1:74a7a8b: import javax.net.ServerSocketFactory;
1:69fad2a: import javax.net.ssl.SSLParameters;
1:1773e2c: import javax.net.ssl.SSLServerSocket;
1:74a7a8b: 
1:391077e: import org.apache.activemq.Service;
1:3d10acc: import org.apache.activemq.ThreadPriorities;
1:9a8f6e4: import org.apache.activemq.TransportLoggerSupport;
1:f451ad0: import org.apache.activemq.command.BrokerInfo;
1:f451ad0: import org.apache.activemq.openwire.OpenWireFormatFactory;
1:f451ad0: import org.apache.activemq.transport.Transport;
1:04ee70a: import org.apache.activemq.transport.TransportFactory;
1:f451ad0: import org.apache.activemq.transport.TransportServer;
1:f451ad0: import org.apache.activemq.transport.TransportServerThreadSupport;
1:68c8c64: import org.apache.activemq.util.IOExceptionSupport;
1:8a1f994: import org.apache.activemq.util.InetAddressUtil;
1:3332220: import org.apache.activemq.util.IntrospectionSupport;
1:391077e: import org.apache.activemq.util.ServiceListener;
1:f451ad0: import org.apache.activemq.util.ServiceStopper;
1:391077e: import org.apache.activemq.util.ServiceSupport;
1:88acb0e: import org.apache.activemq.wireformat.WireFormat;
1:88acb0e: import org.apache.activemq.wireformat.WireFormatFactory;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:f812e34: 
1:d29ca2a: /**
1:d29ca2a:  * A TCP based implementation of {@link TransportServer}
1:d29ca2a:  */
1:e731c39: public class TcpTransportServer extends TransportServerThreadSupport implements ServiceListener {
1:68c8c64: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TcpTransportServer.class);
1:ff99872: 
1:ff99872:     protected volatile ServerSocket serverSocket;
1:ff99872:     protected volatile Selector selector;
1:68c8c64:     protected int backlog = 5000;
1:68c8c64:     protected WireFormatFactory wireFormatFactory = new OpenWireFormatFactory();
1:68c8c64:     protected final TcpTransportFactory transportFactory;
1:68c8c64:     protected long maxInactivityDuration = 30000;
1:f7cba2a:     protected long maxInactivityDurationInitalDelay = 10000;
1:68c8c64:     protected int minmumWireFormatVersion;
1:e731c39:     protected boolean useQueueForAccept = true;
1:7e000d5:     protected boolean allowLinkStealing;
1:1e31df9:     protected boolean verifyHostName = false;
1:7e000d5: 
1:d29ca2a:     /**
1:e731c39:      * trace=true -> the Transport stack where this TcpTransport object will be, will have a TransportLogger layer
1:e731c39:      * trace=false -> the Transport stack where this TcpTransport object will be, will NOT have a TransportLogger layer,
1:e731c39:      * and therefore will never be able to print logging messages. This parameter is most probably set in Connection or
1:e731c39:      * TransportConnector URIs.
1:d29ca2a:      */
1:df6b542:     protected boolean trace = false;
1:0fffe21: 
1:46b01cc:     protected int soTimeout = 0;
1:46b01cc:     protected int socketBufferSize = 64 * 1024;
1:e731c39:     protected int connectionTimeout = 30000;
1:68c8c64: 
1:c4d8d86:     /**
1:e731c39:      * Name of the LogWriter implementation to use. Names are mapped to classes in the
1:e731c39:      * resources/META-INF/services/org/apache/activemq/transport/logwriters directory. This parameter is most probably
1:e731c39:      * set in Connection or TransportConnector URIs.
1:c4d8d86:      */
1:9a8f6e4:     protected String logWriterName = TransportLoggerSupport.defaultLogWriterName;
1:e957937: 
1:d29ca2a:     /**
1:e731c39:      * Specifies if the TransportLogger will be manageable by JMX or not. Also, as long as there is at least 1
1:e731c39:      * TransportLogger which is manageable, a TransportLoggerControl MBean will me created.
1:d29ca2a:      */
1:df6b542:     protected boolean dynamicManagement = false;
1:e957937: 
1:9260494:     /**
1:e731c39:      * startLogging=true -> the TransportLogger object of the Transport stack will initially write messages to the log.
1:e731c39:      * startLogging=false -> the TransportLogger object of the Transport stack will initially NOT write messages to the
1:e731c39:      * log. This parameter only has an effect if trace == true. This parameter is most probably set in Connection or
1:e731c39:      * TransportConnector URIs.
1:9260494:      */
1:df6b542:     protected boolean startLogging = true;
1:5385fd1:     protected int jmxPort = TransportLoggerSupport.defaultJmxPort;
1:68c8c64:     protected final ServerSocketFactory serverSocketFactory;
1:ff99872:     protected final BlockingQueue<Socket> socketQueue = new LinkedBlockingQueue<Socket>();
1:3d10acc:     protected Thread socketHandlerThread;
1:e957937: 
1:391077e:     /**
1:391077e:      * The maximum number of sockets allowed for this server
1:391077e:      */
1:391077e:     protected int maximumConnections = Integer.MAX_VALUE;
1:ff99872:     protected final AtomicInteger currentTransportCount = new AtomicInteger();
1:0fffe21: 
1:e731c39:     public TcpTransportServer(TcpTransportFactory transportFactory, URI location, ServerSocketFactory serverSocketFactory) throws IOException,
1:e731c39:         URISyntaxException {
1:d29ca2a:         super(location);
1:f812e34:         this.transportFactory = transportFactory;
1:f812e34:         this.serverSocketFactory = serverSocketFactory;
1:d29ca2a:     }
1:0fffe21: 
1:68c8c64:     public void bind() throws IOException {
1:f812e34:         URI bind = getBindLocation();
1:c4d8d86: 
1:68c8c64:         String host = bind.getHost();
1:68c8c64:         host = (host == null || host.length() == 0) ? "localhost" : host;
1:68c8c64:         InetAddress addr = InetAddress.getByName(host);
1:f812e34: 
1:68c8c64:         try {
1:ff99872:             serverSocket = serverSocketFactory.createServerSocket(bind.getPort(), backlog, addr);
1:ff99872:             configureServerSocket(serverSocket);
1:f812e34:         } catch (IOException e) {
1:cab35d7:             throw IOExceptionSupport.create("Failed to bind to server socket: " + bind + " due to: " + e, e);
1:934a30a:         }
1:934a30a:         try {
1:e731c39:             setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), resolveHostName(serverSocket, addr), serverSocket.getLocalPort(), bind.getPath(),
1:e731c39:                 bind.getQuery(), bind.getFragment()));
1:f812e34:         } catch (URISyntaxException e) {
1:f812e34:             // it could be that the host name contains invalid characters such
1:e957937:             // as _ on unix platforms so lets try use the IP address instead
1:d29ca2a:             try {
1:e731c39:                 setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), addr.getHostAddress(), serverSocket.getLocalPort(), bind.getPath(),
1:e731c39:                     bind.getQuery(), bind.getFragment()));
1:8011f90:             } catch (URISyntaxException e2) {
1:8011f90:                 throw IOExceptionSupport.create(e2);
1:68c8c64:             }
1:68c8c64:         }
1:68c8c64:     }
1:934a30a: 
1:3332220:     private void configureServerSocket(ServerSocket socket) throws SocketException {
1:3332220:         socket.setSoTimeout(2000);
1:f8071a3:         if (transportOptions != null) {
1:934a30a: 
1:1773e2c:             // If the enabledCipherSuites option is invalid we don't want to ignore it as the call
1:1773e2c:             // to SSLServerSocket to configure it has a side effect on the socket rendering it
1:1773e2c:             // useless as all suites are enabled many of which are considered as insecure.  We
1:1773e2c:             // instead trap that option here and throw an exception.  We should really consider
1:1773e2c:             // all invalid options as breaking and not start the transport but the current design
1:1773e2c:             // doesn't really allow for this.
1:1773e2c:             //
1:1773e2c:             //  see: https://issues.apache.org/jira/browse/AMQ-4582
1:1773e2c:             //
1:1773e2c:             if (socket instanceof SSLServerSocket) {
1:69fad2a:                 if (transportOptions.containsKey("verifyHostName")) {
1:69fad2a:                     verifyHostName = Boolean.parseBoolean(transportOptions.get("verifyHostName").toString());
1:1e31df9:                 } else {
1:1e31df9:                     transportOptions.put("verifyHostName", verifyHostName);
1:69fad2a:                 }
1:69fad2a: 
1:69fad2a:                 if (verifyHostName) {
1:69fad2a:                     SSLParameters sslParams = new SSLParameters();
1:69fad2a:                     sslParams.setEndpointIdentificationAlgorithm("HTTPS");
1:69fad2a:                     ((SSLServerSocket)this.serverSocket).setSSLParameters(sslParams);
1:69fad2a:                 }
1:69fad2a: 
1:1773e2c:                 if (transportOptions.containsKey("enabledCipherSuites")) {
1:1773e2c:                     Object cipherSuites = transportOptions.remove("enabledCipherSuites");
1:934a30a: 
1:1773e2c:                     if (!IntrospectionSupport.setProperty(socket, "enabledCipherSuites", cipherSuites)) {
1:1773e2c:                         throw new SocketException(String.format(
1:1773e2c:                             "Invalid transport options {enabledCipherSuites=%s}", cipherSuites));
1:1773e2c:                     }
1:1773e2c:                 }
1:69fad2a: 
1:1773e2c:             }
1:1773e2c: 
1:f6bf823:             //AMQ-6599 - don't strip out set properties on the socket as we need to set them
1:f6bf823:             //on the Transport as well later
1:f6bf823:             IntrospectionSupport.setProperties(socket, transportOptions, false);
1:68c8c64:         }
1:f7cba2a:     }
1:1773e2c: 
1:391077e:     /**
1:d29ca2a:      * @return Returns the wireFormatFactory.
1:391077e:      */
1:d29ca2a:     public WireFormatFactory getWireFormatFactory() {
1:d29ca2a:         return wireFormatFactory;
1:d29ca2a:     }
1:0fffe21: 
1:d29ca2a:     /**
1:e731c39:      * @param wireFormatFactory
1:e731c39:      *            The wireFormatFactory to set.
1:d29ca2a:      */
1:d29ca2a:     public void setWireFormatFactory(WireFormatFactory wireFormatFactory) {
1:d29ca2a:         this.wireFormatFactory = wireFormatFactory;
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:e731c39:      * Associates a broker info with the transport server so that the transport can do discovery advertisements of the
1:e731c39:      * broker.
1:0fffe21:      *
1:d29ca2a:      * @param brokerInfo
1:d29ca2a:      */
1:3f9b6ed:     @Override
1:d29ca2a:     public void setBrokerInfo(BrokerInfo brokerInfo) {
1:d29ca2a:     }
1:68c8c64: 
1:1229c23:     public long getMaxInactivityDuration() {
1:1229c23:         return maxInactivityDuration;
1:1229c23:     }
1:68c8c64: 
1:1229c23:     public void setMaxInactivityDuration(long maxInactivityDuration) {
1:1229c23:         this.maxInactivityDuration = maxInactivityDuration;
1:1229c23:     }
1:0fffe21: 
1:f7cba2a:     public long getMaxInactivityDurationInitalDelay() {
1:f7cba2a:         return this.maxInactivityDurationInitalDelay;
1:d29ca2a:     }
1:68c8c64: 
1:f7cba2a:     public void setMaxInactivityDurationInitalDelay(long maxInactivityDurationInitalDelay) {
1:f7cba2a:         this.maxInactivityDurationInitalDelay = maxInactivityDurationInitalDelay;
1:d29ca2a:     }
1:f451ad0: 
1:1229c23:     public int getMinmumWireFormatVersion() {
1:1229c23:         return minmumWireFormatVersion;
1:1229c23:     }
1:26bb18b: 
1:1229c23:     public void setMinmumWireFormatVersion(int minmumWireFormatVersion) {
1:1229c23:         this.minmumWireFormatVersion = minmumWireFormatVersion;
1:1229c23:     }
1:1229c23: 
1:1229c23:     public boolean isTrace() {
1:1229c23:         return trace;
1:1229c23:     }
1:1229c23: 
1:1229c23:     public void setTrace(boolean trace) {
1:1229c23:         this.trace = trace;
1:c4d8d86:     }
1:0fffe21: 
1:c4d8d86:     public String getLogWriterName() {
1:c4d8d86:         return logWriterName;
1:c4d8d86:     }
1:c4d8d86: 
1:c4d8d86:     public void setLogWriterName(String logFormat) {
1:c4d8d86:         this.logWriterName = logFormat;
1:0fffe21:     }
1:d29ca2a: 
1:df6b542:     public boolean isDynamicManagement() {
1:df6b542:         return dynamicManagement;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     public void setDynamicManagement(boolean useJmx) {
1:df6b542:         this.dynamicManagement = useJmx;
1:d29ca2a:     }
1:d29ca2a: 
1:5385fd1:     public void setJmxPort(int jmxPort) {
1:5385fd1:         this.jmxPort = jmxPort;
1:5385fd1:     }
1:5385fd1: 
1:5385fd1:     public int getJmxPort() {
1:5385fd1:         return jmxPort;
1:5385fd1:     }
1:5385fd1: 
1:df6b542:     public boolean isStartLogging() {
1:df6b542:         return startLogging;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     public void setStartLogging(boolean startLogging) {
1:df6b542:         this.startLogging = startLogging;
1:d29ca2a:     }
1:0fffe21: 
1:d29ca2a:     /**
1:9260494:      * @return the backlog
1:d29ca2a:      */
1:9260494:     public int getBacklog() {
1:9260494:         return backlog;
1:d29ca2a:     }
1:d29ca2a: 
1:391077e:     /**
1:e731c39:      * @param backlog
1:e731c39:      *            the backlog to set
1:9260494:      */
1:9260494:     public void setBacklog(int backlog) {
1:9260494:         this.backlog = backlog;
1:d29ca2a:     }
1:d29ca2a: 
1:9260494:     /**
1:9260494:      * @return the useQueueForAccept
1:9260494:      */
1:9260494:     public boolean isUseQueueForAccept() {
1:9260494:         return useQueueForAccept;
1:f7cba2a:     }
1:d29ca2a: 
1:9260494:     /**
1:e731c39:      * @param useQueueForAccept
1:e731c39:      *            the useQueueForAccept to set
1:9260494:      */
1:9260494:     public void setUseQueueForAccept(boolean useQueueForAccept) {
1:9260494:         this.useQueueForAccept = useQueueForAccept;
1:f8071a3:     }
1:d29ca2a: 
1:9260494:     /**
1:d29ca2a:      * pull Sockets from the ServerSocket
1:d29ca2a:      */
1:e957937:     @Override
1:d29ca2a:     public void run() {
1:ff99872:         if (!isStopped() && !isStopping()) {
1:ff99872:             final ServerSocket serverSocket = this.serverSocket;
1:ff99872:             if (serverSocket == null) {
1:ff99872:                 onAcceptError(new IOException("Server started without a valid ServerSocket"));
1:ff99872:             }
1:ff99872: 
1:ff99872:             final ServerSocketChannel channel = serverSocket.getChannel();
1:ff99872:             if (channel != null) {
1:ff99872:                 doRunWithServerSocketChannel(channel);
1:ff99872:             } else {
1:ff99872:                 doRunWithServerSocket(serverSocket);
1:ff99872:             }
1:ff99872:         }
1:ff99872:     }
1:ff99872: 
1:ff99872:     private void doRunWithServerSocketChannel(final ServerSocketChannel channel) {
1:ff99872:         try {
1:ff99872:             channel.configureBlocking(false);
1:ff99872:             final Selector selector = Selector.open();
1:ff99872: 
1:e957937:             try {
1:ff99872:                 channel.register(selector, SelectionKey.OP_ACCEPT);
1:ff99872:             } catch (ClosedChannelException ex) {
1:ff99872:                 try {
1:ff99872:                     selector.close();
1:ff99872:                 } catch (IOException ignore) {}
1:d29ca2a: 
1:ff99872:                 throw ex;
1:ff99872:             }
1:d29ca2a: 
1:ff99872:             // Update object instance for later cleanup.
1:ff99872:             this.selector = selector;
1:f7cba2a: 
1:ff99872:             while (!isStopped()) {
1:ff99872:                 int count = selector.select(10);
1:ff99872: 
1:ff99872:                 if (count == 0) {
1:ff99872:                     continue;
1:ff99872:                 }
1:ff99872: 
1:ff99872:                 Set<SelectionKey> keys = selector.selectedKeys();
1:ff99872: 
1:ff99872:                 for (Iterator<SelectionKey> i = keys.iterator(); i.hasNext(); ) {
1:ff99872:                     final SelectionKey key = i.next();
1:ff99872:                     if (key.isAcceptable()) {
1:ff99872:                         try {
1:ff99872:                             SocketChannel sc = channel.accept();
1:ff99872:                             if (sc != null) {
1:ff99872:                                 if (isStopped() || getAcceptListener() == null) {
1:ff99872:                                     sc.close();
1:ff99872:                                 } else {
1:ff99872:                                     if (useQueueForAccept) {
1:ff99872:                                         socketQueue.put(sc.socket());
3:e957937:                                     } else {
1:ff99872:                                         handleSocket(sc.socket());
1:ff99872:                                     }
1:e957937:                                 }
1:e957937:                             }
1:934a30a: 
1:ff99872:                         } catch (SocketTimeoutException ste) {
1:ff99872:                             // expect this to happen
1:ff99872:                         } catch (Exception e) {
1:ff99872:                             e.printStackTrace();
1:ff99872:                             if (!isStopping()) {
1:ff99872:                                 onAcceptError(e);
1:ff99872:                             } else if (!isStopped()) {
1:ff99872:                                 LOG.warn("run()", e);
1:ff99872:                                 onAcceptError(e);
1:e957937:                             }
1:e957937:                         }
1:e957937:                     }
1:ff99872:                     i.remove();
1:e957937:                 }
1:e957937:             }
1:ff99872:         } catch (IOException ex) {
1:ff99872:             if (!isStopping()) {
1:ff99872:                 onAcceptError(ex);
1:ff99872:             } else if (!isStopped()) {
1:ff99872:                 LOG.warn("run()", ex);
1:ff99872:                 onAcceptError(ex);
1:ff99872:             }
1:ff99872:         }
1:ff99872:     }
1:ff99872: 
1:ff99872:     private void doRunWithServerSocket(final ServerSocket serverSocket) {
1:ff99872:         while (!isStopped()) {
1:ff99872:             Socket socket = null;
1:ff99872:             try {
1:ff99872:                 socket = serverSocket.accept();
1:ff99872:                 if (socket != null) {
1:ff99872:                     if (isStopped() || getAcceptListener() == null) {
1:ff99872:                         socket.close();
1:ff99872:                     } else {
1:ff99872:                         if (useQueueForAccept) {
1:ff99872:                             socketQueue.put(socket);
1:e957937:                         } else {
1:ff99872:                             handleSocket(socket);
1:ff99872:                         }
1:934a30a:                     }
1:934a30a:                 }
1:ff99872:             } catch (SocketTimeoutException ste) {
1:ff99872:                 // expect this to happen
1:ff99872:             } catch (Exception e) {
1:ff99872:                 if (!isStopping()) {
1:ff99872:                     onAcceptError(e);
1:ff99872:                 } else if (!isStopped()) {
1:ff99872:                     LOG.warn("run()", e);
1:ff99872:                     onAcceptError(e);
1:934a30a:                 }
1:e731c39:             }
1:0fffe21:         }
1:d29ca2a:     }
1:934a30a: 
1:d29ca2a:     /**
1:e731c39:      * Allow derived classes to override the Transport implementation that this transport server creates.
1:0fffe21:      *
1:0fffe21:      * @param socket
1:b4b8499:      * @param format
1:d8c0ff1:      *
1:d8c0ff1:      * @return a new Transport instance.
1:d8c0ff1:      *
1:b4b8499:      * @throws IOException
1:b4b8499:      */
1:e731c39:     protected Transport createTransport(Socket socket, WireFormat format) throws IOException {
1:f812e34:         return new TcpTransport(format, socket);
1:f812e34:     }
1:b4b8499: 
1:b4b8499:     /**
1:d29ca2a:      * @return pretty print of this
1:d29ca2a:      */
1:e957937:     @Override
1:d29ca2a:     public String toString() {
1:f812e34:         return "" + getBindLocation();
1:b4b8499:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:b4b8499:      * @param socket
1:7e000d5:      * @param bindAddress
1:d29ca2a:      * @return real hostName
3:d29ca2a:      * @throws UnknownHostException
1:d29ca2a:      */
1:b56cb8f:     protected String resolveHostName(ServerSocket socket, InetAddress bindAddress) throws UnknownHostException {
1:b56cb8f:         String result = null;
1:b56cb8f:         if (socket.isBound()) {
1:b56cb8f:             if (socket.getInetAddress().isAnyLocalAddress()) {
1:b56cb8f:                 // make it more human readable and useful, an alternative to 0.0.0.0
1:8a1f994:                 result = InetAddressUtil.getLocalHostName();
1:e957937:             } else {
1:b56cb8f:                 result = socket.getInetAddress().getCanonicalHostName();
1:d29ca2a:             }
1:e957937:         } else {
1:b56cb8f:             result = bindAddress.getCanonicalHostName();
1:d29ca2a:         }
1:d29ca2a:         return result;
1:d29ca2a:     }
1:0fffe21: 
1:3f9b6ed:     @Override
1:3d10acc:     protected void doStart() throws Exception {
2:e957937:         if (useQueueForAccept) {
1:9260494:             Runnable run = new Runnable() {
1:3f9b6ed:                 @Override
1:9260494:                 public void run() {
1:934a30a:                     try {
1:9260494:                         while (!isStopped() && !isStopping()) {
1:9260494:                             Socket sock = socketQueue.poll(1, TimeUnit.SECONDS);
1:9260494:                             if (sock != null) {
1:d8cd370:                                 try {
1:d8cd370:                                     handleSocket(sock);
1:d8cd370:                                 } catch (Throwable thrown) {
1:e957937:                                     if (!isStopping()) {
1:d8cd370:                                         onAcceptError(new Exception(thrown));
1:e957937:                                     } else if (!isStopped()) {
1:d8cd370:                                         LOG.warn("Unexpected error thrown during accept handling: ", thrown);
1:d8cd370:                                         onAcceptError(new Exception(thrown));
1:d8cd370:                                     }
1:d8cd370:                                 }
1:d29ca2a:                             }
1:d29ca2a:                         }
1:0fffe21: 
1:9260494:                     } catch (InterruptedException e) {
1:15412ba:                         if (!isStopped() || !isStopping()) {
1:15412ba:                             LOG.info("socketQueue interrupted - stopping");
2:e957937:                             onAcceptError(e);
1:d29ca2a:                         }
1:d29ca2a:                     }
1:b56cb8f:                 }
1:9260494:             };
1:e731c39:             socketHandlerThread = new Thread(null, run, "ActiveMQ Transport Server Thread Handler: " + toString(), getStackSize());
1:9260494:             socketHandlerThread.setDaemon(true);
1:e731c39:             socketHandlerThread.setPriority(ThreadPriorities.BROKER_MANAGEMENT - 1);
1:9260494:             socketHandlerThread.start();
1:3332220:         }
1:3d10acc:         super.doStart();
2:391077e:     }
1:0fffe21: 
1:3f9b6ed:     @Override
1:d29ca2a:     protected void doStop(ServiceStopper stopper) throws Exception {
1:ff99872:         Exception firstFailure = null;
1:ff99872: 
1:ff99872:         try {
1:ff99872:             if (selector != null) {
1:ff99872:                 selector.close();
1:cc849e7:                 selector = null;
1:ff99872:             }
1:ff99872:         } catch (Exception error) {
1:e957937:         }
1:ff99872: 
1:ff99872:         try {
1:ff99872:             final ServerSocket serverSocket = this.serverSocket;
1:ff99872:             if (serverSocket != null) {
1:ff99872:                 this.serverSocket = null;
1:ff99872:                 serverSocket.close();
1:ff99872:             }
1:ff99872:         } catch (Exception error) {
1:ff99872:             firstFailure = error;
1:e957937:         }
1:ff99872: 
1:4adc8e4:         if (socketHandlerThread != null) {
1:4adc8e4:             socketHandlerThread.interrupt();
1:4adc8e4:             socketHandlerThread = null;
1:4adc8e4:         }
1:ff99872: 
1:ff99872:         try {
1:efcef45:             super.doStop(stopper);
1:ff99872:         } catch (Exception error) {
1:ff99872:             if (firstFailure != null) {
1:ff99872:                 firstFailure = error;
1:ff99872:             }
1:ff99872:         }
1:ff99872: 
1:ff99872:         if (firstFailure != null) {
1:ff99872:             throw firstFailure;
1:ff99872:         }
1:e957937:     }
1:0fffe21: 
1:3f9b6ed:     @Override
1:26bb18b:     public InetSocketAddress getSocketAddress() {
1:e731c39:         return (InetSocketAddress) serverSocket.getLocalSocketAddress();
1:e957937:     }
1:2ee58ca: 
1:04ee70a:     protected void handleSocket(Socket socket) {
1:04ee70a:         doHandleSocket(socket);
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     final protected void doHandleSocket(Socket socket) {
1:e731c39:         boolean closeSocket = true;
1:e14aca8:         boolean countIncremented = false;
1:e957937:         try {
1:e14aca8:             int currentCount;
1:e14aca8:             do {
1:e14aca8:                 currentCount = currentTransportCount.get();
1:e14aca8:                 if (currentCount >= this.maximumConnections) {
1:e14aca8:                      throw new ExceededMaximumConnectionsException(
1:e14aca8:                          "Exceeded the maximum number of allowed client connections. See the '" +
1:e14aca8:                          "maximumConnections' property on the TCP transport configuration URI " +
1:e14aca8:                          "in the ActiveMQ configuration file (e.g., activemq.xml)");
1:e14aca8:                  }
1:04ee70a: 
1:e14aca8:             //Increment this value before configuring the transport
1:e14aca8:             //This is necessary because some of the transport servers must read from the
1:e14aca8:             //socket during configureTransport() so we want to make sure this value is
1:e14aca8:             //accurate as the transport server could pause here waiting for data to be sent from a client
1:e14aca8:             } while(!currentTransportCount.compareAndSet(currentCount, currentCount + 1));
1:e14aca8:             countIncremented = true;
1:1229c23: 
1:e14aca8:             HashMap<String, Object> options = new HashMap<String, Object>();
1:e14aca8:             options.put("maxInactivityDuration", Long.valueOf(maxInactivityDuration));
1:e14aca8:             options.put("maxInactivityDurationInitalDelay", Long.valueOf(maxInactivityDurationInitalDelay));
1:e14aca8:             options.put("minmumWireFormatVersion", Integer.valueOf(minmumWireFormatVersion));
1:e14aca8:             options.put("trace", Boolean.valueOf(trace));
1:e14aca8:             options.put("soTimeout", Integer.valueOf(soTimeout));
1:e14aca8:             options.put("socketBufferSize", Integer.valueOf(socketBufferSize));
1:e14aca8:             options.put("connectionTimeout", Integer.valueOf(connectionTimeout));
1:e14aca8:             options.put("logWriterName", logWriterName);
1:e14aca8:             options.put("dynamicManagement", Boolean.valueOf(dynamicManagement));
1:e14aca8:             options.put("startLogging", Boolean.valueOf(startLogging));
1:5385fd1:             options.put("jmxPort", Integer.valueOf(jmxPort));
1:e14aca8:             options.putAll(transportOptions);
1:1229c23: 
1:e14aca8:             TransportInfo transportInfo = configureTransport(this, socket);
1:e14aca8:             closeSocket = false;
1:1229c23: 
1:e14aca8:             if (transportInfo.transport instanceof ServiceSupport) {
1:e14aca8:                 ((ServiceSupport) transportInfo.transport).addServiceListener(this);
1:e957937:             }
1:e14aca8: 
1:e14aca8:             Transport configuredTransport = transportInfo.transportFactory.serverConfigure(
1:e14aca8:                     transportInfo.transport, transportInfo.format, options);
1:e14aca8: 
1:e14aca8:             getAcceptListener().onAccept(configuredTransport);
1:e14aca8: 
1:e957937:         } catch (SocketTimeoutException ste) {
1:e957937:             // expect this to happen
2:e957937:         } catch (Exception e) {
1:e731c39:             if (closeSocket) {
1:e731c39:                 try {
1:e14aca8:                     //if closing the socket, only decrement the count it was actually incremented
1:e14aca8:                     //where it was incremented
1:e14aca8:                     if (countIncremented) {
1:e14aca8:                         currentTransportCount.decrementAndGet();
1:e14aca8:                     }
1:e957937:                     socket.close();
1:e731c39:                 } catch (Exception ignore) {
1:934a30a:                 }
1:e731c39:             }
1:e731c39: 
1:e957937:             if (!isStopping()) {
1:e957937:                 onAcceptError(e);
1:e957937:             } else if (!isStopped()) {
2:e957937:                 LOG.warn("run()", e);
1:e957937:                 onAcceptError(e);
1:2ee58ca:             }
1:26bb18b:         }
1:1229c23:     }
1:1229c23: 
1:04ee70a:     protected TransportInfo configureTransport(final TcpTransportServer server, final Socket socket) throws Exception {
1:04ee70a:         WireFormat format = wireFormatFactory.createWireFormat();
1:04ee70a:         Transport transport = createTransport(socket, format);
1:04ee70a:         return new TransportInfo(format, transport, transportFactory);
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     protected class TransportInfo {
1:04ee70a:         final WireFormat format;
1:04ee70a:         final Transport transport;
1:04ee70a:         final TransportFactory transportFactory;
1:04ee70a: 
1:04ee70a:         public TransportInfo(WireFormat format, Transport transport, TransportFactory transportFactory) {
1:04ee70a:             this.format = format;
1:04ee70a:             this.transport = transport;
1:04ee70a:             this.transportFactory = transportFactory;
1:04ee70a:         }
1:04ee70a:     }
1:04ee70a: 
1:0fffe21:     public int getSoTimeout() {
1:0fffe21:         return soTimeout;
1:0fffe21:     }
1:d29ca2a: 
1:0fffe21:     public void setSoTimeout(int soTimeout) {
1:0fffe21:         this.soTimeout = soTimeout;
1:0fffe21:     }
1:d29ca2a: 
1:0fffe21:     public int getSocketBufferSize() {
1:0fffe21:         return socketBufferSize;
1:0fffe21:     }
1:d29ca2a: 
1:0fffe21:     public void setSocketBufferSize(int socketBufferSize) {
1:0fffe21:         this.socketBufferSize = socketBufferSize;
1:0fffe21:     }
1:0f19071: 
1:0fffe21:     public int getConnectionTimeout() {
1:0fffe21:         return connectionTimeout;
1:0fffe21:     }
1:0fffe21: 
1:0fffe21:     public void setConnectionTimeout(int connectionTimeout) {
1:0fffe21:         this.connectionTimeout = connectionTimeout;
1:0fffe21:     }
1:0f19071: 
1:d29ca2a:     /**
1:391077e:      * @return the maximumConnections
1:d29ca2a:      */
1:391077e:     public int getMaximumConnections() {
1:391077e:         return maximumConnections;
1:d29ca2a:     }
1:0f19071: 
1:d29ca2a:     /**
1:e731c39:      * @param maximumConnections
1:e731c39:      *            the maximumConnections to set
1:391077e:      */
1:391077e:     public void setMaximumConnections(int maximumConnections) {
1:391077e:         this.maximumConnections = maximumConnections;
1:d29ca2a:     }
1:f7cba2a: 
1:04ee70a:     public AtomicInteger getCurrentTransportCount() {
1:04ee70a:         return currentTransportCount;
1:04ee70a:     }
1:04ee70a: 
1:3f9b6ed:     @Override
1:391077e:     public void started(Service service) {
1:d29ca2a:     }
1:3332220: 
1:3f9b6ed:     @Override
1:391077e:     public void stopped(Service service) {
1:3f9b6ed:         this.currentTransportCount.decrementAndGet();
1:0f19071:     }
1:0fffe21: 
2:3f9b6ed:     @Override
1:0fffe21:     public boolean isSslServer() {
1:0fffe21:         return false;
1:0fffe21:     }
1:7e000d5: 
1:7e000d5:     @Override
1:7e000d5:     public boolean isAllowLinkStealing() {
1:7e000d5:         return allowLinkStealing;
1:7e000d5:     }
1:7e000d5: 
1:d8cd370:     @Override
1:7e000d5:     public void setAllowLinkStealing(boolean allowLinkStealing) {
1:7e000d5:         this.allowLinkStealing = allowLinkStealing;
1:7e000d5:     }
1:0f19071: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:1e31df9
/////////////////////////////////////////////////////////////////////////
1:     protected boolean verifyHostName = false;
/////////////////////////////////////////////////////////////////////////
1:                 } else {
1:                     transportOptions.put("verifyHostName", verifyHostName);
commit:69fad2a
/////////////////////////////////////////////////////////////////////////
1: import javax.net.ssl.SSLParameters;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean verifyHostName = true;
/////////////////////////////////////////////////////////////////////////
1:                 if (transportOptions.containsKey("verifyHostName")) {
1:                     verifyHostName = Boolean.parseBoolean(transportOptions.get("verifyHostName").toString());
1:                 }
1: 
1:                 if (verifyHostName) {
1:                     SSLParameters sslParams = new SSLParameters();
1:                     sslParams.setEndpointIdentificationAlgorithm("HTTPS");
1:                     ((SSLServerSocket)this.serverSocket).setSSLParameters(sslParams);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:f6bf823
/////////////////////////////////////////////////////////////////////////
1:             //AMQ-6599 - don't strip out set properties on the socket as we need to set them
1:             //on the Transport as well later
1:             IntrospectionSupport.setProperties(socket, transportOptions, false);
commit:4adc8e4
/////////////////////////////////////////////////////////////////////////
1:         if (socketHandlerThread != null) {
1:             socketHandlerThread.interrupt();
1:             socketHandlerThread = null;
1:         }
commit:e14aca8
/////////////////////////////////////////////////////////////////////////
1:         boolean countIncremented = false;
1:             int currentCount;
1:             do {
1:                 currentCount = currentTransportCount.get();
1:                 if (currentCount >= this.maximumConnections) {
1:                      throw new ExceededMaximumConnectionsException(
1:                          "Exceeded the maximum number of allowed client connections. See the '" +
1:                          "maximumConnections' property on the TCP transport configuration URI " +
1:                          "in the ActiveMQ configuration file (e.g., activemq.xml)");
1:                  }
1:             //Increment this value before configuring the transport
1:             //This is necessary because some of the transport servers must read from the
1:             //socket during configureTransport() so we want to make sure this value is
1:             //accurate as the transport server could pause here waiting for data to be sent from a client
1:             } while(!currentTransportCount.compareAndSet(currentCount, currentCount + 1));
1:             countIncremented = true;
1:             HashMap<String, Object> options = new HashMap<String, Object>();
1:             options.put("maxInactivityDuration", Long.valueOf(maxInactivityDuration));
1:             options.put("maxInactivityDurationInitalDelay", Long.valueOf(maxInactivityDurationInitalDelay));
1:             options.put("minmumWireFormatVersion", Integer.valueOf(minmumWireFormatVersion));
1:             options.put("trace", Boolean.valueOf(trace));
1:             options.put("soTimeout", Integer.valueOf(soTimeout));
1:             options.put("socketBufferSize", Integer.valueOf(socketBufferSize));
1:             options.put("connectionTimeout", Integer.valueOf(connectionTimeout));
1:             options.put("logWriterName", logWriterName);
1:             options.put("dynamicManagement", Boolean.valueOf(dynamicManagement));
1:             options.put("startLogging", Boolean.valueOf(startLogging));
1:             options.putAll(transportOptions);
1:             TransportInfo transportInfo = configureTransport(this, socket);
1:             closeSocket = false;
1:             if (transportInfo.transport instanceof ServiceSupport) {
1:                 ((ServiceSupport) transportInfo.transport).addServiceListener(this);
1: 
1:             Transport configuredTransport = transportInfo.transportFactory.serverConfigure(
1:                     transportInfo.transport, transportInfo.format, options);
1: 
1:             getAcceptListener().onAccept(configuredTransport);
1: 
1:                     //if closing the socket, only decrement the count it was actually incremented
1:                     //where it was incremented
1:                     if (countIncremented) {
1:                         currentTransportCount.decrementAndGet();
1:                     }
commit:04ee70a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransportFactory;
/////////////////////////////////////////////////////////////////////////
1:     protected void handleSocket(Socket socket) {
1:         doHandleSocket(socket);
1:     }
1: 
1:     final protected void doHandleSocket(Socket socket) {
/////////////////////////////////////////////////////////////////////////
0:                 currentTransportCount.incrementAndGet();
1: 
/////////////////////////////////////////////////////////////////////////
0:                 TransportInfo transportInfo = configureTransport(this, socket);
0:                 if (transportInfo.transport instanceof ServiceSupport) {
0:                     ((ServiceSupport) transportInfo.transport).addServiceListener(this);
0:                 Transport configuredTransport = transportInfo.transportFactory.serverConfigure(
0:                         transportInfo.transport, transportInfo.format, options);
0:             currentTransportCount.decrementAndGet();
0:             currentTransportCount.decrementAndGet();
/////////////////////////////////////////////////////////////////////////
1:     protected TransportInfo configureTransport(final TcpTransportServer server, final Socket socket) throws Exception {
1:         WireFormat format = wireFormatFactory.createWireFormat();
1:         Transport transport = createTransport(socket, format);
1:         return new TransportInfo(format, transport, transportFactory);
1:     }
1: 
1:     protected class TransportInfo {
1:         final WireFormat format;
1:         final Transport transport;
1:         final TransportFactory transportFactory;
1: 
1:         public TransportInfo(WireFormat format, Transport transport, TransportFactory transportFactory) {
1:             this.format = format;
1:             this.transport = transport;
1:             this.transportFactory = transportFactory;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public AtomicInteger getCurrentTransportCount() {
1:         return currentTransportCount;
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
commit:3845aaa
/////////////////////////////////////////////////////////////////////////
0:             serverSocket = null;
commit:efcef45
/////////////////////////////////////////////////////////////////////////
1:         super.doStop(stopper);
author:gtully
-------------------------------------------------------------------------------
commit:5385fd1
/////////////////////////////////////////////////////////////////////////
1:     protected int jmxPort = TransportLoggerSupport.defaultJmxPort;
/////////////////////////////////////////////////////////////////////////
1:     public void setJmxPort(int jmxPort) {
1:         this.jmxPort = jmxPort;
1:     }
1: 
1:     public int getJmxPort() {
1:         return jmxPort;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             options.put("jmxPort", Integer.valueOf(jmxPort));
commit:15412ba
/////////////////////////////////////////////////////////////////////////
1:                         if (!isStopped() || !isStopping()) {
1:                             LOG.info("socketQueue interrupted - stopping");
author:Timothy Bish
-------------------------------------------------------------------------------
commit:cc849e7
/////////////////////////////////////////////////////////////////////////
1:                 selector = null;
commit:ff99872
/////////////////////////////////////////////////////////////////////////
1: import java.nio.channels.ClosedChannelException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected volatile ServerSocket serverSocket;
1:     protected volatile Selector selector;
/////////////////////////////////////////////////////////////////////////
1:     protected final BlockingQueue<Socket> socketQueue = new LinkedBlockingQueue<Socket>();
1:     protected final AtomicInteger currentTransportCount = new AtomicInteger();
/////////////////////////////////////////////////////////////////////////
1:             serverSocket = serverSocketFactory.createServerSocket(bind.getPort(), backlog, addr);
1:             configureServerSocket(serverSocket);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (!isStopped() && !isStopping()) {
1:             final ServerSocket serverSocket = this.serverSocket;
1:             if (serverSocket == null) {
1:                 onAcceptError(new IOException("Server started without a valid ServerSocket"));
1:             }
1: 
1:             final ServerSocketChannel channel = serverSocket.getChannel();
1:             if (channel != null) {
1:                 doRunWithServerSocketChannel(channel);
1:             } else {
1:                 doRunWithServerSocket(serverSocket);
1:             }
1:         }
1:     }
1: 
1:     private void doRunWithServerSocketChannel(final ServerSocketChannel channel) {
1:         try {
1:             channel.configureBlocking(false);
1:             final Selector selector = Selector.open();
1: 
1:                 channel.register(selector, SelectionKey.OP_ACCEPT);
1:             } catch (ClosedChannelException ex) {
1:                 try {
1:                     selector.close();
1:                 } catch (IOException ignore) {}
1:                 throw ex;
1:             }
1:             // Update object instance for later cleanup.
1:             this.selector = selector;
1:             while (!isStopped()) {
1:                 int count = selector.select(10);
1: 
1:                 if (count == 0) {
1:                     continue;
1:                 }
1: 
1:                 Set<SelectionKey> keys = selector.selectedKeys();
1: 
1:                 for (Iterator<SelectionKey> i = keys.iterator(); i.hasNext(); ) {
1:                     final SelectionKey key = i.next();
1:                     if (key.isAcceptable()) {
1:                         try {
1:                             SocketChannel sc = channel.accept();
1:                             if (sc != null) {
1:                                 if (isStopped() || getAcceptListener() == null) {
1:                                     sc.close();
1:                                 } else {
1:                                     if (useQueueForAccept) {
1:                                         socketQueue.put(sc.socket());
1:                                         handleSocket(sc.socket());
1:                             }
1:                         } catch (SocketTimeoutException ste) {
1:                             // expect this to happen
1:                         } catch (Exception e) {
1:                             e.printStackTrace();
1:                             if (!isStopping()) {
1:                                 onAcceptError(e);
1:                             } else if (!isStopped()) {
1:                                 LOG.warn("run()", e);
1:                                 onAcceptError(e);
1:                     i.remove();
1:         } catch (IOException ex) {
1:             if (!isStopping()) {
1:                 onAcceptError(ex);
1:             } else if (!isStopped()) {
1:                 LOG.warn("run()", ex);
1:                 onAcceptError(ex);
1:             }
1:         }
1:     }
1: 
1:     private void doRunWithServerSocket(final ServerSocket serverSocket) {
1:         while (!isStopped()) {
1:             Socket socket = null;
1:             try {
1:                 socket = serverSocket.accept();
1:                 if (socket != null) {
1:                     if (isStopped() || getAcceptListener() == null) {
1:                         socket.close();
1:                     } else {
1:                         if (useQueueForAccept) {
1:                             socketQueue.put(socket);
1:                             handleSocket(socket);
1:                 }
1:             } catch (SocketTimeoutException ste) {
1:                 // expect this to happen
1:             } catch (Exception e) {
1:                 if (!isStopping()) {
1:                     onAcceptError(e);
1:                 } else if (!isStopped()) {
1:                     LOG.warn("run()", e);
1:                     onAcceptError(e);
/////////////////////////////////////////////////////////////////////////
1:         Exception firstFailure = null;
1: 
1:         try {
0:             final Selector selector = this.selector;
1:             if (selector != null) {
0:                 this.selector = null;
1:                 selector.close();
1:             }
1:         } catch (Exception error) {
1: 
1:         try {
1:             final ServerSocket serverSocket = this.serverSocket;
1:             if (serverSocket != null) {
1:                 this.serverSocket = null;
1:                 serverSocket.close();
1:             }
1:         } catch (Exception error) {
1:             firstFailure = error;
1: 
1: 
1:         try {
0:             super.doStop(stopper);
1:         } catch (Exception error) {
1:             if (firstFailure != null) {
1:                 firstFailure = error;
1:             }
1:         }
1: 
1:         if (firstFailure != null) {
1:             throw firstFailure;
1:         }
commit:d8c0ff1
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @return a new Transport instance.
1:      *
commit:e957937
/////////////////////////////////////////////////////////////////////////
1: import java.nio.channels.SelectionKey;
1: import java.nio.channels.ServerSocketChannel;
1: import java.nio.channels.SocketChannel;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.nio.SelectorManager;
0: import org.apache.activemq.transport.nio.SelectorSelection;
/////////////////////////////////////////////////////////////////////////
0:     protected SelectorSelection selector;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             // as _ on unix platforms so lets try use the IP address instead
/////////////////////////////////////////////////////////////////////////
0:         final ServerSocketChannel chan = serverSocket.getChannel();
0:         if (chan != null) {
0:                 chan.configureBlocking(false);
0:                 selector = SelectorManager.getInstance().register(chan, new SelectorManager.Listener() {
1:                     @Override
0:                     public void onSelect(SelectorSelection sel) {
1:                         try {
0:                             SocketChannel sc = chan.accept();
0:                             if (sc != null) {
0:                                 if (isStopped() || getAcceptListener() == null) {
0:                                     sc.close();
1:                                 } else {
1:                                     if (useQueueForAccept) {
0:                                         socketQueue.put(sc.socket());
1:                                     } else {
0:                                         handleSocket(sc.socket());
1:                                     }
1:                                 }
1:                             }
1:                         } catch (Exception e) {
0:                             onError(sel, e);
1:                     @Override
0:                     public void onError(SelectorSelection sel, Throwable error) {
0:                         Exception e = null;
0:                         if (error instanceof Exception) {
0:                             e = (Exception)error;
1:                         } else {
0:                             e = new Exception(error);
1:                         }
1:                         if (!isStopping()) {
1:                             onAcceptError(e);
1:                         } else if (!isStopped()) {
1:                             LOG.warn("run()", e);
1:                             onAcceptError(e);
1:                         }
1:                     }
0:                 });
0:                 selector.setInterestOps(SelectionKey.OP_ACCEPT);
0:                 selector.enable();
0:             } catch (IOException ex) {
0:                 selector = null;
1:             }
1:         } else {
0:             while (!isStopped()) {
0:                 Socket socket = null;
1:                 try {
0:                     socket = serverSocket.accept();
0:                     if (socket != null) {
0:                         if (isStopped() || getAcceptListener() == null) {
1:                             socket.close();
1:                         } else {
1:                             if (useQueueForAccept) {
0:                                 socketQueue.put(socket);
1:                             } else {
0:                                 handleSocket(socket);
1:                             }
1:                         }
1:                     }
1:                 } catch (SocketTimeoutException ste) {
1:                     // expect this to happen
1:                 } catch (Exception e) {
1:                     if (!isStopping()) {
1:                         onAcceptError(e);
1:                     } else if (!isStopped()) {
1:                         LOG.warn("run()", e);
1:                         onAcceptError(e);
1:                     }
/////////////////////////////////////////////////////////////////////////
0:         if (selector != null) {
0:             selector.disable();
0:             selector.close();
0:             selector = null;
1:         }
commit:d8cd370
/////////////////////////////////////////////////////////////////////////
1:                                 try {
1:                                     handleSocket(sock);
1:                                 } catch (Throwable thrown) {
0:                                     if (!isStopping()) {
1:                                         onAcceptError(new Exception(thrown));
0:                                     } else if (!isStopped()) {
1:                                         LOG.warn("Unexpected error thrown during accept handling: ", thrown);
1:                                         onAcceptError(new Exception(thrown));
1:                                     }
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:934a30a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.channels.Selector;
1: import java.util.Iterator;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     protected Selector selector;
/////////////////////////////////////////////////////////////////////////
0:                 selector = Selector.open();
0:                 chan.register(selector, SelectionKey.OP_ACCEPT);
0:                 while (!isStopped()) {
0:                     int count = selector.select(10);
1: 
0:                     if (count == 0) {
0:                         continue;
1:                     }
1: 
0:                     Set<SelectionKey> keys = selector.selectedKeys();
1: 
0:                     for (Iterator<SelectionKey> i = keys.iterator(); i.hasNext(); ) {
0:                         final SelectionKey key = i.next();
0:                         if (key.isAcceptable()) {
1:                             try {
0:                                 SocketChannel sc = chan.accept();
0:                                 if (sc != null) {
0:                                     if (isStopped() || getAcceptListener() == null) {
0:                                         sc.close();
0:                                         if (useQueueForAccept) {
0:                                             socketQueue.put(sc.socket());
0:                                         } else {
0:                                             handleSocket(sc.socket());
1:                                         }
1: 
0:                             } catch (SocketTimeoutException ste) {
0:                                 // expect this to happen
0:                             } catch (Exception e) {
0:                                 e.printStackTrace();
0:                                 if (!isStopping()) {
0:                                     onAcceptError(e);
0:                                 } else if (!isStopped()) {
0:                                     LOG.warn("run()", e);
0:                                     onAcceptError(e);
1:                                 }
0:                         i.remove();
1: 
1:                 }
0:                 if (selector != null) {
1:                     try {
0:                         selector.close();
0:                     } catch (IOException ioe) {}
0:                     selector = null;
1:                 }
/////////////////////////////////////////////////////////////////////////
author:Rob Davies
-------------------------------------------------------------------------------
commit:7e000d5
/////////////////////////////////////////////////////////////////////////
1:     protected boolean allowLinkStealing;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param bindAddress
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public boolean isAllowLinkStealing() {
1:         return allowLinkStealing;
1:     }
1: 
1:     public void setAllowLinkStealing(boolean allowLinkStealing) {
1:         this.allowLinkStealing = allowLinkStealing;
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:1773e2c
/////////////////////////////////////////////////////////////////////////
1: import javax.net.ssl.SSLServerSocket;
/////////////////////////////////////////////////////////////////////////
1: 
1:             // If the enabledCipherSuites option is invalid we don't want to ignore it as the call
1:             // to SSLServerSocket to configure it has a side effect on the socket rendering it
1:             // useless as all suites are enabled many of which are considered as insecure.  We
1:             // instead trap that option here and throw an exception.  We should really consider
1:             // all invalid options as breaking and not start the transport but the current design
1:             // doesn't really allow for this.
1:             //
1:             //  see: https://issues.apache.org/jira/browse/AMQ-4582
1:             //
1:             if (socket instanceof SSLServerSocket) {
1:                 if (transportOptions.containsKey("enabledCipherSuites")) {
1:                     Object cipherSuites = transportOptions.remove("enabledCipherSuites");
1: 
1:                     if (!IntrospectionSupport.setProperty(socket, "enabledCipherSuites", cipherSuites)) {
1:                         throw new SocketException(String.format(
1:                             "Invalid transport options {enabledCipherSuites=%s}", cipherSuites));
1:                     }
1:                 }
1:             }
1: 
commit:e731c39
/////////////////////////////////////////////////////////////////////////
1: public class TcpTransportServer extends TransportServerThreadSupport implements ServiceListener {
/////////////////////////////////////////////////////////////////////////
1:     protected boolean useQueueForAccept = true;
1:      * trace=true -> the Transport stack where this TcpTransport object will be, will have a TransportLogger layer
1:      * trace=false -> the Transport stack where this TcpTransport object will be, will NOT have a TransportLogger layer,
1:      * and therefore will never be able to print logging messages. This parameter is most probably set in Connection or
1:      * TransportConnector URIs.
1:     protected int connectionTimeout = 30000;
1:      * Name of the LogWriter implementation to use. Names are mapped to classes in the
1:      * resources/META-INF/services/org/apache/activemq/transport/logwriters directory. This parameter is most probably
1:      * set in Connection or TransportConnector URIs.
1:      * Specifies if the TransportLogger will be manageable by JMX or not. Also, as long as there is at least 1
1:      * TransportLogger which is manageable, a TransportLoggerControl MBean will me created.
1:      * startLogging=true -> the TransportLogger object of the Transport stack will initially write messages to the log.
1:      * startLogging=false -> the TransportLogger object of the Transport stack will initially NOT write messages to the
1:      * log. This parameter only has an effect if trace == true. This parameter is most probably set in Connection or
1:      * TransportConnector URIs.
/////////////////////////////////////////////////////////////////////////
1:     public TcpTransportServer(TcpTransportFactory transportFactory, URI location, ServerSocketFactory serverSocketFactory) throws IOException,
1:         URISyntaxException {
/////////////////////////////////////////////////////////////////////////
1:             setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), resolveHostName(serverSocket, addr), serverSocket.getLocalPort(), bind.getPath(),
1:                 bind.getQuery(), bind.getFragment()));
1:                 setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), addr.getHostAddress(), serverSocket.getLocalPort(), bind.getPath(),
1:                     bind.getQuery(), bind.getFragment()));
/////////////////////////////////////////////////////////////////////////
1:      * @param wireFormatFactory
1:      *            The wireFormatFactory to set.
1:      * Associates a broker info with the transport server so that the transport can do discovery advertisements of the
1:      * broker.
/////////////////////////////////////////////////////////////////////////
1:      * @param backlog
1:      *            the backlog to set
/////////////////////////////////////////////////////////////////////////
1:      * @param useQueueForAccept
1:      *            the useQueueForAccept to set
/////////////////////////////////////////////////////////////////////////
0:                         } else {
/////////////////////////////////////////////////////////////////////////
1:      * Allow derived classes to override the Transport implementation that this transport server creates.
1:     protected Transport createTransport(Socket socket, WireFormat format) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         if (useQueueForAccept) {
/////////////////////////////////////////////////////////////////////////
1:             socketHandlerThread = new Thread(null, run, "ActiveMQ Transport Server Thread Handler: " + toString(), getStackSize());
1:             socketHandlerThread.setPriority(ThreadPriorities.BROKER_MANAGEMENT - 1);
/////////////////////////////////////////////////////////////////////////
1:         return (InetSocketAddress) serverSocket.getLocalSocketAddress();
1:         boolean closeSocket = true;
0:                 throw new ExceededMaximumConnectionsException(
0:                     "Exceeded the maximum number of allowed client connections. See the '" +
0:                     "maximumConnections' property on the TCP transport configuration URI " +
0:                     "in the ActiveMQ configuration file (e.g., activemq.xml)");
0:                 options.put("maxInactivityDurationInitalDelay", Long.valueOf(maxInactivityDurationInitalDelay));
0:                 options.put("minmumWireFormatVersion", Integer.valueOf(minmumWireFormatVersion));
/////////////////////////////////////////////////////////////////////////
0:                 closeSocket = false;
0:                 Transport configuredTransport = transportFactory.serverConfigure(transport, format, options);
/////////////////////////////////////////////////////////////////////////
1:             if (closeSocket) {
1:                 try {
0:                     socket.close();
1:                 } catch (Exception ignore) {
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param maximumConnections
1:      *            the maximumConnections to set
commit:3f9b6ed
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
0:     protected AtomicInteger currentTransportCount = new AtomicInteger();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:             if (this.currentTransportCount.get() >= this.maximumConnections) {
/////////////////////////////////////////////////////////////////////////
0:                 currentTransportCount.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:         this.currentTransportCount.decrementAndGet();
commit:0fffe21
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * @param socket
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                 throw new ExceededMaximumConnectionsException("Exceeded the maximum " +
0:                     "number of allowed client connections. See the 'maximumConnections' " +
0:                     "property on the TCP transport configuration URI in the ActiveMQ " +
0:                     "configuration file (e.g., activemq.xml)");
1: 
0:                 options.put("maxInactivityDurationInitalDelay",
0:                 options.put("minmumWireFormatVersion",
/////////////////////////////////////////////////////////////////////////
0:                 Transport configuredTransport =
/////////////////////////////////////////////////////////////////////////
1:     }
1:     public int getSoTimeout() {
1:         return soTimeout;
1:     }
1:     public void setSoTimeout(int soTimeout) {
1:         this.soTimeout = soTimeout;
1:     }
1:     public int getSocketBufferSize() {
1:         return socketBufferSize;
1:     }
1:     public void setSocketBufferSize(int socketBufferSize) {
1:         this.socketBufferSize = socketBufferSize;
1:     }
1:     public int getConnectionTimeout() {
1:         return connectionTimeout;
1:     }
1: 
1:     public void setConnectionTimeout(int connectionTimeout) {
1:         this.connectionTimeout = connectionTimeout;
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Override
1:     public boolean isSslServer() {
1:         return false;
1:     }
commit:0885c60
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.TransportLoggerSupport;
/////////////////////////////////////////////////////////////////////////
1:     protected String logWriterName = TransportLoggerSupport.defaultLogWriterName;
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:c4d8d86
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportLoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:  * @author David Martin Clavo david(dot)martin(dot)clavo(at)gmail.com (logging improvement modifications)
/////////////////////////////////////////////////////////////////////////
0:      * Name of the LogWriter implementation to use.
0:      * Names are mapped to classes in the resources/META-INF/services/org/apache/activemq/transport/logwriters directory.
0:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:      */
0:     protected String logWriterName = TransportLoggerFactory.defaultLogWriterName;
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     
1:     public String getLogWriterName() {
1:         return logWriterName;
1:     }
1: 
1:     public void setLogWriterName(String logFormat) {
1:         this.logWriterName = logFormat;
1:     }        
/////////////////////////////////////////////////////////////////////////
0:             options.put("logWriterName", logWriterName);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     protected Map<String, Object> transportOptions;
/////////////////////////////////////////////////////////////////////////
0:                         HashMap<String, Object> options = new HashMap<String, Object>();
/////////////////////////////////////////////////////////////////////////
0:     public void setTransportOption(Map<String, Object> transportOptions) {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TcpTransportServer.class);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("run()", e);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import javax.net.ServerSocketFactory;
1: 
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         this.transportFactory = transportFactory;
1:         this.serverSocketFactory = serverSocketFactory;
1:         URI bind = getBindLocation();
1: 
/////////////////////////////////////////////////////////////////////////
0:             } else {
1:         } catch (IOException e) {
0:             setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), resolveHostName(bind.getHost()), serverSocket.getLocalPort(), bind.getPath(), bind.getQuery(), bind
0:                 .getFragment()));
1:         } catch (URISyntaxException e) {
1:             // it could be that the host name contains invalid characters such
0:             // as _ on unix platforms
0:                 setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), addr.getHostAddress(), serverSocket.getLocalPort(), bind.getPath(), bind.getQuery(), bind.getFragment()));
1: 
/////////////////////////////////////////////////////////////////////////
0:      * @param wireFormatFactory The wireFormatFactory to set.
/////////////////////////////////////////////////////////////////////////
0:                     } else {
/////////////////////////////////////////////////////////////////////////
0:             } catch (SocketTimeoutException ste) {
0:             } catch (Exception e) {
0:                     onAcceptError(e);
/////////////////////////////////////////////////////////////////////////
0:      * Allow derived classes to override the Transport implementation that this
0:      * transport server creates.
0:      * 
0:     protected Transport createTransport(Socket socket, WireFormat format) throws IOException {
1:         return new TcpTransport(format, socket);
1:     }
1:         return "" + getBindLocation();
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:d78c1ff
/////////////////////////////////////////////////////////////////////////
0:                         Transport configuredTransport = transportFactory.serverConfigure(transport, format, options);
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.wireformat.WireFormat;
1: import org.apache.activemq.wireformat.WireFormatFactory;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:68c8c64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IOExceptionSupport;
/////////////////////////////////////////////////////////////////////////
1: 	
0:     protected ServerSocket serverSocket;
1:     protected int backlog = 5000;
1:     protected WireFormatFactory wireFormatFactory = new OpenWireFormatFactory();
1:     protected final TcpTransportFactory transportFactory;
1:     protected long maxInactivityDuration = 30000;
1:     protected int minmumWireFormatVersion;
0:     protected boolean trace;
0:     protected Map transportOptions;
1:     protected final ServerSocketFactory serverSocketFactory;
0: 		this.serverSocketFactory = serverSocketFactory;
1:     public void bind() throws IOException {
0:     	URI bind = getBindLocation();
1:     	
1:         String host = bind.getHost();
1:         host = (host == null || host.length() == 0) ? "localhost" : host;
1:         InetAddress addr = InetAddress.getByName(host);
1:         
0:         if (host.trim().equals("localhost") || addr.equals(InetAddress.getLocalHost())) {
0:         	this.serverSocket = serverSocketFactory.createServerSocket(bind.getPort(), backlog);
1:         }
0:         else {
0:         	this.serverSocket = serverSocketFactory.createServerSocket(bind.getPort(), backlog, addr);
1:         }
0:         this.serverSocket.setSoTimeout(2000);
1:         
1:         try {
0: 			setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), resolveHostName(bind.getHost()), serverSocket.getLocalPort(), bind.getPath(),
0: 					bind.getQuery(), bind.getFragment()));
0: 		} catch (URISyntaxException e) {
0: 			throw IOExceptionSupport.create(e);
1: 		}
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:         return ""+getBindLocation();
/////////////////////////////////////////////////////////////////////////
commit:b4b8499
/////////////////////////////////////////////////////////////////////////
0:     private final TcpTransportFactory transportFactory;
0:     public TcpTransportServer(TcpTransportFactory transportFactory, URI location, ServerSocketFactory serverSocketFactory) throws IOException, URISyntaxException {
0:         this.transportFactory=transportFactory;
0:         this.serverSocket = createServerSocket(location, serverSocketFactory);
0:         this.serverSocket.setSoTimeout(2000);
/////////////////////////////////////////////////////////////////////////
0:                         Transport transport = createTransport(socket, format);
/////////////////////////////////////////////////////////////////////////
0:      * Allow derived classes to override the Transport implementation that this transport server creates.
1:      * @param socket
1:      * @param format
0:      * @return
1:      * @throws IOException
1:      */
0: 	protected Transport createTransport(Socket socket, WireFormat format) throws IOException {
0: 		return new TcpTransport(format, socket);
1: 	}
1: 
1:     /**
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
0:         return ""+getLocation();
commit:2ee58ca
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:     private Map transportOptions;
/////////////////////////////////////////////////////////////////////////
0:                         options.putAll(transportOptions);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void setTransportOption(Map transportOptions) {
0:         this.transportOptions = transportOptions;
1:     }
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activeio.command.WireFormatFactory;
1: import org.apache.activemq.command.BrokerInfo;
1: import org.apache.activemq.openwire.OpenWireFormatFactory;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportServer;
1: import org.apache.activemq.transport.TransportServerThreadSupport;
1: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
commit:26bb18b
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetSocketAddress;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public InetSocketAddress getSocketAddress() {
0:         return (InetSocketAddress)serverSocket.getLocalSocketAddress();
1:     }
commit:ef0c0e1
/////////////////////////////////////////////////////////////////////////
0:     private long maxInactivityDuration = 30000;
commit:375469b
/////////////////////////////////////////////////////////////////////////
0:     private long maxInactivityDuration = 0; //30000;
commit:1229c23
/////////////////////////////////////////////////////////////////////////
0:     private long maxInactivityDuration = 30000;
0:     private int minmumWireFormatVersion;
0:     private boolean trace;
/////////////////////////////////////////////////////////////////////////
0:                         options.put("maxInactivityDuration", new Long(maxInactivityDuration));
0:                         options.put("minmumWireFormatVersion", new Integer(minmumWireFormatVersion));
0:                         options.put("trace", new Boolean(trace));
/////////////////////////////////////////////////////////////////////////
1: 
1:     public long getMaxInactivityDuration() {
1:         return maxInactivityDuration;
1:     }
1: 
1:     public void setMaxInactivityDuration(long maxInactivityDuration) {
1:         this.maxInactivityDuration = maxInactivityDuration;
1:     }
1: 
1:     public int getMinmumWireFormatVersion() {
1:         return minmumWireFormatVersion;
1:     }
1: 
1:     public void setMinmumWireFormatVersion(int minmumWireFormatVersion) {
1:         this.minmumWireFormatVersion = minmumWireFormatVersion;
1:     }
1: 
1:     public boolean isTrace() {
1:         return trace;
1:     }
1: 
1:     public void setTrace(boolean trace) {
1:         this.trace = trace;
1:     }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.tcp;
1: 
0: import org.activeio.command.WireFormat;
0: import org.activeio.command.WireFormatFactory;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.openwire.OpenWireFormatFactory;
0: import org.apache.activemq.transport.TransportServerThreadSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: import java.io.IOException;
1: import java.net.InetAddress;
1: import java.net.ServerSocket;
1: import java.net.Socket;
1: import java.net.SocketTimeoutException;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.net.UnknownHostException;
1: import java.util.HashMap;
1: 
1: /**
1:  * A TCP based implementation of {@link TransportServer}
0:  * 
0:  * @version $Revision: 1.1 $
1:  */
1: 
0: public class TcpTransportServer extends TransportServerThreadSupport {
0:     private static final Log log = LogFactory.getLog(TcpTransportServer.class);
0:     private ServerSocket serverSocket;
0:     private int backlog = 5000;
0:     private WireFormatFactory wireFormatFactory = new OpenWireFormatFactory();
0:     private TcpTransportFactory transportFactory = new TcpTransportFactory();
1:     
1:     /**
0:      * Constructor
0:      * 
0:      * @param location
0:      * @throws IOException
0:      * @throws URISyntaxException
1:      */
0:     public TcpTransportServer(URI location) throws IOException, URISyntaxException {
1:         super(location);
0:         serverSocket = createServerSocket(location);
0:         serverSocket.setSoTimeout(2000);
0:         updatePhysicalUri(location);
1:     }
1: 
1:     /**
1:      * @return Returns the wireFormatFactory.
1:      */
1:     public WireFormatFactory getWireFormatFactory() {
1:         return wireFormatFactory;
1:     }
1: 
1:     /**
0:      * @param wireFormatFactory
0:      *            The wireFormatFactory to set.
1:      */
1:     public void setWireFormatFactory(WireFormatFactory wireFormatFactory) {
1:         this.wireFormatFactory = wireFormatFactory;
1:     }
1: 
1:     /**
0:      * Associates a broker info with the transport server so that the transport
0:      * can do discovery advertisements of the broker.
0:      * 
1:      * @param brokerInfo
1:      */
1:     public void setBrokerInfo(BrokerInfo brokerInfo) {
1:     }
1: 
1:     /**
1:      * pull Sockets from the ServerSocket
1:      */
1:     public void run() {
0:         while (!isClosed()) {
0:             Socket socket = null;
1:             try {
0:                 socket = serverSocket.accept();
0:                 if (socket != null) {
0:                     if (isClosed() || getAcceptListener() == null) {
0:                         socket.close();
1:                     }
0:                     else {
0:                         HashMap options = new HashMap();
0:                         WireFormat format = wireFormatFactory.createWireFormat();
0:                         TcpTransport transport = new TcpTransport(format, socket);
0:                         getAcceptListener().onAccept(transportFactory.configure(transport, format, options));
1:                     }
1:                 }
1:             }
0:             catch (SocketTimeoutException ste) {
0:                 // expect this to happen
1:             }
0:             catch (Exception e) {
0:                 if (!isClosing()) {
0:                     onAcceptError(e); 
0:                 } else if (!isClosed()) {
0:                     log.warn("run()", e);
0:                     onAcceptError(e);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * @return pretty print of this
1:      */
1:     public String toString() {
0:         return "TcpTransportServer@" + getLocation();
1:     }
1: 
1:     /**
0:      * In cases where we construct ourselves with a zero port we need to
0:      * regenerate the URI with the real physical port so that people can connect
0:      * to us via discovery
0:      * 
1:      * @throws UnknownHostException
1:      */
0:     protected void updatePhysicalUri(URI bindAddr) throws URISyntaxException, UnknownHostException {
0:         setLocation(new URI(bindAddr.getScheme(), bindAddr.getUserInfo(), resolveHostName(bindAddr.getHost()), serverSocket.getLocalPort(), bindAddr.getPath(),
0:                 bindAddr.getQuery(), bindAddr.getFragment()));
1:     }
1: 
1:     /**
0:      * 
0:      * @param hostName
1:      * @return real hostName
1:      * @throws UnknownHostException
1:      */
0:     protected String resolveHostName(String hostName) throws UnknownHostException {
0:         String result = hostName;
0:         // hostname can be null for vm:// protocol ...
0:         if (hostName != null && (hostName.equalsIgnoreCase("localhost") || hostName.equals("127.0.0.1"))) {
0:             result = InetAddress.getLocalHost().getHostName();
1:         }
1:         return result;
1:     }
1: 
1:     /**
0:      * Factory method to create a new ServerSocket
0:      * 
1:      * @throws UnknownHostException
0:      * @throws IOException
1:      */
0:     protected ServerSocket createServerSocket(URI bind) throws UnknownHostException, IOException {
0:         ServerSocket answer = null;
0:         String host = bind.getHost();
0:         host = (host == null || host.length() == 0) ? "localhost" : host;
0:         InetAddress addr = InetAddress.getByName(host);
0:         if (host.trim().equals("localhost") || addr.equals(InetAddress.getLocalHost())) {
0:             answer = new ServerSocket(bind.getPort(), backlog);
1:         }
0:         else {
0:             answer = new ServerSocket(bind.getPort(), backlog, addr);
1:         }
0:         return answer;
1:     }
1: 
1:     protected void doStop(ServiceStopper stopper) throws Exception {
0:         if (serverSocket != null) {
0:             serverSocket.close();
1:         }
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TcpTransportServer.class);
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:8a1f994
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.InetAddressUtil;
/////////////////////////////////////////////////////////////////////////
1:                 result = InetAddressUtil.getLocalHostName();
commit:0f19071
/////////////////////////////////////////////////////////////////////////
0:                 throw new ExceededMaximumConnectionsException("Exceeded the maximum " + 
0:                     "number of allowed client connections. See the 'maximumConnections' " + 
0:                     "property on the TCP transport configuration URI in the ActiveMQ " + 
0:                     "configuration file (e.g., activemq.xml)"); 
0:             } else {
0:                 HashMap<String, Object> options = new HashMap<String, Object>();
0:                 options.put("maxInactivityDuration", Long.valueOf(maxInactivityDuration));
0:                 options.put("maxInactivityDurationInitalDelay", 
0:                     Long.valueOf(maxInactivityDurationInitalDelay));
0:                 options.put("minmumWireFormatVersion", 
0:                     Integer.valueOf(minmumWireFormatVersion));
0:                 options.put("trace", Boolean.valueOf(trace));
0:                 options.put("soTimeout", Integer.valueOf(soTimeout));
0:                 options.put("socketBufferSize", Integer.valueOf(socketBufferSize));
0:                 options.put("connectionTimeout", Integer.valueOf(connectionTimeout));
0:                 options.put("logWriterName", logWriterName);
0:                 options.put("dynamicManagement", Boolean.valueOf(dynamicManagement));
0:                 options.put("startLogging", Boolean.valueOf(startLogging));
0:                 options.putAll(transportOptions);
0:                 WireFormat format = wireFormatFactory.createWireFormat();
0:                 Transport transport = createTransport(socket, format);
1: 
0:                 if (transport instanceof ServiceSupport) {
0:                     ((ServiceSupport) transport).addServiceListener(this);
1:                 }
1: 
0:                 Transport configuredTransport = 
0:                     transportFactory.serverConfigure( transport, format, options);
1: 
0:                 getAcceptListener().onAccept(configuredTransport);
/////////////////////////////////////////////////////////////////////////
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:ee4c8ee
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f7cba2a
/////////////////////////////////////////////////////////////////////////
1:     protected long maxInactivityDurationInitalDelay = 10000;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public long getMaxInactivityDurationInitalDelay() {
1:         return this.maxInactivityDurationInitalDelay;
1:     }
1: 
1:     public void setMaxInactivityDurationInitalDelay(long maxInactivityDurationInitalDelay) {
1:         this.maxInactivityDurationInitalDelay = maxInactivityDurationInitalDelay;
1:     }
/////////////////////////////////////////////////////////////////////////
0:             options.put("maxInactivityDurationInitalDelay", Long
0:                     .valueOf(maxInactivityDurationInitalDelay));            
commit:b56cb8f
/////////////////////////////////////////////////////////////////////////
0:             setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), resolveHostName(serverSocket, addr), serverSocket.getLocalPort(), bind.getPath(), bind.getQuery(), bind
/////////////////////////////////////////////////////////////////////////
0:      * @param socket 
0:      * @param inetAddress
1:     protected String resolveHostName(ServerSocket socket, InetAddress bindAddress) throws UnknownHostException {
1:         String result = null;
1:         if (socket.isBound()) {
1:             if (socket.getInetAddress().isAnyLocalAddress()) {
1:                 // make it more human readable and useful, an alternative to 0.0.0.0
0:                 result = InetAddress.getLocalHost().getHostName();
0:             } else {
1:                 result = socket.getInetAddress().getCanonicalHostName();
1:             }
0:         } else {
1:             result = bindAddress.getCanonicalHostName();
commit:f8071a3
/////////////////////////////////////////////////////////////////////////
1:         if (transportOptions != null) {
0:             IntrospectionSupport.setProperties(socket, transportOptions);
1:         }
commit:3332220
/////////////////////////////////////////////////////////////////////////
1: import java.net.SocketException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IntrospectionSupport;
/////////////////////////////////////////////////////////////////////////
0:             configureServerSocket(this.serverSocket);
1:             
/////////////////////////////////////////////////////////////////////////
1:     private void configureServerSocket(ServerSocket socket) throws SocketException {
1:         socket.setSoTimeout(2000);
0:         IntrospectionSupport.setProperties(socket, transportOptions);
1:     }
0: 
author:David Jencks
-------------------------------------------------------------------------------
commit:563ec44
/////////////////////////////////////////////////////////////////////////
0: 
0:             this.serverSocket = serverSocketFactory.createServerSocket(bind.getPort(), backlog, addr);
author:Robert Davies
-------------------------------------------------------------------------------
commit:391077e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.Service;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceListener;
1: import org.apache.activemq.util.ServiceSupport;
/////////////////////////////////////////////////////////////////////////
0: public class TcpTransportServer extends TransportServerThreadSupport implements ServiceListener{
/////////////////////////////////////////////////////////////////////////
0:        
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The maximum number of sockets allowed for this server
1:      */
1:     protected int maximumConnections = Integer.MAX_VALUE;
0:     protected int currentTransportCount=0;
/////////////////////////////////////////////////////////////////////////
0:     protected  Transport createTransport(Socket socket, WireFormat format) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     protected final void handleSocket(Socket socket) {
0:             if (this.currentTransportCount >= this.maximumConnections) {
0:                 
0:             }else {
/////////////////////////////////////////////////////////////////////////
0:             if (transport instanceof ServiceSupport) {
0:                 ((ServiceSupport) transport).addServiceListener(this);
1:             }
1:             }
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * @return the maximumConnections
1:      */
1:     public int getMaximumConnections() {
1:         return maximumConnections;
0:     }
0: 
1:     /**
0:      * @param maximumConnections the maximumConnections to set
1:      */
1:     public void setMaximumConnections(int maximumConnections) {
1:         this.maximumConnections = maximumConnections;
0:     }
0: 
0:     
1:     public void started(Service service) {
0:        this.currentTransportCount++;
0:     }
0: 
1:     public void stopped(Service service) {
0:         this.currentTransportCount--;
0:     }
commit:b7038c0
/////////////////////////////////////////////////////////////////////////
0:             options.put("socketBufferSize", Integer.valueOf(socketBufferSize));
0:             options.put("connectionTimeout", Integer.valueOf(connectionTimeout));
commit:46b01cc
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected int soTimeout = 0;
1:     protected int socketBufferSize = 64 * 1024;
0:     protected int connectionTimeout =  30000;
0: 
/////////////////////////////////////////////////////////////////////////
0:             options.put("soTimeout", Integer.valueOf(soTimeout));
0:             options.put("soTimeout", Integer.valueOf(soTimeout));
0:             options.put("connectionTimeout", Integer.valueOf(socketBufferSize));
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public int getSoTimeout() {
0: 		return soTimeout;
0: 	}
0: 
0: 	public void setSoTimeout(int soTimeout) {
0: 		this.soTimeout = soTimeout;
0: 	}
0: 
0: 	public int getSocketBufferSize() {
0: 		return socketBufferSize;
0: 	}
0: 
0: 	public void setSocketBufferSize(int socketBufferSize) {
0: 		this.socketBufferSize = socketBufferSize;
0: 	}
0: 
0: 	public int getConnectionTimeout() {
0: 		return connectionTimeout;
0: 	}
0: 
0: 	public void setConnectionTimeout(int connectionTimeout) {
0: 		this.connectionTimeout = connectionTimeout;
0: 	}
commit:9260494
/////////////////////////////////////////////////////////////////////////
0:     protected boolean useQueueForAccept=true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the backlog
1:      */
1:     public int getBacklog() {
1:         return backlog;
0:     }
0: 
1:     /**
0:      * @param backlog the backlog to set
1:      */
1:     public void setBacklog(int backlog) {
1:         this.backlog = backlog;
0:     }
0: 
1:     /**
1:      * @return the useQueueForAccept
1:      */
1:     public boolean isUseQueueForAccept() {
1:         return useQueueForAccept;
0:     }
0: 
1:     /**
0:      * @param useQueueForAccept the useQueueForAccept to set
1:      */
1:     public void setUseQueueForAccept(boolean useQueueForAccept) {
1:         this.useQueueForAccept = useQueueForAccept;
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:                         if (useQueueForAccept) {
0:                             socketQueue.put(socket);
0:                         }else {
0:                             handleSocket(socket);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:         if(useQueueForAccept) {
1:             Runnable run = new Runnable() {
1:                 public void run() {
0:                     try {
1:                         while (!isStopped() && !isStopping()) {
1:                             Socket sock = socketQueue.poll(1, TimeUnit.SECONDS);
1:                             if (sock != null) {
0:                                 handleSocket(sock);
0:                             }
0:                         }
0:     
1:                     } catch (InterruptedException e) {
0:                         LOG.info("socketQueue interuppted - stopping");
0:                         if (!isStopping()) {
0:                             onAcceptError(e);
0:     
0:     
1:             };
0:             socketHandlerThread = new Thread(null, run,
0:                     "ActiveMQ Transport Server Thread Handler: " + toString(),
0:                     getStackSize());
1:             socketHandlerThread.setDaemon(true);
0:             socketHandlerThread.setPriority(ThreadPriorities.BROKER_MANAGEMENT-1);
1:             socketHandlerThread.start();
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:     }    
commit:3d10acc
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.BlockingQueue;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.TimeUnit;
1: import org.apache.activemq.ThreadPriorities;
/////////////////////////////////////////////////////////////////////////
0:    
/////////////////////////////////////////////////////////////////////////
0:     protected BlockingQueue<Socket> socketQueue = new LinkedBlockingQueue<Socket>();
1:     protected Thread socketHandlerThread;
0:   
0:         
/////////////////////////////////////////////////////////////////////////
0:                        socketQueue.put(socket);
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected void doStart() throws Exception {
0:         Runnable run = new Runnable() {
0:             public void run() {
0:                 try {
0:                     while (!isStopped() && !isStopping()) {
0:                         Socket sock = socketQueue.poll(1, TimeUnit.SECONDS);
0:                         if (sock != null) {
0:                             handleSocket(sock);
0:                         }
0:                     }
0: 
0:                 } catch (InterruptedException e) {
0:                     LOG.info("socketQueue interuppted - stopping");
0:                     if (!isStopping()) {
0:                         onAcceptError(e);
0:                     }
0:                 }
0: 
0:             }
0: 
0:         };
0:         socketHandlerThread = new Thread(null, run,
0:                 "ActiveMQ Transport Server Thread Handler: " + toString(),
0:                 getStackSize());
0:         socketHandlerThread.setDaemon(true);
0:         socketHandlerThread.setPriority(ThreadPriorities.BROKER_MANAGEMENT-1);
1:         super.doStart();
0:         socketHandlerThread.start();
0:     }
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void handleSocket(Socket socket) {
0:         try {
0:             HashMap<String, Object> options = new HashMap<String, Object>();
0:             options.put("maxInactivityDuration", Long
0:                     .valueOf(maxInactivityDuration));
0:             options.put("minmumWireFormatVersion", Integer
0:                     .valueOf(minmumWireFormatVersion));
0:             options.put("trace", Boolean.valueOf(trace));
0:             options
0:                     .put("dynamicManagement", Boolean
0:                             .valueOf(dynamicManagement));
0:             options.put("startLogging", Boolean.valueOf(startLogging));
0: 
0:             options.putAll(transportOptions);
0:             WireFormat format = wireFormatFactory.createWireFormat();
0:             Transport transport = createTransport(socket, format);
0:             Transport configuredTransport = transportFactory.serverConfigure(
0:                     transport, format, options);
0:             getAcceptListener().onAccept(configuredTransport);
0:         } catch (SocketTimeoutException ste) {
0:             // expect this to happen
0:         } catch (Exception e) {
0:             if (!isStopping()) {
0:                 onAcceptError(e);
0:             } else if (!isStopped()) {
0:                 LOG.warn("run()", e);
0:                 onAcceptError(e);
0:             }
0:         }
0:     }
0:     
0:     
0: }
commit:19a83ae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:df6b542
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportLoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * trace=true -> the Transport stack where this TcpTransport
0:      * object will be, will have a TransportLogger layer
0:      * trace=false -> the Transport stack where this TcpTransport
0:      * object will be, will NOT have a TransportLogger layer, and therefore
0:      * will never be able to print logging messages.
0:      * This parameter is most probably set in Connection or TransportConnector URIs.
0:      */
1:     protected boolean trace = false;
0:     /**
0:      * Name of the LogWriter implementation to use.
0:      * Names are mapped to classes in the resources/META-INF/services/org/apache/activemq/transport/logwriters directory.
0:      * This parameter is most probably set in Connection or TransportConnector URIs.
0:      */
0:     protected String logWriterName = TransportLoggerFactory.defaultLogWriterName;
0:     /**
0:      * Specifies if the TransportLogger will be manageable by JMX or not.
0:      * Also, as long as there is at least 1 TransportLogger which is manageable,
0:      * a TransportLoggerControl MBean will me created.
0:      */
1:     protected boolean dynamicManagement = false;
0:     /**
0:      * startLogging=true -> the TransportLogger object of the Transport stack
0:      * will initially write messages to the log.
0:      * startLogging=false -> the TransportLogger object of the Transport stack
0:      * will initially NOT write messages to the log.
0:      * This parameter only has an effect if trace == true.
0:      * This parameter is most probably set in Connection or TransportConnector URIs.
0:      */
1:     protected boolean startLogging = true;
/////////////////////////////////////////////////////////////////////////
0:     public String getLogWriterName() {
0:         return logWriterName;
0:     }
0: 
0: 
0:     public void setLogWriterName(String logFormat) {
0:         this.logWriterName = logFormat;
0:     }
0: 
1:     public boolean isDynamicManagement() {
1:         return dynamicManagement;
0:     }
0: 
1:     public void setDynamicManagement(boolean useJmx) {
1:         this.dynamicManagement = useJmx;
0:     }
0: 
1:     public boolean isStartLogging() {
1:         return startLogging;
0:     }
0: 
0: 
1:     public void setStartLogging(boolean startLogging) {
1:         this.startLogging = startLogging;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:                         options.put("logWriterName", logWriterName);
0:                         options.put("dynamicManagement", Boolean.valueOf(dynamicManagement));
0:                         options.put("startLogging", Boolean.valueOf(startLogging));
0: 
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:                         options.put("maxInactivityDuration", Long.valueOf(maxInactivityDuration));
0:                         options.put("minmumWireFormatVersion", Integer.valueOf(minmumWireFormatVersion));
0:                         options.put("trace", Boolean.valueOf(trace));
author:James Strachan
-------------------------------------------------------------------------------
commit:8011f90
/////////////////////////////////////////////////////////////////////////
0: 
0:             // it could be that the host name contains invalid characters such as _ on unix platforms
0:             // so lets try use the IP address instead
0:             try {
0:                 setConnectURI(new URI(bind.getScheme(), bind.getUserInfo(), addr.getHostAddress(), serverSocket.getLocalPort(), bind.getPath(),
0:                         bind.getQuery(), bind.getFragment()));
1:             } catch (URISyntaxException e2) {
1:                 throw IOExceptionSupport.create(e2);
0:             }
0:         }
commit:cab35d7
/////////////////////////////////////////////////////////////////////////
0: 
0:         try {
0:             if (host.trim().equals("localhost") || addr.equals(InetAddress.getLocalHost())) {
0:                 this.serverSocket = serverSocketFactory.createServerSocket(bind.getPort(), backlog);
0:             }
0:             else {
0:                 this.serverSocket = serverSocketFactory.createServerSocket(bind.getPort(), backlog, addr);
0:             }
0:             this.serverSocket.setSoTimeout(2000);
0:         catch (IOException e) {
1:             throw IOExceptionSupport.create("Failed to bind to server socket: " + bind + " due to: " + e, e);
commit:2440474
/////////////////////////////////////////////////////////////////////////
0: import javax.net.ServerSocketFactory;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public TcpTransportServer(URI location, ServerSocketFactory serverSocketFactory) throws IOException, URISyntaxException {
0:         serverSocket = createServerSocket(location, serverSocketFactory);
/////////////////////////////////////////////////////////////////////////
0:     protected ServerSocket createServerSocket(URI bind, ServerSocketFactory factory) throws UnknownHostException, IOException {
0:             answer = factory.createServerSocket(bind.getPort(), backlog);
0:             answer = factory.createServerSocket(bind.getPort(), backlog, addr);
commit:436fe42
/////////////////////////////////////////////////////////////////////////
0:         while (!isStopped()) {
0:                     if (isStopped() || getAcceptListener() == null) {
/////////////////////////////////////////////////////////////////////////
0:                 if (!isStopping()) {
0:                 } else if (!isStopped()) {
commit:11be076
/////////////////////////////////////////////////////////////////////////
0:     public long getMaxInactivityDuration() {
0:         return maxInactivityDuration;
0:     }
0: 
0:     public void setMaxInactivityDuration(long maxInactivityDuration) {
0:         this.maxInactivityDuration = maxInactivityDuration;
0:     }
0: 
0:     public int getMinmumWireFormatVersion() {
0:         return minmumWireFormatVersion;
0:     }
0: 
0:     public void setMinmumWireFormatVersion(int minmumWireFormatVersion) {
0:         this.minmumWireFormatVersion = minmumWireFormatVersion;
0:     }
0: 
0:     public boolean isTrace() {
0:         return trace;
0:     }
0: 
0:     public void setTrace(boolean trace) {
0:         this.trace = trace;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         super.doStop(stopper);
commit:44613ad
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.Transport;
/////////////////////////////////////////////////////////////////////////
0:                         Transport configuredTransport = transportFactory.configure(transport, format, options);
0:                         getAcceptListener().onAccept(configuredTransport);
============================================================================