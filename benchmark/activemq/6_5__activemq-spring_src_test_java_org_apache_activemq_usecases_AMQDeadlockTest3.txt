1:fc00993: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:fc00993:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:fc00993:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:fc00993:  */
1:2e57fb5: package org.apache.activemq.usecases;
24:7de0e81: 
1:7de0e81: import java.net.URI;
1:7de0e81: import java.util.ArrayList;
1:933eb2f: import java.util.List;
1:7de0e81: import java.util.Random;
1:7de0e81: import java.util.concurrent.CountDownLatch;
1:7de0e81: import java.util.concurrent.ExecutorService;
1:7de0e81: import java.util.concurrent.Executors;
1:7de0e81: import java.util.concurrent.TimeUnit;
1:7de0e81: import java.util.concurrent.atomic.AtomicInteger;
1:7de0e81: 
1:7de0e81: import javax.jms.BytesMessage;
1:7de0e81: import javax.jms.ConnectionFactory;
1:7de0e81: import javax.jms.DeliveryMode;
1:7de0e81: import javax.jms.JMSException;
1:7de0e81: import javax.jms.Message;
1:7de0e81: import javax.jms.MessageListener;
1:7de0e81: import javax.jms.Session;
1:7de0e81: 
1:1b38caa: import org.apache.activemq.ActiveMQConnectionFactory;
1:7de0e81: import org.apache.activemq.broker.BrokerService;
1:7de0e81: import org.apache.activemq.broker.TransportConnector;
1:7de0e81: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:7de0e81: import org.apache.activemq.broker.region.policy.PolicyMap;
1:7de0e81: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:7de0e81: import org.apache.activemq.network.NetworkConnector;
1:7de0e81: import org.apache.activemq.pool.PooledConnectionFactory;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:7de0e81: import org.springframework.jms.core.JmsTemplate;
1:7de0e81: import org.springframework.jms.core.MessageCreator;
1:7de0e81: import org.springframework.jms.listener.DefaultMessageListenerContainer;
1:7de0e81: 
1:2e57fb5: public class AMQDeadlockTest3 extends org.apache.activemq.test.TestSupport {
1:2e57fb5: 
1:8bf987b:     private static final transient Logger LOG = LoggerFactory.getLogger(AMQDeadlockTest3.class);
1:7de0e81: 
1:7de0e81:     private static final String URL1 = "tcp://localhost:61616";
1:7de0e81: 
1:f812e34:     private static final String URL2 = "tcp://localhost:61617";
1:7de0e81: 
1:f812e34:     private static final String QUEUE1_NAME = "test.queue.1";
1:7de0e81: 
1:f812e34:     private static final String QUEUE2_NAME = "test.queue.2";
1:7de0e81: 
1:f812e34:     private static final int MAX_CONSUMERS = 1;
1:7de0e81: 
1:f812e34:     private static final int MAX_PRODUCERS = 1;
1:7de0e81: 
1:f812e34:     private static final int NUM_MESSAGE_TO_SEND = 10;
1:7de0e81: 
1:1b38caa:     private final AtomicInteger messageCount = new AtomicInteger();
1:f812e34:     private CountDownLatch doneLatch;
1:7de0e81: 
1:1b38caa:     @Override
1:f812e34:     public void setUp() throws Exception {
1:f812e34:     }
1:7de0e81: 
1:1b38caa:     @Override
1:f812e34:     public void tearDown() throws Exception {
1:f812e34:     }
1:7de0e81: 
1:f812e34:     // This should fail with incubator-activemq-fuse-4.1.0.5
1:f812e34:     public void testQueueLimitsWithOneBrokerSameConnection() throws Exception {
1:7de0e81: 
1:f812e34:         BrokerService brokerService1 = null;
1:f812e34:         ActiveMQConnectionFactory acf = null;
1:f812e34:         PooledConnectionFactory pcf = null;
1:f812e34:         DefaultMessageListenerContainer container1 = null;
1:7de0e81: 
1:f812e34:         try {
1:f812e34:             brokerService1 = createBrokerService("broker1", URL1, null);
1:f812e34:             brokerService1.start();
1:7de0e81: 
1:f812e34:             acf = createConnectionFactory(URL1);
1:f812e34:             pcf = new PooledConnectionFactory(acf);
1:7de0e81: 
1:f812e34:             // Only listen on the first queue.. let the 2nd queue fill up.
1:f812e34:             doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND);
1:f812e34:             container1 = createDefaultMessageListenerContainer(acf, new TestMessageListener1(500), QUEUE1_NAME);
1:f812e34:             container1.afterPropertiesSet();
1:7de0e81: 
1:f812e34:             Thread.sleep(2000);
1:7de0e81: 
1:f812e34:             final ExecutorService executor = Executors.newCachedThreadPool();
1:f812e34:             for (int i = 0; i < MAX_PRODUCERS; i++) {
1:f812e34:                 executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
1:f812e34:                 Thread.sleep(1000);
1:f812e34:                 executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
1:f812e34:             }
1:7de0e81: 
1:f812e34:             // Wait for all message to arrive.
1:f812e34:             assertTrue(doneLatch.await(20, TimeUnit.SECONDS));
1:f812e34:             executor.shutdownNow();
1:7de0e81: 
1:1b38caa:             assertEquals(NUM_MESSAGE_TO_SEND, messageCount.get());
1:7de0e81: 
1:f812e34:         } finally {
1:f812e34:             container1.stop();
1:f812e34:             container1.destroy();
1:f812e34:             container1 = null;
1:f812e34:             brokerService1.stop();
1:f812e34:             brokerService1 = null;
1:f812e34:         }
1:f812e34:     }
1:7de0e81: 
1:f812e34:     // This should fail with incubator-activemq-fuse-4.1.0.5
1:f812e34:     public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithOneConnectionForProducing() throws Exception {
1:7de0e81: 
1:f812e34:         BrokerService brokerService1 = null;
1:f812e34:         BrokerService brokerService2 = null;
1:f812e34:         ActiveMQConnectionFactory acf1 = null;
1:f812e34:         ActiveMQConnectionFactory acf2 = null;
1:f812e34:         PooledConnectionFactory pcf = null;
1:f812e34:         DefaultMessageListenerContainer container1 = null;
1:7de0e81: 
1:f812e34:         try {
1:f812e34:             brokerService1 = createBrokerService("broker1", URL1, URL2);
1:f812e34:             brokerService1.start();
1:f812e34:             brokerService2 = createBrokerService("broker2", URL2, URL1);
1:f812e34:             brokerService2.start();
1:7de0e81: 
1:f812e34:             acf1 = createConnectionFactory(URL1);
1:f812e34:             acf2 = createConnectionFactory(URL2);
1:7de0e81: 
1:f812e34:             pcf = new PooledConnectionFactory(acf1);
1:7de0e81: 
1:f812e34:             Thread.sleep(1000);
1:7de0e81: 
1:f812e34:             doneLatch = new CountDownLatch(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND);
1:f812e34:             container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
1:f812e34:             container1.afterPropertiesSet();
1:7de0e81: 
1:f812e34:             final ExecutorService executor = Executors.newCachedThreadPool();
1:f812e34:             for (int i = 0; i < MAX_PRODUCERS; i++) {
1:f812e34:                 executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
1:f812e34:                 Thread.sleep(1000);
1:f812e34:                 executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
1:f812e34:             }
1:7de0e81: 
1:f812e34:             assertTrue(doneLatch.await(20, TimeUnit.SECONDS));
1:f812e34:             executor.shutdownNow();
1:7de0e81: 
1:1b38caa:             assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
1:f812e34:         } finally {
1:7de0e81: 
1:f812e34:             container1.stop();
1:f812e34:             container1.destroy();
1:f812e34:             container1 = null;
1:7de0e81: 
1:f812e34:             brokerService1.stop();
1:f812e34:             brokerService1 = null;
1:f812e34:             brokerService2.stop();
1:f812e34:             brokerService2 = null;
1:f812e34:         }
1:f812e34:     }
1:7de0e81: 
1:f812e34:     // This should fail with incubator-activemq-fuse-4.1.0.5
1:f812e34:     public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithSeperateConnectionsForProducing() throws Exception {
1:7de0e81: 
1:f812e34:         BrokerService brokerService1 = null;
1:f812e34:         BrokerService brokerService2 = null;
1:f812e34:         ActiveMQConnectionFactory acf1 = null;
1:f812e34:         ActiveMQConnectionFactory acf2 = null;
1:f812e34:         DefaultMessageListenerContainer container1 = null;
1:f812e34:         DefaultMessageListenerContainer container2 = null;
1:7de0e81: 
1:f812e34:         try {
1:f812e34:             brokerService1 = createBrokerService("broker1", URL1, URL2);
1:f812e34:             brokerService1.start();
1:f812e34:             brokerService2 = createBrokerService("broker2", URL2, URL1);
1:f812e34:             brokerService2.start();
1:7de0e81: 
1:f812e34:             acf1 = createConnectionFactory(URL1);
1:f812e34:             acf2 = createConnectionFactory(URL2);
1:7de0e81: 
1:f812e34:             Thread.sleep(1000);
1:7de0e81: 
1:f812e34:             doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND * MAX_PRODUCERS);
1:7de0e81: 
1:f812e34:             container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
1:f812e34:             container1.afterPropertiesSet();
1:f812e34:             container2 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(30000), QUEUE2_NAME);
1:f812e34:             container2.afterPropertiesSet();
1:7de0e81: 
1:f812e34:             final ExecutorService executor = Executors.newCachedThreadPool();
1:f812e34:             for (int i = 0; i < MAX_PRODUCERS; i++) {
1:f812e34:                 executor.submit(new NonPooledProducerTask(acf1, QUEUE2_NAME));
1:f812e34:                 Thread.sleep(1000);
1:f812e34:                 executor.submit(new NonPooledProducerTask(acf1, QUEUE1_NAME));
1:f812e34:             }
1:7de0e81: 
1:f812e34:             assertTrue(doneLatch.await(20, TimeUnit.SECONDS));
1:f812e34:             executor.shutdownNow();
1:7de0e81: 
1:1b38caa:             assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
1:f812e34:         } finally {
1:f812e34:             container1.stop();
1:f812e34:             container1.destroy();
1:f812e34:             container1 = null;
1:7de0e81: 
1:f812e34:             container2.stop();
1:f812e34:             container2.destroy();
1:f812e34:             container2 = null;
1:7de0e81: 
1:f812e34:             brokerService1.stop();
1:f812e34:             brokerService1 = null;
1:f812e34:             brokerService2.stop();
1:f812e34:             brokerService2 = null;
1:f812e34:         }
1:f812e34:     }
1:7de0e81: 
1:f812e34:     private BrokerService createBrokerService(final String brokerName, final String uri1, final String uri2) throws Exception {
1:f812e34:         final BrokerService brokerService = new BrokerService();
1:7de0e81: 
1:f812e34:         brokerService.setBrokerName(brokerName);
1:f812e34:         brokerService.setPersistent(false);
1:f812e34:         brokerService.setUseJmx(true);
1:f812e34: 
1:6d8e2c5:         final SystemUsage memoryManager = new SystemUsage();
1:6d8e2c5:         memoryManager.getMemoryUsage().setLimit(5000000);
1:2b0024c:         brokerService.setSystemUsage(memoryManager);
1:f812e34: 
1:933eb2f:         final List<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
1:7de0e81: 
1:f812e34:         final PolicyEntry entry = new PolicyEntry();
1:f812e34:         entry.setQueue(">");
1:f812e34:         // entry.setQueue(QUEUE1_NAME);
1:f812e34:         entry.setMemoryLimit(1000);
1:f812e34:         policyEntries.add(entry);
1:7de0e81: 
1:f812e34:         final PolicyMap policyMap = new PolicyMap();
1:f812e34:         policyMap.setPolicyEntries(policyEntries);
1:f812e34:         brokerService.setDestinationPolicy(policyMap);
1:7de0e81: 
1:f812e34:         final TransportConnector tConnector = new TransportConnector();
1:f812e34:         tConnector.setUri(new URI(uri1));
1:f812e34:         tConnector.setName(brokerName + ".transportConnector");
1:f812e34:         brokerService.addConnector(tConnector);
1:7de0e81: 
1:f812e34:         if (uri2 != null) {
1:f812e34:             final NetworkConnector nc = new DiscoveryNetworkConnector(new URI("static:" + uri2));
1:f812e34:             nc.setBridgeTempDestinations(true);
1:f812e34:             nc.setBrokerName(brokerName);
1:f812e34:             brokerService.addNetworkConnector(nc);
1:f812e34:         }
1:7de0e81: 
1:f812e34:         return brokerService;
1:f812e34:     }
1:7de0e81: 
1:f812e34:     public DefaultMessageListenerContainer createDefaultMessageListenerContainer(final ConnectionFactory acf, final MessageListener listener, final String queue) {
1:f812e34:         final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();
1:f812e34:         container.setConnectionFactory(acf);
1:f812e34:         container.setDestinationName(queue);
1:f812e34:         container.setMessageListener(listener);
1:f812e34:         container.setSessionTransacted(false);
1:f812e34:         container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
1:f812e34:         container.setConcurrentConsumers(MAX_CONSUMERS);
1:f812e34:         return container;
1:f812e34:     }
1:7de0e81: 
1:f812e34:     public ActiveMQConnectionFactory createConnectionFactory(final String url) {
1:f812e34:         final ActiveMQConnectionFactory acf = new ActiveMQConnectionFactory(url);
1:f812e34:         acf.setCopyMessageOnSend(false);
1:f812e34:         acf.setUseAsyncSend(false);
1:f812e34:         acf.setDispatchAsync(true);
1:f812e34:         acf.setUseCompression(false);
1:f812e34:         acf.setOptimizeAcknowledge(false);
1:f812e34:         acf.setOptimizedMessageDispatch(true);
1:f812e34:         acf.setAlwaysSyncSend(true);
1:f812e34:         return acf;
1:f812e34:     }
1:7de0e81: 
1:f812e34:     private class TestMessageListener1 implements MessageListener {
1:7de0e81: 
1:f812e34:         private final long waitTime;
1:7de0e81: 
1:f812e34:         public TestMessageListener1(long waitTime) {
1:f812e34:             this.waitTime = waitTime;
1:f812e34:         }
1:7de0e81: 
1:1b38caa:         @Override
1:f812e34:         public void onMessage(Message msg) {
1:7de0e81: 
1:f812e34:             try {
1:fc00993:                 LOG.info("Listener1 Consumed message " + msg.getIntProperty("count"));
1:f812e34:                 messageCount.incrementAndGet();
1:f812e34:                 doneLatch.countDown();
1:f812e34:                 Thread.sleep(waitTime);
1:f812e34:             } catch (JMSException e) {
1:f812e34:                 e.printStackTrace();
1:f812e34:             } catch (InterruptedException e) {
1:f812e34:                 e.printStackTrace();
1:f812e34:             }
1:f812e34:         }
1:f812e34:     }
1:7de0e81: 
1:f812e34:     private static class PooledProducerTask implements Runnable {
1:7de0e81: 
1:f812e34:         private final String queueName;
1:7de0e81: 
1:f812e34:         private final PooledConnectionFactory pcf;
1:7de0e81: 
1:f812e34:         public PooledProducerTask(final PooledConnectionFactory pcf, final String queueName) {
1:f812e34:             this.pcf = pcf;
1:f812e34:             this.queueName = queueName;
1:f812e34:         }
1:7de0e81: 
1:1b38caa:         @Override
1:f812e34:         public void run() {
1:7de0e81: 
1:f812e34:             try {
1:7de0e81: 
1:f812e34:                 final JmsTemplate jmsTemplate = new JmsTemplate(pcf);
1:f812e34:                 jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:f812e34:                 jmsTemplate.setExplicitQosEnabled(true);
1:f812e34:                 jmsTemplate.setMessageIdEnabled(false);
1:f812e34:                 jmsTemplate.setMessageTimestampEnabled(false);
1:f812e34:                 jmsTemplate.afterPropertiesSet();
1:7de0e81: 
1:f812e34:                 final byte[] bytes = new byte[2048];
1:f812e34:                 final Random r = new Random();
1:f812e34:                 r.nextBytes(bytes);
1:7de0e81: 
1:f812e34:                 Thread.sleep(2000);
1:7de0e81: 
1:f812e34:                 final AtomicInteger count = new AtomicInteger();
1:f812e34:                 for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
1:f812e34:                     jmsTemplate.send(queueName, new MessageCreator() {
1:7de0e81: 
1:1b38caa:                         @Override
1:f812e34:                         public Message createMessage(Session session) throws JMSException {
1:7de0e81: 
1:f812e34:                             final BytesMessage message = session.createBytesMessage();
1:7de0e81: 
1:f812e34:                             message.writeBytes(bytes);
1:f812e34:                             message.setIntProperty("count", count.incrementAndGet());
1:f812e34:                             message.setStringProperty("producer", "pooled");
1:f812e34:                             return message;
1:f812e34:                         }
1:f812e34:                     });
1:7de0e81: 
1:fc00993:                     LOG.info("PooledProducer sent message: " + count.get());
1:f812e34:                     // Thread.sleep(1000);
1:f812e34:                 }
1:7de0e81: 
1:f812e34:             } catch (final Throwable e) {
1:fc00993:                 LOG.error("Producer 1 is exiting", e);
1:f812e34:             }
1:f812e34:         }
1:f812e34:     }
1:7de0e81: 
1:f812e34:     private static class NonPooledProducerTask implements Runnable {
1:7de0e81: 
1:f812e34:         private final String queueName;
1:7de0e81: 
1:f812e34:         private final ConnectionFactory cf;
1:7de0e81: 
1:f812e34:         public NonPooledProducerTask(final ConnectionFactory cf, final String queueName) {
1:f812e34:             this.cf = cf;
1:f812e34:             this.queueName = queueName;
1:f812e34:         }
1:7de0e81: 
1:1b38caa:         @Override
1:f812e34:         public void run() {
1:7de0e81: 
1:f812e34:             try {
1:7de0e81: 
1:f812e34:                 final JmsTemplate jmsTemplate = new JmsTemplate(cf);
1:f812e34:                 jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:f812e34:                 jmsTemplate.setExplicitQosEnabled(true);
1:f812e34:                 jmsTemplate.setMessageIdEnabled(false);
1:f812e34:                 jmsTemplate.setMessageTimestampEnabled(false);
1:f812e34:                 jmsTemplate.afterPropertiesSet();
1:7de0e81: 
1:f812e34:                 final byte[] bytes = new byte[2048];
1:f812e34:                 final Random r = new Random();
1:f812e34:                 r.nextBytes(bytes);
1:7de0e81: 
1:f812e34:                 Thread.sleep(2000);
1:7de0e81: 
1:f812e34:                 final AtomicInteger count = new AtomicInteger();
1:f812e34:                 for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
1:f812e34:                     jmsTemplate.send(queueName, new MessageCreator() {
1:7de0e81: 
1:1b38caa:                         @Override
1:f812e34:                         public Message createMessage(Session session) throws JMSException {
1:7de0e81: 
1:f812e34:                             final BytesMessage message = session.createBytesMessage();
1:7de0e81: 
1:f812e34:                             message.writeBytes(bytes);
1:f812e34:                             message.setIntProperty("count", count.incrementAndGet());
1:f812e34:                             message.setStringProperty("producer", "non-pooled");
1:f812e34:                             return message;
1:f812e34:                         }
1:f812e34:                     });
1:7de0e81: 
1:fc00993:                     LOG.info("Non-PooledProducer sent message: " + count.get());
1:7de0e81: 
1:f812e34:                     // Thread.sleep(1000);
1:f812e34:                 }
1:7de0e81: 
1:f812e34:             } catch (final Throwable e) {
1:fc00993:                 LOG.error("Producer 1 is exiting", e);
1:f812e34:             }
1:f812e34:         }
1:f812e34:     }
32:7de0e81: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:1b38caa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnectionFactory;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicInteger messageCount = new AtomicInteger();
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(NUM_MESSAGE_TO_SEND, messageCount.get());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final transient Logger LOG = LoggerFactory.getLogger(AMQDeadlockTest3.class);
commit:76de7c0
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:2e57fb5
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.usecases;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQConnectionFactory;
1: public class AMQDeadlockTest3 extends org.apache.activemq.test.TestSupport {
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:5d99c99
/////////////////////////////////////////////////////////////////////////
commit:2b0024c
/////////////////////////////////////////////////////////////////////////
1:         brokerService.setSystemUsage(memoryManager);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         final List<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
0:     private static final transient Log LOG = LogFactory.getLog(AMQDeadlockTest3.class);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Listener1 Consumed message " + msg.getIntProperty("count"));
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("PooledProducer sent message: " + count.get());
1:                 LOG.error("Producer 1 is exiting", e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Non-PooledProducer sent message: " + count.get());
1:                 LOG.error("Producer 1 is exiting", e);
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:     private static final String URL2 = "tcp://localhost:61617";
1:     private static final String QUEUE1_NAME = "test.queue.1";
1:     private static final String QUEUE2_NAME = "test.queue.2";
1:     private static final int MAX_CONSUMERS = 1;
1:     private static final int MAX_PRODUCERS = 1;
1:     private static final int NUM_MESSAGE_TO_SEND = 10;
0:     private AtomicInteger messageCount = new AtomicInteger();
1:     private CountDownLatch doneLatch;
1:     public void setUp() throws Exception {
1:     }
1:     public void tearDown() throws Exception {
1:     }
1:     // This should fail with incubator-activemq-fuse-4.1.0.5
1:     public void testQueueLimitsWithOneBrokerSameConnection() throws Exception {
1:         BrokerService brokerService1 = null;
1:         ActiveMQConnectionFactory acf = null;
1:         PooledConnectionFactory pcf = null;
1:         DefaultMessageListenerContainer container1 = null;
1:         try {
1:             brokerService1 = createBrokerService("broker1", URL1, null);
1:             brokerService1.start();
1:             acf = createConnectionFactory(URL1);
1:             pcf = new PooledConnectionFactory(acf);
1:             // Only listen on the first queue.. let the 2nd queue fill up.
1:             doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND);
1:             container1 = createDefaultMessageListenerContainer(acf, new TestMessageListener1(500), QUEUE1_NAME);
1:             container1.afterPropertiesSet();
1:             Thread.sleep(2000);
1:             final ExecutorService executor = Executors.newCachedThreadPool();
1:             for (int i = 0; i < MAX_PRODUCERS; i++) {
1:                 executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
1:                 Thread.sleep(1000);
1:                 executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
1:             }
1:             // Wait for all message to arrive.
1:             assertTrue(doneLatch.await(20, TimeUnit.SECONDS));
1:             executor.shutdownNow();
0:             Assert.assertEquals(NUM_MESSAGE_TO_SEND, messageCount.get());
1:         } finally {
1:             container1.stop();
1:             container1.destroy();
1:             container1 = null;
1:             brokerService1.stop();
1:             brokerService1 = null;
1:         }
1:     }
1:     // This should fail with incubator-activemq-fuse-4.1.0.5
1:     public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithOneConnectionForProducing() throws Exception {
1:         BrokerService brokerService1 = null;
1:         BrokerService brokerService2 = null;
1:         ActiveMQConnectionFactory acf1 = null;
1:         ActiveMQConnectionFactory acf2 = null;
1:         PooledConnectionFactory pcf = null;
1:         DefaultMessageListenerContainer container1 = null;
1:         try {
1:             brokerService1 = createBrokerService("broker1", URL1, URL2);
1:             brokerService1.start();
1:             brokerService2 = createBrokerService("broker2", URL2, URL1);
1:             brokerService2.start();
1:             acf1 = createConnectionFactory(URL1);
1:             acf2 = createConnectionFactory(URL2);
1:             pcf = new PooledConnectionFactory(acf1);
1:             Thread.sleep(1000);
1:             doneLatch = new CountDownLatch(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND);
1:             container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
1:             container1.afterPropertiesSet();
1:             final ExecutorService executor = Executors.newCachedThreadPool();
1:             for (int i = 0; i < MAX_PRODUCERS; i++) {
1:                 executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
1:                 Thread.sleep(1000);
1:                 executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
1:             }
1:             assertTrue(doneLatch.await(20, TimeUnit.SECONDS));
1:             executor.shutdownNow();
0:             Assert.assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
1:         } finally {
1:             container1.stop();
1:             container1.destroy();
1:             container1 = null;
1:             brokerService1.stop();
1:             brokerService1 = null;
1:             brokerService2.stop();
1:             brokerService2 = null;
1:         }
1:     }
1:     // This should fail with incubator-activemq-fuse-4.1.0.5
1:     public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithSeperateConnectionsForProducing() throws Exception {
1:         BrokerService brokerService1 = null;
1:         BrokerService brokerService2 = null;
1:         ActiveMQConnectionFactory acf1 = null;
1:         ActiveMQConnectionFactory acf2 = null;
1:         DefaultMessageListenerContainer container1 = null;
1:         DefaultMessageListenerContainer container2 = null;
1:         try {
1:             brokerService1 = createBrokerService("broker1", URL1, URL2);
1:             brokerService1.start();
1:             brokerService2 = createBrokerService("broker2", URL2, URL1);
1:             brokerService2.start();
1:             acf1 = createConnectionFactory(URL1);
1:             acf2 = createConnectionFactory(URL2);
1:             Thread.sleep(1000);
1:             doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND * MAX_PRODUCERS);
1:             container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
1:             container1.afterPropertiesSet();
1:             container2 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(30000), QUEUE2_NAME);
1:             container2.afterPropertiesSet();
1:             final ExecutorService executor = Executors.newCachedThreadPool();
1:             for (int i = 0; i < MAX_PRODUCERS; i++) {
1:                 executor.submit(new NonPooledProducerTask(acf1, QUEUE2_NAME));
1:                 Thread.sleep(1000);
1:                 executor.submit(new NonPooledProducerTask(acf1, QUEUE1_NAME));
1:             }
1:             assertTrue(doneLatch.await(20, TimeUnit.SECONDS));
1:             executor.shutdownNow();
0:             Assert.assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
1:         } finally {
1:             container1.stop();
1:             container1.destroy();
1:             container1 = null;
1:             container2.stop();
1:             container2.destroy();
1:             container2 = null;
1:             brokerService1.stop();
1:             brokerService1 = null;
1:             brokerService2.stop();
1:             brokerService2 = null;
1:         }
1:     }
1:     private BrokerService createBrokerService(final String brokerName, final String uri1, final String uri2) throws Exception {
1:         final BrokerService brokerService = new BrokerService();
1:         brokerService.setBrokerName(brokerName);
1:         brokerService.setPersistent(false);
1:         brokerService.setUseJmx(true);
0:         final UsageManager memoryManager = new UsageManager();
0:         memoryManager.setLimit(5000000);
0:         brokerService.setMemoryManager(memoryManager);
1: 
0:         final ArrayList policyEntries = new ArrayList();
1: 
1:         final PolicyEntry entry = new PolicyEntry();
1:         entry.setQueue(">");
1:         // entry.setQueue(QUEUE1_NAME);
1:         entry.setMemoryLimit(1000);
1:         policyEntries.add(entry);
1:         final PolicyMap policyMap = new PolicyMap();
1:         policyMap.setPolicyEntries(policyEntries);
1:         brokerService.setDestinationPolicy(policyMap);
1:         final TransportConnector tConnector = new TransportConnector();
1:         tConnector.setUri(new URI(uri1));
0:         tConnector.setBrokerName(brokerName);
1:         tConnector.setName(brokerName + ".transportConnector");
1:         brokerService.addConnector(tConnector);
1:         if (uri2 != null) {
1:             final NetworkConnector nc = new DiscoveryNetworkConnector(new URI("static:" + uri2));
1:             nc.setBridgeTempDestinations(true);
1:             nc.setBrokerName(brokerName);
1:             brokerService.addNetworkConnector(nc);
1:         }
1:         return brokerService;
1:     }
1:     public DefaultMessageListenerContainer createDefaultMessageListenerContainer(final ConnectionFactory acf, final MessageListener listener, final String queue) {
1:         final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();
1:         container.setConnectionFactory(acf);
1:         container.setDestinationName(queue);
1:         container.setMessageListener(listener);
1:         container.setSessionTransacted(false);
1:         container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
1:         container.setConcurrentConsumers(MAX_CONSUMERS);
1:         return container;
1:     }
1:     public ActiveMQConnectionFactory createConnectionFactory(final String url) {
1:         final ActiveMQConnectionFactory acf = new ActiveMQConnectionFactory(url);
1:         acf.setCopyMessageOnSend(false);
1:         acf.setUseAsyncSend(false);
1:         acf.setDispatchAsync(true);
1:         acf.setUseCompression(false);
1:         acf.setOptimizeAcknowledge(false);
1:         acf.setOptimizedMessageDispatch(true);
1:         acf.setAlwaysSyncSend(true);
1:         return acf;
1:     }
1:     private class TestMessageListener1 implements MessageListener {
1:         private final long waitTime;
1:         public TestMessageListener1(long waitTime) {
1:             this.waitTime = waitTime;
1:         }
1:         public void onMessage(Message msg) {
1:             try {
0:                 log.info("Listener1 Consumed message " + msg.getIntProperty("count"));
1:                 messageCount.incrementAndGet();
1:                 doneLatch.countDown();
1:                 Thread.sleep(waitTime);
1:             } catch (JMSException e) {
0:                 // TODO Auto-generated catch block
1:                 e.printStackTrace();
1:             } catch (InterruptedException e) {
0:                 // TODO Auto-generated catch block
1:                 e.printStackTrace();
1:             }
1:         }
1:     }
1:     private static class PooledProducerTask implements Runnable {
1:         private final String queueName;
1:         private final PooledConnectionFactory pcf;
1:         public PooledProducerTask(final PooledConnectionFactory pcf, final String queueName) {
1:             this.pcf = pcf;
1:             this.queueName = queueName;
1:         }
1:         public void run() {
1:             try {
1:                 final JmsTemplate jmsTemplate = new JmsTemplate(pcf);
1:                 jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:                 jmsTemplate.setExplicitQosEnabled(true);
1:                 jmsTemplate.setMessageIdEnabled(false);
1:                 jmsTemplate.setMessageTimestampEnabled(false);
1:                 jmsTemplate.afterPropertiesSet();
1:                 final byte[] bytes = new byte[2048];
1:                 final Random r = new Random();
1:                 r.nextBytes(bytes);
1:                 Thread.sleep(2000);
1:                 final AtomicInteger count = new AtomicInteger();
1:                 for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
1:                     jmsTemplate.send(queueName, new MessageCreator() {
1:                         public Message createMessage(Session session) throws JMSException {
1:                             final BytesMessage message = session.createBytesMessage();
1:                             message.writeBytes(bytes);
1:                             message.setIntProperty("count", count.incrementAndGet());
1:                             message.setStringProperty("producer", "pooled");
1:                             return message;
1:                         }
1:                     });
0:                     log.info("PooledProducer sent message: " + count.get());
1:                     // Thread.sleep(1000);
1:                 }
1:             } catch (final Throwable e) {
0:                 log.error("Producer 1 is exiting", e);
1:             }
1:         }
1:     }
1:     private static class NonPooledProducerTask implements Runnable {
1:         private final String queueName;
1:         private final ConnectionFactory cf;
1:         public NonPooledProducerTask(final ConnectionFactory cf, final String queueName) {
1:             this.cf = cf;
1:             this.queueName = queueName;
1:         }
1:         public void run() {
1:             try {
1:                 final JmsTemplate jmsTemplate = new JmsTemplate(cf);
1:                 jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:                 jmsTemplate.setExplicitQosEnabled(true);
1:                 jmsTemplate.setMessageIdEnabled(false);
1:                 jmsTemplate.setMessageTimestampEnabled(false);
1:                 jmsTemplate.afterPropertiesSet();
1:                 final byte[] bytes = new byte[2048];
1:                 final Random r = new Random();
1:                 r.nextBytes(bytes);
1:                 Thread.sleep(2000);
1:                 final AtomicInteger count = new AtomicInteger();
1:                 for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
1:                     jmsTemplate.send(queueName, new MessageCreator() {
1:                         public Message createMessage(Session session) throws JMSException {
1:                             final BytesMessage message = session.createBytesMessage();
1:                             message.writeBytes(bytes);
1:                             message.setIntProperty("count", count.incrementAndGet());
1:                             message.setStringProperty("producer", "non-pooled");
1:                             return message;
1:                         }
1:                     });
0:                     log.info("Non-PooledProducer sent message: " + count.get());
1:                     // Thread.sleep(1000);
1:                 }
1:             } catch (final Throwable e) {
0:                 log.error("Producer 1 is exiting", e);
1:             }
1:         }
1:     }
commit:489f5aa
/////////////////////////////////////////////////////////////////////////
0: 		acf.setAlwaysSyncSend(true);
commit:7de0e81
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq;
1: 
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Random;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import javax.jms.BytesMessage;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.Session;
1: 
0: import junit.framework.Assert;
0: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.pool.PooledConnectionFactory;
1: import org.springframework.jms.core.JmsTemplate;
1: import org.springframework.jms.core.MessageCreator;
1: import org.springframework.jms.listener.DefaultMessageListenerContainer;
1: 
1: 
0: public class AMQDeadlockTest3 extends TestCase {
1: 
1: 	private static final String URL1 = "tcp://localhost:61616";
1: 
0: 	private static final String URL2 = "tcp://localhost:61617";
1: 
0: 	private static final String QUEUE1_NAME = "test.queue.1";
1: 
0: 	private static final String QUEUE2_NAME = "test.queue.2";
1: 
0: 	private static final int MAX_CONSUMERS = 1;
1: 
0: 	private static final int MAX_PRODUCERS = 1;
1: 
0: 	private static final int NUM_MESSAGE_TO_SEND = 10;
1: 
0: 	private AtomicInteger messageCount = new AtomicInteger();
0: 	private CountDownLatch doneLatch;
1: 
0: 	public void setUp() throws Exception {
1: 	}
1: 
0: 	public void tearDown() throws Exception {
1: 	}
1: 
0: 	// This should fail with incubator-activemq-fuse-4.1.0.5
0: 	public void testQueueLimitsWithOneBrokerSameConnection() throws Exception {
1: 
0: 		BrokerService brokerService1 = null;
0: 		ActiveMQConnectionFactory acf = null;
0: 		PooledConnectionFactory pcf = null;
0: 		DefaultMessageListenerContainer container1 = null;
1: 
0: 		try {
0: 			brokerService1 = createBrokerService("broker1", URL1, null);
0: 			brokerService1.start();
1: 
0: 			acf = createConnectionFactory(URL1);
0: 			pcf = new PooledConnectionFactory(acf);
1: 
0: 			// Only listen on the first queue.. let the 2nd queue fill up.
0: 			doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND);
0: 			container1 = createDefaultMessageListenerContainer(acf,	new TestMessageListener1(500), QUEUE1_NAME);
0: 			container1.afterPropertiesSet();
1: 
0: 			Thread.sleep(2000);
1: 
0: 			final ExecutorService executor = Executors.newCachedThreadPool();
0: 			for (int i = 0; i < MAX_PRODUCERS; i++) {
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
0: 				Thread.sleep(1000);
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
1: 			}
1: 			
0: 			// Wait for all message to arrive.
0: 			assertTrue(doneLatch.await(20, TimeUnit.SECONDS));			
0: 			executor.shutdownNow();
1: 
0: 			Assert.assertEquals(NUM_MESSAGE_TO_SEND, messageCount.get());
1: 
0: 		} finally {
1: 
0: 			container1.stop();
0: 			container1.destroy();
0: 			container1 = null;
0: 			brokerService1.stop();
0: 			brokerService1 = null;
1: 
1: 		}
1: 
1: 	}
1: 	
1: 
1: 
1: 	
0: 	// This should fail with incubator-activemq-fuse-4.1.0.5
0: 	public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithOneConnectionForProducing()
0: 			throws Exception {
1: 
0: 		BrokerService brokerService1 = null;
0: 		BrokerService brokerService2 = null;
0: 		ActiveMQConnectionFactory acf1 = null;
0: 		ActiveMQConnectionFactory acf2 = null;
0: 		PooledConnectionFactory pcf = null;
0: 		DefaultMessageListenerContainer container1 = null;
1: 
0: 		try {
0: 			brokerService1 = createBrokerService("broker1", URL1, URL2);
0: 			brokerService1.start();
0: 			brokerService2 = createBrokerService("broker2", URL2, URL1);
0: 			brokerService2.start();
1: 
0: 			acf1 = createConnectionFactory(URL1);
0: 			acf2 = createConnectionFactory(URL2);
1: 
0: 			pcf = new PooledConnectionFactory(acf1);
1: 
0: 			Thread.sleep(1000);
1: 
0: 			doneLatch = new CountDownLatch(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND);
0: 			container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
0: 			container1.afterPropertiesSet();
1: 
0: 			final ExecutorService executor = Executors.newCachedThreadPool();
0: 			for (int i = 0; i < MAX_PRODUCERS; i++) {
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
0: 				Thread.sleep(1000);
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
1: 			}
1: 
0: 			assertTrue(doneLatch.await(20, TimeUnit.SECONDS));			
0: 			executor.shutdownNow();
1: 
0: 			Assert.assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND,
0: 					messageCount.get());
0: 		} finally {
1: 
0: 			container1.stop();
0: 			container1.destroy();
0: 			container1 = null;
1: 
0: 			brokerService1.stop();
0: 			brokerService1 = null;
0: 			brokerService2.stop();
0: 			brokerService2 = null;
1: 		}
1: 	}
1: 	
1: 	
0: 	// This should fail with incubator-activemq-fuse-4.1.0.5
0: 	public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithSeperateConnectionsForProducing()
0: 			throws Exception {
1: 
0: 		BrokerService brokerService1 = null;
0: 		BrokerService brokerService2 = null;
0: 		ActiveMQConnectionFactory acf1 = null;
0: 		ActiveMQConnectionFactory acf2 = null;
0: 		DefaultMessageListenerContainer container1 = null;
0: 		DefaultMessageListenerContainer container2 = null;
1: 		
0: 		try {
0: 			brokerService1 = createBrokerService("broker1", URL1, URL2);
0: 			brokerService1.start();
0: 			brokerService2 = createBrokerService("broker2", URL2, URL1);
0: 			brokerService2.start();
1: 
0: 			acf1 = createConnectionFactory(URL1);
0: 			acf2 = createConnectionFactory(URL2);
1: 
0: 			Thread.sleep(1000);
1: 
0: 			doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND*MAX_PRODUCERS);
1: 
0: 			container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
0: 			container1.afterPropertiesSet();
0: 			container2 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(30000), QUEUE2_NAME);
0: 			container2.afterPropertiesSet();
1: 
0: 			final ExecutorService executor = Executors.newCachedThreadPool();
0: 			for (int i = 0; i < MAX_PRODUCERS; i++) {
0: 				executor.submit(new NonPooledProducerTask(acf1, QUEUE2_NAME));
0: 				Thread.sleep(1000);
0: 				executor.submit(new NonPooledProducerTask(acf1, QUEUE1_NAME));
1: 			}
1: 
0: 			assertTrue(doneLatch.await(20, TimeUnit.SECONDS));			
0: 			executor.shutdownNow();
1: 
0: 			Assert.assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
0: 		} finally {
1: 
0: 			container1.stop();
0: 			container1.destroy();
0: 			container1 = null;
1: 			
0: 			container2.stop();
0: 			container2.destroy();
0: 			container2 = null;
1: 
0: 			brokerService1.stop();
0: 			brokerService1 = null;
0: 			brokerService2.stop();
0: 			brokerService2 = null;
1: 		}
1: 	}
1: 
1: 
1: 
1: 
0: 	private BrokerService createBrokerService(final String brokerName,
0: 			final String uri1, final String uri2) throws Exception {
0: 		final BrokerService brokerService = new BrokerService();
1: 
0: 		brokerService.setBrokerName(brokerName);
0: 		brokerService.setPersistent(false);
0: 		brokerService.setUseJmx(true);
1: 
0: 		final UsageManager memoryManager = new UsageManager();
0: 		memoryManager.setLimit(5000000);
0: 		brokerService.setMemoryManager(memoryManager);
1: 
0: 		final ArrayList policyEntries = new ArrayList();
1: 
0: 		final PolicyEntry entry = new PolicyEntry();
0: 		entry.setQueue(">");
0: 		// entry.setQueue(QUEUE1_NAME);
0: 		entry.setMemoryLimit(1000);
0: 		policyEntries.add(entry);
1: 
0: 		final PolicyMap policyMap = new PolicyMap();
0: 		policyMap.setPolicyEntries(policyEntries);
0: 		brokerService.setDestinationPolicy(policyMap);
1: 
0: 		final TransportConnector tConnector = new TransportConnector();
0: 		tConnector.setUri(new URI(uri1));
0: 		tConnector.setBrokerName(brokerName);
0: 		tConnector.setName(brokerName + ".transportConnector");
0: 		brokerService.addConnector(tConnector);
1: 
0: 		if (uri2 != null) {
0: 			final NetworkConnector nc = new DiscoveryNetworkConnector(new URI("static:" + uri2));
0: 			nc.setBridgeTempDestinations(true);
0: 			nc.setBrokerName(brokerName);
0: 			nc.setName(brokerName + ".nc");
0: 			brokerService.addNetworkConnector(nc);
1: 		}
1: 
0: 		return brokerService;
1: 
1: 	}
1: 
0: 	public DefaultMessageListenerContainer createDefaultMessageListenerContainer(
0: 			final ConnectionFactory acf, final MessageListener listener,
0: 			final String queue) {
0: 		final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();
0: 		container.setConnectionFactory(acf);
0: 		container.setDestinationName(queue);
0: 		container.setMessageListener(listener);
0: 		container.setSessionTransacted(false);
0: 		container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
0: 		container.setConcurrentConsumers(MAX_CONSUMERS);
0: 		return container;
1: 	}
1: 
0: 	public ActiveMQConnectionFactory createConnectionFactory(final String url) {
0: 		final ActiveMQConnectionFactory acf = new ActiveMQConnectionFactory(url);
0: 		acf.setCopyMessageOnSend(false);
0: 		acf.setUseAsyncSend(false);
0: 		acf.setDispatchAsync(true);
0: 		acf.setUseCompression(false);
0: 		acf.setOptimizeAcknowledge(false);
0: 		acf.setOptimizedMessageDispatch(true);
0: 		acf.setUseSyncSend(true);
0: 		return acf;
1: 	}
1: 
0: 	private class TestMessageListener1 implements MessageListener {
1: 
0: 		private final long waitTime;
1: 
0: 		public TestMessageListener1(long waitTime) {
0: 			this.waitTime = waitTime;
1: 		
1: 		}
1: 
0: 		public void onMessage(Message msg) {
1: 
0: 			try {
0: 				System.out.println("Listener1 Consumed message "+ msg.getIntProperty("count"));
1: 
0: 				messageCount.incrementAndGet();
0: 				doneLatch.countDown();
1: 				
0: 				Thread.sleep(waitTime);
0: 			} catch (JMSException e) {
0: 				// TODO Auto-generated catch block
0: 				e.printStackTrace();
0: 			} catch (InterruptedException e) {
0: 				// TODO Auto-generated catch block
0: 				e.printStackTrace();
1: 			}
1: 
1: 		}
1: 	}
1: 
1: 
0: 	private class PooledProducerTask implements Runnable {
1: 
0: 		private final String queueName;
1: 
0: 		private final PooledConnectionFactory pcf;
1: 
0: 		public PooledProducerTask(final PooledConnectionFactory pcf,
0: 				final String queueName) {
0: 			this.pcf = pcf;
0: 			this.queueName = queueName;
1: 		}
1: 
0: 		public void run() {
1: 
0: 			try {
1: 
0: 				final JmsTemplate jmsTemplate = new JmsTemplate(pcf);
0: 				jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 				jmsTemplate.setExplicitQosEnabled(true);
0: 				jmsTemplate.setMessageIdEnabled(false);
0: 				jmsTemplate.setMessageTimestampEnabled(false);
0: 				jmsTemplate.afterPropertiesSet();
1: 
0: 				final byte[] bytes = new byte[2048];
0: 				final Random r = new Random();
0: 				r.nextBytes(bytes);
1: 
0: 				Thread.sleep(2000);
1: 
0: 				final AtomicInteger count = new AtomicInteger();
0: 				for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
0: 					jmsTemplate.send(queueName, new MessageCreator() {
1: 
0: 						public Message createMessage(Session session)
0: 								throws JMSException {
1: 
0: 							final BytesMessage message = session.createBytesMessage();
1: 
0: 							message.writeBytes(bytes);
0: 							message.setIntProperty("count", count.incrementAndGet());
0: 							message.setStringProperty("producer", "pooled");
0: 							return message;
1: 						}
0: 					});
1: 
0: 					System.out.println("PooledProducer sent message: "+ count.get());
0: 					// Thread.sleep(1000);
1: 				}
1: 
0: 			} catch (final Throwable e) {
0: 				System.err.println("Producer 1 is exiting.");
0: 				e.printStackTrace();
1: 			}
1: 		}
1: 	}
1: 	
1: 	
0: 	private class NonPooledProducerTask implements Runnable {
1: 
0: 		private final String queueName;
1: 
0: 		private final ConnectionFactory cf;
1: 
0: 		public NonPooledProducerTask(final ConnectionFactory cf,
0: 				final String queueName) {
0: 			this.cf = cf;
0: 			this.queueName = queueName;
1: 		}
1: 
0: 		public void run() {
1: 
0: 			try {
1: 
0: 				final JmsTemplate jmsTemplate = new JmsTemplate(cf);
0: 				jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 				jmsTemplate.setExplicitQosEnabled(true);
0: 				jmsTemplate.setMessageIdEnabled(false);
0: 				jmsTemplate.setMessageTimestampEnabled(false);
0: 				jmsTemplate.afterPropertiesSet();
1: 
0: 				final byte[] bytes = new byte[2048];
0: 				final Random r = new Random();
0: 				r.nextBytes(bytes);
1: 
0: 				Thread.sleep(2000);
1: 
0: 				final AtomicInteger count = new AtomicInteger();
0: 				for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
0: 					jmsTemplate.send(queueName, new MessageCreator() {
1: 
0: 						public Message createMessage(Session session)
0: 								throws JMSException {
1: 
0: 							final BytesMessage message = session
0: 									.createBytesMessage();
1: 
0: 							message.writeBytes(bytes);
0: 							message.setIntProperty("count", count
0: 									.incrementAndGet());
0: 							message.setStringProperty("producer", "non-pooled");
0: 							return message;
1: 						}
0: 					});
1: 
0: 					System.out.println("Non-PooledProducer sent message: " + count.get());
1: 
0: 					// Thread.sleep(1000);
1: 				}
1: 
0: 			} catch (final Throwable e) {
0: 				System.err.println("Producer 1 is exiting.");
0: 				e.printStackTrace();
1: 			}
1: 		}
1: 	}
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:         final SystemUsage memoryManager = new SystemUsage();
1:         memoryManager.getMemoryUsage().setLimit(5000000);
0:         brokerService.setUsageManager(memoryManager);
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq;
0: 
0: import java.net.URI;
0: import java.util.ArrayList;
0: import java.util.Random;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicInteger;
0: 
0: import javax.jms.BytesMessage;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.DeliveryMode;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageListener;
0: import javax.jms.Session;
0: 
0: import junit.framework.Assert;
0: import junit.framework.TestCase;
0: 
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.memory.UsageManager;
0: import org.apache.activemq.network.DiscoveryNetworkConnector;
0: import org.apache.activemq.network.NetworkConnector;
0: import org.apache.activemq.pool.PooledConnectionFactory;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.springframework.jms.core.JmsTemplate;
0: import org.springframework.jms.core.MessageCreator;
0: import org.springframework.jms.listener.DefaultMessageListenerContainer;
0: 
0: 
0: public class AMQDeadlockTest3 extends TestCase {
0:     private static final transient Log log = LogFactory.getLog(AMQDeadlockTest3.class);
0: 
0:     private static final String URL1 = "tcp://localhost:61616";
0: 
0: 	private static final String URL2 = "tcp://localhost:61617";
0: 
0: 	private static final String QUEUE1_NAME = "test.queue.1";
0: 
0: 	private static final String QUEUE2_NAME = "test.queue.2";
0: 
0: 	private static final int MAX_CONSUMERS = 1;
0: 
0: 	private static final int MAX_PRODUCERS = 1;
0: 
0: 	private static final int NUM_MESSAGE_TO_SEND = 10;
0: 
0: 	private AtomicInteger messageCount = new AtomicInteger();
0: 	private CountDownLatch doneLatch;
0: 
0: 	public void setUp() throws Exception {
0: 	}
0: 
0: 	public void tearDown() throws Exception {
0: 	}
0: 
0: 	// This should fail with incubator-activemq-fuse-4.1.0.5
0: 	public void testQueueLimitsWithOneBrokerSameConnection() throws Exception {
0: 
0: 		BrokerService brokerService1 = null;
0: 		ActiveMQConnectionFactory acf = null;
0: 		PooledConnectionFactory pcf = null;
0: 		DefaultMessageListenerContainer container1 = null;
0: 
0: 		try {
0: 			brokerService1 = createBrokerService("broker1", URL1, null);
0: 			brokerService1.start();
0: 
0: 			acf = createConnectionFactory(URL1);
0: 			pcf = new PooledConnectionFactory(acf);
0: 
0: 			// Only listen on the first queue.. let the 2nd queue fill up.
0: 			doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND);
0: 			container1 = createDefaultMessageListenerContainer(acf,	new TestMessageListener1(500), QUEUE1_NAME);
0: 			container1.afterPropertiesSet();
0: 
0: 			Thread.sleep(2000);
0: 
0: 			final ExecutorService executor = Executors.newCachedThreadPool();
0: 			for (int i = 0; i < MAX_PRODUCERS; i++) {
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
0: 				Thread.sleep(1000);
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
0: 			}
0: 			
0: 			// Wait for all message to arrive.
0: 			assertTrue(doneLatch.await(20, TimeUnit.SECONDS));			
0: 			executor.shutdownNow();
0: 
0: 			Assert.assertEquals(NUM_MESSAGE_TO_SEND, messageCount.get());
0: 
0: 		} finally {
0: 
0: 			container1.stop();
0: 			container1.destroy();
0: 			container1 = null;
0: 			brokerService1.stop();
0: 			brokerService1 = null;
0: 
0: 		}
0: 
0: 	}
0: 	
0: 
0: 
0: 	
0: 	// This should fail with incubator-activemq-fuse-4.1.0.5
0: 	public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithOneConnectionForProducing()
0: 			throws Exception {
0: 
0: 		BrokerService brokerService1 = null;
0: 		BrokerService brokerService2 = null;
0: 		ActiveMQConnectionFactory acf1 = null;
0: 		ActiveMQConnectionFactory acf2 = null;
0: 		PooledConnectionFactory pcf = null;
0: 		DefaultMessageListenerContainer container1 = null;
0: 
0: 		try {
0: 			brokerService1 = createBrokerService("broker1", URL1, URL2);
0: 			brokerService1.start();
0: 			brokerService2 = createBrokerService("broker2", URL2, URL1);
0: 			brokerService2.start();
0: 
0: 			acf1 = createConnectionFactory(URL1);
0: 			acf2 = createConnectionFactory(URL2);
0: 
0: 			pcf = new PooledConnectionFactory(acf1);
0: 
0: 			Thread.sleep(1000);
0: 
0: 			doneLatch = new CountDownLatch(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND);
0: 			container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
0: 			container1.afterPropertiesSet();
0: 
0: 			final ExecutorService executor = Executors.newCachedThreadPool();
0: 			for (int i = 0; i < MAX_PRODUCERS; i++) {
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE2_NAME));
0: 				Thread.sleep(1000);
0: 				executor.submit(new PooledProducerTask(pcf, QUEUE1_NAME));
0: 			}
0: 
0: 			assertTrue(doneLatch.await(20, TimeUnit.SECONDS));			
0: 			executor.shutdownNow();
0: 
0: 			Assert.assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND,
0: 					messageCount.get());
0: 		} finally {
0: 
0: 			container1.stop();
0: 			container1.destroy();
0: 			container1 = null;
0: 
0: 			brokerService1.stop();
0: 			brokerService1 = null;
0: 			brokerService2.stop();
0: 			brokerService2 = null;
0: 		}
0: 	}
0: 	
0: 	
0: 	// This should fail with incubator-activemq-fuse-4.1.0.5
0: 	public void testQueueLimitsWithTwoBrokerProduceandConsumeonDifferentBrokersWithSeperateConnectionsForProducing()
0: 			throws Exception {
0: 
0: 		BrokerService brokerService1 = null;
0: 		BrokerService brokerService2 = null;
0: 		ActiveMQConnectionFactory acf1 = null;
0: 		ActiveMQConnectionFactory acf2 = null;
0: 		DefaultMessageListenerContainer container1 = null;
0: 		DefaultMessageListenerContainer container2 = null;
0: 		
0: 		try {
0: 			brokerService1 = createBrokerService("broker1", URL1, URL2);
0: 			brokerService1.start();
0: 			brokerService2 = createBrokerService("broker2", URL2, URL1);
0: 			brokerService2.start();
0: 
0: 			acf1 = createConnectionFactory(URL1);
0: 			acf2 = createConnectionFactory(URL2);
0: 
0: 			Thread.sleep(1000);
0: 
0: 			doneLatch = new CountDownLatch(NUM_MESSAGE_TO_SEND*MAX_PRODUCERS);
0: 
0: 			container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(500), QUEUE1_NAME);
0: 			container1.afterPropertiesSet();
0: 			container2 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(30000), QUEUE2_NAME);
0: 			container2.afterPropertiesSet();
0: 
0: 			final ExecutorService executor = Executors.newCachedThreadPool();
0: 			for (int i = 0; i < MAX_PRODUCERS; i++) {
0: 				executor.submit(new NonPooledProducerTask(acf1, QUEUE2_NAME));
0: 				Thread.sleep(1000);
0: 				executor.submit(new NonPooledProducerTask(acf1, QUEUE1_NAME));
0: 			}
0: 
0: 			assertTrue(doneLatch.await(20, TimeUnit.SECONDS));			
0: 			executor.shutdownNow();
0: 
0: 			Assert.assertEquals(MAX_PRODUCERS * NUM_MESSAGE_TO_SEND, messageCount.get());
0: 		} finally {
0: 
0: 			container1.stop();
0: 			container1.destroy();
0: 			container1 = null;
0: 			
0: 			container2.stop();
0: 			container2.destroy();
0: 			container2 = null;
0: 
0: 			brokerService1.stop();
0: 			brokerService1 = null;
0: 			brokerService2.stop();
0: 			brokerService2 = null;
0: 		}
0: 	}
0: 
0: 
0: 
0: 
0: 	private BrokerService createBrokerService(final String brokerName,
0: 			final String uri1, final String uri2) throws Exception {
0: 		final BrokerService brokerService = new BrokerService();
0: 
0: 		brokerService.setBrokerName(brokerName);
0: 		brokerService.setPersistent(false);
0: 		brokerService.setUseJmx(true);
0: 
0: 		final UsageManager memoryManager = new UsageManager();
0: 		memoryManager.setLimit(5000000);
0: 		brokerService.setMemoryManager(memoryManager);
0: 
0: 		final ArrayList policyEntries = new ArrayList();
0: 
0: 		final PolicyEntry entry = new PolicyEntry();
0: 		entry.setQueue(">");
0: 		// entry.setQueue(QUEUE1_NAME);
0: 		entry.setMemoryLimit(1000);
0: 		policyEntries.add(entry);
0: 
0: 		final PolicyMap policyMap = new PolicyMap();
0: 		policyMap.setPolicyEntries(policyEntries);
0: 		brokerService.setDestinationPolicy(policyMap);
0: 
0: 		final TransportConnector tConnector = new TransportConnector();
0: 		tConnector.setUri(new URI(uri1));
0: 		tConnector.setBrokerName(brokerName);
0: 		tConnector.setName(brokerName + ".transportConnector");
0: 		brokerService.addConnector(tConnector);
0: 
0: 		if (uri2 != null) {
0: 			final NetworkConnector nc = new DiscoveryNetworkConnector(new URI("static:" + uri2));
0: 			nc.setBridgeTempDestinations(true);
0: 			nc.setBrokerName(brokerName);
0: 			brokerService.addNetworkConnector(nc);
0: 		}
0: 
0: 		return brokerService;
0: 
0: 	}
0: 
0: 	public DefaultMessageListenerContainer createDefaultMessageListenerContainer(
0: 			final ConnectionFactory acf, final MessageListener listener,
0: 			final String queue) {
0: 		final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();
0: 		container.setConnectionFactory(acf);
0: 		container.setDestinationName(queue);
0: 		container.setMessageListener(listener);
0: 		container.setSessionTransacted(false);
0: 		container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
0: 		container.setConcurrentConsumers(MAX_CONSUMERS);
0: 		return container;
0: 	}
0: 
0: 	public ActiveMQConnectionFactory createConnectionFactory(final String url) {
0: 		final ActiveMQConnectionFactory acf = new ActiveMQConnectionFactory(url);
0: 		acf.setCopyMessageOnSend(false);
0: 		acf.setUseAsyncSend(false);
0: 		acf.setDispatchAsync(true);
0: 		acf.setUseCompression(false);
0: 		acf.setOptimizeAcknowledge(false);
0: 		acf.setOptimizedMessageDispatch(true);
0: 		acf.setAlwaysSyncSend(true);
0: 		return acf;
0: 	}
0: 
0: 	private class TestMessageListener1 implements MessageListener {
0: 
0: 		private final long waitTime;
0: 
0: 		public TestMessageListener1(long waitTime) {
0: 			this.waitTime = waitTime;
0: 		
0: 		}
0: 
0: 		public void onMessage(Message msg) {
0: 
0: 			try {
0: 				log.info("Listener1 Consumed message "+ msg.getIntProperty("count"));
0: 
0: 				messageCount.incrementAndGet();
0: 				doneLatch.countDown();
0: 				
0: 				Thread.sleep(waitTime);
0: 			} catch (JMSException e) {
0: 				// TODO Auto-generated catch block
0: 				e.printStackTrace();
0: 			} catch (InterruptedException e) {
0: 				// TODO Auto-generated catch block
0: 				e.printStackTrace();
0: 			}
0: 
0: 		}
0: 	}
0: 
0: 
0: 	private static class PooledProducerTask implements Runnable {
0: 
0: 		private final String queueName;
0: 
0: 		private final PooledConnectionFactory pcf;
0: 
0: 		public PooledProducerTask(final PooledConnectionFactory pcf,
0: 				final String queueName) {
0: 			this.pcf = pcf;
0: 			this.queueName = queueName;
0: 		}
0: 
0: 		public void run() {
0: 
0: 			try {
0: 
0: 				final JmsTemplate jmsTemplate = new JmsTemplate(pcf);
0: 				jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 				jmsTemplate.setExplicitQosEnabled(true);
0: 				jmsTemplate.setMessageIdEnabled(false);
0: 				jmsTemplate.setMessageTimestampEnabled(false);
0: 				jmsTemplate.afterPropertiesSet();
0: 
0: 				final byte[] bytes = new byte[2048];
0: 				final Random r = new Random();
0: 				r.nextBytes(bytes);
0: 
0: 				Thread.sleep(2000);
0: 
0: 				final AtomicInteger count = new AtomicInteger();
0: 				for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
0: 					jmsTemplate.send(queueName, new MessageCreator() {
0: 
0: 						public Message createMessage(Session session)
0: 								throws JMSException {
0: 
0: 							final BytesMessage message = session.createBytesMessage();
0: 
0: 							message.writeBytes(bytes);
0: 							message.setIntProperty("count", count.incrementAndGet());
0: 							message.setStringProperty("producer", "pooled");
0: 							return message;
0: 						}
0: 					});
0: 
0: 					log.info("PooledProducer sent message: "+ count.get());
0: 					// Thread.sleep(1000);
0: 				}
0: 
0: 			} catch (final Throwable e) {
0: 				log.error("Producer 1 is exiting", e);
0: 			}
0: 		}
0: 	}
0: 	
0: 	
0: 	private static class NonPooledProducerTask implements Runnable {
0: 
0: 		private final String queueName;
0: 
0: 		private final ConnectionFactory cf;
0: 
0: 		public NonPooledProducerTask(final ConnectionFactory cf,
0: 				final String queueName) {
0: 			this.cf = cf;
0: 			this.queueName = queueName;
0: 		}
0: 
0: 		public void run() {
0: 
0: 			try {
0: 
0: 				final JmsTemplate jmsTemplate = new JmsTemplate(cf);
0: 				jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 				jmsTemplate.setExplicitQosEnabled(true);
0: 				jmsTemplate.setMessageIdEnabled(false);
0: 				jmsTemplate.setMessageTimestampEnabled(false);
0: 				jmsTemplate.afterPropertiesSet();
0: 
0: 				final byte[] bytes = new byte[2048];
0: 				final Random r = new Random();
0: 				r.nextBytes(bytes);
0: 
0: 				Thread.sleep(2000);
0: 
0: 				final AtomicInteger count = new AtomicInteger();
0: 				for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
0: 					jmsTemplate.send(queueName, new MessageCreator() {
0: 
0: 						public Message createMessage(Session session)
0: 								throws JMSException {
0: 
0: 							final BytesMessage message = session
0: 									.createBytesMessage();
0: 
0: 							message.writeBytes(bytes);
0: 							message.setIntProperty("count", count
0: 									.incrementAndGet());
0: 							message.setStringProperty("producer", "non-pooled");
0: 							return message;
0: 						}
0: 					});
0: 
0: 					log.info("Non-PooledProducer sent message: " + count.get());
0: 
0: 					// Thread.sleep(1000);
0: 				}
0: 
0: 			} catch (final Throwable e) {
0: 				log.error("Producer 1 is exiting", e);
0: 			}
0: 		}
0: 	}
0: 
0: }
commit:54114cc
/////////////////////////////////////////////////////////////////////////
author:James Strachan
-------------------------------------------------------------------------------
commit:b19f17c
/////////////////////////////////////////////////////////////////////////
0: 				log.error("Producer 1 is exiting", e);
/////////////////////////////////////////////////////////////////////////
0: 				log.error("Producer 1 is exiting", e);
commit:aa1aa58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final transient Log log = LogFactory.getLog(AMQDeadlockTest3.class);
0:     private static final String URL1 = "tcp://localhost:61616";
/////////////////////////////////////////////////////////////////////////
0: 				log.info("Listener1 Consumed message "+ msg.getIntProperty("count"));
/////////////////////////////////////////////////////////////////////////
0: 					log.info("PooledProducer sent message: "+ count.get());
/////////////////////////////////////////////////////////////////////////
0: 					log.info("Non-PooledProducer sent message: " + count.get());
============================================================================