3:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
2:04968b6:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
3:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:634da7a: 
1:1e7881f: import java.io.IOException;
1:1e7881f: import java.util.ArrayList;
1:1e7881f: import java.util.LinkedList;
1:1e7881f: import java.util.List;
1:64f3492: import java.util.Map;
1:ea84378: import java.util.concurrent.CancellationException;
1:1e7881f: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:1e7881f: import java.util.concurrent.CopyOnWriteArrayList;
1:ea84378: import java.util.concurrent.Future;
1:cdb38b3: import java.util.concurrent.atomic.AtomicBoolean;
1:b567bd4: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:3bf0245: 
1:b5e46ef: import org.apache.activemq.advisory.AdvisorySupport;
1:13829ef: import org.apache.activemq.broker.BrokerService;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:84eb9f8: import org.apache.activemq.broker.ProducerBrokerExchange;
1:d29ca2a: import org.apache.activemq.broker.region.policy.DispatchPolicy;
1:d29ca2a: import org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy;
1:bcb60a4: import org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy;
1:d29ca2a: import org.apache.activemq.broker.region.policy.SimpleDispatchPolicy;
1:d29ca2a: import org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy;
1:383a7ac: import org.apache.activemq.broker.util.InsertionCountList;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:833d308: import org.apache.activemq.command.ConsumerInfo;
1:a59cd03: import org.apache.activemq.command.ExceptionResponse;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:a59cd03: import org.apache.activemq.command.ProducerAck;
1:9da7e31: import org.apache.activemq.command.ProducerInfo;
1:9da7e31: import org.apache.activemq.command.Response;
1:d29ca2a: import org.apache.activemq.command.SubscriptionInfo;
1:d29ca2a: import org.apache.activemq.filter.MessageEvaluationContext;
1:3b0afd6: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
1:d29ca2a: import org.apache.activemq.store.MessageRecoveryListener;
1:18571ce: import org.apache.activemq.store.NoLocalSubscriptionAware;
1:18571ce: import org.apache.activemq.store.PersistenceAdapter;
1:d29ca2a: import org.apache.activemq.store.TopicMessageStore;
1:9dd11cb: import org.apache.activemq.thread.Task;
1:9dd11cb: import org.apache.activemq.thread.TaskRunner;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:d29ca2a: import org.apache.activemq.transaction.Synchronization;
1:d29ca2a: import org.apache.activemq.util.SubscriptionKey;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:b567bd4: 
1:04968b6: /**
1:d29ca2a:  * The Topic is a destination that sends a copy of a message to every active
1:d29ca2a:  * Subscription registered.
1:04968b6:  */
1:48764be: public class Topic extends BaseDestination implements Task {
1:8bf987b:     protected static final Logger LOG = LoggerFactory.getLogger(Topic.class);
1:8d11f07:     private final TopicMessageStore topicStore;
1:ecf89a6:     protected final CopyOnWriteArrayList<Subscription> consumers = new CopyOnWriteArrayList<Subscription>();
1:b567bd4:     private final ReentrantReadWriteLock dispatchLock = new ReentrantReadWriteLock();
1:d29ca2a:     private DispatchPolicy dispatchPolicy = new SimpleDispatchPolicy();
1:5f8c101:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy;
1:9ef4259:     private final ConcurrentMap<SubscriptionKey, DurableTopicSubscription> durableSubscribers = new ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription>();
1:9dd11cb:     private final TaskRunner taskRunner;
1:cdb38b3:     private final TaskRunnerFactory taskRunnerFactor;
1:ecf89a6:     private final LinkedList<Runnable> messagesWaitingForSpace = new LinkedList<Runnable>();
1:ecf89a6:     private final Runnable sendMessagesWaitingForSpaceTask = new Runnable() {
1:3039b67:         @Override
1:ecf89a6:         public void run() {
1:9dd11cb:             try {
1:9dd11cb:                 Topic.this.taskRunner.wakeup();
1:9dd11cb:             } catch (InterruptedException e) {
1:90c8ded:             }
1:2769298:         }
1:ecf89a6:     };
1:0d85869: 
1:ddb2c91:     public Topic(BrokerService brokerService, ActiveMQDestination destination, TopicMessageStore store,
1:ddb2c91:             DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Exception {
1:13829ef:         super(brokerService, store, destination, parentStats);
1:48764be:         this.topicStore = store;
1:9ad65c6:         subscriptionRecoveryPolicy = new RetainedMessageSubscriptionRecoveryPolicy(null);
1:9dd11cb:         this.taskRunner = taskFactory.createTaskRunner(this, "Topic  " + destination.getPhysicalName());
1:cdb38b3:         this.taskRunnerFactor = taskFactory;
1:90c8ded:     }
1:83c3dca: 
1:ea84378:     @Override
1:48764be:     public void initialize() throws Exception {
1:13829ef:         super.initialize();
1:9ad65c6:         // set non default subscription recovery policy (override policyEntries)
1:9ad65c6:         if (AdvisorySupport.isMasterBrokerAdvisoryTopic(destination)) {
1:9ad65c6:             subscriptionRecoveryPolicy = new LastImageSubscriptionRecoveryPolicy();
1:9ad65c6:             setAlwaysRetroactive(true);
1:9ad65c6:         }
1:83c3dca:         if (store != null) {
1:ddb2c91:             // AMQ-2586: Better to leave this stat at zero than to give the user
1:ddb2c91:             // misleading metrics.
1:02d5728:             // int messageCount = store.getMessageCount();
1:02d5728:             // destinationStatistics.getMessages().setCount(messageCount);
1:785b16b:             store.start();
1:83c3dca:         }
1:83c3dca:     }
1:8d11f07: 
1:ea84378:     @Override
1:947659c:     public List<Subscription> getConsumers() {
1:230a86c:         synchronized (consumers) {
1:947659c:             return new ArrayList<Subscription>(consumers);
1:9dd11cb:         }
1:9dd11cb:     }
1:8d11f07: 
1:44b00e9:     public boolean lock(MessageReference node, LockOwner sub) {
1:3a5f48d:         return true;
1:5f8c101:     }
1:3bf0245: 
1:3039b67:     @Override
1:7f5213b:     public void addSubscription(ConnectionContext context, final Subscription sub) throws Exception {
1:230a86c:         if (!sub.getConsumerInfo().isDurable()) {
1:b567bd4: 
1:0f502fa:             // Do a retroactive recovery if needed.
1:fe63c29:             if (sub.getConsumerInfo().isRetroactive() || isAlwaysRetroactive()) {
1:a9ba595: 
1:b567bd4:                 // synchronize with dispatch method so that no new messages are sent
1:b567bd4:                 // while we are recovering a subscription to avoid out of order messages.
1:b567bd4:                 dispatchLock.writeLock().lock();
1:230a86c:                 try {
1:144dda0:                     boolean applyRecovery = false;
1:230a86c:                     synchronized (consumers) {
1:144dda0:                         if (!consumers.contains(sub)){
1:144dda0:                             sub.add(context, this);
1:144dda0:                             consumers.add(sub);
1:144dda0:                             applyRecovery=true;
1:144dda0:                             super.addSubscription(context, sub);
1:144dda0:                         }
1:3a5f48d:                     }
1:144dda0:                     if (applyRecovery){
1:144dda0:                         subscriptionRecoveryPolicy.recover(context, this, sub);
1:144dda0:                     }
1:230a86c:                 } finally {
1:b567bd4:                     dispatchLock.writeLock().unlock();
1:3bf0245:                 }
1:ae5bd2e: 
1:9da7e31:             } else {
1:ae5bd2e:                 synchronized (consumers) {
1:144dda0:                     if (!consumers.contains(sub)){
1:144dda0:                         sub.add(context, this);
1:144dda0:                         consumers.add(sub);
1:144dda0:                         super.addSubscription(context, sub);
1:144dda0:                     }
1:3bf0245:                 }
1:b792f11:             }
1:ae5bd2e:         } else {
1:0f502fa:             DurableTopicSubscription dsub = (DurableTopicSubscription) sub;
1:144dda0:             super.addSubscription(context, sub);
1:0ee0cb9:             sub.add(context, this);
1:0ee0cb9:             if(dsub.isActive()) {
1:0ee0cb9:                 synchronized (consumers) {
1:0ee0cb9:                     boolean hasSubscription = false;
1:0ee0cb9: 
1:ae5bd2e:                     if (consumers.size() == 0) {
1:0ee0cb9:                         hasSubscription = false;
1:0ee0cb9:                     } else {
1:ae5bd2e:                         for (Subscription currentSub : consumers) {
1:ae5bd2e:                             if (currentSub.getConsumerInfo().isDurable()) {
1:0ee0cb9:                                 DurableTopicSubscription dcurrentSub = (DurableTopicSubscription) currentSub;
1:ae5bd2e:                                 if (dcurrentSub.getSubscriptionKey().equals(dsub.getSubscriptionKey())) {
1:0ee0cb9:                                     hasSubscription = true;
1:0ee0cb9:                                     break;
1:0ee0cb9:                                 }
1:0ee0cb9:                             }
1:0ee0cb9:                         }
1:0ee0cb9:                     }
1:0ee0cb9: 
1:ae5bd2e:                     if (!hasSubscription) {
1:0ee0cb9:                         consumers.add(sub);
1:0ee0cb9:                     }
1:0ee0cb9:                 }
1:ae5bd2e:             }
1:a5eb7c6:             durableSubscribers.put(dsub.getSubscriptionKey(), dsub);
1:ae5bd2e:         }
1:ae5bd2e:     }
1:ddb2c91: 
1:3039b67:     @Override
1:ae5bd2e:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId) throws Exception {
1:230a86c:         if (!sub.getConsumerInfo().isDurable()) {
1:d86c98a:             boolean removed = false;
1:230a86c:             synchronized (consumers) {
1:d86c98a:                 removed = consumers.remove(sub);
1:d86c98a:             }
1:d86c98a:             if (removed) {
1:d86c98a:                 super.removeSubscription(context, sub, lastDeliveredSequenceId);
1:ae5bd2e:             }
1:ae5bd2e:         }
1:0f502fa:         sub.remove(context, this);
1:ae5bd2e:     }
1:ae5bd2e: 
1:9444a79:     public void deleteSubscription(ConnectionContext context, SubscriptionKey key) throws Exception {
1:8d11f07:         if (topicStore != null) {
1:8d11f07:             topicStore.deleteSubscription(key.clientId, key.subscriptionName);
1:a5eb7c6:             DurableTopicSubscription removed = durableSubscribers.remove(key);
1:230a86c:             if (removed != null) {
2:0f502fa:                 destinationStatistics.getConsumers().decrement();
1:27262c8:                 // deactivate and remove
1:dbb1d8b:                 removed.deactivate(false, 0l);
1:27262c8:                 consumers.remove(removed);
1:ddb2c91:             }
1:27262c8:         }
1:ae5bd2e:     }
1:a9ba595: 
1:18571ce:     private boolean hasDurableSubChanged(SubscriptionInfo info1, ConsumerInfo info2) throws IOException {
1:81b4b9a:         if (hasSelectorChanged(info1, info2)) {
1:81b4b9a:             return true;
1:81b4b9a:         }
1:81b4b9a: 
1:81b4b9a:         return hasNoLocalChanged(info1, info2);
1:81b4b9a:     }
1:81b4b9a: 
1:18571ce:     private boolean hasNoLocalChanged(SubscriptionInfo info1, ConsumerInfo info2) throws IOException {
1:18571ce:         //Not all persistence adapters store the noLocal value for a subscription
1:18571ce:         PersistenceAdapter adapter = broker.getBrokerService().getPersistenceAdapter();
1:18571ce:         if (adapter instanceof NoLocalSubscriptionAware) {
1:81b4b9a:             if (info1.isNoLocal() ^ info2.isNoLocal()) {
1:81b4b9a:                 return true;
1:81b4b9a:             }
1:81b4b9a:         }
1:81b4b9a: 
1:81b4b9a:         return false;
1:81b4b9a:     }
1:81b4b9a: 
1:81b4b9a:     private boolean hasSelectorChanged(SubscriptionInfo info1, ConsumerInfo info2) {
1:833d308:         if (info1.getSelector() != null ^ info2.getSelector() != null) {
1:833d308:             return true;
1:833d308:         }
1:81b4b9a: 
1:833d308:         if (info1.getSelector() != null && !info1.getSelector().equals(info2.getSelector())) {
1:833d308:             return true;
1:833d308:         }
1:833d308: 
1:833d308:         return false;
1:833d308:     }
1:833d308: 
1:7f5213b:     public void activate(ConnectionContext context, final DurableTopicSubscription subscription) throws Exception {
1:0f502fa:         // synchronize with dispatch method so that no new messages are sent
1:b567bd4:         // while we are recovering a subscription to avoid out of order messages.
1:b567bd4:         dispatchLock.writeLock().lock();
1:a59cd03:         try {
1:9da7e31: 
1:8d11f07:             if (topicStore == null) {
1:230a86c:                 return;
1:a9ba595:             }
1:7c3bb40: 
1:0f502fa:             // Recover the durable subscription.
1:23cda2d:             String clientId = subscription.getSubscriptionKey().getClientId();
1:23cda2d:             String subscriptionName = subscription.getSubscriptionKey().getSubscriptionName();
1:8d11f07:             SubscriptionInfo info = topicStore.lookupSubscription(clientId, subscriptionName);
1:0f502fa:             if (info != null) {
1:0f502fa:                 // Check to see if selector changed.
1:833d308:                 if (hasDurableSubChanged(info, subscription.getConsumerInfo())) {
1:0f502fa:                     // Need to delete the subscription
1:8d11f07:                     topicStore.deleteSubscription(clientId, subscriptionName);
1:0f502fa:                     info = null;
1:81b4b9a:                     // Force a rebuild of the selector chain for the subscription otherwise
1:81b4b9a:                     // the stored subscription is updated but the selector expression is not
1:81b4b9a:                     // and the subscription will not behave according to the new configuration.
1:81b4b9a:                     subscription.setSelector(subscription.getConsumerInfo().getSelector());
1:425fa47:                     synchronized (consumers) {
1:3039b67:                         consumers.remove(subscription);
1:425fa47:                     }
1:230a86c:                 } else {
1:230a86c:                     synchronized (consumers) {
1:3039b67:                         if (!consumers.contains(subscription)) {
1:3039b67:                             consumers.add(subscription);
1:3039b67:                         }
1:4ae6807:                     }
1:9da7e31:                 }
1:ecf89a6:             }
1:293a698: 
1:0f502fa:             // Do we need to create the subscription?
1:0f502fa:             if (info == null) {
1:230a86c:                 info = new SubscriptionInfo();
1:230a86c:                 info.setClientId(clientId);
1:833d308:                 info.setSelector(subscription.getConsumerInfo().getSelector());
1:230a86c:                 info.setSubscriptionName(subscriptionName);
1:6d8e2c5:                 info.setDestination(getActiveMQDestination());
1:833d308:                 info.setNoLocal(subscription.getConsumerInfo().isNoLocal());
1:2e7d219:                 // This destination is an actual destination id.
1:6d8e2c5:                 info.setSubscribedDestination(subscription.getConsumerInfo().getDestination());
1:6d8e2c5:                 // This destination might be a pattern
1:2e7d219:                 synchronized (consumers) {
1:4ae6807:                     consumers.add(subscription);
1:c0090f6:                     topicStore.addSubscription(info, subscription.getConsumerInfo().isRetroactive());
1:ecf89a6:                 }
1:ecf89a6:             }
1:9da7e31: 
1:3b0afd6:             final MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
1:0f502fa:             msgContext.setDestination(destination);
1:230a86c:             if (subscription.isRecoveryRequired()) {
1:8d11f07:                 topicStore.recoverSubscription(clientId, subscriptionName, new MessageRecoveryListener() {
1:3039b67:                     @Override
1:230a86c:                     public boolean recoverMessage(Message message) throws Exception {
1:4eef609:                         message.setRegionDestination(Topic.this);
1:230a86c:                         try {
1:4eef609:                             msgContext.setMessageReference(message);
1:230a86c:                             if (subscription.matches(message, msgContext)) {
1:4eef609:                                 subscription.add(message);
1:4eef609:                             }
1:0d85869:                         } catch (IOException e) {
1:e1bbde7:                             LOG.error("Failed to recover this message {}", message, e);
1:230a86c:                         }
1:3a5f48d:                         return true;
1:a59cd03:                     }
1:4eef609: 
1:3039b67:                     @Override
1:230a86c:                     public boolean recoverMessageReference(MessageId messageReference) throws Exception {
1:4eef609:                         throw new RuntimeException("Should not be called.");
1:2748ae1:                     }
1:4eef609: 
1:3039b67:                     @Override
1:230a86c:                     public boolean hasSpace() {
1:3a5f48d:                         return true;
1:230a86c:                     }
1:2748ae1: 
1:3039b67:                     @Override
1:132f662:                     public boolean isDuplicate(MessageId id) {
1:132f662:                         return false;
1:230a86c:                     }
1:4eef609:                 });
1:4eef609:             }
1:230a86c:         } finally {
1:b567bd4:             dispatchLock.writeLock().unlock();
1:b792f11:         }
1:230a86c:     }
1:4597ddd: 
1:3039b67:     public void deactivate(ConnectionContext context, DurableTopicSubscription sub, List<MessageReference> dispatched) throws Exception {
1:230a86c:         synchronized (consumers) {
1:0f502fa:             consumers.remove(sub);
1:4597ddd:         }
1:3039b67:         sub.remove(context, this, dispatched);
1:4597ddd:     }
1:4597ddd: 
1:a581d01:     public void recoverRetroactiveMessages(ConnectionContext context, Subscription subscription) throws Exception {
1:230a86c:         if (subscription.getConsumerInfo().isRetroactive()) {
1:230a86c:             subscriptionRecoveryPolicy.recover(context, this, subscription);
1:4597ddd:         }
1:230a86c:     }
1:4597ddd: 
1:3039b67:     @Override
1:4569d7d:     public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {
1:230a86c:         final ConnectionContext context = producerExchange.getConnectionContext();
1:4597ddd: 
1:9da7e31:         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
1:0736953:         producerExchange.incrementSend();
1:ddb2c91:         final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0
1:ddb2c91:                 && !context.isInRecoveryMode();
1:9da7e31: 
1:179dc3a:         message.setRegionDestination(this);
1:179dc3a: 
1:230a86c:         // There is delay between the client sending it and it arriving at the
1:230a86c:         // destination.. it may have expired.
1:0d85869:         if (message.isExpired()) {
1:27c1719:             broker.messageExpired(context, message, null);
1:c6a485f:             getDestinationStatistics().getExpired().increment();
1:9da7e31:             if (sendProducerAck) {
1:cdc2fd3:                 ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
1:9da7e31:                 context.getConnection().dispatchAsync(ack);
1:ecf89a6:             }
1:230a86c:             return;
1:230a86c:         }
1:9da7e31: 
1:48764be:         if (memoryUsage.isFull()) {
1:cdc2fd3:             isFull(context, memoryUsage);
1:cdc2fd3:             fastProducer(context, producerInfo);
1:ecf89a6: 
1:cdc2fd3:             if (isProducerFlowControl() && context.isProducerFlowControl()) {
1:cdc2fd3: 
1:01b1f7f:                 if (isFlowControlLogRequired()) {
1:0608175:                     LOG.warn("{}, Usage Manager memory limit reached {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:0608175:                             getActiveMQDestination().getQualifiedName(), memoryUsage.getLimit());
1:0608175:                 } else {
1:0608175:                     LOG.debug("{}, Usage Manager memory limit reached {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:a64976a:                             getActiveMQDestination().getQualifiedName(), memoryUsage.getLimit());
1:cdc2fd3:                 }
1:cdc2fd3: 
1:8ce0778:                 if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
1:ddb2c91:                     throw new javax.jms.ResourceAllocationException("Usage Manager memory limit ("
1:2b10259:                             + memoryUsage.getLimit() + ") reached. Rejecting send for producer (" + message.getProducerId()
1:ddb2c91:                             + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
1:ddb2c91:                             + " See http://activemq.apache.org/producer-flow-control.html for more info");
1:230a86c:                 }
1:ecf89a6: 
1:ae5bd2e:                 // We can avoid blocking due to low usage if the producer is sending a sync message or
1:cdc2fd3:                 // if it is using a producer window
1:cdc2fd3:                 if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {
1:cdc2fd3:                     synchronized (messagesWaitingForSpace) {
1:cdc2fd3:                         messagesWaitingForSpace.add(new Runnable() {
1:3039b67:                             @Override
1:cdc2fd3:                             public void run() {
1:cdc2fd3:                                 try {
1:cdc2fd3: 
1:cdc2fd3:                                     // While waiting for space to free up... the
1:cdc2fd3:                                     // message may have expired.
1:0d85869:                                     if (message.isExpired()) {
1:27c1719:                                         broker.messageExpired(context, message, null);
1:a1bd85e:                                         getDestinationStatistics().getExpired().increment();
1:cdc2fd3:                                     } else {
1:cdc2fd3:                                         doMessageSend(producerExchange, message);
1:cdc2fd3:                                     }
1:cdc2fd3: 
1:cdc2fd3:                                     if (sendProducerAck) {
1:ddb2c91:                                         ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message
1:ddb2c91:                                                 .getSize());
1:cdc2fd3:                                         context.getConnection().dispatchAsync(ack);
1:cdc2fd3:                                     } else {
1:cdc2fd3:                                         Response response = new Response();
1:cdc2fd3:                                         response.setCorrelationId(message.getCommandId());
1:cdc2fd3:                                         context.getConnection().dispatchAsync(response);
1:cdc2fd3:                                     }
1:cdc2fd3: 
1:cdc2fd3:                                 } catch (Exception e) {
1:cdc2fd3:                                     if (!sendProducerAck && !context.isInRecoveryMode()) {
1:cdc2fd3:                                         ExceptionResponse response = new ExceptionResponse(e);
1:cdc2fd3:                                         response.setCorrelationId(message.getCommandId());
1:cdc2fd3:                                         context.getConnection().dispatchAsync(response);
1:cdc2fd3:                                     }
1:9da7e31:                                 }
1:230a86c:                             }
1:cdc2fd3:                         });
1:cdc2fd3: 
1:e0c5024:                         registerCallbackForNotFullNotification();
1:cdc2fd3:                         context.setDontSendReponse(true);
1:cdc2fd3:                         return;
1:230a86c:                     }
1:cdc2fd3: 
1:cdc2fd3:                 } else {
1:ae5bd2e:                     // Producer flow control cannot be used, so we have do the flow control
1:ae5bd2e:                     // at the broker by blocking this thread until there is space available.
1:cdc2fd3: 
1:48764be:                     if (memoryUsage.isFull()) {
1:ea84378:                         if (context.isInTransaction()) {
1:cdc2fd3: 
1:cdc2fd3:                             int count = 0;
1:cdc2fd3:                             while (!memoryUsage.waitForSpace(1000)) {
1:cdc2fd3:                                 if (context.getStopping().get()) {
1:cdc2fd3:                                     throw new IOException("Connection closed, send aborted.");
1:ea84378:                                 }
1:cdc2fd3:                                 if (count > 2 && context.isInTransaction()) {
1:48764be:                                     count = 0;
1:cdc2fd3:                                     int size = context.getTransaction().size();
1:e1bbde7:                                     LOG.warn("Waiting for space to send transacted message - transaction elements = {} need more space to commit. Message = {}", size, message);
1:cdc2fd3:                                 }
1:96f2945:                                 count++;
1:cdc2fd3:                             }
1:9da7e31:                         } else {
1:ddb2c91:                             waitForSpace(
1:ddb2c91:                                     context,
1:0736953:                                     producerExchange,
1:ddb2c91:                                     memoryUsage,
1:2b10259:                                     "Usage Manager Memory Usage limit reached. Stopping producer ("
1:ddb2c91:                                             + message.getProducerId()
1:ddb2c91:                                             + ") to prevent flooding "
1:ddb2c91:                                             + getActiveMQDestination().getQualifiedName()
1:ddb2c91:                                             + "."
1:ddb2c91:                                             + " See http://activemq.apache.org/producer-flow-control.html for more info");
1:d4d9ba8:                         }
1:d83969f:                     }
1:cdc2fd3: 
1:cdc2fd3:                     // The usage manager could have delayed us by the time
1:cdc2fd3:                     // we unblock the message could have expired..
1:cdc2fd3:                     if (message.isExpired()) {
1:c6a485f:                         getDestinationStatistics().getExpired().increment();
1:e1bbde7:                         LOG.debug("Expired message: {}", message);
1:cdc2fd3:                         return;
1:cdc2fd3:                     }
1:d83969f:                 }
1:ecf89a6:             }
1:230a86c:         }
1:ecf89a6: 
1:9da7e31:         doMessageSend(producerExchange, message);
1:cdc2fd3:         messageDelivered(context, message);
1:9da7e31:         if (sendProducerAck) {
1:9da7e31:             ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
1:9da7e31:             context.getConnection().dispatchAsync(ack);
1:230a86c:         }
1:230a86c:     }
1:230a86c: 
1:569e5ca:     /**
1:48764be:      * do send the message - this needs to be synchronized to ensure messages
1:48764be:      * are stored AND dispatched in the right order
1:b567bd4:      *
1:569e5ca:      * @param producerExchange
1:569e5ca:      * @param message
1:569e5ca:      * @throws IOException
1:569e5ca:      * @throws Exception
1:569e5ca:      */
1:ddb2c91:     synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message)
1:ddb2c91:             throws IOException, Exception {
1:230a86c:         final ConnectionContext context = producerExchange.getConnectionContext();
1:dfcf776:         message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
1:ea84378:         Future<Object> result = null;
1:230a86c: 
1:48764be:         if (topicStore != null && message.isPersistent() && !canOptimizeOutPersistence()) {
1:a0d2282:             if (systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {
1:2b10259:                 final String logMessage = "Persistent store is Full, " + getStoreUsageHighWaterMark() + "% of "
1:ddb2c91:                         + systemUsage.getStoreUsage().getLimit() + ". Stopping producer (" + message.getProducerId()
1:ddb2c91:                         + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
1:48764be:                         + " See http://activemq.apache.org/producer-flow-control.html for more info";
1:8ce0778:                 if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
1:d021e5b:                     throw new javax.jms.ResourceAllocationException(logMessage);
1:ddb2c91:                 }
1:230a86c: 
1:0736953:                 waitForSpace(context,producerExchange, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);
1:230a86c:             }
1:f4d4c3b:             result = topicStore.asyncAddTopicMessage(context, message,isOptimizeStorage());
1:a953f11: 
1:7c3bb40:             //Moved the reduceMemoryfootprint clearing to the dispatch method
1:a953f11:         }
1:230a86c: 
1:d29ca2a:         message.incrementReferenceCount();
1:230a86c: 
1:f472000:         if (context.isInTransaction()) {
1:f472000:             context.getTransaction().addSynchronization(new Synchronization() {
1:ea84378:                 @Override
1:f472000:                 public void afterCommit() throws Exception {
1:f472000:                     // It could take while before we receive the commit
1:fe31092:                     // operation.. by that time the message could have
1:f472000:                     // expired..
1:6cc2c11:                     if (message.isExpired()) {
1:6cc2c11:                         if (broker.isExpired(message)) {
1:6cc2c11:                             getDestinationStatistics().getExpired().increment();
1:6cc2c11:                             broker.messageExpired(context, message, null);
1:6cc2c11:                         }
1:f472000:                         message.decrementReferenceCount();
1:f472000:                         return;
1:9da7e31:                     }
1:f472000:                     try {
1:f472000:                         dispatch(context, message);
1:f472000:                     } finally {
1:f472000:                         message.decrementReferenceCount();
1:f472000:                     }
1:f472000:                 }
1:c5c1495: 
1:c5c1495:                 @Override
1:c5c1495:                 public void afterRollback() throws Exception {
1:c5c1495:                     message.decrementReferenceCount();
1:c5c1495:                 }
1:f472000:             });
1:f472000: 
1:f472000:         } else {
1:f472000:             try {
2:d29ca2a:                 dispatch(context, message);
1:f472000:             } finally {
1:f472000:                 message.decrementReferenceCount();
1:230a86c:             }
1:230a86c:         }
1:b567bd4: 
1:ea84378:         if (result != null && !result.isCancelled()) {
1:ea84378:             try {
1:ddb2c91:                 result.get();
1:ddb2c91:             } catch (CancellationException e) {
1:ddb2c91:                 // ignore - the task has been cancelled if the message
1:ddb2c91:                 // has already been deleted
1:ea84378:             }
1:ea84378:         }
1:230a86c:     }
1:9da7e31: 
1:04968b6:     private boolean canOptimizeOutPersistence() {
1:a5eb7c6:         return durableSubscribers.size() == 0;
1:a59cd03:     }
1:9da7e31: 
1:3039b67:     @Override
1:d29ca2a:     public String toString() {
1:d29ca2a:         return "Topic: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size();
1:a59cd03:     }
1:230a86c: 
1:3039b67:     @Override
1:ddb2c91:     public void acknowledge(ConnectionContext context, Subscription sub, final MessageAck ack,
1:ddb2c91:             final MessageReference node) throws IOException {
1:8d11f07:         if (topicStore != null && node.isPersistent()) {
1:d29ca2a:             DurableTopicSubscription dsub = (DurableTopicSubscription) sub;
1:23cda2d:             SubscriptionKey key = dsub.getSubscriptionKey();
1:b07f31e:             topicStore.acknowledge(context, key.getClientId(), key.getSubscriptionName(), node.getMessageId(),
1:b07f31e:                     convertToNonRangedAck(ack, node));
1:a59cd03:         }
1:cdc2fd3:         messageConsumed(context, node);
1:a59cd03:     }
1:63e3f41: 
1:3039b67:     @Override
1:d29ca2a:     public void gc() {
1:a59cd03:     }
1:230a86c: 
1:d29ca2a:     public Message loadMessage(MessageId messageId) throws IOException {
1:8d11f07:         return topicStore != null ? topicStore.getMessage(messageId) : null;
1:a59cd03:     }
1:230a86c: 
1:3039b67:     @Override
1:d29ca2a:     public void start() throws Exception {
1:2769298:         if (started.compareAndSet(false, true)) {
1:2769298:             this.subscriptionRecoveryPolicy.start();
1:2769298:             if (memoryUsage != null) {
1:2769298:                 memoryUsage.start();
1:2769298:             }
1:14c605f: 
1:2769298:             if (getExpireMessagesPeriod() > 0 && !AdvisorySupport.isAdvisoryTopic(getActiveMQDestination())) {
1:2769298:                 scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
1:2769298:             }
1:14c605f:         }
1:a59cd03:     }
1:230a86c: 
1:3039b67:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:2769298:         if (started.compareAndSet(true, false)) {
1:2769298:             if (taskRunner != null) {
1:2769298:                 taskRunner.shutdown();
1:2769298:             }
1:2769298:             this.subscriptionRecoveryPolicy.stop();
1:2769298:             if (memoryUsage != null) {
1:2769298:                 memoryUsage.stop();
1:2769298:             }
1:2769298:             if (this.topicStore != null) {
1:2769298:                 this.topicStore.stop();
1:2769298:             }
1:2748ae1: 
1:2769298:             scheduler.cancel(expireMessagesTask);
1:2769298:         }
1:63e3f41:     }
1:2748ae1: 
1:3039b67:     @Override
1:230a86c:     public Message[] browse() {
1:383a7ac:         final List<Message> result = new ArrayList<Message>();
1:383a7ac:         doBrowse(result, getMaxBrowsePageSize());
1:ecf89a6:         return result.toArray(new Message[result.size()]);
1:14c605f:     }
1:9dd11cb: 
1:383a7ac:     private void doBrowse(final List<Message> browseList, final int max) {
1:230a86c:         try {
1:8d11f07:             if (topicStore != null) {
1:9c9b856:                 final List<Message> toExpire = new ArrayList<Message>();
1:8d11f07:                 topicStore.recover(new MessageRecoveryListener() {
1:3039b67:                     @Override
1:230a86c:                     public boolean recoverMessage(Message message) throws Exception {
1:230a86c:                         if (message.isExpired()) {
1:9c9b856:                             toExpire.add(message);
1:2748ae1:                         }
1:383a7ac:                         browseList.add(message);
1:3bf0245:                         return true;
1:2748ae1:                     }
1:2748ae1: 
1:3039b67:                     @Override
1:230a86c:                     public boolean recoverMessageReference(MessageId messageReference) throws Exception {
1:3bf0245:                         return true;
1:2748ae1:                     }
1:230a86c: 
1:3039b67:                     @Override
1:230a86c:                     public boolean hasSpace() {
1:383a7ac:                         return browseList.size() < max;
1:2748ae1:                     }
1:230a86c: 
1:3039b67:                     @Override
1:132f662:                     public boolean isDuplicate(MessageId id) {
1:132f662:                         return false;
1:2748ae1:                     }
1:b792f11:                 });
1:ed3f61a:                 final ConnectionContext connectionContext = createConnectionContext();
1:9c9b856:                 for (Message message : toExpire) {
1:a5eb7c6:                     for (DurableTopicSubscription sub : durableSubscribers.values()) {
1:b78867e:                         if (!sub.isActive()) {
1:67ae2bd:                             message.setRegionDestination(this);
1:b78867e:                             messageExpired(connectionContext, sub, message);
1:a59cd03:                         }
1:a59cd03:                     }
1:a59cd03:                 }
1:230a86c:                 Message[] msgs = subscriptionRecoveryPolicy.browse(getActiveMQDestination());
1:230a86c:                 if (msgs != null) {
1:383a7ac:                     for (int i = 0; i < msgs.length && browseList.size() < max; i++) {
1:383a7ac:                         browseList.add(msgs[i]);
1:a59cd03:                     }
1:a59cd03:                 }
1:a58d36b:             }
1:230a86c:         } catch (Throwable e) {
1:e1bbde7:             LOG.warn("Failed to browse Topic: {}", getActiveMQDestination().getPhysicalName(), e);
1:a58d36b:         }
1:a58d36b:     }
1:230a86c: 
1:3039b67:     @Override
1:9dd11cb:     public boolean iterate() {
1:ecf89a6:         synchronized (messagesWaitingForSpace) {
1:e7316df:             while (!memoryUsage.isFull() && !messagesWaitingForSpace.isEmpty()) {
1:e7316df:                 Runnable op = messagesWaitingForSpace.removeFirst();
1:e7316df:                 op.run();
1:e7316df:             }
1:9dd11cb: 
1:e0c5024:             if (!messagesWaitingForSpace.isEmpty()) {
1:e0c5024:                 registerCallbackForNotFullNotification();
1:9dd11cb:             }
1:9dd11cb:         }
1:9dd11cb:         return false;
1:ecf89a6:     }
1:ecf89a6: 
1:e0c5024:     private void registerCallbackForNotFullNotification() {
1:e0c5024:         // If the usage manager is not full, then the task will not
1:cdc2fd3:         // get called..
1:cdc2fd3:         if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
1:cdc2fd3:             // so call it directly here.
1:cdc2fd3:             sendMessagesWaitingForSpaceTask.run();
1:ecf89a6:         }
1:230a86c:     }
1:230a86c: 
1:d29ca2a:     // Properties
1:d29ca2a:     // -------------------------------------------------------------------------
1:8d11f07: 
1:d29ca2a:     public DispatchPolicy getDispatchPolicy() {
1:d29ca2a:         return dispatchPolicy;
1:230a86c:     }
1:230a86c: 
1:d29ca2a:     public void setDispatchPolicy(DispatchPolicy dispatchPolicy) {
1:d29ca2a:         this.dispatchPolicy = dispatchPolicy;
1:a59cd03:     }
9:230a86c: 
1:d29ca2a:     public SubscriptionRecoveryPolicy getSubscriptionRecoveryPolicy() {
1:d29ca2a:         return subscriptionRecoveryPolicy;
1:a59cd03:     }
1:230a86c: 
1:bcb60a4:     public void setSubscriptionRecoveryPolicy(SubscriptionRecoveryPolicy recoveryPolicy) {
1:bcb60a4:         if (this.subscriptionRecoveryPolicy != null && this.subscriptionRecoveryPolicy instanceof RetainedMessageSubscriptionRecoveryPolicy) {
1:bcb60a4:             // allow users to combine retained message policy with other ActiveMQ policies
1:bcb60a4:             RetainedMessageSubscriptionRecoveryPolicy policy = (RetainedMessageSubscriptionRecoveryPolicy) this.subscriptionRecoveryPolicy;
1:bcb60a4:             policy.setWrapped(recoveryPolicy);
1:bcb60a4:         } else {
1:bcb60a4:             this.subscriptionRecoveryPolicy = recoveryPolicy;
1:bcb60a4:         }
1:a59cd03:     }
1:230a86c: 
1:c2408b8:     // Implementation methods
1:c2408b8:     // -------------------------------------------------------------------------
1:044c07d: 
1:3039b67:     @Override
1:044c07d:     public final void wakeup() {
1:044c07d:     }
1:044c07d: 
1:84eb9f8:     protected void dispatch(final ConnectionContext context, Message message) throws Exception {
1:ddb2c91:         // AMQ-2586: Better to leave this stat at zero than to give the user
1:ddb2c91:         // misleading metrics.
1:02d5728:         // destinationStatistics.getMessages().increment();
1:d29ca2a:         destinationStatistics.getEnqueues().increment();
1:f71e2fe:         destinationStatistics.getMessageSize().addSize(message.getSize());
1:3e2b3d2:         MessageEvaluationContext msgContext = null;
1:b567bd4: 
1:f92d45b:         dispatchLock.readLock().lock();
1:f92d45b:         try {
1:c2408b8:             if (!subscriptionRecoveryPolicy.add(context, message)) {
1:230a86c:                 return;
1:f92d45b:             }
1:230a86c:             synchronized (consumers) {
1:4759253:                 if (consumers.isEmpty()) {
1:4759253:                     onMessageWithNoConsumers(context, message);
1:230a86c:                     return;
1:a59cd03:                 }
1:a59cd03:             }
1:230a86c: 
1:7c3bb40:             // Clear memory before dispatch - need to clear here because the call to
1:7c3bb40:             //subscriptionRecoveryPolicy.add() will unmarshall the state
1:7c3bb40:             if (isReduceMemoryFootprint() && message.isMarshalled()) {
1:7c3bb40:                 message.clearUnMarshalledState();
1:7c3bb40:             }
1:7c3bb40: 
1:3e2b3d2:             msgContext = context.getMessageEvaluationContext();
2:d29ca2a:             msgContext.setDestination(destination);
1:0f502fa:             msgContext.setMessageReference(message);
1:6895d00:             if (!dispatchPolicy.dispatch(message, msgContext, consumers)) {
2:d29ca2a:                 onMessageWithNoConsumers(context, message);
1:3e2b3d2:             }
1:230a86c: 
1:230a86c:         } finally {
1:b567bd4:             dispatchLock.readLock().unlock();
1:48764be:             if (msgContext != null) {
1:3e2b3d2:                 msgContext.clear();
1:3e2b3d2:             }
1:a59cd03:         }
1:18d616c:     }
1:293a698: 
1:cdb38b3:     private final AtomicBoolean expiryTaskInProgress = new AtomicBoolean(false);
1:cdb38b3:     private final Runnable expireMessagesWork = new Runnable() {
1:3039b67:         @Override
2:230a86c:         public void run() {
1:383a7ac:             List<Message> browsedMessages = new InsertionCountList<Message>();
1:383a7ac:             doBrowse(browsedMessages, getMaxExpirePageSize());
1:cdb38b3:             expiryTaskInProgress.set(false);
1:cdb38b3:         }
1:cdb38b3:     };
1:cdb38b3:     private final Runnable expireMessagesTask = new Runnable() {
1:cdb38b3:         @Override
1:cdb38b3:         public void run() {
1:cdb38b3:             if (expiryTaskInProgress.compareAndSet(false, true)) {
1:cdb38b3:                 taskRunnerFactor.execute(expireMessagesWork);
1:cdb38b3:             }
10:0f502fa:         }
1:ecf89a6:     };
1:230a86c: 
1:3039b67:     @Override
1:48764be:     public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {
1:27c1719:         broker.messageExpired(context, reference, subs);
1:ddb2c91:         // AMQ-2586: Better to leave this stat at zero than to give the user
1:ddb2c91:         // misleading metrics.
1:02d5728:         // destinationStatistics.getMessages().decrement();
1:c6a485f:         destinationStatistics.getExpired().increment();
1:0d85869:         MessageAck ack = new MessageAck();
1:0d85869:         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
1:0d85869:         ack.setDestination(destination);
1:0d85869:         ack.setMessageID(reference.getMessageId());
1:0d85869:         try {
1:ed3f61a:             if (subs instanceof DurableTopicSubscription) {
1:ed3f61a:                 ((DurableTopicSubscription)subs).removePending(reference);
1:0f502fa:             }
1:0d85869:             acknowledge(context, subs, ack, reference);
1:230a86c:         } catch (Exception e) {
1:48764be:             LOG.error("Failed to remove expired Message from the store ", e);
1:0d85869:         }
1:0d85869:     }
1:ddb2c91: 
1:a0d2282:     @Override
1:8bf987b:     protected Logger getLog() {
1:a0d2282:         return LOG;
1:0f502fa:     }
1:f4d4c3b: 
1:f4d4c3b:     protected boolean isOptimizeStorage(){
1:f4d4c3b:         boolean result = false;
1:f4d4c3b: 
1:a5eb7c6:         if (isDoOptimzeMessageStorage() && durableSubscribers.isEmpty()==false){
1:f4d4c3b:                 result = true;
1:a5eb7c6:                 for (DurableTopicSubscription s : durableSubscribers.values()) {
1:f4d4c3b:                     if (s.isActive()== false){
1:f4d4c3b:                         result = false;
1:f4d4c3b:                         break;
1:f4d4c3b:                     }
1:f4d4c3b:                     if (s.getPrefetchSize()==0){
1:f4d4c3b:                         result = false;
1:f4d4c3b:                         break;
1:f4d4c3b:                     }
1:f4d4c3b:                     if (s.isSlowConsumer()){
1:f4d4c3b:                         result = false;
1:f4d4c3b:                         break;
1:f4d4c3b:                     }
1:ca83305:                     if (s.getInFlightUsage() > getOptimizeMessageStoreInFlightLimit()){
1:f4d4c3b:                         result = false;
1:f4d4c3b:                         break;
1:f4d4c3b:                     }
1:f4d4c3b:                 }
1:f4d4c3b:         }
1:f4d4c3b:         return result;
1:0ee0cb9:     }
1:230a86c: 
1:04968b6:     /**
1:64f3492:      * force a reread of the store - after transaction recovery completion
1:ea70e82:      * @param pendingAdditionsCount
1:04968b6:      */
1:3039b67:     @Override
1:ea70e82:     public void clearPendingMessages(int pendingAdditionsCount) {
1:b567bd4:         dispatchLock.readLock().lock();
1:0f502fa:         try {
1:f92d45b:             for (DurableTopicSubscription durableTopicSubscription : durableSubscribers.values()) {
2:64f3492:                 clearPendingAndDispatch(durableTopicSubscription);
1:f92d45b:             }
1:f92d45b:         } finally {
1:f92d45b:             dispatchLock.readLock().unlock();
1:f92d45b:         }
1:f4d4c3b:     }
1:f92d45b: 
1:64f3492:     private void clearPendingAndDispatch(DurableTopicSubscription durableTopicSubscription) {
1:64f3492:         synchronized (durableTopicSubscription.pendingLock) {
1:64f3492:             durableTopicSubscription.pending.clear();
1:0f502fa:             try {
1:64f3492:                 durableTopicSubscription.dispatchPending();
1:64f3492:             } catch (IOException exception) {
1:e1bbde7:                 LOG.warn("After clear of pending, failed to dispatch to: {}, for: {}, pending: {}", new Object[]{
1:e1bbde7:                         durableTopicSubscription,
1:e1bbde7:                         destination,
1:e1bbde7:                         durableTopicSubscription.pending }, exception);
1:f4d4c3b:             }
1:0f502fa:         }
1:0f502fa:     }
1:230a86c: 
1:64f3492:     public Map<SubscriptionKey, DurableTopicSubscription> getDurableTopicSubs() {
1:a5eb7c6:         return durableSubscribers;
1:0f502fa:     }
1:0f502fa: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:cdb38b3
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     private final TaskRunnerFactory taskRunnerFactor;
/////////////////////////////////////////////////////////////////////////
1:         this.taskRunnerFactor = taskFactory;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean expiryTaskInProgress = new AtomicBoolean(false);
1:     private final Runnable expireMessagesWork = new Runnable() {
1:             expiryTaskInProgress.set(false);
1:         }
1:     };
1:     private final Runnable expireMessagesTask = new Runnable() {
1:         @Override
1:         public void run() {
1:             if (expiryTaskInProgress.compareAndSet(false, true)) {
1:                 taskRunnerFactor.execute(expireMessagesWork);
1:             }
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1:      * @param pendingAdditionsCount
1:     public void clearPendingMessages(int pendingAdditionsCount) {
commit:0608175
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("{}, Usage Manager memory limit reached {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:                             getActiveMQDestination().getQualifiedName(), memoryUsage.getLimit());
1:                 } else {
1:                     LOG.debug("{}, Usage Manager memory limit reached {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
commit:01b1f7f
/////////////////////////////////////////////////////////////////////////
1:                 if (isFlowControlLogRequired()) {
commit:d86c98a
/////////////////////////////////////////////////////////////////////////
1:             boolean removed = false;
1:                 removed = consumers.remove(sub);
1:             }
1:             if (removed) {
1:                 super.removeSubscription(context, sub, lastDeliveredSequenceId);
commit:6cc2c11
/////////////////////////////////////////////////////////////////////////
1:                     if (message.isExpired()) {
1:                         if (broker.isExpired(message)) {
1:                             getDestinationStatistics().getExpired().increment();
1:                             broker.messageExpired(context, message, null);
1:                         }
commit:67ae2bd
/////////////////////////////////////////////////////////////////////////
1:                             message.setRegionDestination(this);
commit:179dc3a
/////////////////////////////////////////////////////////////////////////
1:         message.setRegionDestination(this);
1: 
/////////////////////////////////////////////////////////////////////////
commit:9ad65c6
/////////////////////////////////////////////////////////////////////////
1:         subscriptionRecoveryPolicy = new RetainedMessageSubscriptionRecoveryPolicy(null);
1:         // set non default subscription recovery policy (override policyEntries)
1:         if (AdvisorySupport.isMasterBrokerAdvisoryTopic(destination)) {
1:             subscriptionRecoveryPolicy = new LastImageSubscriptionRecoveryPolicy();
1:             setAlwaysRetroactive(true);
1:         }
commit:dbb1d8b
/////////////////////////////////////////////////////////////////////////
1:                 removed.deactivate(false, 0l);
commit:c5c1495
/////////////////////////////////////////////////////////////////////////
1: 
1:                 @Override
1:                 public void afterRollback() throws Exception {
1:                     message.decrementReferenceCount();
1:                 }
commit:f92d45b
/////////////////////////////////////////////////////////////////////////
0:     private void rollback(MessageId poisoned) {
1:         dispatchLock.readLock().lock();
1:         try {
1:             for (DurableTopicSubscription durableTopicSubscription : durableSubscribers.values()) {
0:                 durableTopicSubscription.getPending().rollback(poisoned);
1:             }
1:         } finally {
1:             dispatchLock.readLock().unlock();
1:         }
1:     }
1: 
commit:a64976a
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("{}, Usage Manager memory limit reached {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.",
1:                             getActiveMQDestination().getQualifiedName(), memoryUsage.getLimit());
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:2769298
/////////////////////////////////////////////////////////////////////////
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (started.compareAndSet(false, true)) {
1:             this.subscriptionRecoveryPolicy.start();
1:             if (memoryUsage != null) {
1:                 memoryUsage.start();
1:             }
1:             if (getExpireMessagesPeriod() > 0 && !AdvisorySupport.isAdvisoryTopic(getActiveMQDestination())) {
1:                 scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
1:             }
1:         if (started.compareAndSet(true, false)) {
1:             if (taskRunner != null) {
1:                 taskRunner.shutdown();
1:             }
1:             this.subscriptionRecoveryPolicy.stop();
1:             if (memoryUsage != null) {
1:                 memoryUsage.stop();
1:             }
1:             if (this.topicStore != null) {
1:                 this.topicStore.stop();
1:             }
1:             scheduler.cancel(expireMessagesTask);
1:         }
commit:7c3bb40
/////////////////////////////////////////////////////////////////////////
1:             //Moved the reduceMemoryfootprint clearing to the dispatch method
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Clear memory before dispatch - need to clear here because the call to
1:             //subscriptionRecoveryPolicy.add() will unmarshall the state
1:             if (isReduceMemoryFootprint() && message.isMarshalled()) {
1:                 message.clearUnMarshalledState();
1:             }
1: 
commit:18571ce
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.NoLocalSubscriptionAware;
1: import org.apache.activemq.store.PersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
1:     private boolean hasDurableSubChanged(SubscriptionInfo info1, ConsumerInfo info2) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     private boolean hasNoLocalChanged(SubscriptionInfo info1, ConsumerInfo info2) throws IOException {
1:         //Not all persistence adapters store the noLocal value for a subscription
1:         PersistenceAdapter adapter = broker.getBrokerService().getPersistenceAdapter();
1:         if (adapter instanceof NoLocalSubscriptionAware) {
commit:a953f11
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (isReduceMemoryFootprint()) {
0:                 message.clearMarshalledState();
1:             }
commit:11622b3
/////////////////////////////////////////////////////////////////////////
commit:b9b98a4
/////////////////////////////////////////////////////////////////////////
0:             message.beforeMarshall(null);
commit:785b16b
/////////////////////////////////////////////////////////////////////////
1:             store.start();
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:81b4b9a
/////////////////////////////////////////////////////////////////////////
1:         if (hasSelectorChanged(info1, info2)) {
1:             return true;
1:         }
1: 
1:         return hasNoLocalChanged(info1, info2);
1:     }
1: 
0:     private boolean hasNoLocalChanged(SubscriptionInfo info1, ConsumerInfo info2) {
0:         // Prior to V11 the broker did not store the noLocal value for durable subs.
0:         if (brokerService.getStoreOpenWireVersion() >= 11) {
1:             if (info1.isNoLocal() ^ info2.isNoLocal()) {
1:                 return true;
1:             }
1:         }
1: 
1:         return false;
1:     }
1: 
1:     private boolean hasSelectorChanged(SubscriptionInfo info1, ConsumerInfo info2) {
1: 
/////////////////////////////////////////////////////////////////////////
1:                     // Force a rebuild of the selector chain for the subscription otherwise
1:                     // the stored subscription is updated but the selector expression is not
1:                     // and the subscription will not behave according to the new configuration.
1:                     subscription.setSelector(subscription.getConsumerInfo().getSelector());
commit:833d308
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerInfo;
/////////////////////////////////////////////////////////////////////////
0:     private boolean hasDurableSubChanged(SubscriptionInfo info1, ConsumerInfo info2) {
1:         if (info1.getSelector() != null ^ info2.getSelector() != null) {
1:             return true;
1:         }
1:         if (info1.getSelector() != null && !info1.getSelector().equals(info2.getSelector())) {
1:             return true;
1:         }
1: 
1:         return false;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (hasDurableSubChanged(info, subscription.getConsumerInfo())) {
/////////////////////////////////////////////////////////////////////////
1:                 info.setSelector(subscription.getConsumerInfo().getSelector());
1:                 info.setNoLocal(subscription.getConsumerInfo().isNoLocal());
/////////////////////////////////////////////////////////////////////////
commit:16a1e2b
/////////////////////////////////////////////////////////////////////////
0:         if (getExpireMessagesPeriod() > 0 && !AdvisorySupport.isAdvisoryTopic(getActiveMQDestination())) {
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<SubscriptionKey, DurableTopicSubscription> durableSubscribers = new ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription>();
commit:106f759
/////////////////////////////////////////////////////////////////////////
0:             scheduler.executePeriodically(expireMessagesTask, getExpireMessagesPeriod());
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                             LOG.error("Failed to recover this message {}", message, e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("{}, Usage Manager memory limit reached for {}. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info.", getActiveMQDestination().getQualifiedName());
/////////////////////////////////////////////////////////////////////////
1:                                     LOG.warn("Waiting for space to send transacted message - transaction elements = {} need more space to commit. Message = {}", size, message);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Expired message: {}", message);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to browse Topic: {}", getActiveMQDestination().getPhysicalName(), e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("After clear of pending, failed to dispatch to: {}, for: {}, pending: {}", new Object[]{
1:                         durableTopicSubscription,
1:                         destination,
1:                         durableTopicSubscription.pending }, exception);
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:a581d01
/////////////////////////////////////////////////////////////////////////
1:     public void recoverRetroactiveMessages(ConnectionContext context, Subscription subscription) throws Exception {
commit:bcb60a4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
0:             subscriptionRecoveryPolicy = new RetainedMessageSubscriptionRecoveryPolicy(null);
/////////////////////////////////////////////////////////////////////////
1:     public void setSubscriptionRecoveryPolicy(SubscriptionRecoveryPolicy recoveryPolicy) {
1:         if (this.subscriptionRecoveryPolicy != null && this.subscriptionRecoveryPolicy instanceof RetainedMessageSubscriptionRecoveryPolicy) {
1:             // allow users to combine retained message policy with other ActiveMQ policies
1:             RetainedMessageSubscriptionRecoveryPolicy policy = (RetainedMessageSubscriptionRecoveryPolicy) this.subscriptionRecoveryPolicy;
1:             policy.setWrapped(recoveryPolicy);
1:         } else {
1:             this.subscriptionRecoveryPolicy = recoveryPolicy;
1:         }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:c0090f6
/////////////////////////////////////////////////////////////////////////
1:                     topicStore.addSubscription(info, subscription.getConsumerInfo().isRetroactive());
author:Robert Davies
-------------------------------------------------------------------------------
commit:f71e2fe
/////////////////////////////////////////////////////////////////////////
1:         destinationStatistics.getMessageSize().addSize(message.getSize());
commit:0736953
/////////////////////////////////////////////////////////////////////////
1:         producerExchange.incrementSend();
/////////////////////////////////////////////////////////////////////////
1:                                     producerExchange,
/////////////////////////////////////////////////////////////////////////
1:                 waitForSpace(context,producerExchange, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);
commit:144dda0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     boolean applyRecovery = false;
1:                         if (!consumers.contains(sub)){
1:                             sub.add(context, this);
1:                             consumers.add(sub);
1:                             applyRecovery=true;
1:                             super.addSubscription(context, sub);
1:                         }
1:                     if (applyRecovery){
1:                         subscriptionRecoveryPolicy.recover(context, this, sub);
1:                     }
1:                     if (!consumers.contains(sub)){
1:                         sub.add(context, this);
1:                         consumers.add(sub);
1:                         super.addSubscription(context, sub);
1:                     }
1:             super.addSubscription(context, sub);
commit:0ee0cb9
/////////////////////////////////////////////////////////////////////////
1:     		sub.add(context, this);
1:     		if(dsub.isActive()) {
1: 	        	synchronized (consumers) {
1: 	        		boolean hasSubscription = false;
1: 	
0: 	        		if(consumers.size()==0) {
1: 	            		hasSubscription = false;
1: 	        		} else {
0: 		        		for(Subscription currentSub : consumers) {
0: 		        			if(currentSub.getConsumerInfo().isDurable()) {
1: 		        	            DurableTopicSubscription dcurrentSub = (DurableTopicSubscription) currentSub;
0: 		        	            if(dcurrentSub.getSubscriptionKey().equals(dsub.getSubscriptionKey())) {
1: 		        	            	hasSubscription = true;
1: 		        	            	break;
1: 		        	            }
1: 		        			}
1: 		        		}
1: 	        		}
1: 	        		
0: 	                if(!hasSubscription)
1: 	                	consumers.add(sub);
1: 	            }
1:     		}
/////////////////////////////////////////////////////////////////////////
1: }
commit:ca83305
/////////////////////////////////////////////////////////////////////////
1:                     if (s.getInFlightUsage() > getOptimizeMessageStoreInFlightLimit()){
commit:f4d4c3b
/////////////////////////////////////////////////////////////////////////
1:             result = topicStore.asyncAddTopicMessage(context, message,isOptimizeStorage());
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected boolean isOptimizeStorage(){
1:         boolean result = false;
1: 
0:         if (isDoOptimzeMessageStorage() && durableSubcribers.isEmpty()==false){
1:                 result = true;
0:                 for (DurableTopicSubscription s : durableSubcribers.values()) {
1:                     if (s.isActive()== false){
1:                         result = false;
1:                         break;
1:                     }
1:                     if (s.getPrefetchSize()==0){
1:                         result = false;
1:                         break;
1:                     }
1:                     if (s.isSlowConsumer()){
1:                         result = false;
1:                         break;
1:                     }
0:                     if (s.getInFlightUsage() > 10){
1:                         result = false;
1:                         break;
1:                     }
1:                 }
1:         }
1:         return result;
1:     }
1: }
commit:2705e36
/////////////////////////////////////////////////////////////////////////
0:        super.addSubscription(context, sub);
/////////////////////////////////////////////////////////////////////////
0:             super.removeSubscription(context, sub, lastDeliveredSequenceId);
commit:ddb2c91
/////////////////////////////////////////////////////////////////////////
1:     public Topic(BrokerService brokerService, ActiveMQDestination destination, TopicMessageStore store,
1:             DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Exception {
0:         // set default subscription recovery policy
/////////////////////////////////////////////////////////////////////////
1:             // AMQ-2586: Better to leave this stat at zero than to give the user
1:             // misleading metrics.
/////////////////////////////////////////////////////////////////////////
0:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId)
0:             throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             }
/////////////////////////////////////////////////////////////////////////
1:         final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0
1:                 && !context.isInRecoveryMode();
/////////////////////////////////////////////////////////////////////////
0:                     LOG
0:                             .info("Usage Manager memory limit ("
0:                                     + memoryUsage.getLimit()
0:                                     + ") reached for "
1:                                     + getActiveMQDestination().getQualifiedName()
0:                                     + ". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it."
1:                                     + " See http://activemq.apache.org/producer-flow-control.html for more info");
1:                     throw new javax.jms.ResourceAllocationException("Usage Manager memory limit ("
0:                             + memoryUsage.getLimit() + ") reached. Stopping producer (" + message.getProducerId()
1:                             + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
1:                             + " See http://activemq.apache.org/producer-flow-control.html for more info");
0:                 // We can avoid blocking due to low usage if the producer is
0:                 // sending
/////////////////////////////////////////////////////////////////////////
1:                                         ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message
1:                                                 .getSize());
/////////////////////////////////////////////////////////////////////////
0:                         // If the user manager is not full, then the task will
0:                         // not
/////////////////////////////////////////////////////////////////////////
0:                     // Producer flow control cannot be used, so we have do the
0:                     // flow
1: 
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.warn("Waiting for space to send  transacted message - transaction elements = "
0:                                             + size + " need more space to commit. Message = " + message);
1:                             waitForSpace(
1:                                     context,
1:                                     memoryUsage,
0:                                     "Usage Manager memory limit reached. Stopping producer ("
1:                                             + message.getProducerId()
1:                                             + ") to prevent flooding "
0:                                             + getActiveMQDestination().getQualifiedName()
1:                                             + "."
0:                                             + " See http://activemq.apache.org/producer-flow-control.html for more info");
/////////////////////////////////////////////////////////////////////////
1:     synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message)
1:             throws IOException, Exception {
/////////////////////////////////////////////////////////////////////////
0:                 final String logMessage = "Usage Manager Store is Full, " + getStoreUsageHighWaterMark() + "% of "
1:                         + systemUsage.getStoreUsage().getLimit() + ". Stopping producer (" + message.getProducerId()
1:                         + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
1:             }
0:             result = topicStore.asyncAddTopicMessage(context, message);
/////////////////////////////////////////////////////////////////////////
0:                 public void beforeCommit() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                 result.get();
1:             } catch (CancellationException e) {
1:                 // ignore - the task has been cancelled if the message
1:                 // has already been deleted
/////////////////////////////////////////////////////////////////////////
1:     public void acknowledge(ConnectionContext context, Subscription sub, final MessageAck ack,
1:             final MessageReference node) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         // AMQ-2586: Better to leave this stat at zero than to give the user
1:         // misleading metrics.
/////////////////////////////////////////////////////////////////////////
1:         // AMQ-2586: Better to leave this stat at zero than to give the user
1:         // misleading metrics.
/////////////////////////////////////////////////////////////////////////
1: 
commit:1999d94
/////////////////////////////////////////////////////////////////////////
0:             result = topicStore.asyncAddTopicMessage(context, message);      
commit:27262c8
/////////////////////////////////////////////////////////////////////////
1:                 // deactivate and remove
0:                 removed.deactivate(false);
1:                 consumers.remove(removed);
1:             }         
/////////////////////////////////////////////////////////////////////////
0:             topicStore.asyncAddTopicMessage(context, message);      
commit:ea84378
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CancellationException;
1: import java.util.concurrent.Future;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         Future<Object> result = null;
/////////////////////////////////////////////////////////////////////////
1:             if (context.isInTransaction()) {
0:                 topicStore.addMessage(context, message);
0:             }else {
0:                 result = topicStore.asyncAddTopicMessage(context, message);
1:             }      
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:         if (result != null && !result.isCancelled()) {
1:             try {
0:             result.get();
0:             }catch(CancellationException e) {
0:               //ignore - the task has been cancelled if the message
0:               // has already been deleted
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:1e7881f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.LinkedList;
1: import java.util.List;
0: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
0:         subscriptionRecoveryPolicy= new NoSubscriptionRecoveryPolicy();
commit:63e3f41
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
0:         if(this.topicStore != null) {
0:             this.topicStore.stop();
1:         }
commit:3e2b3d2
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedList;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         dispatchValve.increment();   
1:         MessageEvaluationContext msgContext = null;
/////////////////////////////////////////////////////////////////////////
1:             msgContext = context.getMessageEvaluationContext();
1:             }  
0:             if(msgContext != null) {
1:                 msgContext.clear();
1:             }
commit:c8bd57c
/////////////////////////////////////////////////////////////////////////
0:                            LOG.error("Failed to recover this message " + message);
/////////////////////////////////////////////////////////////////////////
commit:0d85869
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (message.isExpired()) {
/////////////////////////////////////////////////////////////////////////
1:                                     if (message.isExpired()) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void messageExpired(ConnectionContext context,Subscription subs, MessageReference reference) {
0:         broker.messageExpired(context, reference);
0:         destinationStatistics.getMessages().decrement();
0:         destinationStatistics.getEnqueues().decrement();
1:         MessageAck ack = new MessageAck();
1:         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
1:         ack.setDestination(destination);
1:         ack.setMessageID(reference.getMessageId());
1:         try {
1:             acknowledge(context, subs, ack, reference);
1:         } catch (IOException e) {
0:             LOG.error("Failed to remove expired Message from the store ",e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
commit:4b27e76
/////////////////////////////////////////////////////////////////////////
0:         super.dispose(context);
commit:8740340
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.tools.ant.taskdefs.condition.IsFalse;
/////////////////////////////////////////////////////////////////////////
0:         if(memoryUsage.isFull()) {
1:             isFull(context, memoryUsage);
1:             fastProducer(context, producerInfo);
1:             if (isProducerFlowControl() && context.isProducerFlowControl()) {
0:                 if (systemUsage.isSendFailIfNoSpace()) {
0:                     throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached");
1:                 }
1:     
0:                 // We can avoid blocking due to low usage if the producer is sending
0:                 // a sync message or
1:                 // if it is using a producer window
1:                 if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {
1:                     synchronized (messagesWaitingForSpace) {
1:                         messagesWaitingForSpace.add(new Runnable() {
1:                             public void run() {
1:                                 
1:                                 try {
1:     
1:                                     // While waiting for space to free up... the
1:                                     // message may have expired.
0:                                     if (broker.isExpired(message)) {
0:                                         broker.messageExpired(context, message);
0:                                         //destinationStatistics.getEnqueues().increment();
0:                                         //destinationStatistics.getMessages().decrement();
1:                                     } else {
1:                                         doMessageSend(producerExchange, message);
1:                                     }
1:     
1:                                     if (sendProducerAck) {
1:                                         ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
1:                                         context.getConnection().dispatchAsync(ack);
1:                                     } else {
1:                                         Response response = new Response();
1:                                         response.setCorrelationId(message.getCommandId());
1:                                         context.getConnection().dispatchAsync(response);
1:                                     }
1:     
1:                                 } catch (Exception e) {
1:                                     if (!sendProducerAck && !context.isInRecoveryMode()) {
1:                                         ExceptionResponse response = new ExceptionResponse(e);
1:                                         response.setCorrelationId(message.getCommandId());
1:                                         context.getConnection().dispatchAsync(response);
1:                                     }
1:                                 
1:                         });
1:     
0:                         // If the user manager is not full, then the task will not
1:                         // get called..
1:                         if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
1:                             // so call it directly here.
1:                             sendMessagesWaitingForSpaceTask.run();
1:                         context.setDontSendReponse(true);
1:                         return;
1:     
1:                 } else {
1:     
0:                     // Producer flow control cannot be used, so we have do the flow
0:                     // control at the broker
0:                     // by blocking this thread until there is space available.
1:                     int count = 0;
1:                     while (!memoryUsage.waitForSpace(1000)) {
1:                         if (context.getStopping().get()) {
1:                             throw new IOException("Connection closed, send aborted.");
1:                         }
1:                         if (count > 2 && context.isInTransaction()) {
0:                             count =0;
1:                             int size = context.getTransaction().size();
0:                             LOG.warn("Waiting for space to send  transacted message - transaction elements = " + size + " need more space to commit. Message = " + message);
1:                         }
1:     
1:                     // The usage manager could have delayed us by the time
1:                     // we unblock the message could have expired..
1:                     if (message.isExpired()) {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Expired message: " + message);
1:                         }
1:                         return;
1:         messageDelivered(context, message);
/////////////////////////////////////////////////////////////////////////
1:         messageConsumed(context, node);
commit:90c8ded
/////////////////////////////////////////////////////////////////////////
0:             if (isProducerFlowControl() && context.isProducerFlowControl() ) {
0:                 if (systemUsage.isSendFailIfNoSpace() && systemUsage.getStoreUsage().isFull()) {
0:                     throw new javax.jms.ResourceAllocationException("Usage Manager Store is Full");
1:                 }
1:             }
commit:dfcf776
/////////////////////////////////////////////////////////////////////////
1:         message.getMessageId().setBrokerSequenceId(getDestinationSequenceId());
commit:044c07d
/////////////////////////////////////////////////////////////////////////
1:     
1:     public final void wakeup() {
1:     }
1:     
commit:cd54a16
/////////////////////////////////////////////////////////////////////////
0:     protected final Log log;
/////////////////////////////////////////////////////////////////////////
0:         this.log = LogFactory.getLog(getClass().getName() + "." + destination.getPhysicalName());
/////////////////////////////////////////////////////////////////////////
0:                         log.warn("Waiting for space to send  transacted message - transaction elements = " + size + " need more space to commit. Message = " + message);
0:                     if (log.isDebugEnabled()) {
0:                         log.debug("Expired message: " + message);
/////////////////////////////////////////////////////////////////////////
0:             log.warn("Failed to browse Topic: " + getActiveMQDestination().getPhysicalName(), e);
commit:e7316df
/////////////////////////////////////////////////////////////////////////
0:         synchronized(messagesWaitingForSpace) {
1:             while (!memoryUsage.isFull() && !messagesWaitingForSpace.isEmpty()) {
1:                 Runnable op = messagesWaitingForSpace.removeFirst();
1:                 op.run();
1:             }
commit:f6fd249
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3b0afd6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.filter.NonCachedMessageEvaluationContext;
/////////////////////////////////////////////////////////////////////////
1:             final MessageEvaluationContext msgContext = new NonCachedMessageEvaluationContext();
commit:d4382e4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.SimpleDispatchSelector;
/////////////////////////////////////////////////////////////////////////
0:         dispatchValve.increment();      
/////////////////////////////////////////////////////////////////////////
0:             MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
/////////////////////////////////////////////////////////////////////////
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
1:             String clientId = subscription.getSubscriptionKey().getClientId();
1:             String subscriptionName = subscription.getSubscriptionKey().getSubscriptionName();
/////////////////////////////////////////////////////////////////////////
1:             SubscriptionKey key = dsub.getSubscriptionKey();
0:             topicStore.acknowledge(context, key.getClientId(), key.getSubscriptionName(), node.getMessageId());
commit:83c3dca
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void initialize() throws Exception{
1:         if (store != null) {
0:             int messageCount = store.getMessageCount();
0:             destinationStatistics.getMessages().setCount(messageCount);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:                                     //destinationStatistics.getEnqueues().increment();
0:                                     //destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:                         //destinationStatistics.getEnqueues().increment();
0:                         //destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:         destinationStatistics.getMessages().increment();
commit:8d11f07
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final TopicMessageStore topicStore;
0:     protected final Valve dispatchValve = new Valve(true);   
/////////////////////////////////////////////////////////////////////////
1:    
0:         super(broker, store, destination,systemUsage, parentStats);
0:         this.topicStore=store;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (topicStore != null) {
1:             topicStore.deleteSubscription(key.clientId, key.subscriptionName);
/////////////////////////////////////////////////////////////////////////
1:             if (topicStore == null) {
/////////////////////////////////////////////////////////////////////////
1:             SubscriptionInfo info = topicStore.lookupSubscription(clientId, subscriptionName);
1:                     topicStore.deleteSubscription(clientId, subscriptionName);
/////////////////////////////////////////////////////////////////////////
0:                 topicStore.addSubsciption(info,subscription.getConsumerInfo().isRetroactive());
1:                 topicStore.recoverSubscription(clientId, subscriptionName, new MessageRecoveryListener() {
/////////////////////////////////////////////////////////////////////////
0:         if (topicStore != null && message.isPersistent()
0:             topicStore.addMessage(context, message);
/////////////////////////////////////////////////////////////////////////
1:         if (topicStore != null && node.isPersistent()) {
0:             topicStore.acknowledge(context, dsub.getClientId(), dsub.getSubscriptionName(), node.getMessageId());
1:         if (topicStore != null) {
0:             topicStore.removeAllMessages(context);
/////////////////////////////////////////////////////////////////////////
1:         return topicStore != null ? topicStore.getMessage(messageId) : null;
/////////////////////////////////////////////////////////////////////////
0:             if (topicStore != null) {
1:                 topicStore.recover(new MessageRecoveryListener() {
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
commit:634da7a
/////////////////////////////////////////////////////////////////////////
1:    
commit:d4d9ba8
/////////////////////////////////////////////////////////////////////////
0:                 int count = 0;
0:                     if (count > 2 && context.isInTransaction()) {
0:                         count =0;
0:                         int size = context.getTransaction().size();
0:                         LOG.warn("Waiting for space to send  transacted message - transaction elements = " + size + " need more space to commit. Message = " + message);
1:                     }
commit:f472000
/////////////////////////////////////////////////////////////////////////
0:     synchronized void doMessageSend(
0:             final ProducerBrokerExchange producerExchange, final Message message)
0:             throws IOException, Exception {
0:         final ConnectionContext context = producerExchange
0:                 .getConnectionContext();
0:         if (store != null && message.isPersistent()
0:                 && !canOptimizeOutPersistence()) {
/////////////////////////////////////////////////////////////////////////
1:         if (context.isInTransaction()) {
1:             context.getTransaction().addSynchronization(new Synchronization() {
1:                 public void afterCommit() throws Exception {
1:                     // It could take while before we receive the commit
0:                     // operration.. by that time the message could have
1:                     // expired..
0:                     if (broker.isExpired(message)) {
0:                         broker.messageExpired(context, message);
1:                         message.decrementReferenceCount();
0:                         destinationStatistics.getMessages().decrement();
1:                         return;
1:                     try {
1:                         dispatch(context, message);
1:                     } finally {
1:                         message.decrementReferenceCount();
1:                     }
1:                 }
1:             });
1:         } else {
1:             try {
1:             } finally {
1:                 message.decrementReferenceCount();
1: 
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Task;
1: import org.apache.activemq.thread.TaskRunner;
/////////////////////////////////////////////////////////////////////////
0: public class Topic  extends BaseDestination  implements Task{
/////////////////////////////////////////////////////////////////////////
1:     private final TaskRunner taskRunner;
1:                 try {
1:                     Topic.this.taskRunner.wakeup();
1:                 } catch (InterruptedException e) {
0:                  TaskRunnerFactory taskFactory) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         } 
1:         this.taskRunner = taskFactory.createTaskRunner(this, "Topic  " + destination.getPhysicalName());
/////////////////////////////////////////////////////////////////////////
0:         if (taskRunner != null) {
0:             taskRunner.shutdown();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean iterate() {
0:         while (!memoryUsage.isFull() && !messagesWaitingForSpace.isEmpty()) {
0:             Runnable op = messagesWaitingForSpace.removeFirst();
0:             op.run();
1:         }
1:         return false;
1:     }
1: 
commit:569e5ca
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * do send the message - this needs to be synchronized to ensure messages are stored AND dispatched in 
0:      * the right order
1:      * @param producerExchange
1:      * @param message
1:      * @throws IOException
1:      * @throws Exception
1:      */
0:     synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
commit:2cb2119
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.state.ProducerState;
/////////////////////////////////////////////////////////////////////////
0:                         producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
commit:0da68b4
/////////////////////////////////////////////////////////////////////////
0: public class Topic  extends BaseDestination {
/////////////////////////////////////////////////////////////////////////
0:         if (isProducerFlowControl() && context.isProducerFlowControl() && memoryUsage.isFull()) {
commit:5f8c101
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
1:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
0:         //set default subscription recovery policy
0:         if (destination.isTemporary() || AdvisorySupport.isAdvisoryTopic(destination) ){
0:         	 subscriptionRecoveryPolicy= new NoSubscriptionRecoveryPolicy();
0:         }else{
0:         	//set the default
0:         	subscriptionRecoveryPolicy= new FixedSizedSubscriptionRecoveryPolicy();
1:         }
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.usage.MemoryUsage;
0: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     private final SystemUsage systemUsage;
0:     private final MemoryUsage memoryUsage;
/////////////////////////////////////////////////////////////////////////
0:                 while (!memoryUsage.isFull() && !messagesWaitingForSpace.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:     public Topic(Broker broker, ActiveMQDestination destination, TopicMessageStore store, SystemUsage systemUsage, DestinationStatistics parentStats,
0:         this.systemUsage=systemUsage;
0:         this.memoryUsage = new MemoryUsage(systemUsage.getMemoryUsage(), destination.toString());
0:         this.memoryUsage.setUsagePortion(1.0f);
0:             store.setMemoryUsage(memoryUsage);
/////////////////////////////////////////////////////////////////////////
0:             if(info==null){
0:                 info=new SubscriptionInfo();
1:                 info.setDestination(getActiveMQDestination()); 
0:                 // Thi destination is an actual destination id.
1:                 info.setSubscribedDestination(subscription.getConsumerInfo().getDestination()); 
1:                 // This destination might be a pattern
0:                 store.addSubsciption(info,subscription.getConsumerInfo().isRetroactive());
/////////////////////////////////////////////////////////////////////////
0:         if (context.isProducerFlowControl() && memoryUsage.isFull()) {
0:             if (systemUsage.isSendFailIfNoSpace()) {
/////////////////////////////////////////////////////////////////////////
0:                     if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
/////////////////////////////////////////////////////////////////////////
0:                 while (!memoryUsage.waitForSpace(1000)) {
/////////////////////////////////////////////////////////////////////////
0:             systemUsage.getStoreUsage().waitForSpace();
/////////////////////////////////////////////////////////////////////////
0:         if (memoryUsage != null) {
0:             memoryUsage.start();
0:         if (memoryUsage != null) {
0:             memoryUsage.stop();
/////////////////////////////////////////////////////////////////////////
0:     public MemoryUsage getBrokerMemoryUsage() {
0:         return memoryUsage;
commit:a401575
/////////////////////////////////////////////////////////////////////////
0:     	if( broker.isExpired(message) ) {
/////////////////////////////////////////////////////////////////////////
0:         			        if(broker.isExpired(message)){
/////////////////////////////////////////////////////////////////////////
0:                     	if(broker.isExpired(message) ) {
commit:3a5f48d
/////////////////////////////////////////////////////////////////////////
0:                     public boolean recoverMessage(Message message) throws Exception{
/////////////////////////////////////////////////////////////////////////
1:                         return true;
0:                     public boolean recoverMessageReference(MessageId messageReference) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:                     public boolean recoverMessage(Message message) throws Exception{
1:                         return true;
0:                     public boolean  recoverMessageReference(MessageId messageReference) throws Exception{
1:                         return true;
1:                     }
commit:a414c20
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0:     final Broker broker;
0:     public Topic(Broker broker,ActiveMQDestination destination, TopicMessageStore store, UsageManager memoryManager, DestinationStatistics parentStats,
0:         this.broker=broker;
/////////////////////////////////////////////////////////////////////////
0:             broker.messageExpired(context,message);
0:             destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:         			            broker.messageExpired(context,message);
0:                                 destinationStatistics.getMessages().decrement();
/////////////////////////////////////////////////////////////////////////
0:                     		broker.messageExpired(context,message);
0:                             message.decrementReferenceCount();
0:                             destinationStatistics.getMessages().decrement();
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0: 	void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.ProducerBrokerExchange;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected void dispatch(final ConnectionContext context, Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                         ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
0:                         producerExchange.setMutable(false);
0:                         producerExchange.setConnectionContext(context);
0:                         context.getBroker().send(producerExchange, message);
commit:ccd81ad
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.FixedSizedSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
0:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy = new FixedSizedSubscriptionRecoveryPolicy();
commit:14c605f
/////////////////////////////////////////////////////////////////////////
0:         this.usageManager = new UsageManager(memoryManager,destination.toString());
/////////////////////////////////////////////////////////////////////////
0:         if (usageManager != null) {
0:             usageManager.start();
1:         }
1:         
0:         if (usageManager != null) {
0:             usageManager.stop();
1:         }
commit:3a2caf4
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CopyOnWriteArraySet;
0: import org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy = new NoSubscriptionRecoveryPolicy();
commit:4597ddd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:     } 
1:     
1:     
0:     protected void recoverRetroactiveMessages(ConnectionContext context,Subscription subscription) throws Exception{
0:         if(subscription.getConsumerInfo().isRetroactive()){
0:             subscriptionRecoveryPolicy.recover(context,this,subscription);
1:         }
1:     }
1:     
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
1: 
0:                     public boolean hasSpace(){
1:                         return true;
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
0:                     public boolean hasSpace(){
1:                        return true;
1:                     }
commit:6895d00
/////////////////////////////////////////////////////////////////////////
1:             if (!dispatchPolicy.dispatch(message, msgContext, consumers)) {
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0:             if(subscription.isRecoveryRequired()){
0:                 store.recoverSubscription(clientId,subscriptionName,new MessageRecoveryListener(){
0:                     public void recoverMessage(Message message) throws Exception{
1:                         message.setRegionDestination(Topic.this);
0:                         try{
1:                             msgContext.setMessageReference(message);
0:                             if(subscription.matches(message,msgContext)){
1:                                 subscription.add(message);
1:                             }
0:                         }catch(InterruptedException e){
0:                             Thread.currentThread().interrupt();
0:                         }catch(IOException e){
0:                             // TODO: Need to handle this better.
0:                             e.printStackTrace();
1: 
0:                     public void recoverMessageReference(String messageReference) throws Exception{
1:                         throw new RuntimeException("Should not be called.");
1: 
0:                     public void finished(){}
1:                 });
1:             }
commit:5c7f4b6
/////////////////////////////////////////////////////////////////////////
0:             store.acknowledge(context, dsub.getClientId(), dsub.getSubscriptionName(), node.getMessageId());
commit:b792f11
/////////////////////////////////////////////////////////////////////////
0:     protected final TopicMessageStore store;//this could be NULL! (If an advsiory)
/////////////////////////////////////////////////////////////////////////
0:         this.store = store; //this could be NULL! (If an advsiory)
/////////////////////////////////////////////////////////////////////////
0:         return store != null ? store.getMessage(messageId) : null;
/////////////////////////////////////////////////////////////////////////
0:             if(store!=null){
0:                 store.recover(new MessageRecoveryListener(){
0:                     public void recoverMessage(Message message) throws Exception{
0:                         result.add(message);
1:                     }
0:                     public void recoverMessageReference(String messageReference) throws Exception{}
0:                     public void finished(){}
1:                 });
0:                 Message[] msgs=subscriptionRecoveryPolicy.browse(getActiveMQDestination());
0:                 if(msgs!=null){
0:                     for(int i=0;i<msgs.length;i++){
0:                         result.add(msgs[i]);
1:                     }
commit:2748ae1
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log log = LogFactory.getLog(Topic.class);
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 public void finished(){
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     
0:     public Message[] browse(){
0:         final Set result=new CopyOnWriteArraySet();
0:         try{
0:             store.recover(new MessageRecoveryListener(){
0:                 public void recoverMessage(Message message) throws Throwable{
0:                     result.add(message);
1:                 }
1: 
0:                 public void recoverMessageReference(String messageReference) throws Throwable{}
1: 
0:                 public void finished(){}
0:             });
0:             Message[] msgs=subscriptionRecoveryPolicy.browse(getActiveMQDestination());
0:             if(msgs!=null){
0:                 for(int i=0;i<msgs.length;i++){
0:                     result.add(msgs[i]);
1:                 }
1:             }
0:         }catch(Throwable e){
0:             log.warn("Failed to browse Topic: "+getActiveMQDestination().getPhysicalName(),e);
1:         }
0:         return (Message[]) result.toArray(new Message[result.size()]);
1:     }
author:Christian Posta
-------------------------------------------------------------------------------
commit:866440d
/////////////////////////////////////////////////////////////////////////
commit:96f2945
/////////////////////////////////////////////////////////////////////////
1:                                 count++;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:3039b67
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                         consumers.remove(subscription);
1:                         if (!consumers.contains(subscription)) {
1:                             consumers.add(subscription);
1:                         }
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                     @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     public void deactivate(ConnectionContext context, DurableTopicSubscription sub, List<MessageReference> dispatched) throws Exception {
1:         sub.remove(context, this, dispatched);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                     @Override
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:425fa47
/////////////////////////////////////////////////////////////////////////
1:                     synchronized (consumers) {
0:                     	consumers.remove(subscription);
1:                     }
commit:4ae6807
/////////////////////////////////////////////////////////////////////////
0:                     	if (!consumers.contains(subscription)) {
1:                     		consumers.add(subscription);
1:                     	}
commit:ae5bd2e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             sub.add(context, this);
0:             if(dsub.isActive()) {
1:                 synchronized (consumers) {
0:                     boolean hasSubscription = false;
1: 
1:                     if (consumers.size() == 0) {
0:                         hasSubscription = false;
1:                     } else {
1:                         for (Subscription currentSub : consumers) {
1:                             if (currentSub.getConsumerInfo().isDurable()) {
0:                                 DurableTopicSubscription dcurrentSub = (DurableTopicSubscription) currentSub;
1:                                 if (dcurrentSub.getSubscriptionKey().equals(dsub.getSubscriptionKey())) {
0:                                     hasSubscription = true;
0:                                     break;
1:                                 }
1:                             }
1:                         }
1:                     }
1: 
1:                     if (!hasSubscription) {
0:                         consumers.add(sub);
1:                     }
1:                 }
1:             }
1:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                 // We can avoid blocking due to low usage if the producer is sending a sync message or
/////////////////////////////////////////////////////////////////////////
1:                     // Producer flow control cannot be used, so we have do the flow control
1:                     // at the broker by blocking this thread until there is space available.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b567bd4
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final ReentrantReadWriteLock dispatchLock = new ReentrantReadWriteLock();
/////////////////////////////////////////////////////////////////////////
1:                 // synchronize with dispatch method so that no new messages are sent
1:                 // while we are recovering a subscription to avoid out of order messages.
1:                 dispatchLock.writeLock().lock();
1:                     dispatchLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         // while we are recovering a subscription to avoid out of order messages.
1:         dispatchLock.writeLock().lock();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             dispatchLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         dispatchLock.readLock().lock();
/////////////////////////////////////////////////////////////////////////
1:             dispatchLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:02d5728
/////////////////////////////////////////////////////////////////////////
0:             // AMQ-2586: Better to leave this stat at zero than to give the user misleading metrics.
1:             // int messageCount = store.getMessageCount();
1:             // destinationStatistics.getMessages().setCount(messageCount);
/////////////////////////////////////////////////////////////////////////
0:         // AMQ-2586: Better to leave this stat at zero than to give the user misleading metrics.
1:         // destinationStatistics.getMessages().increment();
/////////////////////////////////////////////////////////////////////////
0:         // AMQ-2586: Better to leave this stat at zero than to give the user misleading metrics.
1:         // destinationStatistics.getMessages().decrement();
commit:293a698
/////////////////////////////////////////////////////////////////////////
1:             
0:             msgContext.clear();
1:             
commit:44e0eaf
/////////////////////////////////////////////////////////////////////////
0:     protected static final Log LOG = LogFactory.getLog(Topic.class);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         LOG.warn("Waiting for space to send  transacted message - transaction elements = " + size + " need more space to commit. Message = " + message);
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Expired message: " + message);
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to browse Topic: " + getActiveMQDestination().getPhysicalName(), e);
commit:a9ba595
/////////////////////////////////////////////////////////////////////////
0:     public void messageExpired(ConnectionContext context, PrefetchSubscription prefetchSubscription, MessageReference node) {
0:         // TODO Auto-generated method stub
1:         
1:     }
1: 
commit:13829ef
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
0:     public Topic(BrokerService brokerService, ActiveMQDestination destination, TopicMessageStore store, DestinationStatistics parentStats,
1:         super(brokerService, store, destination, parentStats);
/////////////////////////////////////////////////////////////////////////
1:         super.initialize();
commit:d83969f
/////////////////////////////////////////////////////////////////////////
0:             while (!systemUsage.getStoreUsage().waitForSpace(1000)) {
0:                 if (context.getStopping().get()) {
0:                     throw new IOException("Connection closed, send aborted.");
1:                 }
1:             }
commit:9da7e31
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
1:         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
0:         final boolean sendProducerAck = !message.isResponseRequired() && producerInfo.getWindowSize() > 0 && !context.isInRecoveryMode();
1: 
1:             if (sendProducerAck) {
1:                 ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
/////////////////////////////////////////////////////////////////////////
0:             if (producerInfo.getWindowSize() > 0 || message.isResponseRequired()) {
1:                             
1: 
0:                                 // While waiting for space to free up... the
0:                                 // message may have expired.
0:                                 if (broker.isExpired(message)) {
0:                                     broker.messageExpired(context, message);
0:                                     destinationStatistics.getMessages().decrement();
1:                                 } else {
1:                                     doMessageSend(producerExchange, message);
1:                                 }
1: 
1:                                 if (sendProducerAck) {
0:                                     ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
1:                                     context.getConnection().dispatchAsync(ack);
1:                                 } else {
0:                                     Response response = new Response();
0:                                     response.setCorrelationId(message.getCommandId());
0:                                     context.getConnection().dispatchAsync(response);
1:                                 }
1: 
0:                                 if (!sendProducerAck && !context.isInRecoveryMode()) {
1:                             
/////////////////////////////////////////////////////////////////////////
0:         if (sendProducerAck) {
0:             ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), message.getSize());
1:             context.getConnection().dispatchAsync(ack);
1:         }
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     protected final CopyOnWriteArrayList<Subscription> consumers = new CopyOnWriteArrayList<Subscription>();
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription> durableSubcribers = new ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription>();
1:     
1:     private final LinkedList<Runnable> messagesWaitingForSpace = new LinkedList<Runnable>();
1:     private final Runnable sendMessagesWaitingForSpaceTask = new Runnable() {
1:         public void run() {
1: 
0:             // We may need to do this in async thread since this is run for
0:             // within a synchronization
0:             // that the UsageManager is holding.
1: 
1:             synchronized (messagesWaitingForSpace) {
0:                 while (!usageManager.isFull() && !messagesWaitingForSpace.isEmpty()) {
0:                     Runnable op = messagesWaitingForSpace.removeFirst();
0:                     op.run();
1:                 }
1:             }
1: 
1:         };
1:     };
0:     private final Broker broker;
0:         this.store = store; // this could be NULL! (If an advisory)
/////////////////////////////////////////////////////////////////////////
0:             if (store == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     if (context.getStopping().get()) {
1:                     }
/////////////////////////////////////////////////////////////////////////
0:         if (store != null && message.isPersistent() && !canOptimizeOutPersistence()) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         final Set<Message> result = new CopyOnWriteArraySet<Message>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return result.toArray(new Message[result.size()]);
/////////////////////////////////////////////////////////////////////////
0:                     if (message.getOriginalDestination() != null) {
1:                     }
0:                     if (message.getOriginalTransactionId() != null) {
1:                     }
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(Topic.class);
0:     // this could be NULL! (If an advisory)
0:     protected final TopicMessageStore store;
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Expired message: " + message);
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to browse Topic: " + getActiveMQDestination().getPhysicalName(), e);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:     protected final TopicMessageStore store;// this could be NULL! (If an
0:     // advsiory)
/////////////////////////////////////////////////////////////////////////
1: 
0:     public Topic(Broker broker, ActiveMQDestination destination, TopicMessageStore store, UsageManager memoryManager, DestinationStatistics parentStats,
0:                  TaskRunnerFactory taskFactory) {
0:         this.broker = broker;
0:         this.store = store; // this could be NULL! (If an advsiory)
0:         this.usageManager = new UsageManager(memoryManager, destination.toString());
1: 
0:         // Let the store know what usage manager we are using so that he can
0:         // flush messages to disk
0:         if (store != null) {
1: 
0:         // let's copy the enabled property from the parent DestinationStatistics
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (!sub.getConsumerInfo().isDurable()) {
1: 
0:                 // synchronize with dispatch method so that no new messages are
0:                 // sent
0:                 // while we are recovering a subscription to avoid out of order
0:                 // messages.
1: 
1:                     synchronized (consumers) {
1: 
1: 
1:                 synchronized (consumers) {
1:             }
0:             DurableTopicSubscription dsub = (DurableTopicSubscription)sub;
1: 
1:         if (!sub.getConsumerInfo().isDurable()) {
1:             synchronized (consumers) {
1: 
1:             if (removed != null) {
1: 
1: 
1:             synchronized (consumers) {
1: 
0:             if (store == null)
1: 
/////////////////////////////////////////////////////////////////////////
1:                 info = new SubscriptionInfo();
1:                 info.setClientId(clientId);
0:                 info.setSelector(selector);
1:                 info.setSubscriptionName(subscriptionName);
0:                 info.setDestination(getActiveMQDestination()); // This
0:                 // destination
0:                 // is an actual
0:                 // destination
0:                 // id.
0:                 info.setSubscribedDestination(subscription.getConsumerInfo().getDestination()); // This
0:                 // destination
0:                 // might
0:                 // be a
0:                 // pattern
1: 
1:             if (subscription.isRecoveryRequired()) {
0:                 store.recoverSubscription(clientId, subscriptionName, new MessageRecoveryListener() {
1:                     public boolean recoverMessage(Message message) throws Exception {
1:                         try {
1:                             if (subscription.matches(message, msgContext)) {
0:                         } catch (InterruptedException e) {
0:                         } catch (IOException e) {
1:                     public boolean recoverMessageReference(MessageId messageReference) throws Exception {
0:                     public void finished() {
1:                     }
1:                     public boolean hasSpace() {
1: 
1:         } finally {
0:     public void deactivate(ConnectionContext context, DurableTopicSubscription sub) throws Exception {
1:         synchronized (consumers) {
1:     }
1: 
0:     protected void recoverRetroactiveMessages(ConnectionContext context, Subscription subscription) throws Exception {
1:         if (subscription.getConsumerInfo().isRetroactive()) {
1:             subscriptionRecoveryPolicy.recover(context, this, subscription);
1:         public void run() {
1: 
0:             // We may need to do this in async thread since this is run for
0:             // within a synchronization
0:             // that the UsageManager is holding.
1: 
0:             synchronized (messagesWaitingForSpace) {
0:                 while (!usageManager.isFull() && !messagesWaitingForSpace.isEmpty()) {
0:                     Runnable op = messagesWaitingForSpace.removeFirst();
0:                     op.run();
1:                 }
1:             }
1: 
0:         };
1:         final ConnectionContext context = producerExchange.getConnectionContext();
1: 
1:         // There is delay between the client sending it and it arriving at the
1:         // destination.. it may have expired.
0:         if (broker.isExpired(message)) {
0:             broker.messageExpired(context, message);
0:             if ((!message.isResponseRequired() || producerExchange.getProducerState().getInfo().getWindowSize() > 0) && !context.isInRecoveryMode()) {
0:                 ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0:                 context.getConnection().dispatchAsync(ack);
1:             return;
1:         }
1: 
0:         if (context.isProducerFlowControl() && usageManager.isFull()) {
0:             if (usageManager.isSendFailIfNoSpace()) {
1:             }
1: 
0:             // We can avoid blocking due to low usage if the producer is sending
0:             // a sync message or
0:             // if it is using a producer window
0:             if (producerExchange.getProducerState().getInfo().getWindowSize() > 0 || message.isResponseRequired()) {
0:                 synchronized (messagesWaitingForSpace) {
0:                     messagesWaitingForSpace.add(new Runnable() {
1:                         public void run() {
1: 
0:                             // While waiting for space to free up... the message
0:                             // may have expired.
0:                             if (broker.isExpired(message)) {
0:                                 broker.messageExpired(context, message);
1: 
0:                                 if (!message.isResponseRequired() && !context.isInRecoveryMode()) {
0:                                     ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0:                                     context.getConnection().dispatchAsync(ack);
1:                                 }
1:                                 return;
1:                             }
1: 
1:                             try {
0:                                 doMessageSend(producerExchange, message);
1:                             } catch (Exception e) {
0:                                 if (message.isResponseRequired() && !context.isInRecoveryMode()) {
0:                                     ExceptionResponse response = new ExceptionResponse(e);
0:                                     response.setCorrelationId(message.getCommandId());
0:                                     context.getConnection().dispatchAsync(response);
1:                                 }
1:                             }
1:                         }
0:                     });
1: 
0:                     // If the user manager is not full, then the task will not
0:                     // get called..
0:                     if (!usageManager.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
0:                         // so call it directly here.
0:                         sendMessagesWaitingForSpaceTask.run();
1:                     }
0:                     context.setDontSendReponse(true);
1:                     return;
1:                 }
1: 
1:             } else {
1: 
0:                 // Producer flow control cannot be used, so we have do the flow
0:                 // control at the broker
0:                 // by blocking this thread until there is space available.
0:                 while (!usageManager.waitForSpace(1000)) {
0:                     if (context.getStopping().get())
1: 
1:                 if (message.isExpired()) {
1:             }
0:     void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
1:         final ConnectionContext context = producerExchange.getConnectionContext();
0:         message.setRegionDestination(this);
0:         if (store != null && message.isPersistent() && !canOptimizeOutPersistence())
/////////////////////////////////////////////////////////////////////////
0:                         // It could take while before we receive the commit
0:                         // operration.. by that time the message could have
0:                         // expired..
0:                         if (broker.isExpired(message)) {
0:                             broker.messageExpired(context, message);
1:                             return;
1:                         }
0:             } else {
1:         } finally {
1:     }
0:         return durableSubcribers.size() == 0;
/////////////////////////////////////////////////////////////////////////
0:             DurableTopicSubscription dsub = (DurableTopicSubscription)sub;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public Message[] browse() {
0:         final Set result = new CopyOnWriteArraySet();
1:         try {
0:             if (store != null) {
0:                 store.recover(new MessageRecoveryListener() {
1:                     public boolean recoverMessage(Message message) throws Exception {
1:                     public boolean recoverMessageReference(MessageId messageReference) throws Exception {
0:                     public void finished() {
1:                     }
1:                     public boolean hasSpace() {
0:                         return true;
1:                 Message[] msgs = subscriptionRecoveryPolicy.browse(getActiveMQDestination());
1:                 if (msgs != null) {
0:                     for (int i = 0; i < msgs.length; i++) {
1:         } catch (Throwable e) {
0:             log.warn("Failed to browse Topic: " + getActiveMQDestination().getPhysicalName(), e);
0:         return (Message[])result.toArray(new Message[result.size()]);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             synchronized (consumers) {
/////////////////////////////////////////////////////////////////////////
1:         } finally {
/////////////////////////////////////////////////////////////////////////
0: 
0:                     // The original destination and transaction id do not get
0:                     // filled when the message is first sent,
0:                     // it is only populated if the message is routed to another
0:                     // destination like the DLQ
0:                     if (message.getOriginalDestination() != null)
0:                     if (message.getOriginalTransactionId() != null)
0:                     // Disable flow control for this since since we don't want
0:                     // to block.
/////////////////////////////////////////////////////////////////////////
0: 
commit:2728ccb
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             	info = new SubscriptionInfo();
0:             	info.setClientId(clientId);
0:             	info.setSelector(selector);
0:             	info.setSubscriptionName(subscriptionName);
0:             	info.setDestination(getActiveMQDestination()); // This destination is an actual destination id.
0:             	info.setSubscribedDestination(subscription.getConsumerInfo().getDestination()); // This destination might be a pattern
0:                 store.addSubsciption(info, subscription.getConsumerInfo().isRetroactive());
commit:12dba4d
/////////////////////////////////////////////////////////////////////////
0:             if( ( !message.isResponseRequired() || producerExchange.getProducerState().getInfo().getWindowSize() > 0 ) && !context.isInRecoveryMode() ) {
/////////////////////////////////////////////////////////////////////////
0:         			            if( !message.isResponseRequired() && !context.isInRecoveryMode() ) {
/////////////////////////////////////////////////////////////////////////
0: 	            	        	if( message.isResponseRequired() && !context.isInRecoveryMode() ) {
commit:a59cd03
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.ProducerAck;
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedList<Runnable> messagesWaitingForSpace = new LinkedList<Runnable>();
0:     private final Runnable sendMessagesWaitingForSpaceTask = new Runnable() {
0:     	public void run() {
0:     		
0:     		// We may need to do this in async thread since this is run for within a synchronization
0:     		// that the UsageManager is holding.
0:     		
0:     		synchronized( messagesWaitingForSpace ) {
0: 	    		while( !usageManager.isFull() && !messagesWaitingForSpace.isEmpty()) {
0: 	    			Runnable op = messagesWaitingForSpace.removeFirst();
0: 	    			op.run();
1: 	    		}
1:     		}
0:     		
0:     	};
0:     };
/////////////////////////////////////////////////////////////////////////
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Expired message: " + message);
1:             }
0:             if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || !message.isResponseRequired() ) {
0:         		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0: 				context.getConnection().dispatchAsync(ack);	    	            	        		
1:             }
0:     	
0:         if ( context.isProducerFlowControl() && usageManager.isFull() ) {
0:             if(usageManager.isSendFailIfNoSpace()){
1:             } 
0:             	
0:         	// We can avoid blocking due to low usage if the producer is sending a sync message or
0:         	// if it is using a producer window
0:         	if( producerExchange.getProducerState().getInfo().getWindowSize() > 0 || message.isResponseRequired() ) {
0:         		synchronized( messagesWaitingForSpace ) {
0:             		messagesWaitingForSpace.add(new Runnable() {
0:         				public void run() {
0:         					
0:         					// While waiting for space to free up... the message may have expired.
0:         			        if(message.isExpired()){
0:         			            if (log.isDebugEnabled()) {
0:         			                log.debug("Expired message: " + message);
1:         			            }
0:         			            
0:         			            if( !message.isResponseRequired() ) {
0:         			        		ProducerAck ack = new ProducerAck(producerExchange.getProducerState().getInfo().getProducerId(), message.getSize());
0:         							context.getConnection().dispatchAsync(ack);	    	            	        		
1:         			            }
0:         			            return;
1:         			        }
0:         					
0:         					
1: 	            	        try {							
0: 	            	        	doMessageSend(producerExchange, message);
0: 							} catch (Exception e) {
0: 	            	        	if( message.isResponseRequired() ) {
0:     				                ExceptionResponse response = new ExceptionResponse(e);
0:     				                response.setCorrelationId(message.getCommandId());
0:     								context.getConnection().dispatchAsync(response);	    								
1: 	            	        	}
1: 							}
1:         				}
0:         			});
0:             		
0:             		// If the user manager is not full, then the task will not get called..
0: 	            	if( !usageManager.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask) ) {
0: 	            		// so call it directly here.
0: 	            		sendMessagesWaitingForSpaceTask.run();
1: 	            	}			            	
0:             		context.setDontSendReponse(true);
0:             		return;
1:         		}
0:         		
0:         	} else {
0:         		
0:         		// Producer flow control cannot be used, so we have do the flow control at the broker 
0:         		// by blocking this thread until there is space available.	            		
1:                 }
0:                 if(message.isExpired()){
0:                     if (log.isDebugEnabled()) {
0:                         log.debug("Expired message: " + message);
1:                     }
0:                     return;
1:                 }
1:         	}
0:         doMessageSend(producerExchange, message);
1:     }
0: 
0: 	private void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
0: 		final ConnectionContext context = producerExchange.getConnectionContext();
0: 		message.setRegionDestination(this);
/////////////////////////////////////////////////////////////////////////
1: 	}
commit:a0e92d7
/////////////////////////////////////////////////////////////////////////
commit:7de0e81
/////////////////////////////////////////////////////////////////////////
0:         this.usageManager.setUsagePortion(1.0f);
commit:4569d7d
/////////////////////////////////////////////////////////////////////////
1:     public void send(final ProducerBrokerExchange producerExchange, final Message message) throws Exception {
0:     	final ConnectionContext context = producerExchange.getConnectionContext();
0:     	
commit:0afb7f9
/////////////////////////////////////////////////////////////////////////
0:                     public void recoverMessageReference(MessageId messageReference) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:                     public void recoverMessageReference(MessageId messageReference) throws Exception{}
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CopyOnWriteArraySet;
commit:a58d36b
/////////////////////////////////////////////////////////////////////////
0:     	// There is delay between the client sending it and it arriving at the
0:     	// destination.. it may have expired.
0:     	if( message.isExpired() ) {
0:     		return;
1:     	}
0: 
0:                 
0:                 // The usage manager could have delayed us by the time
0:                 // we unblock the message could have expired..
0:             	if( message.isExpired() ) {
0:             		return;
1:             	}
/////////////////////////////////////////////////////////////////////////
0:                     	// It could take while before we receive the commit
0:                     	// operration.. by that time the message could have expired..
0:                     	if( message.isExpired() ) {
0:                     		// TODO: remove message from store.
0:                     		return;
1:                     	}
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0:         
0:         // Let the store know what usage manager we are using so that he can flush messages to disk
0:         // when usage gets high.
0:         if( store!=null ) {
0:             store.setUsageManager(usageManager);
1:         }
0: 
commit:449981b
/////////////////////////////////////////////////////////////////////////
0:        
commit:36722d8
/////////////////////////////////////////////////////////////////////////
0:         this.usageManager = new UsageManager(memoryManager);
0:         this.usageManager.setLimit(Long.MAX_VALUE);
commit:44b00e9
/////////////////////////////////////////////////////////////////////////
1:     public boolean lock(MessageReference node, LockOwner sub) {
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public void addSubscription(ConnectionContext context, final Subscription sub) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void removeSubscription(ConnectionContext context, Subscription sub) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void addInactiveSubscription(ConnectionContext context, DurableTopicSubscription sub) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void activate(ConnectionContext context, final DurableTopicSubscription subscription) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                 public void recoverMessage(Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                 public void recoverMessageReference(String messageReference) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void deactivate(ConnectionContext context, DurableTopicSubscription sub) throws Exception {        
/////////////////////////////////////////////////////////////////////////
0:     public void send(final ConnectionContext context, final Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                     public void afterCommit() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                 public void recoverMessage(Message message) throws Exception{
0:                 public void recoverMessageReference(String messageReference) throws Exception{}
/////////////////////////////////////////////////////////////////////////
0:     protected void dispatch(ConnectionContext context, Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     protected void onMessageWithNoConsumers(ConnectionContext context, Message message) throws Exception {
commit:0f502fa
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap durableSubcribers = new ConcurrentHashMap();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         
0:         if ( !sub.getConsumerInfo().isDurable() ) {
0:             destinationStatistics.getConsumers().increment();
0:             
1:             // Do a retroactive recovery if needed.
0:             if (sub.getConsumerInfo().isRetroactive()) {
1:                 // synchronize with dispatch method so that no new messages are sent
0:                 // while we are recovering a subscription to avoid out of order messages.
0:                 dispatchValve.turnOff();
1:                 try {
0:                     
0:                     synchronized(consumers) {
0:                         consumers.add(sub);
1:                     }
0:                     subscriptionRecoveryPolicy.recover(context, this, sub);
0:                     
0:                 } finally {
0:                     dispatchValve.turnOn();
1:                 }
0:                 
0:             } else {
1:             }            
1:             DurableTopicSubscription dsub = (DurableTopicSubscription) sub;
0:             durableSubcribers.put(dsub.getSubscriptionKey(), dsub);
0:     
0:     public void removeSubscription(ConnectionContext context, Subscription sub) throws Throwable {
0:         if ( !sub.getConsumerInfo().isDurable() ) {
1:             destinationStatistics.getConsumers().decrement();
0:             synchronized(consumers) {
1:                 consumers.remove(sub);
1:             }
1:         }
1:         sub.remove(context, this);
1:     }
0:     
0:     public void addInactiveSubscription(ConnectionContext context, DurableTopicSubscription sub) throws Throwable {
0:         sub.add(context, this);        
0:         destinationStatistics.getConsumers().increment();
0:         durableSubcribers.put(sub.getSubscriptionKey(), sub);
1:     }
0:    
0:     public void deleteSubscription(ConnectionContext context, SubscriptionKey key) throws IOException {
0:         if (store != null) {
0:             store.deleteSubscription(key.clientId, key.subscriptionName);
0:             durableSubcribers.remove(key);
1:             destinationStatistics.getConsumers().decrement();
1:         }
1:     }
0:     
0:     public void activate(ConnectionContext context, final DurableTopicSubscription subscription) throws Throwable {
0:         
0:         
0:             synchronized(consumers) {           
0:                 consumers.add(subscription);
1:             }
0:             
0:             if (store == null )
0:                 return;
0:             
1:             // Recover the durable subscription.
0:             String clientId = subscription.getClientId();
0:             String subscriptionName = subscription.getSubscriptionName();
0:             String selector = subscription.getConsumerInfo().getSelector();
0:             SubscriptionInfo info = store.lookupSubscription(clientId, subscriptionName);
1:             if (info != null) {
1:                 // Check to see if selector changed.
0:                 String s1 = info.getSelector();
0:                 if (s1 == null ^ selector == null || (s1 != null && !s1.equals(selector))) {
1:                     // Need to delete the subscription
0:                     store.deleteSubscription(clientId, subscriptionName);
1:                     info = null;
1:             // Do we need to create the subscription?
1:             if (info == null) {
0:                 store.addSubsciption(clientId, subscriptionName, selector, subscription.getConsumerInfo().isRetroactive());
1:             }
0:     
0:             final MessageEvaluationContext msgContext = new MessageEvaluationContext();
1:             msgContext.setDestination(destination);
0:             store.recoverSubscription(clientId, subscriptionName, new MessageRecoveryListener() {
0:                 public void recoverMessage(Message message) throws Throwable {
0:                     message.setRegionDestination(Topic.this);
1:                     try {
1:                         msgContext.setMessageReference(message);
0:                         if (subscription.matches(message, msgContext)) {
0:                             subscription.add(message);
0:                     catch (InterruptedException e) {
0:                         Thread.currentThread().interrupt();
1:                     }
0:                     catch (IOException e) {
0:                         // TODO: Need to handle this better.
0:                         e.printStackTrace();
1:                     }
1:                 }
0:     
0:                 public void recoverMessageReference(String messageReference) throws Throwable {
0:                     throw new RuntimeException("Should not be called.");
1:                 }
0:             });
0:             
0:             if( true && subscription.getConsumerInfo().isRetroactive() ) {
0:                 // If nothing was in the persistent store, then try to use the recovery policy.
0:                 if( subscription.getEnqueueCounter() == 0 ) {
0:                     subscriptionRecoveryPolicy.recover(context, this, subscription);
0:                 } else {
0:                     // TODO: implement something like
0:                     // subscriptionRecoveryPolicy.recoverNonPersistent(context, this, sub);
0:         
0:     public void deactivate(ConnectionContext context, DurableTopicSubscription sub) throws Throwable {        
0:         synchronized(consumers) {           
1:     }    
0: 
/////////////////////////////////////////////////////////////////////////
0:         return durableSubcribers.size()==0;
/////////////////////////////////////////////////////////////////////////
0: 
commit:a71a2a5
/////////////////////////////////////////////////////////////////////////
0:                 synchronized(consumers) {           
/////////////////////////////////////////////////////////////////////////
0:                 // Do we need to create the subscription?
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void createSubscription(SubscriptionKey key) {
0:         durableSubscriberCounter.incrementAndGet();
0:     }
0:     
0:             durableSubscriberCounter.decrementAndGet();
commit:04968b6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy;
0: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
0:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy = new FixedCountSubscriptionRecoveryPolicy();
0:     private AtomicInteger durableSubscriberCounter = new AtomicInteger();
0:     
/////////////////////////////////////////////////////////////////////////
0:             recover(context, (DurableTopicSubscription) sub, true);
0:             recover(context, sub);
0:         }
0:     }
0: 
1:     /**
0:      * Used to recover the message list non durable subscriptions.  Recovery only happens if the consumer is
0:      * retroactive.
1:      * 
0:      * @param context
0:      * @param sub
0:      * @throws Throwable
1:      */
0:     private void recover(ConnectionContext context, final Subscription sub) throws Throwable {
0:         if (sub.getConsumerInfo().isRetroactive()) {
0:             
0:             // synchronize with dispatch method so that no new messages are sent
0:             // while we are recovering a subscription to avoid out of order messages.
0:             dispatchValve.turnOff();
0:             try {
0:                 
0:                 synchronized(consumers) {
0:                     consumers.add(sub);
0:                 }
0:                 
0:             } finally {
0:                 dispatchValve.turnOn();
0:             
0:         } else {
1:     /**
0:      * Used to recover the message list for a durable subscription.
1:      * 
0:      * @param context
0:      * @param sub
0:      * @param initialActivation
0:      * @throws Throwable
1:      */
0:     public void recover(ConnectionContext context, final DurableTopicSubscription sub, boolean initialActivation) throws Throwable {
/////////////////////////////////////////////////////////////////////////
0:             boolean persistenceWasOptimized = canOptimizeOutPersistence();
0:                 synchronized(consumers) {                    
0:                     durableSubscriberCounter.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:                     
0:                     if( initialActivation && sub.getConsumerInfo().isRetroactive() ) {
0:                         // Then use the subscriptionRecoveryPolicy since there will not be any messages in the persistent store.
0:                         if( persistenceWasOptimized ) {
0:                             subscriptionRecoveryPolicy.recover(context, this, sub);
0:                         } else {
0:                             // TODO: implement something like
0:                             // subscriptionRecoveryPolicy.recoverNonPersistent(context, this, sub);
0:                         }
0:                     }
/////////////////////////////////////////////////////////////////////////
0:             if( sub.getConsumerInfo().isDurable() ) {
0:                 durableSubscriberCounter.decrementAndGet();
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (store != null && message.isPersistent() && !canOptimizeOutPersistence() )
/////////////////////////////////////////////////////////////////////////
1:     private boolean canOptimizeOutPersistence() {
0:         return durableSubscriberCounter.get()==0;
0:     }
0: 
commit:61ab31e
/////////////////////////////////////////////////////////////////////////
0:                 if (!AdvisorySupport.isAdvisoryTopic(destination)) {
0:                     
0:                     // The original destination and transaction id do not get filled when the message is first sent,
0:                     // it is only populated if the message is routed to another destination like the DLQ
0:                     if( message.getOriginalDestination()!=null )
0:                         message.setOriginalDestination(message.getDestination());
0:                     if( message.getOriginalTransactionId()!=null )
0:                         message.setOriginalTransactionId(message.getTransactionId());
0: 
0:                     ActiveMQTopic advisoryTopic = AdvisorySupport.getNoTopicConsumersAdvisoryTopic(destination);
0:                     message.setTransactionId(null);
0:                     message.evictMarshlledForm();
0: 
0:                     // Disable flow control for this since since we don't want to block.
0:                     boolean originalFlowControl = context.isProducerFlowControl();
0:                     try {
0:                         context.setProducerFlowControl(false);
0:                         context.getBroker().send(context, message);
0:                     } finally {
0:                         context.setProducerFlowControl(originalFlowControl);
0:                     }
0:                     
commit:4759253
/////////////////////////////////////////////////////////////////////////
0:             synchronized(consumers) {
0:                 consumers.add(sub);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             if (initialActivation) {
0:                 synchronized(consumers) {
0:                     consumers.add(sub);
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:         synchronized(consumers) {
0:             consumers.remove(sub);
0:         }
/////////////////////////////////////////////////////////////////////////
0:             synchronized(consumers) {
1:                 if (consumers.isEmpty()) {
1:                     onMessageWithNoConsumers(context, message);
0:                     return;
0:                 }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
0: 
0: import java.io.IOException;
0: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.policy.DispatchPolicy;
1: import org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy;
1: import org.apache.activemq.broker.region.policy.SimpleDispatchPolicy;
1: import org.apache.activemq.broker.region.policy.SubscriptionRecoveryPolicy;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.filter.MessageEvaluationContext;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.store.MessageRecoveryListener;
0: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.thread.TaskRunnerFactory;
0: import org.apache.activemq.thread.Valve;
1: import org.apache.activemq.transaction.Synchronization;
1: import org.apache.activemq.util.SubscriptionKey;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: 
1: /**
1:  * The Topic is a destination that sends a copy of a message to every active
1:  * Subscription registered.
0:  * 
0:  * @version $Revision: 1.21 $
1:  */
0: public class Topic implements Destination {
0: 
0:     protected final ActiveMQDestination destination;
0:     protected final CopyOnWriteArrayList consumers = new CopyOnWriteArrayList();
0:     protected final Valve dispatchValve = new Valve(true);
0:     protected final TopicMessageStore store;
0:     protected final UsageManager usageManager;
0:     protected final DestinationStatistics destinationStatistics = new DestinationStatistics();
0: 
1:     private DispatchPolicy dispatchPolicy = new SimpleDispatchPolicy();
0:     private SubscriptionRecoveryPolicy subscriptionRecoveryPolicy = new LastImageSubscriptionRecoveryPolicy();
0: 
0:     public Topic(ActiveMQDestination destination, TopicMessageStore store, UsageManager memoryManager,
0:             DestinationStatistics parentStats, TaskRunnerFactory taskFactory) {
0: 
0:         this.destination = destination;
0:         this.store = store;
0:         this.usageManager = memoryManager;
0: 
0:         // TODO: switch back when cache is working again.
0:         // this.cache = cache;
0:         // destinationStatistics.setMessagesCached(cache.getMessagesCached());
0:         // CacheEvictionUsageListener listener = new
0:         // CacheEvictionUsageListener(memoryManager, 90, 50, taskFactory);
0:         // listener.add(cache);
0:         // this.memoryManager.addUsageListener(listener);
0: 
0:         this.destinationStatistics.setParent(parentStats);
0:     }
0: 
0:     public boolean lock(MessageReference node, Subscription sub) {
0:         return true;
0:     }
0: 
0:     public void addSubscription(ConnectionContext context, final Subscription sub) throws Throwable {
0:         destinationStatistics.getConsumers().increment();
0:         sub.add(context, this);
0:         if (sub.getConsumerInfo().isDurable()) {
0:             recover((DurableTopicSubscription) sub, true);
0:         }
0:         else {
0:             if (sub.getConsumerInfo().isRetroactive()) {
0:                 subscriptionRecoveryPolicy.recover(context, this, sub);
0:             }
0:             consumers.add(sub);
0:         }
0:     }
0: 
0:     public void recover(final DurableTopicSubscription sub, boolean initialActivation) throws Throwable {
0: 
0:         // synchronize with dispatch method so that no new messages are sent
0:         // while
0:         // we are recovering a subscription to avoid out of order messages.
0:         dispatchValve.turnOff();
0:         try {
0: 
0:             if (initialActivation)
0:                 consumers.add(sub);
0: 
0:             if (store != null) {
0:                 String clientId = sub.getClientId();
0:                 String subscriptionName = sub.getSubscriptionName();
0:                 String selector = sub.getConsumerInfo().getSelector();
0:                 SubscriptionInfo info = store.lookupSubscription(clientId, subscriptionName);
0:                 if (info != null) {
0:                     // Check to see if selector changed.
0:                     String s1 = info.getSelector();
0:                     if (s1 == null ^ selector == null || (s1 != null && !s1.equals(selector))) {
0:                         // Need to delete the subscription
0:                         store.deleteSubscription(clientId, subscriptionName);
0:                         info = null;
0:                     }
0:                 }
0:                 // Do we need to crate the subscription?
0:                 if (info == null) {
0:                     store.addSubsciption(clientId, subscriptionName, selector, sub.getConsumerInfo().isRetroactive());
0:                 }
0: 
0:                 if (sub.isRecovered()) {
0:                     final MessageEvaluationContext msgContext = new MessageEvaluationContext();
1:                     msgContext.setDestination(destination);
0:                     store.recoverSubscription(clientId, subscriptionName, new MessageRecoveryListener() {
0:                         public void recoverMessage(Message message) throws Throwable {
0:                             message.setRegionDestination(Topic.this);
0:                             try {
0:                                 msgContext.setMessageReference(message);
0:                                 if (sub.matches(message, msgContext)) {
0:                                     sub.add(message);
0:                                 }
0:                             }
0:                             catch (InterruptedException e) {
0:                                 Thread.currentThread().interrupt();
0:                             }
0:                             catch (IOException e) {
0:                                 // TODO: Need to handle this better.
0:                                 e.printStackTrace();
0:                             }
0:                         }
0: 
0:                         public void recoverMessageReference(String messageReference) throws Throwable {
0:                             throw new RuntimeException("Should not be called.");
0:                         }
0:                     });
0:                 }
0:             }
0: 
0:         }
0:         finally {
0:             dispatchValve.turnOn();
0:         }
0:     }
0: 
0:     public void removeSubscription(ConnectionContext context, Subscription sub) throws Throwable {
0:         destinationStatistics.getConsumers().decrement();
0:         consumers.remove(sub);
0:         sub.remove(context, this);
0:     }
0: 
0:     public void send(final ConnectionContext context, final Message message) throws Throwable {
0: 
0:         if( context.isProducerFlowControl() )
0:             usageManager.waitForSpace();
0:         
0:         message.setRegionDestination(this);
0:         
0:         if (store != null && message.isPersistent())
0:             store.addMessage(context, message);
0: 
1:         message.incrementReferenceCount();
0:         try {
0:     
0:             if (context.isInTransaction()) {
0:                 context.getTransaction().addSynchronization(new Synchronization() {
0:                     public void afterCommit() throws Throwable {
1:                         dispatch(context, message);
0:                     }
0:                 });
0:     
0:             }
0:             else {
1:                 dispatch(context, message);
0:             }
0:             
0:         } finally {
0:             message.decrementReferenceCount();
0:         }
0:         
0:     }
0: 
0:     public void deleteSubscription(ConnectionContext context, SubscriptionKey key) throws IOException {
0:         if (store != null) {
0:             store.deleteSubscription(key.clientId, key.subscriptionName);
0:         }
0:     }
0: 
1:     public String toString() {
1:         return "Topic: destination=" + destination.getPhysicalName() + ", subscriptions=" + consumers.size();
0:     }
0: 
0:     public void acknowledge(ConnectionContext context, Subscription sub, final MessageAck ack, final MessageReference node) throws IOException {
0:         if (store != null && node.isPersistent()) {
1:             DurableTopicSubscription dsub = (DurableTopicSubscription) sub;
0:             store.acknowledge(context, dsub.getClientId(), dsub.getSubscriptionName(), ack.getLastMessageId());
0:         }
0:     }
0: 
0:     public void dispose(ConnectionContext context) throws IOException {
0:         if (store != null) {
0:             store.removeAllMessages(context);
0:         }
0:         destinationStatistics.setParent(null);
0:     }
0: 
1:     public void gc() {
0:     }
0: 
1:     public Message loadMessage(MessageId messageId) throws IOException {
0:         return store.getMessage(messageId);
0:     }
0: 
1:     public void start() throws Exception {
0:         this.subscriptionRecoveryPolicy.start();
0:     }
0: 
1:     public void stop() throws Exception {
0:         this.subscriptionRecoveryPolicy.stop();
0:     }
0: 
1:     // Properties
1:     // -------------------------------------------------------------------------
0:     
0:     public UsageManager getUsageManager() {
0:         return usageManager;
0:     }
0: 
0:     public DestinationStatistics getDestinationStatistics() {
0:         return destinationStatistics;
0:     }
0: 
0:     public ActiveMQDestination getActiveMQDestination() {
0:         return destination;
0:     }
0: 
1:     public DispatchPolicy getDispatchPolicy() {
1:         return dispatchPolicy;
0:     }
0: 
1:     public void setDispatchPolicy(DispatchPolicy dispatchPolicy) {
1:         this.dispatchPolicy = dispatchPolicy;
0:     }
0: 
1:     public SubscriptionRecoveryPolicy getSubscriptionRecoveryPolicy() {
1:         return subscriptionRecoveryPolicy;
0:     }
0: 
0:     public void setSubscriptionRecoveryPolicy(SubscriptionRecoveryPolicy subscriptionRecoveryPolicy) {
0:         this.subscriptionRecoveryPolicy = subscriptionRecoveryPolicy;
0:     }
0: 
0:     protected void dispatch(ConnectionContext context, Message message) throws Throwable {
1:         destinationStatistics.getEnqueues().increment();
0:         dispatchValve.increment();
0:         MessageEvaluationContext msgContext = context.getMessageEvaluationContext();
0:         try {
0:             if (! subscriptionRecoveryPolicy.add(context, message)) {
0:                 return;
0:             }
0:             if (consumers.isEmpty()) {
1:                 onMessageWithNoConsumers(context, message);
0:                 return;
0:             }
0: 
1:             msgContext.setDestination(destination);
0:             msgContext.setMessageReference(message);
0:             
0:             if (!dispatchPolicy.dispatch(context, message, msgContext, consumers)) {
1:                 onMessageWithNoConsumers(context, message);
0:             }
0:         }
0:         finally {
0:             msgContext.clear();
0:             dispatchValve.decrement();
0:         }
0:     }
0: 
1:     /** 
0:      * Provides a hook to allow messages with no consumer to be processed in some way - such as to send to a dead letter queue or something..
1:      */
0:     protected void onMessageWithNoConsumers(ConnectionContext context, Message message) {
0:         if (! message.isPersistent()) {
0:             // allow messages with no consumers to be dispatched to a dead letter queue
0:         }
0:     }
0: 
0:     public MessageStore getMessageStore() {
0:         return store;
0:     }
0: 
0: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:b5e46ef
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
0:         if (AdvisorySupport.isMasterBrokerAdvisoryTopic(destination)) {
0:             subscriptionRecoveryPolicy = new LastImageSubscriptionRecoveryPolicy();
0:             setAlwaysRetroactive(true);
0:         } else {
0:             subscriptionRecoveryPolicy = new NoSubscriptionRecoveryPolicy();
0:         }
commit:b78867e
/////////////////////////////////////////////////////////////////////////
0:                             for (DurableTopicSubscription sub : durableSubcribers.values()) {
1:                                 if (!sub.isActive()) {
1:                                     messageExpired(connectionContext, sub, message);
0:                                 }
commit:ed3f61a
/////////////////////////////////////////////////////////////////////////
0:         if (getExpireMessagesPeriod() > 0) {
0:             scheduler.schedualPeriodically(expireMessagesTask, getExpireMessagesPeriod());
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:          scheduler.cancel(expireMessagesTask);
1:         final ConnectionContext connectionContext = createConnectionContext();
0:                         if (message.isExpired()) {
0:                             for (Subscription sub : durableSubcribers.values()) {
0:                                 messageExpired(connectionContext, sub, message);
0:                             }
0:                         }
/////////////////////////////////////////////////////////////////////////
0:     private final Runnable expireMessagesTask = new Runnable() {
0:         public void run() {
0:             browse();
0:         }
0:     };
0: 
/////////////////////////////////////////////////////////////////////////
1:             if (subs instanceof DurableTopicSubscription) {
1:                 ((DurableTopicSubscription)subs).removePending(reference);
0:             }
0:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0: 
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     protected static final Logger LOG = LoggerFactory.getLogger(Topic.class);
/////////////////////////////////////////////////////////////////////////
1:     protected Logger getLog() {
commit:e0c5024
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         registerCallbackForNotFullNotification();
/////////////////////////////////////////////////////////////////////////
0: 
1:             if (!messagesWaitingForSpace.isEmpty()) {
1:                 registerCallbackForNotFullNotification();
0:             }
1:     private void registerCallbackForNotFullNotification() {
1:         // If the usage manager is not full, then the task will not
0:         // get called..
0:         if (!memoryUsage.notifyCallbackWhenNotFull(sendMessagesWaitingForSpaceTask)) {
0:             // so call it directly here.
0:             sendMessagesWaitingForSpaceTask.run();
0:         }
0:     }
0: 
commit:9444a79
/////////////////////////////////////////////////////////////////////////
1:     public void deleteSubscription(ConnectionContext context, SubscriptionKey key) throws Exception {
0:             DurableTopicSubscription removed = durableSubcribers.remove(key);
0:             // deactivate and remove
0:             removed.deactivate(false);
0:             consumers.remove(removed);
commit:d021e5b
/////////////////////////////////////////////////////////////////////////
0:                 final String logMessage = "Usage Manager memory limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding " +getActiveMQDestination().getQualifiedName() + "." +
0:                         " See http://activemq.apache.org/producer-flow-control.html for more info";
0:                 LOG.info(logMessage);
1:                     throw new javax.jms.ResourceAllocationException(logMessage);
/////////////////////////////////////////////////////////////////////////
0:             if (systemUsage.getStoreUsage().isFull()) {
0:                 final String logMessage = "Usage Manager Store is Full. Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "." +
0:                         " See http://activemq.apache.org/producer-flow-control.html for more info";
0:                 LOG.info(logMessage);
0:                 if (systemUsage.isSendFailIfNoSpace()) {
0:             	    throw new javax.jms.ResourceAllocationException(logMessage);
0:                 }
commit:538d07e
/////////////////////////////////////////////////////////////////////////
0:             if (systemUsage.isSendFailIfNoSpace() && systemUsage.getStoreUsage().isFull()) {
0:                 throw new javax.jms.ResourceAllocationException("Usage Manager Store is Full");
commit:2e7d219
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         sub.add(context, this);
/////////////////////////////////////////////////////////////////////////
0:                     sub.add(context, this);
0:             sub.add(context, this);
/////////////////////////////////////////////////////////////////////////
0:         	
/////////////////////////////////////////////////////////////////////////
0:                 } else {
1:                     synchronized (consumers) {
0:                         consumers.add(subscription);
0:                     }
/////////////////////////////////////////////////////////////////////////
1:                 // This destination is an actual destination id.
0:                 synchronized (consumers) {
0:                     consumers.add(subscription);
0:                     topicStore.addSubsciption(info,subscription.getConsumerInfo().isRetroactive());
0:                 }
0:             
/////////////////////////////////////////////////////////////////////////
commit:9ad6c08
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:a5eb7c6
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription> durableSubscribers = new ConcurrentHashMap<SubscriptionKey, DurableTopicSubscription>();
/////////////////////////////////////////////////////////////////////////
1:             durableSubscribers.put(dsub.getSubscriptionKey(), dsub);
/////////////////////////////////////////////////////////////////////////
1:             DurableTopicSubscription removed = durableSubscribers.remove(key);
/////////////////////////////////////////////////////////////////////////
1:         return durableSubscribers.size() == 0;
/////////////////////////////////////////////////////////////////////////
1:                     for (DurableTopicSubscription sub : durableSubscribers.values()) {
/////////////////////////////////////////////////////////////////////////
1:         if (isDoOptimzeMessageStorage() && durableSubscribers.isEmpty()==false){
1:                 for (DurableTopicSubscription s : durableSubscribers.values()) {
/////////////////////////////////////////////////////////////////////////
0:             for (DurableTopicSubscription durableTopicSubscription : durableSubscribers.values()) {
/////////////////////////////////////////////////////////////////////////
1:         return durableSubscribers;
commit:b07f31e
/////////////////////////////////////////////////////////////////////////
1:             topicStore.acknowledge(context, key.getClientId(), key.getSubscriptionName(), node.getMessageId(),
1:                     convertToNonRangedAck(ack, node));
/////////////////////////////////////////////////////////////////////////
0:     private void clearPendingMessages(SubscriptionKey subscriptionKey) {
commit:64f3492
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * force a reread of the store - after transaction recovery completion
0:      */
0:     public void clearPendingMessages() {
0:         dispatchLock.readLock().lock();
0:         try {
0:             for (DurableTopicSubscription durableTopicSubscription : durableSubcribers.values()) {
1:                 clearPendingAndDispatch(durableTopicSubscription);
0:             }
0:         } finally {
0:             dispatchLock.readLock().unlock();
0:         }
0:     }
0: 
0: 
0:     public void clearPendingMessages(SubscriptionKey subscriptionKey) {
0:         dispatchLock.readLock().lock();
0:         try {
0:             DurableTopicSubscription durableTopicSubscription = durableSubcribers.get(subscriptionKey);
1:             clearPendingAndDispatch(durableTopicSubscription);
0:         } finally {
0:             dispatchLock.readLock().unlock();
0:         }
0:     }
0: 
1:     private void clearPendingAndDispatch(DurableTopicSubscription durableTopicSubscription) {
1:         synchronized (durableTopicSubscription.pendingLock) {
1:             durableTopicSubscription.pending.clear();
0:             try {
1:                 durableTopicSubscription.dispatchPending();
1:             } catch (IOException exception) {
0:                 LOG.warn("After clear of pending, failed to dispatch to: " +
0:                         durableTopicSubscription + ", for :" + destination + ", pending: " +
0:                         durableTopicSubscription.pending, exception);
0:             }
0:         }
0:     }
0: 
1:     public Map<SubscriptionKey, DurableTopicSubscription> getDurableTopicSubs() {
0:         return durableSubcribers;
0:     }
0: 
commit:8ce0778
/////////////////////////////////////////////////////////////////////////
1:                 if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
/////////////////////////////////////////////////////////////////////////
1:                 if (!context.isNetworkConnection() && systemUsage.isSendFailIfNoSpace()) {
commit:9c9b856
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final Valve dispatchValve = new Valve(true);
/////////////////////////////////////////////////////////////////////////
1:                 final List<Message> toExpire = new ArrayList<Message>();
1:                             toExpire.add(message);
/////////////////////////////////////////////////////////////////////////
0:                 final ConnectionContext connectionContext = createConnectionContext();
1:                 for (Message message : toExpire) {
0:                     for (DurableTopicSubscription sub : durableSubcribers.values()) {
0:                         if (!sub.isActive()) {
0:                             messageExpired(connectionContext, sub, message);
0:                         }
0:                     }
0:                 }
commit:383a7ac
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.util.InsertionCountList;
/////////////////////////////////////////////////////////////////////////
1:         final List<Message> result = new ArrayList<Message>();
1:         doBrowse(result, getMaxBrowsePageSize());
0:         return result.toArray(new Message[result.size()]);
0:     }
0: 
1:     private void doBrowse(final List<Message> browseList, final int max) {
0:                 final ConnectionContext connectionContext = createConnectionContext();
/////////////////////////////////////////////////////////////////////////
1:                         browseList.add(message);
/////////////////////////////////////////////////////////////////////////
1:                         return browseList.size() < max;
/////////////////////////////////////////////////////////////////////////
1:                     for (int i = 0; i < msgs.length && browseList.size() < max; i++) {
1:                         browseList.add(msgs[i]);
/////////////////////////////////////////////////////////////////////////
1:             List<Message> browsedMessages = new InsertionCountList<Message>();
1:             doBrowse(browsedMessages, getMaxExpirePageSize());
commit:fe63c29
/////////////////////////////////////////////////////////////////////////
1:             if (sub.getConsumerInfo().isRetroactive() || isAlwaysRetroactive()) {
commit:2b10259
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info(memoryUsage + ", Usage Manager memory limit reached for "
/////////////////////////////////////////////////////////////////////////
1:                             + memoryUsage.getLimit() + ") reached. Rejecting send for producer (" + message.getProducerId()
/////////////////////////////////////////////////////////////////////////
1:                                     "Usage Manager Memory Usage limit reached. Stopping producer ("
/////////////////////////////////////////////////////////////////////////
1:                 final String logMessage = "Persistent store is Full, " + getStoreUsageHighWaterMark() + "% of "
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1:                     // operation.. by that time the message could have
commit:27c1719
/////////////////////////////////////////////////////////////////////////
1:             broker.messageExpired(context, message, null);
/////////////////////////////////////////////////////////////////////////
1:                                         broker.messageExpired(context, message, null);
/////////////////////////////////////////////////////////////////////////
0:                         broker.messageExpired(context, message, null);
/////////////////////////////////////////////////////////////////////////
1:         broker.messageExpired(context, reference, subs);
commit:3432a75
/////////////////////////////////////////////////////////////////////////
0:             topicStore.acknowledge(context, key.getClientId(), key.getSubscriptionName(), node.getMessageId(), ack);
commit:0af6b06
/////////////////////////////////////////////////////////////////////////
0:                 public void afterCommit() throws Exception {
commit:a0d2282
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CopyOnWriteArraySet;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (systemUsage.getStoreUsage().isFull(getStoreUsageHighWaterMark())) {
0:                 final String logMessage = "Usage Manager Store is Full, " + getStoreUsageHighWaterMark() + "% of " + systemUsage.getStoreUsage().getLimit() + ". Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
0:                 waitForSpace(context, systemUsage.getStoreUsage(), getStoreUsageHighWaterMark(), logMessage);
/////////////////////////////////////////////////////////////////////////
0:     
1:     @Override
0:     protected Log getLog() {
1:         return LOG;
0: 
commit:a2af47b
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Usage Manager memory limit ("+ memoryUsage.getLimit() + ") reached for " + getActiveMQDestination().getQualifiedName()
0:                     throw new javax.jms.ResourceAllocationException("Usage Manager memory limit ("+ memoryUsage.getLimit() + ") reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding "
commit:a1bd85e
/////////////////////////////////////////////////////////////////////////
1:                                         getDestinationStatistics().getExpired().increment();
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
1:             getDestinationStatistics().getExpired().increment();
/////////////////////////////////////////////////////////////////////////
1:                                         getDestinationStatistics().getExpired().increment();
/////////////////////////////////////////////////////////////////////////
0:                         getDestinationStatistics().getExpired().increment();
/////////////////////////////////////////////////////////////////////////
0:                         getDestinationStatistics().getExpired().increment();
/////////////////////////////////////////////////////////////////////////
1:         destinationStatistics.getExpired().increment();
commit:132f662
/////////////////////////////////////////////////////////////////////////
0:                     
1:                     public boolean isDuplicate(MessageId id) {
1:                         return false;
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                     
1:                     public boolean isDuplicate(MessageId id) {
1:                         return false;
0:                     }
commit:3b08860
/////////////////////////////////////////////////////////////////////////
0:     public void removeSubscription(ConnectionContext context, Subscription sub, long lastDeliveredSequenceId) throws Exception {
author:Colin W Macnaughton
-------------------------------------------------------------------------------
commit:48764be
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.usage.Usage;
/////////////////////////////////////////////////////////////////////////
1: public class Topic extends BaseDestination implements Task {
0:     protected final Valve dispatchValve = new Valve(true);
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 Topic.this.taskRunner.wakeup();
0:             } catch (InterruptedException e) {
0:             }
0:     public Topic(BrokerService brokerService, ActiveMQDestination destination, TopicMessageStore store, DestinationStatistics parentStats, TaskRunnerFactory taskFactory) throws Exception {
1:         this.topicStore = store;
0:         subscriptionRecoveryPolicy = new NoSubscriptionRecoveryPolicy();
0: 
1:     public void initialize() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             DurableTopicSubscription dsub = (DurableTopicSubscription) sub;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             if (info == null) {
0:                 info = new SubscriptionInfo();
0:                 info.setDestination(getActiveMQDestination());
0:                 info.setSubscribedDestination(subscription.getConsumerInfo().getDestination());
0:                     topicStore.addSubsciption(info, subscription.getConsumerInfo().isRetroactive());
/////////////////////////////////////////////////////////////////////////
0:                             LOG.error("Failed to recover this message " + message);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:         if (memoryUsage.isFull()) {
0: 
0: 
0:                 if (warnOnProducerFlowControl) {
0:                     LOG.info("Usage Manager memory limit reached for " + getActiveMQDestination().getQualifiedName()
0:                             + ". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it."
0:                             + " See http://activemq.apache.org/producer-flow-control.html for more info");
0: 
0:                     throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding "
0:                             + getActiveMQDestination().getQualifiedName() + "." + " See http://activemq.apache.org/producer-flow-control.html for more info");
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:                     
1:                     if (memoryUsage.isFull()) {
0:                         if (context.isInTransaction()) {
0: 
0:                             int count = 0;
0:                             while (!memoryUsage.waitForSpace(1000)) {
0:                                 if (context.getStopping().get()) {
0:                                     throw new IOException("Connection closed, send aborted.");
0:                                 }
0:                                 if (count > 2 && context.isInTransaction()) {
1:                                     count = 0;
0:                                     int size = context.getTransaction().size();
0:                                     LOG.warn("Waiting for space to send  transacted message - transaction elements = " + size + " need more space to commit. Message = " + message);
0:                                 }
0:                             }
0:                         } else {
0:                             waitForSpace(context, memoryUsage, "Usage Manager memory limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding "
0:                                     + getActiveMQDestination().getQualifiedName() + "." + " See http://activemq.apache.org/producer-flow-control.html for more info");
0: 
/////////////////////////////////////////////////////////////////////////
1:      * do send the message - this needs to be synchronized to ensure messages
1:      * are stored AND dispatched in the right order
0:      * 
0:     synchronized void doMessageSend(final ProducerBrokerExchange producerExchange, final Message message) throws IOException, Exception {
0:         final ConnectionContext context = producerExchange.getConnectionContext();
1:         if (topicStore != null && message.isPersistent() && !canOptimizeOutPersistence()) {
0:                 final String logMessage = "Usage Manager Store is Full. Stopping producer (" + message.getProducerId() + ") to prevent flooding " + getActiveMQDestination().getQualifiedName() + "."
1:                         + " See http://activemq.apache.org/producer-flow-control.html for more info";
0:                     throw new javax.jms.ResourceAllocationException(logMessage);
0: 
0:                 waitForSpace(context, systemUsage.getStoreUsage(), logMessage);
/////////////////////////////////////////////////////////////////////////
0:             DurableTopicSubscription dsub = (DurableTopicSubscription) sub;
/////////////////////////////////////////////////////////////////////////
0:         if (this.topicStore != null) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         synchronized (messagesWaitingForSpace) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:         dispatchValve.increment();
/////////////////////////////////////////////////////////////////////////
0:             }
0: 
1:             if (msgContext != null) {
0: 
1:     public void messageExpired(ConnectionContext context, Subscription subs, MessageReference reference) {
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Failed to remove expired Message from the store ", e);
0:     private final void waitForSpace(ConnectionContext context, Usage<?> usage, String warning) throws IOException, InterruptedException {
0:         long start = System.currentTimeMillis();
0:         long nextWarn = start + blockedProducerWarningInterval;
0:         while (!usage.waitForSpace(1000)) {
0:             if (context.getStopping().get()) {
0:                 throw new IOException("Connection closed, send aborted.");
0:             }
0: 
0:             long now = System.currentTimeMillis();
0:             if (now >= nextWarn) {
0:                 LOG.info(warning + " (blocking for: " + (now - start) / 1000 + "s)");
0:                 nextWarn = now + blockedProducerWarningInterval;
0:             }
0:         }
0:     }
commit:4245c35
/////////////////////////////////////////////////////////////////////////
0:             
0:                 
0:                 if(warnOnProducerFlowControl) {
0:                     warnOnProducerFlowControl = false;
0:                     LOG.info("Usage Manager memory limit reached for " +getActiveMQDestination().getQualifiedName() + ". Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it." +
0:                             " See http://activemq.apache.org/producer-flow-control.html for more info");
0:                 
0:                 if (systemUsage.isSendFailIfNoSpace()) {
0:                     throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached. Stopping producer (" + message.getProducerId() + ") to prevent flooding " +getActiveMQDestination().getQualifiedName() + "." +
0:                             " See http://activemq.apache.org/producer-flow-control.html for more info");
0:                 }
0:    
author:James Strachan
-------------------------------------------------------------------------------
commit:947659c
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     public List<Subscription> getConsumers() {
0:         synchronized (consumers) {
1:             return new ArrayList<Subscription>(consumers);
0:         }
0:     }
0: 
commit:aa3b9ac
/////////////////////////////////////////////////////////////////////////
0:         if (context.isProducerFlowControl()) {
0:             if (usageManager.isSendFailIfNoSpace() && usageManager.isFull()) {
0:                 throw new javax.jms.ResourceAllocationException("Usage Manager memory limit reached");
0:             } else {
0:                 usageManager.waitForSpace();
0:             }    
0:         }
commit:44493e4
/////////////////////////////////////////////////////////////////////////
0:     public void resetStatistics(){
0:         getDestinationStatistics().reset();
0:     }
0: 
0:     public String getName() {
0:         return getActiveMQDestination().getPhysicalName();
0:     }
0: 
0:     public long getEnqueueCount() {
0:         return getDestinationStatistics().getEnqueues().getCount();
0:     }
0: 
0:     public long getDequeueCount() {
0:         return getDestinationStatistics().getDequeues().getCount();
0:     }
0: 
0:     public long getConsumerCount() {
0:         return getDestinationStatistics().getConsumers().getCount();
0:     }
0: 
0:     public long getQueueSize() {
0:         return getDestinationStatistics().getMessages().getCount();
0:     }
0: 
0:     public long getMessagesCached() {
0:         return getDestinationStatistics().getMessagesCached().getCount();
0:     }
0: 
0:     public int getMemoryPercentageUsed() {
0:         return getUsageManager().getPercentUsage();
0:     }
0: 
0:     public long getMemoryLimit() {
0:         return getUsageManager().getLimit();
0:     }
0: 
0:     public void setMemoryLimit(long limit) {
0:         getUsageManager().setLimit(limit);
0:     }
0:     
0:     
commit:d680ba1
/////////////////////////////////////////////////////////////////////////
0:     public String getDestination() {
0:         return destination.getPhysicalName();
0:     }
0:     
commit:88203ae
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
0: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
0:     private DeadLetterStrategy deadLetterStrategy = new SharedDeadLetterStrategy();
/////////////////////////////////////////////////////////////////////////
0:     public DeadLetterStrategy getDeadLetterStrategy() {
0:         return deadLetterStrategy;
0:     }
0: 
0:     public void setDeadLetterStrategy(DeadLetterStrategy deadLetterStrategy) {
0:         this.deadLetterStrategy = deadLetterStrategy;
0:     }
0: 
commit:27f7cab
/////////////////////////////////////////////////////////////////////////
0:     private boolean sendAdvisoryIfNoConsumers;
/////////////////////////////////////////////////////////////////////////
0:                     ActiveMQTopic advisoryTopic = AdvisorySupport.getNoTopicConsumersAdvisoryTopic(originalDestination);
commit:c2408b8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.advisory.AdvisorySupport;
0: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
0:     private boolean sendAdvisoryIfNoConsumers = true;
0:     public Topic(ActiveMQDestination destination, TopicMessageStore store, UsageManager memoryManager, DestinationStatistics parentStats,
0:             TaskRunnerFactory taskFactory) {
/////////////////////////////////////////////////////////////////////////
0:         if (context.isProducerFlowControl())
0: 
0: 
0: 
0: 
0: 
0:         }
0:         finally {
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     public boolean isSendAdvisoryIfNoConsumers() {
0:         return sendAdvisoryIfNoConsumers;
0:     }
0: 
0:     public void setSendAdvisoryIfNoConsumers(boolean sendAdvisoryIfNoConsumers) {
0:         this.sendAdvisoryIfNoConsumers = sendAdvisoryIfNoConsumers;
0:     }
0: 
0:     public MessageStore getMessageStore() {
0:         return store;
0:     }
0: 
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
1:             if (!subscriptionRecoveryPolicy.add(context, message)) {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Provides a hook to allow messages with no consumer to be processed in
0:      * some way - such as to send to a dead letter queue or something..
0:     protected void onMessageWithNoConsumers(ConnectionContext context, Message message) throws Throwable {
0:         if (!message.isPersistent()) {
0:             if (sendAdvisoryIfNoConsumers) {
0:                 // allow messages with no consumers to be dispatched to a dead
0:                 // letter queue
0:                 ActiveMQDestination originalDestination = message.getDestination();
0:                 if (!AdvisorySupport.isAdvisoryTopic(originalDestination)) {
0:                     ActiveMQTopic advisoryTopic = AdvisorySupport.getExpiredTopicMessageAdvisoryTopic(originalDestination);
0:                     message.setDestination(advisoryTopic);
0:                     context.getBroker().send(context, message);
0:                 }
0:             }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:b743552
/////////////////////////////////////////////////////////////////////////
0:                 while( !usageManager.waitForSpace(1000) ) {
0:                     if( context.getStopping().get() )
0:                         throw new IOException("Connection closed, send aborted.");
0:                 }            	
commit:49ea0ed
/////////////////////////////////////////////////////////////////////////
0:     	if (context.isProducerFlowControl()  && !context.isNetworkConnection() ) {
commit:ccf3f3c
/////////////////////////////////////////////////////////////////////////
0:         
0:         //let's copy the enabled property from the parent DestinationStatistics
0:         this.destinationStatistics.setEnabled(parentStats.isEnabled());
commit:36de58b
/////////////////////////////////////////////////////////////////////////
author:Patrick Edward Lapus Villacorta
-------------------------------------------------------------------------------
commit:91bcbda
/////////////////////////////////////////////////////////////////////////
0:         destinationStatistics.getConsumers().increment();
0: 
/////////////////////////////////////////////////////////////////////////
0:             Object removed = durableSubcribers.remove(key);
0:             if(removed != null) {
0:                 destinationStatistics.getConsumers().decrement();
0:             }
============================================================================