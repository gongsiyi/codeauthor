3:40a7d3b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b0c2a40:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
6:40a7d3b:  *
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:40a7d3b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:40a7d3b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:40a7d3b:  * See the License for the specific language governing permissions and
1:40a7d3b:  * limitations under the License.
1:92a698f:  */
1:fd4bb60: package org.apache.activemq.ra;
2:ba1bd26: 
1:464402c: import org.apache.activemq.ActiveMQConnection;
1:464402c: import org.apache.activemq.ActiveMQSession;
1:eb6c082: import org.apache.activemq.command.ActiveMQMessage;
1:519d8f7: import org.apache.activemq.command.ActiveMQTextMessage;
1:eb6c082: import org.apache.activemq.command.ConsumerId;
1:519d8f7: import org.apache.activemq.command.MessageDispatch;
1:eb6c082: import org.apache.activemq.command.MessageId;
1:5ebee0a: import org.apache.activemq.command.TransactionInfo;
1:eb6c082: import org.apache.activemq.util.Wait;
1:519d8f7: import org.hamcrest.Description;
1:114706a: import org.hamcrest.Matchers;
1:8274f09: import org.jmock.Expectations;
1:8274f09: import org.jmock.Mockery;
1:519d8f7: import org.jmock.api.Action;
1:519d8f7: import org.jmock.api.Invocation;
1:8274f09: import org.jmock.integration.junit4.JMock;
1:8274f09: import org.jmock.lib.legacy.ClassImposteriser;
1:519d8f7: import org.junit.After;
1:8274f09: import org.junit.Before;
1:8274f09: import org.junit.Test;
1:8274f09: import org.junit.runner.RunWith;
1:519d8f7: import org.slf4j.Logger;
1:519d8f7: import org.slf4j.LoggerFactory;
1:ba1bd26: 
1:5ebee0a: import javax.jms.JMSException;
1:5ebee0a: import javax.jms.Session;
1:5ebee0a: import javax.resource.spi.BootstrapContext;
1:5ebee0a: import javax.resource.spi.endpoint.MessageEndpointFactory;
1:5ebee0a: import javax.resource.spi.work.ExecutionContext;
1:5ebee0a: import javax.resource.spi.work.Work;
1:5ebee0a: import javax.resource.spi.work.WorkListener;
1:5ebee0a: import javax.resource.spi.work.WorkManager;
1:5ebee0a: import javax.transaction.xa.XAResource;
1:5ebee0a: import java.lang.reflect.Method;
1:5ebee0a: import java.util.concurrent.CountDownLatch;
1:5ebee0a: import java.util.concurrent.ExecutorService;
1:5ebee0a: import java.util.concurrent.Executors;
1:5ebee0a: import java.util.concurrent.TimeUnit;
1:5ebee0a: import java.util.concurrent.atomic.AtomicBoolean;
1:5ebee0a: import java.util.concurrent.atomic.AtomicReference;
1:5ebee0a: 
1:5ebee0a: import static org.junit.Assert.assertTrue;
1:5ebee0a: 
1:8274f09: @RunWith(JMock.class)
1:ba1bd26: public class ServerSessionImplTest {
1:ba1bd26: 
1:519d8f7:     private static final Logger LOG = LoggerFactory.getLogger(ServerSessionImplTest.class);
1:519d8f7:     private static final String BROKER_URL = "vm://localhost?broker.persistent=false";
1:ba1bd26: 
1:464402c:     private ServerSessionImpl serverSession;
1:8274f09:     private ServerSessionPoolImpl pool;
1:8274f09:     private WorkManager workManager;
1:519d8f7:     private MessageEndpointProxy messageEndpoint;
1:464402c:     private ActiveMQConnection con;
1:464402c:     private ActiveMQSession session;
1:ba1bd26:     private ActiveMQEndpointWorker endpointWorker;
1:8274f09:     private Mockery context;
1:ba1bd26: 
1:8274f09:     @Before
1:ba1bd26:     public void setUp() throws Exception {
1:ba1bd26:         context = new Mockery() {
1:ba1bd26:             {
1:ba1bd26:                 setImposteriser(ClassImposteriser.INSTANCE);
1:ba1bd26:             }
1:ba1bd26:         };
1:519d8f7: 
1:ba1bd26:         org.apache.activemq.ActiveMQConnectionFactory factory = new org.apache.activemq.ActiveMQConnectionFactory(BROKER_URL);
1:464402c:         con = (ActiveMQConnection) factory.createConnection();
1:519d8f7:         con.start();
1:464402c:         session = (ActiveMQSession) con.createSession(false, Session.AUTO_ACKNOWLEDGE);
3:ba1bd26:     }
1:519d8f7: 
1:519d8f7:     @After
1:519d8f7:     public void tearDown() throws Exception {
1:519d8f7:         if (con != null) {
1:519d8f7:             con.close();
1:519d8f7:         }
1:519d8f7:     }
1:519d8f7: 
1:8274f09:     @Test
1:464402c:     public void testRunDetectsStoppedSession() throws Exception {
1:519d8f7: 
1:519d8f7:         pool = context.mock(ServerSessionPoolImpl.class);
1:519d8f7:         workManager = context.mock(WorkManager.class);
1:519d8f7:         messageEndpoint = context.mock(MessageEndpointProxy.class);
1:519d8f7: 
1:ba1bd26:         serverSession = new ServerSessionImpl(pool, session, workManager, messageEndpoint, false, 10);
1:519d8f7: 
1:464402c:         con.close();
1:ba1bd26:         context.checking(new Expectations() {
1:ba1bd26:             {
1:ba1bd26:                 oneOf(pool).removeFromPool(with(same(serverSession)));
1:ba1bd26:             }
1:ba1bd26:         });
1:464402c:         serverSession.run();
1:ba1bd26:     }
1:519d8f7: 
1:519d8f7:     @Test
1:519d8f7:     public void testCloseCanStopActiveSession() throws Exception {
1:519d8f7: 
1:519d8f7:         final int maxMessages = 4000;
1:519d8f7:         final CountDownLatch messageCount = new CountDownLatch(maxMessages);
1:519d8f7: 
1:519d8f7:         final MessageEndpointFactory messageEndpointFactory = context.mock(MessageEndpointFactory.class);
1:519d8f7:         final MessageResourceAdapter resourceAdapter = context.mock(MessageResourceAdapter.class);
1:519d8f7:         final ActiveMQEndpointActivationKey key = context.mock(ActiveMQEndpointActivationKey.class);
1:519d8f7:         messageEndpoint = context.mock(MessageEndpointProxy.class);
1:519d8f7:         workManager = context.mock(WorkManager.class);
1:519d8f7:         final MessageActivationSpec messageActivationSpec = context.mock(MessageActivationSpec.class);
1:519d8f7:         final BootstrapContext boostrapContext = context.mock(BootstrapContext.class);
1:ba1bd26:         context.checking(new Expectations() {
1:ba1bd26:             {
1:ba1bd26:                 allowing(boostrapContext).getWorkManager();
1:ba1bd26:                 will(returnValue(workManager));
1:ba1bd26:                 allowing(resourceAdapter).getBootstrapContext();
1:ba1bd26:                 will(returnValue(boostrapContext));
1:ba1bd26:                 allowing(messageEndpointFactory).isDeliveryTransacted(with(any(Method.class)));
1:ba1bd26:                 will(returnValue(Boolean.FALSE));
1:ba1bd26:                 allowing(key).getMessageEndpointFactory();
1:ba1bd26:                 will(returnValue(messageEndpointFactory));
1:ba1bd26:                 allowing(key).getActivationSpec();
1:ba1bd26:                 will(returnValue(messageActivationSpec));
1:ba1bd26:                 allowing(messageActivationSpec).isUseJndi();
1:ba1bd26:                 will(returnValue(Boolean.FALSE));
1:ba1bd26:                 allowing(messageActivationSpec).getDestinationType();
1:ba1bd26:                 will(returnValue("javax.jms.Queue"));
1:ba1bd26:                 allowing(messageActivationSpec).getDestination();
1:ba1bd26:                 will(returnValue("Queue"));
1:ba1bd26:                 allowing(messageActivationSpec).getAcknowledgeModeForSession();
1:ba1bd26:                 will(returnValue(1));
1:ba1bd26:                 allowing(messageActivationSpec).getMaxSessionsIntValue();
1:ba1bd26:                 will(returnValue(1));
1:ba1bd26:                 allowing(messageActivationSpec).getEnableBatchBooleanValue();
1:ba1bd26:                 will(returnValue(Boolean.FALSE));
1:ba1bd26:                 allowing(messageActivationSpec).isUseRAManagedTransactionEnabled();
1:ba1bd26:                 will(returnValue(Boolean.TRUE));
1:ba1bd26:                 allowing(messageEndpointFactory).createEndpoint(with(any(XAResource.class)));
1:ba1bd26:                 will(returnValue(messageEndpoint));
1:519d8f7: 
1:114706a:                 allowing(workManager).scheduleWork((Work) with(Matchers.instanceOf(Work.class)), with(any(long.class)), with(any(ExecutionContext.class)),
1:ba1bd26:                     with(any(WorkListener.class)));
1:ba1bd26:                 will(new Action() {
1:519d8f7:                     @Override
1:519d8f7:                     public Object invoke(Invocation invocation) throws Throwable {
1:519d8f7:                         return null;
1:519d8f7:                     }
1:519d8f7: 
1:519d8f7:                     @Override
1:519d8f7:                     public void describeTo(Description description) {
1:519d8f7:                     }
1:519d8f7:                 });
1:519d8f7: 
1:114706a:                 allowing(messageEndpoint).beforeDelivery((Method) with(Matchers.instanceOf(Method.class)));
1:ba1bd26:                 allowing(messageEndpoint).onMessage(with(any(javax.jms.Message.class)));
1:ba1bd26:                 will(new Action() {
1:519d8f7:                     @Override
1:519d8f7:                     public Object invoke(Invocation invocation) throws Throwable {
1:519d8f7:                         messageCount.countDown();
1:519d8f7:                         if (messageCount.getCount() < maxMessages - 11) {
1:519d8f7:                             TimeUnit.MILLISECONDS.sleep(200);
1:519d8f7:                         }
1:519d8f7:                         return null;
1:519d8f7:                     }
1:519d8f7: 
1:519d8f7:                     @Override
1:519d8f7:                     public void describeTo(Description description) {
1:519d8f7:                         description.appendText("Keep message count");
1:519d8f7:                     }
1:519d8f7:                 });
1:519d8f7:                 allowing(messageEndpoint).afterDelivery();
1:519d8f7:                 allowing(messageEndpoint).release();
1:519d8f7: 
1:ba1bd26:             }
3:ba1bd26:         });
1:519d8f7: 
1:519d8f7:         endpointWorker = new ActiveMQEndpointWorker(resourceAdapter, key);
1:519d8f7:         endpointWorker.setConnection(con);
1:519d8f7:         pool = new ServerSessionPoolImpl(endpointWorker, 2);
1:519d8f7: 
1:519d8f7:         endpointWorker.start();
1:519d8f7:         final ServerSessionImpl serverSession1 = (ServerSessionImpl) pool.getServerSession();
1:519d8f7: 
1:519d8f7:         // preload the session dispatch queue to keep the session active
1:519d8f7:         ActiveMQSession session1 = (ActiveMQSession) serverSession1.getSession();
1:ba1bd26:         for (int i = 0; i < maxMessages; i++) {
1:ba1bd26:             MessageDispatch messageDispatch = new MessageDispatch();
1:eb6c082:             ActiveMQMessage message = new ActiveMQTextMessage();
1:eb6c082:             message.setMessageId(new MessageId("0:0:0:" + i));
1:eb6c082:             message.getMessageId().setBrokerSequenceId(i);
1:eb6c082:             messageDispatch.setMessage(message);
1:eb6c082:             messageDispatch.setConsumerId(new ConsumerId("0:0:0"));
1:519d8f7:             session1.dispatch(messageDispatch);
1:519d8f7:         }
1:519d8f7: 
1:519d8f7:         ExecutorService executorService = Executors.newCachedThreadPool();
1:519d8f7:         final CountDownLatch runState = new CountDownLatch(1);
1:ba1bd26:         executorService.execute(new Runnable() {
1:5ebee0a:             @Override
1:519d8f7:             public void run() {
1:519d8f7:                 try {
1:519d8f7:                     serverSession1.run();
1:519d8f7:                     runState.countDown();
1:519d8f7:                 } catch (Exception e) {
1:519d8f7:                     e.printStackTrace();
1:519d8f7:                 }
1:519d8f7:             }
1:519d8f7:         });
1:519d8f7: 
1:eb6c082:         Wait.waitFor(new Wait.Condition() {
1:eb6c082:             @Override
1:eb6c082:             public boolean isSatisified() throws Exception {
1:eb6c082:                 return messageCount.getCount() < maxMessages - 10;
1:eb6c082:             }
1:eb6c082:         });
1:eb6c082:         assertTrue("some messages consumed", messageCount.getCount() < maxMessages);
1:519d8f7:         LOG.info("Closing pool on {}", messageCount.getCount());
1:519d8f7:         pool.close();
1:5ebee0a: 
1:519d8f7:         assertTrue("run has completed", runState.await(20, TimeUnit.SECONDS));
1:519d8f7:         assertTrue("not all messages consumed", messageCount.getCount() > 0);
1:519d8f7:     }
1:5ebee0a: 
1:5ebee0a:     @Test
1:5ebee0a:     public void testGetWhenClosed() throws Exception {
1:5ebee0a: 
1:5ebee0a:         final int maxMessages = 2000;
1:5ebee0a:         final AtomicReference<CountDownLatch> messageCountRef = new AtomicReference<CountDownLatch>();
1:5ebee0a: 
1:5ebee0a:         ExecutorService executorService = Executors.newCachedThreadPool();
1:5ebee0a: 
1:5ebee0a: 
1:5ebee0a:         final MessageEndpointFactory messageEndpointFactory = context.mock(MessageEndpointFactory.class);
1:5ebee0a:         final MessageResourceAdapter resourceAdapter = context.mock(MessageResourceAdapter.class);
1:5ebee0a:         final ActiveMQEndpointActivationKey key = context.mock(ActiveMQEndpointActivationKey.class);
1:5ebee0a:         messageEndpoint = context.mock(MessageEndpointProxy.class);
1:5ebee0a:         workManager = context.mock(WorkManager.class);
1:5ebee0a:         final MessageActivationSpec messageActivationSpec = context.mock(MessageActivationSpec.class);
1:5ebee0a:         final BootstrapContext boostrapContext = context.mock(BootstrapContext.class);
1:5ebee0a:         context.checking(new Expectations() {
1:5ebee0a:             {
1:5ebee0a:                 allowing(boostrapContext).getWorkManager();
1:5ebee0a:                 will(returnValue(workManager));
1:5ebee0a:                 allowing(resourceAdapter).getBootstrapContext();
1:5ebee0a:                 will(returnValue(boostrapContext));
1:5ebee0a:                 allowing(messageEndpointFactory).isDeliveryTransacted(with(any(Method.class)));
1:5ebee0a:                 will(returnValue(Boolean.FALSE));
1:5ebee0a:                 allowing(key).getMessageEndpointFactory();
1:5ebee0a:                 will(returnValue(messageEndpointFactory));
1:5ebee0a:                 allowing(key).getActivationSpec();
1:5ebee0a:                 will(returnValue(messageActivationSpec));
1:5ebee0a:                 allowing(messageActivationSpec).isUseJndi();
1:5ebee0a:                 will(returnValue(Boolean.FALSE));
1:5ebee0a:                 allowing(messageActivationSpec).getDestinationType();
1:5ebee0a:                 will(returnValue("javax.jms.Queue"));
1:5ebee0a:                 allowing(messageActivationSpec).getDestination();
1:5ebee0a:                 will(returnValue("Queue"));
1:5ebee0a:                 allowing(messageActivationSpec).getAcknowledgeModeForSession();
1:5ebee0a:                 will(returnValue(1));
1:5ebee0a:                 allowing(messageActivationSpec).getMaxSessionsIntValue();
1:5ebee0a:                 will(returnValue(10));
1:5ebee0a:                 allowing(messageActivationSpec).getEnableBatchBooleanValue();
1:5ebee0a:                 will(returnValue(Boolean.FALSE));
1:5ebee0a:                 allowing(messageActivationSpec).isUseRAManagedTransactionEnabled();
1:5ebee0a:                 will(returnValue(Boolean.TRUE));
1:5ebee0a:                 allowing(messageEndpointFactory).createEndpoint(with(any(XAResource.class)));
1:5ebee0a:                 will(returnValue(messageEndpoint));
1:5ebee0a: 
1:5ebee0a:                 allowing(workManager).scheduleWork((Work) with(Matchers.instanceOf(Work.class)), with(any(long.class)), with(any(ExecutionContext.class)),
1:5ebee0a:                         with(any(WorkListener.class)));
1:5ebee0a:                 will(new Action() {
1:5ebee0a:                     @Override
1:5ebee0a:                     public Object invoke(Invocation invocation) throws Throwable {
1:5ebee0a:                         LOG.info("Wok manager invocation: " + invocation);
1:5ebee0a: 
1:5ebee0a:                         if (invocation.getParameter(0) instanceof ServerSessionImpl) {
1:5ebee0a:                             final ServerSessionImpl serverSession1 = (ServerSessionImpl)invocation.getParameter(0);
1:5ebee0a:                             executorService.execute(new Runnable() {
1:5ebee0a:                                 @Override
1:5ebee0a:                                 public void run() {
1:5ebee0a:                                     try {
1:5ebee0a:                                         serverSession1.run();
1:5ebee0a:                                     } catch (Exception e) {
1:5ebee0a:                                         LOG.error("Error on Work run: {}", serverSession1, e);
1:5ebee0a:                                         e.printStackTrace();
1:5ebee0a:                                     }
1:5ebee0a:                                 }
1:5ebee0a:                             });
1:5ebee0a:                         }
1:5ebee0a:                         return null;
1:5ebee0a:                     }
1:5ebee0a: 
1:5ebee0a:                     @Override
1:5ebee0a:                     public void describeTo(Description description) {
1:5ebee0a:                     }
1:5ebee0a:                 });
1:5ebee0a: 
1:5ebee0a:                 allowing(messageEndpoint).beforeDelivery((Method) with(Matchers.instanceOf(Method.class)));
1:5ebee0a:                 allowing(messageEndpoint).onMessage(with(any(javax.jms.Message.class)));
1:5ebee0a:                 will(new Action() {
1:5ebee0a:                     @Override
1:5ebee0a:                     public Object invoke(Invocation invocation) throws Throwable {
1:5ebee0a:                         messageCountRef.get().countDown();
1:5ebee0a:                         return null;
1:5ebee0a:                     }
1:5ebee0a: 
1:5ebee0a:                     @Override
1:5ebee0a:                     public void describeTo(Description description) {
1:5ebee0a:                         description.appendText("Keep message count");
1:5ebee0a:                     }
1:5ebee0a:                 });
1:5ebee0a:                 allowing(messageEndpoint).afterDelivery();
1:5ebee0a:                 will(new Action() {
1:519d8f7:                     @Override
1:5ebee0a:                     public void describeTo(Description description) {
1:5ebee0a:                         description.appendText("do sync work on broker");
1:5ebee0a:                     }
1:5ebee0a: 
1:5ebee0a:                     @Override
1:5ebee0a:                     public Object invoke(Invocation invocation) throws Throwable {
1:5ebee0a:                         TransactionInfo transactionInfo = new TransactionInfo();
1:5ebee0a:                         transactionInfo.setType(TransactionInfo.END);
1:5ebee0a:                         LOG.info("AfterDelivery on: " + messageCountRef.get().getCount());
1:5ebee0a:                         return null;
1:5ebee0a:                     }
1:5ebee0a:                 });
1:5ebee0a:                 allowing(messageEndpoint).release();
1:5ebee0a: 
1:5ebee0a:             }
1:5ebee0a:         });
1:5ebee0a: 
1:5ebee0a:         endpointWorker = new ActiveMQEndpointWorker(resourceAdapter, key);
1:5ebee0a:         endpointWorker.setConnection(con);
1:5ebee0a: 
1:5ebee0a: 
1:5ebee0a:         for (int i=0; i<40; i++) {
1:5ebee0a:             final int iteration  = i;
1:5ebee0a:             LOG.info("ITERATION: " +  iteration);
1:5ebee0a:             pool = new ServerSessionPoolImpl(endpointWorker, 2);
1:5ebee0a:             endpointWorker.start();
1:5ebee0a: 
1:5ebee0a:             messageCountRef.set(new CountDownLatch(maxMessages));
1:5ebee0a: 
1:5ebee0a:             final CountDownLatch senderDone = new CountDownLatch(1);
1:5ebee0a:             final CountDownLatch messageSent = new CountDownLatch(maxMessages);
1:5ebee0a:             final AtomicBoolean foundClosedSession = new AtomicBoolean(false);
1:5ebee0a:             executorService.execute(new Runnable() {
1:5ebee0a:                 @Override
1:5ebee0a:                 public void run() {
1:5ebee0a:                     try {
1:5ebee0a:                         // preload the session dispatch queue to keep the session active
1:5ebee0a: 
1:5ebee0a:                         for (int i = 0; i < maxMessages; i++) {
1:5ebee0a:                             MessageDispatch messageDispatch = new MessageDispatch();
1:5ebee0a:                             ActiveMQMessage message = new ActiveMQTextMessage();
1:5ebee0a:                             message.setMessageId(new MessageId("0:0:0:" + i));
1:5ebee0a:                             message.getMessageId().setBrokerSequenceId(i);
1:5ebee0a:                             messageDispatch.setMessage(message);
1:5ebee0a:                             messageDispatch.setConsumerId(new ConsumerId("0:0:0"));
1:5ebee0a:                             ServerSessionImpl serverSession1 = null;
1:5ebee0a:                             try {
1:5ebee0a:                                 serverSession1 = (ServerSessionImpl) pool.getServerSession();
1:5ebee0a:                                 ActiveMQSession session1 = (ActiveMQSession) serverSession1.getSession();
1:5ebee0a:                                 if (session1.isClosed()) {
1:5ebee0a:                                     // closed flag is not volatile - ok to give a whirl with it closed
1:5ebee0a:                                     foundClosedSession.set(true);
1:5ebee0a:                                 }
1:5ebee0a:                                 session1.dispatch(messageDispatch);
1:5ebee0a:                                 messageSent.countDown();
1:5ebee0a:                                 serverSession1.start();
1:5ebee0a:                             } catch (JMSException okOnClose) {
1:5ebee0a:                                 LOG.info("Exception on dispatch to {}", serverSession1, okOnClose);
1:5ebee0a:                             }
1:5ebee0a:                         }
1:5ebee0a:                     } catch (Throwable e) {
1:5ebee0a:                         e.printStackTrace();
1:5ebee0a:                     } finally {
1:5ebee0a:                         senderDone.countDown();
1:5ebee0a:                     }
1:5ebee0a:                 }
1:5ebee0a:             });
1:5ebee0a: 
1:5ebee0a:             assertTrue("[" + iteration + "] Some messages dispatched", Wait.waitFor(new Wait.Condition() {
1:5ebee0a:                 @Override
1:5ebee0a:                 public boolean isSatisified() throws Exception {
1:5ebee0a:                     LOG.info("[" + iteration + "] Wait before close work MessageSent: " + messageSent.getCount() + ", messages got: "+ messageCountRef.get().getCount());
1:5ebee0a:                     return messageSent.getCount() < maxMessages - 20 && messageCountRef.get().getCount() < maxMessages - 5;
1:5ebee0a:                 }
1:5ebee0a:             }, 5000, 10));
1:5ebee0a: 
1:5ebee0a:             assertTrue("some messages consumed", messageCountRef.get().getCount() < maxMessages);
1:5ebee0a: 
1:5ebee0a:             final CountDownLatch closeDone = new CountDownLatch(1);
1:5ebee0a:             final CountDownLatch closeSuccess = new CountDownLatch(1);
1:5ebee0a: 
1:5ebee0a:             executorService.execute(new Runnable() {
1:5ebee0a:                 @Override
1:5ebee0a:                 public void run() {
1:5ebee0a:                     LOG.info("[" + iteration + "] Closing pool on delivered {} and dispatched {}", messageSent.getCount(), messageCountRef.get().getCount());
1:5ebee0a:                     try {
1:5ebee0a:                         pool.close();
1:5ebee0a:                         closeSuccess.countDown();
1:5ebee0a:                     } catch (InvalidMessageEndpointException error) {
1:5ebee0a:                         LOG.error("Ex on pool close", error);
1:5ebee0a:                         //error.printStackTrace();
1:5ebee0a:                     } finally {
1:5ebee0a:                         closeDone.countDown();
1:5ebee0a:                     }
1:5ebee0a:                 }
1:5ebee0a:             });
1:5ebee0a: 
1:5ebee0a:             assertTrue("[" + iteration + "] Pool close does not block", closeDone.await(10, TimeUnit.SECONDS));
1:5ebee0a:             assertTrue("[" + iteration + "] Pool close ok", closeSuccess.await(10, TimeUnit.MILLISECONDS));
1:5ebee0a: 
1:5ebee0a:             assertTrue("[" + iteration + "] sender complete", senderDone.await(30, TimeUnit.SECONDS));
1:5ebee0a:         }
1:5ebee0a:     }
1:5ebee0a: 
1:519d8f7: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:8fd1075
/////////////////////////////////////////////////////////////////////////
commit:5ebee0a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.TransactionInfo;
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.JMSException;
1: import javax.jms.Session;
1: import javax.resource.spi.BootstrapContext;
1: import javax.resource.spi.endpoint.MessageEndpointFactory;
1: import javax.resource.spi.work.ExecutionContext;
1: import javax.resource.spi.work.Work;
1: import javax.resource.spi.work.WorkListener;
1: import javax.resource.spi.work.WorkManager;
1: import javax.transaction.xa.XAResource;
1: import java.lang.reflect.Method;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import static org.junit.Assert.assertTrue;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testGetWhenClosed() throws Exception {
1: 
1:         final int maxMessages = 2000;
1:         final AtomicReference<CountDownLatch> messageCountRef = new AtomicReference<CountDownLatch>();
1: 
1:         ExecutorService executorService = Executors.newCachedThreadPool();
1: 
1: 
1:         final MessageEndpointFactory messageEndpointFactory = context.mock(MessageEndpointFactory.class);
1:         final MessageResourceAdapter resourceAdapter = context.mock(MessageResourceAdapter.class);
1:         final ActiveMQEndpointActivationKey key = context.mock(ActiveMQEndpointActivationKey.class);
1:         messageEndpoint = context.mock(MessageEndpointProxy.class);
1:         workManager = context.mock(WorkManager.class);
1:         final MessageActivationSpec messageActivationSpec = context.mock(MessageActivationSpec.class);
1:         final BootstrapContext boostrapContext = context.mock(BootstrapContext.class);
1:         context.checking(new Expectations() {
1:             {
1:                 allowing(boostrapContext).getWorkManager();
1:                 will(returnValue(workManager));
1:                 allowing(resourceAdapter).getBootstrapContext();
1:                 will(returnValue(boostrapContext));
1:                 allowing(messageEndpointFactory).isDeliveryTransacted(with(any(Method.class)));
1:                 will(returnValue(Boolean.FALSE));
1:                 allowing(key).getMessageEndpointFactory();
1:                 will(returnValue(messageEndpointFactory));
1:                 allowing(key).getActivationSpec();
1:                 will(returnValue(messageActivationSpec));
1:                 allowing(messageActivationSpec).isUseJndi();
1:                 will(returnValue(Boolean.FALSE));
1:                 allowing(messageActivationSpec).getDestinationType();
1:                 will(returnValue("javax.jms.Queue"));
1:                 allowing(messageActivationSpec).getDestination();
1:                 will(returnValue("Queue"));
1:                 allowing(messageActivationSpec).getAcknowledgeModeForSession();
1:                 will(returnValue(1));
1:                 allowing(messageActivationSpec).getMaxSessionsIntValue();
1:                 will(returnValue(10));
1:                 allowing(messageActivationSpec).getEnableBatchBooleanValue();
1:                 will(returnValue(Boolean.FALSE));
1:                 allowing(messageActivationSpec).isUseRAManagedTransactionEnabled();
1:                 will(returnValue(Boolean.TRUE));
1:                 allowing(messageEndpointFactory).createEndpoint(with(any(XAResource.class)));
1:                 will(returnValue(messageEndpoint));
1: 
1:                 allowing(workManager).scheduleWork((Work) with(Matchers.instanceOf(Work.class)), with(any(long.class)), with(any(ExecutionContext.class)),
1:                         with(any(WorkListener.class)));
1:                 will(new Action() {
1:                     @Override
1:                     public Object invoke(Invocation invocation) throws Throwable {
1:                         LOG.info("Wok manager invocation: " + invocation);
1: 
1:                         if (invocation.getParameter(0) instanceof ServerSessionImpl) {
1:                             final ServerSessionImpl serverSession1 = (ServerSessionImpl)invocation.getParameter(0);
1:                             executorService.execute(new Runnable() {
1:                                 @Override
1:                                 public void run() {
1:                                     try {
1:                                         serverSession1.run();
1:                                     } catch (Exception e) {
1:                                         LOG.error("Error on Work run: {}", serverSession1, e);
1:                                         e.printStackTrace();
1:                                     }
1:                                 }
1:                             });
1:                         }
1:                         return null;
1:                     }
1: 
1:                     @Override
1:                     public void describeTo(Description description) {
1:                     }
1:                 });
1: 
1:                 allowing(messageEndpoint).beforeDelivery((Method) with(Matchers.instanceOf(Method.class)));
1:                 allowing(messageEndpoint).onMessage(with(any(javax.jms.Message.class)));
1:                 will(new Action() {
1:                     @Override
1:                     public Object invoke(Invocation invocation) throws Throwable {
1:                         messageCountRef.get().countDown();
1:                         return null;
1:                     }
1: 
1:                     @Override
1:                     public void describeTo(Description description) {
1:                         description.appendText("Keep message count");
1:                     }
1:                 });
1:                 allowing(messageEndpoint).afterDelivery();
1:                 will(new Action() {
1:                     @Override
1:                     public void describeTo(Description description) {
1:                         description.appendText("do sync work on broker");
1:                     }
1: 
1:                     @Override
1:                     public Object invoke(Invocation invocation) throws Throwable {
1:                         TransactionInfo transactionInfo = new TransactionInfo();
1:                         transactionInfo.setType(TransactionInfo.END);
1:                         LOG.info("AfterDelivery on: " + messageCountRef.get().getCount());
1:                         return null;
1:                     }
1:                 });
1:                 allowing(messageEndpoint).release();
1: 
1:             }
1:         });
1: 
1:         endpointWorker = new ActiveMQEndpointWorker(resourceAdapter, key);
1:         endpointWorker.setConnection(con);
1: 
1: 
1:         for (int i=0; i<40; i++) {
1:             final int iteration  = i;
1:             LOG.info("ITERATION: " +  iteration);
1:             pool = new ServerSessionPoolImpl(endpointWorker, 2);
1:             endpointWorker.start();
1: 
1:             messageCountRef.set(new CountDownLatch(maxMessages));
1: 
1:             final CountDownLatch senderDone = new CountDownLatch(1);
1:             final CountDownLatch messageSent = new CountDownLatch(maxMessages);
1:             final AtomicBoolean foundClosedSession = new AtomicBoolean(false);
1:             executorService.execute(new Runnable() {
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         // preload the session dispatch queue to keep the session active
1: 
1:                         for (int i = 0; i < maxMessages; i++) {
1:                             MessageDispatch messageDispatch = new MessageDispatch();
1:                             ActiveMQMessage message = new ActiveMQTextMessage();
1:                             message.setMessageId(new MessageId("0:0:0:" + i));
1:                             message.getMessageId().setBrokerSequenceId(i);
1:                             messageDispatch.setMessage(message);
1:                             messageDispatch.setConsumerId(new ConsumerId("0:0:0"));
1:                             ServerSessionImpl serverSession1 = null;
1:                             try {
1:                                 serverSession1 = (ServerSessionImpl) pool.getServerSession();
1:                                 ActiveMQSession session1 = (ActiveMQSession) serverSession1.getSession();
1:                                 if (session1.isClosed()) {
1:                                     // closed flag is not volatile - ok to give a whirl with it closed
1:                                     foundClosedSession.set(true);
1:                                 }
1:                                 session1.dispatch(messageDispatch);
1:                                 messageSent.countDown();
1:                                 serverSession1.start();
1:                             } catch (JMSException okOnClose) {
1:                                 LOG.info("Exception on dispatch to {}", serverSession1, okOnClose);
1:                             }
1:                         }
1:                     } catch (Throwable e) {
1:                         e.printStackTrace();
1:                     } finally {
1:                         senderDone.countDown();
1:                     }
1:                 }
1:             });
1: 
1:             assertTrue("[" + iteration + "] Some messages dispatched", Wait.waitFor(new Wait.Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("[" + iteration + "] Wait before close work MessageSent: " + messageSent.getCount() + ", messages got: "+ messageCountRef.get().getCount());
1:                     return messageSent.getCount() < maxMessages - 20 && messageCountRef.get().getCount() < maxMessages - 5;
1:                 }
1:             }, 5000, 10));
1: 
1:             assertTrue("some messages consumed", messageCountRef.get().getCount() < maxMessages);
1: 
1:             final CountDownLatch closeDone = new CountDownLatch(1);
1:             final CountDownLatch closeSuccess = new CountDownLatch(1);
1: 
1:             executorService.execute(new Runnable() {
1:                 @Override
1:                 public void run() {
1:                     LOG.info("[" + iteration + "] Closing pool on delivered {} and dispatched {}", messageSent.getCount(), messageCountRef.get().getCount());
1:                     try {
1:                         pool.close();
1:                         closeSuccess.countDown();
1:                     } catch (InvalidMessageEndpointException error) {
1:                         LOG.error("Ex on pool close", error);
1:                         //error.printStackTrace();
1:                     } finally {
1:                         closeDone.countDown();
1:                     }
1:                 }
1:             });
1: 
1:             assertTrue("[" + iteration + "] Pool close does not block", closeDone.await(10, TimeUnit.SECONDS));
1:             assertTrue("[" + iteration + "] Pool close ok", closeSuccess.await(10, TimeUnit.MILLISECONDS));
1: 
0:             assertTrue("[" + iteration + "] not all delivered", messageCountRef.get().getCount() > 0);
1: 
1:             assertTrue("[" + iteration + "] sender complete", senderDone.await(30, TimeUnit.SECONDS));
1:         }
1:     }
1: 
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:             ActiveMQMessage message = new ActiveMQTextMessage();
1:             message.setMessageId(new MessageId("0:0:0:" + i));
1:             message.getMessageId().setBrokerSequenceId(i);
1:             messageDispatch.setMessage(message);
1:             messageDispatch.setConsumerId(new ConsumerId("0:0:0"));
/////////////////////////////////////////////////////////////////////////
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return messageCount.getCount() < maxMessages - 10;
1:             }
1:         });
1:         assertTrue("some messages consumed", messageCount.getCount() < maxMessages);
commit:519d8f7
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Method;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
0: import javax.resource.spi.BootstrapContext;
0: import javax.resource.spi.endpoint.MessageEndpointFactory;
0: import javax.resource.spi.work.ExecutionContext;
0: import javax.resource.spi.work.Work;
0: import javax.resource.spi.work.WorkListener;
0: import javax.transaction.xa.XAResource;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.hamcrest.Description;
1: import org.jmock.api.Action;
1: import org.jmock.api.Invocation;
1: import org.junit.After;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ServerSessionImplTest.class);
1:     private static final String BROKER_URL = "vm://localhost?broker.persistent=false";
1:     private MessageEndpointProxy messageEndpoint;
0:     ActiveMQEndpointWorker endpointWorker;
/////////////////////////////////////////////////////////////////////////
1:         con.start();
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         if (con != null) {
1:             con.close();
1:         }
1:     }
1: 
1: 
1:         pool = context.mock(ServerSessionPoolImpl.class);
1:         workManager = context.mock(WorkManager.class);
1:         messageEndpoint = context.mock(MessageEndpointProxy.class);
1: 
0:         serverSession = new ServerSessionImpl(
0:                 (ServerSessionPoolImpl) pool,
0:                 session,
0:                 (WorkManager) workManager,
0:                 messageEndpoint,
0:                 false,
0:                 10);
1: 
0:         }});
1: 
1:     @Test
1:     public void testCloseCanStopActiveSession() throws Exception {
1: 
1:         final int maxMessages = 4000;
1:         final CountDownLatch messageCount = new CountDownLatch(maxMessages);
1: 
1:         final MessageEndpointFactory messageEndpointFactory = context.mock(MessageEndpointFactory.class);
1:         final MessageResourceAdapter resourceAdapter = context.mock(MessageResourceAdapter.class);
1:         final ActiveMQEndpointActivationKey key = context.mock(ActiveMQEndpointActivationKey.class);
1:         messageEndpoint = context.mock(MessageEndpointProxy.class);
1:         workManager = context.mock(WorkManager.class);
1:         final MessageActivationSpec messageActivationSpec = context.mock(MessageActivationSpec.class);
1:         final BootstrapContext boostrapContext = context.mock(BootstrapContext.class);
0:         context.checking(new Expectations() {{
0:             allowing(boostrapContext).getWorkManager(); will (returnValue(workManager));
0:             allowing(resourceAdapter).getBootstrapContext(); will (returnValue(boostrapContext));
0:             allowing(messageEndpointFactory).isDeliveryTransacted(with (any(Method.class))); will(returnValue(Boolean.FALSE));
0:             allowing(key).getMessageEndpointFactory();  will(returnValue(messageEndpointFactory));
0:             allowing(key).getActivationSpec(); will (returnValue(messageActivationSpec));
0:             allowing(messageActivationSpec).isUseJndi(); will (returnValue(Boolean.FALSE));
0:             allowing(messageActivationSpec).getDestinationType(); will (returnValue("javax.jms.Queue"));
0:             allowing(messageActivationSpec).getDestination(); will (returnValue("Queue"));
0:             allowing(messageActivationSpec).getAcknowledgeModeForSession(); will (returnValue(1));
0:             allowing(messageActivationSpec).getMaxSessionsIntValue(); will (returnValue(1));
0:             allowing(messageActivationSpec).getEnableBatchBooleanValue(); will (returnValue(Boolean.FALSE));
0:             allowing(messageActivationSpec).isUseRAManagedTransactionEnabled(); will (returnValue(Boolean.TRUE));
0:             allowing(messageEndpointFactory).createEndpoint(with (any(XAResource.class))); will (returnValue(messageEndpoint));
1: 
0:             allowing(workManager).scheduleWork((Work) with(anything()), (long) with(any(long.class)), with(any(ExecutionContext.class)), with(any(WorkListener.class)));
0:             will (new Action() {
1:                 @Override
1:                 public Object invoke(Invocation invocation) throws Throwable {
1:                     return null;
1:                 }
1: 
1:                 @Override
1:                 public void describeTo(Description description) {
1:                 }
1:             });
1: 
0:             allowing(messageEndpoint).beforeDelivery((Method) with(anything()));
0:             allowing (messageEndpoint).onMessage(with (any(javax.jms.Message.class))); will(new Action(){
1:                 @Override
1:                 public Object invoke(Invocation invocation) throws Throwable {
1:                     messageCount.countDown();
1:                     if (messageCount.getCount() < maxMessages - 11) {
1:                         TimeUnit.MILLISECONDS.sleep(200);
1:                     }
1:                     return null;
1:                 }
1: 
1:                 @Override
1:                 public void describeTo(Description description) {
1:                     description.appendText("Keep message count");
1:                 }
1:             });
1:             allowing(messageEndpoint).afterDelivery();
1:             allowing(messageEndpoint).release();
1: 
0:         }});
1: 
1:         endpointWorker = new ActiveMQEndpointWorker(resourceAdapter, key);
1:         endpointWorker.setConnection(con);
1:         pool = new ServerSessionPoolImpl(endpointWorker, 2);
1: 
1:         endpointWorker.start();
1:         final ServerSessionImpl serverSession1 = (ServerSessionImpl) pool.getServerSession();
1: 
1:         // preload the session dispatch queue to keep the session active
1:         ActiveMQSession session1 = (ActiveMQSession) serverSession1.getSession();
0:         for (int i=0; i<maxMessages; i++) {
0:             MessageDispatch messageDispatch = new  MessageDispatch();
0:             messageDispatch.setMessage(new ActiveMQTextMessage());
1:             session1.dispatch(messageDispatch);
1:         }
1: 
1:         ExecutorService executorService = Executors.newCachedThreadPool();
1:         final CountDownLatch runState = new CountDownLatch(1);
0:         executorService.execute(new Runnable(){
1:             @Override
1:             public void run() {
1:                 try {
1:                     serverSession1.run();
1:                     runState.countDown();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
0:         while (messageCount.getCount() > maxMessages - 10) {
0:             TimeUnit.MILLISECONDS.sleep(100);
1:         }
1:         LOG.info("Closing pool on {}", messageCount.getCount());
1:         pool.close();
1: 
1:         assertTrue("run has completed", runState.await(20, TimeUnit.SECONDS));
1:         assertTrue("not all messages consumed", messageCount.getCount() > 0);
1:     }
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:114706a
/////////////////////////////////////////////////////////////////////////
1: import org.hamcrest.Matchers;
/////////////////////////////////////////////////////////////////////////
1:                 allowing(workManager).scheduleWork((Work) with(Matchers.instanceOf(Work.class)), with(any(long.class)), with(any(ExecutionContext.class)),
/////////////////////////////////////////////////////////////////////////
1:                 allowing(messageEndpoint).beforeDelivery((Method) with(Matchers.instanceOf(Method.class)));
author:Timothy Bish
-------------------------------------------------------------------------------
commit:ba1bd26
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertTrue;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class ServerSessionImplTest {
1: 
1: 
1:     private ActiveMQEndpointWorker endpointWorker;
1: 
1:     public void setUp() throws Exception {
1:         context = new Mockery() {
1:             {
1:                 setImposteriser(ClassImposteriser.INSTANCE);
1:             }
1:         };
1: 
1:         org.apache.activemq.ActiveMQConnectionFactory factory = new org.apache.activemq.ActiveMQConnectionFactory(BROKER_URL);
/////////////////////////////////////////////////////////////////////////
1:         serverSession = new ServerSessionImpl(pool, session, workManager, messageEndpoint, false, 10);
1:         context.checking(new Expectations() {
1:             {
1:                 oneOf(pool).removeFromPool(with(same(serverSession)));
1:             }
1:         });
/////////////////////////////////////////////////////////////////////////
1:         context.checking(new Expectations() {
1:             {
1:                 allowing(boostrapContext).getWorkManager();
1:                 will(returnValue(workManager));
1:                 allowing(resourceAdapter).getBootstrapContext();
1:                 will(returnValue(boostrapContext));
1:                 allowing(messageEndpointFactory).isDeliveryTransacted(with(any(Method.class)));
1:                 will(returnValue(Boolean.FALSE));
1:                 allowing(key).getMessageEndpointFactory();
1:                 will(returnValue(messageEndpointFactory));
1:                 allowing(key).getActivationSpec();
1:                 will(returnValue(messageActivationSpec));
1:                 allowing(messageActivationSpec).isUseJndi();
1:                 will(returnValue(Boolean.FALSE));
1:                 allowing(messageActivationSpec).getDestinationType();
1:                 will(returnValue("javax.jms.Queue"));
1:                 allowing(messageActivationSpec).getDestination();
1:                 will(returnValue("Queue"));
1:                 allowing(messageActivationSpec).getAcknowledgeModeForSession();
1:                 will(returnValue(1));
1:                 allowing(messageActivationSpec).getMaxSessionsIntValue();
1:                 will(returnValue(1));
1:                 allowing(messageActivationSpec).getEnableBatchBooleanValue();
1:                 will(returnValue(Boolean.FALSE));
1:                 allowing(messageActivationSpec).isUseRAManagedTransactionEnabled();
1:                 will(returnValue(Boolean.TRUE));
1:                 allowing(messageEndpointFactory).createEndpoint(with(any(XAResource.class)));
1:                 will(returnValue(messageEndpoint));
0:                 allowing(workManager).scheduleWork((Work) with(anything()), with(any(long.class)), with(any(ExecutionContext.class)),
1:                     with(any(WorkListener.class)));
1:                 will(new Action() {
0:                     @Override
0:                     public Object invoke(Invocation invocation) throws Throwable {
0:                         return null;
0:                     @Override
0:                     public void describeTo(Description description) {
1:                     }
1:                 });
0:                 allowing(messageEndpoint).beforeDelivery((Method) with(anything()));
1:                 allowing(messageEndpoint).onMessage(with(any(javax.jms.Message.class)));
1:                 will(new Action() {
0:                     @Override
0:                     public Object invoke(Invocation invocation) throws Throwable {
0:                         messageCount.countDown();
0:                         if (messageCount.getCount() < maxMessages - 11) {
0:                             TimeUnit.MILLISECONDS.sleep(200);
1:                         }
0:                         return null;
1:                     }
0: 
0:                     @Override
0:                     public void describeTo(Description description) {
0:                         description.appendText("Keep message count");
1:                     }
1:                 });
0:                 allowing(messageEndpoint).afterDelivery();
0:                 allowing(messageEndpoint).release();
0: 
1:             }
1:         });
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < maxMessages; i++) {
1:             MessageDispatch messageDispatch = new MessageDispatch();
/////////////////////////////////////////////////////////////////////////
1:         executorService.execute(new Runnable() {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:fd4bb60
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.ra;
author:Gary Tully
-------------------------------------------------------------------------------
commit:8274f09
/////////////////////////////////////////////////////////////////////////
0: 
0: import junit.framework.TestCase;
0: 
1: import org.jmock.Expectations;
1: import org.jmock.Mockery;
1: import org.jmock.integration.junit4.JMock;
1: import org.jmock.lib.legacy.ClassImposteriser;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: @RunWith(JMock.class)
0: public class ServerSessionImplTest extends TestCase {
1:     private ServerSessionPoolImpl pool;
1:     private WorkManager workManager;
1:     private Mockery context;
1:     @Before
0:     public void setUp() throws Exception
0:         context = new Mockery() {{
0:             setImposteriser(ClassImposteriser.INSTANCE);
0:         }};
0:         
0:         pool = context.mock(ServerSessionPoolImpl.class);        
0:         workManager = context.mock(WorkManager.class);
0:                 (ServerSessionPoolImpl) pool, 
0:                 (WorkManager) workManager, 
1:     @Test
0:         context.checking(new Expectations() {{
0:             oneOf (pool).removeFromPool(with(same(serverSession)));
0:         }});   
0:     }
author:Robert Davies
-------------------------------------------------------------------------------
commit:464402c
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Method;
0: import javax.jms.Message;
0: import javax.jms.MessageListener;
0: import javax.jms.Session;
0: import javax.resource.ResourceException;
0: import javax.resource.spi.endpoint.MessageEndpoint;
0: import javax.resource.spi.work.WorkManager;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQSession;
0: import org.jmock.Mock;
0: import org.jmock.cglib.MockObjectTestCase;
0:     private static final String BROKER_URL = "vm://localhost";
1:     private ServerSessionImpl serverSession;
0:     private Mock pool;
0:     private Mock workManager;
0:     private MessageEndpoint messageEndpoint;
1:     private ActiveMQConnection con;
1:     private ActiveMQSession session;
0:     
0:     @Override
0:     protected void setUp() throws Exception
0:     {
0:         super.setUp();
0:         org.apache.activemq.ActiveMQConnectionFactory factory = 
0:                 new org.apache.activemq.ActiveMQConnectionFactory(BROKER_URL);
1:         con = (ActiveMQConnection) factory.createConnection();
1:         session = (ActiveMQSession) con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         pool = mock(ServerSessionPoolImpl.class, new Class[]{ActiveMQEndpointWorker.class, int.class}, new Object[]{null, 10});        
0:         workManager = mock(WorkManager.class);
0:         messageEndpoint = new MockMessageEndpoint();
0:         
0:         serverSession = new ServerSessionImpl(
0:                 (ServerSessionPoolImpl) pool.proxy(), 
0:                 session, 
0:                 (WorkManager) workManager.proxy(), 
0:                 messageEndpoint, 
0:                 false, 
0:                 10);
0:     }
0:     
0:     private class MockMessageEndpoint implements MessageEndpoint, MessageListener {
0: 
0:         public void afterDelivery() throws ResourceException
0:         {
0:             throw new UnsupportedOperationException("Not supported yet.");
0:         }
0: 
0:         public void beforeDelivery(Method arg0) throws NoSuchMethodException, ResourceException
0:         {
0:             throw new UnsupportedOperationException("Not supported yet.");
0:         }
0: 
0:         public void release()
0:         {
0:             throw new UnsupportedOperationException("Not supported yet.");
0:         }
0: 
0:         public void onMessage(Message msg)
0:         {
0:             throw new UnsupportedOperationException("Not supported yet.");
0:         }
0:         
0:     }
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void testRunDetectsStoppedSession() throws Exception {
1:         con.close();
0:         pool.expects(once()).method("removeFromPool").with(eq(serverSession));
1:         serverSession.run();
0:         pool.verify();
0: }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:92a698f
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2004 The Apache Software Foundation
/////////////////////////////////////////////////////////////////////////
1:  */
author:James Strachan
-------------------------------------------------------------------------------
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005 Guillaume Nodet
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  *
0:  **/
0: package org.activemq.ra;
0: 
0: import org.jmock.MockObjectTestCase;
0: 
1: /**
0:  * @version $Revision: 1.1.1.1 $
0:  */
0: public class ServerSessionImplTest extends MockObjectTestCase {
0:     
1:     /**
0:      * Need to re-work this test case, it broke since the amq4 internals changed and
0:      * mocks were being using against the internals.
1:      *
0:      */
0:     public void testDummy() {
0:     }
0:     
0: /*
0:     public void testBatch() throws Exception {
0:         DummyActiveMQConnection connection = new DummyActiveMQConnection(new ActiveMQConnectionFactory(),
0:                  null,
0:                  null,
0:                  getMockTransportChannel());
0:         ServerSessionPoolImpl pool = new ServerSessionPoolImpl(null, 1);
0:         DummyActiveMQSession session = new DummyActiveMQSession(connection);
0:         MemoryBoundedQueue queue = connection.getMemoryBoundedQueue("Session(" + session.getSessionId() + ")");
0:         queue.enqueue(new ActiveMQTextMessage());
0:         queue.enqueue(new ActiveMQTextMessage());
0:         queue.enqueue(new ActiveMQTextMessage());
0:         DummyMessageEndpoint endpoint = new DummyMessageEndpoint();
0:         ServerSessionImpl serverSession = new ServerSessionImpl(pool, session, null, endpoint, true, 2);
0:         serverSession.run();
0:         assertEquals(2, endpoint.messagesPerBatch.size());
0:         assertEquals(new Integer(2), endpoint.messagesPerBatch.get(0));
0:         assertEquals(new Integer(1), endpoint.messagesPerBatch.get(1));
0:     }
0: 
0:     private class DummyMessageEndpoint implements MessageEndpoint, MessageListener {
0:         protected List messagesPerBatch = new ArrayList();
0:         protected int nbMessages = -1000;
0:         public void beforeDelivery(Method arg0) throws NoSuchMethodException, ResourceException {
0:             nbMessages = 0;
0:         }
0:         public void afterDelivery() throws ResourceException {
0:             messagesPerBatch.add(new Integer(nbMessages));
0:             nbMessages = -1000;
0:         }
0:         public void release() {
0:         }
0:         public void onMessage(Message arg0) {
0:             nbMessages ++;
0:         }
0:     }
0: 
0:     private class DummyActiveMQSession extends ActiveMQSession {
0:         protected DummyActiveMQSession(ActiveMQConnection connection, SessionId sessionId, int acknowledgeMode, boolean asyncDispatch) throws JMSException {
0:             super(connection, sessionId, acknowledgeMode, asyncDispatch);
0:         }
0:     }
0: 
0:     private class DummyActiveMQConnection extends ActiveMQConnection {
0:         protected DummyActiveMQConnection(Transport transport, String userName, String password, JMSStatsImpl factoryStats) throws IOException {
0:             super(transport, userName, password, factoryStats);
0:         }
0:     }
0: 
0:     private TransportChannel getMockTransportChannel() {
0:         Mock tc = new Mock(TransportChannel.class);
0:         tc.expects(once()).method("setPacketListener");
0:         tc.expects(once()).method("setExceptionListener");
0:         tc.expects(once()).method("addTransportStatusEventListener");
0:         tc.expects(atLeastOnce()).method("asyncSend");
0:         tc.expects(atLeastOnce()).method("send");
0:         return (TransportChannel) tc.proxy();
0:     }
0:     */
0: }
============================================================================