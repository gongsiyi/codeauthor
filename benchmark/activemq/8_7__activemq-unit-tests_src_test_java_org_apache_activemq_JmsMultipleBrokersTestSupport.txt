1:579a1d4: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
4:579a1d4:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:579a1d4:  *
1:579a1d4:  * Unless required by applicable law or agreed to in writing, software
1:579a1d4:  * distributed under the License is distributed on an "AS IS" BASIS,
1:579a1d4:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:579a1d4:  * See the License for the specific language governing permissions and
1:579a1d4:  * limitations under the License.
1:579a1d4:  */
1:579a1d4: package org.apache.activemq;
16:579a1d4: 
1:230a86c: import java.net.URI;
1:579a1d4: import java.util.ArrayList;
1:579a1d4: import java.util.Arrays;
1:579a1d4: import java.util.Collection;
1:230a86c: import java.util.Collections;
1:230a86c: import java.util.HashMap;
1:230a86c: import java.util.Iterator;
1:230a86c: import java.util.List;
1:230a86c: import java.util.Map;
1:3070d33: import java.util.concurrent.CountDownLatch;
1:a818270: import java.util.concurrent.TimeUnit;
1:dd0b16d: import java.util.concurrent.TimeoutException;
1:a818270: import java.util.concurrent.atomic.AtomicInteger;
1:230a86c: 
1:230a86c: import javax.jms.Connection;
1:230a86c: import javax.jms.ConnectionFactory;
1:230a86c: import javax.jms.DeliveryMode;
1:230a86c: import javax.jms.Destination;
1:230a86c: import javax.jms.JMSException;
1:230a86c: import javax.jms.MessageConsumer;
1:230a86c: import javax.jms.MessageProducer;
1:10dae9c: import javax.jms.Queue;
1:10dae9c: import javax.jms.QueueBrowser;
1:230a86c: import javax.jms.Session;
1:230a86c: import javax.jms.TextMessage;
1:230a86c: import javax.jms.Topic;
1:230a86c: 
1:a818270: import org.apache.activemq.advisory.ConsumerEvent;
1:a818270: import org.apache.activemq.advisory.ConsumerEventSource;
1:a818270: import org.apache.activemq.advisory.ConsumerListener;
1:230a86c: import org.apache.activemq.broker.BrokerFactory;
1:230a86c: import org.apache.activemq.broker.BrokerService;
1:230a86c: import org.apache.activemq.broker.TransportConnector;
1:d4ccc50: import org.apache.activemq.broker.region.RegionBroker;
1:d4ccc50: import org.apache.activemq.broker.region.TopicRegion;
1:230a86c: import org.apache.activemq.command.ActiveMQDestination;
1:230a86c: import org.apache.activemq.command.ActiveMQQueue;
1:230a86c: import org.apache.activemq.command.ActiveMQTopic;
1:dd0b16d: import org.apache.activemq.command.BrokerInfo;
1:230a86c: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:b9045db: import org.apache.activemq.network.NetworkBridge;
1:230a86c: import org.apache.activemq.network.NetworkConnector;
1:230a86c: import org.apache.activemq.util.IdGenerator;
1:230a86c: import org.apache.activemq.util.MessageIdList;
1:4213e42: import org.apache.activemq.util.Wait;
1:230a86c: import org.apache.activemq.xbean.BrokerFactoryBean;
1:b9045db: import org.slf4j.Logger;
1:b9045db: import org.slf4j.LoggerFactory;
1:230a86c: import org.springframework.core.io.Resource;
1:e8952f6: 
1:579a1d4: /**
1:230a86c:  * Test case support that allows the easy management and connection of several
1:230a86c:  * brokers.
1:b0c2a40:  * 
1:230a86c:  * 
1:579a1d4:  */
1:579a1d4: public class JmsMultipleBrokersTestSupport extends CombinationTestSupport {
1:b9045db:     private static final Logger LOG = LoggerFactory.getLogger(JmsMultipleBrokersTestSupport.class);
1:579a1d4:     public static final String AUTO_ASSIGN_TRANSPORT = "tcp://localhost:0";
1:fc00993:     public static int maxSetupTime = 5000;
1:e8952f6: 
1:ecf89a6:     protected Map<String, BrokerItem> brokers;
1:ecf89a6:     protected Map<String, Destination> destinations;
1:e8952f6: 
1:579a1d4:     protected int messageSize = 1;
1:579a1d4: 
1:1a9d286:     protected boolean persistentDelivery = true;
1:230a86c:     protected boolean verbose;
1:579a1d4: 
1:6a12e9c:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName) throws Exception {
1:8b0bb33:         return bridgeBrokers(localBrokerName, remoteBrokerName, false, 1, true);
1:e8952f6:     }
1:230a86c: 
1:4c8ab44:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly) throws Exception {
1:ecf89a6:         BrokerService localBroker = brokers.get(localBrokerName).broker;
1:ecf89a6:         BrokerService remoteBroker = brokers.get(remoteBrokerName).broker;
1:230a86c: 
1:4c8ab44:         return bridgeBrokers(localBroker, remoteBroker, dynamicOnly, 1, true, false);
1:dd0b16d:     }
1:e8952f6: 
1:8b0bb33:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly, int networkTTL, boolean conduit) throws Exception {
1:ecf89a6:         BrokerService localBroker = brokers.get(localBrokerName).broker;
1:ecf89a6:         BrokerService remoteBroker = brokers.get(remoteBrokerName).broker;
1:e8952f6: 
1:9041c3f:         return bridgeBrokers(localBroker, remoteBroker, dynamicOnly, networkTTL, conduit, false);
1:e8952f6:     }
1:e8952f6: 
1:579a1d4:     // Overwrite this method to specify how you want to bridge the two brokers
1:230a86c:     // By default, bridge them using add network connector of the local broker
1:230a86c:     // and the first connector of the remote broker
1:9041c3f:     protected NetworkConnector bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker, boolean dynamicOnly, int networkTTL, boolean conduit, boolean failover) throws Exception {
1:4213e42:         List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:579a1d4:         URI remoteURI;
1:579a1d4:         if (!transportConnectors.isEmpty()) {
1:4213e42:             remoteURI = transportConnectors.get(0).getConnectUri();
1:9041c3f:             String uri = "static:(" + remoteURI + ")";
1:9041c3f:             if (failover) {
1:9041c3f:                 uri = "static:(failover:(" + remoteURI + "))";
1:9041c3f:             }
1:9041c3f:             NetworkConnector connector = new DiscoveryNetworkConnector(new URI(uri));
1:179d95e:             connector.setName("to-" + remoteBroker.getBrokerName());
1:e8952f6:             connector.setDynamicOnly(dynamicOnly);
1:e8952f6:             connector.setNetworkTTL(networkTTL);
1:8b0bb33:             connector.setConduitSubscriptions(conduit);
1:e8952f6:             localBroker.addNetworkConnector(connector);
1:fc00993:             maxSetupTime = 2000;
1:6a12e9c:             return connector;
1:579a1d4:         } else {
1:579a1d4:             throw new Exception("Remote broker has no registered connectors.");
2:579a1d4:         }
1:579a1d4: 
1:579a1d4:     }
1:579a1d4: 
1:3da1373:     // This will interconnect all brokers using multicast
1:579a1d4:     protected void bridgeAllBrokers() throws Exception {
1:3da1373:         bridgeAllBrokers("default", 1, false, false);
1:3da1373:     }
1:3da1373:     
1:3da1373:     protected void bridgeAllBrokers(String groupName, int ttl, boolean suppressduplicateQueueSubs) throws Exception {
1:3da1373:         bridgeAllBrokers(groupName, ttl, suppressduplicateQueueSubs, false);
1:579a1d4:     }
1:579a1d4: 
1:3da1373:     protected void bridgeAllBrokers(String groupName, int ttl, boolean suppressduplicateQueueSubs, boolean decreasePriority) throws Exception {
1:ecf89a6:         Collection<BrokerItem> brokerList = brokers.values();
1:ecf89a6:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:ecf89a6:             BrokerService broker = i.next().broker;
1:4213e42:             List<TransportConnector> transportConnectors = broker.getTransportConnectors();
1:579a1d4: 
1:579a1d4:             if (transportConnectors.isEmpty()) {
1:579a1d4:                 broker.addConnector(new URI(AUTO_ASSIGN_TRANSPORT));
1:579a1d4:                 transportConnectors = broker.getTransportConnectors();
1:579a1d4:             }
1:579a1d4: 
1:4213e42:             TransportConnector transport = transportConnectors.get(0);
1:4a7e0b3:             transport.setDiscoveryUri(new URI("multicast://default?group=" + groupName));
1:5511217:             NetworkConnector nc = broker.addNetworkConnector("multicast://default?group=" + groupName);
1:5511217:             nc.setNetworkTTL(ttl);
1:5511217:             nc.setSuppressDuplicateQueueSubscriptions(suppressduplicateQueueSubs);
1:3da1373:             nc.setDecreaseNetworkConsumerPriority(decreasePriority);
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         // Multicasting may take longer to setup
1:fc00993:         maxSetupTime = 8000;
1:579a1d4:     }
1:c752230: 
1:4213e42: 
1:c752230:     protected void waitForBridgeFormation(final int min) throws Exception {
1:4213e42:         for (BrokerItem brokerItem : brokers.values()) {
1:4213e42:             final BrokerService broker = brokerItem.broker;
1:f38908e:             waitForBridgeFormation(broker, min, 0);
1:579a1d4:         }
1:579a1d4:     }
1:579a1d4: 
1:f38908e:     public boolean waitForBridgeFormation(final BrokerService broker, final int min, final int bridgeIndex) throws Exception {
1:f38908e:         return waitForBridgeFormation(broker, min, bridgeIndex, Wait.MAX_WAIT_MILLIS*2);
1:f38908e:     }
1:f38908e: 
1:f38908e:     public boolean waitForBridgeFormation(final BrokerService broker, final int min, final int bridgeIndex, long wait) throws Exception {
1:f38908e: 
1:f38908e:         boolean result = false;
1:f38908e:         if (!broker.getNetworkConnectors().isEmpty()) {
1:f38908e:             result = Wait.waitFor(new Wait.Condition() {
1:f38908e:                 public boolean isSatisified() throws Exception {
1:b9045db:                     int activeCount = 0;
1:b9045db:                     for (NetworkBridge bridge : broker.getNetworkConnectors().get(bridgeIndex).activeBridges()) {
1:b9045db:                         if (bridge.getRemoteBrokerName() != null) {
1:49718ed:                             LOG.info("found bridge[" + bridge + "] to " + bridge.getRemoteBrokerName() + " on broker :" + broker.getBrokerName());
1:b9045db:                             activeCount++;
1:b9045db:                         }
1:b9045db:                     }
1:b9045db:                     return activeCount >= min;
1:f38908e:                 }}, wait);
1:f38908e:         }
1:f38908e:         return result;
1:f38908e:     }
1:f38908e: 
1:d4ccc50:     protected void waitForMinTopicRegionConsumerCount(final String name, final int count) throws Exception {
1:d4ccc50:         final BrokerService broker = brokers.get(name).broker;
1:d4ccc50:         final TopicRegion topicRegion =  (TopicRegion) ((RegionBroker) broker.getRegionBroker()).getTopicRegion();
1:d4ccc50:         assertTrue("found expected consumers in topic region of" + name, Wait.waitFor(new Wait.Condition() {
1:d4ccc50:             @Override
1:d4ccc50:             public boolean isSatisified() throws Exception {
1:d4ccc50:                 LOG.info("topic consumers: " + name +", " +  topicRegion.getSubscriptions().toString());
1:d4ccc50:                 return topicRegion.getSubscriptions().size()  >= count;
1:d4ccc50:             }
1:d4ccc50:         }));
1:d4ccc50:     }
1:d4ccc50: 
1:dd0b16d:     /**
1:dd0b16d:      * Timed wait for {@link #hasBridge(String, String)}.
1:dd0b16d:      * 
1:dd0b16d:      * @see #hasBridge(String, String)
1:dd0b16d:      * 
1:dd0b16d:      * @param localBrokerName
1:dd0b16d:      *            - the name of the broker on the "local" side of the bridge
1:dd0b16d:      * @param remoteBrokerName
1:dd0b16d:      *            - the name of the broker on the "remote" side of the bridge
1:dd0b16d:      * @param time
1:dd0b16d:      *            - the maximum time to wait for the bridge to be established
1:dd0b16d:      * @param units
1:dd0b16d:      *            - the units for <param>time</param>
1:dd0b16d:      * @throws InterruptedException
1:dd0b16d:      *             - if the calling thread is interrupted
1:dd0b16d:      * @throws TimeoutException
1:dd0b16d:      *             - if the bridge is not established within the time limit
1:dd0b16d:      * @throws Exception
1:dd0b16d:      *             - some other unknown error occurs
1:dd0b16d:      */
1:dd0b16d:     protected void waitForBridge(final String localBrokerName,
1:dd0b16d:             final String remoteBrokerName, long time, TimeUnit units)
1:dd0b16d:             throws InterruptedException, TimeoutException, Exception {
1:dd0b16d:         if (!Wait.waitFor(new Wait.Condition() {
1:dd0b16d:             public boolean isSatisified() {
1:dd0b16d:                 return hasBridge(localBrokerName, remoteBrokerName);
1:4213e42:             }
1:dd0b16d:         }, units.toMillis(time))) {
1:dd0b16d:             throw new TimeoutException("Bridge not established from broker "
1:dd0b16d:                     + localBrokerName + " to " + remoteBrokerName + " within "
1:dd0b16d:                     + units.toMillis(time) + " milliseconds.");
1:4213e42:         }
1:4213e42:     }
1:4213e42: 
1:dd0b16d:     /**
1:dd0b16d:      * Determines whether a bridge has been established between the specified
1:dd0b16d:      * brokers.Establishment means that connections have been created and broker
1:dd0b16d:      * info has been exchanged. Due to the asynchronous nature of the
1:dd0b16d:      * connections, there is still a possibility that the bridge may fail
1:dd0b16d:      * shortly after establishment.
1:dd0b16d:      * 
1:dd0b16d:      * @param localBrokerName
1:dd0b16d:      *            - the name of the broker on the "local" side of the bridge
1:dd0b16d:      * @param remoteBrokerName
1:dd0b16d:      *            - the name of the broker on the "remote" side of the bridge
1:dd0b16d:      */
1:dd0b16d:     protected boolean hasBridge(String localBrokerName, String remoteBrokerName) {
1:dd0b16d:         final BrokerItem fromBroker = brokers.get(localBrokerName);
1:dd0b16d:         if (fromBroker == null) {
1:dd0b16d:             throw new IllegalArgumentException("Unknown broker: "
1:dd0b16d:                     + localBrokerName);
1:dd0b16d:         }
1:dd0b16d: 
1:dd0b16d:         for (BrokerInfo peerInfo : fromBroker.broker.getRegionBroker()
1:dd0b16d:                 .getPeerBrokerInfos()) {
1:dd0b16d:             if (peerInfo.getBrokerName().equals(remoteBrokerName)) {
1:dd0b16d:                 return true;
1:dd0b16d:             }
1:dd0b16d:         }
1:dd0b16d:         return false;
1:dd0b16d:     }
1:dd0b16d:     
1:c752230:     protected void waitForBridgeFormation() throws Exception {
1:c752230:         waitForBridgeFormation(1);
1:c752230:     }
1:c752230: 
1:579a1d4:     protected void startAllBrokers() throws Exception {
1:ecf89a6:         Collection<BrokerItem> brokerList = brokers.values();
1:ecf89a6:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:ecf89a6:             BrokerService broker = i.next().broker;
1:579a1d4:             broker.start();
1:d17eceb:             broker.waitUntilStarted();
1:dd0b16d:         }
1:dd0b16d: 
1:fc00993:         Thread.sleep(maxSetupTime);
1:dd0b16d:     }
1:579a1d4: 
1:579a1d4:     protected BrokerService createBroker(String brokerName) throws Exception {
1:579a1d4:         BrokerService broker = new BrokerService();
1:579a1d4:         broker.setBrokerName(brokerName);
1:579a1d4:         brokers.put(brokerName, new BrokerItem(broker));
1:579a1d4: 
1:579a1d4:         return broker;
1:579a1d4:     }
1:579a1d4: 
1:579a1d4:     protected BrokerService createBroker(URI brokerUri) throws Exception {
1:579a1d4:         BrokerService broker = BrokerFactory.createBroker(brokerUri);
1:af1b232:         configureBroker(broker);
1:579a1d4:         brokers.put(broker.getBrokerName(), new BrokerItem(broker));
1:579a1d4: 
1:579a1d4:         return broker;
1:579a1d4:     }
1:579a1d4: 
1:af1b232:     protected void configureBroker(BrokerService broker) {
1:af1b232:     }
1:af1b232: 
1:579a1d4:     protected BrokerService createBroker(Resource configFile) throws Exception {
1:579a1d4:         BrokerFactoryBean brokerFactory = new BrokerFactoryBean(configFile);
1:579a1d4:         brokerFactory.afterPropertiesSet();
1:579a1d4: 
1:579a1d4:         BrokerService broker = brokerFactory.getBroker();
1:579a1d4:         brokers.put(broker.getBrokerName(), new BrokerItem(broker));
1:579a1d4: 
1:579a1d4:         return broker;
1:579a1d4:     }
1:579a1d4: 
1:1a9d286:     protected ConnectionFactory getConnectionFactory(String brokerName) throws Exception {
1:ecf89a6:         BrokerItem brokerItem = brokers.get(brokerName);
1:1a9d286:         if (brokerItem != null) {
1:1a9d286:             return brokerItem.factory;
1:1a9d286:         }
1:1a9d286:         return null;
1:1a9d286:     }
1:a95c6db: 
1:579a1d4:     protected Connection createConnection(String brokerName) throws Exception {
1:ecf89a6:         BrokerItem brokerItem = brokers.get(brokerName);
1:579a1d4:         if (brokerItem != null) {
1:579a1d4:             return brokerItem.createConnection();
1:579a1d4:         }
1:579a1d4:         return null;
1:579a1d4:     }
1:10dae9c: 
1:2bdddc2:     protected MessageConsumer createSyncConsumer(String brokerName, Destination dest) throws Exception {
1:2bdddc2:         BrokerItem brokerItem = brokers.get(brokerName);
1:2bdddc2:         if (brokerItem != null) {
1:2bdddc2:             Connection con = brokerItem.createConnection();
1:2bdddc2:             con.start();
1:2bdddc2:             Session sess = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:2bdddc2:             MessageConsumer consumer = sess.createConsumer(dest);
1:2bdddc2:             return consumer;
1:2bdddc2:         }
1:2bdddc2:         return null;
1:2bdddc2:     }
1:2bdddc2: 
1:230a86c:     protected MessageConsumer createConsumer(String brokerName, Destination dest) throws Exception {
1:b2148c5:         return createConsumer(brokerName, dest, null, null);
1:3070d33:     }
1:a818270: 
1:b2148c5:     protected MessageConsumer createConsumer(String brokerName, Destination dest, String messageSelector) throws Exception {
1:b2148c5:         return createConsumer(brokerName, dest, null, messageSelector);
1:b2148c5:     }
1:b2148c5:     
1:3070d33:     protected MessageConsumer createConsumer(String brokerName, Destination dest, CountDownLatch latch) throws Exception {
1:b2148c5:     	return createConsumer(brokerName, dest, latch, null);
1:b2148c5:     }
1:b2148c5:     
1:b2148c5:     protected MessageConsumer createConsumer(String brokerName, Destination dest, CountDownLatch latch, String messageSelector) throws Exception {
1:ecf89a6:         BrokerItem brokerItem = brokers.get(brokerName);
1:579a1d4:         if (brokerItem != null) {
1:b2148c5:             return brokerItem.createConsumer(dest, latch, messageSelector);
1:579a1d4:         }
1:579a1d4:         return null;
1:579a1d4:     }
1:230a86c:     
1:10dae9c:     protected QueueBrowser createBrowser(String brokerName, Destination dest) throws Exception {
1:10dae9c:         BrokerItem brokerItem = brokers.get(brokerName);
1:10dae9c:         if (brokerItem != null) {
1:10dae9c:             return brokerItem.createBrowser(dest);
1:10dae9c:         }
1:10dae9c:         return null;
1:10dae9c:     }
1:3070d33: 
1:579a1d4:     protected MessageConsumer createDurableSubscriber(String brokerName, Topic dest, String name) throws Exception {
1:ecf89a6:         BrokerItem brokerItem = brokers.get(brokerName);
1:579a1d4:         if (brokerItem != null) {
1:579a1d4:             return brokerItem.createDurableSubscriber(dest, name);
1:579a1d4:         }
1:579a1d4:         return null;
1:579a1d4:     }
1:1a9d286: 
1:579a1d4:     protected MessageIdList getBrokerMessages(String brokerName) {
1:ecf89a6:         BrokerItem brokerItem = brokers.get(brokerName);
1:579a1d4:         if (brokerItem != null) {
1:579a1d4:             return brokerItem.getAllMessages();
1:579a1d4:         }
1:579a1d4:         return null;
1:579a1d4:     }
1:579a1d4: 
1:579a1d4:     protected MessageIdList getConsumerMessages(String brokerName, MessageConsumer consumer) {
1:ecf89a6:         BrokerItem brokerItem = brokers.get(brokerName);
1:579a1d4:         if (brokerItem != null) {
1:579a1d4:             return brokerItem.getConsumerMessages(consumer);
1:579a1d4:         }
1:579a1d4:         return null;
1:579a1d4:     }
1:579a1d4: 
1:a818270:     protected void assertConsumersConnect(String brokerName, Destination destination, final int count, long timeout) throws Exception {
1:a818270:         BrokerItem brokerItem = brokers.get(brokerName);
1:a818270:         Connection conn = brokerItem.createConnection();
1:a818270:         conn.start();
1:a818270:         ConsumerEventSource ces = new ConsumerEventSource(conn, destination);
1:a818270: 
1:a818270:         try {
1:a818270:         	final AtomicInteger actualConnected = new AtomicInteger();
1:a818270: 	        final CountDownLatch latch = new CountDownLatch(1);        
1:a818270: 	        ces.setConsumerListener(new ConsumerListener(){
1:a818270: 				public void onConsumerEvent(ConsumerEvent event) {
1:a818270: 					if( actualConnected.get() < count ) {
1:a818270: 						actualConnected.set(event.getConsumerCount());
1:a818270: 					}
1:a818270: 					if( event.getConsumerCount() >= count ) {
1:a818270: 						latch.countDown();
1:a818270: 					}				
1:a818270: 				}
1:a818270: 			});
1:a818270: 	        ces.start();
1:a818270: 	        
1:a818270: 	        latch.await(timeout, TimeUnit.MILLISECONDS);
1:a818270: 	        assertTrue("Expected at least "+count+" consumers to connect, but only "+actualConnected.get()+" connectect within "+timeout+" ms", actualConnected.get() >= count);
1:a818270: 	        
1:a818270:         } finally {
1:a818270:             ces.stop();
1:a818270:             conn.close();
1:a818270:             brokerItem.connections.remove(conn);
1:a818270:         }
1:a818270:     }
1:a818270: 
1:579a1d4: 
1:579a1d4:     protected void sendMessages(String brokerName, Destination destination, int count) throws Exception {
1:b2148c5:     	sendMessages(brokerName, destination, count, null);
1:b2148c5:     }
1:b2148c5:     
1:b2148c5:     protected void sendMessages(String brokerName, Destination destination, int count, HashMap<String, Object>properties) throws Exception {
1:ecf89a6:         BrokerItem brokerItem = brokers.get(brokerName);
1:579a1d4: 
1:579a1d4:         Connection conn = brokerItem.createConnection();
1:579a1d4:         conn.start();
1:579a1d4:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:579a1d4: 
1:579a1d4:         MessageProducer producer = brokerItem.createProducer(destination, sess);
1:1a9d286:         producer.setDeliveryMode(persistentDelivery ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
1:579a1d4: 
1:579a1d4:         for (int i = 0; i < count; i++) {
1:579a1d4:             TextMessage msg = createTextMessage(sess, conn.getClientID() + ": Message-" + i);
1:b2148c5:             if (properties != null) {
1:b2148c5:             	for (String propertyName : properties.keySet()) {
1:b2148c5:             		msg.setObjectProperty(propertyName, properties.get(propertyName));
1:b2148c5:             	}
1:b2148c5:             }
1:579a1d4:             producer.send(msg);
1:8761189:             onSend(i, msg);
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         producer.close();
1:579a1d4:         sess.close();
1:579a1d4:         conn.close();
1:579a1d4:         brokerItem.connections.remove(conn);
1:579a1d4:     }
1:579a1d4: 
1:8761189:     protected void onSend(int i, TextMessage msg) {
1:8761189:     }
1:8761189: 
1:579a1d4:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:579a1d4:         TextMessage msg = session.createTextMessage();
1:579a1d4: 
1:579a1d4:         // Pad message text
1:579a1d4:         if (initText.length() < messageSize) {
1:579a1d4:             char[] data = new char[messageSize - initText.length()];
1:579a1d4:             Arrays.fill(data, '*');
1:579a1d4:             String str = new String(data);
1:579a1d4:             msg.setText(initText + str);
1:579a1d4: 
1:230a86c:             // Do not pad message text
1:579a1d4:         } else {
1:579a1d4:             msg.setText(initText);
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         return msg;
1:579a1d4:     }
1:579a1d4: 
1:579a1d4:     protected ActiveMQDestination createDestination(String name, boolean topic) throws JMSException {
1:579a1d4:         Destination dest;
1:579a1d4:         if (topic) {
1:579a1d4:             dest = new ActiveMQTopic(name);
1:579a1d4:             destinations.put(name, dest);
1:579a1d4:             return (ActiveMQDestination)dest;
1:579a1d4:         } else {
1:579a1d4:             dest = new ActiveMQQueue(name);
1:579a1d4:             destinations.put(name, dest);
1:579a1d4:             return (ActiveMQDestination)dest;
1:579a1d4:         }
1:579a1d4:     }
1:579a1d4: 
1:579a1d4:     protected void setUp() throws Exception {
1:579a1d4:         super.setUp();
1:ecf89a6:         brokers = new HashMap<String, BrokerItem>();
1:ecf89a6:         destinations = new HashMap<String, Destination>();
1:579a1d4:     }
1:579a1d4: 
1:579a1d4:     protected void tearDown() throws Exception {
1:579a1d4:         destroyAllBrokers();
1:579a1d4:         super.tearDown();
1:579a1d4:     }
1:579a1d4: 
1:579a1d4:     protected void destroyBroker(String brokerName) throws Exception {
1:ecf89a6:         BrokerItem brokerItem = brokers.remove(brokerName);
1:579a1d4: 
1:579a1d4:         if (brokerItem != null) {
1:579a1d4:             brokerItem.destroy();
1:579a1d4:         }
1:579a1d4:     }
1:579a1d4: 
1:579a1d4:     protected void destroyAllBrokers() throws Exception {
1:ecf89a6:         for (Iterator<BrokerItem> i = brokers.values().iterator(); i.hasNext();) {
1:ecf89a6:             BrokerItem brokerItem = i.next();
1:579a1d4:             brokerItem.destroy();
1:579a1d4:         }
1:579a1d4:         brokers.clear();
1:579a1d4:     }
1:579a1d4: 
1:61da1fa:     public String buildFailoverUriToAllBrokers() {
1:61da1fa:         StringBuilder uriBuilder = new StringBuilder("failover:(");
1:61da1fa: 
1:61da1fa:         int index = 1, size = brokers.size();
1:61da1fa: 
1:61da1fa:         for (BrokerItem b : brokers.values()) {
1:61da1fa:             uriBuilder.append(b.getConnectionUri());
1:61da1fa:             if (index < size) {
1:61da1fa:                 uriBuilder.append(",");
1:61da1fa:                 index++;
1:61da1fa:             }
1:61da1fa: 
1:61da1fa:         }
1:61da1fa:         uriBuilder.append(")");
1:61da1fa:         return uriBuilder.toString();
1:61da1fa:     }
1:61da1fa: 
1:579a1d4:     // Class to group broker components together
1:e8952f6:     public class BrokerItem {
1:579a1d4:         public BrokerService broker;
1:579a1d4:         public ActiveMQConnectionFactory factory;
1:ecf89a6:         public List<Connection> connections;
1:ecf89a6:         public Map<MessageConsumer, MessageIdList> consumers;
1:579a1d4:         public MessageIdList allMessages = new MessageIdList();
1:230a86c:         public boolean persistent;
1:ecf89a6:         private IdGenerator id;
1:579a1d4: 
1:579a1d4:         public BrokerItem(BrokerService broker) throws Exception {
1:579a1d4:             this.broker = broker;
1:579a1d4: 
1:579a1d4:             factory = new ActiveMQConnectionFactory(broker.getVmConnectorURI());
1:a95c6db:             factory.setConnectionIDPrefix(broker.getBrokerName());
1:ecf89a6:             consumers = Collections.synchronizedMap(new HashMap<MessageConsumer, MessageIdList>());
1:ecf89a6:             connections = Collections.synchronizedList(new ArrayList<Connection>());
1:579a1d4:             allMessages.setVerbose(verbose);
1:579a1d4:             id = new IdGenerator(broker.getBrokerName() + ":");
1:579a1d4:         }
1:579a1d4: 
1:61da1fa:         public String getConnectionUri(){
1:61da1fa:             return broker.getVmConnectorURI().toString();
1:61da1fa:         }
1:61da1fa: 
1:579a1d4:         public Connection createConnection() throws Exception {
1:579a1d4:             Connection conn = factory.createConnection();
1:579a1d4:             conn.setClientID(id.generateId());
1:579a1d4: 
1:579a1d4:             connections.add(conn);
1:579a1d4:             return conn;
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         public MessageConsumer createConsumer(Destination dest) throws Exception {
1:b2148c5:             return createConsumer(dest, null, null);
1:b2148c5:         }
1:b2148c5:         
1:b2148c5:         public MessageConsumer createConsumer(Destination dest, String messageSelector) throws Exception {
1:b2148c5:         	return createConsumer(dest, null, messageSelector);
1:3070d33:         }
1:230a86c: 
1:b2148c5:         public MessageConsumer createConsumer(Destination dest, CountDownLatch latch, String messageSelector) throws Exception {
1:579a1d4:             Connection c = createConnection();
1:579a1d4:             c.start();
1:579a1d4:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:b2148c5:             return createConsumerWithSession(dest, s, latch, messageSelector);
1:579a1d4:         }
1:3070d33: 
1:3070d33:         public MessageConsumer createConsumerWithSession(Destination dest, Session sess) throws Exception {
1:b2148c5:             return createConsumerWithSession(dest, sess, null, null);
1:3070d33:         }
1:230a86c: 
1:b2148c5:         public MessageConsumer createConsumerWithSession(Destination dest, Session sess, CountDownLatch latch, String messageSelector) throws Exception {
1:b2148c5:             MessageConsumer client = sess.createConsumer(dest, messageSelector);
1:579a1d4:             MessageIdList messageIdList = new MessageIdList();
1:3070d33:             messageIdList.setCountDownLatch(latch);
1:579a1d4:             messageIdList.setParent(allMessages);
1:579a1d4:             client.setMessageListener(messageIdList);
1:579a1d4:             consumers.put(client, messageIdList);
1:579a1d4:             return client;
1:579a1d4:         }
1:10dae9c:         
1:10dae9c:         public QueueBrowser createBrowser(Destination dest) throws Exception {
1:10dae9c:             Connection c = createConnection();
1:10dae9c:             c.start();
1:10dae9c:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:10dae9c:             return s.createBrowser((Queue)dest);
1:10dae9c:         }
1:579a1d4: 
1:579a1d4:         public MessageConsumer createDurableSubscriber(Topic dest, String name) throws Exception {
1:579a1d4:             Connection c = createConnection();
1:579a1d4:             c.start();
1:579a1d4:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:579a1d4:             return createDurableSubscriber(dest, s, name);
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         public MessageConsumer createDurableSubscriber(Topic dest, Session sess, String name) throws Exception {
1:579a1d4:             MessageConsumer client = sess.createDurableSubscriber((Topic)dest, name);
1:579a1d4:             MessageIdList messageIdList = new MessageIdList();
1:579a1d4:             messageIdList.setParent(allMessages);
1:579a1d4:             client.setMessageListener(messageIdList);
1:579a1d4:             consumers.put(client, messageIdList);
1:579a1d4: 
1:579a1d4:             return client;
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         public MessageIdList getAllMessages() {
1:579a1d4:             return allMessages;
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         public MessageIdList getConsumerMessages(MessageConsumer consumer) {
1:ecf89a6:             return consumers.get(consumer);
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         public MessageProducer createProducer(Destination dest) throws Exception {
1:579a1d4:             Connection c = createConnection();
1:579a1d4:             c.start();
1:579a1d4:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:579a1d4:             return createProducer(dest, s);
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         public MessageProducer createProducer(Destination dest, Session sess) throws Exception {
1:579a1d4:             MessageProducer client = sess.createProducer(dest);
1:579a1d4:             client.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
1:579a1d4:             return client;
1:579a1d4:         }
1:579a1d4: 
1:579a1d4:         public void destroy() throws Exception {
1:579a1d4:             while (!connections.isEmpty()) {
1:ecf89a6:                 Connection c = connections.remove(0);
1:579a1d4:                 try {
1:579a1d4:                     c.close();
1:579a1d4:                 } catch (ConnectionClosedException e) {
1:4213e42:                 } catch (JMSException e) {
1:579a1d4:                 }
1:579a1d4:             }
1:579a1d4: 
1:579a1d4:             broker.stop();
1:c752230:             broker.waitUntilStopped();
1:579a1d4:             consumers.clear();
1:579a1d4: 
1:579a1d4:             broker = null;
1:579a1d4:             connections = null;
1:579a1d4:             consumers = null;
1:579a1d4:             factory = null;
1:579a1d4:         }
1:579a1d4:     }
1:579a1d4: 
1:579a1d4: }
============================================================================
author:Christian Posta
-------------------------------------------------------------------------------
commit:61da1fa
/////////////////////////////////////////////////////////////////////////
1:     public String buildFailoverUriToAllBrokers() {
1:         StringBuilder uriBuilder = new StringBuilder("failover:(");
1: 
1:         int index = 1, size = brokers.size();
1: 
1:         for (BrokerItem b : brokers.values()) {
1:             uriBuilder.append(b.getConnectionUri());
1:             if (index < size) {
1:                 uriBuilder.append(",");
1:                 index++;
1:             }
1: 
1:         }
1:         uriBuilder.append(")");
1:         return uriBuilder.toString();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         public String getConnectionUri(){
1:             return broker.getVmConnectorURI().toString();
1:         }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:a95c6db
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             factory.setConnectionIDPrefix(broker.getBrokerName());
commit:179d95e
/////////////////////////////////////////////////////////////////////////
1:             connector.setName("to-" + remoteBroker.getBrokerName());
commit:d4ccc50
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.region.TopicRegion;
/////////////////////////////////////////////////////////////////////////
1:     protected void waitForMinTopicRegionConsumerCount(final String name, final int count) throws Exception {
1:         final BrokerService broker = brokers.get(name).broker;
1:         final TopicRegion topicRegion =  (TopicRegion) ((RegionBroker) broker.getRegionBroker()).getTopicRegion();
1:         assertTrue("found expected consumers in topic region of" + name, Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("topic consumers: " + name +", " +  topicRegion.getSubscriptions().toString());
1:                 return topicRegion.getSubscriptions().size()  >= count;
1:             }
1:         }));
1:     }
1: 
commit:49718ed
/////////////////////////////////////////////////////////////////////////
1:                             LOG.info("found bridge[" + bridge + "] to " + bridge.getRemoteBrokerName() + " on broker :" + broker.getBrokerName());
commit:af1b232
/////////////////////////////////////////////////////////////////////////
1:         configureBroker(broker);
1:     protected void configureBroker(BrokerService broker) {
1:     }
1: 
commit:b9045db
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.network.NetworkBridge;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(JmsMultipleBrokersTestSupport.class);
/////////////////////////////////////////////////////////////////////////
1:                     int activeCount = 0;
1:                     for (NetworkBridge bridge : broker.getNetworkConnectors().get(bridgeIndex).activeBridges()) {
1:                         if (bridge.getRemoteBrokerName() != null) {
0:                             LOG.info("found bridge to " + bridge.getRemoteBrokerName() + " on broker :" + broker.getBrokerName());
1:                             activeCount++;
1:                         }
1:                     }
1:                     return activeCount >= min;
commit:f38908e
/////////////////////////////////////////////////////////////////////////
1:             waitForBridgeFormation(broker, min, 0);
1:     public boolean waitForBridgeFormation(final BrokerService broker, final int min, final int bridgeIndex) throws Exception {
1:         return waitForBridgeFormation(broker, min, bridgeIndex, Wait.MAX_WAIT_MILLIS*2);
1:     }
1: 
1:     public boolean waitForBridgeFormation(final BrokerService broker, final int min, final int bridgeIndex, long wait) throws Exception {
1: 
1:         boolean result = false;
1:         if (!broker.getNetworkConnectors().isEmpty()) {
1:             result = Wait.waitFor(new Wait.Condition() {
1:                 public boolean isSatisified() throws Exception {
0:                     return (broker.getNetworkConnectors().get(bridgeIndex).activeBridges().size() >= min);
1:                 }}, wait);
1:         }
1:         return result;
1:     }
1: 
commit:29c0dff
/////////////////////////////////////////////////////////////////////////
0:                     }}, Wait.MAX_WAIT_MILLIS * 2);
commit:c752230
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void waitForBridgeFormation(final int min) throws Exception {
0:                         return (broker.getNetworkConnectors().get(0).activeBridges().size() >= min);
1:     protected void waitForBridgeFormation() throws Exception {
1:         waitForBridgeFormation(1);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             broker.waitUntilStopped();
commit:7449545
/////////////////////////////////////////////////////////////////////////
0:     protected void waitForBridgeFormation() throws Exception {
0:             if (!broker.getNetworkConnectors().isEmpty()) {
0:                 Wait.waitFor(new Wait.Condition() {
/////////////////////////////////////////////////////////////////////////
commit:4213e42
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:         List<TransportConnector> transportConnectors = remoteBroker.getTransportConnectors();
1:             remoteURI = transportConnectors.get(0).getConnectUri();
/////////////////////////////////////////////////////////////////////////
1:             List<TransportConnector> transportConnectors = broker.getTransportConnectors();
1:             TransportConnector transport = transportConnectors.get(0);
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected void waitForBridgeFormation() throws Exception {
1:         for (BrokerItem brokerItem : brokers.values()) {
1:             final BrokerService broker = brokerItem.broker;
0:             if (!broker.getNetworkConnectors().isEmpty()) {
0:                 Wait.waitFor(new Wait.Condition() {
0:                     public boolean isSatisified() throws Exception {
0:                         return !broker.getNetworkConnectors().get(0).activeBridges().isEmpty();
0:                     }});
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 } catch (JMSException e) {
commit:3da1373
/////////////////////////////////////////////////////////////////////////
1:     // This will interconnect all brokers using multicast
1:         bridgeAllBrokers("default", 1, false, false);
1:     }
1:     
1:     protected void bridgeAllBrokers(String groupName, int ttl, boolean suppressduplicateQueueSubs) throws Exception {
1:         bridgeAllBrokers(groupName, ttl, suppressduplicateQueueSubs, false);
1:     protected void bridgeAllBrokers(String groupName, int ttl, boolean suppressduplicateQueueSubs, boolean decreasePriority) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             nc.setDecreaseNetworkConsumerPriority(decreasePriority);
commit:5511217
/////////////////////////////////////////////////////////////////////////
0:         bridgeAllBrokers("default", 1, false);
0:     protected void bridgeAllBrokers(String groupName, int ttl, boolean suppressduplicateQueueSubs) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             NetworkConnector nc = broker.addNetworkConnector("multicast://default?group=" + groupName);
1:             nc.setNetworkTTL(ttl);
1:             nc.setSuppressDuplicateQueueSubscriptions(suppressduplicateQueueSubs);
commit:8761189
/////////////////////////////////////////////////////////////////////////
1:             onSend(i, msg);
/////////////////////////////////////////////////////////////////////////
1:     protected void onSend(int i, TextMessage msg) {
1:     }
1: 
commit:4a7e0b3
/////////////////////////////////////////////////////////////////////////
1:             transport.setDiscoveryUri(new URI("multicast://default?group=" + groupName));
0:             broker.addNetworkConnector("multicast://default?group=" + groupName);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:dd0b16d
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeoutException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.BrokerInfo;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Timed wait for {@link #hasBridge(String, String)}.
1:      * 
1:      * @see #hasBridge(String, String)
1:      * 
1:      * @param localBrokerName
1:      *            - the name of the broker on the "local" side of the bridge
1:      * @param remoteBrokerName
1:      *            - the name of the broker on the "remote" side of the bridge
1:      * @param time
1:      *            - the maximum time to wait for the bridge to be established
1:      * @param units
1:      *            - the units for <param>time</param>
1:      * @throws InterruptedException
1:      *             - if the calling thread is interrupted
1:      * @throws TimeoutException
1:      *             - if the bridge is not established within the time limit
1:      * @throws Exception
1:      *             - some other unknown error occurs
1:      */
1:     protected void waitForBridge(final String localBrokerName,
1:             final String remoteBrokerName, long time, TimeUnit units)
1:             throws InterruptedException, TimeoutException, Exception {
1:         if (!Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() {
1:                 return hasBridge(localBrokerName, remoteBrokerName);
1:             }
1:         }, units.toMillis(time))) {
1:             throw new TimeoutException("Bridge not established from broker "
1:                     + localBrokerName + " to " + remoteBrokerName + " within "
1:                     + units.toMillis(time) + " milliseconds.");
1:         }
1:     }
1: 
1:     /**
1:      * Determines whether a bridge has been established between the specified
1:      * brokers.Establishment means that connections have been created and broker
1:      * info has been exchanged. Due to the asynchronous nature of the
1:      * connections, there is still a possibility that the bridge may fail
1:      * shortly after establishment.
1:      * 
1:      * @param localBrokerName
1:      *            - the name of the broker on the "local" side of the bridge
1:      * @param remoteBrokerName
1:      *            - the name of the broker on the "remote" side of the bridge
1:      */
1:     protected boolean hasBridge(String localBrokerName, String remoteBrokerName) {
1:         final BrokerItem fromBroker = brokers.get(localBrokerName);
1:         if (fromBroker == null) {
1:             throw new IllegalArgumentException("Unknown broker: "
1:                     + localBrokerName);
1:         }
1: 
1:         for (BrokerInfo peerInfo : fromBroker.broker.getRegionBroker()
1:                 .getPeerBrokerInfos()) {
1:             if (peerInfo.getBrokerName().equals(remoteBrokerName)) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1:     
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:4c8ab44
/////////////////////////////////////////////////////////////////////////
1:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly) throws Exception {
1:         return bridgeBrokers(localBroker, remoteBroker, dynamicOnly, 1, true, false);
commit:d17eceb
/////////////////////////////////////////////////////////////////////////
1:             broker.waitUntilStarted();
commit:2bdddc2
/////////////////////////////////////////////////////////////////////////
1:     protected MessageConsumer createSyncConsumer(String brokerName, Destination dest) throws Exception {
1:         BrokerItem brokerItem = brokers.get(brokerName);
1:         if (brokerItem != null) {
1:             Connection con = brokerItem.createConnection();
1:             con.start();
1:             Session sess = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer consumer = sess.createConsumer(dest);
1:             return consumer;
1:         }
1:         return null;
1:     }
1: 
commit:9041c3f
/////////////////////////////////////////////////////////////////////////
0:         bridgeBrokers(localBroker, remoteBroker, dynamicOnly, 1, true, false);
1:         return bridgeBrokers(localBroker, remoteBroker, dynamicOnly, networkTTL, conduit, false);
1:     protected NetworkConnector bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker, boolean dynamicOnly, int networkTTL, boolean conduit, boolean failover) throws Exception {
1:             String uri = "static:(" + remoteURI + ")";
1:             if (failover) {
1:                 uri = "static:(failover:(" + remoteURI + "))";
1:             }
1:             NetworkConnector connector = new DiscoveryNetworkConnector(new URI(uri));
commit:10dae9c
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Queue;
1: import javax.jms.QueueBrowser;
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected QueueBrowser createBrowser(String brokerName, Destination dest) throws Exception {
1:         BrokerItem brokerItem = brokers.get(brokerName);
1:         if (brokerItem != null) {
1:             return brokerItem.createBrowser(dest);
1:         }
1:         return null;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         
1:         public QueueBrowser createBrowser(Destination dest) throws Exception {
1:             Connection c = createConnection();
1:             c.start();
1:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             return s.createBrowser((Queue)dest);
1:         }
commit:8b0bb33
/////////////////////////////////////////////////////////////////////////
1:         return bridgeBrokers(localBrokerName, remoteBrokerName, false, 1, true);
0:         bridgeBrokers(localBroker, remoteBroker, dynamicOnly, 1, true);
1:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly, int networkTTL, boolean conduit) throws Exception {
0:         return bridgeBrokers(localBroker, remoteBroker, dynamicOnly, networkTTL, conduit);
0:     protected NetworkConnector bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker, boolean dynamicOnly, int networkTTL, boolean conduit) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             connector.setConduitSubscriptions(conduit);
commit:b2148c5
/////////////////////////////////////////////////////////////////////////
1:         return createConsumer(brokerName, dest, null, null);
1:     protected MessageConsumer createConsumer(String brokerName, Destination dest, String messageSelector) throws Exception {
1:         return createConsumer(brokerName, dest, null, messageSelector);
1:     }
1:     
1:     	return createConsumer(brokerName, dest, latch, null);
1:     }
1:     
1:     protected MessageConsumer createConsumer(String brokerName, Destination dest, CountDownLatch latch, String messageSelector) throws Exception {
1:             return brokerItem.createConsumer(dest, latch, messageSelector);
/////////////////////////////////////////////////////////////////////////
1:     	sendMessages(brokerName, destination, count, null);
1:     }
1:     
1:     protected void sendMessages(String brokerName, Destination destination, int count, HashMap<String, Object>properties) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             if (properties != null) {
1:             	for (String propertyName : properties.keySet()) {
1:             		msg.setObjectProperty(propertyName, properties.get(propertyName));
1:             	}
1:             }
/////////////////////////////////////////////////////////////////////////
1:             return createConsumer(dest, null, null);
1:         }
1:         
1:         public MessageConsumer createConsumer(Destination dest, String messageSelector) throws Exception {
1:         	return createConsumer(dest, null, messageSelector);
1:         public MessageConsumer createConsumer(Destination dest, CountDownLatch latch, String messageSelector) throws Exception {
1:             return createConsumerWithSession(dest, s, latch, messageSelector);
1:             return createConsumerWithSession(dest, sess, null, null);
1:         public MessageConsumer createConsumerWithSession(Destination dest, Session sess, CountDownLatch latch, String messageSelector) throws Exception {
1:             MessageConsumer client = sess.createConsumer(dest, messageSelector);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:a818270
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.ConsumerEvent;
1: import org.apache.activemq.advisory.ConsumerEventSource;
1: import org.apache.activemq.advisory.ConsumerListener;
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected void assertConsumersConnect(String brokerName, Destination destination, final int count, long timeout) throws Exception {
1:         BrokerItem brokerItem = brokers.get(brokerName);
1:         Connection conn = brokerItem.createConnection();
1:         conn.start();
1:         ConsumerEventSource ces = new ConsumerEventSource(conn, destination);
1: 
1:         try {
1:         	final AtomicInteger actualConnected = new AtomicInteger();
1: 	        final CountDownLatch latch = new CountDownLatch(1);        
1: 	        ces.setConsumerListener(new ConsumerListener(){
1: 				public void onConsumerEvent(ConsumerEvent event) {
1: 					if( actualConnected.get() < count ) {
1: 						actualConnected.set(event.getConsumerCount());
1: 					}
1: 					if( event.getConsumerCount() >= count ) {
1: 						latch.countDown();
1: 					}				
1: 				}
1: 			});
1: 	        ces.start();
1: 	        
1: 	        latch.await(timeout, TimeUnit.MILLISECONDS);
1: 	        assertTrue("Expected at least "+count+" consumers to connect, but only "+actualConnected.get()+" connectect within "+timeout+" ms", actualConnected.get() >= count);
1: 	        
1:         } finally {
1:             ces.stop();
1:             conn.close();
1:             brokerItem.connections.remove(conn);
1:         }
1:     }
1: 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     protected Map<String, BrokerItem> brokers;
1:     protected Map<String, Destination> destinations;
/////////////////////////////////////////////////////////////////////////
1:         BrokerService localBroker = brokers.get(localBrokerName).broker;
1:         BrokerService remoteBroker = brokers.get(remoteBrokerName).broker;
1:         BrokerService localBroker = brokers.get(localBrokerName).broker;
1:         BrokerService remoteBroker = brokers.get(remoteBrokerName).broker;
/////////////////////////////////////////////////////////////////////////
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
/////////////////////////////////////////////////////////////////////////
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext();) {
1:             BrokerService broker = i.next().broker;
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.get(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.get(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.get(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.get(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.get(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.get(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.get(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         brokers = new HashMap<String, BrokerItem>();
1:         destinations = new HashMap<String, Destination>();
/////////////////////////////////////////////////////////////////////////
1:         BrokerItem brokerItem = brokers.remove(brokerName);
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<BrokerItem> i = brokers.values().iterator(); i.hasNext();) {
1:             BrokerItem brokerItem = i.next();
/////////////////////////////////////////////////////////////////////////
1:         public List<Connection> connections;
1:         public Map<MessageConsumer, MessageIdList> consumers;
1:         private IdGenerator id;
1:             consumers = Collections.synchronizedMap(new HashMap<MessageConsumer, MessageIdList>());
1:             connections = Collections.synchronizedList(new ArrayList<Connection>());
/////////////////////////////////////////////////////////////////////////
1:             return consumers.get(consumer);
/////////////////////////////////////////////////////////////////////////
1:                 Connection c = connections.remove(0);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     public static int maxSetupTime = 5000;
/////////////////////////////////////////////////////////////////////////
1:             maxSetupTime = 2000;
/////////////////////////////////////////////////////////////////////////
1:         maxSetupTime = 8000;
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(maxSetupTime);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.Topic;
1: 
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.util.MessageIdList;
1: import org.apache.activemq.xbean.BrokerFactoryBean;
1: import org.springframework.core.io.Resource;
1:  * Test case support that allows the easy management and connection of several
1:  * brokers.
1:  * 
/////////////////////////////////////////////////////////////////////////
1:     protected boolean verbose;
0:         return bridgeBrokers(localBrokerName, remoteBrokerName, false, 1);
1: 
0:     protected void bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly) throws Exception {
0:         BrokerService localBroker = ((BrokerItem)brokers.get(localBrokerName)).broker;
0:         bridgeBrokers(localBroker, remoteBroker, dynamicOnly, 1);
1: 
0:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName, boolean dynamicOnly, int networkTTL) throws Exception {
0:         BrokerService localBroker = ((BrokerItem)brokers.get(localBrokerName)).broker;
0:         return bridgeBrokers(localBroker, remoteBroker, dynamicOnly, networkTTL);
1:     // By default, bridge them using add network connector of the local broker
1:     // and the first connector of the remote broker
0:     protected NetworkConnector bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker, boolean dynamicOnly, int networkTTL) throws Exception {
0:             NetworkConnector connector = new DiscoveryNetworkConnector(new URI("static:" + remoteURI));
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator i = brokerList.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator i = brokerList.iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:     protected MessageConsumer createConsumer(String brokerName, Destination dest) throws Exception {
0:         return createConsumer(brokerName, dest, null);
1: 
/////////////////////////////////////////////////////////////////////////
1:             // Do not pad message text
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator i = brokers.values().iterator(); i.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:         public boolean persistent;
/////////////////////////////////////////////////////////////////////////
0:             return createConsumer(dest, null);
1: 
/////////////////////////////////////////////////////////////////////////
0:             return createConsumerWithSession(dest, sess, null);
1: 
commit:3070d33
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
/////////////////////////////////////////////////////////////////////////
0:     protected MessageConsumer createConsumer(String brokerName, Destination dest) throws Exception {    	
0:     	return createConsumer(brokerName, dest, null);
1:     }
1:     
1:     protected MessageConsumer createConsumer(String brokerName, Destination dest, CountDownLatch latch) throws Exception {
0:             return brokerItem.createConsumer(dest, latch);
/////////////////////////////////////////////////////////////////////////
0:         	return createConsumer(dest, null);
1:         }
1:         
0:         public MessageConsumer createConsumer(Destination dest, CountDownLatch latch) throws Exception {
0:             return createConsumerWithSession(dest, s, latch);
1:         public MessageConsumer createConsumerWithSession(Destination dest, Session sess) throws Exception {
0:         	return createConsumerWithSession(dest, sess, null);
1:         }
0:         public MessageConsumer createConsumerWithSession(Destination dest, Session sess, CountDownLatch latch) throws Exception {
1:             messageIdList.setCountDownLatch(latch);
commit:6a12e9c
/////////////////////////////////////////////////////////////////////////
1:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName) throws Exception {
0:        return bridgeBrokers(localBrokerName,remoteBrokerName,false,1);
/////////////////////////////////////////////////////////////////////////
0:     protected NetworkConnector bridgeBrokers(String localBrokerName, String remoteBrokerName,boolean dynamicOnly, int networkTTL) throws Exception {
0:         return bridgeBrokers(localBroker, remoteBroker,dynamicOnly,networkTTL);
0:     protected NetworkConnector bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker,boolean dynamicOnly, int networkTTL) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             MAX_SETUP_TIME = 2000;
1:             return connector;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:8c4bb36
/////////////////////////////////////////////////////////////////////////
0:     protected boolean waitForBridgeFormation() throws Exception {
0:         boolean success = true;
0:             if (success && !broker.getNetworkConnectors().isEmpty()) {
0:                 success = success && Wait.waitFor(new Wait.Condition() {
0:         return success;
/////////////////////////////////////////////////////////////////////////
0:         destinations.clear();
author:Robert Davies
-------------------------------------------------------------------------------
commit:e8952f6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.network.DiscoveryNetworkConnector;
0: import org.apache.activemq.network.NetworkConnector;
/////////////////////////////////////////////////////////////////////////
0:        bridgeBrokers(localBrokerName,remoteBrokerName,false,1);
1:     }
1:     
1:     
0:     protected void bridgeBrokers(String localBrokerName, String remoteBrokerName,boolean dynamicOnly) throws Exception {
0:         bridgeBrokers(localBroker, remoteBroker,dynamicOnly,1);
1:     
0:     protected void bridgeBrokers(String localBrokerName, String remoteBrokerName,boolean dynamicOnly, int networkTTL) throws Exception {
0:         BrokerService localBroker  = ((BrokerItem)brokers.get(localBrokerName)).broker;
0:         BrokerService remoteBroker = ((BrokerItem)brokers.get(remoteBrokerName)).broker;
1: 
0:         bridgeBrokers(localBroker, remoteBroker,dynamicOnly,networkTTL);
1:     }
1:     
1:    
0:     protected void bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker,boolean dynamicOnly, int networkTTL) throws Exception {
0:             NetworkConnector connector=new DiscoveryNetworkConnector(new URI("static:" + remoteURI));
1:             connector.setDynamicOnly(dynamicOnly);
1:             connector.setNetworkTTL(networkTTL);
1:             localBroker.addNetworkConnector(connector);
/////////////////////////////////////////////////////////////////////////
1:     public class BrokerItem {
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:1a9d286
/////////////////////////////////////////////////////////////////////////
1:     protected boolean persistentDelivery = true;
/////////////////////////////////////////////////////////////////////////
1:     protected ConnectionFactory getConnectionFactory(String brokerName) throws Exception {
0:         BrokerItem brokerItem = (BrokerItem)brokers.get(brokerName);
1:         if (brokerItem != null) {
1:             return brokerItem.factory;
1:         }
1:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         producer.setDeliveryMode(persistentDelivery ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
/////////////////////////////////////////////////////////////////////////
commit:579a1d4
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
0: import javax.jms.*;
1: 
0: import org.apache.activemq.util.MessageIdList;
0: import org.apache.activemq.util.IdGenerator;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.xbean.BrokerFactoryBean;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.BrokerFactory;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.CombinationTestSupport;
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.ConnectionClosedException;
0: import org.springframework.core.io.Resource;
1: 
0: import java.util.List;
0: import java.util.Map;
0: import java.util.HashMap;
1: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.Collections;
1: import java.util.Arrays;
1: import java.util.Collection;
0: import java.net.URI;
1: 
1: /**
0:  * Test case support that allows the easy management and connection of several brokers.
1:  *
0:  * @version $Revision$
1:  */
1: public class JmsMultipleBrokersTestSupport extends CombinationTestSupport {
1:     public static final String AUTO_ASSIGN_TRANSPORT = "tcp://localhost:0";
0:     public static int MAX_SETUP_TIME = 5000;
1: 
0:     protected Map brokers;
0:     protected Map destinations;
1: 
1:     protected int messageSize = 1;
1: 
0:     protected boolean verbose = false;
1: 
0:     protected void bridgeBrokers(String localBrokerName, String remoteBrokerName) throws Exception {
0:         BrokerService localBroker  = ((BrokerItem)brokers.get(localBrokerName)).broker;
0:         BrokerService remoteBroker = ((BrokerItem)brokers.get(remoteBrokerName)).broker;
1: 
0:         bridgeBrokers(localBroker, remoteBroker);
1:     }
1: 
1:     // Overwrite this method to specify how you want to bridge the two brokers
0:     // By default, bridge them using add network connector of the local broker and the first connector of the remote broker
0:     protected void bridgeBrokers(BrokerService localBroker, BrokerService remoteBroker) throws Exception {
0:         List transportConnectors = remoteBroker.getTransportConnectors();
1:         URI remoteURI;
1:         if (!transportConnectors.isEmpty()) {
0:             remoteURI = ((TransportConnector)transportConnectors.get(0)).getConnectUri();
0:             localBroker.addNetworkConnector("static:" + remoteURI);
1:         } else {
1:             throw new Exception("Remote broker has no registered connectors.");
1:         }
1: 
0:         MAX_SETUP_TIME = 2000;
1:     }
1: 
0:     // This will interconnect all brokes using multicast
1:     protected void bridgeAllBrokers() throws Exception {
0:         bridgeAllBrokers("default");
1:     }
1: 
0:     protected void bridgeAllBrokers(String groupName) throws Exception {
0:         Collection brokerList = brokers.values();
0:         for (Iterator i=brokerList.iterator(); i.hasNext();) {
0:             BrokerService broker = ((BrokerItem)i.next()).broker;
0:             List transportConnectors = broker.getTransportConnectors();
1: 
1:             if (transportConnectors.isEmpty()) {
1:                 broker.addConnector(new URI(AUTO_ASSIGN_TRANSPORT));
1:                 transportConnectors = broker.getTransportConnectors();
1:             }
1: 
0:             TransportConnector transport = (TransportConnector)transportConnectors.get(0);
0:             transport.setDiscoveryUri(new URI("multicast://" + groupName));
0:             broker.addNetworkConnector("multicast://" + groupName);
1:         }
1: 
1:         // Multicasting may take longer to setup
0:         MAX_SETUP_TIME = 8000;
1:     }
1: 
1:     protected void startAllBrokers() throws Exception {
0:         Collection brokerList = brokers.values();
0:         for (Iterator i=brokerList.iterator(); i.hasNext();) {
0:             BrokerService broker = ((BrokerItem)i.next()).broker;
1:             broker.start();
1:         }
1: 
0:         Thread.sleep(MAX_SETUP_TIME);
1:     }
1: 
1:     protected BrokerService createBroker(String brokerName) throws Exception {
1:         BrokerService broker = new BrokerService();
1:         broker.setBrokerName(brokerName);
1:         brokers.put(brokerName, new BrokerItem(broker));
1: 
1:         return broker;
1:     }
1: 
1:     protected BrokerService createBroker(URI brokerUri) throws Exception {
1:         BrokerService broker = BrokerFactory.createBroker(brokerUri);
1:         brokers.put(broker.getBrokerName(), new BrokerItem(broker));
1: 
1:         return broker;
1:     }
1: 
1:     protected BrokerService createBroker(Resource configFile) throws Exception {
1:         BrokerFactoryBean brokerFactory = new BrokerFactoryBean(configFile);
1:         brokerFactory.afterPropertiesSet();
1: 
1:         BrokerService broker = brokerFactory.getBroker();
1:         brokers.put(broker.getBrokerName(), new BrokerItem(broker));
1: 
1:         return broker;
1:     }
1: 
1:     protected Connection createConnection(String brokerName) throws Exception {
0:         BrokerItem brokerItem = (BrokerItem)brokers.get(brokerName);
1:         if (brokerItem != null) {
1:             return brokerItem.createConnection();
1:         }
1:         return null;
1:     }
1: 
0:     protected MessageConsumer createConsumer(String brokerName, Destination dest) throws Exception {
0:         BrokerItem brokerItem = (BrokerItem)brokers.get(brokerName);
1:         if (brokerItem != null) {
0:             return brokerItem.createConsumer(dest);
1:         }
1:         return null;
1:     }
1: 
1:     protected MessageConsumer createDurableSubscriber(String brokerName, Topic dest, String name) throws Exception {
0:         BrokerItem brokerItem = (BrokerItem)brokers.get(brokerName);
1:         if (brokerItem != null) {
1:             return brokerItem.createDurableSubscriber(dest, name);
1:         }
1:         return null;
1:     }
1: 
1:     protected MessageIdList getBrokerMessages(String brokerName) {
0:         BrokerItem brokerItem = (BrokerItem)brokers.get(brokerName);
1:         if (brokerItem != null) {
1:             return brokerItem.getAllMessages();
1:         }
1:         return null;
1:     }
1: 
1:     protected MessageIdList getConsumerMessages(String brokerName, MessageConsumer consumer) {
0:         BrokerItem brokerItem = (BrokerItem)brokers.get(brokerName);
1:         if (brokerItem != null) {
1:             return brokerItem.getConsumerMessages(consumer);
1:         }
1:         return null;
1:     }
1: 
1:     protected void sendMessages(String brokerName, Destination destination, int count) throws Exception {
0:         BrokerItem brokerItem = (BrokerItem)brokers.get(brokerName);
1: 
1:         Connection conn = brokerItem.createConnection();
1:         conn.start();
1:         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         MessageProducer producer = brokerItem.createProducer(destination, sess);
1: 
1:         for (int i = 0; i < count; i++) {
1:             TextMessage msg = createTextMessage(sess, conn.getClientID() + ": Message-" + i);
1:             producer.send(msg);
1:         }
1: 
1:         producer.close();
1:         sess.close();
1:         conn.close();
1:         brokerItem.connections.remove(conn);
1:     }
1: 
1:     protected TextMessage createTextMessage(Session session, String initText) throws Exception {
1:         TextMessage msg = session.createTextMessage();
1: 
1:         // Pad message text
1:         if (initText.length() < messageSize) {
1:             char[] data = new char[messageSize - initText.length()];
1:             Arrays.fill(data, '*');
1:             String str = new String(data);
1:             msg.setText(initText + str);
1: 
0:         // Do not pad message text
1:         } else {
1:             msg.setText(initText);
1:         }
1: 
1:         return msg;
1:     }
1: 
1:     protected ActiveMQDestination createDestination(String name, boolean topic) throws JMSException {
1:         Destination dest;
1:         if (topic) {
1:             dest = new ActiveMQTopic(name);
1:             destinations.put(name, dest);
1:             return (ActiveMQDestination)dest;
1:         } else {
1:             dest = new ActiveMQQueue(name);
1:             destinations.put(name, dest);
1:             return (ActiveMQDestination)dest;
1:         }
1:     }
1: 
1:     protected void setUp() throws Exception {
1:         super.setUp();
0:         brokers = new HashMap();
0:         destinations = new HashMap();
1:     }
1: 
1:     protected void tearDown() throws Exception {
1:         destroyAllBrokers();
1:         super.tearDown();
1:     }
1: 
1:     protected void destroyBroker(String brokerName) throws Exception {
0:         BrokerItem brokerItem = (BrokerItem)brokers.remove(brokerName);
1: 
1:         if (brokerItem != null) {
1:             brokerItem.destroy();
1:         }
1:     }
1: 
1:     protected void destroyAllBrokers() throws Exception {
0:         for (Iterator i=brokers.values().iterator(); i.hasNext();) {
0:             BrokerItem brokerItem = (BrokerItem)i.next();
1:             brokerItem.destroy();
1:         }
1:         brokers.clear();
1:     }
1: 
1: 
1:     // Class to group broker components together
0:     protected class BrokerItem {
1:         public BrokerService broker;
1:         public ActiveMQConnectionFactory factory;
0:         public List connections;
0:         public Map consumers;
1:         public MessageIdList allMessages = new MessageIdList();
1: 
0:         private IdGenerator id;
1: 
0:         public boolean persistent = false;
1: 
1:         public BrokerItem(BrokerService broker) throws Exception {
1:             this.broker = broker;
1: 
1:             factory = new ActiveMQConnectionFactory(broker.getVmConnectorURI());
0:             consumers = Collections.synchronizedMap(new HashMap());
0:             connections = Collections.synchronizedList(new ArrayList());
1:             allMessages.setVerbose(verbose);
1:             id = new IdGenerator(broker.getBrokerName() + ":");
1:         }
1: 
1:         public Connection createConnection() throws Exception {
1:             Connection conn = factory.createConnection();
1:             conn.setClientID(id.generateId());
1: 
1:             connections.add(conn);
1:             return conn;
1:         }
1: 
1:         public MessageConsumer createConsumer(Destination dest) throws Exception {
1:             Connection c = createConnection();
1:             c.start();
1:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             return createConsumer(dest, s);
1:         }
1: 
0:         public MessageConsumer createConsumer(Destination dest, Session sess) throws Exception {
0:             MessageConsumer client = sess.createConsumer(dest);
1:             MessageIdList messageIdList = new MessageIdList();
1:             messageIdList.setParent(allMessages);
1:             client.setMessageListener(messageIdList);
1:             consumers.put(client, messageIdList);
1: 
1:             return client;
1:         }
1: 
1:         public MessageConsumer createDurableSubscriber(Topic dest, String name) throws Exception {
1:             Connection c = createConnection();
1:             c.start();
1:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             return createDurableSubscriber(dest, s, name);
1:         }
1: 
1:         public MessageConsumer createDurableSubscriber(Topic dest, Session sess, String name) throws Exception {
1:             MessageConsumer client = sess.createDurableSubscriber((Topic)dest, name);
1:             MessageIdList messageIdList = new MessageIdList();
1:             messageIdList.setParent(allMessages);
1:             client.setMessageListener(messageIdList);
1:             consumers.put(client, messageIdList);
1: 
1:             return client;
1:         }
1: 
1:         public MessageIdList getAllMessages() {
1:             return allMessages;
1:         }
1: 
1:         public MessageIdList getConsumerMessages(MessageConsumer consumer) {
0:             return (MessageIdList)consumers.get(consumer);
1:         }
1: 
1:         public MessageProducer createProducer(Destination dest) throws Exception {
1:             Connection c = createConnection();
1:             c.start();
1:             Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             return createProducer(dest, s);
1:         }
1: 
1:         public MessageProducer createProducer(Destination dest, Session sess) throws Exception {
1:             MessageProducer client = sess.createProducer(dest);
1:             client.setDeliveryMode(persistent ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT);
1:             return client;
1:         }
1: 
1:         public void destroy() throws Exception {
1:             while (!connections.isEmpty()) {
0:                 Connection c = (Connection)connections.remove(0);
1:                 try {
1:                     c.close();
1:                 } catch (ConnectionClosedException e) {
0:                     e.printStackTrace();
1:                 }
1:             }
1: 
1:             broker.stop();
1:             consumers.clear();
1: 
1:             broker = null;
1:             connections = null;
1:             consumers = null;
1:             factory = null;
1:         }
1:     }
1: 
1: }
============================================================================