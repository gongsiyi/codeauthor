1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f29c801:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:f29c801:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
20:d29ca2a: 
1:67c28b1: import java.util.ArrayList;
1:67c28b1: import java.util.List;
1:fad1dd0: import java.util.concurrent.CountDownLatch;
1:fad1dd0: import java.util.concurrent.TimeUnit;
1:fad1dd0: import java.util.concurrent.atomic.AtomicInteger;
1:fad1dd0: 
1:fad1dd0: import javax.jms.JMSException;
1:fad1dd0: import javax.jms.Message;
1:d29ca2a: import javax.jms.MessageConsumer;
1:fad1dd0: import javax.jms.MessageListener;
1:d29ca2a: import javax.jms.MessageProducer;
1:fad1dd0: import javax.jms.ServerSession;
1:fad1dd0: import javax.jms.ServerSessionPool;
1:d29ca2a: import javax.jms.Session;
1:d29ca2a: import javax.jms.TextMessage;
1:d29ca2a: import junit.framework.Test;
1:d29ca2a: 
1:a3836b5: import org.apache.activemq.broker.region.policy.RedeliveryPolicyMap;
1:a971b64: import org.apache.activemq.command.ActiveMQMessage;
1:d29ca2a: import org.apache.activemq.command.ActiveMQQueue;
1:fad1dd0: import org.apache.activemq.command.ActiveMQTextMessage;
1:a3836b5: import org.apache.activemq.command.ActiveMQTopic;
1:b6bca39: import org.apache.activemq.transport.vm.VMTransportFactory;
1:b6bca39: import org.apache.activemq.transport.vm.VMTransportServer;
1:fad1dd0: import org.apache.activemq.util.Wait;
1:eb6c082: import org.slf4j.Logger;
1:eb6c082: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: public class RedeliveryPolicyTest extends JmsTestSupport {
1:eb6c082:     static final Logger LOG = LoggerFactory.getLogger(RedeliveryPolicyTest.class);
1:d29ca2a: 
1:d29ca2a:     public static Test suite() {
1:d29ca2a:         return suite(RedeliveryPolicyTest.class);
1:c23f9e6:     }
1:20832f1: 
1:d29ca2a:     public static void main(String[] args) {
1:d29ca2a:         junit.textui.TestRunner.run(suite());
1:d29ca2a:     }
1:33b88d3: 
1:c23f9e6: 
1:33b88d3:     public void testGetNext() throws Exception {
1:33b88d3: 
1:33b88d3:         RedeliveryPolicy policy = new RedeliveryPolicy();
1:33b88d3:         policy.setInitialRedeliveryDelay(0);
1:33b88d3:         policy.setRedeliveryDelay(500);
1:33b88d3:         policy.setBackOffMultiplier((short) 2);
1:33b88d3:         policy.setUseExponentialBackOff(true);
1:33b88d3: 
1:33b88d3:         long delay = policy.getNextRedeliveryDelay(0);
1:33b88d3:         assertEquals(500, delay);
1:33b88d3:         delay = policy.getNextRedeliveryDelay(delay);
1:33b88d3:         assertEquals(500*2, delay);
1:33b88d3:         delay = policy.getNextRedeliveryDelay(delay);
1:33b88d3:         assertEquals(500*4, delay);
1:33b88d3: 
1:33b88d3:         policy.setUseExponentialBackOff(false);
1:33b88d3:         delay = policy.getNextRedeliveryDelay(delay);
1:33b88d3:         assertEquals(500, delay);
1:33b88d3:     }
1:33b88d3: 
1:20832f1:     public void testGetNextWithInitialDelay() throws Exception {
1:c23f9e6: 
1:20832f1:         RedeliveryPolicy policy = new RedeliveryPolicy();
1:20832f1:         policy.setInitialRedeliveryDelay(500);
1:20832f1: 
1:20832f1:         long delay = policy.getNextRedeliveryDelay(500);
1:1d71cb7:         assertEquals(1000, delay);
1:20832f1:         delay = policy.getNextRedeliveryDelay(delay);
1:1d71cb7:         assertEquals(1000, delay);
1:20832f1:         delay = policy.getNextRedeliveryDelay(delay);
1:1d71cb7:         assertEquals(1000, delay);
1:20832f1: 
1:20832f1:     }
1:20832f1: 
1:d29ca2a:     /**
1:7f5213b:      * @throws Exception
1:d29ca2a:      */
1:7f5213b:     public void testExponentialRedeliveryPolicyDelaysDeliveryOnRollback() throws Exception {
1:d29ca2a: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:c23f9e6:         policy.setInitialRedeliveryDelay(0);
1:c23f9e6:         policy.setRedeliveryDelay(500);
1:d29ca2a:         policy.setBackOffMultiplier((short) 2);
1:d29ca2a:         policy.setUseExponentialBackOff(true);
1:c23f9e6: 
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:d301cea:         ActiveMQQueue destination = new ActiveMQQueue(getName());
1:d29ca2a:         MessageProducer producer = session.createProducer(destination);
1:f29c801: 
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:f29c801: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         producer.send(session.createTextMessage("1st"));
1:d29ca2a:         producer.send(session.createTextMessage("2nd"));
1:d29ca2a:         session.commit();
1:f29c801: 
1:d29ca2a:         TextMessage m;
1:d29ca2a:         m = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:d29ca2a:         session.rollback();
1:f29c801: 
1:da5139c:         // No delay on first rollback..
1:da5139c:         m = (TextMessage)consumer.receive(100);
1:da5139c:         assertNotNull(m);
1:da5139c:         session.rollback();
1:f29c801: 
1:da5139c:         // Show subsequent re-delivery delay is incrementing.
1:da5139c:         m = (TextMessage)consumer.receive(100);
1:d29ca2a:         assertNull(m);
1:f29c801: 
1:d301cea:         m = (TextMessage)consumer.receive(700);
1:da5139c:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:da5139c:         session.rollback();
1:f29c801: 
1:d29ca2a:         // Show re-delivery delay is incrementing exponentially
1:d29ca2a:         m = (TextMessage)consumer.receive(100);
1:d29ca2a:         assertNull(m);
5:d29ca2a:         m = (TextMessage)consumer.receive(500);
1:d29ca2a:         assertNull(m);
1:d301cea:         m = (TextMessage)consumer.receive(700);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801: 
1:d29ca2a:     }
1:f29c801: 
1:f29c801: 
1:d29ca2a:     /**
1:7f5213b:      * @throws Exception
1:d29ca2a:      */
1:7f5213b:     public void testNornalRedeliveryPolicyDelaysDeliveryOnRollback() throws Exception {
1:f29c801: 
1:d29ca2a:         // Receive a message with the JMS API
1:f29c801:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:c23f9e6:         policy.setInitialRedeliveryDelay(0);
1:c23f9e6:         policy.setRedeliveryDelay(500);
1:f29c801: 
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:d301cea:         ActiveMQQueue destination = new ActiveMQQueue(getName());
1:d29ca2a:         MessageProducer producer = session.createProducer(destination);
1:f29c801: 
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:da5139c: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         producer.send(session.createTextMessage("1st"));
1:d29ca2a:         producer.send(session.createTextMessage("2nd"));
1:d29ca2a:         session.commit();
1:da5139c: 
1:d29ca2a:         TextMessage m;
1:d29ca2a:         m = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:d29ca2a:         session.rollback();
1:da5139c: 
1:da5139c:         // No delay on first rollback..
1:d29ca2a:         m = (TextMessage)consumer.receive(100);
1:d29ca2a:         assertNotNull(m);
1:d29ca2a:         session.rollback();
1:d29ca2a: 
1:da5139c:         // Show subsequent re-delivery delay is incrementing.
1:d29ca2a:         m = (TextMessage)consumer.receive(100);
1:d29ca2a:         assertNull(m);
1:d301cea:         m = (TextMessage)consumer.receive(700);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:d29ca2a:         session.rollback();
1:d29ca2a: 
1:d29ca2a:         // The message gets redelivered after 500 ms every time since
1:d29ca2a:         // we are not using exponential backoff.
1:d29ca2a:         m = (TextMessage)consumer.receive(100);
1:d29ca2a:         assertNull(m);
1:d301cea:         m = (TextMessage)consumer.receive(700);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:7f5213b:      * @throws Exception
1:d29ca2a:      */
1:7f5213b:     public void testDLQHandling() throws Exception {
1:d29ca2a: 
1:d29ca2a:         // Receive a message with the JMS API
1:d29ca2a:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:d29ca2a:         policy.setInitialRedeliveryDelay(100);
1:d29ca2a:         policy.setUseExponentialBackOff(false);
1:d29ca2a:         policy.setMaximumRedeliveries(2);
1:f29c801: 
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:d29ca2a:         MessageProducer producer = session.createProducer(destination);
1:f29c801: 
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(destination);
1:d29ca2a:         MessageConsumer dlqConsumer = session.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1:f29c801: 
1:d29ca2a:         // Send the messages
1:d29ca2a:         producer.send(session.createTextMessage("1st"));
1:d29ca2a:         producer.send(session.createTextMessage("2nd"));
1:d29ca2a:         session.commit();
1:f29c801: 
1:d29ca2a:         TextMessage m;
1:d29ca2a:         m = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:d29ca2a:         session.rollback();
1:d29ca2a: 
1:d29ca2a:         m = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:d29ca2a:         session.rollback();
1:d29ca2a: 
1:33b88d3:         m = (TextMessage)consumer.receive(2000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:d29ca2a:         session.rollback();
1:d29ca2a: 
1:f29c801:         // The last rollback should cause the 1st message to get sent to the DLQ
1:d29ca2a:         m = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("2nd", m.getText());
1:d29ca2a:         session.commit();
1:c23f9e6: 
1:d29ca2a:         // We should be able to get the message off the DLQ now.
1:d29ca2a:         m = (TextMessage)dlqConsumer.receive(1000);
1:a3836b5:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:a971b64:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:b6bca39:         assertTrue("cause exception has policy ref: " + cause, cause.contains("RedeliveryPolicy"));
1:b6bca39:         assertTrue("cause exception has redelivered count ref: " + cause, cause.contains("[3]"));
1:b6bca39: 
1:d29ca2a:         session.commit();
1:fad1dd0: 
1:d29ca2a:     }
1:a3836b5: 
1:f29c801: 
1:d29ca2a:     /**
1:979c5d5:      * @throws Exception
1:d29ca2a:      */
1:979c5d5:     public void testInfiniteMaximumNumberOfRedeliveries() throws Exception {
1:f29c801: 
1:979c5d5:         // Receive a message with the JMS API
1:fad1dd0:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:979c5d5:         policy.setInitialRedeliveryDelay(100);
1:979c5d5:         policy.setUseExponentialBackOff(false);
1:979c5d5:        //  let's set the maximum redeliveries to no maximum (ie. infinite)
1:979c5d5:         policy.setMaximumRedeliveries(-1);
1:f29c801: 
1:f29c801: 
1:fad1dd0:         connection.start();
1:979c5d5:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:979c5d5:         MessageProducer producer = session.createProducer(destination);
1:f29c801: 
1:979c5d5:         MessageConsumer consumer = session.createConsumer(destination);
1:f29c801: 
1:979c5d5:         // Send the messages
1:979c5d5:         producer.send(session.createTextMessage("1st"));
1:979c5d5:         producer.send(session.createTextMessage("2nd"));
4:979c5d5:         session.commit();
1:f29c801: 
1:979c5d5:         TextMessage m;
1:f29c801: 
1:d29ca2a:         m = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
5:979c5d5:         session.rollback();
1:f29c801: 
1:979c5d5:         //we should be able to get the 1st message redelivered until a session.commit is called
7:979c5d5:         m = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801:         session.rollback();
1:f29c801: 
1:33b88d3:         m = (TextMessage)consumer.receive(2000);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801:         session.rollback();
1:f29c801: 
1:33b88d3:         m = (TextMessage)consumer.receive(2000);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801:         session.rollback();
1:f29c801: 
1:33b88d3:         m = (TextMessage)consumer.receive(2000);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801:         session.rollback();
1:f29c801: 
1:33b88d3:         m = (TextMessage)consumer.receive(2000);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801:         session.commit();
1:f29c801: 
1:33b88d3:         m = (TextMessage)consumer.receive(2000);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("2nd", m.getText());
1:f29c801:         session.commit();
1:f29c801: 
1:d29ca2a:     }
1:f29c801: 
1:f29c801:     /**
1:f29c801:      * @throws Exception
1:f29c801:      */
1:f29c801:     public void testMaximumRedeliveryDelay() throws Exception {
1:f29c801: 
1:f29c801:         // Receive a message with the JMS API
1:fad1dd0:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:f29c801:         policy.setInitialRedeliveryDelay(10);
1:f29c801:         policy.setUseExponentialBackOff(true);
1:f29c801:         policy.setMaximumRedeliveries(-1);
1:f29c801:         policy.setRedeliveryDelay(50);
1:f29c801:         policy.setMaximumRedeliveryDelay(1000);
1:f29c801:         policy.setBackOffMultiplier((short) 2);
1:f29c801:         policy.setUseExponentialBackOff(true);
1:f29c801: 
1:fad1dd0:         connection.start();
1:f29c801:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:f29c801:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:f29c801:         MessageProducer producer = session.createProducer(destination);
1:f29c801: 
1:f29c801:         MessageConsumer consumer = session.createConsumer(destination);
1:f29c801: 
1:f29c801:         // Send the messages
1:f29c801:         producer.send(session.createTextMessage("1st"));
1:f29c801:         producer.send(session.createTextMessage("2nd"));
1:f29c801:         session.commit();
1:f29c801: 
1:f29c801:         TextMessage m;
1:f29c801: 
1:f29c801:         for(int i = 0; i < 10; ++i) {
1:f29c801:             // we should be able to get the 1st message redelivered until a session.commit is called
1:f29c801:             m = (TextMessage)consumer.receive(2000);
1:f29c801:             assertNotNull(m);
1:f29c801:             assertEquals("1st", m.getText());
1:f29c801:             session.rollback();
1:f29c801:         }
1:f29c801: 
1:f29c801:         m = (TextMessage)consumer.receive(2000);
1:f29c801:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:f29c801:         session.commit();
1:f29c801: 
1:f29c801:         m = (TextMessage)consumer.receive(2000);
1:f29c801:         assertNotNull(m);
1:f29c801:         assertEquals("2nd", m.getText());
1:f29c801:         session.commit();
1:f29c801: 
1:f29c801:         assertTrue(policy.getNextRedeliveryDelay(Long.MAX_VALUE) == 1000 );
1:f29c801:     }
1:f29c801: 
2:979c5d5:     /**
1:979c5d5:      * @throws Exception
2:979c5d5:      */
1:979c5d5:     public void testZeroMaximumNumberOfRedeliveries() throws Exception {
1:d29ca2a: 
1:979c5d5:         // Receive a message with the JMS API
1:d29ca2a:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:979c5d5:         policy.setInitialRedeliveryDelay(100);
1:979c5d5:         policy.setUseExponentialBackOff(false);
1:979c5d5:         //let's set the maximum redeliveries to 0
1:979c5d5:         policy.setMaximumRedeliveries(0);
1:f29c801: 
1:f29c801:         connection.start();
1:979c5d5:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:979c5d5:         MessageProducer producer = session.createProducer(destination);
1:f29c801: 
1:979c5d5:         MessageConsumer consumer = session.createConsumer(destination);
1:f29c801: 
1:979c5d5:         // Send the messages
1:979c5d5:         producer.send(session.createTextMessage("1st"));
1:979c5d5:         producer.send(session.createTextMessage("2nd"));
1:979c5d5:         session.commit();
1:f29c801: 
1:979c5d5:         TextMessage m;
1:979c5d5:         m = (TextMessage)consumer.receive(1000);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("1st", m.getText());
1:979c5d5:         session.rollback();
1:f29c801: 
1:979c5d5:         //the 1st  message should not be redelivered since maximumRedeliveries is set to 0
1:979c5d5:         m = (TextMessage)consumer.receive(1000);
1:979c5d5:         assertNotNull(m);
1:f29c801:         assertEquals("2nd", m.getText());
1:f29c801:         session.commit();
1:f29c801: 
1:f29c801: 
1:f29c801: 
1:d29ca2a:     }
1:d29ca2a: 
1:fad1dd0:     public void testRepeatedRedeliveryReceiveNoCommit() throws Exception {
1:fad1dd0: 
1:fad1dd0:         connection.start();
1:fad1dd0:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:fad1dd0:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:fad1dd0:         MessageProducer producer = dlqSession.createProducer(destination);
1:fad1dd0: 
1:fad1dd0:         // Send the messages
1:fad1dd0:         producer.send(dlqSession.createTextMessage("1st"));
1:fad1dd0: 
1:fad1dd0:         dlqSession.commit();
1:fad1dd0:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1:fad1dd0: 
1:fad1dd0:         final int maxRedeliveries = 4;
1:fad1dd0:         for (int i=0;i<=maxRedeliveries +1;i++) {
1:fad1dd0: 
1:b6bca39:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:b6bca39:             connections.add(connection);
1:fad1dd0:             // Receive a message with the JMS API
1:b6bca39:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:fad1dd0:             policy.setInitialRedeliveryDelay(0);
1:fad1dd0:             policy.setUseExponentialBackOff(false);
1:fad1dd0:             policy.setMaximumRedeliveries(maxRedeliveries);
1:fad1dd0: 
1:b6bca39:             connection.start();
1:fad1dd0:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:fad1dd0:             MessageConsumer consumer = session.createConsumer(destination);
1:fad1dd0: 
1:fad1dd0:             ActiveMQTextMessage m = ((ActiveMQTextMessage)consumer.receive(4000));
1:fad1dd0:             if (i<=maxRedeliveries) {
1:fad1dd0:                 assertEquals("1st", m.getText());
1:fad1dd0:                 assertEquals(i, m.getRedeliveryCounter());
1:fad1dd0:             } else {
1:fad1dd0:                 assertNull("null on exceeding redelivery count", m);
1:fad1dd0:             }
1:b6bca39:             connection.close();
2:fad1dd0:             connections.remove(connection);
1:fad1dd0:         }
1:fad1dd0: 
1:fad1dd0:         // We should be able to get the message off the DLQ now.
1:fad1dd0:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:fad1dd0:         assertNotNull("Got message from DLQ", m);
1:fad1dd0:         assertEquals("1st", m.getText());
1:fad1dd0:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:b6bca39:         assertTrue("cause exception has policy ref: " + cause, cause.contains("RedeliveryPolicy"));
1:b6bca39:         assertTrue("cause exception has pre dispatch and count:" + cause, cause.contains("Delivery[5]"));
1:b6bca39: 
1:fad1dd0:         dlqSession.commit();
1:b6bca39: 
1:b6bca39: 
1:b6bca39:     }
1:b6bca39: 
1:b6bca39: 
1:b6bca39:     public void testRepeatedRedeliveryBrokerCloseReceiveNoCommit() throws Exception {
1:b6bca39: 
1:b6bca39:         connection.start();
1:b6bca39:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:b6bca39:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:b6bca39: 
1:b6bca39:         MessageProducer producer = session.createProducer(destination);
1:b6bca39: 
1:b6bca39:         // Send the messages
1:b6bca39:         producer.send(session.createTextMessage("1st"));
1:b6bca39: 
1:b6bca39:         session.commit();
1:b6bca39: 
1:b6bca39:         final int maxRedeliveries = 4;
1:b6bca39:         for (int i=0;i<=maxRedeliveries +1;i++) {
1:b6bca39: 
1:816f81e:             final ActiveMQConnection consumerConnection = (ActiveMQConnection)factory.createConnection(userName, password);
1:816f81e:             connections.add(consumerConnection);
1:b6bca39:             // Receive a message with the JMS API
1:816f81e:             RedeliveryPolicy policy = consumerConnection.getRedeliveryPolicy();
1:b6bca39:             policy.setInitialRedeliveryDelay(0);
1:b6bca39:             policy.setUseExponentialBackOff(false);
1:b6bca39:             policy.setMaximumRedeliveries(maxRedeliveries);
1:b6bca39: 
1:816f81e:             consumerConnection.start();
1:816f81e:             session = consumerConnection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:b6bca39:             MessageConsumer consumer = session.createConsumer(destination);
1:b6bca39: 
1:b6bca39:             ActiveMQTextMessage m = ((ActiveMQTextMessage)consumer.receive(4000));
1:b6bca39:             if (i<=maxRedeliveries) {
1:b6bca39:                 assertEquals("1st", m.getText());
1:b6bca39:                 assertEquals(i, m.getRedeliveryCounter());
1:b6bca39:             } else {
1:b6bca39:                 assertNull("null on exceeding redelivery count", m);
1:fad1dd0: 
1:b6bca39:                 assertTrue("message in dlq", Wait.waitFor(new Wait.Condition() {
1:b6bca39:                     @Override
1:b6bca39:                     public boolean isSatisified() throws Exception {
1:b6bca39:                         LOG.info("total dequeue count: " + broker.getAdminView().getTotalDequeueCount());
1:b6bca39:                         return broker.getAdminView().getTotalDequeueCount() == 1;
1:b6bca39:                     }
1:b6bca39:                 }));
1:b6bca39:             }
1:b6bca39: 
1:b6bca39:             // abortive close via broker
1:b6bca39:             for (VMTransportServer transportServer : VMTransportFactory.SERVERS.values()) {
1:b6bca39:                 transportServer.stop();
1:b6bca39:             }
1:b6bca39: 
1:816f81e:             Wait.waitFor(new Wait.Condition() {
1:816f81e:                 @Override
1:816f81e:                 public boolean isSatisified() throws Exception {
1:816f81e:                     return consumerConnection.isTransportFailed();
1:816f81e:                 }
1:816f81e:             });
1:816f81e: 
1:b6bca39:             try {
1:816f81e:                 consumerConnection.close();
1:b6bca39:             } catch (Exception expected) {
1:b6bca39:             } finally {
1:816f81e:                 connections.remove(consumerConnection);
1:816f81e:             }
1:b6bca39:         }
1:816f81e: 
1:b6bca39:         connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:b6bca39:         connection.start();
1:b6bca39:         connections.add(connection);
1:b6bca39:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:b6bca39:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1:b6bca39: 
1:b6bca39:         // We should be able to get the message off the DLQ now.
1:b6bca39:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:b6bca39:         assertNotNull("Got message from DLQ", m);
1:b6bca39:         assertEquals("1st", m.getText());
1:b6bca39:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:b6bca39:         assertTrue("cause exception has policy ref: " + cause, cause.contains("RedeliveryPolicy"));
1:b6bca39:         assertTrue("cause exception has pre dispatch and count:" + cause, cause.contains("Dispatch[5]"));
1:b6bca39: 
1:b6bca39:         dlqSession.commit();
1:b6bca39: 
1:b6bca39:     }
1:b6bca39: 
1:b6bca39:     public void testRepeatedRedeliveryReceiveBrokerCloseNoPreDispatchCheck() throws Exception {
1:b6bca39: 
1:b6bca39:         connection.start();
1:b6bca39:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:b6bca39:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:b6bca39:         MessageProducer producer = session.createProducer(destination);
1:b6bca39: 
1:b6bca39:         // Send the messages
1:b6bca39:         producer.send(session.createTextMessage("1st"));
1:b6bca39:         session.commit();
1:b6bca39: 
1:b6bca39:         final int maxRedeliveries = 4;
1:b6bca39:         for (int i=0;i<=maxRedeliveries + 1;i++) {
1:b6bca39: 
1:816f81e:             final ActiveMQConnection consumerConnection = (ActiveMQConnection)factory.createConnection(userName, password);
1:816f81e:             connections.add(consumerConnection);
1:b6bca39:             // Receive a message with the JMS API
1:816f81e:             RedeliveryPolicy policy = consumerConnection.getRedeliveryPolicy();
1:b6bca39:             policy.setInitialRedeliveryDelay(0);
1:b6bca39:             policy.setUseExponentialBackOff(false);
1:b6bca39:             policy.setMaximumRedeliveries(maxRedeliveries);
1:b6bca39:             policy.setPreDispatchCheck(false);
1:b6bca39: 
1:816f81e:             consumerConnection.start();
1:816f81e:             session = consumerConnection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:b6bca39:             MessageConsumer consumer = session.createConsumer(destination);
1:b6bca39: 
1:b6bca39:             ActiveMQTextMessage m = ((ActiveMQTextMessage)consumer.receive(4000));
1:b6bca39:             assertNotNull("got message on i=" + i, m);
1:b6bca39:             assertEquals("1st", m.getText());
1:b6bca39:             assertEquals(i, m.getRedeliveryCounter());
1:b6bca39: 
1:b6bca39:             // abortive close via broker
1:b6bca39:             for (VMTransportServer transportServer : VMTransportFactory.SERVERS.values()) {
1:b6bca39:                 transportServer.stop();
1:b6bca39:             }
1:b6bca39: 
1:816f81e:             Wait.waitFor(new Wait.Condition() {
1:816f81e:                 @Override
1:816f81e:                 public boolean isSatisified() throws Exception {
1:816f81e:                     return consumerConnection.isTransportFailed();
1:b6bca39:                 }
1:816f81e:             });
1:b6bca39: 
1:b6bca39:             try {
1:816f81e:                 consumerConnection.close();
1:b6bca39:             } catch (Exception expected) {
1:b6bca39:             } finally {
1:816f81e:                 connections.remove(consumerConnection);
1:b6bca39:             }
1:b6bca39:         }
1:fad1dd0:     }
1:fad1dd0: 
1:fad1dd0: 
1:fad1dd0:     public void testRepeatedRedeliveryOnMessageNoCommit() throws Exception {
1:fad1dd0: 
1:b6bca39:         connection.start();
1:fad1dd0:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:fad1dd0:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:fad1dd0:         MessageProducer producer = dlqSession.createProducer(destination);
1:fad1dd0: 
1:fad1dd0:         // Send the messages
1:fad1dd0:         producer.send(dlqSession.createTextMessage("1st"));
1:fad1dd0: 
1:fad1dd0:         dlqSession.commit();
1:fad1dd0:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1:fad1dd0: 
1:fad1dd0:         final int maxRedeliveries = 4;
1:fad1dd0:         final AtomicInteger receivedCount = new AtomicInteger(0);
1:fad1dd0: 
1:fad1dd0:         for (int i=0;i<=maxRedeliveries+1;i++) {
1:fad1dd0: 
1:b6bca39:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:b6bca39:             connections.add(connection);
1:fad1dd0: 
1:b6bca39:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:fad1dd0:             policy.setInitialRedeliveryDelay(0);
1:fad1dd0:             policy.setUseExponentialBackOff(false);
1:fad1dd0:             policy.setMaximumRedeliveries(maxRedeliveries);
1:fad1dd0: 
1:fad1dd0:             connection.start();
1:fad1dd0:             final Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:fad1dd0:             MessageConsumer consumer = session.createConsumer(destination);
1:fad1dd0:             final CountDownLatch done = new CountDownLatch(1);
1:fad1dd0: 
1:fad1dd0:             consumer.setMessageListener(new MessageListener(){
1:fad1dd0:                 @Override
1:fad1dd0:                 public void onMessage(Message message) {
1:fad1dd0:                     try {
1:fad1dd0:                         ActiveMQTextMessage m = (ActiveMQTextMessage)message;
1:fad1dd0:                         assertEquals("1st", m.getText());
1:fad1dd0:                         assertEquals(receivedCount.get(), m.getRedeliveryCounter());
1:fad1dd0:                         receivedCount.incrementAndGet();
1:fad1dd0:                         done.countDown();
1:fad1dd0:                     } catch (Exception ignored) {
1:fad1dd0:                         ignored.printStackTrace();
1:fad1dd0:                     }
1:fad1dd0:                 }
1:fad1dd0:             });
1:fad1dd0: 
1:fad1dd0:             if (i<=maxRedeliveries) {
1:fad1dd0:                 assertTrue("listener done", done.await(5, TimeUnit.SECONDS));
1:fad1dd0:             } else {
1:fad1dd0:                 // final redlivery gets poisoned before dispatch
1:fad1dd0:                 assertFalse("listener done", done.await(1, TimeUnit.SECONDS));
1:fad1dd0:             }
1:b6bca39:             connection.close();
1:b6bca39:             connections.remove(connection);
1:fad1dd0:         }
1:fad1dd0: 
1:fad1dd0:         // We should be able to get the message off the DLQ now.
1:fad1dd0:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:fad1dd0:         assertNotNull("Got message from DLQ", m);
1:fad1dd0:         assertEquals("1st", m.getText());
1:fad1dd0:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:b6bca39:         LOG.info("cause: " + cause);
2:fad1dd0:         assertTrue("cause exception has policy ref", cause.contains("RedeliveryPolicy"));
1:b6bca39:         assertTrue("cause exception has redelivered count ref: " + cause, cause.contains("[5]"));
1:b6bca39: 
1:fad1dd0:         dlqSession.commit();
1:fad1dd0: 
1:fad1dd0:     }
1:fad1dd0: 
1:fad1dd0:     public void testRepeatedRedeliveryServerSessionNoCommit() throws Exception {
1:fad1dd0: 
1:fad1dd0:         connection.start();
1:fad1dd0:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:fad1dd0:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:fad1dd0:         MessageProducer producer = dlqSession.createProducer(destination);
1:fad1dd0: 
1:fad1dd0:         // Send the messages
1:fad1dd0:         producer.send(dlqSession.createTextMessage("1st"));
1:fad1dd0: 
1:fad1dd0:         dlqSession.commit();
1:fad1dd0:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1:fad1dd0: 
1:fad1dd0:         final int maxRedeliveries = 4;
1:fad1dd0:         final AtomicInteger receivedCount = new AtomicInteger(0);
1:fad1dd0: 
1:fad1dd0:         for (int i=0;i<=maxRedeliveries+1;i++) {
2:fad1dd0:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
2:fad1dd0:             connections.add(connection);
1:fad1dd0: 
1:fad1dd0:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:fad1dd0:             policy.setInitialRedeliveryDelay(0);
1:fad1dd0:             policy.setUseExponentialBackOff(false);
1:fad1dd0:             policy.setMaximumRedeliveries(maxRedeliveries);
1:fad1dd0: 
1:fad1dd0:             connection.start();
1:fad1dd0:             final CountDownLatch done = new CountDownLatch(1);
1:fad1dd0: 
1:fad1dd0:             final ActiveMQSession session = (ActiveMQSession) connection.createSession(true, Session.SESSION_TRANSACTED);
1:fad1dd0:             session.setMessageListener(new MessageListener() {
1:fad1dd0:                 @Override
1:fad1dd0:                 public void onMessage(Message message) {
1:fad1dd0:                     try {
1:fad1dd0:                         ActiveMQTextMessage m = (ActiveMQTextMessage) message;
1:eb6c082:                         LOG.info("Got: " + ((ActiveMQTextMessage) message).getMessageId() + ", seq:" + ((ActiveMQTextMessage) message).getMessageId().getBrokerSequenceId());
1:fad1dd0:                         assertEquals("1st", m.getText());
1:fad1dd0:                         assertEquals(receivedCount.get(), m.getRedeliveryCounter());
1:fad1dd0:                         receivedCount.incrementAndGet();
1:fad1dd0:                         done.countDown();
1:fad1dd0:                     } catch (Exception ignored) {
1:fad1dd0:                         ignored.printStackTrace();
1:fad1dd0:                     }
1:fad1dd0:                 }
1:fad1dd0:             });
1:fad1dd0: 
1:fad1dd0:             connection.createConnectionConsumer(
1:fad1dd0:                     destination,
1:fad1dd0:                     null,
1:fad1dd0:                     new ServerSessionPool() {
1:fad1dd0:                         @Override
1:fad1dd0:                         public ServerSession getServerSession() throws JMSException {
1:fad1dd0:                             return new ServerSession() {
1:fad1dd0:                                 @Override
1:fad1dd0:                                 public Session getSession() throws JMSException {
1:fad1dd0:                                     return session;
1:fad1dd0:                                 }
1:fad1dd0: 
1:fad1dd0:                                 @Override
1:fad1dd0:                                 public void start() throws JMSException {
1:fad1dd0:                                 }
1:fad1dd0:                             };
1:fad1dd0:                         }
1:fad1dd0:                     },
1:fad1dd0:                     100,
1:fad1dd0:                     false);
1:fad1dd0: 
1:fad1dd0:             Wait.waitFor(new Wait.Condition() {
1:fad1dd0:                 @Override
1:fad1dd0:                 public boolean isSatisified() throws Exception {
1:fad1dd0:                     session.run();
1:fad1dd0:                     return done.await(10, TimeUnit.MILLISECONDS);
1:fad1dd0:                 }
1:eb6c082:             }, 5000);
1:fad1dd0: 
1:fad1dd0:             if (i<=maxRedeliveries) {
1:fad1dd0:                 assertTrue("listener done @" + i, done.await(5, TimeUnit.SECONDS));
1:fad1dd0:             } else {
1:fad1dd0:                 // final redlivery gets poisoned before dispatch
1:fad1dd0:                 assertFalse("listener not done @" + i, done.await(1, TimeUnit.SECONDS));
1:fad1dd0:             }
2:fad1dd0:             connection.close();
1:b6bca39:             connections.remove(connection);
1:fad1dd0:         }
1:fad1dd0: 
1:fad1dd0:         // We should be able to get the message off the DLQ now.
1:fad1dd0:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:fad1dd0:         assertNotNull("Got message from DLQ", m);
1:fad1dd0:         assertEquals("1st", m.getText());
1:fad1dd0:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:fad1dd0:         assertTrue("cause exception has policy ref", cause.contains("RedeliveryPolicy"));
1:fad1dd0:         dlqSession.commit();
1:fad1dd0: 
1:fad1dd0:     }
1:67c28b1: 
1:67c28b1:     public void testRedeliveryRollbackWithDelayBlocking() throws Exception
1:67c28b1:     {
1:67c28b1:         redeliveryRollbackWithDelay(true);
1:67c28b1:     }
1:67c28b1: 
1:67c28b1:     public void testRedeliveryRollbackWithDelayNonBlocking() throws Exception
1:67c28b1:     {
1:67c28b1:         redeliveryRollbackWithDelay(false);
1:67c28b1:     }
1:67c28b1: 
1:67c28b1:     public void redeliveryRollbackWithDelay(final boolean blockingRedelivery) throws Exception {
1:67c28b1: 
1:67c28b1:         connection.start();
1:67c28b1:         Session sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:67c28b1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:67c28b1:         MessageProducer producer = sendSession.createProducer(destination);
1:67c28b1:         producer.send(sendSession.createTextMessage("1st"));
1:67c28b1:         producer.send(sendSession.createTextMessage("2nd"));
1:67c28b1: 
1:67c28b1: 
1:fad1dd0:         connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:fad1dd0:         connections.add(connection);
1:67c28b1: 
1:67c28b1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:67c28b1:         policy.setInitialRedeliveryDelay(2000);
1:67c28b1:         policy.setUseExponentialBackOff(false);
1:67c28b1:         connection.setNonBlockingRedelivery(blockingRedelivery);
1:67c28b1:         connection.start();
1:67c28b1:         final CountDownLatch done = new CountDownLatch(3);
1:67c28b1: 
1:67c28b1:         final ActiveMQSession session = (ActiveMQSession) connection.createSession(true, Session.SESSION_TRANSACTED);
1:67c28b1:         final List<String> list = new ArrayList<>();
1:67c28b1:         session.setMessageListener(new MessageListener() {
1:67c28b1:             @Override
1:67c28b1:             public void onMessage(Message message) {
1:67c28b1:                 try {
1:67c28b1:                     ActiveMQTextMessage m = (ActiveMQTextMessage) message;
1:67c28b1:                     LOG.info("Got: " + ((ActiveMQTextMessage) message).getMessageId() + ", seq:" + ((ActiveMQTextMessage) message).getMessageId().getBrokerSequenceId());
1:67c28b1:                     list.add(((ActiveMQTextMessage) message).getText());
1:67c28b1:                     if (done.getCount() == 3)
1:67c28b1:                     {
1:67c28b1:                         session.rollback();
1:67c28b1:                     }
1:67c28b1:                     done.countDown();
1:67c28b1: 
1:67c28b1:                 } catch (Exception ignored) {
1:67c28b1:                     ignored.printStackTrace();
1:67c28b1:                 }
1:67c28b1:             }
1:fad1dd0:         });
1:67c28b1: 
1:67c28b1:         connection.createConnectionConsumer(
1:67c28b1:                 destination,
1:67c28b1:                 null,
1:67c28b1:                 new ServerSessionPool() {
1:67c28b1:                     @Override
1:67c28b1:                     public ServerSession getServerSession() throws JMSException {
1:67c28b1:                         return new ServerSession() {
1:67c28b1:                             @Override
1:67c28b1:                             public Session getSession() throws JMSException {
1:67c28b1:                                 return session;
1:67c28b1:                             }
1:67c28b1: 
1:67c28b1:                             @Override
1:67c28b1:                             public void start() throws JMSException {
1:67c28b1:                             }
1:67c28b1:                         };
1:67c28b1:                     }
1:67c28b1:                 },
1:67c28b1:                 100,
1:67c28b1:                 false);
1:67c28b1: 
1:67c28b1:         Wait.waitFor(new Wait.Condition() {
1:67c28b1:             @Override
1:67c28b1:             public boolean isSatisified() throws Exception {
1:67c28b1:                 session.run();
1:67c28b1:                 return done.await(10, TimeUnit.MILLISECONDS);
1:67c28b1:             }
1:67c28b1:         }, 5000);
1:67c28b1: 
1:fad1dd0:         connection.close();
1:fad1dd0:         connections.remove(connection);
1:d29ca2a: 
1:67c28b1:         assertEquals(list.size(), 3);
1:67c28b1:         if (blockingRedelivery) {
1:67c28b1:             assertEquals("1st", list.get(0));
1:67c28b1:             assertEquals("2nd", list.get(1));
1:67c28b1:             assertEquals("1st", list.get(2));
1:67c28b1:         } else {
1:67c28b1:             assertEquals("1st", list.get(0));
1:67c28b1:             assertEquals("1st", list.get(1));
1:67c28b1:             assertEquals("2nd", list.get(2));
1:67c28b1:         }
1:67c28b1:     }
1:67c28b1: 
1:c23f9e6:     public void testInitialRedeliveryDelayZero() throws Exception {
1:c23f9e6: 
1:c23f9e6:         // Receive a message with the JMS API
1:c23f9e6:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:c23f9e6:         policy.setInitialRedeliveryDelay(0);
1:c23f9e6:         policy.setUseExponentialBackOff(false);
1:c23f9e6:         policy.setMaximumRedeliveries(1);
1:c23f9e6: 
1:c23f9e6:         connection.start();
1:c23f9e6:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:c23f9e6:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:c23f9e6:         MessageProducer producer = session.createProducer(destination);
1:c23f9e6: 
1:c23f9e6:         MessageConsumer consumer = session.createConsumer(destination);
1:c23f9e6: 
1:c23f9e6:         // Send the messages
1:c23f9e6:         producer.send(session.createTextMessage("1st"));
1:c23f9e6:         producer.send(session.createTextMessage("2nd"));
1:c23f9e6:         session.commit();
1:c23f9e6: 
1:c23f9e6:         TextMessage m;
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("1st", m.getText());
1:c23f9e6:         session.rollback();
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("1st", m.getText());
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("2nd", m.getText());
1:c23f9e6:         session.commit();
1:c23f9e6: 
1:c23f9e6:         session.commit();
1:c23f9e6:     }
1:c23f9e6: 
1:c23f9e6: 
1:c23f9e6:     public void testInitialRedeliveryDelayOne() throws Exception {
1:c23f9e6: 
1:c23f9e6:         // Receive a message with the JMS API
1:c23f9e6:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:c23f9e6:         policy.setInitialRedeliveryDelay(1000);
1:c23f9e6:         policy.setUseExponentialBackOff(false);
1:c23f9e6:         policy.setMaximumRedeliveries(1);
1:c23f9e6: 
1:c23f9e6:         connection.start();
1:c23f9e6:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:c23f9e6:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:c23f9e6:         MessageProducer producer = session.createProducer(destination);
1:c23f9e6: 
1:c23f9e6:         MessageConsumer consumer = session.createConsumer(destination);
1:c23f9e6: 
1:c23f9e6:         // Send the messages
1:c23f9e6:         producer.send(session.createTextMessage("1st"));
1:c23f9e6:         producer.send(session.createTextMessage("2nd"));
1:c23f9e6:         session.commit();
1:c23f9e6: 
1:c23f9e6:         TextMessage m;
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("1st", m.getText());
1:c23f9e6:         session.rollback();
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNull(m);
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(2000);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("1st", m.getText());
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("2nd", m.getText());
1:c23f9e6:         session.commit();
1:c23f9e6:     }
1:c23f9e6: 
1:c23f9e6:     public void testRedeliveryDelayOne() throws Exception {
1:c23f9e6: 
1:c23f9e6:         // Receive a message with the JMS API
1:c23f9e6:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:c23f9e6:         policy.setInitialRedeliveryDelay(0);
1:c23f9e6:         policy.setRedeliveryDelay(1000);
1:c23f9e6:         policy.setUseExponentialBackOff(false);
1:c23f9e6:         policy.setMaximumRedeliveries(2);
1:c23f9e6: 
1:c23f9e6:         connection.start();
1:c23f9e6:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:c23f9e6:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:c23f9e6:         MessageProducer producer = session.createProducer(destination);
1:c23f9e6: 
1:c23f9e6:         MessageConsumer consumer = session.createConsumer(destination);
1:c23f9e6: 
1:c23f9e6:         // Send the messages
1:c23f9e6:         producer.send(session.createTextMessage("1st"));
1:c23f9e6:         producer.send(session.createTextMessage("2nd"));
1:c23f9e6:         session.commit();
1:c23f9e6: 
1:c23f9e6:         TextMessage m;
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("1st", m.getText());
1:c23f9e6:         session.rollback();
1:d29ca2a: 
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull("first immediate redelivery", m);
1:c23f9e6:         session.rollback();
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNull("second delivery delayed: " + m, m);
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(2000);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("1st", m.getText());
1:c23f9e6: 
1:c23f9e6:         m = (TextMessage)consumer.receive(100);
1:c23f9e6:         assertNotNull(m);
1:c23f9e6:         assertEquals("2nd", m.getText());
1:c23f9e6:         session.commit();
1:c23f9e6:     }
1:d29ca2a: 
1:a3836b5:     public void testRedeliveryPolicyPerDestination() throws Exception {
1:a3836b5: 
1:a3836b5:         RedeliveryPolicy queuePolicy = new RedeliveryPolicy();
1:a3836b5:         queuePolicy.setInitialRedeliveryDelay(0);
1:a3836b5:         queuePolicy.setRedeliveryDelay(1000);
1:a3836b5:         queuePolicy.setUseExponentialBackOff(false);
1:a3836b5:         queuePolicy.setMaximumRedeliveries(2);
1:a3836b5: 
1:a3836b5:         RedeliveryPolicy topicPolicy = new RedeliveryPolicy();
1:a3836b5:         topicPolicy.setInitialRedeliveryDelay(0);
1:a3836b5:         topicPolicy.setRedeliveryDelay(1000);
1:a3836b5:         topicPolicy.setUseExponentialBackOff(false);
1:a3836b5:         topicPolicy.setMaximumRedeliveries(3);
1:a3836b5: 
1:a3836b5:         // Receive a message with the JMS API
1:a3836b5:         RedeliveryPolicyMap map = connection.getRedeliveryPolicyMap();
1:a3836b5:         map.put(new ActiveMQTopic(">"), topicPolicy);
1:a3836b5:         map.put(new ActiveMQQueue(">"), queuePolicy);
1:a3836b5: 
1:a3836b5:         connection.start();
1:a3836b5:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:a3836b5:         ActiveMQQueue queue = new ActiveMQQueue("TEST");
1:a3836b5:         ActiveMQTopic topic = new ActiveMQTopic("TEST");
1:a3836b5: 
1:a3836b5:         MessageProducer producer = session.createProducer(null);
1:a3836b5: 
1:a3836b5:         MessageConsumer queueConsumer = session.createConsumer(queue);
1:a3836b5:         MessageConsumer topicConsumer = session.createConsumer(topic);
1:a3836b5: 
1:a3836b5:         // Send the messages
1:a3836b5:         producer.send(queue, session.createTextMessage("1st"));
1:a3836b5:         producer.send(queue, session.createTextMessage("2nd"));
1:a3836b5:         producer.send(topic, session.createTextMessage("1st"));
1:a3836b5:         producer.send(topic, session.createTextMessage("2nd"));
1:a3836b5: 
1:a3836b5:         session.commit();
1:a3836b5: 
1:a3836b5:         TextMessage m;
1:a3836b5:         m = (TextMessage)queueConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("1st", m.getText());
1:a3836b5:         m = (TextMessage)topicConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("1st", m.getText());
1:a3836b5:         m = (TextMessage)queueConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("2nd", m.getText());
1:a3836b5:         m = (TextMessage)topicConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("2nd", m.getText());
1:a3836b5:         session.rollback();
1:a3836b5: 
1:a3836b5:         m = (TextMessage)queueConsumer.receive(100);
1:a3836b5:         assertNotNull("first immediate redelivery", m);
1:a3836b5:         m = (TextMessage)topicConsumer.receive(100);
1:a3836b5:         assertNotNull("first immediate redelivery", m);
1:a3836b5:         session.rollback();
1:a3836b5: 
1:a3836b5:         m = (TextMessage)queueConsumer.receive(100);
1:a3836b5:         assertNull("second delivery delayed: " + m, m);
1:a3836b5:         m = (TextMessage)topicConsumer.receive(100);
1:a3836b5:         assertNull("second delivery delayed: " + m, m);
1:a3836b5: 
1:a3836b5:         m = (TextMessage)queueConsumer.receive(2000);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("1st", m.getText());
1:a3836b5:         m = (TextMessage)topicConsumer.receive(2000);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("1st", m.getText());
1:a3836b5: 
1:a3836b5:         m = (TextMessage)queueConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("2nd", m.getText());
1:a3836b5:         m = (TextMessage)topicConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("2nd", m.getText());
1:a3836b5:         session.rollback();
1:a3836b5: 
1:a3836b5:         m = (TextMessage)queueConsumer.receive(2000);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("1st", m.getText());
1:a3836b5:         m = (TextMessage)topicConsumer.receive(2000);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("1st", m.getText());
1:a3836b5: 
1:a3836b5:         m = (TextMessage)queueConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("2nd", m.getText());
1:a3836b5:         m = (TextMessage)topicConsumer.receive(100);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("2nd", m.getText());
1:a3836b5:         session.rollback();
1:a3836b5: 
1:a3836b5:         // No third attempt for the Queue consumer
1:a3836b5:         m = (TextMessage)queueConsumer.receive(2000);
1:a3836b5:         assertNull(m);
1:a3836b5:         m = (TextMessage)topicConsumer.receive(2000);
1:a3836b5:         assertNotNull(m);
1:a3836b5:         assertEquals("1st", m.getText());
1:a3836b5: 
1:a3836b5:         m = (TextMessage)queueConsumer.receive(100);
1:a3836b5:         assertNull(m);
1:a3836b5:         m = (TextMessage)topicConsumer.receive(100);
1:979c5d5:         assertNotNull(m);
1:a3836b5:         assertEquals("2nd", m.getText());
1:a3836b5:         session.commit();
1:a3836b5:     }
2:979c5d5: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:816f81e
/////////////////////////////////////////////////////////////////////////
1:             final ActiveMQConnection consumerConnection = (ActiveMQConnection)factory.createConnection(userName, password);
1:             connections.add(consumerConnection);
1:             RedeliveryPolicy policy = consumerConnection.getRedeliveryPolicy();
1:             consumerConnection.start();
1:             session = consumerConnection.createSession(true, Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
1:             Wait.waitFor(new Wait.Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return consumerConnection.isTransportFailed();
1:                 }
1:             });
1: 
1:                 consumerConnection.close();
1:                 connections.remove(consumerConnection);
/////////////////////////////////////////////////////////////////////////
1:             final ActiveMQConnection consumerConnection = (ActiveMQConnection)factory.createConnection(userName, password);
1:             connections.add(consumerConnection);
1:             RedeliveryPolicy policy = consumerConnection.getRedeliveryPolicy();
1:             consumerConnection.start();
1:             session = consumerConnection.createSession(true, Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
1:             Wait.waitFor(new Wait.Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return consumerConnection.isTransportFailed();
1:                 }
1:             });
1: 
1:                 consumerConnection.close();
1:                 connections.remove(consumerConnection);
commit:b6bca39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.vm.VMTransportFactory;
1: import org.apache.activemq.transport.vm.VMTransportServer;
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("cause exception has policy ref: " + cause, cause.contains("RedeliveryPolicy"));
1:         assertTrue("cause exception has redelivered count ref: " + cause, cause.contains("[3]"));
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("cause exception has policy ref: " + cause, cause.contains("RedeliveryPolicy"));
1:         assertTrue("cause exception has pre dispatch and count:" + cause, cause.contains("Delivery[5]"));
1: 
1: 
1:     }
1: 
1: 
1:     public void testRepeatedRedeliveryBrokerCloseReceiveNoCommit() throws Exception {
1: 
1:         connection.start();
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1: 
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1: 
1:         session.commit();
1: 
1:         final int maxRedeliveries = 4;
1:         for (int i=0;i<=maxRedeliveries +1;i++) {
1: 
1:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:             connections.add(connection);
1:             // Receive a message with the JMS API
1:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:             policy.setInitialRedeliveryDelay(0);
1:             policy.setUseExponentialBackOff(false);
1:             policy.setMaximumRedeliveries(maxRedeliveries);
1: 
1:             connection.start();
0:             session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer consumer = session.createConsumer(destination);
1: 
1:             ActiveMQTextMessage m = ((ActiveMQTextMessage)consumer.receive(4000));
1:             if (i<=maxRedeliveries) {
1:                 assertEquals("1st", m.getText());
1:                 assertEquals(i, m.getRedeliveryCounter());
1:             } else {
1:                 assertNull("null on exceeding redelivery count", m);
1: 
1:                 assertTrue("message in dlq", Wait.waitFor(new Wait.Condition() {
1:                     @Override
1:                     public boolean isSatisified() throws Exception {
1:                         LOG.info("total dequeue count: " + broker.getAdminView().getTotalDequeueCount());
1:                         return broker.getAdminView().getTotalDequeueCount() == 1;
1:                     }
1:                 }));
1:             }
1: 
1:             // abortive close via broker
1:             for (VMTransportServer transportServer : VMTransportFactory.SERVERS.values()) {
1:                 transportServer.stop();
1:             }
1: 
1:             try {
1:                 connection.close();
1:             } catch (Exception expected) {
1:             } finally {
1:                 connections.remove(connection);
1:             }
1:         }
1: 
1:         connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:         connection.start();
1:         connections.add(connection);
1:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1: 
1:         // We should be able to get the message off the DLQ now.
1:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:         assertNotNull("Got message from DLQ", m);
1:         assertEquals("1st", m.getText());
1:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:         assertTrue("cause exception has policy ref: " + cause, cause.contains("RedeliveryPolicy"));
1:         assertTrue("cause exception has pre dispatch and count:" + cause, cause.contains("Dispatch[5]"));
1: 
1:         dlqSession.commit();
1: 
1:     }
1: 
1:     public void testRepeatedRedeliveryReceiveBrokerCloseNoPreDispatchCheck() throws Exception {
1: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         session.commit();
1: 
1:         final int maxRedeliveries = 4;
1:         for (int i=0;i<=maxRedeliveries + 1;i++) {
1: 
1:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:             connections.add(connection);
1:             // Receive a message with the JMS API
1:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:             policy.setInitialRedeliveryDelay(0);
1:             policy.setUseExponentialBackOff(false);
1:             policy.setMaximumRedeliveries(maxRedeliveries);
1:             policy.setPreDispatchCheck(false);
1: 
1:             connection.start();
0:             session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer consumer = session.createConsumer(destination);
1: 
1:             ActiveMQTextMessage m = ((ActiveMQTextMessage)consumer.receive(4000));
1:             assertNotNull("got message on i=" + i, m);
1:             assertEquals("1st", m.getText());
1:             assertEquals(i, m.getRedeliveryCounter());
1: 
1:             // abortive close via broker
1:             for (VMTransportServer transportServer : VMTransportFactory.SERVERS.values()) {
1:                 transportServer.stop();
1:             }
1: 
1:             try {
1:                 connection.close();
1:             } catch (Exception expected) {
1:             } finally {
1:                 connections.remove(connection);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("cause: " + cause);
1:         assertTrue("cause exception has redelivered count ref: " + cause, cause.contains("[5]"));
1: 
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     static final Logger LOG = LoggerFactory.getLogger(RedeliveryPolicyTest.class);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("Got: " + ((ActiveMQTextMessage) message).getMessageId() + ", seq:" + ((ActiveMQTextMessage) message).getMessageId().getBrokerSequenceId());
/////////////////////////////////////////////////////////////////////////
1:             }, 5000);
commit:1d71cb7
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(1000, delay);
1:         assertEquals(1000, delay);
1:         assertEquals(1000, delay);
commit:fad1dd0
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.ServerSession;
1: import javax.jms.ServerSessionPool;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:     public void testRepeatedRedeliveryReceiveNoCommit() throws Exception {
1: 
1:         connection.start();
1:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = dlqSession.createProducer(destination);
1: 
1:         // Send the messages
1:         producer.send(dlqSession.createTextMessage("1st"));
1: 
1:         dlqSession.commit();
1:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1: 
1:         final int maxRedeliveries = 4;
1:         for (int i=0;i<=maxRedeliveries +1;i++) {
1: 
1:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:             connections.add(connection);
1:             // Receive a message with the JMS API
1:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:             policy.setInitialRedeliveryDelay(0);
1:             policy.setUseExponentialBackOff(false);
1:             policy.setMaximumRedeliveries(maxRedeliveries);
1: 
1:             connection.start();
1:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer consumer = session.createConsumer(destination);
1: 
1:             ActiveMQTextMessage m = ((ActiveMQTextMessage)consumer.receive(4000));
1:             if (i<=maxRedeliveries) {
1:                 assertEquals("1st", m.getText());
1:                 assertEquals(i, m.getRedeliveryCounter());
1:             } else {
1:                 assertNull("null on exceeding redelivery count", m);
1:             }
1:             connection.close();
1:             connections.remove(connection);
1:         }
1: 
1:         // We should be able to get the message off the DLQ now.
1:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:         assertNotNull("Got message from DLQ", m);
1:         assertEquals("1st", m.getText());
1:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:         assertTrue("cause exception has policy ref", cause.contains("RedeliveryPolicy"));
1:         dlqSession.commit();
1: 
1:     }
1: 
1: 
1:     public void testRepeatedRedeliveryOnMessageNoCommit() throws Exception {
1: 
1:         connection.start();
1:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = dlqSession.createProducer(destination);
1: 
1:         // Send the messages
1:         producer.send(dlqSession.createTextMessage("1st"));
1: 
1:         dlqSession.commit();
1:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1: 
1:         final int maxRedeliveries = 4;
1:         final AtomicInteger receivedCount = new AtomicInteger(0);
1: 
1:         for (int i=0;i<=maxRedeliveries+1;i++) {
1: 
1:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:             connections.add(connection);
1: 
1:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:             policy.setInitialRedeliveryDelay(0);
1:             policy.setUseExponentialBackOff(false);
1:             policy.setMaximumRedeliveries(maxRedeliveries);
1: 
1:             connection.start();
1:             final Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:             MessageConsumer consumer = session.createConsumer(destination);
1:             final CountDownLatch done = new CountDownLatch(1);
1: 
1:             consumer.setMessageListener(new MessageListener(){
1:                 @Override
1:                 public void onMessage(Message message) {
1:                     try {
1:                         ActiveMQTextMessage m = (ActiveMQTextMessage)message;
1:                         assertEquals("1st", m.getText());
1:                         assertEquals(receivedCount.get(), m.getRedeliveryCounter());
1:                         receivedCount.incrementAndGet();
1:                         done.countDown();
1:                     } catch (Exception ignored) {
1:                         ignored.printStackTrace();
1:                     }
1:                 }
1:             });
1: 
1:             if (i<=maxRedeliveries) {
1:                 assertTrue("listener done", done.await(5, TimeUnit.SECONDS));
1:             } else {
1:                 // final redlivery gets poisoned before dispatch
1:                 assertFalse("listener done", done.await(1, TimeUnit.SECONDS));
1:             }
1:             connection.close();
1:             connections.remove(connection);
1:         }
1: 
1:         // We should be able to get the message off the DLQ now.
1:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:         assertNotNull("Got message from DLQ", m);
1:         assertEquals("1st", m.getText());
1:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:         assertTrue("cause exception has policy ref", cause.contains("RedeliveryPolicy"));
1:         dlqSession.commit();
1: 
1:     }
1: 
1:     public void testRepeatedRedeliveryServerSessionNoCommit() throws Exception {
1: 
1:         connection.start();
1:         Session dlqSession = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = dlqSession.createProducer(destination);
1: 
1:         // Send the messages
1:         producer.send(dlqSession.createTextMessage("1st"));
1: 
1:         dlqSession.commit();
1:         MessageConsumer dlqConsumer = dlqSession.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1: 
1:         final int maxRedeliveries = 4;
1:         final AtomicInteger receivedCount = new AtomicInteger(0);
1: 
1:         for (int i=0;i<=maxRedeliveries+1;i++) {
1: 
1:             connection = (ActiveMQConnection)factory.createConnection(userName, password);
1:             connections.add(connection);
1: 
1:             RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:             policy.setInitialRedeliveryDelay(0);
1:             policy.setUseExponentialBackOff(false);
1:             policy.setMaximumRedeliveries(maxRedeliveries);
1: 
1:             connection.start();
1:             final CountDownLatch done = new CountDownLatch(1);
1: 
1:             final ActiveMQSession session = (ActiveMQSession) connection.createSession(true, Session.SESSION_TRANSACTED);
1:             session.setMessageListener(new MessageListener() {
1:                 @Override
1:                 public void onMessage(Message message) {
1:                     try {
1:                         ActiveMQTextMessage m = (ActiveMQTextMessage) message;
1:                         assertEquals("1st", m.getText());
1:                         assertEquals(receivedCount.get(), m.getRedeliveryCounter());
1:                         receivedCount.incrementAndGet();
1:                         done.countDown();
1:                     } catch (Exception ignored) {
1:                         ignored.printStackTrace();
1:                     }
1:                 }
1:             });
1: 
1:             connection.createConnectionConsumer(
1:                     destination,
1:                     null,
1:                     new ServerSessionPool() {
1:                         @Override
1:                         public ServerSession getServerSession() throws JMSException {
1:                             return new ServerSession() {
1:                                 @Override
1:                                 public Session getSession() throws JMSException {
1:                                     return session;
1:                                 }
1: 
1:                                 @Override
1:                                 public void start() throws JMSException {
1:                                 }
1:                             };
1:                         }
1:                     },
1:                     100,
1:                     false);
1: 
1:             Wait.waitFor(new Wait.Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     session.run();
1:                     return done.await(10, TimeUnit.MILLISECONDS);
1:                 }
1:             });
1: 
1:             if (i<=maxRedeliveries) {
1:                 assertTrue("listener done @" + i, done.await(5, TimeUnit.SECONDS));
1:             } else {
1:                 // final redlivery gets poisoned before dispatch
1:                 assertFalse("listener not done @" + i, done.await(1, TimeUnit.SECONDS));
1:             }
1:             connection.close();
1:             connections.remove(connection);
1:         }
1: 
1:         // We should be able to get the message off the DLQ now.
1:         TextMessage m = (TextMessage)dlqConsumer.receive(1000);
1:         assertNotNull("Got message from DLQ", m);
1:         assertEquals("1st", m.getText());
1:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:         assertTrue("cause exception has policy ref", cause.contains("RedeliveryPolicy"));
1:         dlqSession.commit();
1: 
1:     }
commit:33b88d3
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testGetNext() throws Exception {
1: 
1:         RedeliveryPolicy policy = new RedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(0);
1:         policy.setRedeliveryDelay(500);
1:         policy.setBackOffMultiplier((short) 2);
1:         policy.setUseExponentialBackOff(true);
1: 
1:         long delay = policy.getNextRedeliveryDelay(0);
1:         assertEquals(500, delay);
1:         delay = policy.getNextRedeliveryDelay(delay);
1:         assertEquals(500*2, delay);
1:         delay = policy.getNextRedeliveryDelay(delay);
1:         assertEquals(500*4, delay);
1: 
1:         policy.setUseExponentialBackOff(false);
1:         delay = policy.getNextRedeliveryDelay(delay);
1:         assertEquals(500, delay);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         m = (TextMessage)consumer.receive(2000);
/////////////////////////////////////////////////////////////////////////
1:         m = (TextMessage)consumer.receive(2000);
1:         m = (TextMessage)consumer.receive(2000);
1:         m = (TextMessage)consumer.receive(2000);
1:         m = (TextMessage)consumer.receive(2000);
1:         m = (TextMessage)consumer.receive(2000);
author:Andy Taylor
-------------------------------------------------------------------------------
commit:67c28b1
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     public void testRedeliveryRollbackWithDelayBlocking() throws Exception
1:     {
1:         redeliveryRollbackWithDelay(true);
1:     }
1: 
1:     public void testRedeliveryRollbackWithDelayNonBlocking() throws Exception
1:     {
1:         redeliveryRollbackWithDelay(false);
1:     }
1: 
1:     public void redeliveryRollbackWithDelay(final boolean blockingRedelivery) throws Exception {
1: 
1:         connection.start();
1:         Session sendSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = sendSession.createProducer(destination);
1:         producer.send(sendSession.createTextMessage("1st"));
1:         producer.send(sendSession.createTextMessage("2nd"));
1: 
1: 
0:         connection = (ActiveMQConnection)factory.createConnection(userName, password);
0:         connections.add(connection);
1: 
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(2000);
1:         policy.setUseExponentialBackOff(false);
1:         connection.setNonBlockingRedelivery(blockingRedelivery);
1:         connection.start();
1:         final CountDownLatch done = new CountDownLatch(3);
1: 
1:         final ActiveMQSession session = (ActiveMQSession) connection.createSession(true, Session.SESSION_TRANSACTED);
1:         final List<String> list = new ArrayList<>();
1:         session.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 try {
1:                     ActiveMQTextMessage m = (ActiveMQTextMessage) message;
1:                     LOG.info("Got: " + ((ActiveMQTextMessage) message).getMessageId() + ", seq:" + ((ActiveMQTextMessage) message).getMessageId().getBrokerSequenceId());
1:                     list.add(((ActiveMQTextMessage) message).getText());
1:                     if (done.getCount() == 3)
1:                     {
1:                         session.rollback();
1:                     }
1:                     done.countDown();
1: 
1:                 } catch (Exception ignored) {
1:                     ignored.printStackTrace();
1:                 }
1:             }
0:         });
1: 
1:         connection.createConnectionConsumer(
1:                 destination,
1:                 null,
1:                 new ServerSessionPool() {
1:                     @Override
1:                     public ServerSession getServerSession() throws JMSException {
1:                         return new ServerSession() {
1:                             @Override
1:                             public Session getSession() throws JMSException {
1:                                 return session;
1:                             }
1: 
1:                             @Override
1:                             public void start() throws JMSException {
1:                             }
1:                         };
1:                     }
1:                 },
1:                 100,
1:                 false);
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 session.run();
1:                 return done.await(10, TimeUnit.MILLISECONDS);
1:             }
1:         }, 5000);
1: 
0:         connection.close();
0:         connections.remove(connection);
1: 
1:         assertEquals(list.size(), 3);
1:         if (blockingRedelivery) {
1:             assertEquals("1st", list.get(0));
1:             assertEquals("2nd", list.get(1));
1:             assertEquals("1st", list.get(2));
1:         } else {
1:             assertEquals("1st", list.get(0));
1:             assertEquals("1st", list.get(1));
1:             assertEquals("2nd", list.get(2));
1:         }
1:     }
1: 
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:20832f1
/////////////////////////////////////////////////////////////////////////
1:     public void testGetNextWithInitialDelay() throws Exception {
1: 
1:         RedeliveryPolicy policy = new RedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(500);
1: 
1:         long delay = policy.getNextRedeliveryDelay(500);
0:         assertEquals(500, delay);
1:         delay = policy.getNextRedeliveryDelay(delay);
0:         assertEquals(500, delay);
1:         delay = policy.getNextRedeliveryDelay(delay);
0:         assertEquals(500, delay);
1: 
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:a971b64
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
1:         String cause = m.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
0:         assertTrue("cause exception has policy ref", cause.contains("RedeliveryPolicy"));
commit:c23f9e6
/////////////////////////////////////////////////////////////////////////
1:         policy.setInitialRedeliveryDelay(0);
1:         policy.setRedeliveryDelay(500);              
/////////////////////////////////////////////////////////////////////////
1:         policy.setInitialRedeliveryDelay(0);
1:         policy.setRedeliveryDelay(500);
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1: 
1:     public void testInitialRedeliveryDelayZero() throws Exception {
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(0);
1:         policy.setUseExponentialBackOff(false);
1:         policy.setMaximumRedeliveries(1);
1: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
1: 
1:         TextMessage m;
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         session.rollback();
1: 
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1: 
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.commit();
1: 
1:         session.commit();
1:     }
1: 
1: 
1:     public void testInitialRedeliveryDelayOne() throws Exception {
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(1000);
1:         policy.setUseExponentialBackOff(false);
1:         policy.setMaximumRedeliveries(1);
1: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
1: 
1:         TextMessage m;
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         session.rollback();
1: 
1:         m = (TextMessage)consumer.receive(100);
1:         assertNull(m);
1: 
1:         m = (TextMessage)consumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1: 
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.commit();
1:     }
1: 
1:     public void testRedeliveryDelayOne() throws Exception {
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(0);
1:         policy.setRedeliveryDelay(1000);
1:         policy.setUseExponentialBackOff(false);
1:         policy.setMaximumRedeliveries(2);
1: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
1: 
1:         TextMessage m;
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         session.rollback();
1: 
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull("first immediate redelivery", m);
1:         session.rollback();
1: 
1:         m = (TextMessage)consumer.receive(100);
1:         assertNull("second delivery delayed: " + m, m);
1: 
1:         m = (TextMessage)consumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1: 
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.commit();
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:a3836b5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.RedeliveryPolicyMap;
1: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testRedeliveryPolicyPerDestination() throws Exception {
1: 
1:         RedeliveryPolicy queuePolicy = new RedeliveryPolicy();
1:         queuePolicy.setInitialRedeliveryDelay(0);
1:         queuePolicy.setRedeliveryDelay(1000);
1:         queuePolicy.setUseExponentialBackOff(false);
1:         queuePolicy.setMaximumRedeliveries(2);
1: 
1:         RedeliveryPolicy topicPolicy = new RedeliveryPolicy();
1:         topicPolicy.setInitialRedeliveryDelay(0);
1:         topicPolicy.setRedeliveryDelay(1000);
1:         topicPolicy.setUseExponentialBackOff(false);
1:         topicPolicy.setMaximumRedeliveries(3);
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicyMap map = connection.getRedeliveryPolicyMap();
1:         map.put(new ActiveMQTopic(">"), topicPolicy);
1:         map.put(new ActiveMQQueue(">"), queuePolicy);
1: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue queue = new ActiveMQQueue("TEST");
1:         ActiveMQTopic topic = new ActiveMQTopic("TEST");
1: 
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         MessageConsumer queueConsumer = session.createConsumer(queue);
1:         MessageConsumer topicConsumer = session.createConsumer(topic);
1: 
1:         // Send the messages
1:         producer.send(queue, session.createTextMessage("1st"));
1:         producer.send(queue, session.createTextMessage("2nd"));
1:         producer.send(topic, session.createTextMessage("1st"));
1:         producer.send(topic, session.createTextMessage("2nd"));
1: 
1:         session.commit();
1: 
1:         TextMessage m;
1:         m = (TextMessage)queueConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         m = (TextMessage)topicConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         m = (TextMessage)queueConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         m = (TextMessage)topicConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.rollback();
1: 
1:         m = (TextMessage)queueConsumer.receive(100);
1:         assertNotNull("first immediate redelivery", m);
1:         m = (TextMessage)topicConsumer.receive(100);
1:         assertNotNull("first immediate redelivery", m);
1:         session.rollback();
1: 
1:         m = (TextMessage)queueConsumer.receive(100);
1:         assertNull("second delivery delayed: " + m, m);
1:         m = (TextMessage)topicConsumer.receive(100);
1:         assertNull("second delivery delayed: " + m, m);
1: 
1:         m = (TextMessage)queueConsumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         m = (TextMessage)topicConsumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1: 
1:         m = (TextMessage)queueConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         m = (TextMessage)topicConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.rollback();
1: 
1:         m = (TextMessage)queueConsumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         m = (TextMessage)topicConsumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1: 
1:         m = (TextMessage)queueConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         m = (TextMessage)topicConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.rollback();
1: 
1:         // No third attempt for the Queue consumer
1:         m = (TextMessage)queueConsumer.receive(2000);
1:         assertNull(m);
1:         m = (TextMessage)topicConsumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1: 
1:         m = (TextMessage)queueConsumer.receive(100);
1:         assertNull(m);
1:         m = (TextMessage)topicConsumer.receive(100);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.commit();
1:     }
commit:f29c801
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
0:         policy.setRedeliveryDelay(500);
1: 
1: 
1: 
1:         assertEquals("1st", m.getText());
1: 
1: 
1:         assertEquals("1st", m.getText());
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("1st", m.getText());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         assertEquals("1st", m.getText());
1: 
1:         assertEquals("1st", m.getText());
1: 
1:         assertEquals("1st", m.getText());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertEquals("1st", m.getText());
1:         assertEquals("1st", m.getText());
1:         assertEquals("1st", m.getText());
1: 
1:         // The last rollback should cause the 1st message to get sent to the DLQ
1:         assertEquals("2nd", m.getText());
1: 
1:         assertEquals("1st", m.getText());
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
1:         assertEquals("1st", m.getText());
1: 
1:         assertEquals("1st", m.getText());
1:         session.rollback();
1: 
1:         assertEquals("1st", m.getText());
1:         session.rollback();
1: 
1:         assertEquals("1st", m.getText());
1:         session.rollback();
1: 
1:         assertEquals("1st", m.getText());
1:         session.rollback();
1: 
1:         assertEquals("1st", m.getText());
1:         session.commit();
1: 
1:         assertEquals("2nd", m.getText());
1:         session.commit();
1: 
1: 
1:     /**
1:      * @throws Exception
1:      */
1:     public void testMaximumRedeliveryDelay() throws Exception {
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(10);
1:         policy.setUseExponentialBackOff(true);
1:         policy.setMaximumRedeliveries(-1);
1:         policy.setRedeliveryDelay(50);
1:         policy.setMaximumRedeliveryDelay(1000);
1:         policy.setBackOffMultiplier((short) 2);
1:         policy.setUseExponentialBackOff(true);
1: 
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
1: 
1:         TextMessage m;
1: 
1:         for(int i = 0; i < 10; ++i) {
1:             // we should be able to get the 1st message redelivered until a session.commit is called
1:             m = (TextMessage)consumer.receive(2000);
1:             assertNotNull(m);
1:             assertEquals("1st", m.getText());
1:             session.rollback();
1:         }
1: 
1:         m = (TextMessage)consumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("1st", m.getText());
1:         session.commit();
1: 
1:         m = (TextMessage)consumer.receive(2000);
1:         assertNotNull(m);
1:         assertEquals("2nd", m.getText());
1:         session.commit();
1: 
1:         assertTrue(policy.getNextRedeliveryDelay(Long.MAX_VALUE) == 1000 );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1:         assertEquals("1st", m.getText());
1: 
1:         assertEquals("2nd", m.getText());
1:         session.commit();
1: 
1: 
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:d301cea
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQQueue destination = new ActiveMQQueue(getName());
/////////////////////////////////////////////////////////////////////////
1:         m = (TextMessage)consumer.receive(700);
/////////////////////////////////////////////////////////////////////////
1:         m = (TextMessage)consumer.receive(700);
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQQueue destination = new ActiveMQQueue(getName());
/////////////////////////////////////////////////////////////////////////
1:         m = (TextMessage)consumer.receive(700);
/////////////////////////////////////////////////////////////////////////
1:         m = (TextMessage)consumer.receive(700);
commit:da5139c
/////////////////////////////////////////////////////////////////////////
1:         // No delay on first rollback..
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         session.rollback();
1:         
1:         // Show subsequent re-delivery delay is incrementing.
1:         
/////////////////////////////////////////////////////////////////////////
1:         // No delay on first rollback..
1:         m = (TextMessage)consumer.receive(100);
1:         assertNotNull(m);
1:         session.rollback();
1:         
1:         // Show subsequent re-delivery delay is incrementing.
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception
1:     public void testExponentialRedeliveryPolicyDelaysDeliveryOnRollback() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception
1:     public void testNornalRedeliveryPolicyDelaysDeliveryOnRollback() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception
1:     public void testDLQHandling() throws Exception {
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.RedeliveryPolicy;
1: 
1: /**
0:  * Test cases used to test the JMS message exclusive consumers.
0:  * 
0:  * @version $Revision$
1:  */
1: public class RedeliveryPolicyTest extends JmsTestSupport {
1: 
1:     public static Test suite() {
1:         return suite(RedeliveryPolicyTest.class);
1:     }
1: 
1:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
1: 
1:     /**
0:      * @throws Throwable
1:      */
0:     public void testExponentialRedeliveryPolicyDelaysDeliveryOnRollback() throws Throwable {
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
0:         policy.setInitialRedeliveryDelay(500);
1:         policy.setBackOffMultiplier((short) 2);
1:         policy.setUseExponentialBackOff(true);
1:         
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1:         
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
1:         
1:         TextMessage m;
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
1: 
0:         // Show re-delivery delay is incrementing.
1:         m = (TextMessage)consumer.receive(100);
1:         assertNull(m);
1:         m = (TextMessage)consumer.receive(500);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
1:         
1:         // Show re-delivery delay is incrementing exponentially
1:         m = (TextMessage)consumer.receive(100);
1:         assertNull(m);
1:         m = (TextMessage)consumer.receive(500);
1:         assertNull(m);
1:         m = (TextMessage)consumer.receive(500);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         
1:     }
1: 
1: 
1:     /**
0:      * @throws Throwable
1:      */
0:     public void testNornalRedeliveryPolicyDelaysDeliveryOnRollback() throws Throwable {
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
0:         policy.setInitialRedeliveryDelay(500);
1:         
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1:         
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
1:         
1:         TextMessage m;
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
1: 
0:         // Show re-delivery delay is incrementing.
1:         m = (TextMessage)consumer.receive(100);
1:         assertNull(m);
1:         m = (TextMessage)consumer.receive(500);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
1:         
1:         // The message gets redelivered after 500 ms every time since
1:         // we are not using exponential backoff.
1:         m = (TextMessage)consumer.receive(100);
1:         assertNull(m);
1:         m = (TextMessage)consumer.receive(500);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         
1:     }
1: 
1:     /**
0:      * @throws Throwable
1:      */
0:     public void testDLQHandling() throws Throwable {
1: 
1:         // Receive a message with the JMS API
1:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(100);
1:         policy.setUseExponentialBackOff(false);
1:         policy.setMaximumRedeliveries(2);
1:         
1:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1:         
1:         MessageConsumer consumer = session.createConsumer(destination);
1:         MessageConsumer dlqConsumer = session.createConsumer(new ActiveMQQueue("ActiveMQ.DLQ"));
1: 
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
1:         
1:         TextMessage m;
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
1: 
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
1: 
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
1:         
0:         // The last rollback should cause the 1st message to get sent to the DLQ 
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("2nd", m.getText());        
1:         session.commit();
1:         
1:         // We should be able to get the message off the DLQ now.
1:         m = (TextMessage)dlqConsumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.commit();
1:         
1:     }
1: }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:979c5d5
/////////////////////////////////////////////////////////////////////////
0:     
0:     
1:     /**
1:      * @throws Exception
1:      */
1:     public void testInfiniteMaximumNumberOfRedeliveries() throws Exception {
0: 
1:         // Receive a message with the JMS API
0:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(100);
1:         policy.setUseExponentialBackOff(false);
1:        //  let's set the maximum redeliveries to no maximum (ie. infinite)
1:         policy.setMaximumRedeliveries(-1);
0:         
0:         
0:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
0:         
1:         MessageConsumer consumer = session.createConsumer(destination);
0:         
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
0:            
1:         TextMessage m;
0:  
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
0:         
1:         //we should be able to get the 1st message redelivered until a session.commit is called
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();           
0:         
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();  
0:         
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();  
0:         
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();  
0:         
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.commit();  
0:         
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("2nd", m.getText());        
1:         session.commit();  
0:        
1:     }
0:     
1:     /**
1:      * @throws Exception
1:      */
1:     public void testZeroMaximumNumberOfRedeliveries() throws Exception {
0: 
1:         // Receive a message with the JMS API
0:         RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(100);
1:         policy.setUseExponentialBackOff(false);
1:         //let's set the maximum redeliveries to 0
1:         policy.setMaximumRedeliveries(0);
0:       
0:         connection.start();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
0:         ActiveMQQueue destination = new ActiveMQQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
0:         
1:         MessageConsumer consumer = session.createConsumer(destination);
0:         
1:         // Send the messages
1:         producer.send(session.createTextMessage("1st"));
1:         producer.send(session.createTextMessage("2nd"));
1:         session.commit();
0:         
1:         TextMessage m;
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("1st", m.getText());        
1:         session.rollback();
0:         
1:         //the 1st  message should not be redelivered since maximumRedeliveries is set to 0
1:         m = (TextMessage)consumer.receive(1000);
1:         assertNotNull(m);
0:         assertEquals("2nd", m.getText());        
1:         session.commit();        
0:      
0:   
0:        
1:     }    
author:James Strachan
-------------------------------------------------------------------------------
commit:c8d74e7
/////////////////////////////////////////////////////////////////////////
============================================================================