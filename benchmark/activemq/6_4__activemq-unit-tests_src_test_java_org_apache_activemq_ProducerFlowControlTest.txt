1:9a432f2: /**
1:9a432f2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9a432f2:  * contributor license agreements.  See the NOTICE file distributed with
1:9a432f2:  * this work for additional information regarding copyright ownership.
1:9a432f2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9a432f2:  * (the "License"); you may not use this file except in compliance with
1:9a432f2:  * the License.  You may obtain a copy of the License at
1:9a432f2:  *
1:9a432f2:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9a432f2:  *
1:9a432f2:  * Unless required by applicable law or agreed to in writing, software
1:9a432f2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9a432f2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9a432f2:  * See the License for the specific language governing permissions and
1:9a432f2:  * limitations under the License.
1:9a432f2:  */
1:9a432f2: package org.apache.activemq;
3:9a432f2: 
1:9a432f2: import java.io.IOException;
1:9a432f2: import java.util.concurrent.CountDownLatch;
1:9a432f2: import java.util.concurrent.TimeUnit;
1:9a432f2: import java.util.concurrent.atomic.AtomicBoolean;
1:01b1f7f: import java.util.concurrent.atomic.AtomicInteger;
1:9a432f2: 
1:01b1f7f: import javax.jms.Connection;
1:9a432f2: import javax.jms.ConnectionFactory;
1:9a432f2: import javax.jms.DeliveryMode;
1:9a432f2: import javax.jms.JMSException;
1:9a432f2: import javax.jms.MessageConsumer;
1:9a432f2: import javax.jms.MessageProducer;
1:9a432f2: import javax.jms.Session;
1:9a432f2: import javax.jms.TextMessage;
1:9a432f2: 
1:9a432f2: import org.apache.activemq.broker.BrokerService;
1:9a432f2: import org.apache.activemq.broker.TransportConnector;
1:01b1f7f: import org.apache.activemq.broker.region.Queue;
1:01b1f7f: import org.apache.activemq.broker.region.Topic;
1:9a432f2: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:9a432f2: import org.apache.activemq.broker.region.policy.PolicyMap;
1:9a432f2: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
1:9a432f2: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
1:9a432f2: import org.apache.activemq.command.ActiveMQQueue;
1:9a432f2: import org.apache.activemq.transport.tcp.TcpTransport;
1:01b1f7f: import org.apache.activemq.util.DefaultTestAppender;
1:01b1f7f: import org.apache.log4j.Appender;
1:01b1f7f: import org.apache.log4j.Level;
1:01b1f7f: import org.apache.log4j.spi.LoggingEvent;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:9a432f2: 
1:9a432f2: public class ProducerFlowControlTest extends JmsTestSupport {
1:8bf987b:     static final Logger LOG = LoggerFactory.getLogger(ProducerFlowControlTest.class);
1:9a432f2:     ActiveMQQueue queueA = new ActiveMQQueue("QUEUE.A");
1:9a432f2:     ActiveMQQueue queueB = new ActiveMQQueue("QUEUE.B");
1:f1d59cd:     protected TransportConnector connector;
1:f1d59cd:     protected ActiveMQConnection connection;
1:f1d59cd:     // used to test sendFailIfNoSpace on SystemUsage 
1:f1d59cd:     protected final AtomicBoolean gotResourceException = new AtomicBoolean(false);
1:9a432f2: 
1:9a432f2:     public void test2ndPubisherWithProducerWindowSendConnectionThatIsBlocked() throws Exception {
1:9a432f2:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
2:9a432f2:         factory.setProducerWindowSize(1024 * 64);
1:9a432f2:         connection = (ActiveMQConnection)factory.createConnection();
1:9a432f2:         connections.add(connection);
1:9a432f2:         connection.start();
1:9a432f2: 
1:9a432f2:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:9a432f2:         MessageConsumer consumer = session.createConsumer(queueB);
1:9a432f2: 
1:9a432f2:         // Test sending to Queue A
1:9a432f2:         // 1 few sends should not block until the producer window is used up.
1:9a432f2:         fillQueue(queueA);
1:9a432f2: 
1:9a432f2:         // Test sending to Queue B it should not block since the connection
1:9a432f2:         // should not be blocked.
1:9a432f2:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
1:9a432f2:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1:9a432f2: 
1:9a432f2:         TextMessage msg = (TextMessage)consumer.receive();
1:9a432f2:         assertEquals("Message 1", msg.getText());
1:9a432f2:         msg.acknowledge();
1:9a432f2: 
1:9a432f2:         pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
1:9a432f2:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1:9a432f2: 
1:9a432f2:         msg = (TextMessage)consumer.receive();
1:9a432f2:         assertEquals("Message 2", msg.getText());
1:9a432f2:         msg.acknowledge();
3:9a432f2:     }
1:f1d59cd: 
1:9a432f2:     public void testPubisherRecoverAfterBlock() throws Exception {
1:9a432f2:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:9a432f2:         connection = (ActiveMQConnection)factory.createConnection();
1:9a432f2:         connections.add(connection);
1:9a432f2:         connection.start();
1:9a432f2: 
1:9a432f2:         final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:9a432f2:         final MessageProducer producer = session.createProducer(queueA);
1:9a432f2:         
1:9a432f2:         final AtomicBoolean done = new AtomicBoolean(true);
1:9a432f2:         final AtomicBoolean keepGoing = new AtomicBoolean(true);
1:f1d59cd:         
1:f1d59cd:    
1:9a432f2: 		Thread thread = new Thread("Filler") {
1:97e0fcc: 		    int i;
1:9a432f2: 			@Override
1:9a432f2: 			public void run() {
1:9a432f2:                 while (keepGoing.get()) {
1:9a432f2:                     done.set(false);
1:9a432f2:                     try {
1:97e0fcc: 						producer.send(session.createTextMessage("Test message " + ++i));
1:97e0fcc: 						LOG.info("sent: " + i);
1:9a432f2: 					} catch (JMSException e) {
1:9a432f2: 					}
1:9a432f2:                 }
1:9a432f2: 			}
1:9a432f2: 		};
1:9a432f2: 		thread.start();
1:f1d59cd:         waitForBlockedOrResourceLimit(done);
1:9a432f2: 
1:9a432f2:         // after receiveing messges, producer should continue sending messages 
1:9a432f2:         // (done == false)
1:9a432f2:         MessageConsumer consumer = session.createConsumer(queueA);
1:9a432f2:         TextMessage msg;
1:9a432f2:         for (int idx = 0; idx < 5; ++idx) {
1:9a432f2:         	msg = (TextMessage) consumer.receive(1000);
1:97e0fcc:         	LOG.info("received: " + idx + ", msg: " + msg.getJMSMessageID());
1:9a432f2:         	msg.acknowledge();
1:9a432f2:         }
2:9a432f2:         Thread.sleep(1000);
2:9a432f2:         keepGoing.set(false);
1:97e0fcc:     	
1:97e0fcc: 		assertFalse("producer has resumed", done.get());
1:9a432f2:     }
1:97e0fcc: 
1:97e0fcc:     public void testAsyncPubisherRecoverAfterBlock() throws Exception {
1:97e0fcc:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:97e0fcc:         factory.setProducerWindowSize(1024 * 5);
1:97e0fcc:         factory.setUseAsyncSend(true);
1:97e0fcc:         connection = (ActiveMQConnection)factory.createConnection();
1:97e0fcc:         connections.add(connection);
1:97e0fcc:         connection.start();
1:97e0fcc: 
1:97e0fcc:         final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:97e0fcc:         final MessageProducer producer = session.createProducer(queueA);
1:97e0fcc:         
1:97e0fcc:         final AtomicBoolean done = new AtomicBoolean(true);
1:97e0fcc:         final AtomicBoolean keepGoing = new AtomicBoolean(true);
1:97e0fcc:         
1:97e0fcc:    
1:97e0fcc:         Thread thread = new Thread("Filler") {
1:97e0fcc:             int i;
1:97e0fcc:             @Override
1:97e0fcc:             public void run() {
1:97e0fcc:                 while (keepGoing.get()) {
1:97e0fcc:                     done.set(false);
1:97e0fcc:                     try {
1:97e0fcc:                         producer.send(session.createTextMessage("Test message " + ++i));
1:97e0fcc:                         LOG.info("sent: " + i);
1:97e0fcc:                     } catch (JMSException e) {
1:97e0fcc:                     }
1:97e0fcc:                 }
1:97e0fcc:             }
1:97e0fcc:         };
1:97e0fcc:         thread.start();
1:97e0fcc:         waitForBlockedOrResourceLimit(done);
1:97e0fcc: 
1:97e0fcc:         // after receiveing messges, producer should continue sending messages 
1:97e0fcc:         // (done == false)
1:97e0fcc:         MessageConsumer consumer = session.createConsumer(queueA);
1:97e0fcc:         TextMessage msg;
1:97e0fcc:         for (int idx = 0; idx < 5; ++idx) {
1:97e0fcc:             msg = (TextMessage) consumer.receive(1000);
1:97e0fcc:             assertNotNull("Got a message", msg);
1:97e0fcc:             LOG.info("received: " + idx + ", msg: " + msg.getJMSMessageID());
1:97e0fcc:             msg.acknowledge();
1:97e0fcc:         }
1:97e0fcc:         Thread.sleep(1000);
1:97e0fcc:         keepGoing.set(false);
1:97e0fcc:         
1:97e0fcc:         assertFalse("producer has resumed", done.get());
1:97e0fcc:     }
1:9a432f2: 
1:9a432f2:     public void test2ndPubisherWithSyncSendConnectionThatIsBlocked() throws Exception {
1:9a432f2:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:9a432f2:         factory.setAlwaysSyncSend(true);
1:9a432f2:         connection = (ActiveMQConnection)factory.createConnection();
1:9a432f2:         connections.add(connection);
1:9a432f2:         connection.start();
1:9a432f2: 
1:9a432f2:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:9a432f2:         MessageConsumer consumer = session.createConsumer(queueB);
1:9a432f2: 
1:9a432f2:         // Test sending to Queue A
1:9a432f2:         // 1st send should not block. But the rest will.
1:9a432f2:         fillQueue(queueA);
1:9a432f2: 
1:9a432f2:         // Test sending to Queue B it should not block.
1:9a432f2:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
1:9a432f2:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1:9a432f2: 
1:9a432f2:         TextMessage msg = (TextMessage)consumer.receive();
1:9a432f2:         assertEquals("Message 1", msg.getText());
1:9a432f2:         msg.acknowledge();
1:9a432f2: 
1:9a432f2:         pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
1:9a432f2:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1:9a432f2: 
1:9a432f2:         msg = (TextMessage)consumer.receive();
1:9a432f2:         assertEquals("Message 2", msg.getText());
1:9a432f2:         msg.acknowledge();
1:9a432f2:     }
1:9a432f2: 
1:9a432f2:     public void testSimpleSendReceive() throws Exception {
1:9a432f2:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:9a432f2:         factory.setAlwaysSyncSend(true);
1:9a432f2:         connection = (ActiveMQConnection)factory.createConnection();
1:9a432f2:         connections.add(connection);
1:9a432f2:         connection.start();
1:9a432f2: 
1:9a432f2:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:9a432f2:         MessageConsumer consumer = session.createConsumer(queueA);
1:9a432f2: 
1:9a432f2:         // Test sending to Queue B it should not block.
1:9a432f2:         CountDownLatch pubishDoneToQeueuA = asyncSendTo(queueA, "Message 1");
1:9a432f2:         assertTrue(pubishDoneToQeueuA.await(2, TimeUnit.SECONDS));
1:9a432f2: 
1:9a432f2:         TextMessage msg = (TextMessage)consumer.receive();
1:9a432f2:         assertEquals("Message 1", msg.getText());
1:9a432f2:         msg.acknowledge();
1:9a432f2: 
1:9a432f2:         pubishDoneToQeueuA = asyncSendTo(queueA, "Message 2");
1:9a432f2:         assertTrue(pubishDoneToQeueuA.await(2, TimeUnit.SECONDS));
1:9a432f2: 
1:9a432f2:         msg = (TextMessage)consumer.receive();
1:9a432f2:         assertEquals("Message 2", msg.getText());
1:9a432f2:         msg.acknowledge();
1:9a432f2:     }
1:9a432f2: 
1:9a432f2:     public void test2ndPubisherWithStandardConnectionThatIsBlocked() throws Exception {
1:9a432f2:         ConnectionFactory factory = createConnectionFactory();
1:9a432f2:         connection = (ActiveMQConnection)factory.createConnection();
1:9a432f2:         connections.add(connection);
1:9a432f2:         connection.start();
1:9a432f2: 
1:9a432f2:         // Test sending to Queue A
1:9a432f2:         // 1st send should not block.
1:9a432f2:         fillQueue(queueA);
1:9a432f2: 
1:9a432f2:         // Test sending to Queue B it should block.
1:9a432f2:         // Since even though the it's queue limits have not been reached, the
1:9a432f2:         // connection
1:9a432f2:         // is blocked.
1:9a432f2:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
1:9a432f2:         assertFalse(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1:9a432f2:     }
1:9a432f2: 
1:01b1f7f:     public void testDisableWarning() throws Exception {
1:01b1f7f:         final AtomicInteger warnings = new AtomicInteger();
1:0608175:         final AtomicInteger debugs = new AtomicInteger();
1:0608175: 
1:01b1f7f:         Appender appender = new DefaultTestAppender() {
1:01b1f7f:             @Override
1:01b1f7f:             public void doAppend(LoggingEvent event) {
1:0608175:                 if (event.getLevel().equals(Level.WARN) && event.getMessage().toString().contains("Usage Manager Memory Limit")) {
1:0608175:                     LOG.info("received warn log message: " + event.getMessage());
1:01b1f7f:                     warnings.incrementAndGet();
1:01b1f7f:                 }
1:0608175:                 if (event.getLevel().equals(Level.DEBUG) && event.getMessage().toString().contains("Usage Manager Memory Limit")) {
1:0608175:                     LOG.info("received debug log message: " + event.getMessage());
1:0608175:                     debugs.incrementAndGet();
1:0608175:                 }
1:0608175: 
1:01b1f7f:             }
1:01b1f7f:         };
1:01b1f7f:         org.apache.log4j.Logger log4jLogger =
1:01b1f7f:                 org.apache.log4j.Logger.getLogger(Queue.class);
1:01b1f7f:         log4jLogger.addAppender(appender);
1:0608175:         log4jLogger.setLevel(Level.DEBUG);
1:01b1f7f:         try {
1:01b1f7f:             ConnectionFactory factory = createConnectionFactory();
1:01b1f7f:             connection = (ActiveMQConnection)factory.createConnection();
1:01b1f7f:             connections.add(connection);
1:01b1f7f:             connection.start();
1:01b1f7f: 
1:01b1f7f:             fillQueue(queueB);
1:01b1f7f:             assertEquals(1, warnings.get());
1:01b1f7f: 
1:01b1f7f:             broker.getDestinationPolicy().getDefaultEntry().setBlockedProducerWarningInterval(0);
1:01b1f7f:             warnings.set(0);
1:01b1f7f: 
1:01b1f7f:             // new connection b/c other is blocked
1:01b1f7f:             connection = (ActiveMQConnection)factory.createConnection();
1:01b1f7f:             connections.add(connection);
1:01b1f7f:             connection.start();
1:01b1f7f:             fillQueue(new ActiveMQQueue("SomeOtherQueueToPickUpNewPolicy"));
1:01b1f7f:             assertEquals(0, warnings.get());
1:0608175:             assertTrue(debugs.get() > 1);
1:01b1f7f: 
1:01b1f7f:         } finally {
1:01b1f7f:             log4jLogger.removeAppender(appender);
1:01b1f7f:         }
1:01b1f7f:     }
1:01b1f7f: 
1:9a432f2:     private void fillQueue(final ActiveMQQueue queue) throws JMSException, InterruptedException {
1:9a432f2:         final AtomicBoolean done = new AtomicBoolean(true);
1:9a432f2:         final AtomicBoolean keepGoing = new AtomicBoolean(true);
1:9a432f2: 
1:9a432f2:         // Starts an async thread that every time it publishes it sets the done
1:9a432f2:         // flag to false.
1:9a432f2:         // Once the send starts to block it will not reset the done flag
1:9a432f2:         // anymore.
1:9a432f2:         new Thread("Fill thread.") {
1:9a432f2:             public void run() {
1:9a432f2:                 Session session = null;
1:9a432f2:                 try {
1:9a432f2:                     session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:9a432f2:                     MessageProducer producer = session.createProducer(queue);
1:9a432f2:                     producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:9a432f2:                     while (keepGoing.get()) {
1:9a432f2:                         done.set(false);
1:9a432f2:                         producer.send(session.createTextMessage("Hello World"));
1:9a432f2:                     }
1:9a432f2:                 } catch (JMSException e) {
1:9a432f2:                 } finally {
1:9a432f2:                     safeClose(session);
1:9a432f2:                 }
1:9a432f2:             }
1:9a432f2:         }.start();
1:f1d59cd: 
1:f1d59cd:         waitForBlockedOrResourceLimit(done);
1:f1d59cd:         keepGoing.set(false);
1:f1d59cd:     }
1:9a432f2: 
1:f1d59cd:     protected void waitForBlockedOrResourceLimit(final AtomicBoolean done)
1:f1d59cd:             throws InterruptedException {
2:9a432f2:         while (true) {
1:9a432f2:             Thread.sleep(1000);
1:f1d59cd:             // the producer is blocked once the done flag stays true or there is a resource exception
1:f1d59cd:             if (done.get() || gotResourceException.get()) {
2:9a432f2:                 break;
1:9a432f2:             }
2:9a432f2:             done.set(true);
1:9a432f2:         }
1:9a432f2:     }
1:9a432f2: 
1:9a432f2:     private CountDownLatch asyncSendTo(final ActiveMQQueue queue, final String message) throws JMSException {
1:9a432f2:         final CountDownLatch done = new CountDownLatch(1);
1:9a432f2:         new Thread("Send thread.") {
1:9a432f2:             public void run() {
1:9a432f2:                 Session session = null;
1:9a432f2:                 try {
1:9a432f2:                     session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:9a432f2:                     MessageProducer producer = session.createProducer(queue);
1:9a432f2:                     producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:9a432f2:                     producer.send(session.createTextMessage(message));
1:9a432f2:                     done.countDown();
1:9a432f2:                 } catch (JMSException e) {
1:9a432f2:                 } finally {
1:9a432f2:                     safeClose(session);
1:9a432f2:                 }
1:9a432f2:             }
1:9a432f2:         }.start();
1:9a432f2:         return done;
1:9a432f2:     }
1:9a432f2: 
1:9a432f2:     protected BrokerService createBroker() throws Exception {
1:9a432f2:         BrokerService service = new BrokerService();
1:9a432f2:         service.setPersistent(false);
1:9a432f2:         service.setUseJmx(false);
1:9a432f2: 
1:9a432f2:         // Setup a destination policy where it takes only 1 message at a time.
1:9a432f2:         PolicyMap policyMap = new PolicyMap();
1:9a432f2:         PolicyEntry policy = new PolicyEntry();
1:9a432f2:         policy.setMemoryLimit(1);
1:9a432f2:         policy.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
1:9a432f2:         policy.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
1:aead3e0:         policy.setProducerFlowControl(true);
1:9a432f2:         policyMap.setDefaultEntry(policy);
1:9a432f2:         service.setDestinationPolicy(policyMap);
1:9a432f2: 
1:9a432f2:         connector = service.addConnector("tcp://localhost:0");
1:9a432f2:         return service;
1:9a432f2:     }
1:9a432f2: 
1:6d9163a:     public void setUp() throws Exception {
1:6d9163a:         setAutoFail(true);
1:6d9163a:         super.setUp();
1:6d9163a:     }
1:6d9163a:     
1:9a432f2:     protected void tearDown() throws Exception {
1:01b1f7f:         for (Connection c : connections) {
1:01b1f7f:             // force error on blocked connections
1:01b1f7f:             ActiveMQConnection connection = (ActiveMQConnection) c;
1:f1d59cd:             TcpTransport t = (TcpTransport)connection.getTransport().narrow(TcpTransport.class);
1:f1d59cd:             t.getTransportListener().onException(new IOException("Disposed."));
1:f1d59cd:             connection.getTransport().stop();
1:9a432f2:         }
1:fb6c2da:         super.tearDown();
1:f1d59cd:     }
1:9a432f2: 
1:9a432f2:     protected ConnectionFactory createConnectionFactory() throws Exception {
1:9a432f2:         return new ActiveMQConnectionFactory(connector.getConnectUri());
1:9a432f2:     }
1:9a432f2: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:0608175
/////////////////////////////////////////////////////////////////////////
1:         final AtomicInteger debugs = new AtomicInteger();
1: 
1:                 if (event.getLevel().equals(Level.WARN) && event.getMessage().toString().contains("Usage Manager Memory Limit")) {
1:                     LOG.info("received warn log message: " + event.getMessage());
1:                 if (event.getLevel().equals(Level.DEBUG) && event.getMessage().toString().contains("Usage Manager Memory Limit")) {
1:                     LOG.info("received debug log message: " + event.getMessage());
1:                     debugs.incrementAndGet();
1:                 }
1: 
1:         log4jLogger.setLevel(Level.DEBUG);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue(debugs.get() > 1);
commit:01b1f7f
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
1: import javax.jms.Connection;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.broker.region.Topic;
1: import org.apache.activemq.util.DefaultTestAppender;
1: import org.apache.log4j.Appender;
1: import org.apache.log4j.Level;
1: import org.apache.log4j.spi.LoggingEvent;
/////////////////////////////////////////////////////////////////////////
1:     public void testDisableWarning() throws Exception {
1:         final AtomicInteger warnings = new AtomicInteger();
1:         Appender appender = new DefaultTestAppender() {
1:             @Override
1:             public void doAppend(LoggingEvent event) {
0:                 if (event.getLevel().equals(Level.INFO) && event.getMessage().toString().contains("Usage Manager Memory Limit")) {
0:                     LOG.info("received  log message: " + event.getMessage());
1:                     warnings.incrementAndGet();
1:                 }
1:             }
1:         };
1:         org.apache.log4j.Logger log4jLogger =
1:                 org.apache.log4j.Logger.getLogger(Queue.class);
1:         log4jLogger.addAppender(appender);
1:         try {
1:             ConnectionFactory factory = createConnectionFactory();
1:             connection = (ActiveMQConnection)factory.createConnection();
1:             connections.add(connection);
1:             connection.start();
1: 
1:             fillQueue(queueB);
1:             assertEquals(1, warnings.get());
1: 
1:             broker.getDestinationPolicy().getDefaultEntry().setBlockedProducerWarningInterval(0);
1:             warnings.set(0);
1: 
1:             // new connection b/c other is blocked
1:             connection = (ActiveMQConnection)factory.createConnection();
1:             connections.add(connection);
1:             connection.start();
1:             fillQueue(new ActiveMQQueue("SomeOtherQueueToPickUpNewPolicy"));
1:             assertEquals(0, warnings.get());
1: 
1:         } finally {
1:             log4jLogger.removeAppender(appender);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (Connection c : connections) {
1:             // force error on blocked connections
1:             ActiveMQConnection connection = (ActiveMQConnection) c;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     static final Logger LOG = LoggerFactory.getLogger(ProducerFlowControlTest.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:fb6c2da
/////////////////////////////////////////////////////////////////////////
1:         super.tearDown();
commit:97e0fcc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     static final Log LOG = LogFactory.getLog(ProducerFlowControlTest.class);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		    int i;
1: 						producer.send(session.createTextMessage("Test message " + ++i));
1: 						LOG.info("sent: " + i);
/////////////////////////////////////////////////////////////////////////
1:         	LOG.info("received: " + idx + ", msg: " + msg.getJMSMessageID());
1: 		assertFalse("producer has resumed", done.get());
1: 
1:     public void testAsyncPubisherRecoverAfterBlock() throws Exception {
1:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:         factory.setProducerWindowSize(1024 * 5);
1:         factory.setUseAsyncSend(true);
1:         connection = (ActiveMQConnection)factory.createConnection();
1:         connections.add(connection);
1:         connection.start();
1: 
1:         final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         final MessageProducer producer = session.createProducer(queueA);
1:         
1:         final AtomicBoolean done = new AtomicBoolean(true);
1:         final AtomicBoolean keepGoing = new AtomicBoolean(true);
1:         
1:    
1:         Thread thread = new Thread("Filler") {
1:             int i;
1:             @Override
1:             public void run() {
1:                 while (keepGoing.get()) {
1:                     done.set(false);
1:                     try {
1:                         producer.send(session.createTextMessage("Test message " + ++i));
1:                         LOG.info("sent: " + i);
1:                     } catch (JMSException e) {
1:                     }
1:                 }
1:             }
1:         };
1:         thread.start();
1:         waitForBlockedOrResourceLimit(done);
1: 
1:         // after receiveing messges, producer should continue sending messages 
1:         // (done == false)
1:         MessageConsumer consumer = session.createConsumer(queueA);
1:         TextMessage msg;
1:         for (int idx = 0; idx < 5; ++idx) {
1:             msg = (TextMessage) consumer.receive(1000);
1:             assertNotNull("Got a message", msg);
1:             LOG.info("received: " + idx + ", msg: " + msg.getJMSMessageID());
1:             msg.acknowledge();
1:         }
1:         Thread.sleep(1000);
1:         keepGoing.set(false);
1:         
1:         assertFalse("producer has resumed", done.get());
1:     }
1: 
commit:6d9163a
/////////////////////////////////////////////////////////////////////////
1:     public void setUp() throws Exception {
1:         setAutoFail(true);
1:         super.setUp();
1:     }
1:     
commit:f1d59cd
/////////////////////////////////////////////////////////////////////////
1:     protected TransportConnector connector;
1:     protected ActiveMQConnection connection;
1:     // used to test sendFailIfNoSpace on SystemUsage 
1:     protected final AtomicBoolean gotResourceException = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:         
1:    
/////////////////////////////////////////////////////////////////////////
1:         waitForBlockedOrResourceLimit(done);
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:         waitForBlockedOrResourceLimit(done);
1:         keepGoing.set(false);
1:     }
1: 
1:     protected void waitForBlockedOrResourceLimit(final AtomicBoolean done)
1:             throws InterruptedException {
1:             // the producer is blocked once the done flag stays true or there is a resource exception
1:             if (done.get() || gotResourceException.get()) {
/////////////////////////////////////////////////////////////////////////
0:         if (connection != null) {
1:             TcpTransport t = (TcpTransport)connection.getTransport().narrow(TcpTransport.class);
1:             t.getTransportListener().onException(new IOException("Disposed."));
1:             connection.getTransport().stop();
0:             super.tearDown();
1:         }
commit:9a432f2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import java.io.IOException;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.JMSException;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
1: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.transport.tcp.TcpTransport;
1: 
1: public class ProducerFlowControlTest extends JmsTestSupport {
1: 
1:     ActiveMQQueue queueA = new ActiveMQQueue("QUEUE.A");
1:     ActiveMQQueue queueB = new ActiveMQQueue("QUEUE.B");
0:     private TransportConnector connector;
0:     private ActiveMQConnection connection;
1: 
1:     public void test2ndPubisherWithProducerWindowSendConnectionThatIsBlocked() throws Exception {
1:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:         factory.setProducerWindowSize(1024 * 64);
1:         connection = (ActiveMQConnection)factory.createConnection();
1:         connections.add(connection);
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createConsumer(queueB);
1: 
1:         // Test sending to Queue A
1:         // 1 few sends should not block until the producer window is used up.
1:         fillQueue(queueA);
1: 
1:         // Test sending to Queue B it should not block since the connection
1:         // should not be blocked.
1:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
1:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1: 
1:         TextMessage msg = (TextMessage)consumer.receive();
1:         assertEquals("Message 1", msg.getText());
1:         msg.acknowledge();
1: 
1:         pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
1:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1: 
1:         msg = (TextMessage)consumer.receive();
1:         assertEquals("Message 2", msg.getText());
1:         msg.acknowledge();
1:     }
1: 
1:     public void testPubisherRecoverAfterBlock() throws Exception {
1:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:         factory.setProducerWindowSize(1024 * 64);
0:         factory.setUseAsyncSend(true);
1:         connection = (ActiveMQConnection)factory.createConnection();
1:         connections.add(connection);
1:         connection.start();
1: 
1:         final Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         final MessageProducer producer = session.createProducer(queueA);
1:         
1:         final AtomicBoolean done = new AtomicBoolean(true);
1:         final AtomicBoolean keepGoing = new AtomicBoolean(true);
1: 		Thread thread = new Thread("Filler") {
1: 			@Override
1: 			public void run() {
1:                 while (keepGoing.get()) {
1:                     done.set(false);
1:                     try {
0: 						producer.send(session.createTextMessage("Test message"));
1: 					} catch (JMSException e) {
1: 					}
1:                 }
1: 			}
1: 		};
1: 		thread.start();
1:         while (true) {
1:             Thread.sleep(1000);
0:             // the producer is blocked once the done flag stays true.
0:             if (done.get()) {
1:                 break;
1:             }
1:             done.set(true);
1:         }
1: 
1:         // after receiveing messges, producer should continue sending messages 
1:         // (done == false)
1:         MessageConsumer consumer = session.createConsumer(queueA);
1:         TextMessage msg;
1:         for (int idx = 0; idx < 5; ++idx) {
1:         	msg = (TextMessage) consumer.receive(1000);
1:         	msg.acknowledge();
1:         }
1:         Thread.sleep(1000);
1:         keepGoing.set(false);
1:     	
0: 		assertFalse(done.get());
1:     }
1:     public void test2ndPubisherWithSyncSendConnectionThatIsBlocked() throws Exception {
1:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:         factory.setAlwaysSyncSend(true);
1:         connection = (ActiveMQConnection)factory.createConnection();
1:         connections.add(connection);
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createConsumer(queueB);
1: 
1:         // Test sending to Queue A
1:         // 1st send should not block. But the rest will.
1:         fillQueue(queueA);
1: 
1:         // Test sending to Queue B it should not block.
1:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
1:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1: 
1:         TextMessage msg = (TextMessage)consumer.receive();
1:         assertEquals("Message 1", msg.getText());
1:         msg.acknowledge();
1: 
1:         pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
1:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1: 
1:         msg = (TextMessage)consumer.receive();
1:         assertEquals("Message 2", msg.getText());
1:         msg.acknowledge();
1:     }
1: 
1:     public void testSimpleSendReceive() throws Exception {
1:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
1:         factory.setAlwaysSyncSend(true);
1:         connection = (ActiveMQConnection)factory.createConnection();
1:         connections.add(connection);
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createConsumer(queueA);
1: 
1:         // Test sending to Queue B it should not block.
1:         CountDownLatch pubishDoneToQeueuA = asyncSendTo(queueA, "Message 1");
1:         assertTrue(pubishDoneToQeueuA.await(2, TimeUnit.SECONDS));
1: 
1:         TextMessage msg = (TextMessage)consumer.receive();
1:         assertEquals("Message 1", msg.getText());
1:         msg.acknowledge();
1: 
1:         pubishDoneToQeueuA = asyncSendTo(queueA, "Message 2");
1:         assertTrue(pubishDoneToQeueuA.await(2, TimeUnit.SECONDS));
1: 
1:         msg = (TextMessage)consumer.receive();
1:         assertEquals("Message 2", msg.getText());
1:         msg.acknowledge();
1:     }
1: 
1:     public void test2ndPubisherWithStandardConnectionThatIsBlocked() throws Exception {
1:         ConnectionFactory factory = createConnectionFactory();
1:         connection = (ActiveMQConnection)factory.createConnection();
1:         connections.add(connection);
1:         connection.start();
1: 
1:         // Test sending to Queue A
1:         // 1st send should not block.
1:         fillQueue(queueA);
1: 
1:         // Test sending to Queue B it should block.
1:         // Since even though the it's queue limits have not been reached, the
1:         // connection
1:         // is blocked.
1:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
1:         assertFalse(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
1:     }
1: 
1:     private void fillQueue(final ActiveMQQueue queue) throws JMSException, InterruptedException {
1:         final AtomicBoolean done = new AtomicBoolean(true);
1:         final AtomicBoolean keepGoing = new AtomicBoolean(true);
1: 
1:         // Starts an async thread that every time it publishes it sets the done
1:         // flag to false.
1:         // Once the send starts to block it will not reset the done flag
1:         // anymore.
1:         new Thread("Fill thread.") {
1:             public void run() {
1:                 Session session = null;
1:                 try {
1:                     session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                     MessageProducer producer = session.createProducer(queue);
1:                     producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:                     while (keepGoing.get()) {
1:                         done.set(false);
1:                         producer.send(session.createTextMessage("Hello World"));
1:                     }
1:                 } catch (JMSException e) {
1:                 } finally {
1:                     safeClose(session);
1:                 }
1:             }
1:         }.start();
1: 
1:         while (true) {
1:             Thread.sleep(1000);
0:             // the producer is blocked once the done flag stays true.
0:             if (done.get()) {
1:                 break;
1:             }
1:             done.set(true);
1:         }
1:         keepGoing.set(false);
1:     }
1: 
1:     private CountDownLatch asyncSendTo(final ActiveMQQueue queue, final String message) throws JMSException {
1:         final CountDownLatch done = new CountDownLatch(1);
1:         new Thread("Send thread.") {
1:             public void run() {
1:                 Session session = null;
1:                 try {
1:                     session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                     MessageProducer producer = session.createProducer(queue);
1:                     producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:                     producer.send(session.createTextMessage(message));
1:                     done.countDown();
1:                 } catch (JMSException e) {
1:                 } finally {
1:                     safeClose(session);
1:                 }
1:             }
1:         }.start();
1:         return done;
1:     }
1: 
1:     protected BrokerService createBroker() throws Exception {
1:         BrokerService service = new BrokerService();
1:         service.setPersistent(false);
1:         service.setUseJmx(false);
1: 
1:         // Setup a destination policy where it takes only 1 message at a time.
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry policy = new PolicyEntry();
1:         policy.setMemoryLimit(1);
1:         policy.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
1:         policy.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
1:         policyMap.setDefaultEntry(policy);
1:         service.setDestinationPolicy(policyMap);
1: 
1:         connector = service.addConnector("tcp://localhost:0");
1:         return service;
1:     }
1: 
1:     protected void tearDown() throws Exception {
0:         TcpTransport t = (TcpTransport)connection.getTransport().narrow(TcpTransport.class);
0:         t.getTransportListener().onException(new IOException("Disposed."));
0:         connection.getTransport().stop();
0:         super.tearDown();
1:     }
1: 
1:     protected ConnectionFactory createConnectionFactory() throws Exception {
1:         return new ActiveMQConnectionFactory(connector.getConnectUri());
1:     }
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:aead3e0
/////////////////////////////////////////////////////////////////////////
1:         policy.setProducerFlowControl(true);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0:             if (done.get()) {
0:             }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
0: 
0:     ActiveMQQueue queueA = new ActiveMQQueue("QUEUE.A");
0:     ActiveMQQueue queueB = new ActiveMQQueue("QUEUE.B");
0:     private TransportConnector connector;
0:     private ActiveMQConnection connection;
0:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
0:         factory.setProducerWindowSize(1024 * 64);
0:         connection = (ActiveMQConnection)factory.createConnection();
0:         connection.start();
0:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createConsumer(queueB);
0:         // Test sending to Queue A
0:         // 1 few sends should not block until the producer window is used up.
0:         fillQueue(queueA);
0:         // Test sending to Queue B it should not block since the connection
0:         // should not be blocked.
0:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
0:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
0: 
0:         TextMessage msg = (TextMessage)consumer.receive();
0:         assertEquals("Message 1", msg.getText());
0:         msg.acknowledge();
0: 
0:         pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
0:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
0: 
0:         msg = (TextMessage)consumer.receive();
0:         assertEquals("Message 2", msg.getText());
0:         msg.acknowledge();
0:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
0:         connection = (ActiveMQConnection)factory.createConnection();
0:         connection.start();
0:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createConsumer(queueB);
0:         // Test sending to Queue A
0:         // 1st send should not block. But the rest will.
0:         fillQueue(queueA);
0:         // Test sending to Queue B it should not block.
0:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
0:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
0: 
0:         TextMessage msg = (TextMessage)consumer.receive();
0:         assertEquals("Message 1", msg.getText());
0:         msg.acknowledge();
0: 
0:         pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
0:         assertTrue(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
0: 
0:         msg = (TextMessage)consumer.receive();
0:         assertEquals("Message 2", msg.getText());
0:         msg.acknowledge();
0:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory)createConnectionFactory();
0:         connection = (ActiveMQConnection)factory.createConnection();
0:         connection.start();
0:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createConsumer(queueA);
0:         // Test sending to Queue B it should not block.
0:         CountDownLatch pubishDoneToQeueuA = asyncSendTo(queueA, "Message 1");
0:         assertTrue(pubishDoneToQeueuA.await(2, TimeUnit.SECONDS));
0: 
0:         TextMessage msg = (TextMessage)consumer.receive();
0:         assertEquals("Message 1", msg.getText());
0:         msg.acknowledge();
0: 
0:         pubishDoneToQeueuA = asyncSendTo(queueA, "Message 2");
0:         assertTrue(pubishDoneToQeueuA.await(2, TimeUnit.SECONDS));
0: 
0:         msg = (TextMessage)consumer.receive();
0:         assertEquals("Message 2", msg.getText());
0:         msg.acknowledge();
0:         connection = (ActiveMQConnection)factory.createConnection();
0:         connection.start();
0:         // Test sending to Queue A
0:         // 1st send should not block.
0:         fillQueue(queueA);
0:         // Test sending to Queue B it should block.
0:         // Since even though the it's queue limits have not been reached, the
0:         // connection
0:         // is blocked.
0:         CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
0:         assertFalse(pubishDoneToQeueuB.await(2, TimeUnit.SECONDS));
0:     private void fillQueue(final ActiveMQQueue queue) throws JMSException, InterruptedException {
0:         final AtomicBoolean done = new AtomicBoolean(true);
0:         final AtomicBoolean keepGoing = new AtomicBoolean(true);
0:         // Starts an async thread that every time it publishes it sets the done
0:         // flag to false.
0:         // Once the send starts to block it will not reset the done flag
0:         // anymore.
0:         new Thread("Fill thread.") {
0:             public void run() {
0:                 Session session = null;
0:                 try {
0:                     session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:                     MessageProducer producer = session.createProducer(queue);
0:                     producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:                     while (keepGoing.get()) {
0:                         done.set(false);
0:                         producer.send(session.createTextMessage("Hello World"));
0:                     }
0:                 } catch (JMSException e) {
0:                 } finally {
0:                     safeClose(session);
0:                 }
0:             }
0:         }.start();
0:         while (true) {
0:             Thread.sleep(1000);
0:             // the producer is blocked once the done flag stays true.
0:             if (done.get())
0:                 break;
0:             done.set(true);
0:         }
0:         keepGoing.set(false);
0:     }
0: 
0:     private CountDownLatch asyncSendTo(final ActiveMQQueue queue, final String message) throws JMSException {
0:         final CountDownLatch done = new CountDownLatch(1);
0:         new Thread("Send thread.") {
0:             public void run() {
0:                 Session session = null;
0:                 try {
0:                     session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:                     MessageProducer producer = session.createProducer(queue);
0:                     producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:                     producer.send(session.createTextMessage(message));
0:                     done.countDown();
0:                 } catch (JMSException e) {
0:                 } finally {
0:                     safeClose(session);
0:                 }
0:             }
0:         }.start();
0:         return done;
0:     }
0: 
0:         PolicyMap policyMap = new PolicyMap();
0:         policyMap.setDefaultEntry(policy);
0: 
0:         connector = service.addConnector("tcp://localhost:0");
0: 
0:         TcpTransport t = (TcpTransport)connection.getTransport().narrow(TcpTransport.class);
0:         t.getTransportListener().onException(new IOException("Disposed."));
0:         connection.getTransport().stop();
0:         super.tearDown();
0: 
commit:f7a30b8
/////////////////////////////////////////////////////////////////////////
0:     public void test2ndPubisherWithProducerWindowSendConnectionThatIsBlocked() throws Exception {
0:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory) createConnectionFactory();
0:         factory.setProducerWindowSize(1024*64);
0:         connection = (ActiveMQConnection) factory.createConnection();
0:         connections.add(connection);
0:     	connection.start();
0: 
0:     	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:     	MessageConsumer consumer = session.createConsumer(queueB);
0: 
0:     	// Test sending to Queue A
0:     	// 1 few sends should not block until the producer window is used up. 
0:     	fillQueue(queueA);
0: 
0:     	// Test sending to Queue B it should not block since the connection should not be blocked.
0:     	CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
0:     	assertTrue( pubishDoneToQeueuB.await(2, TimeUnit.SECONDS) );
0:     	
0:     	TextMessage msg = (TextMessage) consumer.receive();
0:     	assertEquals("Message 1", msg.getText());
0:     	msg.acknowledge();
0:     	
0:     	pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
0:     	assertTrue( pubishDoneToQeueuB.await(2, TimeUnit.SECONDS) );
0:     	
0:     	msg = (TextMessage) consumer.receive();
0:     	assertEquals("Message 2", msg.getText());
0:     	msg.acknowledge();
0:     }
0: 
commit:489f5aa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
0:         factory.setAlwaysSyncSend(true);
0:     	// Test sending to Queue A
0:     	// 1st send should not block.  But the rest will.
0:     	fillQueue(queueA);
0: 
0:     	// Test sending to Queue B it should not block. 
/////////////////////////////////////////////////////////////////////////
0:     public void testSimpleSendReceive() throws Exception {
0:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory) createConnectionFactory();
0:         factory.setAlwaysSyncSend(true);
0:         connection = (ActiveMQConnection) factory.createConnection();
0:         connections.add(connection);
0:     	connection.start();
0: 
0:     	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:     	MessageConsumer consumer = session.createConsumer(queueA);
0: 
0:     	// Test sending to Queue B it should not block. 
0:     	CountDownLatch pubishDoneToQeueuA = asyncSendTo(queueA, "Message 1");
0:     	assertTrue( pubishDoneToQeueuA.await(2, TimeUnit.SECONDS) );
0:     	
0:     	TextMessage msg = (TextMessage) consumer.receive();
0:     	assertEquals("Message 1", msg.getText());
0:     	msg.acknowledge();
0:     	
0:     	pubishDoneToQeueuA = asyncSendTo(queueA, "Message 2");
0:     	assertTrue( pubishDoneToQeueuA.await(2, TimeUnit.SECONDS) );
0:     	
0:     	msg = (TextMessage) consumer.receive();
0:     	assertEquals("Message 2", msg.getText());
0:     	msg.acknowledge();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         policy.setPendingQueuePolicy(new VMPendingQueueMessageStoragePolicy());
commit:7de0e81
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq;
0: 
0: import java.io.IOException;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: 
0: import javax.jms.ConnectionFactory;
0: import javax.jms.DeliveryMode;
0: import javax.jms.JMSException;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import javax.jms.TextMessage;
0: 
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.transport.tcp.TcpTransport;
0: 
0: 
0: public class ProducerFlowControlTest extends JmsTestSupport {
0: 	
0: 	ActiveMQQueue queueA = new ActiveMQQueue("QUEUE.A");
0: 	ActiveMQQueue queueB = new ActiveMQQueue("QUEUE.B");
0: 	private TransportConnector connector;
0: 	private ActiveMQConnection connection;
0: 
0:     public void test2ndPubisherWithSyncSendConnectionThatIsBlocked() throws Exception {
0:         ActiveMQConnectionFactory factory = (ActiveMQConnectionFactory) createConnectionFactory();
0:         factory.setUseSyncSend(true);
0:         connection = (ActiveMQConnection) factory.createConnection();
0:         connections.add(connection);
0:     	connection.start();
0: 
0:     	// Test sending to Queue A
0:     	// 1st send should not block.
0:     	fillQueue(queueA);
0:     	
0:     	Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:     	MessageConsumer consumer = session.createConsumer(queueB);
0: 
0:     	// Test sending to Queue B it should block. 
0:     	// Since even though  the it's queue limits have not been reached, the connection
0:     	// is blocked.
0:     	CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
0:     	assertTrue( pubishDoneToQeueuB.await(2, TimeUnit.SECONDS) );
0:     	
0:     	TextMessage msg = (TextMessage) consumer.receive();
0:     	assertEquals("Message 1", msg.getText());
0:     	msg.acknowledge();
0:     	
0:     	pubishDoneToQeueuB = asyncSendTo(queueB, "Message 2");
0:     	assertTrue( pubishDoneToQeueuB.await(2, TimeUnit.SECONDS) );
0:     	
0:     	msg = (TextMessage) consumer.receive();
0:     	assertEquals("Message 2", msg.getText());
0:     	msg.acknowledge();
0:     }
0: 
0:     public void test2ndPubisherWithStandardConnectionThatIsBlocked() throws Exception {
0:         ConnectionFactory factory = createConnectionFactory();
0:         connection = (ActiveMQConnection) factory.createConnection();
0:         connections.add(connection);
0:     	connection.start();
0: 
0:     	// Test sending to Queue A
0:     	// 1st send should not block.
0:     	fillQueue(queueA);
0: 
0:     	// Test sending to Queue B it should block. 
0:     	// Since even though  the it's queue limits have not been reached, the connection
0:     	// is blocked.
0:     	CountDownLatch pubishDoneToQeueuB = asyncSendTo(queueB, "Message 1");
0:     	assertFalse( pubishDoneToQeueuB.await(2, TimeUnit.SECONDS) );    	
0:     }
0: 
0: 
0: 	private void fillQueue(final ActiveMQQueue queue) throws JMSException, InterruptedException {
0: 		final AtomicBoolean done = new AtomicBoolean(true);
0: 		final AtomicBoolean keepGoing = new AtomicBoolean(true);
0: 		
0: 		// Starts an async thread that every time it publishes it sets the done flag to false.
0: 		// Once the send starts to block it will not reset the done flag anymore.
0: 		new Thread("Fill thread.") {
0: 			public void run() {
0: 				Session session=null;
0: 		    	try {
0: 					session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 					MessageProducer producer = session.createProducer(queue);
0: 					producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 					while( keepGoing.get() ) {
0: 						done.set(false);
0: 						producer.send(session.createTextMessage("Hello World"));						
0: 					}
0: 				} catch (JMSException e) {
0: 				} finally {
0: 					safeClose(session);
0: 				}
0: 			}
0: 		}.start();
0: 		
0: 		while( true ) {
0: 			Thread.sleep(1000);
0: 			// the producer is blocked once the done flag stays true.
0: 			if( done.get() )
0: 				break;
0: 			done.set(true);
0: 		}		
0: 		keepGoing.set(false);
0: 	}
0: 
0: 	private CountDownLatch asyncSendTo(final ActiveMQQueue queue, final String message) throws JMSException {
0: 		final CountDownLatch done = new CountDownLatch(1);
0: 		new Thread("Send thread.") {
0: 			public void run() {
0: 				Session session=null;
0: 		    	try {
0: 					session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 					MessageProducer producer = session.createProducer(queue);
0: 					producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0: 					producer.send(session.createTextMessage(message));
0: 					done.countDown();
0: 				} catch (JMSException e) {
0: 				} finally {
0: 					safeClose(session);
0: 				}
0: 			}
0: 		}.start();    	
0: 		return done;
0: 	}
0: 
0:     protected BrokerService createBroker() throws Exception {
0:         BrokerService service = new BrokerService();
0:         service.setPersistent(false);
0:         service.setUseJmx(false);
0:         
0:         // Setup a destination policy where it takes only 1 message at a time.
0:         PolicyMap policyMap = new PolicyMap();        
0:         PolicyEntry policy = new PolicyEntry();
0:         policy.setMemoryLimit(1);
0:         policy.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
0:         policyMap.setDefaultEntry(policy);        
0:         service.setDestinationPolicy(policyMap);
0:         
0:         connector = service.addConnector("tcp://localhost:0");        
0:         return service;
0:     }
0:     
0:     protected void tearDown() throws Exception {
0:     	TcpTransport t = (TcpTransport) connection.getTransport().narrow(TcpTransport.class);
0:     	t.getTransportListener().onException(new IOException("Disposed."));
0:     	connection.getTransport().stop();
0:     	super.tearDown();
0:     }
0:     
0:     protected ConnectionFactory createConnectionFactory() throws Exception {
0:         return new ActiveMQConnectionFactory(connector.getConnectUri());
0:     }
0: }
============================================================================