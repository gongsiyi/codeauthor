1:0b6bf7e: /**
1:0b6bf7e:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:0b6bf7e:  * contributor license agreements.  See the NOTICE file distributed with
1:0b6bf7e:  * this work for additional information regarding copyright ownership.
1:0b6bf7e:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:0b6bf7e:  * (the "License"); you may not use this file except in compliance with
1:0b6bf7e:  * the License.  You may obtain a copy of the License at
1:0b6bf7e:  *
1:0b6bf7e:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0b6bf7e:  *
1:0b6bf7e:  * Unless required by applicable law or agreed to in writing, software
1:0b6bf7e:  * distributed under the License is distributed on an "AS IS" BASIS,
1:0b6bf7e:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0b6bf7e:  * See the License for the specific language governing permissions and
1:0b6bf7e:  * limitations under the License.
1:0b6bf7e:  */
1:0b6bf7e: package org.apache.activemq.usecases;
1:0b6bf7e: 
1:2aff82c: import static org.junit.Assert.assertEquals;
1:2aff82c: import static org.junit.Assert.assertFalse;
1:2aff82c: import static org.junit.Assert.assertTrue;
1:0b6bf7e: 
1:2aff82c: import java.util.Iterator;
1:0b6bf7e: import java.util.LinkedHashSet;
1:0b6bf7e: import java.util.concurrent.TimeUnit;
1:0b6bf7e: 
1:0b6bf7e: import javax.jms.Connection;
1:0b6bf7e: import javax.jms.Destination;
1:0b6bf7e: import javax.jms.JMSException;
1:0b6bf7e: import javax.jms.Message;
1:0b6bf7e: import javax.jms.MessageConsumer;
1:0b6bf7e: import javax.jms.MessageListener;
1:0b6bf7e: import javax.jms.MessageProducer;
1:0b6bf7e: import javax.jms.Session;
1:2aff82c: import javax.jms.TextMessage;
1:0b6bf7e: 
1:0b6bf7e: import org.apache.activemq.ActiveMQConnection;
1:0b6bf7e: import org.apache.activemq.ActiveMQConnectionFactory;
1:0b6bf7e: import org.apache.activemq.RedeliveryPolicy;
1:0b6bf7e: import org.apache.activemq.broker.BrokerService;
1:0b6bf7e: import org.apache.activemq.util.Wait;
1:0b6bf7e: import org.junit.After;
1:0b6bf7e: import org.junit.Before;
1:0b6bf7e: import org.junit.Test;
1:0b6bf7e: import org.slf4j.Logger;
1:0b6bf7e: import org.slf4j.LoggerFactory;
1:0b6bf7e: 
1:0b6bf7e: public class NonBlockingConsumerRedeliveryTest {
1:0b6bf7e:     private static final Logger LOG = LoggerFactory.getLogger(NonBlockingConsumerRedeliveryTest.class);
1:0b6bf7e: 
1:0b6bf7e:     private final String destinationName = "Destination";
1:0b6bf7e:     private final int MSG_COUNT = 100;
1:0b6bf7e: 
1:0b6bf7e:     private BrokerService broker;
1:0b6bf7e:     private String connectionUri;
1:0b6bf7e: 
1:0b6bf7e:     private ActiveMQConnectionFactory connectionFactory;
1:0b6bf7e: 
1:0b6bf7e:     @Test
1:0b6bf7e:     public void testMessageDeleiveredWhenNonBlockingEnabled() throws Exception {
1:0b6bf7e: 
1:0b6bf7e:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:0b6bf7e:         final LinkedHashSet<Message> beforeRollback = new LinkedHashSet<Message>();
1:0b6bf7e:         final LinkedHashSet<Message> afterRollback = new LinkedHashSet<Message>();
1:0b6bf7e: 
1:0b6bf7e:         Connection connection = connectionFactory.createConnection();
1:0b6bf7e:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:0b6bf7e:         Destination destination = session.createQueue(destinationName);
1:0b6bf7e:         MessageConsumer consumer = session.createConsumer(destination);
1:0b6bf7e: 
1:0b6bf7e:         consumer.setMessageListener(new MessageListener() {
1:0b6bf7e:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e:                 received.add(message);
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         sendMessages();
1:0b6bf7e: 
1:0b6bf7e:         session.commit();
1:0b6bf7e:         connection.start();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:0b6bf7e:                     return received.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         beforeRollback.addAll(received);
1:0b6bf7e:         received.clear();
1:0b6bf7e:         session.rollback();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:0b6bf7e:                     return received.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:2aff82c: 
1:0b6bf7e:         afterRollback.addAll(received);
1:0b6bf7e:         received.clear();
1:0b6bf7e: 
1:0b6bf7e:         assertEquals(beforeRollback.size(), afterRollback.size());
1:0b6bf7e:         assertEquals(beforeRollback, afterRollback);
1:0b6bf7e:         session.commit();
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     @Test
1:2aff82c:     public void testMessageDeleiveredInCorrectOrder() throws Exception {
1:2aff82c: 
1:2aff82c:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:2aff82c:         final LinkedHashSet<Message> beforeRollback = new LinkedHashSet<Message>();
1:2aff82c:         final LinkedHashSet<Message> afterRollback = new LinkedHashSet<Message>();
1:2aff82c: 
1:2aff82c:         Connection connection = connectionFactory.createConnection();
1:2aff82c:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:2aff82c:         Destination destination = session.createQueue(destinationName);
1:2aff82c:         MessageConsumer consumer = session.createConsumer(destination);
1:2aff82c: 
1:2aff82c:         consumer.setMessageListener(new MessageListener() {
1:2aff82c:             @Override
1:2aff82c:             public void onMessage(Message message) {
1:2aff82c:                 received.add(message);
1:2aff82c:             }
1:2aff82c:         });
1:2aff82c: 
1:2aff82c:         sendMessages();
1:2aff82c: 
1:2aff82c:         session.commit();
1:2aff82c:         connection.start();
1:2aff82c: 
1:2aff82c:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:2aff82c:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:2aff82c:                 public boolean isSatisified() throws Exception {
1:2aff82c:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:2aff82c:                     return received.size() == MSG_COUNT;
1:2aff82c:                 }
1:2aff82c:             }
1:2aff82c:         ));
1:2aff82c: 
1:2aff82c:         beforeRollback.addAll(received);
1:2aff82c:         received.clear();
1:2aff82c:         session.rollback();
1:2aff82c: 
1:2aff82c:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:2aff82c:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:2aff82c:                 public boolean isSatisified() throws Exception {
1:2aff82c:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:2aff82c:                     return received.size() == MSG_COUNT;
1:2aff82c:                 }
1:2aff82c:             }
1:2aff82c:         ));
1:2aff82c: 
1:2aff82c:         afterRollback.addAll(received);
1:2aff82c:         received.clear();
1:2aff82c: 
1:2aff82c:         assertEquals(beforeRollback.size(), afterRollback.size());
1:2aff82c:         assertEquals(beforeRollback, afterRollback);
1:0b6bf7e: 
1:2aff82c:         Iterator<Message> after = afterRollback.iterator();
1:2aff82c:         Iterator<Message> before = beforeRollback.iterator();
1:2aff82c: 
1:2aff82c:         while (before.hasNext() && after.hasNext()) {
1:2aff82c:             TextMessage original = (TextMessage) before.next();
1:2aff82c:             TextMessage rolledBack = (TextMessage) after.next();
1:2aff82c: 
1:2aff82c:             int originalInt = Integer.parseInt(original.getText());
1:2aff82c:             int rolledbackInt = Integer.parseInt(rolledBack.getText());
1:2aff82c: 
1:2aff82c:             assertEquals(originalInt, rolledbackInt);
1:2aff82c:         }
1:2aff82c: 
1:2aff82c:         session.commit();
1:2aff82c:     }
1:2aff82c: 
1:2aff82c:     @Test
1:0b6bf7e:     public void testMessageDeleiveryDoesntStop() throws Exception {
1:0b6bf7e: 
1:0b6bf7e:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:0b6bf7e:         final LinkedHashSet<Message> beforeRollback = new LinkedHashSet<Message>();
1:0b6bf7e:         final LinkedHashSet<Message> afterRollback = new LinkedHashSet<Message>();
1:0b6bf7e: 
1:0b6bf7e:         Connection connection = connectionFactory.createConnection();
1:0b6bf7e:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:0b6bf7e:         Destination destination = session.createQueue(destinationName);
1:0b6bf7e:         MessageConsumer consumer = session.createConsumer(destination);
1:0b6bf7e: 
1:0b6bf7e:         consumer.setMessageListener(new MessageListener() {
1:2aff82c:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e:                 received.add(message);
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         sendMessages();
1:0b6bf7e:         connection.start();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:0b6bf7e:                     return received.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         beforeRollback.addAll(received);
1:0b6bf7e:         received.clear();
1:0b6bf7e:         session.rollback();
1:0b6bf7e: 
1:0b6bf7e:         sendMessages();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:0b6bf7e:                     return received.size() == MSG_COUNT * 2;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         afterRollback.addAll(received);
1:0b6bf7e:         received.clear();
1:0b6bf7e: 
1:0b6bf7e:         assertEquals(beforeRollback.size() * 2, afterRollback.size());
1:0b6bf7e: 
1:0b6bf7e:         session.commit();
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     @Test
1:0b6bf7e:     public void testNonBlockingMessageDeleiveryIsDelayed() throws Exception {
1:0b6bf7e:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:0b6bf7e: 
1:0b6bf7e:         ActiveMQConnection connection = (ActiveMQConnection) connectionFactory.createConnection();
1:0b6bf7e:         connection.getRedeliveryPolicy().setInitialRedeliveryDelay(TimeUnit.SECONDS.toMillis(6));
1:0b6bf7e:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:0b6bf7e:         Destination destination = session.createQueue(destinationName);
1:0b6bf7e:         MessageConsumer consumer = session.createConsumer(destination);
1:0b6bf7e: 
1:0b6bf7e:         consumer.setMessageListener(new MessageListener() {
1:2aff82c:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e:                 received.add(message);
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         sendMessages();
1:0b6bf7e:         connection.start();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:0b6bf7e:                     return received.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         received.clear();
1:0b6bf7e:         session.rollback();
1:0b6bf7e: 
1:0b6bf7e:         assertFalse("Delayed redelivery test not expecting any messages yet.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     return received.size() > 0;
1:0b6bf7e:                 }
1:0b6bf7e:             }, TimeUnit.SECONDS.toMillis(4)
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         session.commit();
1:0b6bf7e:         session.close();
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     @Test
1:0b6bf7e:     public void testNonBlockingMessageDeleiveryWithRollbacks() throws Exception {
1:0b6bf7e:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:0b6bf7e: 
1:0b6bf7e:         ActiveMQConnection connection = (ActiveMQConnection) connectionFactory.createConnection();
1:0b6bf7e:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:0b6bf7e:         final Destination destination = session.createQueue(destinationName);
1:0b6bf7e:         final MessageConsumer consumer = session.createConsumer(destination);
1:0b6bf7e: 
1:0b6bf7e:         consumer.setMessageListener(new MessageListener() {
1:2aff82c:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e:                 received.add(message);
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         sendMessages();
1:0b6bf7e:         connection.start();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:0b6bf7e:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:0b6bf7e:                     return received.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         received.clear();
1:0b6bf7e: 
1:0b6bf7e:         consumer.setMessageListener(new MessageListener() {
1:0b6bf7e: 
1:0b6bf7e:             int count = 0;
1:0b6bf7e: 
1:0b6bf7e:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e: 
1:0b6bf7e:                 if (++count > 10) {
1:0b6bf7e:                     try {
1:0b6bf7e:                         session.rollback();
1:0b6bf7e:                         LOG.info("Rolling back session.");
1:0b6bf7e:                         count = 0;
1:0b6bf7e:                     } catch (JMSException e) {
1:0b6bf7e:                         LOG.warn("Caught an unexcepted exception: " + e.getMessage());
1:0b6bf7e:                     }
1:0b6bf7e:                 } else {
1:0b6bf7e:                     received.add(message);
1:0b6bf7e:                     try {
1:0b6bf7e:                         session.commit();
1:0b6bf7e:                     } catch (JMSException e) {
1:0b6bf7e:                         LOG.warn("Caught an unexcepted exception: " + e.getMessage());
1:0b6bf7e:                     }
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         session.rollback();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:0b6bf7e:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:0b6bf7e:                     return received.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         assertEquals(MSG_COUNT, received.size());
1:0b6bf7e:         session.commit();
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     @Test
1:0b6bf7e:     public void testNonBlockingMessageDeleiveryWithAllRolledBack() throws Exception {
1:0b6bf7e:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:0b6bf7e:         final LinkedHashSet<Message> dlqed = new LinkedHashSet<Message>();
1:0b6bf7e: 
1:0b6bf7e:         ActiveMQConnection connection = (ActiveMQConnection) connectionFactory.createConnection();
1:0b6bf7e:         connection.getRedeliveryPolicy().setMaximumRedeliveries(5);
1:0b6bf7e:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:0b6bf7e:         final Destination destination = session.createQueue(destinationName);
1:0b6bf7e:         final Destination dlq = session.createQueue("ActiveMQ.DLQ");
1:0b6bf7e:         final MessageConsumer consumer = session.createConsumer(destination);
1:0b6bf7e:         final MessageConsumer dlqConsumer = session.createConsumer(dlq);
1:0b6bf7e: 
1:0b6bf7e:         dlqConsumer.setMessageListener(new MessageListener() {
1:0b6bf7e:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e:                 dlqed.add(message);
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         consumer.setMessageListener(new MessageListener() {
1:0b6bf7e:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e:                 received.add(message);
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         sendMessages();
1:0b6bf7e:         connection.start();
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:0b6bf7e:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:0b6bf7e:                     return received.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         session.rollback();
1:0b6bf7e: 
1:0b6bf7e:         consumer.setMessageListener(new MessageListener() {
1:0b6bf7e:             @Override
1:0b6bf7e:             public void onMessage(Message message) {
1:0b6bf7e:                 try {
1:0b6bf7e:                     session.rollback();
1:0b6bf7e:                 } catch (JMSException e) {
1:0b6bf7e:                     LOG.warn("Caught an unexcepted exception: " + e.getMessage());
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         });
1:0b6bf7e: 
1:0b6bf7e:         assertTrue("Post-Rollback expects to DLQ: " + MSG_COUNT + " messages.",
1:0b6bf7e:             Wait.waitFor(new Wait.Condition(){
1:2aff82c:                 @Override
1:0b6bf7e:                 public boolean isSatisified() throws Exception {
1:0b6bf7e:                     LOG.info("Consumer has received " + dlqed.size() + " messages in DLQ.");
1:0b6bf7e:                     return dlqed.size() == MSG_COUNT;
1:0b6bf7e:                 }
1:0b6bf7e:             }
1:0b6bf7e:         ));
1:0b6bf7e: 
1:0b6bf7e:         session.commit();
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     private void sendMessages() throws Exception {
1:0b6bf7e:         Connection connection = connectionFactory.createConnection();
1:0b6bf7e:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:0b6bf7e:         Destination destination = session.createQueue(destinationName);
1:0b6bf7e:         MessageProducer producer = session.createProducer(destination);
1:0b6bf7e:         for(int i = 0; i < MSG_COUNT; ++i) {
1:0b6bf7e:             producer.send(session.createTextMessage("" + i));
1:0b6bf7e:         }
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     @Before
1:0b6bf7e:     public void startBroker() throws Exception {
1:0b6bf7e:         broker = new BrokerService();
1:0b6bf7e:         broker.setDeleteAllMessagesOnStartup(true);
1:0b6bf7e:         broker.setPersistent(false);
1:0b6bf7e:         broker.setUseJmx(false);
1:0b6bf7e:         broker.addConnector("tcp://0.0.0.0:0");
1:0b6bf7e:         broker.start();
1:0b6bf7e:         broker.waitUntilStarted();
1:0b6bf7e: 
1:0b6bf7e:         connectionUri = broker.getTransportConnectors().get(0).getPublishableConnectString();
1:0b6bf7e:         connectionFactory = new ActiveMQConnectionFactory(connectionUri);
1:0b6bf7e:         connectionFactory.setNonBlockingRedelivery(true);
1:0b6bf7e: 
1:0b6bf7e:         RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:0b6bf7e:         policy.setInitialRedeliveryDelay(TimeUnit.SECONDS.toMillis(2));
1:0b6bf7e:         policy.setBackOffMultiplier(-1);
1:0b6bf7e:         policy.setRedeliveryDelay(TimeUnit.SECONDS.toMillis(2));
1:0b6bf7e:         policy.setMaximumRedeliveryDelay(-1);
1:0b6bf7e:         policy.setUseExponentialBackOff(false);
1:0b6bf7e:         policy.setMaximumRedeliveries(-1);
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     @After
1:0b6bf7e:     public void stopBroker() throws Exception {
1:0b6bf7e:         broker.stop();
1:0b6bf7e:         broker.waitUntilStopped();
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2aff82c
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.TextMessage;
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:     public void testMessageDeleiveredInCorrectOrder() throws Exception {
1: 
1:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:         final LinkedHashSet<Message> beforeRollback = new LinkedHashSet<Message>();
1:         final LinkedHashSet<Message> afterRollback = new LinkedHashSet<Message>();
1: 
1:         Connection connection = connectionFactory.createConnection();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(destinationName);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 received.add(message);
1:             }
1:         });
1: 
1:         sendMessages();
1: 
1:         session.commit();
1:         connection.start();
1: 
1:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         beforeRollback.addAll(received);
1:         received.clear();
1:         session.rollback();
1: 
1:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         afterRollback.addAll(received);
1:         received.clear();
1: 
1:         assertEquals(beforeRollback.size(), afterRollback.size());
1:         assertEquals(beforeRollback, afterRollback);
1: 
1:         Iterator<Message> after = afterRollback.iterator();
1:         Iterator<Message> before = beforeRollback.iterator();
1: 
1:         while (before.hasNext() && after.hasNext()) {
1:             TextMessage original = (TextMessage) before.next();
1:             TextMessage rolledBack = (TextMessage) after.next();
1: 
1:             int originalInt = Integer.parseInt(original.getText());
1:             int rolledbackInt = Integer.parseInt(rolledBack.getText());
1: 
1:             assertEquals(originalInt, rolledbackInt);
1:         }
1: 
1:         session.commit();
1:     }
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
commit:ef24cc9
commit:0b6bf7e
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
0: import static org.junit.Assert.*;
1: 
1: import java.util.LinkedHashSet;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.Connection;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.RedeliveryPolicy;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.util.Wait;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class NonBlockingConsumerRedeliveryTest {
1:     private static final Logger LOG = LoggerFactory.getLogger(NonBlockingConsumerRedeliveryTest.class);
1: 
1:     private final String destinationName = "Destination";
1:     private final int MSG_COUNT = 100;
1: 
1:     private BrokerService broker;
1:     private String connectionUri;
1: 
1:     private ActiveMQConnectionFactory connectionFactory;
1: 
1:     @Test
1:     public void testMessageDeleiveredWhenNonBlockingEnabled() throws Exception {
1: 
1:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:         final LinkedHashSet<Message> beforeRollback = new LinkedHashSet<Message>();
1:         final LinkedHashSet<Message> afterRollback = new LinkedHashSet<Message>();
1: 
1:         Connection connection = connectionFactory.createConnection();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(destinationName);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 received.add(message);
1:             }
1:         });
1: 
1:         sendMessages();
1: 
1:         session.commit();
1:         connection.start();
1: 
1:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         beforeRollback.addAll(received);
1:         received.clear();
1:         session.rollback();
1: 
1:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         afterRollback.addAll(received);
1:         received.clear();
1: 
1:         assertEquals(beforeRollback.size(), afterRollback.size());
1:         assertEquals(beforeRollback, afterRollback);
1:         session.commit();
1:     }
1: 
1:     @Test
1:     public void testMessageDeleiveryDoesntStop() throws Exception {
1: 
1:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:         final LinkedHashSet<Message> beforeRollback = new LinkedHashSet<Message>();
1:         final LinkedHashSet<Message> afterRollback = new LinkedHashSet<Message>();
1: 
1:         Connection connection = connectionFactory.createConnection();
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(destinationName);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 received.add(message);
1:             }
1:         });
1: 
1:         sendMessages();
1:         connection.start();
1: 
1:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         beforeRollback.addAll(received);
1:         received.clear();
1:         session.rollback();
1: 
1:         sendMessages();
1: 
1:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:                     return received.size() == MSG_COUNT * 2;
1:                 }
1:             }
1:         ));
1: 
1:         afterRollback.addAll(received);
1:         received.clear();
1: 
1:         assertEquals(beforeRollback.size() * 2, afterRollback.size());
1: 
1:         session.commit();
1:     }
1: 
1:     @Test
1:     public void testNonBlockingMessageDeleiveryIsDelayed() throws Exception {
1:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1: 
1:         ActiveMQConnection connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.getRedeliveryPolicy().setInitialRedeliveryDelay(TimeUnit.SECONDS.toMillis(6));
1:         Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(destinationName);
1:         MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 received.add(message);
1:             }
1:         });
1: 
1:         sendMessages();
1:         connection.start();
1: 
1:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         received.clear();
1:         session.rollback();
1: 
1:         assertFalse("Delayed redelivery test not expecting any messages yet.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     return received.size() > 0;
1:                 }
1:             }, TimeUnit.SECONDS.toMillis(4)
1:         ));
1: 
1:         session.commit();
1:         session.close();
1:     }
1: 
1:     @Test
1:     public void testNonBlockingMessageDeleiveryWithRollbacks() throws Exception {
1:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1: 
1:         ActiveMQConnection connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         final Destination destination = session.createQueue(destinationName);
1:         final MessageConsumer consumer = session.createConsumer(destination);
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 received.add(message);
1:             }
1:         });
1: 
1:         sendMessages();
1:         connection.start();
1: 
1:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         received.clear();
1: 
1:         consumer.setMessageListener(new MessageListener() {
1: 
1:             int count = 0;
1: 
1:             @Override
1:             public void onMessage(Message message) {
1: 
1:                 if (++count > 10) {
1:                     try {
1:                         session.rollback();
1:                         LOG.info("Rolling back session.");
1:                         count = 0;
1:                     } catch (JMSException e) {
1:                         LOG.warn("Caught an unexcepted exception: " + e.getMessage());
1:                     }
1:                 } else {
1:                     received.add(message);
1:                     try {
1:                         session.commit();
1:                     } catch (JMSException e) {
1:                         LOG.warn("Caught an unexcepted exception: " + e.getMessage());
1:                     }
1:                 }
1:             }
1:         });
1: 
1:         session.rollback();
1: 
1:         assertTrue("Post-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages since rollback.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         assertEquals(MSG_COUNT, received.size());
1:         session.commit();
1:     }
1: 
1:     @Test
1:     public void testNonBlockingMessageDeleiveryWithAllRolledBack() throws Exception {
1:         final LinkedHashSet<Message> received = new LinkedHashSet<Message>();
1:         final LinkedHashSet<Message> dlqed = new LinkedHashSet<Message>();
1: 
1:         ActiveMQConnection connection = (ActiveMQConnection) connectionFactory.createConnection();
1:         connection.getRedeliveryPolicy().setMaximumRedeliveries(5);
1:         final Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:         final Destination destination = session.createQueue(destinationName);
1:         final Destination dlq = session.createQueue("ActiveMQ.DLQ");
1:         final MessageConsumer consumer = session.createConsumer(destination);
1:         final MessageConsumer dlqConsumer = session.createConsumer(dlq);
1: 
1:         dlqConsumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 dlqed.add(message);
1:             }
1:         });
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 received.add(message);
1:             }
1:         });
1: 
1:         sendMessages();
1:         connection.start();
1: 
1:         assertTrue("Pre-Rollback expects to receive: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + received.size() + " messages.");
1:                     return received.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         session.rollback();
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 try {
1:                     session.rollback();
1:                 } catch (JMSException e) {
1:                     LOG.warn("Caught an unexcepted exception: " + e.getMessage());
1:                 }
1:             }
1:         });
1: 
1:         assertTrue("Post-Rollback expects to DLQ: " + MSG_COUNT + " messages.",
1:             Wait.waitFor(new Wait.Condition(){
1:                 public boolean isSatisified() throws Exception {
1:                     LOG.info("Consumer has received " + dlqed.size() + " messages in DLQ.");
1:                     return dlqed.size() == MSG_COUNT;
1:                 }
1:             }
1:         ));
1: 
1:         session.commit();
1:     }
1: 
1:     private void sendMessages() throws Exception {
1:         Connection connection = connectionFactory.createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(destinationName);
1:         MessageProducer producer = session.createProducer(destination);
1:         for(int i = 0; i < MSG_COUNT; ++i) {
1:             producer.send(session.createTextMessage("" + i));
1:         }
1:     }
1: 
1:     @Before
1:     public void startBroker() throws Exception {
1:         broker = new BrokerService();
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.setPersistent(false);
1:         broker.setUseJmx(false);
1:         broker.addConnector("tcp://0.0.0.0:0");
1:         broker.start();
1:         broker.waitUntilStarted();
1: 
1:         connectionUri = broker.getTransportConnectors().get(0).getPublishableConnectString();
1:         connectionFactory = new ActiveMQConnectionFactory(connectionUri);
1:         connectionFactory.setNonBlockingRedelivery(true);
1: 
1:         RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:         policy.setInitialRedeliveryDelay(TimeUnit.SECONDS.toMillis(2));
1:         policy.setBackOffMultiplier(-1);
1:         policy.setRedeliveryDelay(TimeUnit.SECONDS.toMillis(2));
1:         policy.setMaximumRedeliveryDelay(-1);
1:         policy.setUseExponentialBackOff(false);
1:         policy.setMaximumRedeliveries(-1);
1:     }
1: 
1:     @After
1:     public void stopBroker() throws Exception {
1:         broker.stop();
1:         broker.waitUntilStopped();
1:     }
1: 
1: }
============================================================================