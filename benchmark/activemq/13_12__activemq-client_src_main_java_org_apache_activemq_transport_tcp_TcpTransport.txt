1:31c55f7: /*
1:31c55f7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f812e34:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.transport.tcp;
1:e22a37a: 
1:04ee70a: import java.io.DataInputStream;
1:04ee70a: import java.io.DataOutputStream;
1:04ee70a: import java.io.IOException;
1:04ee70a: import java.io.InterruptedIOException;
1:04ee70a: import java.net.InetAddress;
1:04ee70a: import java.net.InetSocketAddress;
1:04ee70a: import java.net.Socket;
1:04ee70a: import java.net.SocketAddress;
1:04ee70a: import java.net.SocketException;
1:04ee70a: import java.net.SocketTimeoutException;
1:04ee70a: import java.net.URI;
1:04ee70a: import java.net.UnknownHostException;
1:04ee70a: import java.nio.ByteBuffer;
1:31c55f7: import java.security.cert.X509Certificate;
1:04ee70a: import java.util.HashMap;
1:04ee70a: import java.util.Map;
1:04ee70a: import java.util.concurrent.CountDownLatch;
1:04ee70a: import java.util.concurrent.TimeUnit;
1:04ee70a: import java.util.concurrent.atomic.AtomicReference;
1:04ee70a: 
1:04ee70a: import javax.net.SocketFactory;
1:04ee70a: 
1:ea74731: import org.apache.activemq.Service;
1:9a8f6e4: import org.apache.activemq.TransportLoggerSupport;
1:8a01c5d: import org.apache.activemq.thread.TaskRunnerFactory;
1:ea74731: import org.apache.activemq.transport.Transport;
1:ea74731: import org.apache.activemq.transport.TransportThreadSupport;
1:8a1f994: import org.apache.activemq.util.InetAddressUtil;
1:ea74731: import org.apache.activemq.util.IntrospectionSupport;
1:ea74731: import org.apache.activemq.util.ServiceStopper;
1:ea74731: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:9a8f6e4: 
1:d29ca2a: /**
1:d29ca2a:  * An implementation of the {@link Transport} interface using raw tcp/ip
1:d29ca2a:  */
1:d29ca2a: public class TcpTransport extends TransportThreadSupport implements Transport, Service, Runnable {
1:31c55f7: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TcpTransport.class);
1:31c55f7: 
1:68c8c64:     protected final URI remoteLocation;
1:68c8c64:     protected final URI localLocation;
1:68c8c64:     protected final WireFormat wireFormat;
1:ea74731: 
1:68c8c64:     protected int connectionTimeout = 30000;
1:933eb2f:     protected int soTimeout;
1:166a04b:     protected int socketBufferSize = 64 * 1024;
1:166a04b:     protected int ioBufferSize = 8 * 1024;
1:157d630:     protected boolean closeAsync=true;
1:68c8c64:     protected Socket socket;
1:68c8c64:     protected DataOutputStream dataOut;
1:68c8c64:     protected DataInputStream dataIn;
1:2189100:     protected TimeStampStream buffOut = null;
1:ea74731: 
1:04ee70a:     protected final InitBuffer initBuffer;
1:04ee70a: 
1:d29ca2a:     /**
1:dfeecb4:      * The Traffic Class to be set on the socket.
1:d29ca2a:      */
1:dfeecb4:     protected int trafficClass = 0;
1:d29ca2a:     /**
1:dfeecb4:      * Keeps track of attempts to set the Traffic Class on the socket.
1:d29ca2a:      */
1:54fa83d:     private boolean trafficClassSet = false;
1:d29ca2a:     /**
1:dfeecb4:      * Prevents setting both the Differentiated Services and Type of Service
1:dfeecb4:      * transport options at the same time, since they share the same spot in
1:dfeecb4:      * the TCP/IP packet headers.
1:dfeecb4:      */
1:dfeecb4:     protected boolean diffServChosen = false;
1:dfeecb4:     protected boolean typeOfServiceChosen = false;
1:d29ca2a:     /**
1:df6b542:      * trace=true -> the Transport stack where this TcpTransport
1:df6b542:      * object will be, will have a TransportLogger layer
1:df6b542:      * trace=false -> the Transport stack where this TcpTransport
1:df6b542:      * object will be, will NOT have a TransportLogger layer, and therefore
1:df6b542:      * will never be able to print logging messages.
2:df6b542:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:54fa83d:      */
1:df6b542:     protected boolean trace = false;
1:c4d8d86:     /**
1:c4d8d86:      * Name of the LogWriter implementation to use.
1:c4d8d86:      * Names are mapped to classes in the resources/META-INF/services/org/apache/activemq/transport/logwriters directory.
1:c4d8d86:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:c4d8d86:      */
1:9a8f6e4:     protected String logWriterName = TransportLoggerSupport.defaultLogWriterName;
1:dfeecb4:     /**
1:df6b542:      * Specifies if the TransportLogger will be manageable by JMX or not.
1:df6b542:      * Also, as long as there is at least 1 TransportLogger which is manageable,
1:df6b542:      * a TransportLoggerControl MBean will me created.
1:54fa83d:      */
1:df6b542:     protected boolean dynamicManagement = false;
1:54fa83d:     /**
1:df6b542:      * startLogging=true -> the TransportLogger object of the Transport stack
1:df6b542:      * will initially write messages to the log.
1:df6b542:      * startLogging=false -> the TransportLogger object of the Transport stack
1:df6b542:      * will initially NOT write messages to the log.
1:df6b542:      * This parameter only has an effect if trace == true.
1:df6b542:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:df6b542:      */
1:df6b542:     protected boolean startLogging = true;
1:54fa83d:     /**
1:df6b542:      * Specifies the port that will be used by the JMX server to manage
1:df6b542:      * the TransportLoggers.
1:df6b542:      * This should only be set in an URI by a client (producer or consumer) since
1:df6b542:      * a broker will already create a JMX server.
1:df6b542:      * It is useful for people who test a broker and clients in the same machine
1:df6b542:      * and want to control both via JMX; a different port will be needed.
1:df6b542:      */
1:df6b542:     protected int jmxPort = 1099;
1:05101de:     protected boolean useLocalHost = false;
1:68c8c64:     protected int minmumWireFormatVersion;
1:635bc2b:     protected SocketFactory socketFactory;
1:ea74731:     protected final AtomicReference<CountDownLatch> stoppedLatch = new AtomicReference<CountDownLatch>();
1:78265ea:     protected volatile int receiveCounter;
1:68c8c64: 
1:69fad2a:     protected Map<String, Object> socketOptions;
1:52d5189:     private int soLinger = Integer.MIN_VALUE;
1:d4a8347:     private Boolean keepAlive;
1:d21381d:     private Boolean tcpNoDelay;
1:fd2c95e:     private Thread runnerThread;
1:e22a37a: 
1:df6b542:     /**
2:d29ca2a:      * Connect to a remote Node - e.g. a Broker
1:f812e34:      *
3:d29ca2a:      * @param wireFormat
1:e73f5aa:      * @param socketFactory
4:d29ca2a:      * @param remoteLocation
1:f812e34:      * @param localLocation - e.g. local InetAddress and local port
5:d29ca2a:      * @throws IOException
4:d29ca2a:      * @throws UnknownHostException
1:d29ca2a:      */
1:933eb2f:     public TcpTransport(WireFormat wireFormat, SocketFactory socketFactory, URI remoteLocation,
1:933eb2f:                         URI localLocation) throws UnknownHostException, IOException {
1:68c8c64:         this.wireFormat = wireFormat;
1:e73f5aa:         this.socketFactory = socketFactory;
1:2d27d56:         try {
1:68c8c64:             this.socket = socketFactory.createSocket();
1:f812e34:         } catch (SocketException e) {
1:e73f5aa:             this.socket = null;
1:f812e34:         }
1:68c8c64:         this.remoteLocation = remoteLocation;
1:68c8c64:         this.localLocation = localLocation;
1:04ee70a:         this.initBuffer = null;
1:68c8c64:         setDaemon(false);
1:e22a37a:     }
1:2a1ec7c: 
1:d29ca2a:     /**
1:d29ca2a:      * Initialize from a server Socket
1:f812e34:      *
1:d29ca2a:      * @param wireFormat
1:d29ca2a:      * @param socket
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     public TcpTransport(WireFormat wireFormat, Socket socket) throws IOException {
1:04ee70a:         this(wireFormat, socket, null);
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     public TcpTransport(WireFormat wireFormat, Socket socket, InitBuffer initBuffer) throws IOException {
1:68c8c64:         this.wireFormat = wireFormat;
1:d29ca2a:         this.socket = socket;
1:68c8c64:         this.remoteLocation = null;
1:68c8c64:         this.localLocation = null;
1:04ee70a:         this.initBuffer = initBuffer;
1:d29ca2a:         setDaemon(true);
1:1229c23:     }
1:2a1ec7c: 
1:d29ca2a:     /**
1:d29ca2a:      * A one way asynchronous send
1:d29ca2a:      */
1:04ee70a:     @Override
1:9ca56a0:     public void oneway(Object command) throws IOException {
1:9ca56a0:         checkStarted();
1:2a1ec7c:         wireFormat.marshal(command, dataOut);
1:2a1ec7c:         dataOut.flush();
1:e22a37a:     }
1:e22a37a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return pretty print of 'this'
1:d29ca2a:      */
1:f392884:     @Override
1:d29ca2a:     public String toString() {
1:6c73104:         return "" + (socket.isConnected() ? "tcp://" + socket.getInetAddress() + ":" + socket.getPort() + "@" + socket.getLocalPort()
1:956c3e0:                 : (localLocation != null ? localLocation : remoteLocation)) ;
1:e22a37a:     }
1:2d27d56: 
1:d29ca2a:     /**
1:d29ca2a:      * reads packets from a Socket
1:d29ca2a:      */
1:04ee70a:     @Override
1:e22a37a:     public void run() {
1:8761189:         LOG.trace("TCP consumer thread for " + this + " starting");
1:fd2c95e:         this.runnerThread=Thread.currentThread();
1:e22a37a:         try {
1:f812e34:             while (!isStopped()) {
1:f812e34:                 doRun();
1:e22a37a:             }
1:e22a37a:         } catch (IOException e) {
1:f812e34:             stoppedLatch.get().countDown();
1:ea74731:             onException(e);
1:e233801:         } catch (Throwable e){
1:f812e34:             stoppedLatch.get().countDown();
1:a58b008:             IOException ioe=new IOException("Unexpected error occurred: " + e);
1:e233801:             ioe.initCause(e);
1:e233801:             onException(ioe);
1:e233801:         }finally {
2:ea74731:             stoppedLatch.get().countDown();
1:e22a37a:         }
1:e22a37a:     }
1:ea74731: 
1:f812e34:     protected void doRun() throws IOException {
1:e22a37a:         try {
1:f812e34:             Object command = readCommand();
1:f812e34:             doConsume(command);
1:f812e34:         } catch (SocketTimeoutException e) {
1:f812e34:         } catch (InterruptedIOException e) {
1:e22a37a:         }
1:f812e34:     }
1:2d27d56: 
1:e73f5aa:     protected Object readCommand() throws IOException {
1:e73f5aa:         return wireFormat.unmarshal(dataIn);
1:2d27d56:     }
1:ea74731: 
1:d29ca2a:     // Properties
1:d29ca2a:     // -------------------------------------------------------------------------
1:54fa83d:     public String getDiffServ() {
1:54fa83d:         // This is the value requested by the user by setting the Tcp Transport
1:54fa83d:         // options. If the socket hasn't been created, then this value may not
1:54fa83d:         // reflect the value returned by Socket.getTrafficClass().
1:dfeecb4:         return Integer.toString(this.trafficClass);
1:2d27d56:     }
1:68c8c64: 
1:54fa83d:     public void setDiffServ(String diffServ) throws IllegalArgumentException {
1:dfeecb4:         this.trafficClass = QualityOfServiceUtils.getDSCP(diffServ);
1:dfeecb4:         this.diffServChosen = true;
1:2d27d56:     }
1:b4b8499: 
1:dfeecb4:     public int getTypeOfService() {
1:dfeecb4:         // This is the value requested by the user by setting the Tcp Transport
1:dfeecb4:         // options. If the socket hasn't been created, then this value may not
1:dfeecb4:         // reflect the value returned by Socket.getTrafficClass().
1:dfeecb4:         return this.trafficClass;
1:2d27d56:     }
1:b4b8499: 
1:dfeecb4:     public void setTypeOfService(int typeOfService) {
1:dfeecb4:         this.trafficClass = QualityOfServiceUtils.getToS(typeOfService);
1:dfeecb4:         this.typeOfServiceChosen = true;
1:ea74731:     }
1:2ee58ca: 
1:d29ca2a:     public boolean isTrace() {
1:d29ca2a:         return trace;
1:ea74731:     }
1:f451ad0: 
1:d29ca2a:     public void setTrace(boolean trace) {
1:d29ca2a:         this.trace = trace;
1:ea74731:     }
1:c4d8d86: 
1:c4d8d86:     public String getLogWriterName() {
1:c4d8d86:         return logWriterName;
1:c4d8d86:     }
1:c4d8d86: 
1:c4d8d86:     public void setLogWriterName(String logFormat) {
1:c4d8d86:         this.logWriterName = logFormat;
1:c4d8d86:     }
1:1229c23: 
1:df6b542:     public boolean isDynamicManagement() {
1:df6b542:         return dynamicManagement;
1:ea74731:     }
1:1229c23: 
1:df6b542:     public void setDynamicManagement(boolean useJmx) {
1:df6b542:         this.dynamicManagement = useJmx;
1:1229c23:     }
1:1229c23: 
1:df6b542:     public boolean isStartLogging() {
1:df6b542:         return startLogging;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     public void setStartLogging(boolean startLogging) {
1:df6b542:         this.startLogging = startLogging;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     public int getJmxPort() {
1:df6b542:         return jmxPort;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     public void setJmxPort(int jmxPort) {
1:df6b542:         this.jmxPort = jmxPort;
1:d29ca2a:     }
1:c4d8d86: 
1:d29ca2a:     public int getMinmumWireFormatVersion() {
1:d29ca2a:         return minmumWireFormatVersion;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setMinmumWireFormatVersion(int minmumWireFormatVersion) {
1:d29ca2a:         this.minmumWireFormatVersion = minmumWireFormatVersion;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isUseLocalHost() {
1:d29ca2a:         return useLocalHost;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets whether 'localhost' or the actual local host name should be used to
1:d29ca2a:      * make local connections. On some operating systems such as Macs its not
1:d29ca2a:      * possible to connect as the local host name so localhost is better.
1:d29ca2a:      */
1:d29ca2a:     public void setUseLocalHost(boolean useLocalHost) {
1:d29ca2a:         this.useLocalHost = useLocalHost;
1:d29ca2a:     }
1:d29ca2a: 
1:99c1a67:     public int getSocketBufferSize() {
1:99c1a67:         return socketBufferSize;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:99c1a67:      * Sets the buffer size to use on the socket
1:d29ca2a:      */
1:99c1a67:     public void setSocketBufferSize(int socketBufferSize) {
1:99c1a67:         this.socketBufferSize = socketBufferSize;
1:d29ca2a:     }
1:d29ca2a: 
1:99c1a67:     public int getSoTimeout() {
1:99c1a67:         return soTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:99c1a67:      * Sets the socket timeout
1:d29ca2a:      */
1:99c1a67:     public void setSoTimeout(int soTimeout) {
1:99c1a67:         this.soTimeout = soTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:c2123e3:     public int getConnectionTimeout() {
1:c2123e3:         return connectionTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     /**
1:c2123e3:      * Sets the timeout used to connect to the socket
1:df6b542:      */
1:c2123e3:     public void setConnectionTimeout(int connectionTimeout) {
1:c2123e3:         this.connectionTimeout = connectionTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:d4a8347:     public Boolean getKeepAlive() {
1:d4a8347:         return keepAlive;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     /**
1:d4a8347:      * Enable/disable TCP KEEP_ALIVE mode
1:df6b542:      */
1:d4a8347:     public void setKeepAlive(Boolean keepAlive) {
1:d4a8347:         this.keepAlive = keepAlive;
1:d29ca2a:     }
1:d29ca2a: 
1:0aa5c2a:     /**
1:52d5189:      * Enable/disable soLinger
1:52d5189:      * @param soLinger enabled if > -1, disabled if == -1, system default otherwise
1:0aa5c2a:      */
1:0aa5c2a:     public void setSoLinger(int soLinger) {
1:0aa5c2a:         this.soLinger = soLinger;
1:d29ca2a:     }
1:d29ca2a: 
1:0aa5c2a:     public int getSoLinger() {
1:0aa5c2a:         return soLinger;
1:d29ca2a:     }
1:d29ca2a: 
1:d21381d:     public Boolean getTcpNoDelay() {
1:d21381d:         return tcpNoDelay;
1:d29ca2a:     }
1:d29ca2a: 
1:df6b542:     /**
1:d21381d:      * Enable/disable the TCP_NODELAY option on the socket
1:df6b542:      */
1:d21381d:     public void setTcpNoDelay(Boolean tcpNoDelay) {
1:d21381d:         this.tcpNoDelay = tcpNoDelay;
1:d29ca2a:     }
1:f812e34: 
1:df6b542:     /**
1:166a04b:      * @return the ioBufferSize
1:166a04b:      */
1:f812e34:     public int getIoBufferSize() {
1:166a04b:         return this.ioBufferSize;
1:d29ca2a:     }
1:d29ca2a: 
2:166a04b:     /**
1:166a04b:      * @param ioBufferSize the ioBufferSize to set
1:166a04b:      */
1:f812e34:     public void setIoBufferSize(int ioBufferSize) {
1:f812e34:         this.ioBufferSize = ioBufferSize;
1:d29ca2a:     }
1:d29ca2a: 
1:157d630:     /**
1:157d630:      * @return the closeAsync
1:157d630:      */
1:157d630:     public boolean isCloseAsync() {
1:157d630:         return closeAsync;
1:0aa5c2a:     }
1:d29ca2a: 
1:157d630:     /**
1:157d630:      * @param closeAsync the closeAsync to set
1:157d630:      */
1:157d630:     public void setCloseAsync(boolean closeAsync) {
1:157d630:         this.closeAsync = closeAsync;
1:0aa5c2a:     }
1:d29ca2a: 
1:d29ca2a:     // Implementation methods
1:d29ca2a:     // -------------------------------------------------------------------------
1:d29ca2a:     protected String resolveHostName(String host) throws UnknownHostException {
1:670a9c4:         if (isUseLocalHost()) {
1:8a1f994:             String localName = InetAddressUtil.getLocalHostName();
1:670a9c4:             if (localName != null && localName.equals(host)) {
1:d29ca2a:                 return "localhost";
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return host;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Configures the socket for use
1:f812e34:      *
1:7dfb0a2:      * @param sock  the socket
1:dfeecb4:      * @throws SocketException, IllegalArgumentException if setting the options
1:dfeecb4:      *         on the socket failed.
1:d29ca2a:      */
1:7dfb0a2:     protected void initialiseSocket(Socket sock) throws SocketException, IllegalArgumentException {
1:e73f5aa:         if (socketOptions != null) {
1:7dfb0a2:             // copy the map as its used values is being removed when calling setProperties
1:7dfb0a2:             // and we need to be able to set the options again in case socket is re-initailized
1:7dfb0a2:             Map<String, Object> copy = new HashMap<String, Object>(socketOptions);
1:7dfb0a2:             IntrospectionSupport.setProperties(socket, copy);
1:7dfb0a2:             if (!copy.isEmpty()) {
1:7dfb0a2:                 throw new IllegalArgumentException("Invalid socket parameters: " + copy);
1:7dfb0a2:             }
1:d0b43c1:         }
1:28e9cd7: 
1:e22a37a:         try {
1:90726a6:             //only positive values are legal
1:90726a6:             if (socketBufferSize > 0) {
1:90726a6:                 sock.setReceiveBufferSize(socketBufferSize);
1:90726a6:                 sock.setSendBufferSize(socketBufferSize);
1:90726a6:             } else {
1:90726a6:                 LOG.warn("Socket buffer size was set to {}; Skipping this setting as the size must be a positive number.", socketBufferSize);
1:90726a6:             }
1:f812e34:         } catch (SocketException se) {
1:fc00993:             LOG.warn("Cannot set socket buffer size = " + socketBufferSize);
1:7dfb0a2:             LOG.debug("Cannot set socket buffer size. Reason: " + se.getMessage() + ". This exception is ignored.", se);
1:d0b43c1:         }
1:d29ca2a:         sock.setSoTimeout(soTimeout);
1:28e9cd7: 
1:d4a8347:         if (keepAlive != null) {
1:d4a8347:             sock.setKeepAlive(keepAlive.booleanValue());
1:dfeecb4:         }
1:28e9cd7: 
1:52d5189:         if (soLinger > -1) {
1:0aa5c2a:             sock.setSoLinger(true, soLinger);
1:52d5189:         } else if (soLinger == -1) {
1:52d5189:             sock.setSoLinger(false, 0);
1:0aa5c2a:         }
1:d21381d:         if (tcpNoDelay != null) {
1:d21381d:             sock.setTcpNoDelay(tcpNoDelay.booleanValue());
1:dfeecb4:         }
1:dfeecb4:         if (!this.trafficClassSet) {
1:dfeecb4:             this.trafficClassSet = setTrafficClass(sock);
1:54fa83d:         }
1:54fa83d:     }
1:28e9cd7: 
1:f392884:     @Override
1:c2123e3:     protected void doStart() throws Exception {
1:68c8c64:         connect();
1:ea74731:         stoppedLatch.set(new CountDownLatch(1));
1:68c8c64:         super.doStart();
1:68c8c64:     }
1:68c8c64: 
1:e73f5aa:     protected void connect() throws Exception {
1:68c8c64: 
1:e73f5aa:         if (socket == null && socketFactory == null) {
1:e73f5aa:             throw new IllegalStateException("Cannot connect if the socket or socketFactory have not been set");
1:68c8c64:         }
1:68c8c64: 
1:e73f5aa:         InetSocketAddress localAddress = null;
1:e73f5aa:         InetSocketAddress remoteAddress = null;
1:28e9cd7: 
1:e73f5aa:         if (localLocation != null) {
1:933eb2f:             localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()),
1:933eb2f:                                                  localLocation.getPort());
1:54fa83d:         }
1:28e9cd7: 
1:e73f5aa:         if (remoteLocation != null) {
1:68c8c64:             String host = resolveHostName(remoteLocation.getHost());
1:b4b8499:             remoteAddress = new InetSocketAddress(host, remoteLocation.getPort());
1:b4b8499:         }
1:54fa83d:         // Set the traffic class before the socket is connected when possible so
1:54fa83d:         // that the connection packets are given the correct traffic class.
1:dfeecb4:         this.trafficClassSet = setTrafficClass(socket);
1:b4b8499: 
1:e73f5aa:         if (socket != null) {
1:b4b8499: 
1:e73f5aa:             if (localAddress != null) {
1:b4b8499:                 socket.bind(localAddress);
1:b4b8499:             }
1:28e9cd7: 
1:e73f5aa:             // If it's a server accepted socket.. we don't need to connect it
1:e73f5aa:             // to a remote address.
1:b4b8499:             if (remoteAddress != null) {
1:e73f5aa:                 if (connectionTimeout >= 0) {
1:b4b8499:                     socket.connect(remoteAddress, connectionTimeout);
1:f812e34:                 } else {
1:b4b8499:                     socket.connect(remoteAddress);
1:68c8c64:                 }
1:28e9cd7:             }
1:68c8c64: 
1:f812e34:         } else {
1:e73f5aa:             // For SSL sockets.. you can't create an unconnected socket :(
1:e73f5aa:             // This means the timout option are not supported either.
1:e73f5aa:             if (localAddress != null) {
1:933eb2f:                 socket = socketFactory.createSocket(remoteAddress.getAddress(), remoteAddress.getPort(),
1:933eb2f:                                                     localAddress.getAddress(), localAddress.getPort());
1:f812e34:             } else {
1:e73f5aa:                 socket = socketFactory.createSocket(remoteAddress.getAddress(), remoteAddress.getPort());
1:157d630:             }
1:157d630:         }
1:28e9cd7: 
1:68c8c64:         initialiseSocket(socket);
3:d29ca2a:         initializeStreams();
1:68c8c64:     }
1:ea74731: 
1:f392884:     @Override
1:68c8c64:     protected void doStop(ServiceStopper stopper) throws Exception {
1:fc00993:         if (LOG.isDebugEnabled()) {
1:fc00993:             LOG.debug("Stopping transport " + this);
1:d29ca2a:         }
1:d29ca2a: 
1:e73f5aa:         // Closing the streams flush the sockets before closing.. if the socket
1:e73f5aa:         // is hung.. then this hangs the close.
1:a86a587:         // closeStreams();
1:d29ca2a:         if (socket != null) {
1:157d630:             if (closeAsync) {
1:28e9cd7:                 //closing the socket can hang also
1:157d630:                 final CountDownLatch latch = new CountDownLatch(1);
1:d29ca2a: 
1:8a01c5d:                 // need a async task for this
1:8a01c5d:                 final TaskRunnerFactory taskRunnerFactory = new TaskRunnerFactory();
1:8a01c5d:                 taskRunnerFactory.execute(new Runnable() {
1:04ee70a:                     @Override
1:d29ca2a:                     public void run() {
1:8a01c5d:                         LOG.trace("Closing socket {}", socket);
1:ea74731:                         try {
1:d29ca2a:                             socket.close();
1:8a01c5d:                             LOG.debug("Closed socket {}", socket);
1:ea74731:                         } catch (IOException e) {
1:28e9cd7:                             if (LOG.isDebugEnabled()) {
1:8a01c5d:                                 LOG.debug("Caught exception closing socket " + socket + ". This exception will be ignored.", e);
1:d29ca2a:                             }
1:ea74731:                         } finally {
1:157d630:                             latch.countDown();
1:f812e34:                         }
1:d29ca2a:                     }
1:157d630:                 });
1:8978ac0: 
1:f812e34:                 try {
1:28e9cd7:                     latch.await(1,TimeUnit.SECONDS);
2:e22a37a:                 } catch (InterruptedException e) {
1:28e9cd7:                     Thread.currentThread().interrupt();
1:8a01c5d:                 } finally {
1:8a01c5d:                     taskRunnerFactory.shutdownNow();
1:e22a37a:                 }
1:8978ac0: 
1:28e9cd7:             } else {
1:8a01c5d:                 // close synchronously
1:8a01c5d:                 LOG.trace("Closing socket {}", socket);
1:ea74731:                 try {
2:157d630:                     socket.close();
1:8a01c5d:                     LOG.debug("Closed socket {}", socket);
2:157d630:                 } catch (IOException e) {
1:8a01c5d:                     if (LOG.isDebugEnabled()) {
1:8a01c5d:                         LOG.debug("Caught exception closing socket " + socket + ". This exception will be ignored.", e);
1:8a01c5d:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:28e9cd7:     }
1:f812e34: 
1:ea74731:     /**
1:ea74731:      * Override so that stop() blocks until the run thread is no longer running.
1:ea74731:      */
1:ea74731:     @Override
1:ea74731:     public void stop() throws Exception {
1:f812e34:         super.stop();
1:f812e34:         CountDownLatch countDownLatch = stoppedLatch.get();
1:fd2c95e:         if (countDownLatch != null && Thread.currentThread() != this.runnerThread) {
1:8228663:             countDownLatch.await(1,TimeUnit.SECONDS);
1:f812e34:         }
1:ea74731:     }
1:28e9cd7: 
1:e73f5aa:     protected void initializeStreams() throws Exception {
1:8978ac0:         TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), ioBufferSize) {
1:8978ac0:             @Override
1:8978ac0:             public int read() throws IOException {
1:8978ac0:                 receiveCounter++;
1:8978ac0:                 return super.read();
1:8978ac0:             }
1:8978ac0:             @Override
1:8978ac0:             public int read(byte[] b, int off, int len) throws IOException {
1:8978ac0:                 receiveCounter++;
1:8978ac0:                 return super.read(b, off, len);
1:8978ac0:             }
1:8978ac0:             @Override
1:8978ac0:             public long skip(long n) throws IOException {
1:8978ac0:                 receiveCounter++;
1:8978ac0:                 return super.skip(n);
1:8978ac0:             }
1:8978ac0:             @Override
1:8978ac0:             protected void fill() throws IOException {
1:8978ac0:                 receiveCounter++;
1:8978ac0:                 super.fill();
1:8978ac0:             }
1:8978ac0:         };
1:04ee70a:         //Unread the initBuffer that was used for protocol detection if it exists
1:04ee70a:         //so the stream can start over
1:04ee70a:         if (initBuffer != null) {
1:04ee70a:             buffIn.unread(initBuffer.buffer.array());
1:04ee70a:         }
1:d29ca2a:         this.dataIn = new DataInputStream(buffIn);
1:2189100:         TcpBufferedOutputStream outputStream = new TcpBufferedOutputStream(socket.getOutputStream(), ioBufferSize);
1:2189100:         this.dataOut = new DataOutputStream(outputStream);
1:2189100:         this.buffOut = outputStream;
1:04ee70a: 
1:ea74731:     }
1:d29ca2a: 
1:d29ca2a:     protected void closeStreams() throws IOException {
1:d29ca2a:         if (dataOut != null) {
1:d29ca2a:             dataOut.close();
1:d29ca2a:         }
1:d29ca2a:         if (dataIn != null) {
1:d29ca2a:             dataIn.close();
1:2ee58ca:         }
1:d29ca2a:     }
1:2ee58ca: 
1:933eb2f:     public void setSocketOptions(Map<String, Object> socketOptions) {
1:933eb2f:         this.socketOptions = new HashMap<String, Object>(socketOptions);
1:d29ca2a:     }
1:d29ca2a: 
1:04ee70a:     @Override
1:0f1dcce:     public String getRemoteAddress() {
1:e73f5aa:         if (socket != null) {
1:1acc98b:             SocketAddress address = socket.getRemoteSocketAddress();
1:1acc98b:             if (address instanceof InetSocketAddress) {
1:1acc98b:                 return "tcp://" + ((InetSocketAddress)address).getAddress().getHostAddress() + ":" + ((InetSocketAddress)address).getPort();
1:1acc98b:             } else {
1:1acc98b:                 return "" + socket.getRemoteSocketAddress();
1:d29ca2a:             }
1:1acc98b:         }
1:e73f5aa:         return null;
3:157d630:     }
1:642d38c: 
1:642d38c:     @Override
1:642d38c:     public <T> T narrow(Class<T> target) {
1:642d38c:         if (target == Socket.class) {
1:642d38c:             return target.cast(socket);
1:2189100:         } else if ( target == TimeStampStream.class) {
1:f561d6b:             return target.cast(buffOut);
1:642d38c:         }
1:642d38c:         return super.narrow(target);
1:642d38c:     }
1:28e9cd7: 
1:04ee70a:     @Override
1:8978ac0:     public int getReceiveCounter() {
1:8978ac0:         return receiveCounter;
1:8978ac0:     }
1:28e9cd7: 
1:04ee70a:     public static class InitBuffer {
1:04ee70a:         public final int readSize;
1:04ee70a:         public final ByteBuffer buffer;
1:04ee70a: 
1:04ee70a:         public InitBuffer(int readSize, ByteBuffer buffer) {
1:04ee70a:             if (buffer == null) {
1:04ee70a:                 throw new IllegalArgumentException("Null buffer not allowed.");
1:04ee70a:             }
1:04ee70a:             this.readSize = readSize;
1:04ee70a:             this.buffer = buffer;
1:04ee70a:         }
1:04ee70a:     }
1:04ee70a: 
1:54fa83d:     /**
1:dfeecb4:      * @param sock The socket on which to set the Traffic Class.
1:54fa83d:      * @return Whether or not the Traffic Class was set on the given socket.
1:dfeecb4:      * @throws SocketException if the system does not support setting the
1:dfeecb4:      *         Traffic Class.
1:dfeecb4:      * @throws IllegalArgumentException if both the Differentiated Services and
1:dfeecb4:      *         Type of Services transport options have been set on the same
1:dfeecb4:      *         connection.
1:54fa83d:      */
1:dfeecb4:     private boolean setTrafficClass(Socket sock) throws SocketException,
1:dfeecb4:             IllegalArgumentException {
1:dfeecb4:         if (sock == null
1:dfeecb4:             || (!this.diffServChosen && !this.typeOfServiceChosen)) {
1:54fa83d:             return false;
1:54fa83d:         }
1:dfeecb4:         if (this.diffServChosen && this.typeOfServiceChosen) {
1:dfeecb4:             throw new IllegalArgumentException("Cannot set both the "
1:dfeecb4:                 + " Differentiated Services and Type of Services transport "
1:dfeecb4:                 + " options on the same connection.");
1:dfeecb4:         }
1:0885c60: 
1:dfeecb4:         sock.setTrafficClass(this.trafficClass);
1:0885c60: 
1:9740fb2:         int resultTrafficClass = sock.getTrafficClass();
1:9740fb2:         if (this.trafficClass != resultTrafficClass) {
1:9740fb2:             // In the case where the user has specified the ECN bits (e.g. in
1:9740fb2:             // Type of Service) but the system won't allow the ECN bits to be
1:9740fb2:             // set or in the case where setting the traffic class failed for
1:9740fb2:             // other reasons, emit a warning.
1:9740fb2:             if ((this.trafficClass >> 2) == (resultTrafficClass >> 2)
1:9740fb2:                     && (this.trafficClass & 3) != (resultTrafficClass & 3)) {
1:9740fb2:                 LOG.warn("Attempted to set the Traffic Class to "
1:9740fb2:                     + this.trafficClass + " but the result Traffic Class was "
1:9740fb2:                     + resultTrafficClass + ". Please check that your system "
1:9740fb2:                     + "allows you to set the ECN bits (the first two bits).");
1:9740fb2:             } else {
1:9740fb2:                 LOG.warn("Attempted to set the Traffic Class to "
1:9740fb2:                     + this.trafficClass + " but the result Traffic Class was "
1:9740fb2:                     + resultTrafficClass + ". Please check that your system "
1:9740fb2:                          + "supports java.net.setTrafficClass.");
1:9740fb2:             }
1:9740fb2:             return false;
1:9740fb2:         }
1:dfeecb4:         // Reset the guards that prevent both the Differentiated Services
1:dfeecb4:         // option and the Type of Service option from being set on the same
1:dfeecb4:         // connection.
1:dfeecb4:         this.diffServChosen = false;
1:dfeecb4:         this.typeOfServiceChosen = false;
1:dfeecb4:         return true;
1:54fa83d:     }
2:0aa5c2a: 
1:69fad2a:     @Override
1:036f2a8:     public WireFormat getWireFormat() {
1:036f2a8:         return wireFormat;
1:036f2a8:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public X509Certificate[] getPeerCertificates() {
1:31c55f7:         return null;
1:31c55f7:     }
1:31c55f7: 
1:31c55f7:     @Override
1:31c55f7:     public void setPeerCertificates(X509Certificate[] certificates) {
1:31c55f7:     }
1:157d630: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:69fad2a
/////////////////////////////////////////////////////////////////////////
1:     protected Map<String, Object> socketOptions;
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:90726a6
/////////////////////////////////////////////////////////////////////////
1:             //only positive values are legal
1:             if (socketBufferSize > 0) {
1:                 sock.setReceiveBufferSize(socketBufferSize);
1:                 sock.setSendBufferSize(socketBufferSize);
1:             } else {
1:                 LOG.warn("Socket buffer size was set to {}; Skipping this setting as the size must be a positive number.", socketBufferSize);
1:             }
commit:04ee70a
/////////////////////////////////////////////////////////////////////////
1: import java.io.DataInputStream;
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.io.InterruptedIOException;
1: import java.net.InetAddress;
1: import java.net.InetSocketAddress;
1: import java.net.Socket;
1: import java.net.SocketAddress;
1: import java.net.SocketException;
1: import java.net.SocketTimeoutException;
1: import java.net.URI;
1: import java.net.UnknownHostException;
1: import java.nio.ByteBuffer;
1: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import javax.net.SocketFactory;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final InitBuffer initBuffer;
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.initBuffer = null;
/////////////////////////////////////////////////////////////////////////
1:         this(wireFormat, socket, null);
1:     }
1: 
1:     public TcpTransport(WireFormat wireFormat, Socket socket, InitBuffer initBuffer) throws IOException {
1:         this.initBuffer = initBuffer;
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         //Unread the initBuffer that was used for protocol detection if it exists
1:         //so the stream can start over
1:         if (initBuffer != null) {
1:             buffIn.unread(initBuffer.buffer.array());
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public static class InitBuffer {
1:         public final int readSize;
1:         public final ByteBuffer buffer;
1: 
1:         public InitBuffer(int readSize, ByteBuffer buffer) {
1:             if (buffer == null) {
1:                 throw new IllegalArgumentException("Null buffer not allowed.");
1:             }
1:             this.readSize = readSize;
1:             this.buffer = buffer;
1:         }
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
/////////////////////////////////////////////////////////////////////////
1: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public X509Certificate[] getPeerCertificates() {
1:         return null;
1:     }
1: 
1:     @Override
1:     public void setPeerCertificates(X509Certificate[] certificates) {
1:     }
author:gtully
-------------------------------------------------------------------------------
commit:a58b008
/////////////////////////////////////////////////////////////////////////
1:             IOException ioe=new IOException("Unexpected error occurred: " + e);
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:7dfb0a2
/////////////////////////////////////////////////////////////////////////
1:      * @param sock  the socket
1:     protected void initialiseSocket(Socket sock) throws SocketException, IllegalArgumentException {
1:             // copy the map as its used values is being removed when calling setProperties
1:             // and we need to be able to set the options again in case socket is re-initailized
1:             Map<String, Object> copy = new HashMap<String, Object>(socketOptions);
1:             IntrospectionSupport.setProperties(socket, copy);
1:             if (!copy.isEmpty()) {
1:                 throw new IllegalArgumentException("Invalid socket parameters: " + copy);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Cannot set socket buffer size. Reason: " + se.getMessage() + ". This exception is ignored.", se);
commit:8a01c5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:                 // need a async task for this
1:                 final TaskRunnerFactory taskRunnerFactory = new TaskRunnerFactory();
1:                 taskRunnerFactory.execute(new Runnable() {
1:                         LOG.trace("Closing socket {}", socket);
1:                             LOG.debug("Closed socket {}", socket);
1:                                 LOG.debug("Caught exception closing socket " + socket + ". This exception will be ignored.", e);
/////////////////////////////////////////////////////////////////////////
1:                 } finally {
1:                     taskRunnerFactory.shutdownNow();
1:                 // close synchronously
1:                 LOG.trace("Closing socket {}", socket);
1:                     LOG.debug("Closed socket {}", socket);
1:                     if (LOG.isDebugEnabled()) {
1:                         LOG.debug("Caught exception closing socket " + socket + ". This exception will be ignored.", e);
1:                     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.TransportLoggerSupport;
/////////////////////////////////////////////////////////////////////////
0: import javax.net.SocketFactory;
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.InterruptedIOException;
0: import java.net.*;
0: import java.util.HashMap;
0: import java.util.Map;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicReference;
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected String logWriterName = TransportLoggerSupport.defaultLogWriterName;
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:8978ac0
/////////////////////////////////////////////////////////////////////////
0:     private volatile int receiveCounter;
/////////////////////////////////////////////////////////////////////////
1:         TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), ioBufferSize) {
1:             @Override
1:             public int read() throws IOException {
1:                 receiveCounter++;
1:                 return super.read();
1:             }
1:             @Override
1:             public int read(byte[] b, int off, int len) throws IOException {
1:                 receiveCounter++;
1:                 return super.read(b, off, len);
1:             }
1:             @Override
1:             public long skip(long n) throws IOException {
1:                 receiveCounter++;
1:                 return super.skip(n);
1:             }
1:             @Override
1:             protected void fill() throws IOException {
1:                 receiveCounter++;
1:                 super.fill();
1:             }
1:         };
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public int getReceiveCounter() {
1:         return receiveCounter;
1:     }
commit:2a1ec7c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         wireFormat.marshal(command, dataOut);
1:         dataOut.flush();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:            
commit:e22a37a
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ArrayBlockingQueue;
0: import java.util.concurrent.LinkedBlockingQueue;
/////////////////////////////////////////////////////////////////////////
0:     private final ArrayBlockingQueue<Object> outbound = new ArrayBlockingQueue<Object>(100);
0:     private Thread onewayThread;
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:         try {
0:             outbound.put(command);
1:         } catch (InterruptedException e) {
0:             throw new InterruptedIOException();
1:         }
1:     }
1: 
0:     protected void sendOneways() {
1:         try {
0:             while(!isStopped()) {
0:                 Object command = outbound.poll(500, TimeUnit.MILLISECONDS);
0:                 if( command!=null ) {
1:                     try {
0:                         while( command!=null ) {
0:                             wireFormat.marshal(command, dataOut);
0:                             command = outbound.poll();
1:                         }
0:                         dataOut.flush();
1:                     } catch (IOException e) {
0:                         getTransportListener().onException(e);
1:                     }
1:                 }
1:             }
1:         } catch (InterruptedException e) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         onewayThread = new Thread(null, new Runnable(){
1:             public void run() {
0:                 sendOneways();
0:             }}, "ActiveMQ Transport Sender: " + toString(), getStackSize());
0:         onewayThread.start();
/////////////////////////////////////////////////////////////////////////
1:         }
0:         if( onewayThread!=null ) {
0:             onewayThread.join();
0:             onewayThread = null;
0:             outbound.clear();
commit:c4d8d86
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportLoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:  * @author David Martin Clavo david(dot)martin(dot)clavo(at)gmail.com (logging improvement modifications)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Name of the LogWriter implementation to use.
1:      * Names are mapped to classes in the resources/META-INF/services/org/apache/activemq/transport/logwriters directory.
1:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:      */
0:     protected String logWriterName = TransportLoggerFactory.defaultLogWriterName;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public String getLogWriterName() {
1:         return logWriterName;
1:     }
1: 
1:     public void setLogWriterName(String logFormat) {
1:         this.logWriterName = logFormat;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
commit:642d38c
/////////////////////////////////////////////////////////////////////////
1:     
1:     @Override
1:     public <T> T narrow(Class<T> target) {
1:         if (target == Socket.class) {
1:             return target.cast(socket);
1:         }
1:         return super.narrow(target);
1:     }
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     protected int soTimeout;
/////////////////////////////////////////////////////////////////////////
0:     private Map<String, Object> socketOptions;
/////////////////////////////////////////////////////////////////////////
1:     public TcpTransport(WireFormat wireFormat, SocketFactory socketFactory, URI remoteLocation,
1:                         URI localLocation) throws UnknownHostException, IOException {
/////////////////////////////////////////////////////////////////////////
1:             localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()),
1:                                                  localLocation.getPort());
/////////////////////////////////////////////////////////////////////////
1:                 socket = socketFactory.createSocket(remoteAddress.getAddress(), remoteAddress.getPort(),
1:                                                     localAddress.getAddress(), localAddress.getPort());
/////////////////////////////////////////////////////////////////////////
1:     public void setSocketOptions(Map<String, Object> socketOptions) {
1:         this.socketOptions = new HashMap<String, Object>(socketOptions);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TcpTransport.class);
/////////////////////////////////////////////////////////////////////////
0:         LOG.trace("TCP consumer thread starting");
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Cannot set socket buffer size = " + socketBufferSize);
0:             LOG.debug("Cannot set socket buffer size. Reason: " + se, se);
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("Stopping transport " + this);
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * 
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param localLocation - e.g. local InetAddress and local port
/////////////////////////////////////////////////////////////////////////
1:         } catch (SocketException e) {
/////////////////////////////////////////////////////////////////////////
1:      * 
/////////////////////////////////////////////////////////////////////////
1:             while (!isStopped()) {
1:                 doRun();
1:             }
1:             stoppedLatch.get().countDown();
1:             stoppedLatch.get().countDown();
1:     protected void doRun() throws IOException {
1:         try {
1:             Object command = readCommand();
1:             doConsume(command);
1:         } catch (SocketTimeoutException e) {
1:         } catch (InterruptedIOException e) {
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getIoBufferSize() {
1:     public void setIoBufferSize(int ioBufferSize) {
1:         this.ioBufferSize = ioBufferSize;
/////////////////////////////////////////////////////////////////////////
1:      * 
/////////////////////////////////////////////////////////////////////////
1:         } catch (SocketException se) {
/////////////////////////////////////////////////////////////////////////
1:                 } else {
1:         } else {
1:             } else {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         super.stop();
1:         CountDownLatch countDownLatch = stoppedLatch.get();
0:         if (countDownLatch != null) {
0:             countDownLatch.await();
1:         }
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:2d27d56
/////////////////////////////////////////////////////////////////////////
0: 	            doRun();
/////////////////////////////////////////////////////////////////////////
1: 
0: 	protected void doRun() throws IOException {
1: 		try {
0: 		    Object command = readCommand();
0: 		    doConsume(command);
1: 		}
0: 		catch (SocketTimeoutException e) {
1: 		}
0: 		catch (InterruptedIOException e) {
1: 		}
1: 	}
1: 
commit:ea74731
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.atomic.AtomicReference;
1: 
0: import javax.net.SocketFactory;
1: 
1: import org.apache.activemq.Service;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportThreadSupport;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.ServiceStopper;
1: import org.apache.activemq.wireformat.WireFormat;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
1:     protected final AtomicReference<CountDownLatch> stoppedLatch = new AtomicReference<CountDownLatch>();
/////////////////////////////////////////////////////////////////////////
1:         try {
0: 	        while (!isStopped()) {
1: 	            try {
0: 	                Object command = readCommand();
0: 	                doConsume(command);
1: 	            }
0: 	            catch (SocketTimeoutException e) {
1: 	            }
0: 	            catch (InterruptedIOException e) {
1: 	            }
1: 	        }
1:         } catch (IOException e) {
1:         	stoppedLatch.get().countDown();
1:             onException(e);
1:         } finally {
1:         	stoppedLatch.get().countDown();
/////////////////////////////////////////////////////////////////////////
1:         stoppedLatch.set(new CountDownLatch(1));
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     /**
1:      * Override so that stop() blocks until the run thread is no longer running.
1:      */
1:     @Override
1:     public void stop() throws Exception {
0:     	super.stop();
0:     	CountDownLatch countDownLatch = stoppedLatch.get();
0:     	if( countDownLatch!=null ) {
0:     		countDownLatch.await();
1:     	}
1:     }
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void oneway(Object command) throws IOException {
1:         checkStarted();
/////////////////////////////////////////////////////////////////////////
0:                 Object command = wireFormat.unmarshal(dataIn);
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.wireformat.WireFormat;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:68c8c64
/////////////////////////////////////////////////////////////////////////
0: import java.net.SocketAddress;
/////////////////////////////////////////////////////////////////////////
1:     protected final URI remoteLocation;
1:     protected final URI localLocation;
1:     protected final WireFormat wireFormat;
1: 
1:     protected int connectionTimeout = 30000;
0:     protected int soTimeout = 0;
0:     protected int socketBufferSize = 128 * 1024;
1:     protected Socket socket;
1:     protected DataOutputStream dataOut;
1:     protected DataInputStream dataIn;
0:     protected boolean trace;
0:     protected boolean useLocalHost = true;
1:     protected int minmumWireFormatVersion;
/////////////////////////////////////////////////////////////////////////
1:         this.wireFormat = wireFormat;
1:         this.socket = socketFactory.createSocket();
1: 		this.remoteLocation = remoteLocation;
1: 		this.localLocation = localLocation;
1:         setDaemon(false);
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.wireFormat = wireFormat;
1: 		this.remoteLocation = null;
1: 		this.localLocation = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connect();
1:         super.doStart();
1:     }
1: 
0: 	protected void connect() throws SocketException, IOException {
1: 		
1: 		initialiseSocket(socket);
1: 		
0:         if( localLocation!=null ) {
0:         	SocketAddress localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());
1:         }                
0: 		if( remoteLocation!=null ) {
1: 			String host = resolveHostName(remoteLocation.getHost());
0: 	        InetSocketAddress remoteAddress = new InetSocketAddress(host, remoteLocation.getPort());        
1: 		}
1:         
1: 	}
1:     protected void doStop(ServiceStopper stopper) throws Exception {    	
/////////////////////////////////////////////////////////////////////////
0:     	IntrospectionSupport.setProperties(socket, socketOptions);
commit:f2f4281
/////////////////////////////////////////////////////////////////////////
0:             log.warn("Cannot set socket buffer size = " + socketBufferSize);
0:             log.debug("Cannot set socket buffer size. Reason: " + se, se);
commit:b4b8499
/////////////////////////////////////////////////////////////////////////
0: import javax.net.SocketFactory;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private InetSocketAddress remoteAddress;
0: 	private InetSocketAddress localAddress;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * @param localLocation ignored if null
1:     	
1:         remoteAddress = new InetSocketAddress(host, remoteLocation.getPort());
1:         
0:         if( localLocation!=null ) {
0:         	localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());
1:         }
1:         
0:         Socket sock = socketFactory.createSocket();        
/////////////////////////////////////////////////////////////////////////
0:         if( localAddress!=null ) {
1:         	socket.bind(localAddress);
1:         }
1:         if (remoteAddress != null) {
1:                 socket.connect(remoteAddress, connectionTimeout);
1:                 socket.connect(remoteAddress);
commit:2ee58ca
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
0: import org.apache.activemq.util.IntrospectionSupport;
/////////////////////////////////////////////////////////////////////////
0:     private Map socketOptions;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void setSocketOptions(Map socketOptions) {
0:         IntrospectionSupport.setProperties(socket, socketOptions);
1:     }
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activemq.Service;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportThreadSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
commit:ef0c0e1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:375469b
/////////////////////////////////////////////////////////////////////////
0:     private long maxInactivityDuration = 0; //30000;
commit:1229c23
/////////////////////////////////////////////////////////////////////////
0:     private long maxInactivityDuration = 30000;
1:     
/////////////////////////////////////////////////////////////////////////
0:     public long getMaxInactivityDuration() {
0:         return maxInactivityDuration;
1:     }
1: 
0:     public void setMaxInactivityDuration(long maxInactivityDuration) {
0:         this.maxInactivityDuration = maxInactivityDuration;
1:     }
1: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.tcp;
1: 
0: import org.activeio.command.WireFormat;
0: import org.apache.activemq.Service;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportThreadSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import java.io.DataInputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.io.InterruptedIOException;
0: import java.net.InetAddress;
0: import java.net.InetSocketAddress;
0: import java.net.Socket;
0: import java.net.SocketAddress;
0: import java.net.SocketException;
0: import java.net.SocketTimeoutException;
0: import java.net.URI;
0: import java.net.UnknownHostException;
1: 
1: /**
1:  * An implementation of the {@link Transport} interface using raw tcp/ip
0:  * 
0:  * @version $Revision$
1:  */
1: public class TcpTransport extends TransportThreadSupport implements Transport, Service, Runnable {
0:     private static final Log log = LogFactory.getLog(TcpTransport.class);
1: 
0:     private int soTimeout = 10000;
0:     private int socketBufferSize = 64 * 1024;
0:     private Socket socket;
0:     private DataOutputStream dataOut;
0:     private DataInputStream dataIn;
0:     private WireFormat wireFormat;
0:     private boolean trace;
0:     private boolean useLocalHost = true;
0:     private int minmumWireFormatVersion;
1: 
1:     /**
0:      * Construct basic helpers
0:      * 
1:      * @param wireFormat
1:      */
0:     protected TcpTransport(WireFormat wireFormat) {
0:         this.wireFormat = wireFormat;
1:     }
1: 
1:     /**
1:      * Connect to a remote Node - e.g. a Broker
0:      * 
1:      * @param wireFormat
1:      * @param remoteLocation
1:      * @throws IOException
1:      * @throws UnknownHostException
1:      */
0:     public TcpTransport(WireFormat wireFormat, URI remoteLocation) throws UnknownHostException, IOException {
0:         this(wireFormat);
0:         this.socket = createSocket(remoteLocation);
1:         initializeStreams();
1:     }
1: 
1:     /**
1:      * Connect to a remote Node - e.g. a Broker
0:      * 
1:      * @param wireFormat
1:      * @param remoteLocation
0:      * @param localLocation -
0:      *            e.g. local InetAddress and local port
1:      * @throws IOException
1:      * @throws UnknownHostException
1:      */
0:     public TcpTransport(WireFormat wireFormat, URI remoteLocation, URI localLocation) throws UnknownHostException, IOException {
0:         this(wireFormat);
0:         this.socket = createSocket(remoteLocation, localLocation);
1:         initializeStreams();
1:     }
1: 
1:     /**
1:      * Initialize from a server Socket
0:      * 
1:      * @param wireFormat
1:      * @param socket
1:      * @throws IOException
1:      */
1:     public TcpTransport(WireFormat wireFormat, Socket socket) throws IOException {
0:         this(wireFormat);
1:         this.socket = socket;
0:         initialiseSocket(socket);
1:         initializeStreams();
1:         setDaemon(true);
1:     }
1: 
1:     /**
1:      * A one way asynchronous send
1:      */
0:     public void oneway(Command command) throws IOException {
0:         wireFormat.marshal(command, dataOut);
0:         dataOut.flush();
1:     }
1: 
1:     /**
1:      * @return pretty print of 'this'
1:      */
1:     public String toString() {
0:         return "tcp://"+socket.getInetAddress()+":"+socket.getPort();
1:     }
1: 
1:     /**
1:      * reads packets from a Socket
1:      */
1:     public void run() {
0:         log.trace("TCP consumer thread starting");
0:         while (!isClosed()) {
0:             try {
0:                 Command command = (Command) wireFormat.unmarshal(dataIn);
0:                 doConsume(command);
1:             }
0:             catch (SocketTimeoutException e) {
1:             }
0:             catch (InterruptedIOException e) {
1:             }
0:             catch (IOException e) {
0:                 try {
0:                     stop();
1:                 }
0:                 catch (Exception e2) {
0:                     log.warn("Caught while closing: " + e2 + ". Now Closed", e2);
1:                 }
0:                 onException(e);
1:             }
1:         }
1:     }
1: 
1:     // Properties
1:     // -------------------------------------------------------------------------
1: 
1:     public boolean isTrace() {
1:         return trace;
1:     }
1: 
1:     public void setTrace(boolean trace) {
1:         this.trace = trace;
1:     }
1: 
1:     public int getMinmumWireFormatVersion() {
1:         return minmumWireFormatVersion;
1:     }
1: 
1:     public void setMinmumWireFormatVersion(int minmumWireFormatVersion) {
1:         this.minmumWireFormatVersion = minmumWireFormatVersion;
1:     }
1: 
1:     public boolean isUseLocalHost() {
1:         return useLocalHost;
1:     }
1: 
1:     /**
1:      * Sets whether 'localhost' or the actual local host name should be used to
1:      * make local connections. On some operating systems such as Macs its not
1:      * possible to connect as the local host name so localhost is better.
1:      */
1:     public void setUseLocalHost(boolean useLocalHost) {
1:         this.useLocalHost = useLocalHost;
1:     }
1: 
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
1: 
1:     /**
0:      * Factory method to create a new socket
0:      * 
1:      * @param remoteLocation
0:      *            the URI to connect to
0:      * @return the newly created socket
1:      * @throws UnknownHostException
1:      * @throws IOException
1:      */
0:     protected Socket createSocket(URI remoteLocation) throws UnknownHostException, IOException {
0:         String host = resolveHostName(remoteLocation.getHost());
0:         SocketAddress sockAddress = new InetSocketAddress(host, remoteLocation.getPort());
0:         Socket sock = new Socket();
0:         initialiseSocket(sock);
0:         sock.connect(sockAddress);
0:         return sock;
1:     }
1: 
1:     /**
0:      * Factory method to create a new socket
0:      * 
1:      * @param remoteLocation
0:      * @param localLocation
0:      * @return
1:      * @throws IOException
1:      * @throws IOException
1:      * @throws UnknownHostException
1:      */
0:     protected Socket createSocket(URI remoteLocation, URI localLocation) throws IOException, UnknownHostException {
0:         String host = resolveHostName(remoteLocation.getHost());
0:         SocketAddress sockAddress = new InetSocketAddress(host, remoteLocation.getPort());
0:         SocketAddress localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());
0:         Socket sock = new Socket();
0:         initialiseSocket(sock);
0:         sock.bind(localAddress);
0:         sock.connect(sockAddress);
0:         return sock;
1:     }
1: 
1:     protected String resolveHostName(String host) throws UnknownHostException {
0:         String localName = InetAddress.getLocalHost().getHostName();
0:         if (localName != null && isUseLocalHost()) {
0:             if (localName.equals(host)) {
1:                 return "localhost";
1:             }
1:         }
1:         return host;
1:     }
1: 
1:     /**
1:      * Configures the socket for use
0:      * 
0:      * @param sock
0:      * @throws SocketException
1:      */
0:     protected void initialiseSocket(Socket sock) throws SocketException {
0:         try {
0:             sock.setReceiveBufferSize(socketBufferSize);
0:             sock.setSendBufferSize(socketBufferSize);
1:         }
0:         catch (SocketException se) {
0:             log.warn("Cannot set socket buffer size = " + socketBufferSize, se);
1:         }
1:         sock.setSoTimeout(soTimeout);
1:     }
1: 
0:     protected void initializeStreams() throws IOException {
0:         TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), 4096);
1:         this.dataIn = new DataInputStream(buffIn);
0:         TcpBufferedOutputStream buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), 8192);
0:         this.dataOut = new DataOutputStream(buffOut);
1:     }
1: 
0:     protected void doStop(ServiceStopper stopper) throws Exception {
0:         closeStreams();
1:         if (socket != null) {
1:             socket.close();
1:         }
1:     }
1: 
1:     protected void closeStreams() throws IOException {
1:         if (dataOut != null) {
1:             dataOut.close();
1:         }
1:         if (dataIn != null) {
1:             dataIn.close();
1:         }
1:     }
1: 
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:78265ea
/////////////////////////////////////////////////////////////////////////
1:     protected volatile int receiveCounter;
commit:28e9cd7
/////////////////////////////////////////////////////////////////////////
0: gxfdgvdfg * Licensed to the Apache Software Foundation (ASF) under one or more
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
1:                 //closing the socket can hang also
1: 
1:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("Caught exception closing socket", e);
1:                             }
0:                         } finally {
1: 
0:                 try {
1:                     latch.await(1,TimeUnit.SECONDS);
0:                 } catch (InterruptedException e) {
1:                     Thread.currentThread().interrupt();
1:                 }
1: 
1:             } else {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:0885c60
/////////////////////////////////////////////////////////////////////////
0: import java.net.InetAddress;
0: import java.net.InetSocketAddress;
0: import java.net.Socket;
0: import java.net.SocketAddress;
0: import java.net.SocketException;
0: import java.net.SocketTimeoutException;
0: import java.net.URI;
0: import java.net.UnknownHostException;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:6c73104
/////////////////////////////////////////////////////////////////////////
1:         return "" + (socket.isConnected() ? "tcp://" + socket.getInetAddress() + ":" + socket.getPort() + "@" + socket.getLocalPort()
commit:dad86e6
/////////////////////////////////////////////////////////////////////////
0:             IOException ioe=new IOException("Unexpected error occured: " + e);
commit:52d5189
/////////////////////////////////////////////////////////////////////////
1:     private int soLinger = Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
1:      * Enable/disable soLinger
1:      * @param soLinger enabled if > -1, disabled if == -1, system default otherwise
/////////////////////////////////////////////////////////////////////////
1:         if (soLinger > -1) {
1:         } else if (soLinger == -1) {
1:             sock.setSoLinger(false, 0);
commit:0aa5c2a
/////////////////////////////////////////////////////////////////////////
0:     private int soLinger = -1;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Enable soLinger with the specified soLinger
0:      * @param soLinger enabled if > -1
1:      */
1:     public void setSoLinger(int soLinger) {
1:         this.soLinger = soLinger;
1:     }
1: 
1:     public int getSoLinger() {
1:         return soLinger;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (soLinger != -1) {
1:             sock.setSoLinger(true, soLinger);
1:         }
commit:e10f75c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 DefaultThreadPools.getDefaultTaskRunnerFactory().execute(new Runnable() {
commit:1355cf5
/////////////////////////////////////////////////////////////////////////
0: 
0: import static org.apache.activemq.thread.DefaultThreadPools.getDefaultTaskRunnerFactory;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 getDefaultTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
commit:670a9c4
/////////////////////////////////////////////////////////////////////////
1:         if (isUseLocalHost()) {
0:             String localName = InetAddress.getLocalHost().getHostName();
1:             if (localName != null && localName.equals(host)) {
commit:05101de
/////////////////////////////////////////////////////////////////////////
1:     protected boolean useLocalHost = false;
commit:2189100
/////////////////////////////////////////////////////////////////////////
1:     protected TimeStampStream buffOut = null;
/////////////////////////////////////////////////////////////////////////
1:         TcpBufferedOutputStream outputStream = new TcpBufferedOutputStream(socket.getOutputStream(), ioBufferSize);
1:         this.dataOut = new DataOutputStream(outputStream);
1:         this.buffOut = outputStream;
/////////////////////////////////////////////////////////////////////////
1:         } else if ( target == TimeStampStream.class) {
commit:956c3e0
/////////////////////////////////////////////////////////////////////////
0:         return "" + (socket.isConnected() ? "tcp://" + socket.getInetAddress() + ":" + socket.getPort()
1:                 : (localLocation != null ? localLocation : remoteLocation)) ;
commit:f561d6b
/////////////////////////////////////////////////////////////////////////
0:     protected TcpBufferedOutputStream buffOut = null;
/////////////////////////////////////////////////////////////////////////
0:         buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), ioBufferSize);
/////////////////////////////////////////////////////////////////////////
0:         } else if ( target == TcpBufferedOutputStream.class) {
1:             return target.cast(buffOut);
0:     
commit:8761189
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("TCP consumer thread for " + this + " starting");
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:036f2a8
/////////////////////////////////////////////////////////////////////////
0: 
1:     public WireFormat getWireFormat() {
1:         return wireFormat;
1:     }
commit:1acc98b
/////////////////////////////////////////////////////////////////////////
0: import java.net.*;
/////////////////////////////////////////////////////////////////////////
1:             SocketAddress address = socket.getRemoteSocketAddress();
1:             if (address instanceof InetSocketAddress) {
1:                 return "tcp://" + ((InetSocketAddress)address).getAddress().getHostAddress() + ":" + ((InetSocketAddress)address).getPort();
1:             } else {
1:                 return "" + socket.getRemoteSocketAddress();
1:             }
commit:e5e99d7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d0b43c1
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected int maxFrameSize = 104857600; //100MB
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:     public int getMaxFrameSize() {
0:         return maxFrameSize;
1:     }
0: 
0:     public void setMaxFrameSize(int maxFrameSize) {
0:         this.maxFrameSize = maxFrameSize;
1:     }
0: 
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TcpTransport.class);
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:8a1f994
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.InetAddressUtil;
/////////////////////////////////////////////////////////////////////////
1:             String localName = InetAddressUtil.getLocalHostName();
author:Robert Davies
-------------------------------------------------------------------------------
commit:9740fb2
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:         int resultTrafficClass = sock.getTrafficClass();
1:         if (this.trafficClass != resultTrafficClass) {
1:             // In the case where the user has specified the ECN bits (e.g. in
1:             // Type of Service) but the system won't allow the ECN bits to be
1:             // set or in the case where setting the traffic class failed for
1:             // other reasons, emit a warning.
1:             if ((this.trafficClass >> 2) == (resultTrafficClass >> 2)
1:                     && (this.trafficClass & 3) != (resultTrafficClass & 3)) {
1:                 LOG.warn("Attempted to set the Traffic Class to "
1:                     + this.trafficClass + " but the result Traffic Class was "
1:                     + resultTrafficClass + ". Please check that your system "
1:                     + "allows you to set the ECN bits (the first two bits).");
1:             } else {
1:                 LOG.warn("Attempted to set the Traffic Class to "
1:                     + this.trafficClass + " but the result Traffic Class was "
1:                     + resultTrafficClass + ". Please check that your system "
1:                          + "supports java.net.setTrafficClass.");
1:             }
1:             return false;
1:         }
commit:dfeecb4
/////////////////////////////////////////////////////////////////////////
1:      * The Traffic Class to be set on the socket.
1:     protected int trafficClass = 0;
1:      * Keeps track of attempts to set the Traffic Class on the socket.
1:      * Prevents setting both the Differentiated Services and Type of Service
1:      * transport options at the same time, since they share the same spot in
1:      * the TCP/IP packet headers.
1:      */
1:     protected boolean diffServChosen = false;
1:     protected boolean typeOfServiceChosen = false;
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         return Integer.toString(this.trafficClass);
1:         this.trafficClass = QualityOfServiceUtils.getDSCP(diffServ);
1:         this.diffServChosen = true;
1:     public int getTypeOfService() {
1:         // This is the value requested by the user by setting the Tcp Transport
1:         // options. If the socket hasn't been created, then this value may not
1:         // reflect the value returned by Socket.getTrafficClass().
1:         return this.trafficClass;
1:     }
0:   
1:     public void setTypeOfService(int typeOfService) {
1:         this.trafficClass = QualityOfServiceUtils.getToS(typeOfService);
1:         this.typeOfServiceChosen = true;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @throws SocketException, IllegalArgumentException if setting the options
1:      *         on the socket failed.
0:     protected void initialiseSocket(Socket sock) throws SocketException,
1:             IllegalArgumentException {
/////////////////////////////////////////////////////////////////////////
1:         if (!this.trafficClassSet) {
1:             this.trafficClassSet = setTrafficClass(sock);
/////////////////////////////////////////////////////////////////////////
1:         this.trafficClassSet = setTrafficClass(socket);
/////////////////////////////////////////////////////////////////////////
0: 
1:      * @param sock The socket on which to set the Traffic Class.
1:      * @throws SocketException if the system does not support setting the
1:      *         Traffic Class.
1:      * @throws IllegalArgumentException if both the Differentiated Services and
1:      *         Type of Services transport options have been set on the same
1:      *         connection.
1:     private boolean setTrafficClass(Socket sock) throws SocketException,
0:             IllegalArgumentException {
1:         if (sock == null
1:             || (!this.diffServChosen && !this.typeOfServiceChosen)) {
1:         if (this.diffServChosen && this.typeOfServiceChosen) {
1:             throw new IllegalArgumentException("Cannot set both the "
1:                 + " Differentiated Services and Type of Services transport "
1:                 + " options on the same connection.");
1:         }
1:         sock.setTrafficClass(this.trafficClass);
1:         // Reset the guards that prevent both the Differentiated Services
1:         // option and the Type of Service option from being set on the same
1:         // connection.
1:         this.diffServChosen = false;
1:         this.typeOfServiceChosen = false;
1:         return true;
commit:54fa83d
/////////////////////////////////////////////////////////////////////////
0:      * Differentiated Services Code Point. Determines the Traffic Class to be
0:      * set on the socket.
1:      */
0:     protected int dscp = 0;
1:     /**
0:      * Keeps track of attempts to set the Traffic Class.
1:      */
1:     private boolean trafficClassSet = false;
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     public String getDiffServ() {
1:         // This is the value requested by the user by setting the Tcp Transport
1:         // options. If the socket hasn't been created, then this value may not
1:         // reflect the value returned by Socket.getTrafficClass().
0:         return Integer.toString(dscp);
1:     }
0: 
1:     public void setDiffServ(String diffServ) throws IllegalArgumentException {
0:         this.dscp = QualityOfServiceUtils.getDSCP(diffServ);
1:     }
0: 
0:     // TODO: Add methods for setting and getting a ToS value.
/////////////////////////////////////////////////////////////////////////
0:         if (!trafficClassSet) {
0:             trafficClassSet = setTrafficClass(sock);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // Set the traffic class before the socket is connected when possible so
1:         // that the connection packets are given the correct traffic class.
0:         trafficClassSet = setTrafficClass(socket);
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return Whether or not the Traffic Class was set on the given socket.
1:      */
0:     private boolean setTrafficClass(Socket sock) {
0:         // TODO: Add in ToS support.
0: 
0:         if (sock == null)
1:             return false;
0: 
0:         boolean success = false;
0: 
0:         try {
0:             sock.setTrafficClass(this.dscp);
0:             success = true;
0:         } catch (SocketException e) {
0:             // The system does not support setting the traffic class through
0:             // setTrafficClass.
0:             LOG.error("Unable to set the traffic class: " + e);
1:         }
0: 
0:         return success;
1:     }
commit:f392884
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e233801
/////////////////////////////////////////////////////////////////////////
1:         } catch (Throwable e){
0:             stoppedLatch.get().countDown();
0:             IOException ioe=new IOException("Unexpected error occured");
1:             ioe.initCause(e);
1:             onException(ioe);
1:         }finally {
commit:5a368ca
/////////////////////////////////////////////////////////////////////////
commit:157d630
/////////////////////////////////////////////////////////////////////////
1:     protected boolean closeAsync=true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the closeAsync
1:      */
1:     public boolean isCloseAsync() {
1:         return closeAsync;
1:     }
0: 
1:     /**
1:      * @param closeAsync the closeAsync to set
1:      */
1:     public void setCloseAsync(boolean closeAsync) {
1:         this.closeAsync = closeAsync;
1:     }
/////////////////////////////////////////////////////////////////////////
1:             if (closeAsync) {
0:                 //closing the socket can hang also 
1:                 final CountDownLatch latch = new CountDownLatch(1);
0:                 SOCKET_CLOSE.execute(new Runnable() {
0:     
0:                     public void run() {
0:                         try {
0:                             socket.shutdownInput();
0:                             socket.shutdownOutput();
1:                             socket.close();
1:                         } catch (IOException e) {
0:                             LOG.debug("Caught exception closing socket",e);
0:                         }finally {
1:                             latch.countDown();
1:                         }
1:                     }
0:                     
1:                 });
0:                 latch.await(1,TimeUnit.SECONDS);
0:             }else {
0:                 try {
1:                     socket.close();
1:                 } catch (IOException e) {
0:                     LOG.debug("Caught exception closing socket",e);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
0:                 thread.setPriority(Thread.MAX_PRIORITY);
commit:8228663
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.SynchronousQueue;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:     private static final ThreadPoolExecutor SOCKET_CLOSE;
/////////////////////////////////////////////////////////////////////////
0:             //closing the socket can hang also 
0:             final CountDownLatch latch = new CountDownLatch(1);
0:             SOCKET_CLOSE.execute(new Runnable() {
0: 
0:                 public void run() {
0:                     try {
0:                         socket.close();
0:                     } catch (IOException e) {
0:                         LOG.debug("Caught exception closing socket",e);
0:                     }finally {
0:                         latch.countDown();
0:                     }
0:                 }
0:                 
0:             });
0:             latch.await(1,TimeUnit.SECONDS);
0:            
/////////////////////////////////////////////////////////////////////////
1:             countDownLatch.await(1,TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:     static {
0:         SOCKET_CLOSE =   new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactory() {
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "TcpSocketClose: "+runnable);
0:                 thread.setDaemon(true);
0:                 return thread;
0:             }
0:         });
0:     }
commit:fd2c95e
/////////////////////////////////////////////////////////////////////////
1:     private Thread runnerThread;
/////////////////////////////////////////////////////////////////////////
1:         this.runnerThread=Thread.currentThread();
/////////////////////////////////////////////////////////////////////////
1:         if (countDownLatch != null && Thread.currentThread() != this.runnerThread) {
commit:19a83ae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
commit:df6b542
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportLoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * trace=true -> the Transport stack where this TcpTransport
1:      * object will be, will have a TransportLogger layer
1:      * trace=false -> the Transport stack where this TcpTransport
1:      * object will be, will NOT have a TransportLogger layer, and therefore
1:      * will never be able to print logging messages.
1:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:      */
1:     protected boolean trace = false;
1:     /**
0:      * Name of the LogWriter implementation to use.
0:      * Names are mapped to classes in the resources/META-INF/services/org/apache/activemq/transport/logwriters directory.
1:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:      */
0:     protected String logWriterName = TransportLoggerFactory.defaultLogWriterName;
1:     /**
1:      * Specifies if the TransportLogger will be manageable by JMX or not.
1:      * Also, as long as there is at least 1 TransportLogger which is manageable,
1:      * a TransportLoggerControl MBean will me created.
1:      */
1:     protected boolean dynamicManagement = false;
1:     /**
1:      * startLogging=true -> the TransportLogger object of the Transport stack
1:      * will initially write messages to the log.
1:      * startLogging=false -> the TransportLogger object of the Transport stack
1:      * will initially NOT write messages to the log.
1:      * This parameter only has an effect if trace == true.
1:      * This parameter is most probably set in Connection or TransportConnector URIs.
1:      */
1:     protected boolean startLogging = true;
1:     /**
1:      * Specifies the port that will be used by the JMX server to manage
1:      * the TransportLoggers.
1:      * This should only be set in an URI by a client (producer or consumer) since
1:      * a broker will already create a JMX server.
1:      * It is useful for people who test a broker and clients in the same machine
1:      * and want to control both via JMX; a different port will be needed.
1:      */
1:     protected int jmxPort = 1099;
/////////////////////////////////////////////////////////////////////////
0:     public String getLogWriterName() {
0:         return logWriterName;
0:     }
0: 
0: 
0:     public void setLogWriterName(String logFormat) {
0:         this.logWriterName = logFormat;
0:     }
0: 
0: 
1:     public boolean isDynamicManagement() {
1:         return dynamicManagement;
0:     }
0: 
0: 
1:     public void setDynamicManagement(boolean useJmx) {
1:         this.dynamicManagement = useJmx;
0:     }
0: 
1:     public boolean isStartLogging() {
1:         return startLogging;
0:     }
0: 
0: 
1:     public void setStartLogging(boolean startLogging) {
1:         this.startLogging = startLogging;
0:     }
0: 
0: 
1:     public int getJmxPort() {
1:         return jmxPort;
0:     }
0: 
0: 
1:     public void setJmxPort(int jmxPort) {
1:         this.jmxPort = jmxPort;
0:     }
0: 
0: 
commit:166a04b
/////////////////////////////////////////////////////////////////////////
1:     protected int socketBufferSize = 64 * 1024;
1:     protected int ioBufferSize = 8 * 1024;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the ioBufferSize
1:      */
0:     public int getIoBufferSize(){
1:         return this.ioBufferSize;
0:     }
0: 
1:     /**
1:      * @param ioBufferSize the ioBufferSize to set
1:      */
0:     public void setIoBufferSize(int ioBufferSize){
0:         this.ioBufferSize=ioBufferSize;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), ioBufferSize);
0:         TcpBufferedOutputStream buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), ioBufferSize);
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     
0:   
commit:c852f07
/////////////////////////////////////////////////////////////////////////
0:     private int soTimeout = 0;
0:     private int socketBufferSize = 128 * 1024;
/////////////////////////////////////////////////////////////////////////
0:         TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), 8*1024);
0:         TcpBufferedOutputStream buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), 16*1024);
author:James Strachan
-------------------------------------------------------------------------------
commit:0aac7f5
/////////////////////////////////////////////////////////////////////////
0:         if (log.isDebugEnabled()) {
0:             log.debug("Stopping transport " + this);
0:         }
0: 
commit:e73f5aa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.Service;
0: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportThreadSupport;
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.wireformat.WireFormat;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import javax.net.SocketFactory;
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0:     private Map socketOptions;
0:      *
1:      * @param socketFactory
0:      * @param localLocation  -
0:      *                       e.g. local InetAddress and local port
1:         this.socketFactory = socketFactory;
0:         try {
0:             this.socket = socketFactory.createSocket();
0:         }
0:         catch (SocketException e) {
1:             this.socket = null;
0:         }
0:         this.remoteLocation = remoteLocation;
0:         this.localLocation = localLocation;
0:      *
/////////////////////////////////////////////////////////////////////////
0:         this.remoteLocation = null;
0:         this.localLocation = null;
/////////////////////////////////////////////////////////////////////////
0:         return "tcp://" + socket.getInetAddress() + ":" + socket.getPort();
/////////////////////////////////////////////////////////////////////////
0:                 Object command = readCommand();
/////////////////////////////////////////////////////////////////////////
1:     protected Object readCommand() throws IOException {
1:         return wireFormat.unmarshal(dataIn);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
1:         if (socketOptions != null) {
0:             IntrospectionSupport.setProperties(socket, socketOptions);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected void connect() throws Exception {
1:         if (socket == null && socketFactory == null) {
1:             throw new IllegalStateException("Cannot connect if the socket or socketFactory have not been set");
0:         }
0: 
1:         InetSocketAddress localAddress = null;
1:         InetSocketAddress remoteAddress = null;
0: 
1:         if (localLocation != null) {
0:             localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());
0:         }
0: 
1:         if (remoteLocation != null) {
0:             String host = resolveHostName(remoteLocation.getHost());
0:             remoteAddress = new InetSocketAddress(host, remoteLocation.getPort());
0:         }
0: 
1:         if (socket != null) {
0: 
1:             if (localAddress != null) {
0:                 socket.bind(localAddress);
0:             }
0: 
1:             // If it's a server accepted socket.. we don't need to connect it
1:             // to a remote address.
0:             if (remoteAddress != null) {
1:                 if (connectionTimeout >= 0) {
0:                     socket.connect(remoteAddress, connectionTimeout);
0:                 }
0:                 else {
0:                     socket.connect(remoteAddress);
0:                 }
0:             }
0: 
0:         }
0:         else {
1:             // For SSL sockets.. you can't create an unconnected socket :(
1:             // This means the timout option are not supported either.
1:             if (localAddress != null) {
0:                 socket = socketFactory.createSocket(remoteAddress.getAddress(), remoteAddress.getPort(), localAddress.getAddress(), localAddress.getPort());
0:             }
0:             else {
1:                 socket = socketFactory.createSocket(remoteAddress.getAddress(), remoteAddress.getPort());
0:             }
0:         }
0: 
0:         initialiseSocket(socket);
0:         initializeStreams();
0:     }
0: 
0:     protected void doStop(ServiceStopper stopper) throws Exception {
1:         // Closing the streams flush the sockets before closing.. if the socket
1:         // is hung.. then this hangs the close.
0:         }
1:     protected void initializeStreams() throws Exception {
0:         TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), 8 * 1024);
0:         TcpBufferedOutputStream buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), 16 * 1024);
/////////////////////////////////////////////////////////////////////////
0:         this.socketOptions = new HashMap(socketOptions);
1:         if (socket != null) {
0:             return "" + socket.getRemoteSocketAddress();
0:         }
1:         return null;
commit:d21381d
/////////////////////////////////////////////////////////////////////////
1:     private Boolean tcpNoDelay;
/////////////////////////////////////////////////////////////////////////
1:     public Boolean getTcpNoDelay() {
1:         return tcpNoDelay;
0:     }
0: 
0:     /**
1:      * Enable/disable the TCP_NODELAY option on the socket
0:      */
1:     public void setTcpNoDelay(Boolean tcpNoDelay) {
1:         this.tcpNoDelay = tcpNoDelay;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         if (tcpNoDelay != null) {
1:             sock.setTcpNoDelay(tcpNoDelay.booleanValue());
0:         }
commit:d4a8347
/////////////////////////////////////////////////////////////////////////
1:     private Boolean keepAlive;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public Boolean getKeepAlive() {
1:         return keepAlive;
0:     }
0: 
0:     /**
1:      * Enable/disable TCP KEEP_ALIVE mode
0:      */
1:     public void setKeepAlive(Boolean keepAlive) {
1:         this.keepAlive = keepAlive;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         
1:         if (keepAlive != null) {
1:             sock.setKeepAlive(keepAlive.booleanValue());
0:         }
commit:0f1dcce
/////////////////////////////////////////////////////////////////////////
0: 
1: 	public String getRemoteAddress() {
0: 		if(socket != null){
0: 			return "" + socket.getRemoteSocketAddress();
0: 		}
0: 		return null;
0: 	}
commit:2440474
/////////////////////////////////////////////////////////////////////////
0: import javax.net.SocketFactory;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public TcpTransport(WireFormat wireFormat, SocketFactory socketFactory, URI remoteLocation) throws UnknownHostException, IOException {
0:         this.socket = createSocket(socketFactory, remoteLocation);
0:      * @param socketFactory 
0:     public TcpTransport(WireFormat wireFormat, SocketFactory socketFactory, URI remoteLocation, URI localLocation) throws UnknownHostException, IOException {
0:         this.socket = createSocket(socketFactory, remoteLocation, localLocation);
/////////////////////////////////////////////////////////////////////////
0:     protected Socket createSocket(SocketFactory socketFactory, URI remoteLocation) throws UnknownHostException, IOException {
0:         Socket sock = socketFactory.createSocket();
/////////////////////////////////////////////////////////////////////////
0:     protected Socket createSocket(SocketFactory socketFactory, URI remoteLocation, URI localLocation) throws IOException, UnknownHostException {
0:         Socket sock = socketFactory.createSocket();
commit:436fe42
/////////////////////////////////////////////////////////////////////////
0:         while (!isStopped()) {
commit:9c2185b
/////////////////////////////////////////////////////////////////////////
0:     private int connectionTimeout = 30000;
commit:c2123e3
/////////////////////////////////////////////////////////////////////////
0:     private int connectionTimeout = -1;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:     public int getConnectionTimeout() {
1:         return connectionTimeout;
0:     }
0: 
0:     /**
1:      * Sets the timeout used to connect to the socket
0:      */
1:     public void setConnectionTimeout(int connectionTimeout) {
1:         this.connectionTimeout = connectionTimeout;
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
1:     protected void doStart() throws Exception {
0:         initialiseSocket(socket);
0:         if (socketAddress != null) {
0:             if (connectionTimeout >= 0) {
0:                 socket.connect(socketAddress, connectionTimeout);
0:             }
0:             else {
0:                 socket.connect(socketAddress);
0:             }
0:         }
0:         initializeStreams();
0:         super.doStart();
/////////////////////////////////////////////////////////////////////////
0:     protected void initializeStreams() throws IOException {
0:         TcpBufferedInputStream buffIn = new TcpBufferedInputStream(socket.getInputStream(), 4096);
0:         this.dataIn = new DataInputStream(buffIn);
0:         TcpBufferedOutputStream buffOut = new TcpBufferedOutputStream(socket.getOutputStream(), 8192);
0:         this.dataOut = new DataOutputStream(buffOut);
0:     }
0: 
commit:3d96abc
/////////////////////////////////////////////////////////////////////////
0:         checkStarted(command);
commit:99c1a67
/////////////////////////////////////////////////////////////////////////
0:     private InetSocketAddress socketAddress;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
1:     public int getSocketBufferSize() {
1:         return socketBufferSize;
0:     }
0: 
0:     /**
1:      * Sets the buffer size to use on the socket
0:      */
1:     public void setSocketBufferSize(int socketBufferSize) {
1:         this.socketBufferSize = socketBufferSize;
0:     }
0: 
1:     public int getSoTimeout() {
1:         return soTimeout;
0:     }
0: 
0:     /**
1:      * Sets the socket timeout
0:      */
1:     public void setSoTimeout(int soTimeout) {
1:         this.soTimeout = soTimeout;
0:     }
0: 
0:     public long getMaxInactivityDuration() {
0:         return maxInactivityDuration;
0:     }
0: 
0:     /**
0:      * Sets the maximum inactivity duration
0:      */
0:     public void setMaxInactivityDuration(long maxInactivityDuration) {
0:         this.maxInactivityDuration = maxInactivityDuration;
0:     }
0: 
0:     protected void doStart() throws Exception {
0:         initialiseSocket(socket);
0:         if (socketAddress != null) {
0:             socket.connect(socketAddress);
0:         }
0:         initializeStreams();
0:         super.doStart();
0:     }
/////////////////////////////////////////////////////////////////////////
0:         socketAddress = new InetSocketAddress(host, remoteLocation.getPort());
/////////////////////////////////////////////////////////////////////////
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:635bc2b
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     protected SocketFactory socketFactory;
0: 
0:     private Map socketOptions;    
/////////////////////////////////////////////////////////////////////////
0: 	this.socketFactory = socketFactory;
0: 	try {
0: 		this.socket = socketFactory.createSocket();
0: 	} catch (SocketException e) {
0: 		this.socket = null;
0: 	}
0: 	this.remoteLocation = remoteLocation;
0: 	this.localLocation = localLocation;
/////////////////////////////////////////////////////////////////////////
0:     	if( socketOptions != null ) {
0:     		IntrospectionSupport.setProperties(socket, socketOptions);
0:     	}
0:     	
/////////////////////////////////////////////////////////////////////////
0:      protected void connect() throws SocketException, IOException {
0: 	if( socket == null && socketFactory == null ) {
0: 		throw new IllegalStateException("Cannot connect if the socket or socketFactory have not been set");
0: 	}
0: 		
0: 	InetSocketAddress localAddress=null;
0: 	InetSocketAddress remoteAddress=null;
0:            localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());
0:         }  
0:                       
0: 	if( remoteLocation!=null ) {
0: 		String host = resolveHostName(remoteLocation.getHost());
0: 	        remoteAddress = new InetSocketAddress(host, remoteLocation.getPort());
0: 	}
0: 	
0:    	if( socket!=null ) {
0:     		
0:     		if( localAddress!=null )
0:     			socket.bind(localAddress);
0:     		
0:     		// If it's a server accepted socket.. we don't need to connect it 
0:     		// to a remote address.
0:     		if ( remoteAddress!=null ) {
0: 	            if (connectionTimeout >= 0) {
0: 	                socket.connect(remoteAddress, connectionTimeout);
0: 	            } else {
0: 	                socket.connect(remoteAddress);
0: 	            }
0:     		}
0:             
0:     	} else {
0:     		// For SSL sockets.. you can't create an unconnected socket :(
0:     		// This means the timout option are not supported either.
0:     		if( localAddress!=null ) {
0:             	socket = socketFactory.createSocket(remoteAddress.getAddress(), remoteAddress.getPort(), localAddress.getAddress(), localAddress.getPort());
0:     		} else {
0:             	socket = socketFactory.createSocket(remoteAddress.getAddress(), remoteAddress.getPort());
0:     		}
0:     	}
0: 		
0: 	initialiseSocket(socket);        
/////////////////////////////////////////////////////////////////////////
0:     	this.socketOptions = new HashMap(socketOptions);
0:     public String getRemoteAddress() {
0: 	if(socket != null){
0: 		return "" + socket.getRemoteSocketAddress();
0: 	return null;
0:     }
commit:a86a587
/////////////////////////////////////////////////////////////////////////
0:     protected void doStop(ServiceStopper stopper) throws Exception {   
0:     	// Closing the streams flush the sockets before closing.. if the socket
0:     	// is hung.. then this hangs the close.
1:         // closeStreams();
0:         }    	
============================================================================