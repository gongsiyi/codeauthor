1:a0af351: /**
1:a0af351:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:a0af351:  * contributor license agreements.  See the NOTICE file distributed with
1:a0af351:  * this work for additional information regarding copyright ownership.
1:a0af351:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:a0af351:  * (the "License"); you may not use this file except in compliance with
1:a0af351:  * the License.  You may obtain a copy of the License at
1:a0af351:  *
1:a0af351:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a0af351:  *
1:a0af351:  * Unless required by applicable law or agreed to in writing, software
1:a0af351:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a0af351:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a0af351:  * See the License for the specific language governing permissions and
1:a0af351:  * limitations under the License.
1:a0af351:  */
1:a0af351: package org.apache.activemq.transport.discovery.http;
7:a0af351: 
1:a0af351: import java.io.IOException;
1:a0af351: import java.util.HashMap;
1:a0af351: import java.util.HashSet;
1:a0af351: import java.util.Map;
1:a0af351: import java.util.Scanner;
1:a0af351: import java.util.Set;
1:a0af351: import java.util.concurrent.atomic.AtomicBoolean;
1:a0af351: import java.util.concurrent.atomic.AtomicInteger;
1:a0af351: import java.util.concurrent.atomic.AtomicReference;
1:a0af351: 
1:a0af351: import org.apache.activemq.Service;
1:a0af351: import org.apache.activemq.command.DiscoveryEvent;
1:a0af351: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1:a0af351: import org.apache.activemq.transport.discovery.DiscoveryListener;
1:a0af351: import org.apache.activemq.util.IntrospectionSupport;
1:272b846: import org.apache.activemq.util.Suspendable;
1:082fdc5: import org.apache.http.client.HttpClient;
1:082fdc5: import org.apache.http.client.ResponseHandler;
1:082fdc5: import org.apache.http.client.methods.HttpDelete;
1:082fdc5: import org.apache.http.client.methods.HttpGet;
1:082fdc5: import org.apache.http.client.methods.HttpPut;
1:082fdc5: import org.apache.http.impl.client.BasicResponseHandler;
1:082fdc5: import org.apache.http.impl.client.DefaultHttpClient;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:a0af351: 
1:272b846: public class HTTPDiscoveryAgent implements DiscoveryAgent, Suspendable {
1:272b846: 
1:272b846:     static enum UpdateState {
1:272b846:         SUSPENDED,
1:272b846:         RESUMING,
1:272b846:         RESUMED
1:272b846:     }
1:a0af351: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(HTTPDiscoveryAgent.class);
1:a0af351: 
1:a0af351:     private String registryURL = "http://localhost:8080/discovery-registry/default";
1:082fdc5:     private HttpClient httpClient = new DefaultHttpClient();
1:082fdc5:     private AtomicBoolean running = new AtomicBoolean();
1:a0af351:     private final AtomicReference<DiscoveryListener> discoveryListener = new AtomicReference<DiscoveryListener>();
1:a0af351:     private final HashSet<String> registeredServices = new HashSet<String>();
1:a0af351:     private final HashMap<String, SimpleDiscoveryEvent> discoveredServices = new HashMap<String, SimpleDiscoveryEvent>();
1:a0af351:     private Thread thread;
1:082fdc5:     private long updateInterval = 1000 * 10;
1:082fdc5:     @SuppressWarnings("unused")
1:a0af351:     private String brokerName;
1:082fdc5:     private boolean startEmbeddRegistry = false;
1:a0af351:     private Service jetty;
1:082fdc5:     private AtomicInteger startCounter = new AtomicInteger(0);
1:a0af351: 
1:a0af351:     private long initialReconnectDelay = 1000;
1:a0af351:     private long maxReconnectDelay = 1000 * 30;
1:a0af351:     private long backOffMultiplier = 2;
1:082fdc5:     private boolean useExponentialBackOff = true;
1:a0af351:     private int maxReconnectAttempts;
1:a0af351:     private final Object sleepMutex = new Object();
1:272b846:     private final Object updateMutex = new Object();
1:272b846:     private UpdateState updateState = UpdateState.RESUMED;
1:a0af351:     private long minConnectTime = 5000;
1:a0af351: 
1:a0af351:     class SimpleDiscoveryEvent extends DiscoveryEvent {
1:a0af351: 
1:a0af351:         private int connectFailures;
1:a0af351:         private long reconnectDelay = initialReconnectDelay;
1:a0af351:         private long connectTime = System.currentTimeMillis();
1:a0af351:         private AtomicBoolean failed = new AtomicBoolean(false);
1:a0af351:         private AtomicBoolean removed = new AtomicBoolean(false);
1:a0af351: 
1:a0af351:         public SimpleDiscoveryEvent(String service) {
1:a0af351:             super(service);
2:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:a0af351:     public String getGroup() {
2:a0af351:         return null;
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void registerService(String service) throws IOException {
1:082fdc5:         synchronized (registeredServices) {
1:a0af351:             registeredServices.add(service);
1:a0af351:         }
1:a0af351:         doRegister(service);
1:a0af351:     }
1:a0af351: 
1:a0af351:     synchronized private void doRegister(String service) {
1:a0af351:         String url = registryURL;
1:a0af351:         try {
1:082fdc5:             HttpPut method = new HttpPut(url);
1:082fdc5:             method.addHeader("service", service);
1:082fdc5:             ResponseHandler<String> handler = new BasicResponseHandler();
1:082fdc5:             String responseBody = httpClient.execute(method, handler);
1:082fdc5:             LOG.debug("PUT to " + url + " got a " + responseBody);
1:a0af351:         } catch (Exception e) {
1:082fdc5:             LOG.debug("PUT to " + url + " failed with: " + e);
1:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:082fdc5:     @SuppressWarnings("unused")
1:a0af351:     synchronized private void doUnRegister(String service) {
1:a0af351:         String url = registryURL;
1:a0af351:         try {
1:082fdc5:             HttpDelete method = new HttpDelete(url);
1:082fdc5:             method.addHeader("service", service);
1:082fdc5:             ResponseHandler<String> handler = new BasicResponseHandler();
1:082fdc5:             String responseBody = httpClient.execute(method, handler);
1:082fdc5:             LOG.debug("DELETE to " + url + " got a " + responseBody);
1:a0af351:         } catch (Exception e) {
1:082fdc5:             LOG.debug("DELETE to " + url + " failed with: " + e);
1:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:a0af351:     synchronized private Set<String> doLookup(long freshness) {
1:082fdc5:         String url = registryURL + "?freshness=" + freshness;
1:a0af351:         try {
1:082fdc5:             HttpGet method = new HttpGet(url);
1:082fdc5:             ResponseHandler<String> handler = new BasicResponseHandler();
1:082fdc5:             String response = httpClient.execute(method, handler);
1:082fdc5:             LOG.debug("GET to " + url + " got a " + response);
1:a0af351:             Set<String> rc = new HashSet<String>();
1:082fdc5:             Scanner scanner = new Scanner(response);
1:082fdc5:             while (scanner.hasNextLine()) {
1:a0af351:                 String service = scanner.nextLine();
1:082fdc5:                 if (service.trim().length() != 0) {
1:a0af351:                     rc.add(service);
1:a0af351:                 }
1:a0af351:             }
1:ffa396c:             scanner.close();
1:a0af351:             return rc;
1:a0af351:         } catch (Exception e) {
1:082fdc5:             LOG.debug("GET to " + url + " failed with: " + e);
1:a0af351:             return null;
1:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void serviceFailed(DiscoveryEvent devent) throws IOException {
1:a0af351: 
1:082fdc5:         final SimpleDiscoveryEvent event = (SimpleDiscoveryEvent) devent;
1:a0af351:         if (event.failed.compareAndSet(false, true)) {
1:a0af351:             discoveryListener.get().onServiceRemove(event);
1:082fdc5:             if (!event.removed.get()) {
1:a0af351:                 // Setup a thread to re-raise the event...
1:a0af351:                 Thread thread = new Thread() {
1:a0af351:                     public void run() {
1:a0af351: 
1:082fdc5:                         // We detect a failed connection attempt because the
1:082fdc5:                         // service
1:a0af351:                         // fails right away.
1:a0af351:                         if (event.connectTime + minConnectTime > System.currentTimeMillis()) {
1:082fdc5:                             LOG.debug("Failure occured soon after the discovery event was generated.  " +
1:082fdc5:                                       "It will be clasified as a connection failure: " + event);
1:a0af351: 
1:a0af351:                             event.connectFailures++;
1:a0af351: 
1:a0af351:                             if (maxReconnectAttempts > 0 && event.connectFailures >= maxReconnectAttempts) {
1:082fdc5:                                 LOG.debug("Reconnect attempts exceeded " + maxReconnectAttempts +
1:082fdc5:                                           " tries.  Reconnecting has been disabled.");
1:a0af351:                                 return;
1:a0af351:                             }
1:a0af351: 
1:a0af351:                             synchronized (sleepMutex) {
1:a0af351:                                 try {
1:a0af351:                                     if (!running.get() || event.removed.get()) {
1:a0af351:                                         return;
1:a0af351:                                     }
1:082fdc5:                                     LOG.debug("Waiting " + event.reconnectDelay +
1:082fdc5:                                               " ms before attepting to reconnect.");
1:a0af351:                                     sleepMutex.wait(event.reconnectDelay);
1:a0af351:                                 } catch (InterruptedException ie) {
1:a0af351:                                     Thread.currentThread().interrupt();
1:a0af351:                                     return;
1:a0af351:                                 }
1:a0af351:                             }
1:a0af351: 
1:a0af351:                             if (!useExponentialBackOff) {
1:a0af351:                                 event.reconnectDelay = initialReconnectDelay;
2:a0af351:                             } else {
1:a0af351:                                 // Exponential increment of reconnect delay.
1:a0af351:                                 event.reconnectDelay *= backOffMultiplier;
1:a0af351:                                 if (event.reconnectDelay > maxReconnectDelay) {
1:a0af351:                                     event.reconnectDelay = maxReconnectDelay;
1:a0af351:                                 }
1:a0af351:                             }
1:a0af351: 
1:a0af351:                         } else {
1:a0af351:                             event.connectFailures = 0;
1:a0af351:                             event.reconnectDelay = initialReconnectDelay;
1:a0af351:                         }
1:a0af351: 
1:a0af351:                         if (!running.get() || event.removed.get()) {
1:a0af351:                             return;
1:a0af351:                         }
1:a0af351: 
1:a0af351:                         event.connectTime = System.currentTimeMillis();
1:a0af351:                         event.failed.set(false);
1:a0af351:                         discoveryListener.get().onServiceAdd(event);
1:a0af351:                     }
1:a0af351:                 };
1:a0af351:                 thread.setDaemon(true);
1:a0af351:                 thread.start();
1:a0af351:             }
1:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void setBrokerName(String brokerName) {
1:a0af351:         this.brokerName = brokerName;
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void setDiscoveryListener(DiscoveryListener discoveryListener) {
1:a0af351:         this.discoveryListener.set(discoveryListener);
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void setGroup(String group) {
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void start() throws Exception {
1:082fdc5:         if (startCounter.addAndGet(1) == 1) {
1:082fdc5:             if (startEmbeddRegistry) {
1:a0af351:                 jetty = createEmbeddedJettyServer();
1:082fdc5:                 Map<String, Object> props = new HashMap<String, Object>();
1:a0af351:                 props.put("agent", this);
1:a0af351:                 IntrospectionSupport.setProperties(jetty, props);
1:a0af351:                 jetty.start();
1:a0af351:             }
1:a0af351: 
1:a0af351:             running.set(true);
1:a0af351:             thread = new Thread("HTTPDiscovery Agent") {
1:a0af351:                 @Override
1:a0af351:                 public void run() {
1:082fdc5:                     while (running.get()) {
1:a0af351:                         try {
1:a0af351:                             update();
1:272b846:                             synchronized (updateMutex) {
1:272b846:                                 do {
1:272b846:                                     if( updateState == UpdateState.RESUMING ) {
1:272b846:                                         updateState = UpdateState.RESUMED;
1:272b846:                                     } else {
1:272b846:                                         updateMutex.wait(updateInterval);
1:272b846:                                     }
1:272b846:                                 } while( updateState==UpdateState.SUSPENDED && running.get());
1:272b846:                             }
1:a0af351:                         } catch (InterruptedException e) {
1:a0af351:                             return;
1:a0af351:                         }
1:a0af351:                     }
1:a0af351:                 }
1:a0af351:             };
1:a0af351:             thread.setDaemon(true);
1:a0af351:             thread.start();
1:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:a0af351:     /**
1:082fdc5:      * Create the EmbeddedJettyServer instance via reflection so that we can
1:082fdc5:      * avoid a hard runtime dependency on jetty.
1:a0af351:      *
1:a0af351:      * @return
1:a0af351:      * @throws Exception
1:a0af351:      */
1:082fdc5:     private Service createEmbeddedJettyServer() throws Exception {
1:082fdc5:         Class<?> clazz = HTTPDiscoveryAgent.class.getClassLoader().loadClass("org.apache.activemq.transport.discovery.http.EmbeddedJettyServer");
1:082fdc5:         return (Service) clazz.newInstance();
1:a0af351:     }
1:a0af351: 
1:a0af351:     private void update() {
1:a0af351:         // Register all our services...
1:082fdc5:         synchronized (registeredServices) {
1:a0af351:             for (String service : registeredServices) {
1:a0af351:                 doRegister(service);
1:a0af351:             }
1:a0af351:         }
1:a0af351: 
1:a0af351:         // Find new registered services...
1:a0af351:         DiscoveryListener discoveryListener = this.discoveryListener.get();
1:082fdc5:         if (discoveryListener != null) {
1:082fdc5:             Set<String> activeServices = doLookup(updateInterval * 3);
1:082fdc5:             // If there is error talking the the central server, then
1:082fdc5:             // activeServices == null
1:082fdc5:             if (activeServices != null) {
1:082fdc5:                 synchronized (discoveredServices) {
1:a0af351: 
1:a0af351:                     HashSet<String> removedServices = new HashSet<String>(discoveredServices.keySet());
1:a0af351:                     removedServices.removeAll(activeServices);
1:a0af351: 
1:a0af351:                     HashSet<String> addedServices = new HashSet<String>(activeServices);
1:a0af351:                     addedServices.removeAll(discoveredServices.keySet());
1:a0af351:                     addedServices.removeAll(removedServices);
1:a0af351: 
1:a0af351:                     for (String service : addedServices) {
1:a0af351:                         SimpleDiscoveryEvent e = new SimpleDiscoveryEvent(service);
1:a0af351:                         discoveredServices.put(service, e);
1:a0af351:                         discoveryListener.onServiceAdd(e);
1:a0af351:                     }
1:a0af351: 
1:a0af351:                     for (String service : removedServices) {
1:a0af351:                         SimpleDiscoveryEvent e = discoveredServices.remove(service);
1:082fdc5:                         if (e != null) {
1:a0af351:                             e.removed.set(true);
1:a0af351:                         }
1:a0af351:                         discoveryListener.onServiceRemove(e);
1:a0af351:                     }
1:a0af351:                 }
1:a0af351:             }
1:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void stop() throws Exception {
1:082fdc5:         if (startCounter.decrementAndGet() == 0) {
1:272b846:             resume();
1:a0af351:             running.set(false);
1:082fdc5:             if (thread != null) {
1:082fdc5:                 thread.join(updateInterval * 3);
1:082fdc5:                 thread = null;
1:a0af351:             }
1:082fdc5:             if (jetty != null) {
1:a0af351:                 jetty.stop();
1:a0af351:                 jetty = null;
1:a0af351:             }
1:a0af351:         }
1:a0af351:     }
1:a0af351: 
1:a0af351:     public String getRegistryURL() {
1:a0af351:         return registryURL;
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void setRegistryURL(String discoveryRegistryURL) {
1:a0af351:         this.registryURL = discoveryRegistryURL;
1:a0af351:     }
1:a0af351: 
1:a0af351:     public long getUpdateInterval() {
1:a0af351:         return updateInterval;
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void setUpdateInterval(long updateInterval) {
1:a0af351:         this.updateInterval = updateInterval;
1:a0af351:     }
1:a0af351: 
1:a0af351:     public boolean isStartEmbeddRegistry() {
1:a0af351:         return startEmbeddRegistry;
1:a0af351:     }
1:a0af351: 
1:a0af351:     public void setStartEmbeddRegistry(boolean startEmbeddRegistry) {
1:a0af351:         this.startEmbeddRegistry = startEmbeddRegistry;
1:a0af351:     }
1:272b846: 
1:272b846: 
1:272b846:     @Override
1:272b846:     public void suspend() throws Exception {
1:272b846:         synchronized (updateMutex) {
1:272b846:             updateState = UpdateState.SUSPENDED;
1:272b846:         }
1:272b846:     }
1:272b846: 
1:272b846:     @Override
1:272b846:     public void resume() throws Exception {
1:272b846:         synchronized (updateMutex) {
1:272b846:             updateState = UpdateState.RESUMING;
1:272b846:             updateMutex.notify();
1:272b846:         }
1:272b846:     }
1:272b846: 
1:a0af351: }
============================================================================
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:ffa396c
/////////////////////////////////////////////////////////////////////////
1:             scanner.close();
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:272b846
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Suspendable;
/////////////////////////////////////////////////////////////////////////
1: public class HTTPDiscoveryAgent implements DiscoveryAgent, Suspendable {
1: 
1:     static enum UpdateState {
1:         SUSPENDED,
1:         RESUMING,
1:         RESUMED
1:     }
/////////////////////////////////////////////////////////////////////////
1:     private final Object updateMutex = new Object();
1:     private UpdateState updateState = UpdateState.RESUMED;
/////////////////////////////////////////////////////////////////////////
1:                             synchronized (updateMutex) {
1:                                 do {
1:                                     if( updateState == UpdateState.RESUMING ) {
1:                                         updateState = UpdateState.RESUMED;
1:                                     } else {
1:                                         updateMutex.wait(updateInterval);
1:                                     }
1:                                 } while( updateState==UpdateState.SUSPENDED && running.get());
1:                             }
/////////////////////////////////////////////////////////////////////////
1:             resume();
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     @Override
1:     public void suspend() throws Exception {
1:         synchronized (updateMutex) {
1:             updateState = UpdateState.SUSPENDED;
1:         }
1:     }
1: 
1:     @Override
1:     public void resume() throws Exception {
1:         synchronized (updateMutex) {
1:             updateState = UpdateState.RESUMING;
1:             updateMutex.notify();
1:         }
1:     }
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a1ad8c
commit:a0af351
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.discovery.http;
1: 
1: import java.io.IOException;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Map;
1: import java.util.Scanner;
1: import java.util.Set;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.atomic.AtomicReference;
1: 
1: import org.apache.activemq.Service;
1: import org.apache.activemq.command.DiscoveryEvent;
1: import org.apache.activemq.transport.discovery.DiscoveryAgent;
1: import org.apache.activemq.transport.discovery.DiscoveryListener;
1: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.commons.httpclient.HttpClient;
0: import org.apache.commons.httpclient.methods.DeleteMethod;
0: import org.apache.commons.httpclient.methods.GetMethod;
0: import org.apache.commons.httpclient.methods.PutMethod;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: public class HTTPDiscoveryAgent implements DiscoveryAgent {
1:     
0:     private static final Log LOG = LogFactory.getLog(HTTPDiscoveryAgent.class);
1:     
1:     private String registryURL = "http://localhost:8080/discovery-registry/default";
0:     private HttpClient httpClient = new HttpClient();
0:     private AtomicBoolean running=new AtomicBoolean();
1:     private final AtomicReference<DiscoveryListener> discoveryListener = new AtomicReference<DiscoveryListener>();
1:     private final HashSet<String> registeredServices = new HashSet<String>();
1:     private final HashMap<String, SimpleDiscoveryEvent> discoveredServices = new HashMap<String, SimpleDiscoveryEvent>();    
1:     private Thread thread;   
0:     private long updateInterval = 1000*10;
1:     private String brokerName;
0:     private boolean startEmbeddRegistry=false;
1:     private Service jetty;
0:     private AtomicInteger startCounter=new AtomicInteger(0);
1: 
1:     
1:     private long initialReconnectDelay = 1000;
1:     private long maxReconnectDelay = 1000 * 30;
1:     private long backOffMultiplier = 2;
0:     private boolean useExponentialBackOff=true;    
1:     private int maxReconnectAttempts;
1:     private final Object sleepMutex = new Object();
1:     private long minConnectTime = 5000;
1:     
1:     class SimpleDiscoveryEvent extends DiscoveryEvent {
1: 
1:         private int connectFailures;
1:         private long reconnectDelay = initialReconnectDelay;
1:         private long connectTime = System.currentTimeMillis();
1:         private AtomicBoolean failed = new AtomicBoolean(false);
1:         private AtomicBoolean removed = new AtomicBoolean(false);
1: 
1:         public SimpleDiscoveryEvent(String service) {
1:             super(service);
1:         }
1: 
1:     }
1: 
1:     
1:     public String getGroup() {
1:         return null;
1:     }
1: 
1:     public void registerService(String service) throws IOException {
0:         synchronized(registeredServices) {
1:             registeredServices.add(service);
1:         }
1:         doRegister(service);
1:     }
1: 
1:     synchronized private void doRegister(String service) {
1:         String url = registryURL;
1:         try {
0:             PutMethod method = new PutMethod(url);
0: //            method.setParams(createParams());
0:             method.setRequestHeader("service", service);
0:             int responseCode = httpClient.executeMethod(method);
0:             LOG.debug("PUT to "+url+" got a "+responseCode);
1:         } catch (Exception e) {
0:             LOG.debug("PUT to "+url+" failed with: "+e);
1:         }
1:     }
1:     
1:     synchronized private void doUnRegister(String service) {
1:         String url = registryURL;
1:         try {
0:             DeleteMethod method = new DeleteMethod(url);
0: //            method.setParams(createParams());
0:             method.setRequestHeader("service", service);
0:             int responseCode = httpClient.executeMethod(method);
0:             LOG.debug("DELETE to "+url+" got a "+responseCode);
1:         } catch (Exception e) {
0:             LOG.debug("DELETE to "+url+" failed with: "+e);
1:         }
1:     }
1: 
0: //    private HttpMethodParams createParams() {
0: //        HttpMethodParams params = new HttpMethodParams();
0: //        params.setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler(0,false));
0: //        return params;
0: //    }
1:     
1:     synchronized private Set<String> doLookup(long freshness) {
0:         String url = registryURL+"?freshness="+freshness;
1:         try {
0:             GetMethod method = new GetMethod(url);
0: //            method.setParams(createParams());
0:             int responseCode = httpClient.executeMethod(method);
0:             LOG.debug("GET to "+url+" got a "+responseCode);
0:             if( responseCode == 200 ) {
1:                 Set<String> rc = new HashSet<String>();
0:                 Scanner scanner = new Scanner(method.getResponseBodyAsStream());
0:                 while( scanner.hasNextLine() ) {
1:                     String service = scanner.nextLine();
0:                     if( service.trim().length() != 0 ) {
1:                         rc.add(service);
1:                     }
1:                 }
1:                 return rc;
1:             } else {
0:                 LOG.debug("GET to "+url+" failed with response code: "+responseCode);
1:                 return null;
1:             }
1:         } catch (Exception e) {
0:             LOG.debug("GET to "+url+" failed with: "+e);
1:             return null;
1:         }
1:     }
1: 
1:     public void serviceFailed(DiscoveryEvent devent) throws IOException {
1: 
0:         final SimpleDiscoveryEvent event = (SimpleDiscoveryEvent)devent;
1:         if (event.failed.compareAndSet(false, true)) {
1:         	discoveryListener.get().onServiceRemove(event);
0:         	if(!event.removed.get()) {
1: 	        	// Setup a thread to re-raise the event...
1: 	            Thread thread = new Thread() {
1: 	                public void run() {
1: 	
0: 	                    // We detect a failed connection attempt because the service
1: 	                    // fails right away.
1: 	                    if (event.connectTime + minConnectTime > System.currentTimeMillis()) {
0: 	                        LOG.debug("Failure occured soon after the discovery event was generated.  It will be clasified as a connection failure: "+event);
1: 	
1: 	                        event.connectFailures++;
1: 	
1: 	                        if (maxReconnectAttempts > 0 && event.connectFailures >= maxReconnectAttempts) {
0: 	                            LOG.debug("Reconnect attempts exceeded "+maxReconnectAttempts+" tries.  Reconnecting has been disabled.");
1: 	                            return;
1: 	                        }
1: 	
1: 	                        synchronized (sleepMutex) {
1: 	                            try {
1: 	                                if (!running.get() || event.removed.get()) {
1: 	                                    return;
1: 	                                }
0: 	                                LOG.debug("Waiting "+event.reconnectDelay+" ms before attepting to reconnect.");
1: 	                                sleepMutex.wait(event.reconnectDelay);
1: 	                            } catch (InterruptedException ie) {
1: 	                                Thread.currentThread().interrupt();
1: 	                                return;
1: 	                            }
1: 	                        }
1: 	
1: 	                        if (!useExponentialBackOff) {
1: 	                            event.reconnectDelay = initialReconnectDelay;
1: 	                        } else {
1: 	                            // Exponential increment of reconnect delay.
1: 	                            event.reconnectDelay *= backOffMultiplier;
1: 	                            if (event.reconnectDelay > maxReconnectDelay) {
1: 	                                event.reconnectDelay = maxReconnectDelay;
1: 	                            }
1: 	                        }
1: 	
1: 	                    } else {
1: 	                        event.connectFailures = 0;
1: 	                        event.reconnectDelay = initialReconnectDelay;
1: 	                    }
1: 	
1: 	                    if (!running.get() || event.removed.get()) {
1: 	                        return;
1: 	                    }
1: 	
1: 	                    event.connectTime = System.currentTimeMillis();
1: 	                    event.failed.set(false);
1: 	                    discoveryListener.get().onServiceAdd(event);
1: 	                }
1: 	            };
1: 	            thread.setDaemon(true);
1: 	            thread.start();
1:         	}
1:         }
1:     }
1: 
1: 
1:     public void setBrokerName(String brokerName) {
1:         this.brokerName = brokerName;
1:     }
1: 
1:     public void setDiscoveryListener(DiscoveryListener discoveryListener) {
1:         this.discoveryListener.set(discoveryListener);
1:     }
1: 
1:     public void setGroup(String group) {
1:     }
1: 
1:     public void start() throws Exception {
0:         if( startCounter.addAndGet(1)==1 ) {
0:             if( startEmbeddRegistry ) {
1:                 jetty = createEmbeddedJettyServer();
0:                 Map props = new HashMap();
1:                 props.put("agent", this);
1:                 IntrospectionSupport.setProperties(jetty, props);
1:                 jetty.start();
1:             }
1:             
1:             running.set(true);
1:             thread = new Thread("HTTPDiscovery Agent") {
1:                 @Override
1:                 public void run() {
0:                     while(running.get()) {
1:                         try {
1:                             update();
0:                             Thread.sleep(updateInterval);
1:                         } catch (InterruptedException e) {
1:                             return;
1:                         }
1:                     }
1:                 }
1:             };
1:             thread.setDaemon(true);
1:             thread.start();
1:         }
1:     }
1: 
1:     /**
0:      * Create the EmbeddedJettyServer instance via reflection so that we can avoid a hard runtime dependency on 
0:      * jetty.
1:      * 
1:      * @return
1:      * @throws Exception
1:      */
0:     private Service createEmbeddedJettyServer()  throws Exception {
0:         Class clazz = HTTPDiscoveryAgent.class.getClassLoader().loadClass("org.apache.activemq.transport.discovery.http.EmbeddedJettyServer");
0:         return (Service)clazz.newInstance();
1:     }
1: 
1:     private void update() {
1:         // Register all our services...
0:         synchronized(registeredServices) {
1:             for (String service : registeredServices) {
1:                 doRegister(service);
1:             }
1:         }
1:         
1:         // Find new registered services...
1:         DiscoveryListener discoveryListener = this.discoveryListener.get();
0:         if(discoveryListener!=null) {
0:             Set<String> activeServices = doLookup(updateInterval*3);
0:             // If there is error talking the the central server, then activeServices == null
0:             if( activeServices !=null ) {
0:                 synchronized(discoveredServices) {
1:                     
1:                     HashSet<String> removedServices = new HashSet<String>(discoveredServices.keySet());
1:                     removedServices.removeAll(activeServices);
1:                     
1:                     HashSet<String> addedServices = new HashSet<String>(activeServices);
1:                     addedServices.removeAll(discoveredServices.keySet());
1:                     addedServices.removeAll(removedServices);
1:                     
1:                     for (String service : addedServices) {
1:                         SimpleDiscoveryEvent e = new SimpleDiscoveryEvent(service);
1:                         discoveredServices.put(service, e);
1:                         discoveryListener.onServiceAdd(e);
1:                     }
1:                     
1:                     for (String service : removedServices) {
1:                     	SimpleDiscoveryEvent e = discoveredServices.remove(service);
0:                     	if( e !=null ) {
1:                     		e.removed.set(true);
1:                     	}
1:                         discoveryListener.onServiceRemove(e);
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public void stop() throws Exception {
0:         if( startCounter.decrementAndGet()==0 ) {
1:             running.set(false);
0:             if( thread!=null ) {
0:                 thread.join(updateInterval*3);
0:                 thread=null;
1:             }
0:             if( jetty!=null ) {
1:                 jetty.stop();
1:                 jetty = null;
1:             }
1:         }
1:     }
1: 
1:     public String getRegistryURL() {
1:         return registryURL;
1:     }
1: 
1:     public void setRegistryURL(String discoveryRegistryURL) {
1:         this.registryURL = discoveryRegistryURL;
1:     }
1: 
1:     public long getUpdateInterval() {
1:         return updateInterval;
1:     }
1: 
1:     public void setUpdateInterval(long updateInterval) {
1:         this.updateInterval = updateInterval;
1:     }
1: 
1:     public boolean isStartEmbeddRegistry() {
1:         return startEmbeddRegistry;
1:     }
1: 
1:     public void setStartEmbeddRegistry(boolean startEmbeddRegistry) {
1:         this.startEmbeddRegistry = startEmbeddRegistry;
1:     }
1: 
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:082fdc5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.http.client.HttpClient;
1: import org.apache.http.client.ResponseHandler;
1: import org.apache.http.client.methods.HttpDelete;
1: import org.apache.http.client.methods.HttpGet;
1: import org.apache.http.client.methods.HttpPut;
1: import org.apache.http.impl.client.BasicResponseHandler;
1: import org.apache.http.impl.client.DefaultHttpClient;
0: 
0: 
1:     private HttpClient httpClient = new DefaultHttpClient();
1:     private AtomicBoolean running = new AtomicBoolean();
0:     private final HashMap<String, SimpleDiscoveryEvent> discoveredServices = new HashMap<String, SimpleDiscoveryEvent>();
0:     private Thread thread;
1:     private long updateInterval = 1000 * 10;
1:     @SuppressWarnings("unused")
1:     private boolean startEmbeddRegistry = false;
1:     private AtomicInteger startCounter = new AtomicInteger(0);
1:     private boolean useExponentialBackOff = true;
0: 
/////////////////////////////////////////////////////////////////////////
1:         synchronized (registeredServices) {
/////////////////////////////////////////////////////////////////////////
1:             HttpPut method = new HttpPut(url);
1:             method.addHeader("service", service);
1:             ResponseHandler<String> handler = new BasicResponseHandler();
1:             String responseBody = httpClient.execute(method, handler);
1:             LOG.debug("PUT to " + url + " got a " + responseBody);
1:             LOG.debug("PUT to " + url + " failed with: " + e);
1:     @SuppressWarnings("unused")
0:     synchronized private void doUnRegister(String service) {
0:         String url = registryURL;
1:             HttpDelete method = new HttpDelete(url);
1:             method.addHeader("service", service);
1:             ResponseHandler<String> handler = new BasicResponseHandler();
1:             String responseBody = httpClient.execute(method, handler);
1:             LOG.debug("DELETE to " + url + " got a " + responseBody);
1:             LOG.debug("DELETE to " + url + " failed with: " + e);
0:         }
0:     }
0: 
0:     synchronized private Set<String> doLookup(long freshness) {
1:         String url = registryURL + "?freshness=" + freshness;
0:         try {
1:             HttpGet method = new HttpGet(url);
1:             ResponseHandler<String> handler = new BasicResponseHandler();
1:             String response = httpClient.execute(method, handler);
1:             LOG.debug("GET to " + url + " got a " + response);
0:             Set<String> rc = new HashSet<String>();
1:             Scanner scanner = new Scanner(response);
1:             while (scanner.hasNextLine()) {
0:                 String service = scanner.nextLine();
1:                 if (service.trim().length() != 0) {
0:                     rc.add(service);
0:                 }
0:             }
0:             return rc;
0:         } catch (Exception e) {
1:             LOG.debug("GET to " + url + " failed with: " + e);
1:         final SimpleDiscoveryEvent event = (SimpleDiscoveryEvent) devent;
0:             discoveryListener.get().onServiceRemove(event);
1:             if (!event.removed.get()) {
0:                 // Setup a thread to re-raise the event...
0:                 Thread thread = new Thread() {
0:                     public void run() {
0: 
1:                         // We detect a failed connection attempt because the
1:                         // service
0:                         // fails right away.
0:                         if (event.connectTime + minConnectTime > System.currentTimeMillis()) {
1:                             LOG.debug("Failure occured soon after the discovery event was generated.  " +
1:                                       "It will be clasified as a connection failure: " + event);
0: 
0:                             event.connectFailures++;
0: 
0:                             if (maxReconnectAttempts > 0 && event.connectFailures >= maxReconnectAttempts) {
1:                                 LOG.debug("Reconnect attempts exceeded " + maxReconnectAttempts +
1:                                           " tries.  Reconnecting has been disabled.");
0:                                 return;
0:                             }
0: 
0:                             synchronized (sleepMutex) {
0:                                 try {
0:                                     if (!running.get() || event.removed.get()) {
0:                                         return;
0:                                     }
1:                                     LOG.debug("Waiting " + event.reconnectDelay +
1:                                               " ms before attepting to reconnect.");
0:                                     sleepMutex.wait(event.reconnectDelay);
0:                                 } catch (InterruptedException ie) {
0:                                     Thread.currentThread().interrupt();
0:                                     return;
0:                                 }
0:                             }
0: 
0:                             if (!useExponentialBackOff) {
0:                                 event.reconnectDelay = initialReconnectDelay;
0:                             } else {
0:                                 // Exponential increment of reconnect delay.
0:                                 event.reconnectDelay *= backOffMultiplier;
0:                                 if (event.reconnectDelay > maxReconnectDelay) {
0:                                     event.reconnectDelay = maxReconnectDelay;
0:                                 }
0:                             }
0: 
0:                         } else {
0:                             event.connectFailures = 0;
0:                             event.reconnectDelay = initialReconnectDelay;
0:                         }
0: 
0:                         if (!running.get() || event.removed.get()) {
0:                             return;
0:                         }
0: 
0:                         event.connectTime = System.currentTimeMillis();
0:                         event.failed.set(false);
0:                         discoveryListener.get().onServiceAdd(event);
0:                     }
0:                 };
0:                 thread.setDaemon(true);
0:                 thread.start();
0:             }
/////////////////////////////////////////////////////////////////////////
1:         if (startCounter.addAndGet(1) == 1) {
1:             if (startEmbeddRegistry) {
1:                 Map<String, Object> props = new HashMap<String, Object>();
0: 
1:                     while (running.get()) {
/////////////////////////////////////////////////////////////////////////
1:      * Create the EmbeddedJettyServer instance via reflection so that we can
1:      * avoid a hard runtime dependency on jetty.
0:      *
1:     private Service createEmbeddedJettyServer() throws Exception {
1:         Class<?> clazz = HTTPDiscoveryAgent.class.getClassLoader().loadClass("org.apache.activemq.transport.discovery.http.EmbeddedJettyServer");
1:         return (Service) clazz.newInstance();
1:         synchronized (registeredServices) {
0: 
1:         if (discoveryListener != null) {
1:             Set<String> activeServices = doLookup(updateInterval * 3);
1:             // If there is error talking the the central server, then
1:             // activeServices == null
1:             if (activeServices != null) {
1:                 synchronized (discoveredServices) {
0: 
0: 
0: 
0: 
0:                         SimpleDiscoveryEvent e = discoveredServices.remove(service);
1:                         if (e != null) {
0:                             e.removed.set(true);
0:                         }
/////////////////////////////////////////////////////////////////////////
1:         if (startCounter.decrementAndGet() == 0) {
1:             if (thread != null) {
1:                 thread.join(updateInterval * 3);
1:                 thread = null;
1:             if (jetty != null) {
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(HTTPDiscoveryAgent.class);
============================================================================