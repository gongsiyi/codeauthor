13:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:230a86c:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
13:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
1:74a7a8b: 
1:74a7a8b: import java.util.HashMap;
1:ecf89a6: import java.util.Map;
1:74a7a8b: import java.util.concurrent.atomic.AtomicLong;
1:a2cb4a8: 
1:74a7a8b: import javax.jms.Destination;
1:74a7a8b: import javax.jms.IllegalStateException;
1:74a7a8b: import javax.jms.InvalidDestinationException;
1:74a7a8b: import javax.jms.JMSException;
1:74a7a8b: import javax.jms.Message;
1:a2cb4a8: 
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:c9bb1c9: import org.apache.activemq.command.ProducerAck;
1:d29ca2a: import org.apache.activemq.command.ProducerId;
1:d29ca2a: import org.apache.activemq.command.ProducerInfo;
1:d29ca2a: import org.apache.activemq.management.JMSProducerStatsImpl;
1:d29ca2a: import org.apache.activemq.management.StatsCapable;
1:d29ca2a: import org.apache.activemq.management.StatsImpl;
1:6d8e2c5: import org.apache.activemq.usage.MemoryUsage;
1:c9bb1c9: import org.apache.activemq.util.IntrospectionSupport;
1:88f6058: import org.slf4j.Logger;
1:88f6058: import org.slf4j.LoggerFactory;
1:74a7a8b: 
1:d29ca2a: /**
1:d29ca2a:  * A client uses a <CODE>MessageProducer</CODE> object to send messages to a
1:d29ca2a:  * destination. A <CODE>MessageProducer</CODE> object is created by passing a
1:d29ca2a:  * <CODE>Destination</CODE> object to a message-producer creation method
1:d29ca2a:  * supplied by a session.
9:d29ca2a:  * <P>
1:d29ca2a:  * <CODE>MessageProducer</CODE> is the parent interface for all message
1:d29ca2a:  * producers.
1:d29ca2a:  * <P>
1:230a86c:  * A client also has the option of creating a message producer without supplying
1:230a86c:  * a destination. In this case, a destination must be provided with every send
1:230a86c:  * operation. A typical use for this kind of message producer is to send replies
1:230a86c:  * to requests using the request's <CODE>JMSReplyTo</CODE> destination.
1:d29ca2a:  * <P>
1:d29ca2a:  * A client can specify a default delivery mode, priority, and time to live for
1:d29ca2a:  * messages sent by a message producer. It can also specify the delivery mode,
1:d29ca2a:  * priority, and time to live for an individual message.
1:d29ca2a:  * <P>
1:230a86c:  * A client can specify a time-to-live value in milliseconds for each message it
1:230a86c:  * sends. This value defines a message expiration time that is the sum of the
1:230a86c:  * message's time-to-live and the GMT when it is sent (for transacted sends,
1:230a86c:  * this is the time the client sends the message, not the time the transaction
1:230a86c:  * is committed).
1:d29ca2a:  * <P>
1:230a86c:  * A JMS provider should do its best to expire messages accurately; however, the
1:230a86c:  * JMS API does not define the accuracy provided.
1:88f6058:  *
1:88f6058:  *
1:d29ca2a:  * @see javax.jms.TopicPublisher
1:d29ca2a:  * @see javax.jms.QueueSender
4:d29ca2a:  * @see javax.jms.Session#createProducer
1:d29ca2a:  */
1:677c22b: public class ActiveMQMessageProducer extends ActiveMQMessageProducerSupport implements StatsCapable, Disposable {
1:4207bd9: 
1:88f6058:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQMessageProducer.class);
1:88f6058: 
1:d29ca2a:     protected ProducerInfo info;
1:ecf89a6:     protected boolean closed;
1:ecf89a6: 
1:1a5ad28:     private final JMSProducerStatsImpl stats;
1:d29ca2a:     private AtomicLong messageSequence;
1:1a5ad28:     private final long startTime;
1:86faaef:     private MessageTransformer transformer;
1:6d8e2c5:     private MemoryUsage producerWindow;
23:d29ca2a: 
1:114a923:     protected ActiveMQMessageProducer(ActiveMQSession session, ProducerId producerId, ActiveMQDestination destination, int sendTimeout) throws JMSException {
1:677c22b:         super(session);
1:d29ca2a:         this.info = new ProducerInfo(producerId);
1:230a86c:         this.info.setWindowSize(session.connection.getProducerWindowSize());
1:88f6058:         // Allows the options on the destination to configure the producerInfo
1:230a86c:         if (destination != null && destination.getOptions() != null) {
1:6c4bcb3:             Map<String, Object> options = IntrospectionSupport.extractProperties(
1:6c4bcb3:                 new HashMap<String, Object>(destination.getOptions()), "producer.");
1:56272fa:             IntrospectionSupport.setProperties(this.info, options);
1:88f6058:             if (options.size() > 0) {
1:88f6058:                 String msg = "There are " + options.size()
1:88f6058:                     + " producer options that couldn't be set on the producer."
1:88f6058:                     + " Check the options are spelled correctly."
1:88f6058:                     + " Unknown parameters=[" + options + "]."
1:88f6058:                     + " This producer cannot be started.";
1:88f6058:                 LOG.warn(msg);
1:88f6058:                 throw new ConfigurationException(msg);
1:88f6058:             }
1:c9bb1c9:         }
1:88f6058: 
1:d29ca2a:         this.info.setDestination(destination);
1:230a86c: 
1:deee040:         // Enable producer window flow control if protocol >= 3 and the window size > 0
1:230a86c:         if (session.connection.getProtocolVersion() >= 3 && this.info.getWindowSize() > 0) {
1:6d8e2c5:             producerWindow = new MemoryUsage("Producer Window: " + producerId);
1:1a5ad28:             producerWindow.setExecutor(session.getConnectionExecutor());
1:230a86c:             producerWindow.setLimit(this.info.getWindowSize());
1:9a432f2:             producerWindow.start();
1:c9bb1c9:         }
1:c9bb1c9: 
1:d29ca2a:         this.defaultDeliveryMode = Message.DEFAULT_DELIVERY_MODE;
1:d29ca2a:         this.defaultPriority = Message.DEFAULT_PRIORITY;
1:d29ca2a:         this.defaultTimeToLive = Message.DEFAULT_TIME_TO_LIVE;
1:d29ca2a:         this.startTime = System.currentTimeMillis();
1:d29ca2a:         this.messageSequence = new AtomicLong(0);
1:d29ca2a:         this.stats = new JMSProducerStatsImpl(session.getSessionStats(), destination);
1:a2cb4a8:         try {
1:a2cb4a8:             this.session.addProducer(this);
1:a2cb4a8:             this.session.syncSendPacket(info);
1:a2cb4a8:         } catch (JMSException e) {
1:a2cb4a8:             this.session.removeProducer(this);
1:a2cb4a8:             throw e;
1:a2cb4a8:         }
1:114a923:         this.setSendTimeout(sendTimeout);
1:86faaef:         setTransformer(session.getTransformer());
1:c9bb1c9:     }
1:c9bb1c9: 
1:a2cb4a8:     @Override
1:d29ca2a:     public StatsImpl getStats() {
1:d29ca2a:         return stats;
1:c9bb1c9:     }
1:d29ca2a: 
1:d29ca2a:     public JMSProducerStatsImpl getProducerStats() {
1:d29ca2a:         return stats;
17:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Gets the destination associated with this <CODE>MessageProducer</CODE>.
1:88f6058:      *
1:d29ca2a:      * @return this producer's <CODE>Destination/ <CODE>
7:d29ca2a:      * @throws JMSException if the JMS provider fails to close the producer due to
11:d29ca2a:      *                      some internal error.
3:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:a2cb4a8:     @Override
1:d29ca2a:     public Destination getDestination() throws JMSException {
11:d29ca2a:         checkClosed();
1:d29ca2a:         return this.info.getDestination();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Closes the message producer.
1:d29ca2a:      * <P>
1:d29ca2a:      * Since a provider may allocate some resources on behalf of a <CODE>
1:230a86c:      * MessageProducer</CODE>
1:230a86c:      * outside the Java virtual machine, clients should close them when they are
1:230a86c:      * not needed. Relying on garbage collection to eventually reclaim these
1:230a86c:      * resources may not be timely enough.
1:88f6058:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to close the producer due
1:230a86c:      *                 to some internal error.
1:d29ca2a:      */
1:a2cb4a8:     @Override
1:d29ca2a:     public void close() throws JMSException {
1:74a7a8b:         if (!closed) {
1:d29ca2a:             dispose();
1:d29ca2a:             this.session.asyncSendPacket(info.createRemoveCommand());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:a2cb4a8:     @Override
1:d29ca2a:     public void dispose() {
1:74a7a8b:         if (!closed) {
1:d29ca2a:             this.session.removeProducer(this);
1:9a432f2:             if (producerWindow != null) {
1:9a432f2:                 producerWindow.stop();
1:d29ca2a:             }
1:d29ca2a:             closed = true;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Check if the instance of this producer has been closed.
1:88f6058:      *
1:d29ca2a:      * @throws IllegalStateException
1:d29ca2a:      */
1:a2cb4a8:     @Override
1:d29ca2a:     protected void checkClosed() throws IllegalStateException {
1:d29ca2a:         if (closed) {
1:d29ca2a:             throw new IllegalStateException("The producer is closed");
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sends a message to a destination for an unidentified message producer,
1:d29ca2a:      * specifying delivery mode, priority and time to live.
1:d29ca2a:      * <P>
1:230a86c:      * Typically, a message producer is assigned a destination at creation time;
1:230a86c:      * however, the JMS API also supports unidentified message producers, which
1:230a86c:      * require that the destination be supplied every time a message is sent.
1:88f6058:      *
1:230a86c:      * @param destination the destination to send this message to
1:230a86c:      * @param message the message to send
2:d29ca2a:      * @param deliveryMode the delivery mode to use
1:230a86c:      * @param priority the priority for this message
1:230a86c:      * @param timeToLive the message's lifetime (in milliseconds)
1:230a86c:      * @throws JMSException if the JMS provider fails to send the message due to
1:230a86c:      *                 some internal error.
1:230a86c:      * @throws UnsupportedOperationException if an invalid destination is
1:230a86c:      *                 specified.
1:230a86c:      * @throws InvalidDestinationException if a client uses this method with an
1:230a86c:      *                 invalid destination.
1:d29ca2a:      * @see javax.jms.Session#createProducer
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:1a5ad28:     @Override
1:230a86c:     public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {
1:d4cd7f9:         this.send(destination, message, deliveryMode, priority, timeToLive, null);
1:d4cd7f9:     }
1:d4cd7f9: 
1:d4cd7f9:     public void send(Message message, AsyncCallback onComplete) throws JMSException {
1:d4cd7f9:         this.send(this.getDestination(),
1:d4cd7f9:                   message,
1:d4cd7f9:                   this.defaultDeliveryMode,
1:d4cd7f9:                   this.defaultPriority,
1:d4cd7f9:                   this.defaultTimeToLive, onComplete);
1:d4cd7f9:     }
1:d4cd7f9: 
1:d4cd7f9:     public void send(Destination destination, Message message, AsyncCallback onComplete) throws JMSException {
1:d4cd7f9:         this.send(destination,
1:d4cd7f9:                   message,
1:d4cd7f9:                   this.defaultDeliveryMode,
1:d4cd7f9:                   this.defaultPriority,
1:d4cd7f9:                   this.defaultTimeToLive,
1:d4cd7f9:                   onComplete);
1:d4cd7f9:     }
1:d4cd7f9: 
1:d4cd7f9:     public void send(Message message, int deliveryMode, int priority, long timeToLive, AsyncCallback onComplete) throws JMSException {
1:d4cd7f9:         this.send(this.getDestination(),
1:d4cd7f9:                   message,
1:d4cd7f9:                   deliveryMode,
1:d4cd7f9:                   priority,
1:d4cd7f9:                   timeToLive,
1:d4cd7f9:                   onComplete);
1:d4cd7f9:     }
1:d4cd7f9: 
1:d4cd7f9:     public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive, AsyncCallback onComplete) throws JMSException {
1:d29ca2a:         checkClosed();
1:d29ca2a:         if (destination == null) {
1:230a86c:             if (info.getDestination() == null) {
1:d29ca2a:                 throw new UnsupportedOperationException("A destination must be specified.");
1:d29ca2a:             }
1:d29ca2a:             throw new InvalidDestinationException("Don't understand null destinations");
1:d29ca2a:         }
1:d29ca2a: 
1:230a86c:         ActiveMQDestination dest;
1:aec2762:         if (destination.equals(info.getDestination())) {
1:230a86c:             dest = (ActiveMQDestination)destination;
1:230a86c:         } else if (info.getDestination() == null) {
1:d29ca2a:             dest = ActiveMQDestination.transform(destination);
1:d29ca2a:         } else {
1:d29ca2a:             throw new UnsupportedOperationException("This producer can only send messages to: " + this.info.getDestination().getPhysicalName());
1:d29ca2a:         }
1:4e1ec02:         if (dest == null) {
1:4e1ec02:             throw new JMSException("No destination specified");
1:d29ca2a:         }
1:d29ca2a: 
1:86faaef:         if (transformer != null) {
1:86faaef:             Message transformedMessage = transformer.producerTransform(session, this, message);
1:86faaef:             if (transformedMessage != null) {
1:86faaef:                 message = transformedMessage;
1:d29ca2a:             }
1:d29ca2a:         }
1:c9bb1c9: 
1:230a86c:         if (producerWindow != null) {
1:230a86c:             try {
1:230a86c:                 producerWindow.waitForSpace();
1:230a86c:             } catch (InterruptedException e) {
1:230a86c:                 throw new JMSException("Send aborted due to thread interrupt.");
1:230a86c:             }
1:230a86c:         }
1:230a86c: 
1:d4cd7f9:         this.session.send(this, dest, message, deliveryMode, priority, timeToLive, producerWindow, sendTimeout, onComplete);
1:230a86c: 
1:230a86c:         stats.onMessage();
1:230a86c:     }
1:c9bb1c9: 
1:86faaef:     public MessageTransformer getTransformer() {
1:86faaef:         return transformer;
1:c9bb1c9:     }
1:c9bb1c9: 
1:d29ca2a:     /**
1:230a86c:      * Sets the transformer used to transform messages before they are sent on
1:230a86c:      * to the JMS bus
1:d29ca2a:      */
1:86faaef:     public void setTransformer(MessageTransformer transformer) {
1:86faaef:         this.transformer = transformer;
1:c9bb1c9:     }
1:c9bb1c9: 
1:d29ca2a:     /**
1:d29ca2a:      * @return the time in milli second when this object was created.
1:d29ca2a:      */
1:d29ca2a:     protected long getStartTime() {
1:d29ca2a:         return this.startTime;
1:c9bb1c9:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the messageSequence.
1:d29ca2a:      */
1:d29ca2a:     protected long getMessageSequence() {
1:d29ca2a:         return messageSequence.incrementAndGet();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param messageSequence The messageSequence to set.
1:d29ca2a:      */
1:d29ca2a:     protected void setMessageSequence(AtomicLong messageSequence) {
1:d29ca2a:         this.messageSequence = messageSequence;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the info.
1:d29ca2a:      */
1:230a86c:     protected ProducerInfo getProducerInfo() {
1:230a86c:         return this.info != null ? this.info : null;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param info The info to set
1:d29ca2a:      */
1:230a86c:     protected void setProducerInfo(ProducerInfo info) {
1:d29ca2a:         this.info = info;
1:d29ca2a:     }
1:d29ca2a: 
1:1a5ad28:     @Override
1:d29ca2a:     public String toString() {
1:230a86c:         return "ActiveMQMessageProducer { value=" + info.getProducerId() + " }";
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void onProducerAck(ProducerAck pa) {
1:230a86c:         if (this.producerWindow != null) {
1:230a86c:             this.producerWindow.decreaseUsage(pa.getSize());
1:230a86c:         }
1:230a86c:     }
1:c9bb1c9: 
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:deee040
/////////////////////////////////////////////////////////////////////////
1:         // Enable producer window flow control if protocol >= 3 and the window size > 0
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:a2cb4a8
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             this.session.addProducer(this);
1:             this.session.syncSendPacket(info);
1:         } catch (JMSException e) {
1:             this.session.removeProducer(this);
1:             throw e;
1:         }
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:6c4bcb3
/////////////////////////////////////////////////////////////////////////
1:             Map<String, Object> options = IntrospectionSupport.extractProperties(
1:                 new HashMap<String, Object>(destination.getOptions()), "producer.");
commit:56272fa
/////////////////////////////////////////////////////////////////////////
0:             Map<String, Object> options = IntrospectionSupport.extractProperties(destination.getOptions(), "producer.");
1:             IntrospectionSupport.setProperties(this.info, options);
commit:88f6058
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQMessageProducer.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Allows the options on the destination to configure the producerInfo
1:             if (options.size() > 0) {
1:                 String msg = "There are " + options.size()
1:                     + " producer options that couldn't be set on the producer."
1:                     + " Check the options are spelled correctly."
1:                     + " Unknown parameters=[" + options + "]."
1:                     + " This producer cannot be started.";
1:                 LOG.warn(msg);
1:                 throw new ConfigurationException(msg);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:d4cd7f9
/////////////////////////////////////////////////////////////////////////
1:         this.send(destination, message, deliveryMode, priority, timeToLive, null);
1:     }
1: 
1:     public void send(Message message, AsyncCallback onComplete) throws JMSException {
1:         this.send(this.getDestination(),
1:                   message,
1:                   this.defaultDeliveryMode,
1:                   this.defaultPriority,
1:                   this.defaultTimeToLive, onComplete);
1:     }
1: 
1:     public void send(Destination destination, Message message, AsyncCallback onComplete) throws JMSException {
1:         this.send(destination,
1:                   message,
1:                   this.defaultDeliveryMode,
1:                   this.defaultPriority,
1:                   this.defaultTimeToLive,
1:                   onComplete);
1:     }
1: 
1:     public void send(Message message, int deliveryMode, int priority, long timeToLive, AsyncCallback onComplete) throws JMSException {
1:         this.send(this.getDestination(),
1:                   message,
1:                   deliveryMode,
1:                   priority,
1:                   timeToLive,
1:                   onComplete);
1:     }
1: 
1:     public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive, AsyncCallback onComplete) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:         this.session.send(this, dest, message, deliveryMode, priority, timeToLive, producerWindow, sendTimeout, onComplete);
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean closed;
1: 
/////////////////////////////////////////////////////////////////////////
0:             Map<String, String> options = new HashMap<String, String>(destination.getOptions());
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import javax.jms.Destination;
1: import javax.jms.IllegalStateException;
1: import javax.jms.InvalidDestinationException;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (!closed) {
1:         if (!closed) {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:  * A client also has the option of creating a message producer without supplying
1:  * a destination. In this case, a destination must be provided with every send
1:  * operation. A typical use for this kind of message producer is to send replies
1:  * to requests using the request's <CODE>JMSReplyTo</CODE> destination.
1:  * A client can specify a time-to-live value in milliseconds for each message it
1:  * sends. This value defines a message expiration time that is the sum of the
1:  * message's time-to-live and the GMT when it is sent (for transacted sends,
1:  * this is the time the client sends the message, not the time the transaction
1:  * is committed).
1:  * A JMS provider should do its best to expire messages accurately; however, the
1:  * JMS API does not define the accuracy provided.
1:  * 
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQMessageProducer(ActiveMQSession session, ProducerId producerId, ActiveMQDestination destination) throws JMSException {
1:         this.info.setWindowSize(session.connection.getProducerWindowSize());
1:         if (destination != null && destination.getOptions() != null) {
1: 
0:         // Enable producer window flow control if protocol > 3 and the window
0:         // size > 0
1:         if (session.connection.getProtocolVersion() >= 3 && this.info.getWindowSize() > 0) {
0:             producerWindow = new UsageManager("Producer Window: " + producerId);
1:             producerWindow.setLimit(this.info.getWindowSize());
/////////////////////////////////////////////////////////////////////////
0:         this.session.addProducer(this);
/////////////////////////////////////////////////////////////////////////
0:      * 
/////////////////////////////////////////////////////////////////////////
1:      * MessageProducer</CODE>
1:      * outside the Java virtual machine, clients should close them when they are
1:      * not needed. Relying on garbage collection to eventually reclaim these
1:      * resources may not be timely enough.
0:      * 
1:      * @throws JMSException if the JMS provider fails to close the producer due
1:      *                 to some internal error.
0:         if (closed == false) {
0:         if (closed == false) {
0:      * 
/////////////////////////////////////////////////////////////////////////
1:      * Typically, a message producer is assigned a destination at creation time;
1:      * however, the JMS API also supports unidentified message producers, which
1:      * require that the destination be supplied every time a message is sent.
0:      * 
1:      * @param destination the destination to send this message to
1:      * @param message the message to send
1:      * @param priority the priority for this message
1:      * @param timeToLive the message's lifetime (in milliseconds)
1:      * @throws JMSException if the JMS provider fails to send the message due to
1:      *                 some internal error.
1:      * @throws UnsupportedOperationException if an invalid destination is
1:      *                 specified.
1:      * @throws InvalidDestinationException if a client uses this method with an
1:      *                 invalid destination.
1:     public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {
1:             if (info.getDestination() == null) {
1:         ActiveMQDestination dest;
0:         if (destination == info.getDestination()) {
1:             dest = (ActiveMQDestination)destination;
1:         } else if (info.getDestination() == null) {
/////////////////////////////////////////////////////////////////////////
1:         if (producerWindow != null) {
1:             try {
1:                 producerWindow.waitForSpace();
1:             } catch (InterruptedException e) {
1:                 throw new JMSException("Send aborted due to thread interrupt.");
1:             }
1:         }
1: 
0:         this.session.send(this, dest, message, deliveryMode, priority, timeToLive, producerWindow);
1: 
1:         stats.onMessage();
1:     }
1:      * Sets the transformer used to transform messages before they are sent on
1:      * to the JMS bus
/////////////////////////////////////////////////////////////////////////
1:     protected ProducerInfo getProducerInfo() {
1:         return this.info != null ? this.info : null;
1:     protected void setProducerInfo(ProducerInfo info) {
1:         return "ActiveMQMessageProducer { value=" + info.getProducerId() + " }";
1:     public void onProducerAck(ProducerAck pa) {
1:         if (this.producerWindow != null) {
1:             this.producerWindow.decreaseUsage(pa.getSize());
1:         }
1:     }
commit:4207bd9
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.concurrent.atomic.AtomicLong;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.session.send(this, dest, message, deliveryMode, priority, timeToLive, producerWindow);
commit:c9bb1c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerAck;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.util.IntrospectionSupport;
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0:     private UsageManager producerWindow;
0:         this.info.setWindowSize(session.connection.getProducerWindowSize());        
0:         if (destination!=null && destination.getOptions() != null) {
0:             HashMap options = new HashMap(destination.getOptions());
0:             IntrospectionSupport.setProperties(this.info, options, "producer.");
1:         }
1:         
0:         // Enable producer window flow control if protocol > 3 and the window size > 0
0:         if( session.connection.getProtocolVersion()>=3 && this.info.getWindowSize()>0 ) {
0:         	producerWindow = new UsageManager("Producer Window: "+producerId);
0:         	producerWindow.setLimit(this.info.getWindowSize());
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         
0:         if( producerWindow!=null ) {
0:         	try {
0: 				producerWindow.waitForSpace();
0: 			} catch (InterruptedException e) {
0: 				throw new JMSException("Send aborted due to thread interrupt.");
1: 			}
1:         }
1:         
0:         int size = this.session.send(this, dest, message, deliveryMode, priority, timeToLive);
1: 
0:         if( producerWindow!=null ) {
0: 			producerWindow.increaseUsage(size);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0: 	public void onProducerAck(ProducerAck pa) {
0: 		if( this.producerWindow!=null ) {
0: 			this.producerWindow.decreaseUsage(pa.getSize());
1: 		}
1: 	}
1: 
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicLong;
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.Disposable;
commit:c59246d
/////////////////////////////////////////////////////////////////////////
0:         return "ActiveMQMessageProducer { value=" +info.getProducerId()+" }";
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
0: import javax.jms.DeliveryMode;
0: import javax.jms.Destination;
0: import javax.jms.IllegalStateException;
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageFormatException;
0: import javax.jms.MessageProducer;
1: 
0: import org.activeio.Disposable;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.management.JMSProducerStatsImpl;
1: import org.apache.activemq.management.StatsCapable;
1: import org.apache.activemq.management.StatsImpl;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicLong;
1: 
1: /**
1:  * A client uses a <CODE>MessageProducer</CODE> object to send messages to a
1:  * destination. A <CODE>MessageProducer</CODE> object is created by passing a
1:  * <CODE>Destination</CODE> object to a message-producer creation method
1:  * supplied by a session.
1:  * <P>
1:  * <CODE>MessageProducer</CODE> is the parent interface for all message
1:  * producers.
1:  * <P>
0:  * A client also has the option of creating a message producer without
0:  * supplying a destination. In this case, a destination must be provided with
0:  * every send operation. A typical use for this kind of message producer is to
0:  * send replies to requests using the request's <CODE>JMSReplyTo</CODE>
0:  * destination.
1:  * <P>
1:  * A client can specify a default delivery mode, priority, and time to live for
1:  * messages sent by a message producer. It can also specify the delivery mode,
1:  * priority, and time to live for an individual message.
1:  * <P>
0:  * A client can specify a time-to-live value in milliseconds for each message
0:  * it sends. This value defines a message expiration time that is the sum of
0:  * the message's time-to-live and the GMT when it is sent (for transacted
0:  * sends, this is the time the client sends the message, not the time the
0:  * transaction is committed).
1:  * <P>
0:  * A JMS provider should do its best to expire messages accurately; however,
0:  * the JMS API does not define the accuracy provided.
0:  *
0:  * @version $Revision: 1.14 $
1:  * @see javax.jms.TopicPublisher
1:  * @see javax.jms.QueueSender
1:  * @see javax.jms.Session#createProducer
1:  */
0: public class ActiveMQMessageProducer implements MessageProducer, StatsCapable, Closeable, Disposable {
1: 
0:     protected ActiveMQSession session;
1:     protected ProducerInfo info;
0:     private JMSProducerStatsImpl stats;
1:     private AtomicLong messageSequence;
1: 
0:     protected boolean closed;
0:     private boolean disableMessageID;
0:     private boolean disableMessageTimestamp;
0:     private int defaultDeliveryMode;
0:     private int defaultPriority;
0:     private long defaultTimeToLive;
0:     private long startTime;
1: 
0:     protected ActiveMQMessageProducer(ActiveMQSession session, ProducerId producerId, ActiveMQDestination destination)
0:             throws JMSException {
0:         this.session = session;
1:         this.info = new ProducerInfo(producerId);
1:         this.info.setDestination(destination);
0:         this.disableMessageID = false;
0:         this.disableMessageTimestamp = session.connection.isDisableTimeStampsByDefault();
1:         this.defaultDeliveryMode = Message.DEFAULT_DELIVERY_MODE;
1:         this.defaultPriority = Message.DEFAULT_PRIORITY;
1:         this.defaultTimeToLive = Message.DEFAULT_TIME_TO_LIVE;
1:         this.startTime = System.currentTimeMillis();
1:         this.messageSequence = new AtomicLong(0);
1:         this.stats = new JMSProducerStatsImpl(session.getSessionStats(), destination);
0:         this.session.addProducer(this);        
0:         this.session.asyncSendPacket(info);
1:     }
1: 
1:     public StatsImpl getStats() {
1:         return stats;
1:     }
1: 
1:     public JMSProducerStatsImpl getProducerStats() {
1:         return stats;
1:     }
1: 
1:     /**
0:      * Sets whether message IDs are disabled.
1:      * <P>
0:      * Since message IDs take some effort to create and increase a message's
0:      * size, some JMS providers may be able to optimize message overhead if
0:      * they are given a hint that the message ID is not used by an application.
0:      * By calling the <CODE>setDisableMessageID</CODE> method on this message
0:      * producer, a JMS client enables this potential optimization for all
0:      * messages sent by this message producer. If the JMS provider accepts this
0:      * hint, these messages must have the message ID set to null; if the
0:      * provider ignores the hint, the message ID must be set to its normal
0:      * unique value.
1:      * <P>
0:      * Message IDs are enabled by default.
0:      *
0:      * @param value indicates if message IDs are disabled
1:      * @throws JMSException if the JMS provider fails to close the producer due to
1:      *                      some internal error.
1:      */
0:     public void setDisableMessageID(boolean value) throws JMSException {
1:         checkClosed();
0:         this.disableMessageID = value;
1:     }
1: 
1:     /**
0:      * Gets an indication of whether message IDs are disabled.
0:      *
0:      * @return an indication of whether message IDs are disabled
0:      * @throws JMSException if the JMS provider fails to determine if message IDs are
0:      *                      disabled due to some internal error.
1:      */
0:     public boolean getDisableMessageID() throws JMSException {
1:         checkClosed();
0:         return this.disableMessageID;
1:     }
1: 
1:     /**
0:      * Sets whether message timestamps are disabled.
1:      * <P>
0:      * Since timestamps take some effort to create and increase a message's
0:      * size, some JMS providers may be able to optimize message overhead if
0:      * they are given a hint that the timestamp is not used by an application.
0:      * By calling the <CODE>setDisableMessageTimestamp</CODE> method on this
0:      * message producer, a JMS client enables this potential optimization for
0:      * all messages sent by this message producer. If the JMS provider accepts
0:      * this hint, these messages must have the timestamp set to zero; if the
0:      * provider ignores the hint, the timestamp must be set to its normal
0:      * value.
1:      * <P>
0:      * Message timestamps are enabled by default.
0:      *
0:      * @param value indicates if message timestamps are disabled
1:      * @throws JMSException if the JMS provider fails to close the producer due to
1:      *                      some internal error.
1:      */
0:     public void setDisableMessageTimestamp(boolean value) throws JMSException {
1:         checkClosed();
0:         this.disableMessageTimestamp = value;
1:     }
1: 
1:     /**
0:      * Gets an indication of whether message timestamps are disabled.
0:      *
0:      * @return an indication of whether message timestamps are disabled
1:      * @throws JMSException if the JMS provider fails to close the producer due to
1:      *                      some internal error.
1:      */
0:     public boolean getDisableMessageTimestamp() throws JMSException {
1:         checkClosed();
0:         return this.disableMessageTimestamp;
1:     }
1: 
1:     /**
0:      * Sets the producer's default delivery mode.
1:      * <P>
0:      * Delivery mode is set to <CODE>PERSISTENT</CODE> by default.
0:      *
0:      * @param newDeliveryMode the message delivery mode for this message producer; legal
0:      *                        values are <code>DeliveryMode.NON_PERSISTENT</code> and
0:      *                        <code>DeliveryMode.PERSISTENT</code>
0:      * @throws JMSException if the JMS provider fails to set the delivery mode due to
1:      *                      some internal error.
0:      * @see javax.jms.MessageProducer#getDeliveryMode
0:      * @see javax.jms.DeliveryMode#NON_PERSISTENT
0:      * @see javax.jms.DeliveryMode#PERSISTENT
0:      * @see javax.jms.Message#DEFAULT_DELIVERY_MODE
1:      */
0:     public void setDeliveryMode(int newDeliveryMode) throws JMSException {
0:         if (newDeliveryMode != DeliveryMode.PERSISTENT && newDeliveryMode != DeliveryMode.NON_PERSISTENT) {
0:             throw new IllegalStateException("unkown delivery mode: " + newDeliveryMode);
1:         }
1:         checkClosed();
0:         this.defaultDeliveryMode = newDeliveryMode;
1:     }
1: 
1:     /**
0:      * Gets the producer's default delivery mode.
0:      *
0:      * @return the message delivery mode for this message producer
1:      * @throws JMSException if the JMS provider fails to close the producer due to
1:      *                      some internal error.
1:      */
0:     public int getDeliveryMode() throws JMSException {
1:         checkClosed();
0:         return this.defaultDeliveryMode;
1:     }
1: 
1:     /**
0:      * Sets the producer's default priority.
1:      * <P>
0:      * The JMS API defines ten levels of priority value, with 0 as the lowest
0:      * priority and 9 as the highest. Clients should consider priorities 0-4 as
0:      * gradations of normal priority and priorities 5-9 as gradations of
0:      * expedited priority. Priority is set to 4 by default.
0:      *
0:      * @param newDefaultPriority the message priority for this message producer; must be a
0:      *                           value between 0 and 9
0:      * @throws JMSException if the JMS provider fails to set the delivery mode due to
1:      *                      some internal error.
0:      * @see javax.jms.MessageProducer#getPriority
0:      * @see javax.jms.Message#DEFAULT_PRIORITY
1:      */
0:     public void setPriority(int newDefaultPriority) throws JMSException {
0:         if (newDefaultPriority < 0 || newDefaultPriority > 9) {
0:             throw new IllegalStateException("default priority must be a value between 0 and 9");
1:         }
1:         checkClosed();
0:         this.defaultPriority = newDefaultPriority;
1:     }
1: 
1:     /**
0:      * Gets the producer's default priority.
0:      *
0:      * @return the message priority for this message producer
1:      * @throws JMSException if the JMS provider fails to close the producer due to
1:      *                      some internal error.
0:      * @see javax.jms.MessageProducer#setPriority
1:      */
0:     public int getPriority() throws JMSException {
1:         checkClosed();
0:         return this.defaultPriority;
1:     }
1: 
1:     /**
0:      * Sets the default length of time in milliseconds from its dispatch time
0:      * that a produced message should be retained by the message system.
1:      * <P>
0:      * Time to live is set to zero by default.
0:      *
0:      * @param timeToLive the message time to live in milliseconds; zero is unlimited
0:      * @throws JMSException if the JMS provider fails to set the time to live due to
1:      *                      some internal error.
0:      * @see javax.jms.MessageProducer#getTimeToLive
0:      * @see javax.jms.Message#DEFAULT_TIME_TO_LIVE
1:      */
0:     public void setTimeToLive(long timeToLive) throws JMSException {
0:         if (timeToLive < 0l) {
0:             throw new IllegalStateException("cannot set a negative timeToLive");
1:         }
1:         checkClosed();
0:         this.defaultTimeToLive = timeToLive;
1:     }
1: 
1:     /**
0:      * Gets the default length of time in milliseconds from its dispatch time
0:      * that a produced message should be retained by the message system.
0:      *
0:      * @return the message time to live in milliseconds; zero is unlimited
0:      * @throws JMSException if the JMS provider fails to get the time to live due to
1:      *                      some internal error.
0:      * @see javax.jms.MessageProducer#setTimeToLive
1:      */
0:     public long getTimeToLive() throws JMSException {
1:         checkClosed();
0:         return this.defaultTimeToLive;
1:     }
1: 
1:     /**
1:      * Gets the destination associated with this <CODE>MessageProducer</CODE>.
0:      *
1:      * @return this producer's <CODE>Destination/ <CODE>
1:      * @throws JMSException if the JMS provider fails to close the producer due to
1:      *                      some internal error.
1:      * @since 1.1
1:      */
1:     public Destination getDestination() throws JMSException {
1:         checkClosed();
1:         return this.info.getDestination();
1:     }
1: 
1:     /**
1:      * Closes the message producer.
1:      * <P>
1:      * Since a provider may allocate some resources on behalf of a <CODE>
0:      * MessageProducer</CODE> outside the Java virtual machine, clients should
0:      * close them when they are not needed. Relying on garbage collection to
0:      * eventually reclaim these resources may not be timely enough.
0:      *
1:      * @throws JMSException if the JMS provider fails to close the producer due to
1:      *                      some internal error.
1:      */
1:     public void close() throws JMSException {
0:         if( closed==false ) {
1:             dispose();
1:             this.session.asyncSendPacket(info.createRemoveCommand());
1:         }
1:     }
1: 
1:     public void dispose() {
0:         if( closed==false ) {
1:             this.session.removeProducer(this);
1:             closed = true;
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Check if the instance of this producer has been closed.
1:      * @throws IllegalStateException
1:      */
1:     protected void checkClosed() throws IllegalStateException {
1:         if (closed) {
1:             throw new IllegalStateException("The producer is closed");
1:         }
1:     }
1: 
1:     /**
0:      * Sends a message using the <CODE>MessageProducer</CODE>'s default
0:      * delivery mode, priority, and time to live.
0:      *
0:      * @param message the message to send
0:      * @throws JMSException                if the JMS provider fails to send the message due to some
0:      *                                     internal error.
0:      * @throws MessageFormatException      if an invalid message is specified.
0:      * @throws InvalidDestinationException if a client uses this method with a <CODE>
0:      *                                     MessageProducer</CODE> with an invalid destination.
0:      * @throws java.lang.UnsupportedOperationException
0:      *                                     if a client uses this method with a <CODE>
0:      *                                     MessageProducer</CODE> that did not specify a
0:      *                                     destination at creation time.
1:      * @see javax.jms.Session#createProducer
0:      * @see javax.jms.MessageProducer
1:      * @since 1.1
1:      */
0:     public void send(Message message) throws JMSException {
0:         this.send(this.getDestination(),
0:                   message,
0:                   this.defaultDeliveryMode,
0:                   this.defaultPriority,
0:                   this.defaultTimeToLive);
1:     }
1: 
1:     /**
0:      * Sends a message to the destination, specifying delivery mode, priority,
0:      * and time to live.
0:      *
0:      * @param message      the message to send
1:      * @param deliveryMode the delivery mode to use
0:      * @param priority     the priority for this message
0:      * @param timeToLive   the message's lifetime (in milliseconds)
0:      * @throws JMSException                if the JMS provider fails to send the message due to some
0:      *                                     internal error.
0:      * @throws MessageFormatException      if an invalid message is specified.
0:      * @throws InvalidDestinationException if a client uses this method with a <CODE>
0:      *                                     MessageProducer</CODE> with an invalid destination.
0:      * @throws java.lang.UnsupportedOperationException
0:      *                                     if a client uses this method with a <CODE>
0:      *                                     MessageProducer</CODE> that did not specify a
0:      *                                     destination at creation time.
1:      * @see javax.jms.Session#createProducer
1:      * @since 1.1
1:      */
0:     public void send(Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {
0:         this.send(this.getDestination(),
0:                   message,
0:                   deliveryMode,
0:                   priority,
0:                   timeToLive);
1:     }
1: 
1:     /**
0:      * Sends a message to a destination for an unidentified message producer.
0:      * Uses the <CODE>MessageProducer</CODE>'s default delivery mode,
0:      * priority, and time to live.
1:      * <P>
0:      * Typically, a message producer is assigned a destination at creation
0:      * time; however, the JMS API also supports unidentified message producers,
0:      * which require that the destination be supplied every time a message is
0:      * sent.
0:      *
0:      * @param destination the destination to send this message to
0:      * @param message     the message to send
0:      * @throws JMSException                if the JMS provider fails to send the message due to some
0:      *                                     internal error.
0:      * @throws MessageFormatException      if an invalid message is specified.
0:      * @throws InvalidDestinationException if a client uses this method with an invalid destination.
0:      * @throws java.lang.UnsupportedOperationException
0:      *                                     if a client uses this method with a <CODE>
0:      *                                     MessageProducer</CODE> that specified a destination at
0:      *                                     creation time.
1:      * @see javax.jms.Session#createProducer
0:      * @see javax.jms.MessageProducer
1:      */
0:     public void send(Destination destination, Message message) throws JMSException {
0:         this.send(destination,
0:                   message,
0:                   this.defaultDeliveryMode,
0:                   this.defaultPriority,
0:                   this.defaultTimeToLive);
1:     }
1: 
1:     /**
1:      * Sends a message to a destination for an unidentified message producer,
1:      * specifying delivery mode, priority and time to live.
1:      * <P>
0:      * Typically, a message producer is assigned a destination at creation
0:      * time; however, the JMS API also supports unidentified message producers,
0:      * which require that the destination be supplied every time a message is
0:      * sent.
0:      *
0:      * @param destination  the destination to send this message to
0:      * @param message      the message to send
1:      * @param deliveryMode the delivery mode to use
0:      * @param priority     the priority for this message
0:      * @param timeToLive   the message's lifetime (in milliseconds)
0:      * @throws JMSException                if the JMS provider fails to send the message due to some
0:      *                                     internal error.
0:      * @throws UnsupportedOperationException   if an invalid destination is specified.
0:      * @throws InvalidDestinationException if a client uses this method with an invalid destination.
1:      * @see javax.jms.Session#createProducer
1:      * @since 1.1
1:      */
0:     public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive)
0:             throws JMSException {
1:         checkClosed();
1:         if (destination == null) {
0:             if( info.getDestination() == null ) {
1:                 throw new UnsupportedOperationException("A destination must be specified.");
1:             }
1:             throw new InvalidDestinationException("Don't understand null destinations");
1:         }
1: 
0:         ActiveMQDestination dest; 
0:         if( destination == info.getDestination() ) {
0:             dest = (ActiveMQDestination) destination;
0:         } else  if ( info.getDestination() == null ) {
1:             dest = ActiveMQDestination.transform(destination);
1:         } else {
1:             throw new UnsupportedOperationException("This producer can only send messages to: " + this.info.getDestination().getPhysicalName());
1:         }
1:         
0:         this.session.send(this, dest, message, deliveryMode, priority, timeToLive);
0:         stats.onMessage();            
1:     }
1: 
1:     /**
1:      * @return the time in milli second when this object was created.
1:      */
1:     protected long getStartTime() {
1:         return this.startTime;
1:     }
1: 
1:     /**
1:      * @return Returns the messageSequence.
1:      */
1:     protected long getMessageSequence() {
1:         return messageSequence.incrementAndGet();
1:     }
1: 
1:     /**
1:      * @param messageSequence The messageSequence to set.
1:      */
1:     protected void setMessageSequence(AtomicLong messageSequence) {
1:         this.messageSequence = messageSequence;
1:     }
1: 
1:     /**
1:      * @return Returns the info.
1:      */
0:     protected ProducerInfo getProducerInfo(){
0:         return this.info!=null?this.info:null;
1:     }
1: 
1:     /**
1:      * @param info The info to set
1:      */
0:     protected  void setProducerInfo(ProducerInfo info){
1:         this.info = info;
1:     }
1: 
1:     public String toString() {
0:         return "ActiveMQMessageProducer { consumerId=" +info.getProducerId()+" }";
1:     }
1: 
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:aec2762
/////////////////////////////////////////////////////////////////////////
1:         if (destination.equals(info.getDestination())) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final JMSProducerStatsImpl stats;
1:     private final long startTime;
/////////////////////////////////////////////////////////////////////////
1:             producerWindow.setExecutor(session.getConnectionExecutor());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:114a923
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQMessageProducer(ActiveMQSession session, ProducerId producerId, ActiveMQDestination destination, int sendTimeout) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:         this.setSendTimeout(sendTimeout);
/////////////////////////////////////////////////////////////////////////
0:         this.session.send(this, dest, message, deliveryMode, priority, timeToLive, producerWindow,sendTimeout);
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.MemoryUsage;
/////////////////////////////////////////////////////////////////////////
1:     private MemoryUsage producerWindow;
/////////////////////////////////////////////////////////////////////////
1:             producerWindow = new MemoryUsage("Producer Window: " + producerId);
author:Gary Tully
-------------------------------------------------------------------------------
commit:9a432f2
/////////////////////////////////////////////////////////////////////////
1:             producerWindow.start();
/////////////////////////////////////////////////////////////////////////
1:             if (producerWindow != null) {
1:                 producerWindow.stop();
0:             }
author:James Strachan
-------------------------------------------------------------------------------
commit:677c22b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Destination;
0: import javax.jms.IllegalStateException;
0: import javax.jms.InvalidDestinationException;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import java.util.HashMap;
0: import java.util.concurrent.atomic.AtomicLong;
0: 
/////////////////////////////////////////////////////////////////////////
1: public class ActiveMQMessageProducer extends ActiveMQMessageProducerSupport implements StatsCapable, Disposable {
1:         super(session);
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:86faaef
/////////////////////////////////////////////////////////////////////////
1:     private MessageTransformer transformer;
/////////////////////////////////////////////////////////////////////////
1:         setTransformer(session.getTransformer());
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (transformer != null) {
1:             Message transformedMessage = transformer.producerTransform(session, this, message);
1:             if (transformedMessage != null) {
1:                 message = transformedMessage;
0:             }
0:         }
0: 
1:     public MessageTransformer getTransformer() {
1:         return transformer;
0:     }
0: 
0:     /**
0:      * Sets the transformer used to transform messages before they are sent on to the JMS bus
0:      */
1:     public void setTransformer(MessageTransformer transformer) {
1:         this.transformer = transformer;
0:     }
0: 
commit:4e1ec02
/////////////////////////////////////////////////////////////////////////
1:         if (dest == null) {
1:             throw new JMSException("No destination specified");
0:         }
============================================================================