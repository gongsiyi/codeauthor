2:4e5012c: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
2:6fbb568:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:4e5012c:  * Unless required by applicable law or agreed to in writing, software
1:4e5012c:  * distributed under the License is distributed on an "AS IS" BASIS,
1:4e5012c:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4e5012c:  * See the License for the specific language governing permissions and
1:4e5012c:  * limitations under the License.
4:4e5012c:  */
1:4e5012c: package org.apache.activemq.web;
1:755ffd5: 
1:4e5012c: import java.io.IOException;
1:4e5012c: import java.io.PrintWriter;
1:4e5012c: import java.io.StringWriter;
1:f32792a: import java.util.HashMap;
1:f32792a: import java.util.Iterator;
1:f32792a: import java.util.LinkedList;
1:f32792a: import java.util.List;
1:f32792a: import java.util.Map;
1:f32792a: import java.util.Timer;
1:f32792a: import java.util.TimerTask;
5:540dd5c: 
1:4e5012c: import javax.jms.Destination;
1:4e5012c: import javax.jms.JMSException;
1:4e5012c: import javax.jms.Message;
1:4e5012c: import javax.jms.MessageConsumer;
1:4e5012c: import javax.jms.ObjectMessage;
1:4e5012c: import javax.jms.TextMessage;
1:4e5012c: import javax.servlet.ServletConfig;
1:4e5012c: import javax.servlet.ServletException;
1:4e5012c: import javax.servlet.http.HttpServletRequest;
1:4e5012c: import javax.servlet.http.HttpServletResponse;
1:4e5012c: import javax.servlet.http.HttpSession;
1:540dd5c: 
1:4e5012c: import org.apache.activemq.MessageAvailableConsumer;
1:e8a06c4: import org.eclipse.jetty.continuation.Continuation;
1:5415f3a: import org.eclipse.jetty.continuation.ContinuationListener;
1:e8a06c4: import org.eclipse.jetty.continuation.ContinuationSupport;
1:f32792a: import org.slf4j.Logger;
1:f32792a: import org.slf4j.LoggerFactory;
1:540dd5c: 
1:4e5012c: /**
1:4e5012c:  * A servlet for sending and receiving messages to/from JMS destinations using
1:4e5012c:  * HTTP POST for sending and HTTP GET for receiving. <p/> You can specify the
1:4e5012c:  * destination and whether it is a topic or queue via configuration details on
1:4e5012c:  * the servlet or as request parameters. <p/> For reading messages you can
1:4e5012c:  * specify a readTimeout parameter to determine how long the servlet should
1:540dd5c:  * block for. The servlet can be configured with the following init parameters:
1:540dd5c:  * <dl>
1:540dd5c:  * <dt>defaultReadTimeout</dt>
1:540dd5c:  * <dd>The default time in ms to wait for messages. May be overridden by a
1:540dd5c:  * request using the 'timeout' parameter</dd>
1:540dd5c:  * <dt>maximumReadTimeout</dt>
1:540dd5c:  * <dd>The maximum value a request may specify for the 'timeout' parameter</dd>
1:540dd5c:  * <dt>maximumMessages</dt>
1:540dd5c:  * <dd>maximum messages to send per response</dd>
1:540dd5c:  * <dt></dt>
1:540dd5c:  * <dd></dd>
1:4060ad9:  * </dl>
1:d912424:  *
1:d912424:  *
1:4e5012c:  */
1:d912424: @SuppressWarnings("serial")
1:4e5012c: public class MessageListenerServlet extends MessageServletSupport {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(MessageListenerServlet.class);
1:d912424: 
1:5415f3a:     private final String readTimeoutParameter = "timeout";
1:4e5012c:     private long defaultReadTimeout = -1;
1:c6f73c5:     private long maximumReadTimeout = 25000;
1:4e5012c:     private int maximumMessages = 100;
1:5415f3a:     private final Timer clientCleanupTimer = new Timer("ActiveMQ Ajax Client Cleanup Timer", true);
1:5415f3a:     private final HashMap<String,AjaxWebClient> ajaxWebClients = new HashMap<String,AjaxWebClient>();
1:d912424: 
1:5415f3a:     @Override
1:4e5012c:     public void init() throws ServletException {
1:4e5012c:         ServletConfig servletConfig = getServletConfig();
1:4e5012c:         String name = servletConfig.getInitParameter("defaultReadTimeout");
1:4e5012c:         if (name != null) {
1:4e5012c:             defaultReadTimeout = asLong(name);
27:4e5012c:         }
1:4e5012c:         name = servletConfig.getInitParameter("maximumReadTimeout");
1:4e5012c:         if (name != null) {
1:4e5012c:             maximumReadTimeout = asLong(name);
1:4060ad9:         }
1:4e5012c:         name = servletConfig.getInitParameter("maximumMessages");
1:4e5012c:         if (name != null) {
1:540dd5c:             maximumMessages = (int)asLong(name);
1:4060ad9:         }
1:755ffd5:         clientCleanupTimer.schedule( new ClientCleaner(), 5000, 60000 );
1:c6f73c5:     }
1:d912424: 
1:4e5012c:     /**
1:540dd5c:      * Sends a message to a destination or manage subscriptions. If the the
1:540dd5c:      * content type of the POST is
1:540dd5c:      * <code>application/x-www-form-urlencoded</code>, then the form
1:540dd5c:      * parameters "destination", "message" and "type" are used to pass a message
1:540dd5c:      * or a subscription. If multiple messages or subscriptions are passed in a
1:540dd5c:      * single post, then additional parameters are shortened to "dN", "mN" and
1:540dd5c:      * "tN" where N is an index starting from 1. The type is either "send",
1:540dd5c:      * "listen" or "unlisten". For send types, the message is the text of the
1:540dd5c:      * TextMessage, otherwise it is the ID to be used for the subscription. If
1:540dd5c:      * the content type is not <code>application/x-www-form-urlencoded</code>,
1:540dd5c:      * then the body of the post is sent as the message to a destination that is
1:540dd5c:      * derived from a query parameter, the URL or the default destination.
1:d912424:      *
2:4e5012c:      * @param request
2:4e5012c:      * @param response
2:4e5012c:      * @throws ServletException
2:4e5012c:      * @throws IOException
1:d754e76:      */
1:5415f3a:     @Override
1:4e5012c:     protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:d912424: 
1:4e5012c:         // lets turn the HTTP post into a JMS Message
1:755ffd5:         AjaxWebClient client = getAjaxWebClient( request );
1:540dd5c:         String messageIds = "";
1:d912424: 
1:92b9d86:         synchronized (client) {
1:d912424: 
1:540dd5c:             if (LOG.isDebugEnabled()) {
1:755ffd5:                 LOG.debug("POST client=" + client + " session=" + request.getSession().getId() + " clientId="+ request.getParameter("clientId") + " info=" + request.getPathInfo() + " contentType=" + request.getContentType());
1:540dd5c:                 // dump(request.getParameterMap());
1:c6f73c5:             }
1:755ffd5: 
1:540dd5c:             int messages = 0;
1:755ffd5: 
1:6fbb568:             // loop until no more messages
1:540dd5c:             while (true) {
1:540dd5c:                 // Get the message parameters. Multiple messages are encoded
1:540dd5c:                 // with more compact parameter names.
1:540dd5c:                 String destinationName = request.getParameter(messages == 0 ? "destination" : ("d" + messages));
1:755ffd5: 
1:540dd5c:                 if (destinationName == null) {
1:540dd5c:                     destinationName = request.getHeader("destination");
1:540dd5c:                 }
1:755ffd5: 
1:540dd5c:                 String message = request.getParameter(messages == 0 ? "message" : ("m" + messages));
1:540dd5c:                 String type = request.getParameter(messages == 0 ? "type" : ("t" + messages));
1:755ffd5: 
1:540dd5c:                 if (destinationName == null || message == null || type == null) {
1:88fc7fe:                     break;
1:540dd5c:                 }
1:755ffd5: 
1:b73b8bc:                 try {
1:540dd5c:                     Destination destination = getDestination(client, request, destinationName);
1:c6ede16: 
1:540dd5c:                     if (LOG.isDebugEnabled()) {
1:540dd5c:                         LOG.debug(messages + " destination=" + destinationName + " message=" + message + " type=" + type);
1:540dd5c:                         LOG.debug(destination + " is a " + destination.getClass().getName());
1:b73b8bc:                     }
1:540dd5c: 
1:88fc7fe:                     messages++;
1:540dd5c: 
1:540dd5c:                     if ("listen".equals(type)) {
1:755ffd5:                         AjaxListener listener = client.getListener();
1:755ffd5:                         Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();
1:755ffd5:                         Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();
1:540dd5c:                         client.closeConsumer(destination); // drop any existing
1:540dd5c:                         // consumer.
1:a05e84e:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));
1:c6ede16: 
1:92b9d86:                         consumer.setAvailableListener(listener);
1:6fbb568:                         consumerIdMap.put(consumer, message);
1:755ffd5:                         consumerDestinationNameMap.put(consumer, destinationName);
1:540dd5c:                         if (LOG.isDebugEnabled()) {
1:540dd5c:                             LOG.debug("Subscribed: " + consumer + " to " + destination + " id=" + message);
1:92b9d86:                         }
1:540dd5c:                     } else if ("unlisten".equals(type)) {
1:755ffd5:                         Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();
1:d912424:                         Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();
1:a05e84e:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));
1:c6ede16: 
1:92b9d86:                         consumer.setAvailableListener(null);
1:92b9d86:                         consumerIdMap.remove(consumer);
1:755ffd5:                         consumerDestinationNameMap.remove(consumer);
1:4060ad9:                         client.closeConsumer(destination);
1:540dd5c:                         if (LOG.isDebugEnabled()) {
1:540dd5c:                             LOG.debug("Unsubscribed: " + consumer);
1:92b9d86:                         }
1:540dd5c:                     } else if ("send".equals(type)) {
1:6fbb568:                         TextMessage text = client.getSession().createTextMessage(message);
1:6fbb568:                         appendParametersToMessage(request, text);
1:540dd5c: 
1:6fbb568:                         client.send(destination, text);
1:540dd5c:                         messageIds += text.getJMSMessageID() + "\n";
1:540dd5c:                         if (LOG.isDebugEnabled()) {
1:540dd5c:                             LOG.debug("Sent " + message + " to " + destination);
1:92b9d86:                         }
1:540dd5c:                     } else {
1:540dd5c:                         LOG.warn("unknown type " + type);
1:4e5012c:                     }
1:540dd5c: 
1:540dd5c:                 } catch (JMSException e) {
1:540dd5c:                     LOG.warn("jms", e);
1:4e5012c:                 }
1:4e5012c:             }
1:4e5012c:         }
1:540dd5c: 
1:540dd5c:         if ("true".equals(request.getParameter("poll"))) {
1:540dd5c:             try {
1:8cb2141:                 // TODO return message IDs
1:540dd5c:                 doMessages(client, request, response);
1:540dd5c:             } catch (JMSException e) {
1:4e5012c:                 throw new ServletException("JMS problem: " + e, e);
1:c6f73c5:             }
1:540dd5c:         } else {
1:8cb2141:             // handle simple POST of a message
1:540dd5c:             if (request.getContentLength() != 0 && (request.getContentType() == null || !request.getContentType().toLowerCase().startsWith("application/x-www-form-urlencoded"))) {
1:d754e76:                 try {
1:540dd5c:                     Destination destination = getDestination(client, request);
1:d754e76:                     String body = getPostedMessageBody(request);
1:540dd5c:                     TextMessage message = client.getSession().createTextMessage(body);
1:4e5012c:                     appendParametersToMessage(request, message);
1:540dd5c: 
1:d754e76:                     client.send(destination, message);
1:540dd5c:                     if (LOG.isDebugEnabled()) {
1:540dd5c:                         LOG.debug("Sent to destination: " + destination + " body: " + body);
1:d754e76:                     }
1:540dd5c:                     messageIds += message.getJMSMessageID() + "\n";
1:540dd5c:                 } catch (JMSException e) {
1:d754e76:                     throw new ServletException(e);
1:8cb2141:                 }
1:8cb2141:             }
1:540dd5c: 
1:8cb2141:             response.setContentType("text/plain");
1:d754e76:             response.setHeader("Cache-Control", "no-cache");
1:540dd5c:             response.getWriter().print(messageIds);
1:92b9d86:         }
1:92b9d86:     }
1:540dd5c: 
1:4e5012c:     /**
1:4e5012c:      * Supports a HTTP DELETE to be equivlanent of consuming a singe message
1:4e5012c:      * from a queue
1:4e5012c:      */
1:5415f3a:     @Override
1:4e5012c:     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:8cb2141:         try {
1:755ffd5:             AjaxWebClient client = getAjaxWebClient(request);
1:540dd5c:             if (LOG.isDebugEnabled()) {
1:755ffd5:                 LOG.debug("GET client=" + client + " session=" + request.getSession().getId() + " clientId="+ request.getParameter("clientId") + " uri=" + request.getRequestURI() + " query=" + request.getQueryString());
1:92b9d86:             }
1:540dd5c: 
1:92b9d86:             doMessages(client, request, response);
1:540dd5c:         } catch (JMSException e) {
1:92b9d86:             throw new ServletException("JMS problem: " + e, e);
1:92b9d86:         }
1:92b9d86:     }
1:540dd5c: 
1:4e5012c:     /**
1:4e5012c:      * Reads a message from a destination up to some specific timeout period
1:d912424:      *
1:540dd5c:      * @param client The webclient
1:4e5012c:      * @param request
1:4e5012c:      * @param response
1:4e5012c:      * @throws ServletException
1:4e5012c:      * @throws IOException
1:4e5012c:      */
1:755ffd5:     protected void doMessages(AjaxWebClient client, HttpServletRequest request, HttpServletResponse response) throws JMSException, IOException {
1:540dd5c: 
1:4e5012c:         int messages = 0;
1:4e5012c:         // This is a poll for any messages
1:540dd5c: 
1:4e5012c:         long timeout = getReadTimeout(request);
1:540dd5c:         if (LOG.isDebugEnabled()) {
1:540dd5c:             LOG.debug("doMessage timeout=" + timeout);
1:540dd5c:         }
1:d912424: 
1:88fc7fe:         // this is non-null if we're resuming the continuation.
1:88fc7fe:         // attributes set in AjaxListener
1:c6ede16:         UndeliveredAjaxMessage undelivered_message = null;
1:c6ede16:         Message message = null;
1:c6ede16:         undelivered_message = (UndeliveredAjaxMessage)request.getAttribute("undelivered_message");
1:c6ede16:         if( undelivered_message != null ) {
1:5415f3a:             message = undelivered_message.getMessage();
1:c6ede16:         }
1:d912424: 
4:4e5012c:         synchronized (client) {
1:b73b8bc: 
1:d912424:             List<MessageConsumer> consumers = client.getConsumers();
1:c6ede16:             MessageAvailableConsumer consumer = null;
1:c6ede16:             if( undelivered_message != null ) {
1:c6ede16:                 consumer = (MessageAvailableConsumer)undelivered_message.getConsumer();
1:c6ede16:             }
1:b73b8bc: 
1:b73b8bc:             if (message == null) {
1:b73b8bc:                 // Look for a message that is ready to go
1:b73b8bc:                 for (int i = 0; message == null && i < consumers.size(); i++) {
1:b73b8bc:                     consumer = (MessageAvailableConsumer)consumers.get(i);
1:b73b8bc:                     if (consumer.getAvailableListener() == null) {
1:b73b8bc:                         continue;
1:b73b8bc:                     }
1:d912424: 
1:b73b8bc:                     // Look for any available messages
1:b73b8bc:                     message = consumer.receive(10);
1:b73b8bc:                     if (LOG.isDebugEnabled()) {
1:b73b8bc:                         LOG.debug("received " + message + " from " + consumer);
1:b73b8bc:                     }
1:540dd5c:                 }
1:540dd5c:             }
1:b73b8bc: 
1:755ffd5:             // prepare the response
1:755ffd5:             response.setContentType("text/xml");
1:755ffd5:             response.setHeader("Cache-Control", "no-cache");
1:d912424: 
1:c6ede16:             if (message == null && client.getListener().getUndeliveredMessages().size() == 0) {
1:b73b8bc:                 Continuation continuation = ContinuationSupport.getContinuation(request);
1:d912424: 
1:5415f3a:                 // Add a listener to the continuation to make sure it actually
1:166ab43:                 // will expire (seems like a bug in Jetty Servlet 3 continuations,
1:5415f3a:                 // see https://issues.apache.org/jira/browse/AMQ-3447
1:5415f3a:                 continuation.addContinuationListener(new ContinuationListener() {
1:5415f3a:                     @Override
1:5415f3a:                     public void onTimeout(Continuation cont) {
1:5415f3a:                         if (LOG.isDebugEnabled()) {
1:166ab43:                             LOG.debug("Continuation " + cont.toString() + " expired.");
1:5415f3a:                         }
1:5415f3a:                     }
1:5415f3a: 
1:5415f3a:                     @Override
1:5415f3a:                     public void onComplete(Continuation cont) {
1:5415f3a:                         if (LOG.isDebugEnabled()) {
1:166ab43:                            LOG.debug("Continuation " + cont.toString() + " completed.");
1:5415f3a:                         }
1:5415f3a:                     }
1:5415f3a:                 });
1:5415f3a: 
1:bef96a9:                 if (continuation.isExpired()) {
1:b73b8bc:                     response.setStatus(HttpServletResponse.SC_OK);
1:b73b8bc:                     StringWriter swriter = new StringWriter();
1:b73b8bc:                     PrintWriter writer = new PrintWriter(swriter);
1:b73b8bc:                     writer.println("<ajax-response>");
1:b73b8bc:                     writer.print("</ajax-response>");
1:755ffd5: 
1:b73b8bc:                     writer.flush();
1:b73b8bc:                     String m = swriter.toString();
1:d912424:                     response.getWriter().println(m);
1:d912424: 
1:b73b8bc:                     return;
1:b73b8bc:                 }
1:b73b8bc: 
1:25f4766:                 continuation.setTimeout(timeout);
1:e8a06c4:                 continuation.suspend();
1:88fc7fe:                 LOG.debug( "Suspending continuation " + continuation );
1:d912424: 
1:b73b8bc:                 // Fetch the listeners
1:755ffd5:                 AjaxListener listener = client.getListener();
1:bef96a9:                 listener.access();
1:755ffd5: 
1:b73b8bc:                 // register this continuation with our listener.
1:b73b8bc:                 listener.setContinuation(continuation);
1:d912424: 
1:25f4766:                 return;
1:d754e76:             }
1:d912424: 
1:4e5012c:             StringWriter swriter = new StringWriter();
1:4e5012c:             PrintWriter writer = new PrintWriter(swriter);
1:d912424: 
1:755ffd5:             Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();
1:755ffd5:             Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();
1:4e5012c:             response.setStatus(HttpServletResponse.SC_OK);
1:4e5012c:             writer.println("<ajax-response>");
1:b73b8bc: 
1:4e5012c:             // Send any message we already have
1:4e5012c:             if (message != null) {
1:bef96a9:                 String id = consumerIdMap.get(consumer);
1:bef96a9:                 String destinationName = consumerDestinationNameMap.get(consumer);
1:c6ede16:                 LOG.debug( "sending pre-existing message" );
1:b73b8bc:                 writeMessageResponse(writer, message, id, destinationName);
1:d912424: 
1:bef96a9:                 messages++;
1:d754e76:             }
1:d912424: 
1:c6ede16:             // send messages buffered while continuation was unavailable.
1:c6ede16:             LinkedList<UndeliveredAjaxMessage> undeliveredMessages = ((AjaxListener)consumer.getAvailableListener()).getUndeliveredMessages();
1:c6ede16:             LOG.debug("Send " + undeliveredMessages.size() + " unconsumed messages");
1:c6ede16:             synchronized( undeliveredMessages ) {
1:166ab43:                 for (Iterator<UndeliveredAjaxMessage> it = undeliveredMessages.iterator(); it.hasNext();) {
1:c6ede16:                     messages++;
1:c6ede16:                     UndeliveredAjaxMessage undelivered = it.next();
1:5415f3a:                     Message msg = undelivered.getMessage();
1:c6ede16:                     consumer = (MessageAvailableConsumer)undelivered.getConsumer();
1:c6ede16:                     String id = consumerIdMap.get(consumer);
1:c6ede16:                     String destinationName = consumerDestinationNameMap.get(consumer);
1:c6ede16:                     LOG.debug( "sending undelivered/buffered messages" );
1:c6ede16:                     LOG.debug( "msg:" +msg+ ", id:" +id+ ", destinationName:" +destinationName);
1:bef96a9:                     writeMessageResponse(writer, msg, id, destinationName);
1:c6ede16:                     it.remove();
1:bef96a9:                     if (messages >= maximumMessages) {
1:bef96a9:                         break;
1:bef96a9:                     }
1:bef96a9:                 }
1:c6ede16:             }
1:bef96a9: 
1:4e5012c:             // Send the rest of the messages
1:4e5012c:             for (int i = 0; i < consumers.size() && messages < maximumMessages; i++) {
1:540dd5c:                 consumer = (MessageAvailableConsumer)consumers.get(i);
1:540dd5c:                 if (consumer.getAvailableListener() == null) {
2:4e5012c:                     continue;
1:c6ede16:                 }
1:b73b8bc: 
2:4e5012c:                 // Look for any available messages
1:b043ebe:                 while (messages < maximumMessages) {
1:b043ebe:                     message = consumer.receiveNoWait();
1:b73b8bc:                     if (message == null) {
1:c6ede16:                         break;
1:c6ede16:                     }
1:b043ebe:                     messages++;
1:88fc7fe:                     String id = consumerIdMap.get(consumer);
1:88fc7fe:                     String destinationName = consumerDestinationNameMap.get(consumer);
1:c6ede16:                     LOG.debug( "sending final available messages" );
1:b73b8bc:                     writeMessageResponse(writer, message, id, destinationName);
1:88fc7fe:                 }
1:b043ebe:             }
1:b73b8bc: 
1:92b9d86:             writer.print("</ajax-response>");
1:b73b8bc: 
1:4e5012c:             writer.flush();
1:4e5012c:             String m = swriter.toString();
1:b73b8bc:             response.getWriter().println(m);
1:92b9d86:         }
1:92b9d86:     }
1:b73b8bc: 
1:b73b8bc:     protected void writeMessageResponse(PrintWriter writer, Message message, String id, String destinationName) throws JMSException, IOException {
1:b73b8bc:         writer.print("<response id='");
1:b73b8bc:         writer.print(id);
1:b73b8bc:         writer.print("'");
1:b73b8bc:         if (destinationName != null) {
1:b73b8bc:             writer.print(" destination='" + destinationName + "' ");
1:b73b8bc:         }
1:b73b8bc:         writer.print(">");
1:4e5012c:         if (message instanceof TextMessage) {
1:540dd5c:             TextMessage textMsg = (TextMessage)message;
1:aa2188c:             String txt = textMsg.getText();
1:a1b235d:             if (txt != null) {
1:a1b235d:                 if (txt.startsWith("<?")) {
1:a1b235d:                     txt = txt.substring(txt.indexOf("?>") + 2);
1:a1b235d:                 }
1:a1b235d:                 writer.print(txt);
1:540dd5c:             }
1:4e5012c:         } else if (message instanceof ObjectMessage) {
1:540dd5c:             ObjectMessage objectMsg = (ObjectMessage)message;
1:4e5012c:             Object object = objectMsg.getObject();
1:a1b235d:             if (object != null) {
1:a1b235d:                 writer.print(object.toString());
1:a1b235d:             }
1:540dd5c:         }
1:b73b8bc:         writer.println("</response>");
1:92b9d86:     }
1:d912424: 
1:755ffd5:     /*
1:755ffd5:      * Return the AjaxWebClient for this session+clientId.
1:755ffd5:      * Create one if it does not already exist.
1:755ffd5:      */
1:755ffd5:     protected AjaxWebClient getAjaxWebClient( HttpServletRequest request ) {
1:540dd5c:         HttpSession session = request.getSession(true);
1:d912424: 
1:d912424:         String clientId = request.getParameter( "clientId" );
1:755ffd5:         // if user doesn't supply a 'clientId', we'll just use a default.
1:755ffd5:         if( clientId == null ) {
1:755ffd5:             clientId = "defaultAjaxWebClient";
1:540dd5c:         }
1:755ffd5:         String sessionKey = session.getId() + '-' + clientId;
1:d912424: 
1:f32792a:         AjaxWebClient client = null;
1:755ffd5:         synchronized (ajaxWebClients) {
1:f32792a:             client = ajaxWebClients.get( sessionKey );
1:755ffd5:             // create a new AjaxWebClient if one does not already exist for this sessionKey.
1:755ffd5:             if( client == null ) {
1:755ffd5:                 if (LOG.isDebugEnabled()) {
1:755ffd5:                     LOG.debug( "creating new AjaxWebClient in "+sessionKey );
1:755ffd5:                 }
1:755ffd5:                 client = new AjaxWebClient( request, maximumReadTimeout );
1:755ffd5:                 ajaxWebClients.put( sessionKey, client );
1:755ffd5:             }
1:755ffd5:             client.updateLastAccessed();
1:955cece:         }
1:755ffd5:         return client;
1:955cece:     }
1:755ffd5: 
1:4e5012c:     /**
1:4e5012c:      * @return the timeout value for read requests which is always >= 0 and <=
1:4e5012c:      *         maximumReadTimeout to avoid DoS attacks
1:4e5012c:      */
1:4e5012c:     protected long getReadTimeout(HttpServletRequest request) {
1:4e5012c:         long answer = defaultReadTimeout;
1:755ffd5: 
1:4e5012c:         String name = request.getParameter(readTimeoutParameter);
1:4e5012c:         if (name != null) {
1:4e5012c:             answer = asLong(name);
1:4e5012c:         }
1:4e5012c:         if (answer < 0 || answer > maximumReadTimeout) {
1:4e5012c:             answer = maximumReadTimeout;
1:4e5012c:         }
1:4e5012c:         return answer;
1:4e5012c:     }
1:d912424: 
1:d754e76:     /*
1:755ffd5:      * an instance of this class runs every minute (started in init), to clean up old web clients & free resources.
1:4e5012c:      */
1:755ffd5:     private class ClientCleaner extends TimerTask {
1:5415f3a:         @Override
1:755ffd5:         public void run() {
1:755ffd5:             if( LOG.isDebugEnabled() ) {
1:755ffd5:                 LOG.debug( "Cleaning up expired web clients." );
1:d0c46a7:             }
1:d912424: 
1:755ffd5:             synchronized( ajaxWebClients ) {
1:d912424:                 Iterator<Map.Entry<String, AjaxWebClient>> it = ajaxWebClients.entrySet().iterator();
1:755ffd5:                 while ( it.hasNext() ) {
1:d912424:                     Map.Entry<String,AjaxWebClient> e = it.next();
1:755ffd5:                     String key = e.getKey();
1:755ffd5:                     AjaxWebClient val = e.getValue();
1:755ffd5:                     if ( LOG.isDebugEnabled() ) {
1:755ffd5:                         LOG.debug( "AjaxWebClient " + key + " last accessed " + val.getMillisSinceLastAccessed()/1000 + " seconds ago." );
1:4e5012c:                     }
1:755ffd5:                     // close an expired client and remove it from the ajaxWebClients hash.
1:755ffd5:                     if( val.closeIfExpired() ) {
1:755ffd5:                         if ( LOG.isDebugEnabled() ) {
1:755ffd5:                             LOG.debug( "Removing expired AjaxWebClient " + key );
1:755ffd5:                         }
1:755ffd5:                         it.remove();
1:755ffd5:                     }
1:755ffd5:                 }
1:4e5012c:             }
1:4e5012c:         }
1:4e5012c:     }
1:c6ede16: 
1:5415f3a:     @Override
1:d912424:     public void destroy() {
1:d912424:         // make sure we cancel the timer
1:d912424:         clientCleanupTimer.cancel();
1:d912424:         super.destroy();
1:d912424:     }
1:4e5012c: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:166ab43
/////////////////////////////////////////////////////////////////////////
1:                 // will expire (seems like a bug in Jetty Servlet 3 continuations,
1:                             LOG.debug("Continuation " + cont.toString() + " expired.");
1:                            LOG.debug("Continuation " + cont.toString() + " completed.");
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<UndeliveredAjaxMessage> it = undeliveredMessages.iterator(); it.hasNext();) {
/////////////////////////////////////////////////////////////////////////
commit:5415f3a
/////////////////////////////////////////////////////////////////////////
1: import org.eclipse.jetty.continuation.ContinuationListener;
/////////////////////////////////////////////////////////////////////////
1:     private final String readTimeoutParameter = "timeout";
1:     private final Timer clientCleanupTimer = new Timer("ActiveMQ Ajax Client Cleanup Timer", true);
1:     private final HashMap<String,AjaxWebClient> ajaxWebClients = new HashMap<String,AjaxWebClient>();
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             message = undelivered_message.getMessage();
/////////////////////////////////////////////////////////////////////////
1:                 // Add a listener to the continuation to make sure it actually
0:                 // will expire (seems like a bug in Jetty Servlet 3 continuations, 
1:                 // see https://issues.apache.org/jira/browse/AMQ-3447
1:                 continuation.addContinuationListener(new ContinuationListener() {
1:                     @Override
1:                     public void onTimeout(Continuation cont) {
1:                         if (LOG.isDebugEnabled()) {
0:                              LOG.debug("Continuation " + cont.toString() + " expired.");
1:                         }
1:                     }
1: 
1:                     @Override
1:                     public void onComplete(Continuation cont) {
1:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Continuation " + cont.toString() + " completed.");
1:                         }
1:                     }
1:                 });
1: 
/////////////////////////////////////////////////////////////////////////
1:                     Message msg = undelivered.getMessage();
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:a1b235d
/////////////////////////////////////////////////////////////////////////
1:             if (txt != null) {
1:                 if (txt.startsWith("<?")) {
1:                     txt = txt.substring(txt.indexOf("?>") + 2);
1:                 }
1:                 writer.print(txt);
1:             if (object != null) {
1:                 writer.print(object.toString());
1:             }
commit:f32792a
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Timer;
1: import java.util.TimerTask;
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:         AjaxWebClient client = null;
1:             client = ajaxWebClients.get( sessionKey );
commit:d912424
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1: @SuppressWarnings("serial")
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:                         Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             List<MessageConsumer> consumers = client.getConsumers();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                     response.getWriter().println(m);
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         String clientId = request.getParameter( "clientId" );
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                 Iterator<Map.Entry<String, AjaxWebClient>> it = ajaxWebClients.entrySet().iterator();
1:                     Map.Entry<String,AjaxWebClient> e = it.next();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void destroy() {
1:         // make sure we cancel the timer
1:         clientCleanupTimer.cancel();
1:         super.destroy();
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:faa8d79
/////////////////////////////////////////////////////////////////////////
0:     private Timer clientCleanupTimer = new Timer("ActiveMQ Ajax Client Cleanup Timer", true);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(MessageListenerServlet.class);
commit:bef96a9
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:             if (message == null && client.getListener().getUnconsumedMessages().size() == 0) {
1:                 if (continuation.isExpired()) {
/////////////////////////////////////////////////////////////////////////
1:                 listener.access();
/////////////////////////////////////////////////////////////////////////
0:                 LinkedList<Message> unconsumedMessages = ((AjaxListener)consumer.getAvailableListener()).getUnconsumedMessages();
0:                 LOG.debug("Send " + unconsumedMessages.size() + " unconsumed messages");
0:                 for (Message msg : unconsumedMessages) {
1:                     messages++;
1:                     String id = consumerIdMap.get(consumer);
1:                     String destinationName = consumerDestinationNameMap.get(consumer);
1:                     writeMessageResponse(writer, msg, id, destinationName);
1:                     if (messages >= maximumMessages) {
1:                         break;
1:                     }
1:                 }
1: 
commit:755ffd5
/////////////////////////////////////////////////////////////////////////
0: import java.util.Date;
0: import java.util.Iterator;
0: import java.util.Timer;
0: import java.util.TimerTask;
/////////////////////////////////////////////////////////////////////////
1:     
0:     private Timer clientCleanupTimer = new Timer();
0:     private HashMap<String,AjaxWebClient> ajaxWebClients = new HashMap<String,AjaxWebClient>();
1:     
/////////////////////////////////////////////////////////////////////////
1:         clientCleanupTimer.schedule( new ClientCleaner(), 5000, 60000 );
1:     
/////////////////////////////////////////////////////////////////////////
1:         AjaxWebClient client = getAjaxWebClient( request );
1:                 LOG.debug("POST client=" + client + " session=" + request.getSession().getId() + " clientId="+ request.getParameter("clientId") + " info=" + request.getPathInfo() + " contentType=" + request.getContentType());
/////////////////////////////////////////////////////////////////////////
1:                         AjaxListener listener = client.getListener();
1:                         Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();
1:                         Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();
1:                         consumerDestinationNameMap.put(consumer, destinationName);
1:                         Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();
0:                         Map consumerDestinationNameMap = client.getDestinationNameMap();
1:                         consumerDestinationNameMap.remove(consumer);
/////////////////////////////////////////////////////////////////////////
1:             AjaxWebClient client = getAjaxWebClient(request);
1:                 LOG.debug("GET client=" + client + " session=" + request.getSession().getId() + " clientId="+ request.getParameter("clientId") + " uri=" + request.getRequestURI() + " query=" + request.getQueryString());
/////////////////////////////////////////////////////////////////////////
1:     protected void doMessages(AjaxWebClient client, HttpServletRequest request, HttpServletResponse response) throws JMSException, IOException {
/////////////////////////////////////////////////////////////////////////
1:             
1:             // prepare the response
1:             response.setContentType("text/xml");
1:             response.setHeader("Cache-Control", "no-cache");
1:             
/////////////////////////////////////////////////////////////////////////
1:                 AjaxListener listener = client.getListener();
1:             
1:             Map<MessageAvailableConsumer, String> consumerIdMap = client.getIdMap();
1:             Map<MessageAvailableConsumer, String> consumerDestinationNameMap = client.getDestinationNameMap();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
1:      * Return the AjaxWebClient for this session+clientId.
1:      * Create one if it does not already exist.
1:      */
1:     protected AjaxWebClient getAjaxWebClient( HttpServletRequest request ) {
0:         long now = (new Date()).getTime();
1:         
0:         String clientId = request.getParameter( "clientId" );      
1:         // if user doesn't supply a 'clientId', we'll just use a default.
1:         if( clientId == null ) {
1:             clientId = "defaultAjaxWebClient";
1:         String sessionKey = session.getId() + '-' + clientId;
1:         
0:         AjaxWebClient client = ajaxWebClients.get( sessionKey );
1:         synchronized (ajaxWebClients) {
1:             // create a new AjaxWebClient if one does not already exist for this sessionKey.
1:             if( client == null ) {
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug( "creating new AjaxWebClient in "+sessionKey );
1:                 }
1:                 client = new AjaxWebClient( request, maximumReadTimeout );
1:                 ajaxWebClients.put( sessionKey, client );
1:             }
1:             client.updateLastAccessed();
1:         return client;
/////////////////////////////////////////////////////////////////////////
1:     
1:      * an instance of this class runs every minute (started in init), to clean up old web clients & free resources.
1:     private class ClientCleaner extends TimerTask {
1:         public void run() {
1:             if( LOG.isDebugEnabled() ) {
1:                 LOG.debug( "Cleaning up expired web clients." );
1:             
1:             synchronized( ajaxWebClients ) {
0:                 Iterator it = ajaxWebClients.entrySet().iterator();
1:                 while ( it.hasNext() ) {
0:                     Map.Entry<String,AjaxWebClient> e = (Map.Entry<String,AjaxWebClient>)it.next();
1:                     String key = e.getKey();
1:                     AjaxWebClient val = e.getValue();
1:                     if ( LOG.isDebugEnabled() ) {
1:                         LOG.debug( "AjaxWebClient " + key + " last accessed " + val.getMillisSinceLastAccessed()/1000 + " seconds ago." );
1:                     // close an expired client and remove it from the ajaxWebClients hash.
1:                     if( val.closeIfExpired() ) {
1:                         if ( LOG.isDebugEnabled() ) {
1:                             LOG.debug( "Removing expired AjaxWebClient " + key );
1:                         }
1:                         it.remove();
1:                     }
1:                 }
commit:b73b8bc
/////////////////////////////////////////////////////////////////////////
0:         message = (Message)request.getAttribute("message"); 
1:         
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer)request.getAttribute("consumer");
1:             if (message == null) {
1:                 // Look for a message that is ready to go
1:                 for (int i = 0; message == null && i < consumers.size(); i++) {
1:                     consumer = (MessageAvailableConsumer)consumers.get(i);
1:                     if (consumer.getAvailableListener() == null) {
1:                         continue;
1:                     }
1:     
1:                     // Look for any available messages
1:                     message = consumer.receive(10);
1:                     if (LOG.isDebugEnabled()) {
1:                         LOG.debug("received " + message + " from " + consumer);
1:                     }
1:             if (message == null) {
1:                 Continuation continuation = ContinuationSupport.getContinuation(request);
1:                 
0:                 if (continuation.isExpired()) {  
1:                     response.setStatus(HttpServletResponse.SC_OK);
1:                     StringWriter swriter = new StringWriter();
1:                     PrintWriter writer = new PrintWriter(swriter);
1:                     writer.println("<ajax-response>");
1:                     writer.print("</ajax-response>");
1:                     writer.flush();
1:                     String m = swriter.toString();
1:                     response.getWriter().println(m); 
1:                     
1:                     return;
1:                 }
1:                 
1:                 // Fetch the listeners
0:                 Listener listener = getListener(request);
1: 
1:                 // register this continuation with our listener.
1:                 listener.setContinuation(continuation);
1:                 
1:             
/////////////////////////////////////////////////////////////////////////
1:                 writeMessageResponse(writer, message, id, destinationName);
1:                 
/////////////////////////////////////////////////////////////////////////
1:                     writeMessageResponse(writer, message, id, destinationName);
/////////////////////////////////////////////////////////////////////////
1:     protected void writeMessageResponse(PrintWriter writer, Message message, String id, String destinationName) throws JMSException, IOException {
1:         writer.print("<response id='");
1:         writer.print(id);
1:         writer.print("'");
1:         if (destinationName != null) {
1:             writer.print(" destination='" + destinationName + "' ");
1:         }
1:         writer.print(">");
/////////////////////////////////////////////////////////////////////////
1:         writer.println("</response>");
/////////////////////////////////////////////////////////////////////////
1:                     try {
0:                         Message message = consumer.receive(10);
0:                         continuation.setAttribute("message", message);
0:                         continuation.setAttribute("consumer", consumer);
0:                     } catch (Exception e) {
0:                         LOG.error("Error receiving message " + e, e);
1:                     }
0:                     continuation.resume();
/////////////////////////////////////////////////////////////////////////
commit:a05e84e
/////////////////////////////////////////////////////////////////////////
1:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));
/////////////////////////////////////////////////////////////////////////
1:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.selectorName));
commit:ce9f83c
/////////////////////////////////////////////////////////////////////////
0:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.SELECTOR_NAME));
/////////////////////////////////////////////////////////////////////////
0:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination, request.getHeader(WebClient.SELECTOR_NAME));
commit:25f4766
/////////////////////////////////////////////////////////////////////////
0:         if (listener != null && continuation != null && !continuation.isInitial()) {
/////////////////////////////////////////////////////////////////////////
0:             if (message == null && continuation.isInitial()) {
1:                 continuation.setTimeout(timeout);
1:                 return;
commit:5a7ceac
/////////////////////////////////////////////////////////////////////////
0:         continuation.setTimeout(timeout);
commit:e8a06c4
/////////////////////////////////////////////////////////////////////////
1: import org.eclipse.jetty.continuation.Continuation;
1: import org.eclipse.jetty.continuation.ContinuationSupport;
/////////////////////////////////////////////////////////////////////////
0:         Continuation continuation = ContinuationSupport.getContinuation(request);
0:         if (listener != null && continuation != null && !continuation.isSuspended()) {
/////////////////////////////////////////////////////////////////////////
1:                 continuation.suspend();
commit:9ed183d
/////////////////////////////////////////////////////////////////////////
author:Alex Dean
-------------------------------------------------------------------------------
commit:c6ede16
/////////////////////////////////////////////////////////////////////////
1:         
1:         UndeliveredAjaxMessage undelivered_message = null;
1:         Message message = null;
1:         undelivered_message = (UndeliveredAjaxMessage)request.getAttribute("undelivered_message");
1:         if( undelivered_message != null ) {
0:             message = (Message)undelivered_message.getMessage();
1:         }
1:             MessageAvailableConsumer consumer = null;
1:             if( undelivered_message != null ) {
1:                 consumer = (MessageAvailableConsumer)undelivered_message.getConsumer();
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (message == null && client.getListener().getUndeliveredMessages().size() == 0) {
/////////////////////////////////////////////////////////////////////////
1:             
1:                 LOG.debug( "sending pre-existing message" );
1:             
1:             // send messages buffered while continuation was unavailable.
1:             LinkedList<UndeliveredAjaxMessage> undeliveredMessages = ((AjaxListener)consumer.getAvailableListener()).getUndeliveredMessages();
1:             LOG.debug("Send " + undeliveredMessages.size() + " unconsumed messages");
1:             synchronized( undeliveredMessages ) {
0:                 for (Iterator<UndeliveredAjaxMessage> it = undeliveredMessages.iterator(); it.hasNext(); ) {
1:                     messages++;
1:                     UndeliveredAjaxMessage undelivered = it.next();
0:                     Message msg = (Message)undelivered.getMessage();
1:                     consumer = (MessageAvailableConsumer)undelivered.getConsumer();
1:                     String id = consumerIdMap.get(consumer);
1:                     String destinationName = consumerDestinationNameMap.get(consumer);
1:                     LOG.debug( "sending undelivered/buffered messages" );
1:                     LOG.debug( "msg:" +msg+ ", id:" +id+ ", destinationName:" +destinationName);
0:                     writeMessageResponse(writer, msg, id, destinationName);
1:                     it.remove();
0:                     if (messages >= maximumMessages) {
1:                         break;
1:                     }
1:                 }
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug( "sending final available messages" );
commit:88fc7fe
/////////////////////////////////////////////////////////////////////////
1:         // this is non-null if we're resuming the continuation.
1:         // attributes set in AjaxListener
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug( "Suspending continuation " + continuation );
/////////////////////////////////////////////////////////////////////////
0:                 synchronized( unconsumedMessages ) {
0:                     for (Iterator<Message> it = unconsumedMessages.iterator(); it.hasNext(); ) {
1:                         messages++;
0:                         Message msg = it.next();
1:                         String id = consumerIdMap.get(consumer);
1:                         String destinationName = consumerDestinationNameMap.get(consumer);
0:                         writeMessageResponse(writer, msg, id, destinationName);
0:                         it.remove();
0:                         if (messages >= maximumMessages) {
1:                             break;
1:                         }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1:  * block for. The servlet can be configured with the following init parameters:
1:  * <dl>
1:  * <dt>defaultReadTimeout</dt>
1:  * <dd>The default time in ms to wait for messages. May be overridden by a
1:  * request using the 'timeout' parameter</dd>
1:  * <dt>maximumReadTimeout</dt>
1:  * <dd>The maximum value a request may specify for the 'timeout' parameter</dd>
1:  * <dt>maximumMessages</dt>
1:  * <dd>maximum messages to send per response</dd>
1:  * <dt></dt>
1:  * <dd></dd>
0:     private static final Log LOG = LogFactory.getLog(MessageListenerServlet.class);
1: 
/////////////////////////////////////////////////////////////////////////
1:             maximumMessages = (int)asLong(name);
1:      * Sends a message to a destination or manage subscriptions. If the the
1:      * content type of the POST is
1:      * <code>application/x-www-form-urlencoded</code>, then the form
1:      * parameters "destination", "message" and "type" are used to pass a message
1:      * or a subscription. If multiple messages or subscriptions are passed in a
1:      * single post, then additional parameters are shortened to "dN", "mN" and
1:      * "tN" where N is an index starting from 1. The type is either "send",
1:      * "listen" or "unlisten". For send types, the message is the text of the
1:      * TextMessage, otherwise it is the ID to be used for the subscription. If
1:      * the content type is not <code>application/x-www-form-urlencoded</code>,
1:      * then the body of the post is sent as the message to a destination that is
1:      * derived from a query parameter, the URL or the default destination.
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         String messageIds = "";
1: 
1: 
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("POST client=" + client + " session=" + request.getSession().getId() + " info=" + request.getPathInfo() + " contentType=" + request.getContentType());
1:                 // dump(request.getParameterMap());
1: 
1:             int messages = 0;
1: 
1:             while (true) {
1:                 // Get the message parameters. Multiple messages are encoded
1:                 // with more compact parameter names.
1:                 String destinationName = request.getParameter(messages == 0 ? "destination" : ("d" + messages));
1: 
1:                 if (destinationName == null) {
1:                     destinationName = request.getHeader("destination");
1:                 }
1: 
1:                 String message = request.getParameter(messages == 0 ? "message" : ("m" + messages));
1:                 String type = request.getParameter(messages == 0 ? "type" : ("t" + messages));
1: 
1:                 if (destinationName == null || message == null || type == null) {
1:                 }
1: 
1:                     Destination destination = getDestination(client, request, destinationName);
1: 
1:                     if (LOG.isDebugEnabled()) {
1:                         LOG.debug(messages + " destination=" + destinationName + " message=" + message + " type=" + type);
1:                         LOG.debug(destination + " is a " + destination.getClass().getName());
1: 
1: 
1:                     if ("listen".equals(type)) {
0:                         Map<MessageAvailableConsumer, String> consumerIdMap = getConsumerIdMap(request);
0:                         Map<MessageAvailableConsumer, String> consumerDestinationMap = getConsumerDestinationNameMap(request);
1:                         client.closeConsumer(destination); // drop any existing
1:                         // consumer.
0:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination);
1: 
0:                         consumerDestinationMap.put(consumer, destinationName);
1:                         if (LOG.isDebugEnabled()) {
1:                             LOG.debug("Subscribed: " + consumer + " to " + destination + " id=" + message);
1:                     } else if ("unlisten".equals(type)) {
0:                         Map<MessageAvailableConsumer, String> consumerIdMap = getConsumerIdMap(request);
0:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer)client.getConsumer(destination);
1: 
1:                         if (LOG.isDebugEnabled()) {
1:                             LOG.debug("Unsubscribed: " + consumer);
1:                     } else if ("send".equals(type)) {
1:                         messageIds += text.getJMSMessageID() + "\n";
1:                         if (LOG.isDebugEnabled()) {
1:                             LOG.debug("Sent " + message + " to " + destination);
1:                     } else {
1:                         LOG.warn("unknown type " + type);
1: 
1:                 } catch (JMSException e) {
1:                     LOG.warn("jms", e);
1: 
1:         if ("true".equals(request.getParameter("poll"))) {
1:             try {
1:                 doMessages(client, request, response);
1:             } catch (JMSException e) {
1:         } else {
1:             if (request.getContentLength() != 0 && (request.getContentType() == null || !request.getContentType().toLowerCase().startsWith("application/x-www-form-urlencoded"))) {
1:                     Destination destination = getDestination(client, request);
1:                     TextMessage message = client.getSession().createTextMessage(body);
1:                     if (LOG.isDebugEnabled()) {
1:                         LOG.debug("Sent to destination: " + destination + " body: " + body);
1:                     messageIds += message.getJMSMessageID() + "\n";
1:                 } catch (JMSException e) {
1: 
1:             response.getWriter().print(messageIds);
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("GET client=" + client + " session=" + request.getSession().getId() + " uri=" + request.getRequestURI() + " query=" + request.getQueryString());
0: 
1:         } catch (JMSException e) {
1:      * @param client The webclient
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("doMessage timeout=" + timeout);
0: 
0:         if (listener != null && continuation != null && !continuation.isPending()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 consumer = (MessageAvailableConsumer)consumers.get(i);
1:                 if (consumer.getAvailableListener() == null) {
1:                 }
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("received " + message + " from " + consumer);
/////////////////////////////////////////////////////////////////////////
0:             Map<MessageAvailableConsumer, String> consumerIdMap = getConsumerIdMap(request);
0:                 String id = consumerIdMap.get(consumer);
0:                 if (destinationName != null) {
0:                     writer.print(" destination='" + destinationName + "' ");
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 consumer = (MessageAvailableConsumer)consumers.get(i);
0:                 if (consumer.getAvailableListener() == null) {
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                     String id = consumerIdMap.get(consumer);
0:                     if (destinationName != null) {
0:                         writer.print(" destination='" + destinationName + "' ");
1:                     }
0:                     writer.print(">");
0:             // writer.println("<response type='object'
0:             // id='amqPoll'><ok/></response>");
0: 
/////////////////////////////////////////////////////////////////////////
1:             TextMessage textMsg = (TextMessage)message;
1:             ObjectMessage objectMsg = (ObjectMessage)message;
/////////////////////////////////////////////////////////////////////////
0:         Listener listener = (Listener)session.getAttribute("mls.listener");
/////////////////////////////////////////////////////////////////////////
0:     protected Map<MessageAvailableConsumer, String> getConsumerIdMap(HttpServletRequest request) {
0:         Map<MessageAvailableConsumer, String> map = (Map<MessageAvailableConsumer, String>)session.getAttribute("mls.consumerIdMap");
0:             map = new HashMap<MessageAvailableConsumer, String>();
1:         HttpSession session = request.getSession(true);
0:         Map<MessageAvailableConsumer, String> map = (Map<MessageAvailableConsumer, String>)session.getAttribute("mls.consumerDestinationNameMap");
0:         if (map == null) {
0:             map = new HashMap<MessageAvailableConsumer, String>();
0:             session.setAttribute("mls.consumerDestinationNameMap", map);
1:         }
0:         return map;
0: 
/////////////////////////////////////////////////////////////////////////
0:         public void access() {
0:             lastAccess = System.currentTimeMillis();
0: 
0:         public synchronized void setContinuation(Continuation continuation) {
0:         public synchronized void onMessageAvailable(MessageConsumer consumer) {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("message for " + consumer + "continuation=" + continuation);
0:             if (continuation != null) {
0:             } else if (System.currentTimeMillis() - lastAccess > 2 * maximumReadTimeout) {
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:d0c46a7
/////////////////////////////////////////////////////////////////////////
0:         synchronized public void setContinuation(Continuation continuation) {
0:             this.continuation = continuation;
0:         synchronized public void onMessageAvailable(MessageConsumer consumer) {
0:             if (log.isDebugEnabled()) {
0:                 log.debug("message for "+consumer+"continuation="+continuation);
0:             if (continuation != null)
0:                 continuation.resume();
0:             else if (System.currentTimeMillis()-lastAccess>2*maximumReadTimeout)
0:             {
0:                 new Thread() {
0:                     public void run() {
0:                         client.closeConsumers();
0:                     };
0:                 }.start();
1:             }
0:             continuation = null;
author:James Strachan
-------------------------------------------------------------------------------
commit:955cece
/////////////////////////////////////////////////////////////////////////
0:                 
0:                 if(destination_name == null)
0:                 	destination_name = request.getHeader("destination");
0:                 
/////////////////////////////////////////////////////////////////////////
0:                         Map consumerDestinationMap = getConsumerDestinationNameMap(request);
0:                         consumerDestinationMap.put(consumer, destination_name);
/////////////////////////////////////////////////////////////////////////
0:                         Map consumerDestinationMap = getConsumerDestinationNameMap(request);
0:                         consumerDestinationMap.remove(consumer);
/////////////////////////////////////////////////////////////////////////
0:             Map<MessageAvailableConsumer, String> consumerDestinationNameMap = getConsumerDestinationNameMap(request);
0:                 String destinationName = consumerDestinationNameMap.get(consumer);
0:                 writer.print("'");
0:                 if(destinationName != null)
0:                 	writer.print(" destination='" + destinationName + "' ");
0:                 writer.print(">");
/////////////////////////////////////////////////////////////////////////
0:                     String destinationName = consumerDestinationNameMap.get(consumer);
0:                     writer.print("'");
0:                     if(destinationName != null)
0:                     	writer.print(" destination='" + destinationName + "' ");
0:                     writer.print(">");                    
/////////////////////////////////////////////////////////////////////////
0:     protected Map<MessageAvailableConsumer, String> getConsumerDestinationNameMap(HttpServletRequest request) {
0:     	HttpSession session = request.getSession(true);
0:     	Map map = (Map) session.getAttribute("mls.consumerDestinationNameMap");
0:       if (map == null) {
0:         map = new HashMap<MessageAvailableConsumer, String>();
0:         session.setAttribute("mls.consumerDestinationNameMap", map);
1:       }
0:       return map;
1:     }
0:     
commit:b043ebe
/////////////////////////////////////////////////////////////////////////
1:                 while (messages < maximumMessages) {
1:                     message = consumer.receiveNoWait();
0:                     if (message == null) {
0:                         break;
1:                     }
1:                     messages++;
commit:c1a1dd2
/////////////////////////////////////////////////////////////////////////
0:         WebClient client = WebClient.getWebClient(request);
/////////////////////////////////////////////////////////////////////////
0:             WebClient client = WebClient.getWebClient(request);
/////////////////////////////////////////////////////////////////////////
0:             listener = new Listener(WebClient.getWebClient(request));
commit:d754e76
/////////////////////////////////////////////////////////////////////////
0:             // lets assume a simple POST of a message
1:             /*
1:             */
0:             
1:             try {
0:                 Destination destination=getDestination(client, request);
1:                 String body = getPostedMessageBody(request);
0:                 TextMessage message = client.getSession().createTextMessage(body );
1:                 client.send(destination, message);
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("Sent to destination: " + destination + " body: " + body);
1:                 }
0:                 
0:                 response.setContentType("text");
1:                 response.setHeader("Cache-Control", "no-cache");
0:                 response.getWriter().print(message.getJMSMessageID());
1:             }
0:             catch (JMSException e) {
1:                 throw new ServletException(e);
1:             }
author:Gregory John Wilkins
-------------------------------------------------------------------------------
commit:6fbb568
/////////////////////////////////////////////////////////////////////////
0:      * Sends a message to a destination or manage subscriptions.
1:      * 
0:      * If the the content type of the POST is <code>application/x-www-form-urlencoded</code>, then the form parameters 
0:      * "destination", "message" and "type" are used to pass a message or a subscription.  If multiple messages
0:      * or subscriptions are passed in a single post, then additional parameters are shortened to "dN", "mN" and "tN"
0:      * where N is an index starting from 1. The type is either "send", "listen" or "unlisten".  For send types,
0:      * the message is the text of the TextMessage, otherwise it is the ID to be used for the subscription.
1:      * 
0:      * If the content type is not <code>application/x-www-form-urlencoded</code>, then the body of the post is
0:      * sent as the message to a destination that is derived from a query parameter, the URL or the default destination.
/////////////////////////////////////////////////////////////////////////
0:             int messages=0;
1:             // loop until no more messages
0:             while (true)
0:                 // Get the message parameters.   Multiple messages are encoded with more compact parameter names.
0:                 String destination_name = request.getParameter(messages==0?"destination":("d"+messages));
0:                 String message = request.getParameter(messages==0?"message":("m"+messages));
0:                 String type = request.getParameter(messages==0?"type":("t"+messages));
0:                 
0:                 if (destination_name==null || message==null || type==null)
0:                     break;
0:                 
0:                     Destination destination=getDestination(client,request,destination_name);
0:                         log.debug(messages+" destination="+destination_name+" message="+message+" type="+type);
0:                     messages++;
0:                     
/////////////////////////////////////////////////////////////////////////
1:                         consumerIdMap.put(consumer, message);
0:                             log.debug("Subscribed: "+consumer+" to "+destination+" id="+message);
/////////////////////////////////////////////////////////////////////////
1:                         TextMessage text = client.getSession().createTextMessage(message);
1:                         appendParametersToMessage(request, text);
1:                         client.send(destination, text);
0:                         message_ids+=text.getJMSMessageID()+"\n";
0:                             log.debug("Sent "+message+" to "+destination);
commit:cb97916
/////////////////////////////////////////////////////////////////////////
0:         HttpSession session = request.getSession(true);
commit:8cb2141
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  * <dt>defaultReadTimeout</dt><dd>The default time in ms to wait for messages. 
0:  * May be overridden by a request using the 'timeout' parameter</dd>
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:         String message_ids="";
/////////////////////////////////////////////////////////////////////////
0:                         message_ids+=message.getJMSMessageID()+"\n";
/////////////////////////////////////////////////////////////////////////
1:                 // TODO return message IDs
/////////////////////////////////////////////////////////////////////////
0:         else 
1:             // handle simple POST of a message
0:             if (request.getContentLength()!=0 && 
0:                (request.getContentType()==null || !request.getContentType().toLowerCase().startsWith("application/x-www-form-urlencoded")))
0:             {
1:                 try {
0:                     Destination destination=getDestination(client, request);
0:                     String body = getPostedMessageBody(request);
0:                     TextMessage message = client.getSession().createTextMessage(body );
0:                     client.send(destination, message);
0:                     if (log.isDebugEnabled()) {
0:                         log.debug("Sent to destination: " + destination + " body: " + body);
1:                     }
0:                     message_ids+=message.getJMSMessageID()+"\n";
0:                 catch (JMSException e) {
0:                     throw new ServletException(e);
1:                 }
0:             
1:             response.setContentType("text/plain");
0:             response.setHeader("Cache-Control", "no-cache");
0:             response.getWriter().print(message_ids);
/////////////////////////////////////////////////////////////////////////
0:             
/////////////////////////////////////////////////////////////////////////
0: 
commit:4060ad9
/////////////////////////////////////////////////////////////////////////
0:  * The servlet can be configured with the following init parameters:<dl>
0:  * <dt>defaultReadTimeout</dt><dd>The default time in ms to wait for messages. May be overridden by a request using the 'timeout' parameter</dd>
0:  * <dt>maximumReadTimeout</dt><dd>The maximum value a request may specify for the 'timeout' parameter</dd>
0:  * <dt>maximumMessages</dt><dd>maximum messages to send per response</dd>
0:  * <dt></dt><dd></dd>
1:  * </dl>
0:  *  
0:  * 
/////////////////////////////////////////////////////////////////////////
0:                         client.closeConsumer(destination); // drop any existing consumer.
/////////////////////////////////////////////////////////////////////////
1:                         client.closeConsumer(destination);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Continuation continuation = ContinuationSupport.getContinuation(request, client);
0:         if (listener!=null && continuation!=null && !continuation.isPending())
0:             listener.access();
0:         Message message = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             listener.setContinuation(null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             
/////////////////////////////////////////////////////////////////////////
0:         long lastAccess;
0:         public void access()
0:         {
0:             lastAccess=System.currentTimeMillis();
1:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:                 else if (System.currentTimeMillis()-lastAccess>2*maximumReadTimeout)
0:                 {
0:                     client.closeConsumers();
1:                 }
commit:b33d3fc
/////////////////////////////////////////////////////////////////////////
0:             response.setContentType("text/xml");
commit:c6f73c5
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     private long maximumReadTimeout = 25000;
/////////////////////////////////////////////////////////////////////////
0:             // dump(request.getParameterMap());
/////////////////////////////////////////////////////////////////////////
0:         else
0:         {
0:             response.getWriter().print("<ajax-response></ajax-response>");
1:         }
/////////////////////////////////////////////////////////////////////////
0:         // System.err.println("--");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private static void dump(Map map)
0:     {
0:         Iterator iter=map.entrySet().iterator();
0:         while(iter.hasNext())
0:         {
0:             Map.Entry entry=(Map.Entry)iter.next();
0:             String k=(String)entry.getKey();
0:             String[] v=(String[])entry.getValue();
0:             System.err.println(k+":"+(v==null?"[]":Arrays.asList(v).toString()));
1:         }
1:     }
commit:92b9d86
/////////////////////////////////////////////////////////////////////////
0: import org.mortbay.jetty.RetryRequest;
/////////////////////////////////////////////////////////////////////////
0:     private long maximumReadTimeout = 10000;
/////////////////////////////////////////////////////////////////////////
0:         
0:         
0:         WebClient client = getWebClient(request);
0:         
1:         synchronized (client) {
0:             
0:             // System.err.println("POST client="+client+" session="+request.getSession().getId()+" info="+request.getPathInfo()+" contentType="+request.getContentType());
0:             
0:             String[] destinations = request.getParameterValues("destination");
0:             String[] messages = request.getParameterValues("message");
0:             String[] types = request.getParameterValues("type");
0:             
0:             if (destinations.length!=messages.length || messages.length!=types.length)
0:             {
0:                 // System.err.println("ERROR destination="+destinations.length+" message="+messages.length+" type="+types.length);
0:                 response.sendError(HttpServletResponse.SC_BAD_REQUEST,"missmatched destination, message or type");
0:                 return;
0:             
0:             for (int i=0;i<types.length;i++)
0:             {
0:                 try {
0:                     // System.err.println(i+" destination="+destinations[i]+" message="+messages[i]+" type="+types[i]);
0:                     
0:                     String type=types[i];
0:                     Destination destination=getDestination(client,request,destinations[i]);
0:                     
0:                     if ("listen".equals(type))
0:                     {
0:                         Listener listener = getListener(request);
0:                         Map consumerIdMap = getConsumerIdMap(request);
0:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer) client.getConsumer(destination);
0:                         
1:                         consumer.setAvailableListener(listener);
0:                         consumerIdMap.put(consumer, messages[i]);
0:                         // System.err.println("Subscribed: "+consumer+" to "+destination+" id="+messages[i]);
1:                     }
0:                     else if ("unlisten".equals(type))
0:                     {
0:                         Map consumerIdMap = getConsumerIdMap(request);
0:                         MessageAvailableConsumer consumer = (MessageAvailableConsumer) client.getConsumer(destination);
0:                         
0:                         // TODO should we destroy consumer on unsubscribe?
1:                         consumer.setAvailableListener(null);
1:                         consumerIdMap.remove(consumer);
0:                         // System.err.println("Unsubscribed: "+consumer);
0:                         
1:                     }
0:                     else if ("send".equals(type))
0:                     {
0:                         TextMessage message = client.getSession().createTextMessage(messages[i]);
0:                         // TODO sent message parameters
0:                         client.send(destination, message);
0:                         // System.err.println("Sent "+messages[i]+" to "+destination);
0:                         // TODO return message ID.
1:                     }
0:                     else
0:                         log.warn("unknown type "+type);
0:                     
1:                 } 
0:                 catch (JMSException e) {
0:                     log.warn("jms", e);
1:                 }
1:             }
0:             
0:         if ("true".equals(request.getParameter("poll")))
0:         {
0:             try
0:             {
0:                 doMessages(client,request,response);
1:             }
0:             catch (JMSException e) 
0:             {
1:                 throw new ServletException("JMS problem: " + e, e);
1:             }
1:         }
0:         // System.err.println("==");
/////////////////////////////////////////////////////////////////////////
0:         String end="--";
0:             // System.err.println("GET client="+client+" session="+request.getSession().getId()+" uri="+request.getRequestURI()+" query="+request.getQueryString());
1:             doMessages(client, request, response);
0:         catch(RetryRequest r)
0:         {
0:             end="??";
0:             throw r;
1:         }
0:         finally
0:         {
0:             // System.err.println(end);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         // System.err.println("doMessage timeout="+timeout);
0:         
/////////////////////////////////////////////////////////////////////////
0:                 writer.print("<response id='");
0:                 writer.print("'>");
/////////////////////////////////////////////////////////////////////////
0:                     writer.print("<response id='");
/////////////////////////////////////////////////////////////////////////
0:             // writer.println("<response type='object' id='amqPoll'><ok/></response>");
1:             writer.print("</ajax-response>");
0:             response.getWriter().println(m);
/////////////////////////////////////////////////////////////////////////
0:         // System.err.println("doSubscription destination="+destination);
commit:4e5012c
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.activemq.web;
0: 
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.io.StringWriter;
0: import java.util.HashMap;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: 
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.ObjectMessage;
1: import javax.jms.TextMessage;
1: import javax.servlet.ServletConfig;
1: import javax.servlet.ServletException;
1: import javax.servlet.http.HttpServletRequest;
1: import javax.servlet.http.HttpServletResponse;
1: import javax.servlet.http.HttpSession;
0: 
1: import org.apache.activemq.MessageAvailableConsumer;
0: import org.apache.activemq.MessageAvailableListener;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.mortbay.util.ajax.Continuation;
0: import org.mortbay.util.ajax.ContinuationSupport;
0: 
1: /**
1:  * A servlet for sending and receiving messages to/from JMS destinations using
1:  * HTTP POST for sending and HTTP GET for receiving. <p/> You can specify the
1:  * destination and whether it is a topic or queue via configuration details on
1:  * the servlet or as request parameters. <p/> For reading messages you can
1:  * specify a readTimeout parameter to determine how long the servlet should
0:  * block for.
0:  * 
0:  * @version $Revision: 1.1.1.1 $
1:  */
1: public class MessageListenerServlet extends MessageServletSupport {
0:     private static final Log log = LogFactory.getLog(MessageListenerServlet.class);
0: 
0:     private String readTimeoutParameter = "timeout";
0: 
1:     private long defaultReadTimeout = -1;
0: 
0:     private long maximumReadTimeout = 20000;
0: 
1:     private int maximumMessages = 100;
0: 
1:     public void init() throws ServletException {
1:         ServletConfig servletConfig = getServletConfig();
1:         String name = servletConfig.getInitParameter("defaultReadTimeout");
1:         if (name != null) {
1:             defaultReadTimeout = asLong(name);
1:         }
1:         name = servletConfig.getInitParameter("maximumReadTimeout");
1:         if (name != null) {
1:             maximumReadTimeout = asLong(name);
1:         }
1:         name = servletConfig.getInitParameter("maximumMessages");
1:         if (name != null) {
0:             maximumMessages = (int) asLong(name);
1:         }
1:     }
0: 
1:     /**
0:      * Sends a message to a destination
0:      * 
1:      * @param request
1:      * @param response
1:      * @throws ServletException
1:      * @throws IOException
1:      */
1:     protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
1:         // lets turn the HTTP post into a JMS Message
0:         try {
0:             WebClient client = getWebClient(request);
0:             // System.err.println("POST client="+client+"
0:             // session="+request.getSession().getId()+"
0:             // info="+request.getPathInfo()+" query="+request.getQueryString());
0: 
0:             String text = getPostedMessageBody(request);
0: 
0:             // lets create the destination from the URI?
0:             Destination destination = getDestination(client, request);
0:             if (destination == null)
0:                 throw new NoDestinationSuppliedException();
0: 
0:             if (log.isDebugEnabled()) {
0:                 log.debug("Sending message to: " + destination + " with text: " + text);
1:             }
0: 
0:             TextMessage message = client.getSession().createTextMessage(text);
1:             appendParametersToMessage(request, message);
0:             client.send(destination, message);
0: 
0:             // lets return a unique URI for reliable messaging
0:             response.setStatus(HttpServletResponse.SC_NO_CONTENT);
0:             // System.err.println("Sent "+message+" to "+destination);
0:             /*
0:              * StringWriter swriter = new StringWriter(); PrintWriter writer =
0:              * new PrintWriter(swriter);
0:              * 
0:              * writer.println("<ajax-response><response type='object'
0:              * id='amqSend'><amq jmsid='"+message.getJMSMessageID()+"'/></response></ajax-response>");
0:              * writer.flush(); String m=swriter.toString();
0:              * System.err.println(m); response.getWriter().write(m);
0:              * response.getWriter().flush();
1:              */
0:         } catch (JMSException e) {
0:             throw new ServletException("Could not post JMS message: " + e, e);
1:         }
1:     }
0: 
1:     /**
1:      * Supports a HTTP DELETE to be equivlanent of consuming a singe message
1:      * from a queue
1:      */
1:     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
0: 
0:         try {
0:             WebClient client = getWebClient(request);
0:             // System.err.println("GET client="+client+"
0:             // session="+request.getSession().getId()+"
0:             // info="+request.getPathInfo()+" query="+request.getQueryString());
0: 
0:             Destination destination = getDestination(client, request);
0:             if (destination != null)
0:                 doSubscription(client, destination, request, response);
0:             else
0:                 doMessages(client, request, response);
1:         }
0: 
0:         catch (JMSException e) {
1:             throw new ServletException("JMS problem: " + e, e);
1:         }
0: 
1:     }
0: 
1:     /**
1:      * Reads a message from a destination up to some specific timeout period
0:      * 
0:      * @param client
0:      *            The webclient
1:      * @param request
1:      * @param response
1:      * @throws ServletException
1:      * @throws IOException
1:      */
0:     protected void doMessages(WebClient client, HttpServletRequest request, HttpServletResponse response) throws JMSException, IOException {
0: 
1:         int messages = 0;
1:         // This is a poll for any messages
0: 
1:         long timeout = getReadTimeout(request);
0: 
0:         Continuation continuation = null;
0:         Message message = null;
0: 
0:         Listener listener = getListener(request);
0: 
1:         synchronized (client) {
0: 
0:             List consumers = client.getConsumers();
0:             MessageAvailableConsumer consumer = null;
0: 
0:             // Look for a message that is ready to go
0:             for (int i = 0; message == null && i < consumers.size(); i++) {
0:                 consumer = (MessageAvailableConsumer) consumers.get(i);
0:                 if (consumer.getAvailableListener() == null)
1:                     continue;
0: 
1:                 // Look for any available messages
0:                 message = consumer.receiveNoWait();
0:                 // System.err.println("received "+message+" from "+consumer);
1:             }
0: 
0:             // Get an existing Continuation or create a new one if there are no
0:             // messages
0: 
0:             if (message == null) {
0:                 continuation = ContinuationSupport.getContinuation(request, client);
0: 
0:                 // register this continuation with our listener.
0:                 listener.setContinuation(continuation);
0: 
0:                 // Get the continuation object (may wait and/or retry
0:                 // request here).
0:                 continuation.suspend(timeout);
1:             }
0: 
0:             // prepare the responds
0:             response.setContentType("text/xml");
0: 
1:             StringWriter swriter = new StringWriter();
1:             PrintWriter writer = new PrintWriter(swriter);
0: 
0:             Map consumerIdMap = getConsumerIdMap(request);
1:             response.setStatus(HttpServletResponse.SC_OK);
1:             writer.println("<ajax-response>");
0: 
1:             // Send any message we already have
1:             if (message != null) {
0:                 String id = (String) consumerIdMap.get(consumer);
0:                 writer.print("<response type='object' id='");
0:                 writer.print(id);
0:                 writer.print("'>\n");
0:                 writeMessageResponse(writer, message);
0:                 writer.println("</response>");
0:                 messages++;
1:             }
0: 
1:             // Send the rest of the messages
1:             for (int i = 0; i < consumers.size() && messages < maximumMessages; i++) {
0:                 consumer = (MessageAvailableConsumer) consumers.get(i);
0:                 if (consumer.getAvailableListener() == null)
1:                     continue;
0: 
1:                 // Look for any available messages
0:                 message = consumer.receiveNoWait();
0:                 // System.err.println("received "+message+" from "+consumer);
0:                 while (message != null && messages < maximumMessages) {
0:                     Destination destination = message.getJMSDestination();
0:                     String id = (String) consumerIdMap.get(consumer);
0:                     writer.print("<response type='object' id='");
0:                     writer.print(id);
0:                     writer.print("'>");
0:                     writeMessageResponse(writer, message);
0:                     writer.println("</response>");
0:                     messages++;
0:                     message = consumer.receiveNoWait();
1:                 }
1:             }
0: 
0:             // Add poll message
0:             writer.println("<response type='object' id='amqPoll'><ok/></response>");
0:             writer.println("</ajax-response>");
0: 
1:             writer.flush();
1:             String m = swriter.toString();
0:             // System.err.println(m);
0:             response.getWriter().write(m);
1:         }
0: 
1:     }
0: 
1:     /**
0:      * Subscribe or unsubscribe to a destination. The listen request parameter
0:      * is used to indicate subscribe (tree) or unsubscribe (false).
0:      * 
1:      * @param request
1:      * @param response
1:      * @throws ServletException
1:      * @throws IOException
1:      */
0:     protected void doSubscription(WebClient client, Destination destination, HttpServletRequest request, HttpServletResponse response) throws JMSException, ServletException, IOException {
0: 
0:         String s = request.getParameter("listen");
0:         if (s == null || s.length() == 0) {
0:             log.warn("No listen paramenter for subscribe");
0:             response.sendError(HttpServletResponse.SC_BAD_REQUEST, "No listen parameter");
0:             return;
1:         }
0:         boolean listen = Boolean.valueOf(s).booleanValue();
0: 
0:         String id = request.getParameter("id");
0:         if (listen && (id == null || id.length() == 0)) {
0:             log.warn("No id paramenter for subscribe");
0:             response.sendError(HttpServletResponse.SC_BAD_REQUEST, "No id parameter");
0:             return;
1:         }
0: 
0:         Listener listener = getListener(request);
0:         Map consumerIdMap = getConsumerIdMap(request);
0: 
1:         synchronized (client) {
0:             MessageAvailableConsumer consumer = (MessageAvailableConsumer) client.getConsumer(destination);
0: 
0:             if (listen) {
0:                 consumer.setAvailableListener(listener);
0:                 consumerIdMap.put(consumer, id);
0:                 // System.err.println("Subscribed: "+consumer+" to
0:                 // "+destination);
0:             } else {
0:                 // TODO should we destroy consumer on unsubscribe?
0:                 consumer.setAvailableListener(null);
0:                 consumerIdMap.remove(consumer);
0:                 // System.err.println("Unsubscribed: "+consumer);
1:             }
1:         }
0: 
0:         response.setStatus(HttpServletResponse.SC_NO_CONTENT);
1:     }
0: 
0:     protected void writeMessageResponse(PrintWriter writer, Message message) throws JMSException, IOException {
1:         if (message instanceof TextMessage) {
0:             TextMessage textMsg = (TextMessage) message;
0:             writer.print(textMsg.getText());
1:         } else if (message instanceof ObjectMessage) {
0:             ObjectMessage objectMsg = (ObjectMessage) message;
1:             Object object = objectMsg.getObject();
0:             writer.print(object.toString());
1:         }
1:     }
0: 
0:     protected Listener getListener(HttpServletRequest request) {
0:         HttpSession session = request.getSession();
0:         Listener listener = (Listener) session.getAttribute("mls.listener");
0:         if (listener == null) {
0:             listener = new Listener(getWebClient(request));
0:             session.setAttribute("mls.listener", listener);
1:         }
0:         return listener;
1:     }
0: 
0:     protected Map getConsumerIdMap(HttpServletRequest request) {
0:         HttpSession session = request.getSession();
0:         Map map = (Map) session.getAttribute("mls.consumerIdMap");
0:         if (map == null) {
0:             map = new HashMap();
0:             session.setAttribute("mls.consumerIdMap", map);
1:         }
0:         return map;
1:     }
0: 
0:     protected boolean isRicoAjax(HttpServletRequest request) {
0:         String rico = request.getParameter("rico");
0:         return rico != null && rico.equals("true");
1:     }
0: 
1:     /**
1:      * @return the timeout value for read requests which is always >= 0 and <=
1:      *         maximumReadTimeout to avoid DoS attacks
1:      */
1:     protected long getReadTimeout(HttpServletRequest request) {
1:         long answer = defaultReadTimeout;
0: 
1:         String name = request.getParameter(readTimeoutParameter);
1:         if (name != null) {
1:             answer = asLong(name);
1:         }
1:         if (answer < 0 || answer > maximumReadTimeout) {
1:             answer = maximumReadTimeout;
1:         }
1:         return answer;
1:     }
0: 
0:     /*
0:      * Listen for available messages and wakeup any continuations.
1:      */
0:     private class Listener implements MessageAvailableListener {
0:         WebClient client;
0: 
0:         Continuation continuation;
0: 
0:         List queue = new LinkedList();
0: 
0:         Listener(WebClient client) {
0:             this.client = client;
1:         }
0: 
0:         public void setContinuation(Continuation continuation) {
1:             synchronized (client) {
0:                 this.continuation = continuation;
1:             }
1:         }
0: 
0:         public void onMessageAvailable(MessageConsumer consumer) {
1:             synchronized (client) {
0:                 // System.err.println("message for "+consumer+"
0:                 // continuation="+continuation);
0:                 if (continuation != null)
0:                     continuation.resume();
0:                 continuation = null;
1:             }
1:         }
0: 
1:     }
0: 
1: }
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:c2aad2a
/////////////////////////////////////////////////////////////////////////
0:                         appendParametersToMessage(request, message);
0: 
/////////////////////////////////////////////////////////////////////////
0:                     appendParametersToMessage(request, message);
0: 
author:Joseph Dennis O. Gapuz
-------------------------------------------------------------------------------
commit:bd04e35
/////////////////////////////////////////////////////////////////////////
0:             response.setHeader("Cache-Control", "no-cache");
/////////////////////////////////////////////////////////////////////////
0:             response.setHeader("Cache-Control", "no-cache");
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:aa2188c
/////////////////////////////////////////////////////////////////////////
0:             if (log.isDebugEnabled()) {
0:                 log.debug("POST client="+client+" session="+request.getSession().getId()+" info="+request.getPathInfo()+" contentType="+request.getContentType());
0:             }
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("ERROR destination="+destinations.length+" message="+messages.length+" type="+types.length);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                     if (log.isDebugEnabled()) {
0:                         log.debug(i+" destination="+destinations[i]+" message="+messages[i]+" type="+types[i]);
0:                         log.debug(destination+" is a "+destination.getClass().getName());
0:                     }
0:                     
/////////////////////////////////////////////////////////////////////////
0:                         if (log.isDebugEnabled()) {
0:                             log.debug("Subscribed: "+consumer+" to "+destination+" id="+messages[i]);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                         if (log.isDebugEnabled()) {
0:                             log.debug("Unsubscribed: "+consumer);
0:                         }
0:                         if (log.isDebugEnabled()) {
0:                             log.debug("Sent "+messages[i]+" to "+destination);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:             if (log.isDebugEnabled()) {
0:                 log.debug("GET client="+client+" session="+request.getSession().getId()+" uri="+request.getRequestURI()+" query="+request.getQueryString());
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (log.isDebugEnabled()) {
0:             log.debug("doMessage timeout="+timeout);
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("received "+message+" from "+consumer);
0:                 }
/////////////////////////////////////////////////////////////////////////
1:             String txt = textMsg.getText();
0:             if (txt.startsWith("<?")) {
0:                 txt = txt.substring(txt.indexOf("?>") + 2);
0:             }
0:             writer.print(txt);
/////////////////////////////////////////////////////////////////////////
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("message for "+consumer+"continuation="+continuation);
0:                 }
============================================================================