1:8871c67: /**
1:8871c67:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8871c67:  * contributor license agreements.  See the NOTICE file distributed with
1:8871c67:  * this work for additional information regarding copyright ownership.
1:8871c67:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8871c67:  * (the "License"); you may not use this file except in compliance with
1:8871c67:  * the License.  You may obtain a copy of the License at
1:8871c67:  *
1:8871c67:  *      http://www.apache.org/licenses/LICENSE-2.0
1:8871c67:  *
1:8871c67:  * Unless required by applicable law or agreed to in writing, software
1:8871c67:  * distributed under the License is distributed on an "AS IS" BASIS,
1:8871c67:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8871c67:  * See the License for the specific language governing permissions and
1:8871c67:  * limitations under the License.
1:8871c67:  */
1:8871c67: package org.apache.activemq.usecases;
1:8871c67: 
1:8871c67: import org.apache.activemq.ActiveMQConnectionFactory;
1:8871c67: import org.apache.activemq.broker.BrokerFactory;
1:8871c67: import org.apache.activemq.broker.BrokerService;
1:8871c67: import org.apache.activemq.command.ActiveMQTopic;
1:8871c67: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:8871c67: import org.junit.Test;
1:8871c67: 
1:8871c67: import javax.jms.*;
1:8871c67: import java.io.File;
1:8871c67: import java.text.SimpleDateFormat;
1:8871c67: import java.util.ArrayList;
1:8871c67: import java.util.Arrays;
1:8871c67: import java.util.Date;
1:8871c67: import java.util.HashSet;
1:8871c67: import java.util.Vector;
1:8871c67: import java.util.concurrent.ConcurrentLinkedQueue;
1:8871c67: import java.util.concurrent.CopyOnWriteArrayList;
1:8871c67: 
1:8871c67: // see https://issues.apache.org/activemq/browse/AMQ-2985
1:8871c67: // this demonstrated receiving old messages eventually along with validating order receipt
1:8871c67: public class DurableSubProcessTest extends org.apache.activemq.TestSupport  {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubProcessTest.class);
1:8871c67:     public static final long RUNTIME = 4 * 60 * 1000;
1:8871c67: 
1:8871c67:     public static final int SERVER_SLEEP = 2 * 1000; // max
1:8871c67:     public static final int CARGO_SIZE = 10; // max
1:8871c67: 
1:8871c67:     public static final int MAX_CLIENTS = 7;
1:8871c67:     public static final Random CLIENT_LIFETIME = new Random(30 * 1000, 2 * 60 * 1000);
1:8871c67:     public static final Random CLIENT_ONLINE = new Random(2 * 1000, 15 * 1000);
1:8871c67:     public static final Random CLIENT_OFFLINE = new Random(1 * 1000, 20 * 1000);
1:8871c67: 
1:8871c67:     public static final boolean PERSISTENT_BROKER = true;
1:8871c67:     public static final boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1:8871c67: 
1:8871c67: 
1:8871c67:     private BrokerService broker;
1:8871c67:     private ActiveMQTopic topic;
1:8871c67: 
1:8871c67:     private ClientManager clientManager;
1:8871c67:     private Server server;
1:8871c67:     private HouseKeeper houseKeeper;
1:8871c67: 
1:8871c67:     static final Vector<Throwable> exceptions = new Vector<Throwable>(); 
1:8871c67: 
1:8871c67:     @Test
1:8871c67:     public void testProcess() {
1:8871c67:         try {
1:8871c67:             server.start();
1:8871c67:             clientManager.start();
1:8871c67: 
1:8871c67:             if (ALLOW_SUBSCRIPTION_ABANDONMENT)
1:8871c67:                 houseKeeper.start();
1:8871c67: 
1:8871c67:             Thread.sleep(RUNTIME);
1:8871c67:             assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:8871c67:         }
1:8871c67:         catch (Throwable e) {
1:8871c67:             exit("DurableSubProcessTest.testProcess failed.", e);
1:8871c67:         }
1:8871c67:         LOG.info("DONE.");
1:8871c67:     }
1:8871c67: 
1:8871c67:     /**
1:8871c67:      * Creates batch of messages in a transaction periodically.
1:8871c67:      * The last message in the transaction is always a special
1:8871c67:      * message what contains info about the whole transaction.
1:8871c67:      * <p>Notifies the clients about the created messages also.
1:8871c67:      */
1:8871c67:     final class Server extends Thread {
1:8871c67: 
1:8871c67:         final String url = "vm://" + DurableSubProcessTest.this.getName() + "?" +
1:8871c67:                 "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&" +
1:8871c67:                 "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&" +
1:8871c67:                 "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&" +
1:8871c67:                 "jms.alwaysSyncSend=true&jms.dispatchAsync=false&" +
1:8871c67:                 "jms.watchTopicAdvisories=false&" +
1:8871c67:                 "waitForStart=200&create=false";
1:8871c67:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:8871c67: 
1:8871c67:         final Object sendMutex = new Object();
1:8871c67:         final String[] cargos = new String[500];
1:8871c67: 
1:8871c67:         int transRover = 0;
1:8871c67:         int messageRover = 0;
1:8871c67: 
1:8871c67:         public Server() {
1:8871c67:             super("Server");
1:8871c67:             setDaemon(true);
1:8871c67:         }
1:8871c67: 
1:8871c67:         @Override
1:8871c67:         public void run() {
1:8871c67:             try {
1:8871c67:                 while (true) {
1:8871c67:                     DurableSubProcessTest.sleepRandom(SERVER_SLEEP);
1:8871c67:                     send();
1:8871c67:                 }
1:8871c67:             }
1:8871c67:             catch (Throwable e) {
1:8871c67:                 exit("Server.run failed", e);
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         public void send() throws JMSException {
1:8871c67:             // do not create new clients now
1:8871c67:             // ToDo: Test this case later.
1:8871c67:             synchronized (sendMutex) {
1:8871c67:                 int trans = ++transRover;
1:8871c67:                 boolean relevantTrans = random(2) > 1;
1:8871c67:                 ClientType clientType = relevantTrans ? ClientType.randomClientType() : null; // sends this types
1:8871c67:                 int count = random(200);
1:8871c67: 
1:8871c67:                 LOG.info("Sending Trans[id=" + trans + ", count=" + count + ", clientType=" + clientType + "]");
1:8871c67: 
1:8871c67:                 Connection con = cf.createConnection();
1:8871c67:                 Session sess = con.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:8871c67:                 MessageProducer prod = sess.createProducer(null);
1:8871c67: 
1:8871c67:                 for (int i = 0; i < count; i++) {
1:8871c67:                     Message message = sess.createMessage();
1:8871c67:                     message.setIntProperty("ID", ++messageRover);
1:8871c67:                     String type = clientType != null ? clientType.randomMessageType() : ClientType.randomNonRelevantMessageType();
1:8871c67:                     message.setStringProperty("TYPE", type);
1:8871c67: 
1:8871c67:                     if (CARGO_SIZE > 0)
1:8871c67:                         message.setStringProperty("CARGO", getCargo(CARGO_SIZE));
1:8871c67: 
1:8871c67:                     prod.send(topic, message);
1:8871c67:                     clientManager.onServerMessage(message);
1:8871c67:                 }
1:8871c67: 
1:8871c67:                 Message message = sess.createMessage();
1:8871c67:                 message.setIntProperty("ID", ++messageRover);
1:8871c67:                 message.setIntProperty("TRANS", trans);
1:8871c67:                 message.setBooleanProperty("COMMIT", true);
1:8871c67:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:8871c67:                 prod.send(topic, message);
1:8871c67:                 clientManager.onServerMessage(message);
1:8871c67: 
1:8871c67:                 sess.commit();
1:8871c67:                 sess.close();
1:8871c67:                 con.close();
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         private String getCargo(int length) {
1:8871c67:             if (length == 0)
1:8871c67:                 return null;
1:8871c67: 
1:8871c67:             if (length < cargos.length) {
1:8871c67:                 String result = cargos[length];
1:8871c67:                 if (result == null) {
1:8871c67:                     result = getCargoImpl(length);
1:8871c67:                     cargos[length] = result;
1:8871c67:                 }
1:8871c67:                 return result;
1:8871c67:             }
1:8871c67:             return getCargoImpl(length);
1:8871c67:         }
1:8871c67: 
1:8871c67:         private String getCargoImpl(int length) {
1:8871c67:             StringBuilder sb = new StringBuilder(length);
1:8871c67:             for (int i = length; --i >=0; ) {
1:8871c67:                 sb.append('a');
1:8871c67:             }
1:8871c67:             return sb.toString();
1:8871c67:         }
1:8871c67:     }
1:8871c67: 
1:8871c67:     /**
1:8871c67:      * Clients listen on different messages in the topic.
1:8871c67:      * The 'TYPE' property helps the client to select the
1:8871c67:      * proper messages.
1:8871c67:      */
1:8871c67:     private enum ClientType {
1:8871c67:         A ("a", "b", "c"),
1:8871c67:         B ("c", "d", "e"),
1:8871c67:         C ("d", "e", "f"),
1:8871c67:         D ("g", "h");
1:8871c67: 
1:8871c67:         public final String[] messageTypes;
1:8871c67:         public final HashSet<String> messageTypeSet;
1:8871c67:         public final String selector;
1:8871c67: 
1:8871c67:         ClientType(String... messageTypes) {
1:8871c67:             this.messageTypes = messageTypes;
1:8871c67:             messageTypeSet = new HashSet<String>(Arrays.asList(messageTypes));
1:8871c67: 
1:8871c67:             StringBuilder sb = new StringBuilder("TYPE in (");
1:8871c67:             for (int i = 0; i < messageTypes.length; i++) {
1:8871c67:                 if (i > 0)
1:8871c67:                     sb.append(", ");
1:8871c67:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:8871c67:             }
1:8871c67:             sb.append(')');
1:8871c67:             selector = sb.toString();
1:8871c67:         }
1:8871c67: 
1:8871c67:         public static ClientType randomClientType() {
1:8871c67:             return values()[DurableSubProcessTest.random(values().length - 1)];
1:8871c67:         }
1:8871c67: 
1:8871c67:         public final String randomMessageType() {
1:8871c67:             return messageTypes[DurableSubProcessTest.random(messageTypes.length - 1)];
1:8871c67:         }
1:8871c67: 
1:8871c67:         public static String randomNonRelevantMessageType() {
1:8871c67:             return Integer.toString(DurableSubProcessTest.random(20));
1:8871c67:         }
1:8871c67: 
1:8871c67:         public final boolean isRelevant(String messageType) {
1:8871c67:             return messageTypeSet.contains(messageType);
1:8871c67:         }
1:8871c67: 
1:8871c67:         @Override
1:8871c67:         public final String toString() {
1:8871c67:             return this.name() /*+ '[' + selector + ']'*/;
1:8871c67:         }
1:8871c67:     }
1:8871c67: 
1:8871c67:     /**
1:8871c67:      * Creates new cliens.
1:8871c67:      */
1:8871c67:     private final class ClientManager extends Thread {
1:8871c67: 
1:8871c67:         private int clientRover = 0;
1:8871c67: 
1:8871c67:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1:8871c67: 
1:8871c67:         public ClientManager() {
1:8871c67:             super("ClientManager");
1:8871c67:             setDaemon(true);
1:8871c67:         }
1:8871c67: 
1:8871c67:         @Override
1:8871c67:         public void run() {
1:8871c67:             try {
1:8871c67:                 while (true) {
1:8871c67:                     if (clients.size() < MAX_CLIENTS)
1:8871c67:                         createNewClient();
1:8871c67: 
1:8871c67:                     int size = clients.size();
1:8871c67:                     sleepRandom(size * 3 * 1000, size * 6 * 1000);
1:8871c67:                 }
1:8871c67:             }
1:8871c67:             catch (Throwable e) {
1:8871c67:                 exit("ClientManager.run failed.", e);
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         private void createNewClient() throws JMSException {
1:8871c67:             ClientType type = ClientType.randomClientType();
1:8871c67: 
1:8871c67:             Client client;
1:8871c67:             synchronized (server.sendMutex) {
1:8871c67:                 client = new Client(++clientRover, type, CLIENT_LIFETIME, CLIENT_ONLINE, CLIENT_OFFLINE);
1:8871c67:                 clients.add(client);
1:8871c67:             }
1:8871c67:             client.start();
1:8871c67: 
1:8871c67:             LOG.info(client.toString() + " created. " + this);
1:8871c67:         }
1:8871c67: 
1:8871c67:         public void removeClient(Client client) {
1:8871c67:             clients.remove(client);
1:8871c67:         }
1:8871c67: 
1:8871c67:         public void onServerMessage(Message message) throws JMSException {
1:8871c67:             for (Client client: clients) {
1:8871c67:                 client.onServerMessage(message);
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         @Override
1:8871c67:         public String toString() {
1:8871c67:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:8871c67:             sb.append(clients.size());
1:8871c67:             sb.append(", clients=");
1:8871c67:             boolean sep = false;
1:8871c67:             for (Client client: clients) {
1:8871c67:                 if (sep) sb.append(", ");
1:8871c67:                 else sep = true;
1:8871c67:                 sb.append(client.toString());
1:8871c67:             }
1:8871c67:             sb.append(']');
1:8871c67:             return sb.toString();
1:8871c67:         }
1:8871c67:     }
1:8871c67: 
1:8871c67:     /**
1:8871c67:      * Consumes massages from a durable subscription.
1:8871c67:      * Goes online/offline periodically. Checks the incoming messages
1:8871c67:      * against the sent messages of the server.
1:8871c67:      */
1:8871c67:     private final class Client extends Thread {
1:8871c67: 
1:8871c67:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?" +
1:8871c67:                 "jms.watchTopicAdvisories=false&" +
1:8871c67:                 "jms.alwaysSyncSend=true&jms.dispatchAsync=true&" +
1:8871c67:                 "jms.producerWindowSize=20971520&" +
1:8871c67:                 "jms.copyMessageOnSend=false&" +
1:4acd132:                 "initialReconnectDelay=100&maxReconnectDelay=30000&" +
1:8871c67:                 "useExponentialBackOff=true";
1:8871c67:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1:8871c67: 
1:8871c67:         public static final String SUBSCRIPTION_NAME = "subscription";
1:8871c67: 
1:8871c67:         private final int id;
1:8871c67:         private final String conClientId;
1:8871c67: 
1:8871c67:         private final Random lifetime;
1:8871c67:         private final Random online;
1:8871c67:         private final Random offline;
1:8871c67: 
1:8871c67:         private final ClientType clientType;
1:8871c67:         private final String selector;
1:8871c67: 
1:8871c67:         private final ConcurrentLinkedQueue<Message> waitingList = new ConcurrentLinkedQueue<Message>();
1:8871c67: 
1:8871c67:         public Client(int id, ClientType clientType, Random lifetime, Random online, Random offline) throws JMSException {
1:8871c67:             super("Client" + id);
1:8871c67:             setDaemon(true);
1:8871c67: 
1:8871c67:             this.id = id;
1:8871c67:             conClientId = "cli" + id;
1:8871c67:             this.clientType = clientType;
1:8871c67:             selector = "(COMMIT = true and RELEVANT = true) or " + clientType.selector;
1:8871c67: 
1:8871c67:             this.lifetime = lifetime;
1:8871c67:             this.online = online;
1:8871c67:             this.offline = offline;
1:8871c67: 
1:8871c67:             subscribe();
1:8871c67:         }
1:8871c67: 
1:8871c67:         @Override
1:8871c67:         public void run() {
1:8871c67:             long end = System.currentTimeMillis() + lifetime.next();
1:8871c67:             try {
1:8871c67:                 boolean sleep = false;
1:8871c67:                 while (true) {
1:8871c67:                     long max = end - System.currentTimeMillis();
1:8871c67:                     if (max <= 0)
1:8871c67:                         break;
1:8871c67: 
1:8871c67:                     if (sleep) offline.sleepRandom();
1:8871c67:                     else sleep = true;
1:8871c67: 
1:8871c67:                     process(online.next());
1:8871c67:                 }
1:8871c67: 
1:8871c67:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0)
1:8871c67:                     unsubscribe();
1:8871c67:                 else {
1:8871c67:                     LOG.info("Client abandon the subscription. " + this);
1:8871c67: 
1:8871c67:                     // housekeeper should sweep these abandoned subscriptions
1:8871c67:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:8871c67:                 }
1:8871c67:             }
1:8871c67:             catch (Throwable e) {
1:8871c67:                 exit(toString() + " failed.", e);
1:8871c67:             }
1:8871c67: 
1:8871c67:             clientManager.removeClient(this);
1:8871c67:             LOG.info(toString() + " DONE.");
1:8871c67:         }
1:8871c67: 
1:8871c67:         private void process(long millis) throws JMSException {
1:8871c67:             long end = System.currentTimeMillis() + millis;
1:8871c67:             long hardEnd = end + 2000; // wait to finish the transaction.
1:8871c67:             boolean inTransaction = false;
1:8871c67:             int transCount = 0;
1:8871c67: 
1:8871c67:             LOG.info(toString() + " ONLINE.");
1:8871c67:             Connection con = openConnection();
1:8871c67:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:8871c67:             MessageConsumer consumer = sess.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, false);
1:8871c67:             try {
1:8871c67:                 do {
1:8871c67:                     long max = end - System.currentTimeMillis();
1:8871c67:                     if (max <= 0) {
1:8871c67:                         if (!inTransaction)
1:8871c67:                             break;
1:8871c67: 
1:8871c67:                         max = hardEnd - System.currentTimeMillis();
1:8871c67:                         if (max <= 0)
1:8871c67:                             exit("" + this + " failed: Transaction is not finished.");
1:8871c67:                     }
1:8871c67: 
1:8871c67:                     Message message = consumer.receive(max);
1:8871c67:                     if (message == null)
1:8871c67:                         continue;
1:8871c67: 
1:8871c67:                     onClientMessage(message);
1:8871c67: 
1:8871c67:                     if (message.propertyExists("COMMIT")) {
1:8871c67:                         message.acknowledge();
1:8871c67: 
1:8871c67:                         LOG.info("Received Trans[id=" + message.getIntProperty("TRANS") + ", count=" + transCount + "] in " + this + ".");
1:8871c67: 
1:8871c67:                         inTransaction = false;
1:8871c67:                         transCount = 0;
1:8871c67:                     }
1:8871c67:                     else {
1:8871c67:                         inTransaction = true;
1:8871c67:                         transCount++;
1:8871c67:                     }
1:8871c67:                 } while (true);
1:8871c67:             }
1:8871c67:             finally {
1:8871c67:                 sess.close();
1:8871c67:                 con.close();
1:8871c67: 
1:8871c67:                 LOG.info(toString() + " OFFLINE.");
1:8871c67: 
1:8871c67:                 // Check if the messages are in the waiting
1:8871c67:                 // list for long time.
1:8871c67:                 Message topMessage = waitingList.peek();
1:8871c67:                 if (topMessage != null)
1:8871c67:                     checkDeliveryTime(topMessage);
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         public void onServerMessage(Message message) throws JMSException {
1:8871c67:             if (Boolean.TRUE.equals(message.getObjectProperty("COMMIT"))) {
1:8871c67:                 if (Boolean.TRUE.equals(message.getObjectProperty("RELEVANT")))
1:8871c67:                     waitingList.add(message);
1:8871c67:             }
1:8871c67:             else {
1:8871c67:                 String messageType = message.getStringProperty("TYPE");
1:8871c67:                 if (clientType.isRelevant(messageType))
1:8871c67:                     waitingList.add(message);
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         public void onClientMessage(Message message) {
1:8871c67:             Message serverMessage = waitingList.poll();
1:8871c67:             try {
1:8871c67:                 if (serverMessage == null)
1:8871c67:                     exit("" + this + " failed: There is no next server message, but received: " + message);
1:8871c67: 
1:8871c67:                 Integer receivedId = (Integer) message.getObjectProperty("ID");
1:8871c67:                 Integer serverId = (Integer) serverMessage.getObjectProperty("ID");
1:8871c67:                 if (receivedId == null || serverId == null)
1:8871c67:                     exit("" + this + " failed: message ID not found.\r\n" +
1:8871c67:                             " received: " + message + "\r\n" +
1:8871c67:                             "   server: " + serverMessage);
1:8871c67: 
1:8871c67:                 if (!serverId.equals(receivedId))
1:8871c67:                     exit("" + this + " failed: Received wrong message.\r\n" +
1:8871c67:                             " received: " + message + "\r\n" +
1:8871c67:                             "   server: " + serverMessage);
1:8871c67: 
1:8871c67:                 checkDeliveryTime(message);
1:8871c67:             }
1:8871c67:             catch (Throwable e) {
1:8871c67:                 exit("" + this + ".onClientMessage failed.\r\n" +
1:8871c67:                         " received: " + message + "\r\n" +
1:8871c67:                         "   server: " + serverMessage, e);
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         /**
1:8871c67:          * Checks if the message was not delivered fast enough.
1:8871c67:          */
1:8871c67:         public void checkDeliveryTime(Message message) throws JMSException {
1:8871c67:             long creation = message.getJMSTimestamp();
1:8871c67:             long min = System.currentTimeMillis() - (offline.max + online.min);
1:8871c67: 
1:8871c67:             if (min > creation) {
1:8871c67:                 SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss.SSS");
1:8871c67:                 exit("" + this + ".checkDeliveryTime failed. Message time: " + df.format(new Date(creation)) + ", min: " + df.format(new Date(min)) + "\r\n" + message);
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         private Connection openConnection() throws JMSException {
1:8871c67:             Connection con = cf.createConnection();
1:8871c67:             con.setClientID(conClientId);
1:8871c67:             con.start();
1:8871c67:             return con;
1:8871c67:         }
1:8871c67: 
1:8871c67:         private void subscribe() throws JMSException {
1:8871c67:             Connection con = openConnection();
1:8871c67:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8871c67:             session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, true);
1:8871c67:             session.close();
1:8871c67:             con.close();
1:8871c67:         }
1:8871c67: 
1:8871c67:         private void unsubscribe() throws JMSException {
1:8871c67:             Connection con = openConnection();
1:8871c67:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:8871c67:             session.unsubscribe(SUBSCRIPTION_NAME);
1:8871c67:             session.close();
1:8871c67:             con.close();
1:8871c67:         }
1:8871c67: 
1:8871c67:         @Override
1:8871c67:         public String toString() {
1:8871c67:             return "Client[id=" + id + ", type=" + clientType + "]";
1:8871c67:         }
1:8871c67:     }
1:8871c67: 
1:8871c67:     /**
1:8871c67:      * Sweeps out not-used durable subscriptions.
1:8871c67:      */
1:8871c67:     private final class HouseKeeper extends Thread {
1:8871c67: 
1:8871c67:         private HouseKeeper() {
1:8871c67:             super("HouseKeeper");
1:8871c67:             setDaemon(true);
1:8871c67:         }
1:8871c67: 
1:8871c67:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1:8871c67: 
1:8871c67:         @Override
1:8871c67:         public void run() {
1:8871c67:             while (true) {
1:8871c67:                 try {
1:8871c67:                     Thread.sleep(60 * 1000);
1:8871c67:                     sweep();
1:8871c67:                 }
1:8871c67:                 catch (InterruptedException ex) {
1:8871c67:                     break;
1:8871c67:                 }
1:8871c67:                 catch (Throwable e) {
1:8871c67:                     Exception log = new Exception("HouseKeeper failed.", e);
1:8871c67:                     log.printStackTrace();
1:8871c67:                 }
1:8871c67:             }
1:8871c67:         }
1:8871c67: 
1:8871c67:         private void sweep() throws Exception {
1:8871c67:             LOG.info("Housekeeper sweeping.");
1:8871c67: 
1:8871c67:             int closed = 0;
1:8871c67:             ArrayList<String> sweeped = new ArrayList<String>();
1:8871c67:             try {
1:8871c67:                 for (String clientId: abandonedSubscriptions) {
1:8871c67:                     sweeped.add(clientId);
1:8871c67:                     LOG.info("Sweeping out subscription of " + clientId + ".");
1:8871c67:                     broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);
1:8871c67:                     closed++;
1:8871c67:                 }
1:8871c67:             }
1:8871c67:             finally {
1:8871c67:                 abandonedSubscriptions.removeAll(sweeped);
1:8871c67:             }
1:8871c67: 
1:8871c67:             LOG.info("Housekeeper sweeped out " + closed + " subscriptions.");
1:8871c67:         }
1:8871c67:     }
1:8871c67: 
1:8871c67:     public static int random(int max) {
1:8871c67:         return (int) (Math.random() * (max + 1));
1:8871c67:     }
1:8871c67: 
1:8871c67:     public static int random(int min, int max) {
1:8871c67:         return random(max - min) + min;
1:8871c67:     }
1:8871c67: 
1:8871c67:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:8871c67:         Thread.sleep(random(maxMillis));
1:8871c67:     }
1:8871c67: 
1:8871c67:     public static void sleepRandom(int minMillis, int maxMillis) throws InterruptedException {
1:8871c67:         Thread.sleep(random(minMillis, maxMillis));
1:8871c67:     }
1:8871c67: 
1:8871c67:     public static final class Random {
1:8871c67: 
1:8871c67:         final int min;
1:8871c67:         final int max;
1:8871c67: 
1:8871c67:         Random(int min, int max) {
1:8871c67:             this.min = min;
1:8871c67:             this.max = max;
1:8871c67:         }
1:8871c67: 
1:8871c67:         public int next() {
1:8871c67:             return random(min, max);
1:8871c67:         }
1:8871c67: 
1:8871c67:         public void sleepRandom() throws InterruptedException {
1:8871c67:             DurableSubProcessTest.sleepRandom(min, max);
1:8871c67:         }
1:8871c67:     }
1:8871c67: 
1:8871c67:     public static void exit(String message) {
1:8871c67:         exit(message, null);
1:8871c67:     }
1:8871c67: 
1:8871c67:     public static void exit(String message, Throwable e) {
1:8871c67:         Throwable log = new RuntimeException(message, e);
1:8871c67:         log.printStackTrace();
1:8871c67:         LOG.error(message, e);
1:8871c67:         exceptions.add(e);
1:8871c67:         fail(message);
1:8871c67:     }
1:8871c67: 
1:8871c67:     protected void setUp() throws Exception {
1:8871c67:         topic = (ActiveMQTopic) createDestination();
1:8871c67:         startBroker();
1:8871c67: 
1:8871c67:         clientManager = new ClientManager();
1:8871c67:         server = new Server();
1:8871c67:         houseKeeper = new HouseKeeper();
1:8871c67: 
1:8871c67:         super.setUp();
1:8871c67:     }
1:8871c67: 
1:8871c67:     protected void tearDown() throws Exception {
1:8871c67:         super.tearDown();
1:8871c67: 
1:8871c67:         destroyBroker();
1:8871c67:     }
1:8871c67: 
1:8871c67:     private void startBroker() throws Exception {
1:8871c67:         startBroker(true);
1:8871c67:     }
1:8871c67: 
1:8871c67:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:8871c67:         if (broker != null)
1:8871c67:             return;
1:8871c67: 
1:8871c67:         broker = BrokerFactory.createBroker("broker:(vm://localhost)");
1:8871c67:         broker.setBrokerName(getName());
1:8871c67:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1:8871c67: 
1:8871c67:         if (PERSISTENT_BROKER) {
1:8871c67:             broker.setPersistent(true);
1:8871c67:             KahaDBPersistenceAdapter persistenceAdapter = new KahaDBPersistenceAdapter();
1:8871c67:             persistenceAdapter.setDirectory(new File("activemq-data/" + getName()));
1:8871c67:             broker.setPersistenceAdapter(persistenceAdapter);
1:8871c67:         }
1:8871c67:         else
1:8871c67:             broker.setPersistent(false);
1:8871c67: 
1:8871c67:         broker.addConnector("tcp://localhost:61656");
1:8871c67: 
1:8871c67:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:8871c67:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:8871c67:         broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);
1:8871c67: 
1:8871c67:         broker.start();
1:8871c67:     }
1:8871c67: 
1:8871c67:     private void destroyBroker() throws Exception {
1:8871c67:         if (broker == null)
1:8871c67:             return;
1:8871c67: 
1:8871c67:         broker.stop();
1:8871c67:         broker = null;
1:8871c67:     }
1:8871c67: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:4acd132
/////////////////////////////////////////////////////////////////////////
1:                 "initialReconnectDelay=100&maxReconnectDelay=30000&" +
commit:8871c67
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.usecases;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: import org.junit.Test;
1: 
1: import javax.jms.*;
1: import java.io.File;
1: import java.text.SimpleDateFormat;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Date;
1: import java.util.HashSet;
1: import java.util.Vector;
1: import java.util.concurrent.ConcurrentLinkedQueue;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: 
1: // see https://issues.apache.org/activemq/browse/AMQ-2985
1: // this demonstrated receiving old messages eventually along with validating order receipt
1: public class DurableSubProcessTest extends org.apache.activemq.TestSupport  {
0:     private static final Log LOG = LogFactory.getLog(DurableSubProcessTest.class);
1:     public static final long RUNTIME = 4 * 60 * 1000;
1: 
1:     public static final int SERVER_SLEEP = 2 * 1000; // max
1:     public static final int CARGO_SIZE = 10; // max
1: 
1:     public static final int MAX_CLIENTS = 7;
1:     public static final Random CLIENT_LIFETIME = new Random(30 * 1000, 2 * 60 * 1000);
1:     public static final Random CLIENT_ONLINE = new Random(2 * 1000, 15 * 1000);
1:     public static final Random CLIENT_OFFLINE = new Random(1 * 1000, 20 * 1000);
1: 
1:     public static final boolean PERSISTENT_BROKER = true;
1:     public static final boolean ALLOW_SUBSCRIPTION_ABANDONMENT = true;
1: 
1: 
1:     private BrokerService broker;
1:     private ActiveMQTopic topic;
1: 
1:     private ClientManager clientManager;
1:     private Server server;
1:     private HouseKeeper houseKeeper;
1: 
1:     static final Vector<Throwable> exceptions = new Vector<Throwable>(); 
1: 
1:     @Test
1:     public void testProcess() {
1:         try {
1:             server.start();
1:             clientManager.start();
1: 
1:             if (ALLOW_SUBSCRIPTION_ABANDONMENT)
1:                 houseKeeper.start();
1: 
1:             Thread.sleep(RUNTIME);
1:             assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:         }
1:         catch (Throwable e) {
1:             exit("DurableSubProcessTest.testProcess failed.", e);
1:         }
1:         LOG.info("DONE.");
1:     }
1: 
1:     /**
1:      * Creates batch of messages in a transaction periodically.
1:      * The last message in the transaction is always a special
1:      * message what contains info about the whole transaction.
1:      * <p>Notifies the clients about the created messages also.
1:      */
1:     final class Server extends Thread {
1: 
1:         final String url = "vm://" + DurableSubProcessTest.this.getName() + "?" +
1:                 "jms.redeliveryPolicy.maximumRedeliveries=2&jms.redeliveryPolicy.initialRedeliveryDelay=500&" +
1:                 "jms.producerWindowSize=20971520&jms.prefetchPolicy.all=100&" +
1:                 "jms.copyMessageOnSend=false&jms.disableTimeStampsByDefault=false&" +
1:                 "jms.alwaysSyncSend=true&jms.dispatchAsync=false&" +
1:                 "jms.watchTopicAdvisories=false&" +
1:                 "waitForStart=200&create=false";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         final Object sendMutex = new Object();
1:         final String[] cargos = new String[500];
1: 
1:         int transRover = 0;
1:         int messageRover = 0;
1: 
1:         public Server() {
1:             super("Server");
1:             setDaemon(true);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 while (true) {
1:                     DurableSubProcessTest.sleepRandom(SERVER_SLEEP);
1:                     send();
1:                 }
1:             }
1:             catch (Throwable e) {
1:                 exit("Server.run failed", e);
1:             }
1:         }
1: 
1:         public void send() throws JMSException {
1:             // do not create new clients now
1:             // ToDo: Test this case later.
1:             synchronized (sendMutex) {
1:                 int trans = ++transRover;
1:                 boolean relevantTrans = random(2) > 1;
1:                 ClientType clientType = relevantTrans ? ClientType.randomClientType() : null; // sends this types
1:                 int count = random(200);
1: 
1:                 LOG.info("Sending Trans[id=" + trans + ", count=" + count + ", clientType=" + clientType + "]");
1: 
1:                 Connection con = cf.createConnection();
1:                 Session sess = con.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:                 MessageProducer prod = sess.createProducer(null);
1: 
1:                 for (int i = 0; i < count; i++) {
1:                     Message message = sess.createMessage();
1:                     message.setIntProperty("ID", ++messageRover);
1:                     String type = clientType != null ? clientType.randomMessageType() : ClientType.randomNonRelevantMessageType();
1:                     message.setStringProperty("TYPE", type);
1: 
1:                     if (CARGO_SIZE > 0)
1:                         message.setStringProperty("CARGO", getCargo(CARGO_SIZE));
1: 
1:                     prod.send(topic, message);
1:                     clientManager.onServerMessage(message);
1:                 }
1: 
1:                 Message message = sess.createMessage();
1:                 message.setIntProperty("ID", ++messageRover);
1:                 message.setIntProperty("TRANS", trans);
1:                 message.setBooleanProperty("COMMIT", true);
1:                 message.setBooleanProperty("RELEVANT", relevantTrans);
1:                 prod.send(topic, message);
1:                 clientManager.onServerMessage(message);
1: 
1:                 sess.commit();
1:                 sess.close();
1:                 con.close();
1:             }
1:         }
1: 
1:         private String getCargo(int length) {
1:             if (length == 0)
1:                 return null;
1: 
1:             if (length < cargos.length) {
1:                 String result = cargos[length];
1:                 if (result == null) {
1:                     result = getCargoImpl(length);
1:                     cargos[length] = result;
1:                 }
1:                 return result;
1:             }
1:             return getCargoImpl(length);
1:         }
1: 
1:         private String getCargoImpl(int length) {
1:             StringBuilder sb = new StringBuilder(length);
1:             for (int i = length; --i >=0; ) {
1:                 sb.append('a');
1:             }
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Clients listen on different messages in the topic.
1:      * The 'TYPE' property helps the client to select the
1:      * proper messages.
1:      */
1:     private enum ClientType {
1:         A ("a", "b", "c"),
1:         B ("c", "d", "e"),
1:         C ("d", "e", "f"),
1:         D ("g", "h");
1: 
1:         public final String[] messageTypes;
1:         public final HashSet<String> messageTypeSet;
1:         public final String selector;
1: 
1:         ClientType(String... messageTypes) {
1:             this.messageTypes = messageTypes;
1:             messageTypeSet = new HashSet<String>(Arrays.asList(messageTypes));
1: 
1:             StringBuilder sb = new StringBuilder("TYPE in (");
1:             for (int i = 0; i < messageTypes.length; i++) {
1:                 if (i > 0)
1:                     sb.append(", ");
1:                 sb.append('\'').append(messageTypes[i]).append('\'');
1:             }
1:             sb.append(')');
1:             selector = sb.toString();
1:         }
1: 
1:         public static ClientType randomClientType() {
1:             return values()[DurableSubProcessTest.random(values().length - 1)];
1:         }
1: 
1:         public final String randomMessageType() {
1:             return messageTypes[DurableSubProcessTest.random(messageTypes.length - 1)];
1:         }
1: 
1:         public static String randomNonRelevantMessageType() {
1:             return Integer.toString(DurableSubProcessTest.random(20));
1:         }
1: 
1:         public final boolean isRelevant(String messageType) {
1:             return messageTypeSet.contains(messageType);
1:         }
1: 
1:         @Override
1:         public final String toString() {
1:             return this.name() /*+ '[' + selector + ']'*/;
1:         }
1:     }
1: 
1:     /**
1:      * Creates new cliens.
1:      */
1:     private final class ClientManager extends Thread {
1: 
1:         private int clientRover = 0;
1: 
1:         private final CopyOnWriteArrayList<Client> clients = new CopyOnWriteArrayList<Client>();
1: 
1:         public ClientManager() {
1:             super("ClientManager");
1:             setDaemon(true);
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 while (true) {
1:                     if (clients.size() < MAX_CLIENTS)
1:                         createNewClient();
1: 
1:                     int size = clients.size();
1:                     sleepRandom(size * 3 * 1000, size * 6 * 1000);
1:                 }
1:             }
1:             catch (Throwable e) {
1:                 exit("ClientManager.run failed.", e);
1:             }
1:         }
1: 
1:         private void createNewClient() throws JMSException {
1:             ClientType type = ClientType.randomClientType();
1: 
1:             Client client;
1:             synchronized (server.sendMutex) {
1:                 client = new Client(++clientRover, type, CLIENT_LIFETIME, CLIENT_ONLINE, CLIENT_OFFLINE);
1:                 clients.add(client);
1:             }
1:             client.start();
1: 
1:             LOG.info(client.toString() + " created. " + this);
1:         }
1: 
1:         public void removeClient(Client client) {
1:             clients.remove(client);
1:         }
1: 
1:         public void onServerMessage(Message message) throws JMSException {
1:             for (Client client: clients) {
1:                 client.onServerMessage(message);
1:             }
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             StringBuilder sb = new StringBuilder("ClientManager[count=");
1:             sb.append(clients.size());
1:             sb.append(", clients=");
1:             boolean sep = false;
1:             for (Client client: clients) {
1:                 if (sep) sb.append(", ");
1:                 else sep = true;
1:                 sb.append(client.toString());
1:             }
1:             sb.append(']');
1:             return sb.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Consumes massages from a durable subscription.
1:      * Goes online/offline periodically. Checks the incoming messages
1:      * against the sent messages of the server.
1:      */
1:     private final class Client extends Thread {
1: 
1:         String url = "failover:(tcp://localhost:61656?wireFormat.maxInactivityDuration=0)?" +
1:                 "jms.watchTopicAdvisories=false&" +
1:                 "jms.alwaysSyncSend=true&jms.dispatchAsync=true&" +
1:                 "jms.producerWindowSize=20971520&" +
1:                 "jms.copyMessageOnSend=false&" +
0:                 "initialReconnectDelay=100&maxReconnectDelay=30000&maxReconnectAttempts=0&" +
1:                 "useExponentialBackOff=true";
1:         final ConnectionFactory cf = new ActiveMQConnectionFactory(url);
1: 
1:         public static final String SUBSCRIPTION_NAME = "subscription";
1: 
1:         private final int id;
1:         private final String conClientId;
1: 
1:         private final Random lifetime;
1:         private final Random online;
1:         private final Random offline;
1: 
1:         private final ClientType clientType;
1:         private final String selector;
1: 
1:         private final ConcurrentLinkedQueue<Message> waitingList = new ConcurrentLinkedQueue<Message>();
1: 
1:         public Client(int id, ClientType clientType, Random lifetime, Random online, Random offline) throws JMSException {
1:             super("Client" + id);
1:             setDaemon(true);
1: 
1:             this.id = id;
1:             conClientId = "cli" + id;
1:             this.clientType = clientType;
1:             selector = "(COMMIT = true and RELEVANT = true) or " + clientType.selector;
1: 
1:             this.lifetime = lifetime;
1:             this.online = online;
1:             this.offline = offline;
1: 
1:             subscribe();
1:         }
1: 
1:         @Override
1:         public void run() {
1:             long end = System.currentTimeMillis() + lifetime.next();
1:             try {
1:                 boolean sleep = false;
1:                 while (true) {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0)
1:                         break;
1: 
1:                     if (sleep) offline.sleepRandom();
1:                     else sleep = true;
1: 
1:                     process(online.next());
1:                 }
1: 
1:                 if (!ALLOW_SUBSCRIPTION_ABANDONMENT || random(1) > 0)
1:                     unsubscribe();
1:                 else {
1:                     LOG.info("Client abandon the subscription. " + this);
1: 
1:                     // housekeeper should sweep these abandoned subscriptions
1:                     houseKeeper.abandonedSubscriptions.add(conClientId);
1:                 }
1:             }
1:             catch (Throwable e) {
1:                 exit(toString() + " failed.", e);
1:             }
1: 
1:             clientManager.removeClient(this);
1:             LOG.info(toString() + " DONE.");
1:         }
1: 
1:         private void process(long millis) throws JMSException {
1:             long end = System.currentTimeMillis() + millis;
1:             long hardEnd = end + 2000; // wait to finish the transaction.
1:             boolean inTransaction = false;
1:             int transCount = 0;
1: 
1:             LOG.info(toString() + " ONLINE.");
1:             Connection con = openConnection();
1:             Session sess = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:             MessageConsumer consumer = sess.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, false);
1:             try {
1:                 do {
1:                     long max = end - System.currentTimeMillis();
1:                     if (max <= 0) {
1:                         if (!inTransaction)
1:                             break;
1: 
1:                         max = hardEnd - System.currentTimeMillis();
1:                         if (max <= 0)
1:                             exit("" + this + " failed: Transaction is not finished.");
1:                     }
1: 
1:                     Message message = consumer.receive(max);
1:                     if (message == null)
1:                         continue;
1: 
1:                     onClientMessage(message);
1: 
1:                     if (message.propertyExists("COMMIT")) {
1:                         message.acknowledge();
1: 
1:                         LOG.info("Received Trans[id=" + message.getIntProperty("TRANS") + ", count=" + transCount + "] in " + this + ".");
1: 
1:                         inTransaction = false;
1:                         transCount = 0;
1:                     }
1:                     else {
1:                         inTransaction = true;
1:                         transCount++;
1:                     }
1:                 } while (true);
1:             }
1:             finally {
1:                 sess.close();
1:                 con.close();
1: 
1:                 LOG.info(toString() + " OFFLINE.");
1: 
1:                 // Check if the messages are in the waiting
1:                 // list for long time.
1:                 Message topMessage = waitingList.peek();
1:                 if (topMessage != null)
1:                     checkDeliveryTime(topMessage);
1:             }
1:         }
1: 
1:         public void onServerMessage(Message message) throws JMSException {
1:             if (Boolean.TRUE.equals(message.getObjectProperty("COMMIT"))) {
1:                 if (Boolean.TRUE.equals(message.getObjectProperty("RELEVANT")))
1:                     waitingList.add(message);
1:             }
1:             else {
1:                 String messageType = message.getStringProperty("TYPE");
1:                 if (clientType.isRelevant(messageType))
1:                     waitingList.add(message);
1:             }
1:         }
1: 
1:         public void onClientMessage(Message message) {
1:             Message serverMessage = waitingList.poll();
1:             try {
1:                 if (serverMessage == null)
1:                     exit("" + this + " failed: There is no next server message, but received: " + message);
1: 
1:                 Integer receivedId = (Integer) message.getObjectProperty("ID");
1:                 Integer serverId = (Integer) serverMessage.getObjectProperty("ID");
1:                 if (receivedId == null || serverId == null)
1:                     exit("" + this + " failed: message ID not found.\r\n" +
1:                             " received: " + message + "\r\n" +
1:                             "   server: " + serverMessage);
1: 
1:                 if (!serverId.equals(receivedId))
1:                     exit("" + this + " failed: Received wrong message.\r\n" +
1:                             " received: " + message + "\r\n" +
1:                             "   server: " + serverMessage);
1: 
1:                 checkDeliveryTime(message);
1:             }
1:             catch (Throwable e) {
1:                 exit("" + this + ".onClientMessage failed.\r\n" +
1:                         " received: " + message + "\r\n" +
1:                         "   server: " + serverMessage, e);
1:             }
1:         }
1: 
1:         /**
1:          * Checks if the message was not delivered fast enough.
1:          */
1:         public void checkDeliveryTime(Message message) throws JMSException {
1:             long creation = message.getJMSTimestamp();
1:             long min = System.currentTimeMillis() - (offline.max + online.min);
1: 
1:             if (min > creation) {
1:                 SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss.SSS");
1:                 exit("" + this + ".checkDeliveryTime failed. Message time: " + df.format(new Date(creation)) + ", min: " + df.format(new Date(min)) + "\r\n" + message);
1:             }
1:         }
1: 
1:         private Connection openConnection() throws JMSException {
1:             Connection con = cf.createConnection();
1:             con.setClientID(conClientId);
1:             con.start();
1:             return con;
1:         }
1: 
1:         private void subscribe() throws JMSException {
1:             Connection con = openConnection();
1:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.createDurableSubscriber(topic, SUBSCRIPTION_NAME, selector, true);
1:             session.close();
1:             con.close();
1:         }
1: 
1:         private void unsubscribe() throws JMSException {
1:             Connection con = openConnection();
1:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.unsubscribe(SUBSCRIPTION_NAME);
1:             session.close();
1:             con.close();
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             return "Client[id=" + id + ", type=" + clientType + "]";
1:         }
1:     }
1: 
1:     /**
1:      * Sweeps out not-used durable subscriptions.
1:      */
1:     private final class HouseKeeper extends Thread {
1: 
1:         private HouseKeeper() {
1:             super("HouseKeeper");
1:             setDaemon(true);
1:         }
1: 
1:         public final CopyOnWriteArrayList<String> abandonedSubscriptions = new CopyOnWriteArrayList<String>();
1: 
1:         @Override
1:         public void run() {
1:             while (true) {
1:                 try {
1:                     Thread.sleep(60 * 1000);
1:                     sweep();
1:                 }
1:                 catch (InterruptedException ex) {
1:                     break;
1:                 }
1:                 catch (Throwable e) {
1:                     Exception log = new Exception("HouseKeeper failed.", e);
1:                     log.printStackTrace();
1:                 }
1:             }
1:         }
1: 
1:         private void sweep() throws Exception {
1:             LOG.info("Housekeeper sweeping.");
1: 
1:             int closed = 0;
1:             ArrayList<String> sweeped = new ArrayList<String>();
1:             try {
1:                 for (String clientId: abandonedSubscriptions) {
1:                     sweeped.add(clientId);
1:                     LOG.info("Sweeping out subscription of " + clientId + ".");
1:                     broker.getAdminView().destroyDurableSubscriber(clientId, Client.SUBSCRIPTION_NAME);
1:                     closed++;
1:                 }
1:             }
1:             finally {
1:                 abandonedSubscriptions.removeAll(sweeped);
1:             }
1: 
1:             LOG.info("Housekeeper sweeped out " + closed + " subscriptions.");
1:         }
1:     }
1: 
1:     public static int random(int max) {
1:         return (int) (Math.random() * (max + 1));
1:     }
1: 
1:     public static int random(int min, int max) {
1:         return random(max - min) + min;
1:     }
1: 
1:     public static void sleepRandom(int maxMillis) throws InterruptedException {
1:         Thread.sleep(random(maxMillis));
1:     }
1: 
1:     public static void sleepRandom(int minMillis, int maxMillis) throws InterruptedException {
1:         Thread.sleep(random(minMillis, maxMillis));
1:     }
1: 
1:     public static final class Random {
1: 
1:         final int min;
1:         final int max;
1: 
1:         Random(int min, int max) {
1:             this.min = min;
1:             this.max = max;
1:         }
1: 
1:         public int next() {
1:             return random(min, max);
1:         }
1: 
1:         public void sleepRandom() throws InterruptedException {
1:             DurableSubProcessTest.sleepRandom(min, max);
1:         }
1:     }
1: 
1:     public static void exit(String message) {
1:         exit(message, null);
1:     }
1: 
1:     public static void exit(String message, Throwable e) {
1:         Throwable log = new RuntimeException(message, e);
1:         log.printStackTrace();
1:         LOG.error(message, e);
1:         exceptions.add(e);
1:         fail(message);
1:     }
1: 
1:     protected void setUp() throws Exception {
1:         topic = (ActiveMQTopic) createDestination();
1:         startBroker();
1: 
1:         clientManager = new ClientManager();
1:         server = new Server();
1:         houseKeeper = new HouseKeeper();
1: 
1:         super.setUp();
1:     }
1: 
1:     protected void tearDown() throws Exception {
1:         super.tearDown();
1: 
1:         destroyBroker();
1:     }
1: 
1:     private void startBroker() throws Exception {
1:         startBroker(true);
1:     }
1: 
1:     private void startBroker(boolean deleteAllMessages) throws Exception {
1:         if (broker != null)
1:             return;
1: 
1:         broker = BrokerFactory.createBroker("broker:(vm://localhost)");
1:         broker.setBrokerName(getName());
1:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
1: 
1:         if (PERSISTENT_BROKER) {
1:             broker.setPersistent(true);
1:             KahaDBPersistenceAdapter persistenceAdapter = new KahaDBPersistenceAdapter();
1:             persistenceAdapter.setDirectory(new File("activemq-data/" + getName()));
1:             broker.setPersistenceAdapter(persistenceAdapter);
1:         }
1:         else
1:             broker.setPersistent(false);
1: 
1:         broker.addConnector("tcp://localhost:61656");
1: 
1:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getTempUsage().setLimit(256 * 1024 * 1024);
1:         broker.getSystemUsage().getStoreUsage().setLimit(256 * 1024 * 1024);
1: 
1:         broker.start();
1:     }
1: 
1:     private void destroyBroker() throws Exception {
1:         if (broker == null)
1:             return;
1: 
1:         broker.stop();
1:         broker = null;
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubProcessTest.class);
/////////////////////////////////////////////////////////////////////////
0: }
============================================================================