1:03f38ae: /**
1:03f38ae:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:03f38ae:  * contributor license agreements.  See the NOTICE file distributed with
1:03f38ae:  * this work for additional information regarding copyright ownership.
1:03f38ae:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:03f38ae:  * (the "License"); you may not use this file except in compliance with
1:03f38ae:  * the License.  You may obtain a copy of the License at
1:03f38ae:  *
1:03f38ae:  *      http://www.apache.org/licenses/LICENSE-2.0
1:03f38ae:  *
1:03f38ae:  * Unless required by applicable law or agreed to in writing, software
1:03f38ae:  * distributed under the License is distributed on an "AS IS" BASIS,
1:03f38ae:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:03f38ae:  * See the License for the specific language governing permissions and
1:03f38ae:  * limitations under the License.
1:03f38ae:  */
1:3432a75: 
1:03f38ae: package org.apache.activemq.store.jdbc;
1:6983978: 
1:fe31092: import java.sql.PreparedStatement;
1:fe31092: import java.sql.ResultSet;
1:06cbebc: import java.util.Arrays;
1:fa4481c: import java.util.HashMap;
1:06cbebc: import java.util.Vector;
1:fe31092: import java.util.concurrent.TimeUnit;
1:06cbebc: import java.util.concurrent.atomic.AtomicInteger;
1:4743a20: 
1:69dc0d4: import javax.jms.Connection;
1:3ddb71c: import javax.jms.DeliveryMode;
1:3432a75: import javax.jms.Message;
1:3ddb71c: import javax.jms.MessageListener;
1:3ddb71c: import javax.jms.MessageProducer;
1:69dc0d4: import javax.jms.Session;
1:3ddb71c: import javax.jms.TextMessage;
1:3432a75: import javax.jms.TopicSubscriber;
1:4743a20: 
1:165959e: import javax.sql.DataSource;
1:c4425ca: import junit.framework.Test;
1:4743a20: 
1:fe31092: import org.apache.activemq.command.ActiveMQMessage;
1:3432a75: import org.apache.activemq.command.ActiveMQTopic;
1:03f38ae: import org.apache.activemq.store.MessagePriorityTest;
1:03f38ae: import org.apache.activemq.store.PersistenceAdapter;
1:3ddb71c: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:3432a75: 
1:03f38ae: public class JDBCMessagePriorityTest extends MessagePriorityTest {
1:3ddb71c: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JDBCMessagePriorityTest.class);
1:165959e:     DataSource dataSource;
1:fe31092:     JDBCPersistenceAdapter jdbc;
1:3432a75: 
1:fe31092:     @Override
1:03f38ae:     protected PersistenceAdapter createPersistenceAdapter(boolean delete) throws Exception {
1:fe31092:         jdbc = new JDBCPersistenceAdapter();
1:165959e:         dataSource = jdbc.getDataSource();
1:c4425ca:         jdbc.deleteAllMessages();
1:06cbebc:         jdbc.setCleanupPeriod(2000);
1:03f38ae:         return jdbc;
1:6983978:     }
1:6983978: 
1:6983978: 
1:3432a75:     // this cannot be a general test as kahaDB just has support for 3 priority levels
1:3432a75:     public void testDurableSubsReconnectWithFourLevels() throws Exception {
1:06cbebc:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:06cbebc:         final String subName = "priorityDisconnect";
1:06cbebc:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:06cbebc:         sub.close();
1:06cbebc: 
1:3432a75:         final int MED_PRI = LOW_PRI + 1;
1:3432a75:         final int MED_HIGH_PRI = HIGH_PRI - 1;
1:06cbebc: 
1:3432a75:         ProducerThread lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:3432a75:         ProducerThread medPri = new ProducerThread(topic, MSG_NUM, MED_PRI);
1:3432a75:         ProducerThread medHighPri = new ProducerThread(topic, MSG_NUM, MED_HIGH_PRI);
1:3432a75:         ProducerThread highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
1:06cbebc: 
1:3432a75:         lowPri.start();
1:3432a75:         highPri.start();
1:3432a75:         medPri.start();
1:3432a75:         medHighPri.start();
1:06cbebc: 
1:3432a75:         lowPri.join();
1:3432a75:         highPri.join();
1:3432a75:         medPri.join();
1:3432a75:         medHighPri.join();
1:3432a75: 
1:3432a75: 
1:3432a75:         final int closeFrequency = MSG_NUM;
1:3432a75:         final int[] priorities = new int[]{HIGH_PRI, MED_HIGH_PRI, MED_PRI, LOW_PRI};
1:06cbebc:         sub = sess.createDurableSubscriber(topic, subName);
1:3432a75:         for (int i = 0; i < MSG_NUM * 4; i++) {
1:06cbebc:             Message msg = sub.receive(10000);
1:3ddb71c:             LOG.debug("received i=" + i + ", m=" + (msg != null ?
1:06cbebc:                     msg.getJMSMessageID() + ", priority: " + msg.getJMSPriority()
1:3ddb71c:                     : null));
1:06cbebc:             assertNotNull("Message " + i + " was null", msg);
1:3432a75:             assertEquals("Message " + i + " has wrong priority", priorities[i / MSG_NUM], msg.getJMSPriority());
1:3432a75:             if (i > 0 && i % closeFrequency == 0) {
1:3432a75:                 LOG.info("Closing durable sub.. on: " + i);
1:3432a75:                 sub.close();
1:06cbebc:                 sub = sess.createDurableSubscriber(topic, subName);
1:3ddb71c:             }
1:3432a75:         }
1:3432a75:         LOG.info("closing on done!");
1:3432a75:         sub.close();
1:3432a75:     }
1:3432a75: 
1:06cbebc:     public void initCombosForTestConcurrentDurableSubsReconnectWithXLevels() {
1:3ddb71c:         addCombinationValues("prioritizeMessages", new Object[]{Boolean.TRUE, Boolean.FALSE});
1:06cbebc:     }
1:3432a75: 
1:06cbebc:     public void testConcurrentDurableSubsReconnectWithXLevels() throws Exception {
1:3432a75:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:3432a75:         final String subName = "priorityDisconnect";
1:69dc0d4:         Connection consumerConn = factory.createConnection();
1:69dc0d4:         consumerConn.setClientID("priorityDisconnect");
1:69dc0d4:         consumerConn.start();
1:69dc0d4:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3432a75: 
1:69dc0d4:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
1:3432a75:         sub.close();
1:3432a75: 
1:06cbebc:         final int maxPriority = 5;
1:69dc0d4: 
1:06cbebc:         final AtomicInteger[] messageCounts = new AtomicInteger[maxPriority];
1:fe31092:         final long[] messageIds = new long[maxPriority];
1:06cbebc:         Vector<ProducerThread> producers = new Vector<ProducerThread>();
1:3ddb71c:         for (int priority = 0; priority < maxPriority; priority++) {
1:06cbebc:             producers.add(new ProducerThread(topic, MSG_NUM, priority));
1:06cbebc:             messageCounts[priority] = new AtomicInteger(0);
1:fe31092:             messageIds[priority] = 1l;
1:06cbebc:         }
1:06cbebc: 
1:06cbebc:         for (ProducerThread producer : producers) {
1:06cbebc:             producer.start();
1:06cbebc:         }
1:06cbebc: 
1:3ddb71c:         final int closeFrequency = MSG_NUM / 2;
1:4743a20:         HashMap<String, String> dups = new HashMap<String, String>();
1:69dc0d4:         sub = consumerSession.createDurableSubscriber(topic, subName);
1:3ddb71c:         for (int i = 0; i < MSG_NUM * maxPriority; i++) {
1:06cbebc:             Message msg = sub.receive(10000);
1:3ddb71c:             LOG.debug("received i=" + i + ", m=" + (msg != null ?
1:06cbebc:                     msg.getJMSMessageID() + ", priority: " + msg.getJMSPriority()
1:3ddb71c:                     : null));
1:fe31092:             assertNotNull("Message " + i + " was null, counts: " + Arrays.toString(messageCounts), msg);
1:3ddb71c:             assertNull("no duplicate message failed on : " + msg.getJMSMessageID(), dups.put(msg.getJMSMessageID(), subName));
1:06cbebc:             messageCounts[msg.getJMSPriority()].incrementAndGet();
1:fe31092:             assertEquals("message is in order : " + msg,
1:fe31092:                     messageIds[msg.getJMSPriority()],((ActiveMQMessage)msg).getMessageId().getProducerSequenceId());
1:fe31092:             messageIds[msg.getJMSPriority()]++;
1:06cbebc:             if (i > 0 && i % closeFrequency == 0) {
1:06cbebc:                 LOG.info("Closing durable sub.. on: " + i + ", counts: " + Arrays.toString(messageCounts));
1:06cbebc:                 sub.close();
1:69dc0d4:                 sub = consumerSession.createDurableSubscriber(topic, subName);
1:06cbebc:             }
1:06cbebc:         }
1:06cbebc:         LOG.info("closing on done!");
1:06cbebc:         sub.close();
1:69dc0d4:         consumerSession.close();
1:69dc0d4:         consumerConn.close();
1:06cbebc: 
1:06cbebc:         for (ProducerThread producer : producers) {
1:06cbebc:             producer.join();
1:06cbebc:         }
1:06cbebc:     }
1:06cbebc: 
1:3ddb71c:     public void initCombosForTestConcurrentRate() {
1:3ddb71c:         addCombinationValues("prefetchVal", new Object[]{new Integer(1), new Integer(500)});
1:3ddb71c:     }
1:3ddb71c: 
1:3ddb71c:     public void testConcurrentRate() throws Exception {
1:3ddb71c:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:3ddb71c:         final String subName = "priorityConcurrent";
1:3ddb71c:         Connection consumerConn = factory.createConnection();
1:3ddb71c:         consumerConn.setClientID("subName");
1:3ddb71c:         consumerConn.start();
1:3ddb71c:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3ddb71c:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
1:3ddb71c:         sub.close();
1:3ddb71c: 
1:3ddb71c:         final int TO_SEND = 2000;
1:3ddb71c:         final Vector<Message> duplicates = new Vector<Message>();
1:3ddb71c:         final int[] dups = new int[TO_SEND * 4];
1:3ddb71c:         long start;
1:3ddb71c:         double max = 0, sum = 0;
1:3ddb71c:         MessageProducer messageProducer = sess.createProducer(topic);
1:3ddb71c:         TextMessage message = sess.createTextMessage();
1:3ddb71c:         for (int i = 0; i < TO_SEND; i++) {
1:3ddb71c:             int priority = i % 10;
1:3ddb71c:             message.setText(i + "-" + priority);
1:3ddb71c:             message.setIntProperty("seq", i);
1:3ddb71c:             message.setJMSPriority(priority);
1:3ddb71c:             if (i > 0 && i % 1000 == 0) {
1:3ddb71c:                 LOG.info("Max send time: " + max + ". Sending message: " + message.getText());
1:3ddb71c:             }
1:3ddb71c:             start = System.currentTimeMillis();
1:3ddb71c:             messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1:3ddb71c:             long duration = System.currentTimeMillis() - start;
1:3ddb71c:             max = Math.max(max, duration);
1:3ddb71c:             if (duration == max) {
1:3ddb71c:                 LOG.info("new max: " + max + " on i=" + i + ", " + message.getText());
1:3ddb71c:             }
1:3ddb71c:             sum += duration;
1:3ddb71c:         }
1:3ddb71c: 
1:3ddb71c:         LOG.info("Sent: " + TO_SEND + ", max send time: " + max);
1:3ddb71c: 
1:3ddb71c:         double noConsumerAve = (sum * 100 / TO_SEND);
1:3ddb71c:         sub = consumerSession.createDurableSubscriber(topic, subName);
1:3ddb71c:         final AtomicInteger count = new AtomicInteger();
1:3ddb71c:         sub.setMessageListener(new MessageListener() {
1:4743a20:             @Override
1:3ddb71c:             public void onMessage(Message message) {
1:6983978:                 try {
1:3ddb71c:                     count.incrementAndGet();
1:3ddb71c:                     if (count.get() % 100 == 0) {
1:3ddb71c:                         LOG.info("onMessage: count: " + count.get() + ", " + ((TextMessage) message).getText() + ", seqNo " + message.getIntProperty("seq") + ", " + message.getJMSMessageID());
1:cc64a51:                     }
1:3ddb71c:                     int seqNo = message.getIntProperty("seq");
1:3ddb71c:                     if (dups[seqNo] == 0) {
1:3ddb71c:                         dups[seqNo] = 1;
1:3ddb71c:                     } else {
1:3ddb71c:                         LOG.error("Duplicate: " + ((TextMessage) message).getText() + ", " + message.getJMSMessageID());
1:3ddb71c:                         duplicates.add(message);
1:6983978:                     }
1:3ddb71c:                 } catch (Exception e) {
1:3ddb71c:                     e.printStackTrace();
1:3ddb71c:                 }
1:3ddb71c:             }
1:3ddb71c:         });
1:3ddb71c: 
1:3ddb71c:         LOG.info("Activated consumer");
1:3ddb71c:         sum = max = 0;
1:3ddb71c:         for (int i = TO_SEND; i < (TO_SEND * 2); i++) {
1:3ddb71c:             int priority = i % 10;
1:3ddb71c:             message.setText(i + "-" + priority);
1:3ddb71c:             message.setIntProperty("seq", i);
1:3ddb71c:             message.setJMSPriority(priority);
1:3ddb71c:             if (i > 0 && i % 1000 == 0) {
1:3ddb71c:                 LOG.info("Max send time: " + max + ". Sending message: " + message.getText());
1:3ddb71c:             }
1:3ddb71c:             start = System.currentTimeMillis();
1:3ddb71c:             messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1:3ddb71c:             long duration = System.currentTimeMillis() - start;
1:3ddb71c:             max = Math.max(max, duration);
1:3ddb71c:             if (duration == max) {
1:3ddb71c:                 LOG.info("new max: " + max + " on i=" + i + ", " + message.getText());
1:3ddb71c:             }
1:3ddb71c:             sum += duration;
1:3ddb71c:         }
1:3ddb71c:         LOG.info("Sent another: " + TO_SEND + ", max send time: " + max);
1:3ddb71c: 
1:3ddb71c:         double withConsumerAve = (sum * 100 / TO_SEND);
1:72bf2f8:         final int reasonableMultiplier = 4; // not so reasonable, but on slow disks it can be
1:72bf2f8:         assertTrue("max X times as slow with consumer:" + withConsumerAve + " , noConsumerMax:" + noConsumerAve,
1:72bf2f8:                 withConsumerAve < noConsumerAve * reasonableMultiplier);
1:3ddb71c:         Wait.waitFor(new Wait.Condition() {
1:4743a20:             @Override
1:3ddb71c:             public boolean isSatisified() throws Exception {
1:3ddb71c:                 LOG.info("count: " + count.get());
1:3ddb71c:                 return TO_SEND * 2 == count.get();
1:3ddb71c:             }
1:3ddb71c:         }, 60 * 1000);
1:3ddb71c: 
1:3ddb71c:         assertTrue("No duplicates : " + duplicates, duplicates.isEmpty());
1:3ddb71c:         assertEquals("got all messages", TO_SEND * 2, count.get());
1:3ddb71c:     }
1:3ddb71c: 
1:fe31092:     public void testCleanupPriorityDestination() throws Exception {
1:fe31092:         assertEquals("no messages pending", 0, messageTableCount());
1:fe31092: 
1:fe31092:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:fe31092:         final String subName = "priorityConcurrent";
1:fe31092:         Connection consumerConn = factory.createConnection();
1:fe31092:         consumerConn.setClientID("subName");
1:fe31092:         consumerConn.start();
1:fe31092:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:fe31092:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
1:fe31092:         sub.close();
1:fe31092: 
1:fe31092:         MessageProducer messageProducer = sess.createProducer(topic);
1:fe31092:         Message message = sess.createTextMessage();
1:fe31092:         message.setJMSPriority(2);
1:fe31092:         messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1:fe31092:         message.setJMSPriority(5);
1:fe31092:         messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1:fe31092: 
1:fe31092:         assertEquals("two messages pending", 2, messageTableCount());
1:fe31092: 
1:fe31092:         sub = consumerSession.createDurableSubscriber(topic, subName);
1:fe31092: 
1:fe31092:         message = sub.receive(5000);
1:fe31092:         assertEquals("got high priority", 5, message.getJMSPriority());
1:fe31092: 
1:fe31092:         waitForAck(5);
1:fe31092: 
1:fe31092:         for (int i=0; i<10; i++) {
1:fe31092:             jdbc.cleanup();
1:fe31092:         }
1:fe31092:         assertEquals("one messages pending", 1, messageTableCount());
1:fe31092: 
1:fe31092:         message = sub.receive(5000);
1:fe31092:         assertEquals("got high priority", 2, message.getJMSPriority());
1:fe31092: 
1:fe31092:         waitForAck(2);
1:fe31092: 
1:fe31092:         for (int i=0; i<10; i++) {
1:fe31092:             jdbc.cleanup();
1:fe31092:         }
1:fe31092:         assertEquals("no messages pending", 0, messageTableCount());
1:fe31092:     }
1:fe31092: 
1:fe31092: 
1:fe31092:     public void testCleanupNonPriorityDestination() throws Exception {
1:fe31092:         assertEquals("no messages pending", 0, messageTableCount());
1:fe31092: 
1:fe31092:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST_CLEANUP_NO_PRIORITY");
1:fe31092:         final String subName = "subName";
1:fe31092:         Connection consumerConn = factory.createConnection();
1:fe31092:         consumerConn.setClientID("subName");
1:fe31092:         consumerConn.start();
1:fe31092:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:fe31092:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
1:fe31092:         sub.close();
1:fe31092: 
1:fe31092:         MessageProducer messageProducer = sess.createProducer(topic);
1:fe31092:         Message message = sess.createTextMessage("ToExpire");
1:fe31092:         messageProducer.send(message, DeliveryMode.PERSISTENT, Message.DEFAULT_PRIORITY, 4000);
1:fe31092: 
1:fe31092:         message = sess.createTextMessage("A");
1:fe31092:         messageProducer.send(message);
1:fe31092:         message = sess.createTextMessage("B");
1:fe31092:         messageProducer.send(message);
1:fe31092:         message = null;
1:fe31092: 
1:fe31092:         assertEquals("three messages pending", 3, messageTableCount());
1:fe31092: 
1:fe31092:         // let first message expire
1:fe31092:         TimeUnit.SECONDS.sleep(5);
1:fe31092: 
1:fe31092:         sub = consumerSession.createDurableSubscriber(topic, subName);
1:fe31092:         message = sub.receive(5000);
1:fe31092:         assertNotNull("got message", message);
1:fe31092:         LOG.info("Got: " + message);
1:fe31092: 
1:fe31092:         waitForAck(0, 1);
1:fe31092: 
1:fe31092:         for (int i=0; i<10; i++) {
1:fe31092:             jdbc.cleanup();
1:fe31092:         }
1:fe31092:         assertEquals("one messages pending", 1, messageTableCount());
1:fe31092: 
1:fe31092:         message = sub.receive(5000);
1:fe31092:         assertNotNull("got message two", message);
1:fe31092:         LOG.info("Got: " + message);
1:fe31092: 
1:fe31092:         waitForAck(0, 2);
1:fe31092: 
1:fe31092:         for (int i=0; i<10; i++) {
1:fe31092:             jdbc.cleanup();
1:fe31092:         }
1:fe31092:         assertEquals("no messages pending", 0, messageTableCount());
1:fe31092:     }
1:fe31092: 
1:fe31092:     private int messageTableCount() throws Exception {
1:fe31092:         int count = -1;
1:fe31092:         java.sql.Connection c = dataSource.getConnection();
1:fe31092:         try {
1:fe31092:             PreparedStatement s = c.prepareStatement("SELECT COUNT(*) FROM ACTIVEMQ_MSGS");
1:fe31092:             ResultSet rs = s.executeQuery();
1:fe31092:             if (rs.next()) {
1:fe31092:                 count = rs.getInt(1);
1:fe31092:             }
1:fe31092:         } finally {
1:fe31092:             if (c!=null) {
1:fe31092:                 c.close();
1:fe31092:             }
1:fe31092:         }
1:fe31092:         return count;
1:fe31092:     }
1:fe31092: 
1:fe31092:     private void waitForAck(final int priority) throws Exception {
1:fe31092:         waitForAck(priority, 0);
1:fe31092:     }
1:fe31092: 
1:fe31092:     private void waitForAck(final int priority, final int minId) throws Exception {
1:fe31092:        assertTrue("got ack for " + priority, Wait.waitFor(new Wait.Condition() {
1:4743a20:            @Override
1:fe31092:            public boolean isSatisified() throws Exception {
1:fe31092:                int id = 0;
1:fe31092:                java.sql.Connection c = dataSource.getConnection();
1:fe31092:                try {
1:fe31092:                     PreparedStatement s = c.prepareStatement("SELECT LAST_ACKED_ID FROM ACTIVEMQ_ACKS WHERE PRIORITY=" + priority);
1:fe31092:                     ResultSet rs = s.executeQuery();
1:fe31092:                     if (rs.next()) {
1:fe31092:                         id = rs.getInt(1);
1:fe31092:                     }
1:fe31092:                 } finally {
1:fe31092:                     if (c!=null) {
1:fe31092:                         c.close();
1:fe31092:                     }
1:fe31092:                 }
1:fe31092:                return id>minId;
1:fe31092:            }
1:fe31092:        }));
1:fe31092:     }
1:fe31092: 
1:4743a20:     @SuppressWarnings("unused")
1:fe31092:     private int messageTableDump() throws Exception {
1:fe31092:         int count = -1;
1:fe31092:         java.sql.Connection c = dataSource.getConnection();
1:fe31092:         try {
1:fe31092:             PreparedStatement s = c.prepareStatement("SELECT * FROM ACTIVEMQ_MSGS");
1:fe31092:             ResultSet rs = s.executeQuery();
1:fe31092:             if (rs.next()) {
1:fe31092:                 count = rs.getInt(1);
1:fe31092:             }
1:fe31092:         } finally {
1:fe31092:             if (c!=null) {
1:fe31092:                 c.close();
1:fe31092:             }
1:fe31092:         }
1:fe31092:         return count;
1:fe31092:     }
1:fe31092: 
1:c4425ca:     public static Test suite() {
1:c4425ca:         return suite(JDBCMessagePriorityTest.class);
1:3ddb71c:     }
1:c4425ca: 
1:3432a75: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:f2a335c
/////////////////////////////////////////////////////////////////////////
commit:165959e
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.DataSource;
/////////////////////////////////////////////////////////////////////////
1:     DataSource dataSource;
1:         dataSource = jdbc.getDataSource();
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0: import org.apache.derby.jdbc.EmbeddedDataSource;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String, String> dups = new HashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unused")
commit:ef24cc9
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.util.ThreadTracker;
/////////////////////////////////////////////////////////////////////////
1:     JDBCPersistenceAdapter jdbc;
1:         jdbc = new JDBCPersistenceAdapter();
/////////////////////////////////////////////////////////////////////////
1:         final long[] messageIds = new long[maxPriority];
1:             messageIds[priority] = 1l;
/////////////////////////////////////////////////////////////////////////
1:             assertNotNull("Message " + i + " was null, counts: " + Arrays.toString(messageCounts), msg);
1:             assertEquals("message is in order : " + msg,
1:                     messageIds[msg.getJMSPriority()],((ActiveMQMessage)msg).getMessageId().getProducerSequenceId());
1:             messageIds[msg.getJMSPriority()]++;
/////////////////////////////////////////////////////////////////////////
1:     public void testCleanupPriorityDestination() throws Exception {
1:         assertEquals("no messages pending", 0, messageTableCount());
1: 
1:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:         final String subName = "priorityConcurrent";
1:         Connection consumerConn = factory.createConnection();
1:         consumerConn.setClientID("subName");
1:         consumerConn.start();
1:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         MessageProducer messageProducer = sess.createProducer(topic);
1:         Message message = sess.createTextMessage();
1:         message.setJMSPriority(2);
1:         messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1:         message.setJMSPriority(5);
1:         messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1: 
1:         assertEquals("two messages pending", 2, messageTableCount());
1: 
1:         sub = consumerSession.createDurableSubscriber(topic, subName);
1: 
1:         message = sub.receive(5000);
1:         assertEquals("got high priority", 5, message.getJMSPriority());
1: 
1:         waitForAck(5);
1: 
1:         for (int i=0; i<10; i++) {
1:             jdbc.cleanup();
1:         }
1:         assertEquals("one messages pending", 1, messageTableCount());
1: 
1:         message = sub.receive(5000);
1:         assertEquals("got high priority", 2, message.getJMSPriority());
1: 
1:         waitForAck(2);
1: 
1:         for (int i=0; i<10; i++) {
1:             jdbc.cleanup();
1:         }
1:         assertEquals("no messages pending", 0, messageTableCount());
1:     }
1: 
1: 
1:     public void testCleanupNonPriorityDestination() throws Exception {
1:         assertEquals("no messages pending", 0, messageTableCount());
1: 
1:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST_CLEANUP_NO_PRIORITY");
1:         final String subName = "subName";
1:         Connection consumerConn = factory.createConnection();
1:         consumerConn.setClientID("subName");
1:         consumerConn.start();
1:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         MessageProducer messageProducer = sess.createProducer(topic);
1:         Message message = sess.createTextMessage("ToExpire");
1:         messageProducer.send(message, DeliveryMode.PERSISTENT, Message.DEFAULT_PRIORITY, 4000);
1: 
1:         message = sess.createTextMessage("A");
1:         messageProducer.send(message);
1:         message = sess.createTextMessage("B");
1:         messageProducer.send(message);
1:         message = null;
1: 
1:         assertEquals("three messages pending", 3, messageTableCount());
1: 
1:         // let first message expire
1:         TimeUnit.SECONDS.sleep(5);
1: 
1:         sub = consumerSession.createDurableSubscriber(topic, subName);
1:         message = sub.receive(5000);
1:         assertNotNull("got message", message);
1:         LOG.info("Got: " + message);
1: 
1:         waitForAck(0, 1);
1: 
1:         for (int i=0; i<10; i++) {
1:             jdbc.cleanup();
1:         }
1:         assertEquals("one messages pending", 1, messageTableCount());
1: 
1:         message = sub.receive(5000);
1:         assertNotNull("got message two", message);
1:         LOG.info("Got: " + message);
1: 
1:         waitForAck(0, 2);
1: 
1:         for (int i=0; i<10; i++) {
1:             jdbc.cleanup();
1:         }
1:         assertEquals("no messages pending", 0, messageTableCount());
1:     }
1: 
1:     private int messageTableCount() throws Exception {
1:         int count = -1;
1:         java.sql.Connection c = dataSource.getConnection();
1:         try {
1:             PreparedStatement s = c.prepareStatement("SELECT COUNT(*) FROM ACTIVEMQ_MSGS");
1:             ResultSet rs = s.executeQuery();
1:             if (rs.next()) {
1:                 count = rs.getInt(1);
1:             }
1:         } finally {
1:             if (c!=null) {
1:                 c.close();
1:             }
1:         }
1:         return count;
1:     }
1: 
1:     private void waitForAck(final int priority) throws Exception {
1:         waitForAck(priority, 0);
1:     }
1: 
1:     private void waitForAck(final int priority, final int minId) throws Exception {
1:        assertTrue("got ack for " + priority, Wait.waitFor(new Wait.Condition() {
1:            @Override
1:            public boolean isSatisified() throws Exception {
1:                int id = 0;
1:                java.sql.Connection c = dataSource.getConnection();
1:                try {
1:                     PreparedStatement s = c.prepareStatement("SELECT LAST_ACKED_ID FROM ACTIVEMQ_ACKS WHERE PRIORITY=" + priority);
1:                     ResultSet rs = s.executeQuery();
1:                     if (rs.next()) {
1:                         id = rs.getInt(1);
1:                     }
1:                 } finally {
1:                     if (c!=null) {
1:                         c.close();
1:                     }
1:                 }
1:                return id>minId;
1:            }
1:        }));
1:     }
1: 
1:     private int messageTableDump() throws Exception {
1:         int count = -1;
1:         java.sql.Connection c = dataSource.getConnection();
1:         try {
1:             PreparedStatement s = c.prepareStatement("SELECT * FROM ACTIVEMQ_MSGS");
1:             ResultSet rs = s.executeQuery();
1:             if (rs.next()) {
1:                 count = rs.getInt(1);
1:             }
1:         } finally {
1:             if (c!=null) {
1:                 c.close();
1:             }
1:         }
1:         return count;
1:     }
1: 
commit:cc64a51
/////////////////////////////////////////////////////////////////////////
0:         dataSource.setShutdownDatabase(null);
/////////////////////////////////////////////////////////////////////////
0:             if (dataSource != null) {
0:                 // ref http://svn.apache.org/viewvc/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/JDBCDataSource.java?view=markup
0:                 dataSource.setShutdownDatabase("shutdown");
0:                 dataSource.getConnection();
1:            }
0:        } finally {
0:             dataSource.setShutdownDatabase(null);
commit:6983978
/////////////////////////////////////////////////////////////////////////
0:     EmbeddedDataSource dataSource;
0:         dataSource = new EmbeddedDataSource();
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected void tearDown() throws Exception {
0:        super.tearDown();
1:        try {
0:            dataSource.setShutdownDatabase("true");
0:            dataSource.getConnection();
0:        } catch (Exception ignored) {
1:        }
1: 
1:     }
1: 
commit:72bf2f8
/////////////////////////////////////////////////////////////////////////
1:         final int reasonableMultiplier = 4; // not so reasonable, but on slow disks it can be
1:         assertTrue("max X times as slow with consumer:" + withConsumerAve + " , noConsumerMax:" + noConsumerAve,
1:                 withConsumerAve < noConsumerAve * reasonableMultiplier);
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.DeliveryMode;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.TextMessage;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("received i=" + i + ", m=" + (msg != null ?
1:                     : null));
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("prioritizeMessages", new Object[]{Boolean.TRUE, Boolean.FALSE});
/////////////////////////////////////////////////////////////////////////
1:         for (int priority = 0; priority < maxPriority; priority++) {
/////////////////////////////////////////////////////////////////////////
1:         final int closeFrequency = MSG_NUM / 2;
1:         for (int i = 0; i < MSG_NUM * maxPriority; i++) {
1:             LOG.debug("received i=" + i + ", m=" + (msg != null ?
1:                     : null));
1:             assertNull("no duplicate message failed on : " + msg.getJMSMessageID(), dups.put(msg.getJMSMessageID(), subName));
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestConcurrentRate() {
1:         addCombinationValues("prefetchVal", new Object[]{new Integer(1), new Integer(500)});
1:     }
1: 
1:     public void testConcurrentRate() throws Exception {
1:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:         final String subName = "priorityConcurrent";
1:         Connection consumerConn = factory.createConnection();
1:         consumerConn.setClientID("subName");
1:         consumerConn.start();
1:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         final int TO_SEND = 2000;
1:         final Vector<Message> duplicates = new Vector<Message>();
1:         final int[] dups = new int[TO_SEND * 4];
1:         long start;
1:         double max = 0, sum = 0;
1:         MessageProducer messageProducer = sess.createProducer(topic);
1:         TextMessage message = sess.createTextMessage();
1:         for (int i = 0; i < TO_SEND; i++) {
1:             int priority = i % 10;
1:             message.setText(i + "-" + priority);
1:             message.setIntProperty("seq", i);
1:             message.setJMSPriority(priority);
1:             if (i > 0 && i % 1000 == 0) {
1:                 LOG.info("Max send time: " + max + ". Sending message: " + message.getText());
1:             }
1:             start = System.currentTimeMillis();
1:             messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1:             long duration = System.currentTimeMillis() - start;
1:             max = Math.max(max, duration);
1:             if (duration == max) {
1:                 LOG.info("new max: " + max + " on i=" + i + ", " + message.getText());
1:             }
1:             sum += duration;
1:         }
1: 
1:         LOG.info("Sent: " + TO_SEND + ", max send time: " + max);
1: 
1:         double noConsumerAve = (sum * 100 / TO_SEND);
1:         sub = consumerSession.createDurableSubscriber(topic, subName);
1:         final AtomicInteger count = new AtomicInteger();
1:         sub.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
0:                 try {
1:                     count.incrementAndGet();
1:                     if (count.get() % 100 == 0) {
1:                         LOG.info("onMessage: count: " + count.get() + ", " + ((TextMessage) message).getText() + ", seqNo " + message.getIntProperty("seq") + ", " + message.getJMSMessageID());
1:                     }
1:                     int seqNo = message.getIntProperty("seq");
1:                     if (dups[seqNo] == 0) {
1:                         dups[seqNo] = 1;
1:                     } else {
1:                         LOG.error("Duplicate: " + ((TextMessage) message).getText() + ", " + message.getJMSMessageID());
1:                         duplicates.add(message);
1:                     }
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
1:         LOG.info("Activated consumer");
1:         sum = max = 0;
1:         for (int i = TO_SEND; i < (TO_SEND * 2); i++) {
1:             int priority = i % 10;
1:             message.setText(i + "-" + priority);
1:             message.setIntProperty("seq", i);
1:             message.setJMSPriority(priority);
1:             if (i > 0 && i % 1000 == 0) {
1:                 LOG.info("Max send time: " + max + ". Sending message: " + message.getText());
1:             }
1:             start = System.currentTimeMillis();
1:             messageProducer.send(message, DeliveryMode.PERSISTENT, message.getJMSPriority(), 0);
1:             long duration = System.currentTimeMillis() - start;
1:             max = Math.max(max, duration);
1:             if (duration == max) {
1:                 LOG.info("new max: " + max + " on i=" + i + ", " + message.getText());
1:             }
1:             sum += duration;
1:         }
1:         LOG.info("Sent another: " + TO_SEND + ", max send time: " + max);
1: 
1:         double withConsumerAve = (sum * 100 / TO_SEND);
0:         assertTrue("max three times as slow with consumer:" + withConsumerAve + " , noConsumerMax:" + noConsumerAve,
0:                 withConsumerAve < noConsumerAve * 3);
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("count: " + count.get());
1:                 return TO_SEND * 2 == count.get();
1:             }
1:         }, 60 * 1000);
1: 
1:         assertTrue("No duplicates : " + duplicates, duplicates.isEmpty());
1:         assertEquals("got all messages", TO_SEND * 2, count.get());
1:     }
1: 
commit:6aacb03
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("received i=" + i + ", m=" + (msg!=null?
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("received i=" + i + ", m=" + (msg!=null?
0:             assertNull("no duplicate message failed on : " + msg.getJMSMessageID(), dups.put(msg.getJMSMessageID(), subName));            
commit:fa4481c
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0:         HashMap dups = new HashMap();
0:             assertNull("no duplicate message", dups.put(msg.getJMSMessageID(), subName));
commit:06cbebc
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Vector;
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1:         jdbc.setCleanupPeriod(2000);
/////////////////////////////////////////////////////////////////////////
1:             Message msg = sub.receive(10000);
0:             LOG.info("received i=" + i + ", m=" + (msg!=null?
1:                     msg.getJMSMessageID() + ", priority: " + msg.getJMSPriority()
0:                     : null) );
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestConcurrentDurableSubsReconnectWithXLevels() {
0:         addCombinationValues("prioritizeMessages", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:     }
1: 
1:     public void testConcurrentDurableSubsReconnectWithXLevels() throws Exception {
1:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:         final String subName = "priorityDisconnect";
1:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         final int maxPriority = 5;
1: 
1:         final AtomicInteger[] messageCounts = new AtomicInteger[maxPriority];
1:         Vector<ProducerThread> producers = new Vector<ProducerThread>();
0:         for (int priority=0; priority <maxPriority; priority++) {
1:             producers.add(new ProducerThread(topic, MSG_NUM, priority));
1:             messageCounts[priority] = new AtomicInteger(0);
1:         }
1: 
1:         for (ProducerThread producer : producers) {
1:             producer.start();
1:         }
1: 
0:         final int closeFrequency = MSG_NUM/2;
1: 
1:         sub = sess.createDurableSubscriber(topic, subName);
0:         for (int i=0; i < MSG_NUM * maxPriority; i++) {
1:             Message msg = sub.receive(10000);
0:             LOG.info("received i=" + i + ", m=" + (msg!=null?
1:                     msg.getJMSMessageID() + ", priority: " + msg.getJMSPriority()
0:                     : null) );
1:             assertNotNull("Message " + i + " was null", msg);
1:             messageCounts[msg.getJMSPriority()].incrementAndGet();
1:             if (i > 0 && i % closeFrequency == 0) {
1:                 LOG.info("Closing durable sub.. on: " + i + ", counts: " + Arrays.toString(messageCounts));
1:                 sub.close();
1:                 sub = sess.createDurableSubscriber(topic, subName);
1:             }
1:         }
1:         LOG.info("closing on done!");
1:         sub.close();
1: 
1:         for (ProducerThread producer : producers) {
1:             producer.join();
1:         }
1:     }
1: 
commit:107509f
/////////////////////////////////////////////////////////////////////////
0:         dataSource.setShutdownDatabase("false");
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Message;
1: import javax.jms.TopicSubscriber;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(JDBCMessagePriorityTest.class);
1:     
/////////////////////////////////////////////////////////////////////////
0:         jdbc.setCleanupPeriod(1000);
1: 
1:     // this cannot be a general test as kahaDB just has support for 3 priority levels
1:     public void testDurableSubsReconnectWithFourLevels() throws Exception {
1:         ActiveMQTopic topic = (ActiveMQTopic) sess.createTopic("TEST");
1:         final String subName = "priorityDisconnect";
0:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         final int MED_PRI = LOW_PRI + 1;
1:         final int MED_HIGH_PRI = HIGH_PRI - 1;
1: 
1:         ProducerThread lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:         ProducerThread medPri = new ProducerThread(topic, MSG_NUM, MED_PRI);
1:         ProducerThread medHighPri = new ProducerThread(topic, MSG_NUM, MED_HIGH_PRI);
1:         ProducerThread highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
1: 
1:         lowPri.start();
1:         highPri.start();
1:         medPri.start();
1:         medHighPri.start();
1: 
1:         lowPri.join();
1:         highPri.join();
1:         medPri.join();
1:         medHighPri.join();
1: 
1: 
1:         final int closeFrequency = MSG_NUM;
1:         final int[] priorities = new int[]{HIGH_PRI, MED_HIGH_PRI, MED_PRI, LOW_PRI};
0:         sub = sess.createDurableSubscriber(topic, subName);
1:         for (int i = 0; i < MSG_NUM * 4; i++) {
0:             Message msg = sub.receive(30000);
0:             LOG.debug("received i=" + i + ", m=" + (msg!=null? msg.getJMSMessageID() : null));
0:             assertNotNull("Message " + i + " was null", msg);
1:             assertEquals("Message " + i + " has wrong priority", priorities[i / MSG_NUM], msg.getJMSPriority());
1:             if (i > 0 && i % closeFrequency == 0) {
1:                 LOG.info("Closing durable sub.. on: " + i);
1:                 sub.close();
0:                 sub = sess.createDurableSubscriber(topic, subName);
1:             }
1:         }
1:         LOG.info("closing on done!");
1:         sub.close();
1:     }
1: 
commit:9705671
/////////////////////////////////////////////////////////////////////////
0:     // pending fix...
0:     @Override
0:     public void testDurableSubsReconnect() throws Exception {
0:         // TODO: fix jdbc durable sub recovery 
0:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JDBCMessagePriorityTest.class);
commit:69dc0d4
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Connection;
1: import javax.jms.Session;
/////////////////////////////////////////////////////////////////////////
1:         Connection consumerConn = factory.createConnection();
1:         consumerConn.setClientID("priorityDisconnect");
1:         consumerConn.start();
1:         Session consumerSession = consumerConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         TopicSubscriber sub = consumerSession.createDurableSubscriber(topic, subName);
/////////////////////////////////////////////////////////////////////////
1:         sub = consumerSession.createDurableSubscriber(topic, subName);
/////////////////////////////////////////////////////////////////////////
1:                 sub = consumerSession.createDurableSubscriber(topic, subName);
1:         consumerSession.close();
1:         consumerConn.close();
commit:c4425ca
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
1: 
/////////////////////////////////////////////////////////////////////////
1:         jdbc.deleteAllMessages();
0:     
1:     public static Test suite() {
1:         return suite(JDBCMessagePriorityTest.class);
0:     }
commit:03f38ae
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.activemq.store.jdbc;
0: 
1: import org.apache.activemq.store.MessagePriorityTest;
1: import org.apache.activemq.store.PersistenceAdapter;
0: import org.apache.derby.jdbc.EmbeddedDataSource;
0: 
1: public class JDBCMessagePriorityTest extends MessagePriorityTest {
0: 
0:     @Override
1:     protected PersistenceAdapter createPersistenceAdapter(boolean delete) throws Exception {
0:         JDBCPersistenceAdapter jdbc = new JDBCPersistenceAdapter();
0:         EmbeddedDataSource dataSource = new EmbeddedDataSource();
0:         dataSource.setDatabaseName("derbyDb");
0:         dataSource.setCreateDatabase("create");
0:         jdbc.setDataSource(dataSource);
1:         return jdbc;
0:     }
0: 
0: }
============================================================================