1:1045fc0: /**
1:7f883f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7f883f6:  * contributor license agreements.  See the NOTICE file distributed with
1:7f883f6:  * this work for additional information regarding copyright ownership.
1:7f883f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7f883f6:  * (the "License"); you may not use this file except in compliance with
1:7f883f6:  * the License.  You may obtain a copy of the License at
3:9c42236:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9c42236:  *
1:1045fc0:  * Unless required by applicable law or agreed to in writing, software
1:1045fc0:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1045fc0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1045fc0:  * See the License for the specific language governing permissions and
1:1045fc0:  * limitations under the License.
1:1045fc0:  */
1:1045fc0: package org.apache.activemq.network;
2:d36c0d4: 
1:82295fd: import static org.junit.Assert.assertEquals;
1:c7d559f: import static org.junit.Assert.assertNotNull;
1:c7d559f: import static org.junit.Assert.assertNull;
1:c7d559f: import static org.junit.Assert.assertTrue;
1:a307c57: 
1:a307c57: import java.util.Arrays;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:a307c57: 
1:a307c57: import javax.jms.DeliveryMode;
1:a307c57: import javax.jms.Destination;
1:a307c57: import javax.jms.JMSException;
1:a307c57: import javax.jms.Message;
1:a307c57: import javax.jms.MessageConsumer;
1:a307c57: import javax.jms.MessageListener;
1:a307c57: import javax.jms.MessageProducer;
1:a307c57: import javax.jms.TextMessage;
1:a307c57: import javax.jms.TopicRequestor;
1:a307c57: import javax.jms.TopicSession;
1:a307c57: 
1:a307c57: import org.apache.activemq.ActiveMQConnection;
1:1045fc0: import org.apache.activemq.broker.BrokerService;
1:ecb10e9: import org.apache.activemq.command.ActiveMQDestination;
1:a307c57: import org.apache.activemq.command.ActiveMQMessage;
1:406a342: import org.apache.activemq.command.ActiveMQQueue;
1:1045fc0: import org.apache.activemq.command.ActiveMQTopic;
1:8d0cf31: import org.apache.activemq.command.ConsumerId;
1:8d0cf31: import org.apache.activemq.util.Wait;
1:406a342: import org.apache.activemq.util.Wait.Condition;
1:c3e57ec: import org.junit.Ignore;
1:c3e57ec: import org.junit.Test;
1:1045fc0: import org.springframework.context.support.AbstractApplicationContext;
1:c3e57ec: 
1:a8a032a: public class SimpleNetworkTest extends BaseNetworkTest {
1:c3e57ec: 
1:1045fc0:     protected static final int MESSAGE_COUNT = 10;
1:c3e57ec: 
1:1045fc0:     protected AbstractApplicationContext context;
1:9c42236:     protected ActiveMQTopic included;
1:9c42236:     protected ActiveMQTopic excluded;
1:230a86c:     protected String consumerName = "durableSubs";
1:a307c57: 
1:a8a032a:     @Override
1:a8a032a:     protected void doSetUp(boolean deleteAllMessages) throws Exception {
1:a8a032a:         super.doSetUp(deleteAllMessages);
1:a8a032a: 
1:a8a032a:         included = new ActiveMQTopic("include.test.bar");
1:a8a032a:         excluded = new ActiveMQTopic("exclude.test.bar");
1:a8a032a:     }
1:a8a032a: 
1:8012f28:     // works b/c of non marshaling vm transport, the connection
1:8012f28:     // ref from the client is used during the forward
1:a46db89:     @Test(timeout = 60 * 1000)
1:a307c57:     public void testMessageCompression() throws Exception {
1:10c998b: 
1:a307c57:         ActiveMQConnection localAmqConnection = (ActiveMQConnection) localConnection;
1:a307c57:         localAmqConnection.setUseCompression(true);
1:a307c57: 
1:a307c57:         MessageConsumer consumer1 = remoteSession.createConsumer(included);
1:a307c57:         MessageProducer producer = localSession.createProducer(included);
1:a307c57:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:a307c57: 
1:a307c57:         waitForConsumerRegistration(localBroker, 1, included);
1:a307c57: 
1:a307c57:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:a307c57:             Message test = localSession.createTextMessage("test-" + i);
1:a307c57:             producer.send(test);
1:9e03278:             Message msg = consumer1.receive(3000);
1:fe9d99e:             assertNotNull("not null? message: " + i, msg);
1:a307c57:             ActiveMQMessage amqMessage = (ActiveMQMessage) msg;
1:a307c57:             assertTrue(amqMessage.isCompressed());
1:a307c57:         }
1:a307c57:         // ensure no more messages received
1:a307c57:         assertNull(consumer1.receive(1000));
1:10c998b: 
1:10c998b:         assertNetworkBridgeStatistics(MESSAGE_COUNT, 0);
1:a307c57:     }
1:10c998b: 
1:a46db89:     @Test(timeout = 60 * 1000)
1:230a86c:     public void testRequestReply() throws Exception {
1:230a86c:         final MessageProducer remoteProducer = remoteSession.createProducer(null);
1:230a86c:         MessageConsumer remoteConsumer = remoteSession.createConsumer(included);
1:230a86c:         remoteConsumer.setMessageListener(new MessageListener() {
1:c7d559f:             @Override
1:230a86c:             public void onMessage(Message msg) {
1:230a86c:                 try {
1:230a86c:                     TextMessage textMsg = (TextMessage)msg;
1:230a86c:                     String payload = "REPLY: " + textMsg.getText();
1:a9c49a7:                     Destination replyTo;
1:230a86c:                     replyTo = msg.getJMSReplyTo();
1:a9c49a7:                     textMsg.clearBody();
1:a9c49a7:                     textMsg.setText(payload);
1:230a86c:                     remoteProducer.send(replyTo, textMsg);
1:230a86c:                 } catch (JMSException e) {
1:a9c49a7:                     e.printStackTrace();
1:d36c0d4:                 }
1:d36c0d4:             }
1:a9c49a7:         });
1:a307c57: 
1:230a86c:         TopicRequestor requestor = new TopicRequestor((TopicSession)localSession, included);
1:a9119ec:         // allow for consumer infos to perculate arround
1:e80bf00:         Thread.sleep(5000);
1:230a86c:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:230a86c:             TextMessage msg = localSession.createTextMessage("test msg: " + i);
1:230a86c:             TextMessage result = (TextMessage)requestor.request(msg);
1:a9c49a7:             assertNotNull(result);
1:fc00993:             LOG.info(result.getText());
1:d36c0d4:         }
1:10c998b: 
1:10c998b:         assertNetworkBridgeStatistics(MESSAGE_COUNT, MESSAGE_COUNT);
1:a9c49a7:     }
1:ecb10e9: 
1:a46db89:     @Test(timeout = 60 * 1000)
1:a9119ec:     public void testFiltering() throws Exception {
1:1045fc0:         MessageConsumer includedConsumer = remoteSession.createConsumer(included);
1:1045fc0:         MessageConsumer excludedConsumer = remoteSession.createConsumer(excluded);
1:1045fc0:         MessageProducer includedProducer = localSession.createProducer(included);
1:1045fc0:         MessageProducer excludedProducer = localSession.createProducer(excluded);
1:10c998b:         // allow for consumer infos to perculate around
1:e80bf00:         Thread.sleep(2000);
1:1045fc0:         Message test = localSession.createTextMessage("test");
1:9c42236:         includedProducer.send(test);
1:9c42236:         excludedProducer.send(test);
1:a9119ec:         assertNull(excludedConsumer.receive(1000));
1:a9119ec:         assertNotNull(includedConsumer.receive(1000));
1:10c998b: 
1:10c998b:         assertNetworkBridgeStatistics(1, 0);
1:a9c49a7:     }
1:d36c0d4: 
1:a46db89:     @Test(timeout = 60 * 1000)
1:543bc84:     public void testConduitBridge() throws Exception {
1:1045fc0:         MessageConsumer consumer1 = remoteSession.createConsumer(included);
1:1045fc0:         MessageConsumer consumer2 = remoteSession.createConsumer(included);
1:1045fc0:         MessageProducer producer = localSession.createProducer(included);
1:9c42236:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:8d0cf31: 
1:ecb10e9:         waitForConsumerRegistration(localBroker, 2, included);
1:8d0cf31: 
1:230a86c:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:230a86c:             Message test = localSession.createTextMessage("test-" + i);
1:1045fc0:             producer.send(test);
1:e80bf00:             assertNotNull(consumer1.receive(1000));
1:e80bf00:             assertNotNull(consumer2.receive(1000));
1:a9c49a7:         }
1:9c42236:         // ensure no more messages received
1:e80bf00:         assertNull(consumer1.receive(1000));
1:e80bf00:         assertNull(consumer2.receive(1000));
1:bab0887: 
1:10c998b:         assertNetworkBridgeStatistics(MESSAGE_COUNT, 0);
1:d36c0d4: 
1:bab0887:         assertNotNull(localBroker.getManagementContext().getObjectInstance(
1:bab0887:                 localBroker.createNetworkConnectorObjectName(localBroker.getNetworkConnectors().get(0))));
1:a9c49a7:     }
1:d36c0d4: 
1:ecb10e9:     private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {
1:8d0cf31:         assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {
1:8d0cf31:             @Override
1:8d0cf31:             public boolean isSatisified() throws Exception {
1:8d0cf31:                 Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();
1:8d0cf31:                 if (bridges.length > 0) {
1:ecb10e9:                     LOG.info(brokerService + " bridges "  + Arrays.toString(bridges));
1:8d0cf31:                     DemandForwardingBridgeSupport demandForwardingBridgeSupport = (DemandForwardingBridgeSupport) bridges[0];
1:9ef4259:                     ConcurrentMap<ConsumerId, DemandSubscription> forwardingBridges = demandForwardingBridgeSupport.getLocalSubscriptionMap();
1:8d0cf31:                     LOG.info(brokerService + " bridge "  + demandForwardingBridgeSupport + ", localSubs: " + forwardingBridges);
1:8d0cf31:                     if (!forwardingBridges.isEmpty()) {
1:ecb10e9:                         for (DemandSubscription demandSubscription : forwardingBridges.values()) {
1:ecb10e9:                             if (demandSubscription.getLocalInfo().getDestination().equals(destination)) {
1:8d0cf31:                                 LOG.info(brokerService + " DemandSubscription "  + demandSubscription + ", size: " + demandSubscription.size());
1:8d0cf31:                                 return demandSubscription.size() >= min;
1:8d0cf31:                             }
1:8d0cf31:                         }
1:ecb10e9:                     }
1:ecb10e9:                 }
1:8d0cf31:                 return false;
1:8d0cf31:             }
1:8d0cf31:         }));
1:406a342:     }
1:406a342: 
1:406a342:     //Added for AMQ-6465 to make sure memory usage decreased back to 0 after messages are forwarded
1:406a342:     //to the other broker
1:406a342:     @Test(timeout = 60 * 1000)
1:406a342:     public void testDurableTopicSubForwardMemoryUsage() throws Exception {
1:406a342:         // create a remote durable consumer to create demand
1:406a342:         MessageConsumer remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
1:406a342:         Thread.sleep(1000);
1:406a342: 
1:406a342:         MessageProducer producer = localSession.createProducer(included);
1:406a342:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:406a342:             Message test = localSession.createTextMessage("test-" + i);
1:406a342:             producer.send(test);
1:406a342:         }
1:406a342:         Thread.sleep(1000);
1:406a342: 
1:406a342:         //Make sure stats are set
1:406a342:         assertEquals(MESSAGE_COUNT,
1:406a342:                 localBroker.getDestination(included).getDestinationStatistics().getForwards().getCount());
1:406a342: 
1:406a342:         assertTrue(Wait.waitFor(new Condition() {
1:406a342: 
1:406a342:             @Override
1:406a342:             public boolean isSatisified() throws Exception {
1:406a342:                 return localBroker.getSystemUsage().getMemoryUsage().getUsage() == 0;
1:406a342:             }
1:406a342:         }, 10000, 500));
1:406a342:         remoteConsumer.close();
1:406a342:     }
1:c4a1346: 
1:406a342:     //Added for AMQ-6465 to make sure memory usage decreased back to 0 after messages are forwarded
1:406a342:     //to the other broker
1:406a342:     @Test(timeout = 60 * 1000)
1:406a342:     public void testTopicSubForwardMemoryUsage() throws Exception {
1:406a342:         // create a remote durable consumer to create demand
1:406a342:         MessageConsumer remoteConsumer = remoteSession.createConsumer(included);
1:406a342:         Thread.sleep(1000);
1:c4a1346: 
1:406a342:         MessageProducer producer = localSession.createProducer(included);
1:c4a1346:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:406a342:             Message test = localSession.createTextMessage("test-" + i);
1:406a342:             producer.send(test);
1:406a342:         }
1:406a342:         Thread.sleep(1000);
1:406a342: 
1:406a342:         //Make sure stats are set
1:406a342:         assertEquals(MESSAGE_COUNT,
1:406a342:                 localBroker.getDestination(included).getDestinationStatistics().getForwards().getCount());
1:406a342: 
1:406a342:         assertTrue(Wait.waitFor(new Condition() {
1:406a342: 
1:406a342:             @Override
1:406a342:             public boolean isSatisified() throws Exception {
1:406a342:                 return localBroker.getSystemUsage().getMemoryUsage().getUsage() == 0;
1:406a342:             }
1:406a342:         }, 10000, 500));
1:406a342: 
1:c4a1346:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:c4a1346:             assertNotNull("message count: " + i, remoteConsumer.receive(2500));
1:c4a1346:         }
1:406a342:         remoteConsumer.close();
1:c4a1346:     }
1:406a342: 
1:406a342:     //Added for AMQ-6465 to make sure memory usage decreased back to 0 after messages are forwarded
1:406a342:     //to the other broker
1:406a342:     @Test(timeout = 60 * 1000)
1:406a342:     public void testQueueSubForwardMemoryUsage() throws Exception {
1:406a342:         ActiveMQQueue queue = new ActiveMQQueue("include.test.foo");
1:406a342:         MessageConsumer remoteConsumer = remoteSession.createConsumer(queue);
1:406a342:         Thread.sleep(1000);
1:406a342: 
1:406a342:         MessageProducer producer = localSession.createProducer(queue);
1:406a342:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:406a342:             Message test = localSession.createTextMessage("test-" + i);
1:406a342:             producer.send(test);
1:406a342:         }
1:406a342:         Thread.sleep(1000);
1:406a342: 
1:406a342:         //Make sure stats are set
1:406a342:         assertEquals(MESSAGE_COUNT,
1:406a342:                 localBroker.getDestination(queue).getDestinationStatistics().getForwards().getCount());
1:406a342: 
1:406a342:         assertTrue(Wait.waitFor(new Condition() {
1:406a342: 
1:406a342:             @Override
1:406a342:             public boolean isSatisified() throws Exception {
1:406a342:                 return localBroker.getSystemUsage().getMemoryUsage().getUsage() == 0;
1:406a342:             }
1:406a342:         }, 10000, 500));
1:406a342: 
1:406a342:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:c4a1346:             assertNotNull("message count: " + i, remoteConsumer.receive(2500));
1:406a342:         }
1:406a342:         remoteConsumer.close();
1:8d0cf31:     }
1:82295fd: 
1:a46db89:     @Test(timeout = 60 * 1000)
1:543bc84:     public void testDurableStoreAndForward() throws Exception {
1:9c42236:         // create a remote durable consumer
1:230a86c:         MessageConsumer remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
2:8cf566b:         Thread.sleep(1000);
1:8cf566b:         // now close everything down and restart
1:8cf566b:         doTearDown();
1:c3e57ec:         doSetUp(false);
1:230a86c:         MessageProducer producer = localSession.createProducer(included);
1:230a86c:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:1045fc0:             Message test = localSession.createTextMessage("test-" + i);
1:9c42236:             producer.send(test);
7:9c42236:         }
1:8cf566b:         Thread.sleep(1000);
1:82295fd: 
1:82295fd:         //Make sure stats are set
1:82295fd:         assertEquals(MESSAGE_COUNT,
1:82295fd:                 localBroker.getDestination(included).getDestinationStatistics().getForwards().getCount());
1:8d0cf31: 
1:9c42236:         // close everything down and restart
2:9c42236:         doTearDown();
1:c3e57ec:         doSetUp(false);
1:230a86c:         remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
1:230a86c:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:8cf566b:             assertNotNull("message count: " + i, remoteConsumer.receive(2500));
1:9c42236:         }
1:9c42236:     }
1:8cf566b: 
1:c3e57ec:     @Ignore("This seems like a simple use case, but it is problematic to consume an existing topic store, " +
1:c3e57ec:             "it requires a connection per durable to match that connectionId")
1:8cf566b:     public void testDurableStoreAndForwardReconnect() throws Exception {
1:8cf566b:         // create a local durable consumer
1:8cf566b:         MessageConsumer localConsumer = localSession.createDurableSubscriber(included, consumerName);
1:c3e57ec:         Thread.sleep(5000);
1:9c42236:         // now close everything down and restart
1:9c42236:         doTearDown();
1:c3e57ec:         doSetUp(false);
1:8cf566b:         // send messages
1:8cf566b:         MessageProducer producer = localSession.createProducer(included);
1:8cf566b:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:8cf566b:             Message test = localSession.createTextMessage("test-" + i);
1:8cf566b:             producer.send(test);
1:8cf566b:         }
1:c3e57ec:         Thread.sleep(5000);
1:8cf566b:         // consume some messages locally
1:8cf566b:         localConsumer = localSession.createDurableSubscriber(included, consumerName);
1:c3e57ec:         LOG.info("Consume from local consumer: " + localConsumer);
1:8cf566b:         for (int i = 0; i < MESSAGE_COUNT / 2; i++) {
1:8cf566b:             assertNotNull("message count: " + i, localConsumer.receive(2500));
1:9529b24:         }
1:c3e57ec:         Thread.sleep(5000);
1:8cf566b:         // close everything down and restart
1:8cf566b:         doTearDown();
1:c3e57ec:         doSetUp(false);
1:c3e57ec:         Thread.sleep(5000);
1:9529b24: 
1:c3e57ec:         LOG.info("Consume from remote");
1:8cf566b:         // consume the rest remotely
1:8cf566b:         MessageConsumer remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
1:c3e57ec:         LOG.info("Remote consumer: " + remoteConsumer);
1:c3e57ec:         Thread.sleep(5000);
1:8cf566b:         for (int i = 0; i < MESSAGE_COUNT / 2; i++) {
1:c3e57ec:             assertNotNull("message count: " + i, remoteConsumer.receive(10000));
1:8cf566b:         }
1:8cf566b:     }
1:c3e57ec: 
1:10c998b:     protected void assertNetworkBridgeStatistics(final long expectedLocalSent, final long expectedRemoteSent) throws Exception {
1:10c998b: 
1:10c998b:         final NetworkBridge localBridge = localBroker.getNetworkConnectors().get(0).activeBridges().iterator().next();
1:10c998b:         final NetworkBridge remoteBridge = remoteBroker.getNetworkConnectors().get(0).activeBridges().iterator().next();
1:10c998b: 
1:10c998b:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:10c998b:             @Override
1:10c998b:             public boolean isSatisified() throws Exception {
1:10c998b:                 return expectedLocalSent == localBridge.getNetworkBridgeStatistics().getDequeues().getCount() &&
1:10c998b:                        0 == localBridge.getNetworkBridgeStatistics().getReceivedCount().getCount() &&
1:10c998b:                        expectedRemoteSent == remoteBridge.getNetworkBridgeStatistics().getDequeues().getCount() &&
1:10c998b:                        0 == remoteBridge.getNetworkBridgeStatistics().getReceivedCount().getCount();
1:10c998b:             }
1:10c998b:         }));
1:10c998b:     }
1:8cf566b: }
============================================================================
author:?ukasz Dywicki
-------------------------------------------------------------------------------
commit:a8a032a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class SimpleNetworkTest extends BaseNetworkTest {
1:     @Override
1:     protected void doSetUp(boolean deleteAllMessages) throws Exception {
1:         super.doSetUp(deleteAllMessages);
1: 
1:         included = new ActiveMQTopic("include.test.bar");
1:         excluded = new ActiveMQTopic("exclude.test.bar");
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
author:gtully
-------------------------------------------------------------------------------
commit:c4a1346
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             assertNotNull("message count: " + i, remoteConsumer.receive(2500));
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             assertNotNull("message count: " + i, remoteConsumer.receive(2500));
1:         }
commit:fe9d99e
/////////////////////////////////////////////////////////////////////////
1:             assertNotNull("not null? message: " + i, msg);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:bab0887
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertNotNull(localBroker.getManagementContext().getObjectInstance(
1:                 localBroker.createNetworkConnectorObjectName(localBroker.getNetworkConnectors().get(0))));
commit:406a342
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.util.Wait.Condition;
/////////////////////////////////////////////////////////////////////////
1:     //Added for AMQ-6465 to make sure memory usage decreased back to 0 after messages are forwarded
1:     //to the other broker
1:     @Test(timeout = 60 * 1000)
1:     public void testDurableTopicSubForwardMemoryUsage() throws Exception {
1:         // create a remote durable consumer to create demand
1:         MessageConsumer remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
1:         Thread.sleep(1000);
1: 
1:         MessageProducer producer = localSession.createProducer(included);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             Message test = localSession.createTextMessage("test-" + i);
1:             producer.send(test);
1:         }
1:         Thread.sleep(1000);
1: 
1:         //Make sure stats are set
1:         assertEquals(MESSAGE_COUNT,
1:                 localBroker.getDestination(included).getDestinationStatistics().getForwards().getCount());
1: 
1:         assertTrue(Wait.waitFor(new Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return localBroker.getSystemUsage().getMemoryUsage().getUsage() == 0;
1:             }
1:         }, 10000, 500));
1:         remoteConsumer.close();
1:     }
1: 
1:     //Added for AMQ-6465 to make sure memory usage decreased back to 0 after messages are forwarded
1:     //to the other broker
1:     @Test(timeout = 60 * 1000)
1:     public void testTopicSubForwardMemoryUsage() throws Exception {
1:         // create a remote durable consumer to create demand
1:         MessageConsumer remoteConsumer = remoteSession.createConsumer(included);
1:         Thread.sleep(1000);
1: 
1:         MessageProducer producer = localSession.createProducer(included);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             Message test = localSession.createTextMessage("test-" + i);
1:             producer.send(test);
1:         }
1:         Thread.sleep(1000);
1: 
1:         //Make sure stats are set
1:         assertEquals(MESSAGE_COUNT,
1:                 localBroker.getDestination(included).getDestinationStatistics().getForwards().getCount());
1: 
1:         assertTrue(Wait.waitFor(new Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return localBroker.getSystemUsage().getMemoryUsage().getUsage() == 0;
1:             }
1:         }, 10000, 500));
1:         remoteConsumer.close();
1:     }
1: 
1:     //Added for AMQ-6465 to make sure memory usage decreased back to 0 after messages are forwarded
1:     //to the other broker
1:     @Test(timeout = 60 * 1000)
1:     public void testQueueSubForwardMemoryUsage() throws Exception {
1:         ActiveMQQueue queue = new ActiveMQQueue("include.test.foo");
1:         MessageConsumer remoteConsumer = remoteSession.createConsumer(queue);
1:         Thread.sleep(1000);
1: 
1:         MessageProducer producer = localSession.createProducer(queue);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             Message test = localSession.createTextMessage("test-" + i);
1:             producer.send(test);
1:         }
1:         Thread.sleep(1000);
1: 
1:         //Make sure stats are set
1:         assertEquals(MESSAGE_COUNT,
1:                 localBroker.getDestination(queue).getDestinationStatistics().getForwards().getCount());
1: 
1:         assertTrue(Wait.waitFor(new Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return localBroker.getSystemUsage().getMemoryUsage().getUsage() == 0;
1:             }
1:         }, 10000, 500));
1:         remoteConsumer.close();
1:     }
1: 
commit:82295fd
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
/////////////////////////////////////////////////////////////////////////
1: 
1:         //Make sure stats are set
1:         assertEquals(MESSAGE_COUNT,
1:                 localBroker.getDestination(included).getDestinationStatistics().getForwards().getCount());
1: 
commit:10c998b
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertNetworkBridgeStatistics(MESSAGE_COUNT, 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertNetworkBridgeStatistics(MESSAGE_COUNT, MESSAGE_COUNT);
/////////////////////////////////////////////////////////////////////////
1:         // allow for consumer infos to perculate around
1: 
1:         assertNetworkBridgeStatistics(1, 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertNetworkBridgeStatistics(MESSAGE_COUNT, 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void assertNetworkBridgeStatistics(final long expectedLocalSent, final long expectedRemoteSent) throws Exception {
1: 
1:         final NetworkBridge localBridge = localBroker.getNetworkConnectors().get(0).activeBridges().iterator().next();
1:         final NetworkBridge remoteBridge = remoteBroker.getNetworkConnectors().get(0).activeBridges().iterator().next();
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return expectedLocalSent == localBridge.getNetworkBridgeStatistics().getDequeues().getCount() &&
1:                        0 == localBridge.getNetworkBridgeStatistics().getReceivedCount().getCount() &&
1:                        expectedRemoteSent == remoteBridge.getNetworkBridgeStatistics().getDequeues().getCount() &&
1:                        0 == remoteBridge.getNetworkBridgeStatistics().getReceivedCount().getCount();
1:             }
1:         }));
1:     }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:                     ConcurrentMap<ConsumerId, DemandSubscription> forwardingBridges = demandForwardingBridgeSupport.getLocalSubscriptionMap();
author:Kevin Earls
-------------------------------------------------------------------------------
commit:a46db89
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c7d559f
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
1:             @Override
commit:ef24cc9
commit:9e03278
/////////////////////////////////////////////////////////////////////////
1:             Message msg = consumer1.receive(3000);
commit:a307c57
/////////////////////////////////////////////////////////////////////////
0: import static junit.framework.Assert.assertNotNull;
0: import static junit.framework.Assert.assertNull;
0: import static junit.framework.Assert.assertTrue;
1: 
0: import java.net.URI;
1: import java.util.Arrays;
0: import java.util.concurrent.ConcurrentHashMap;
1: 
0: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
0: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.TopicRequestor;
1: import javax.jms.TopicSession;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testMessageCompression() throws Exception {
1: 
1:         ActiveMQConnection localAmqConnection = (ActiveMQConnection) localConnection;
1:         localAmqConnection.setUseCompression(true);
1: 
1:         MessageConsumer consumer1 = remoteSession.createConsumer(included);
1:         MessageProducer producer = localSession.createProducer(included);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1: 
1:         waitForConsumerRegistration(localBroker, 1, included);
1: 
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             Message test = localSession.createTextMessage("test-" + i);
1:             producer.send(test);
0:             Message msg = consumer1.receive(1000);
0:             assertNotNull(msg);
1:             ActiveMQMessage amqMessage = (ActiveMQMessage) msg;
1:             assertTrue(amqMessage.isCompressed());
1:         }
1:         // ensure no more messages received
1:         assertNull(consumer1.receive(1000));
1:     }
1: 
0:     @Test
commit:9529b24
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:8012f28
/////////////////////////////////////////////////////////////////////////
1:     // works b/c of non marshaling vm transport, the connection
1:     // ref from the client is used during the forward
commit:c3e57ec
/////////////////////////////////////////////////////////////////////////
0: import org.junit.After;
0: import org.junit.Before;
1: import org.junit.Ignore;
1: import org.junit.Test;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0: import static junit.framework.Assert.assertNotNull;
0: import static junit.framework.Assert.assertNull;
0: import static junit.framework.Assert.assertTrue;
1: 
0: public class SimpleNetworkTest {
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:     @Test
1:         doSetUp(false);
/////////////////////////////////////////////////////////////////////////
1:         doSetUp(false);
1:     @Ignore("This seems like a simple use case, but it is problematic to consume an existing topic store, " +
1:             "it requires a connection per durable to match that connectionId")
1:         Thread.sleep(5000);
1:         doSetUp(false);
1:         Thread.sleep(5000);
1:         LOG.info("Consume from local consumer: " + localConsumer);
1:         Thread.sleep(5000);
1:         doSetUp(false);
1:         Thread.sleep(5000);
1: 
1:         LOG.info("Consume from remote");
1:         LOG.info("Remote consumer: " + remoteConsumer);
1:         Thread.sleep(5000);
1:             assertNotNull("message count: " + i, remoteConsumer.receive(10000));
0:     @Before
0:     public void setUp() throws Exception {
0:         doSetUp(true);
0:     @After
0:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     protected void doSetUp(boolean deleteAllMessages) throws Exception {
0:         remoteBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
0:         localBroker.setDeleteAllMessagesOnStartup(deleteAllMessages);
/////////////////////////////////////////////////////////////////////////
0:         localConnection.setClientID("clientId");
0:         remoteConnection.setClientID("clientId");
commit:8d0cf31
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1: 
0:         waitForConsumerRegistration(localBroker, 2);
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void waitForConsumerRegistration(final BrokerService brokerService, final int min) throws Exception {
1:         assertTrue("Internal bridge consumers registered in time", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 Object[] bridges = brokerService.getNetworkConnectors().get(0).bridges.values().toArray();
1:                 if (bridges.length > 0) {
0:                     LOG.info(brokerService + " bridges "  + bridges);
1:                     DemandForwardingBridgeSupport demandForwardingBridgeSupport = (DemandForwardingBridgeSupport) bridges[0];
0:                     ConcurrentHashMap<ConsumerId, DemandSubscription> forwardingBridges = demandForwardingBridgeSupport.getLocalSubscriptionMap();
1:                     LOG.info(brokerService + " bridge "  + demandForwardingBridgeSupport + ", localSubs: " + forwardingBridges);
1:                     if (!forwardingBridges.isEmpty()) {
0:                         DemandSubscription demandSubscription = (DemandSubscription) forwardingBridges.values().toArray()[0];
1:                         LOG.info(brokerService + " DemandSubscription "  + demandSubscription + ", size: " + demandSubscription.size());
1:                         return demandSubscription.size() >= min;
1:                     }
1:                 }
1:                 return false;
1:             }
1:         }));
1:     }
1: 
commit:12aeb27
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class SimpleNetworkTest extends org.apache.activemq.TestSupport {
/////////////////////////////////////////////////////////////////////////
0:         setAutoFail(true);
commit:e80bf00
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(5000);
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(2000);
1:             assertNotNull(consumer1.receive(1000));
1:             assertNotNull(consumer2.receive(1000));
1:         assertNull(consumer1.receive(1000));
1:         assertNull(consumer2.receive(1000));
commit:dbefbec
/////////////////////////////////////////////////////////////////////////
0:         fac.setAlwaysSyncSend(true);
0:         fac.setDispatchAsync(false);
commit:564a9c2
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull("message count: " + i, remoteConsumer.receive(1000));
commit:543bc84
/////////////////////////////////////////////////////////////////////////
1:     public void testConduitBridge() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testDurableStoreAndForward() throws Exception {
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:ecb10e9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.*;
0: import java.net.URI;
0: import java.util.Arrays;
0: import java.util.concurrent.ConcurrentHashMap;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         waitForConsumerRegistration(localBroker, 2, included);
/////////////////////////////////////////////////////////////////////////
1:     private void waitForConsumerRegistration(final BrokerService brokerService, final int min, final ActiveMQDestination destination) throws Exception {
1:                     LOG.info(brokerService + " bridges "  + Arrays.toString(bridges));
1:                         for (DemandSubscription demandSubscription : forwardingBridges.values()) {
1:                             if (demandSubscription.getLocalInfo().getDestination().equals(destination)) {
0:                                 LOG.info(brokerService + " DemandSubscription "  + demandSubscription + ", size: " + demandSubscription.size());
0:                                 return demandSubscription.size() >= min;
1:                             }
1:                         }
/////////////////////////////////////////////////////////////////////////
0:         remoteBroker.waitUntilStarted();
0:         localBroker.waitUntilStarted();
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOG = LoggerFactory.getLogger(SimpleNetworkTest.class);
commit:8cf566b
/////////////////////////////////////////////////////////////////////////
1:     public void testDurableStoreAndForwardReconnect() throws Exception {
1:         // create a local durable consumer
1:         MessageConsumer localConsumer = localSession.createDurableSubscriber(included, consumerName);
1:         Thread.sleep(1000);
1:         // now close everything down and restart
1:         doTearDown();
0:         doSetUp();
1:         // send messages
1:         MessageProducer producer = localSession.createProducer(included);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             Message test = localSession.createTextMessage("test-" + i);
1:             producer.send(test);
1:         }
1:         Thread.sleep(1000);
1:         // consume some messages locally
1:         localConsumer = localSession.createDurableSubscriber(included, consumerName);
1:         for (int i = 0; i < MESSAGE_COUNT / 2; i++) {
1:             assertNotNull("message count: " + i, localConsumer.receive(2500));
1:         }
1:         Thread.sleep(1000);
1:         // close everything down and restart
1:         doTearDown();
0:         doSetUp();
1:         // consume the rest remotely
1:         MessageConsumer remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
1:         for (int i = 0; i < MESSAGE_COUNT / 2; i++) {
1:             assertNotNull("message count: " + i, remoteConsumer.receive(2500));
1:         }
1:     }    
1:     
commit:fee7f6a
/////////////////////////////////////////////////////////////////////////
0:             assertNotNull("message count: " + i, remoteConsumer.receive(2500));
author:Robert Davies
-------------------------------------------------------------------------------
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
commit:a9119ec
/////////////////////////////////////////////////////////////////////////
1:     public void testFiltering() throws Exception {
1:         // allow for consumer infos to perculate arround
0:         Thread.sleep(2000);
1:         assertNull(excludedConsumer.receive(1000));
1:         assertNotNull(includedConsumer.receive(1000));
commit:eeb8d5b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(2000);//allow for consumer infos to perculate arround
/////////////////////////////////////////////////////////////////////////
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:         System.err.println("START TEST!");
/////////////////////////////////////////////////////////////////////////
0:         System.err.println("FIN TEST!");
0:     public void XtestFiltering() throws Exception{
1:       
/////////////////////////////////////////////////////////////////////////
0:         System.err.println("FIN TEST!");
0:     public void XtestConduitBridge() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     public void XtestDurableStoreAndForward() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:         remoteBroker=createRemoteBroker();
0:         localBroker=createLocalBroker();
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected BrokerService createBroker(String URI) throws Exception {
0:         Resource resource=new ClassPathResource(URI);
0:         BrokerFactoryBean factory=new BrokerFactoryBean(resource);
0:         resource=new ClassPathResource(URI);
0:         factory=new BrokerFactoryBean(resource);
0:         factory.afterPropertiesSet();
0:         BrokerService result=factory.getBroker();
0:         return result;
1:     }
1:     
0:     protected BrokerService createLocalBroker() throws Exception {
0:         return createBroker(getLocalBrokerURI());
1:     }
1:     
0:     protected BrokerService createRemoteBroker() throws Exception {
0:         return createBroker(getRemoteBrokerURI());
1:     }
commit:a9c49a7
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
0: import javax.jms.MessageListener;
0: import javax.jms.TextMessage;
0: import javax.jms.TopicRequestor;
0: import javax.jms.TopicSession;
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0:     public void testRequestReply() throws Exception{
0:         final MessageProducer remoteProducer=remoteSession.createProducer(null);
0:         MessageConsumer remoteConsumer=remoteSession.createConsumer(included);
0:         remoteConsumer.setMessageListener(new MessageListener(){
0:             public void onMessage(Message msg){
0:                 try{
0:                     TextMessage textMsg=(TextMessage) msg;
0:                     String payload="REPLY: "+textMsg.getText();
1:                     Destination replyTo;
0:                     replyTo=msg.getJMSReplyTo();
1:                     textMsg.clearBody();
1:                     textMsg.setText(payload);
0:                     remoteProducer.send(replyTo,textMsg);
0:                 }catch(JMSException e){
0:                     // TODO Auto-generated catch block
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
0:         
0:         TopicRequestor requestor=new TopicRequestor((TopicSession) localSession,included);
0:         Thread.sleep(2000);//alow for consumer infos to perculate arround
0:         for (int i =0;i < MESSAGE_COUNT; i++){
0:             TextMessage msg = localSession.createTextMessage("test msg: " +i);
0:             TextMessage result = (TextMessage) requestor.request(msg);
1:             assertNotNull(result);
0:             System.out.println(result.getText());
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:         Resource resource=new ClassPathResource(getRemoteBrokerURI());
0:         remoteBroker=factory.getBroker();
0:         remoteBroker.start();
0:         
0:         resource=new ClassPathResource(getLocalBrokerURI());
0:         localBroker=factory.getBroker();
0:         
0:         
commit:9c42236
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
0:  * the License. You may obtain a copy of the License at
1:  * 
1:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
0: public class SimpleNetworkTest extends TestCase{
0:     protected static final int MESSAGE_COUNT=10;
0:     protected Session localSession;
0:     protected Session remoteSession;
1:     protected ActiveMQTopic included;
1:     protected ActiveMQTopic excluded;
0:     protected String consumerName="durableSubs";
0:         MessageConsumer includedConsumer=remoteSession.createConsumer(included);
0:         MessageConsumer excludedConsumer=remoteSession.createConsumer(excluded);
0:         MessageProducer includedProducer=localSession.createProducer(included);
0:         MessageProducer excludedProducer=localSession.createProducer(excluded);
0:         Message test=localSession.createTextMessage("test");
1:         includedProducer.send(test);
1:         excludedProducer.send(test);
0:         assertNull(excludedConsumer.receive(500));
0:         assertNotNull(includedConsumer.receive(500));
1:     }
0: 
0:     public void testConduitBridge() throws Exception{
0:         MessageConsumer consumer1=remoteSession.createConsumer(included);
0:         MessageConsumer consumer2=remoteSession.createConsumer(included);
0:         MessageProducer producer=localSession.createProducer(included);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:         Thread.sleep(1000);
0:         for(int i=0;i<MESSAGE_COUNT;i++){
0:             Message test=localSession.createTextMessage("test-"+i);
1:         // ensure no more messages received
1:     }
0:     public void testDurableStoreAndForward() throws Exception{
1:         // create a remote durable consumer
0:         MessageConsumer remoteConsumer=remoteSession.createDurableSubscriber(included,consumerName);
0:         Thread.sleep(1000);
1:         // now close everything down and restart
1:         doTearDown();
0:         doSetUp();
0:         MessageProducer producer=localSession.createProducer(included);
0:         for(int i=0;i<MESSAGE_COUNT;i++){
0:             Message test=localSession.createTextMessage("test-"+i);
1:             producer.send(test);
1:         }
0:         Thread.sleep(1000);
1:         // close everything down and restart
1:         doTearDown();
0:         doSetUp();
0:         remoteConsumer=remoteSession.createDurableSubscriber(included,consumerName);
0:         for(int i=0;i<MESSAGE_COUNT;i++){
0:             Message test=localSession.createTextMessage("test-"+i);
0:             assertNotNull(remoteConsumer.receive(500));
1:         }
1:     }
0: 
0:     protected void setUp() throws Exception{
0:         super.setUp();
0:         doSetUp();
1:     }
0: 
0:     protected void tearDown() throws Exception{
0:         localBroker.deleteAllMessages();
0:         remoteBroker.deleteAllMessages();
1:         doTearDown();
0:         super.tearDown();
1:     }
0: 
0:     protected void doTearDown() throws Exception{
0:         localConnection.close();
0:         remoteConnection.close();
0:         localBroker.stop();
0:         remoteBroker.stop();
1:     }
0: 
0:     protected void doSetUp() throws Exception{
0:         Resource resource=new ClassPathResource("org/apache/activemq/network/localBroker.xml");
0:         BrokerFactoryBean factory=new BrokerFactoryBean(resource);
0:         factory.afterPropertiesSet();
0:         localBroker=factory.getBroker();
0:         resource=new ClassPathResource("org/apache/activemq/network/remoteBroker.xml");
0:         factory=new BrokerFactoryBean(resource);
0:         factory.afterPropertiesSet();
0:         remoteBroker=factory.getBroker();
0:         localBroker.start();
0:         remoteBroker.start();
0:         URI localURI=localBroker.getVmConnectorURI();
0:         ActiveMQConnectionFactory fac=new ActiveMQConnectionFactory(localURI);
0:         localConnection=fac.createConnection();
0:         localConnection.setClientID("local");
0:         localConnection.start();
0:         URI remoteURI=remoteBroker.getVmConnectorURI();
0:         fac=new ActiveMQConnectionFactory(remoteURI);
0:         remoteConnection=fac.createConnection();
0:         remoteConnection.setClientID("remote");
0:         remoteConnection.start();
0:         included=new ActiveMQTopic("include.test.bar");
0:         excluded=new ActiveMQTopic("exclude.test.bar");
0:         localSession=localConnection.createSession(false,Session.AUTO_ACKNOWLEDGE);
0:         remoteSession=remoteConnection.createSession(false,Session.AUTO_ACKNOWLEDGE);
1:     }
commit:9d8f82b
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Connection;
0: import javax.jms.DeliveryMode;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.Session;
0: import org.apache.activemq.ActiveMQConnectionFactory;
commit:1045fc0
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
0: 
0: import java.net.URI;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import javax.jms.*;
0: import junit.framework.TestCase;
0: 
0: import org.apache.activemq.*;
0: import org.apache.activemq.broker.BrokerRegistry;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.BrokerTestSupport;
0: import org.apache.activemq.broker.StubConnection;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.broker.region.QueueRegion;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.memory.UsageManager;
0: import org.apache.activemq.store.PersistenceAdapter;
0: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
0: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportFactory;
0: import org.apache.activemq.xbean.BrokerFactoryBean;
1: import org.springframework.context.support.AbstractApplicationContext;
0: import org.springframework.context.support.ClassPathXmlApplicationContext;
0: import org.springframework.core.io.ClassPathResource;
0: import org.springframework.core.io.Resource;
0: 
0: public class SimpleNetworkTest extends TestCase  {
0:     
1:     protected static final int MESSAGE_COUNT = 10;
1:     protected AbstractApplicationContext context;
0:     protected Connection localConnection;
0:     protected Connection remoteConnection;
0:     protected BrokerService localBroker;
0:     protected BrokerService remoteBroker;
0:     
0:    
0: 
0:     protected void setUp() throws Exception {
0:         
0:         super.setUp();
0:         Resource resource = new ClassPathResource("org/apache/activemq/network/localBroker.xml");
0:         BrokerFactoryBean factory = new BrokerFactoryBean(resource);
0:         factory.afterPropertiesSet();
0:         localBroker = factory.getBroker();
0:         
0:         resource = new ClassPathResource("org/apache/activemq/network/remoteBroker.xml");
0:         factory = new BrokerFactoryBean(resource);
0:         factory.afterPropertiesSet();
0:         remoteBroker = factory.getBroker();
0:         
0:         localBroker.start();
0:         remoteBroker.start();
0:         
0:         URI localURI = localBroker.getVmConnectorURI();
0:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(localURI);
0:         localConnection = fac.createConnection();
0:         localConnection.start();
0:         
0:         URI remoteURI = remoteBroker.getVmConnectorURI();
0:         fac = new ActiveMQConnectionFactory(remoteURI);
0:         remoteConnection = fac.createConnection();
0:         remoteConnection.start();
0:         
0:     }
0: 
0:     
0:     protected void tearDown() throws Exception {
0:         localConnection.close();
0:         remoteConnection.close();
0:         localBroker.stop();
0:         remoteBroker.stop();
0:         super.tearDown();
0:     }
0:     
0:       
0:     public void testFiltering() throws Exception{
0:        ActiveMQTopic included = new ActiveMQTopic("include.test.bar");
0:        ActiveMQTopic excluded = new ActiveMQTopic("exclude.test.bar");
0:        Session localSession = localConnection.createSession(false,Session.AUTO_ACKNOWLEDGE);
0:        Session remoteSession = remoteConnection.createSession(false,Session.AUTO_ACKNOWLEDGE);
1:        MessageConsumer includedConsumer = remoteSession.createConsumer(included);
1:        MessageConsumer excludedConsumer = remoteSession.createConsumer(excluded);
1:        MessageProducer includedProducer = localSession.createProducer(included);
1:        MessageProducer excludedProducer = localSession.createProducer(excluded);
0:        Thread.sleep(1000);
0:        
1:        Message test = localSession.createTextMessage("test");
0:        includedProducer.send(test);
0:        excludedProducer.send(test);
0:        
0:        assertNull(excludedConsumer.receive(500));
0:        assertNotNull(includedConsumer.receive(500));
0:     }
0:     
0:     public void testConduitBridge() throws Exception{
0:         ActiveMQTopic included = new ActiveMQTopic("include.test.bar");
0:        
0:         Session localSession = localConnection.createSession(false,Session.AUTO_ACKNOWLEDGE);
0:         Session remoteSession = remoteConnection.createSession(false,Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer1 = remoteSession.createConsumer(included);
1:         MessageConsumer consumer2 = remoteSession.createConsumer(included);
1:         MessageProducer producer = localSession.createProducer(included);
0:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:        
0:         Thread.sleep(1000);
0:         
0:         
0:         int count = 10;
0:         for (int i = 0; i < count; i++){
1:             Message test = localSession.createTextMessage("test-" + i);
1:             producer.send(test);
0:             assertNotNull(consumer1.receive(500));
0:             assertNotNull(consumer2.receive(500));
0:         }
0:         
0:         
0:         //ensure no more messages received
0:         assertNull(consumer1.receive(500));
0:         assertNull(consumer2.receive(500));
0:      }
0:     
0:     
0: 
0: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     protected static final int MESSAGE_COUNT = 10;
/////////////////////////////////////////////////////////////////////////
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(SimpleNetworkTest.class);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info(result.getText());
0:     public void xtestFiltering() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void xtestConduitBridge() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void xtestDurableStoreAndForward() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     protected BrokerService createBroker(String uri) throws Exception {
0:         Resource resource = new ClassPathResource(uri);
0:         resource = new ClassPathResource(uri);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0: 
0: public class SimpleNetworkTest extends TestCase {
0: 
0:     protected static final int MESSAGE_COUNT = 10;
/////////////////////////////////////////////////////////////////////////
1:     protected String consumerName = "durableSubs";
0: 
1:     public void testRequestReply() throws Exception {
1:         final MessageProducer remoteProducer = remoteSession.createProducer(null);
1:         MessageConsumer remoteConsumer = remoteSession.createConsumer(included);
1:         remoteConsumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message msg) {
1:                 try {
1:                     TextMessage textMsg = (TextMessage)msg;
1:                     String payload = "REPLY: " + textMsg.getText();
1:                     replyTo = msg.getJMSReplyTo();
1:                     remoteProducer.send(replyTo, textMsg);
1:                 } catch (JMSException e) {
0: 
1:         TopicRequestor requestor = new TopicRequestor((TopicSession)localSession, included);
0:         // allow for consumer infos to perculate arround
0:         Thread.sleep(2000);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             TextMessage msg = localSession.createTextMessage("test msg: " + i);
1:             TextMessage result = (TextMessage)requestor.request(msg);
0:     public void XtestFiltering() throws Exception {
0: 
0:         MessageConsumer includedConsumer = remoteSession.createConsumer(included);
0:         MessageConsumer excludedConsumer = remoteSession.createConsumer(excluded);
0:         MessageProducer includedProducer = localSession.createProducer(included);
0:         MessageProducer excludedProducer = localSession.createProducer(excluded);
0:         Message test = localSession.createTextMessage("test");
0:     public void XtestConduitBridge() throws Exception {
0:         MessageConsumer consumer1 = remoteSession.createConsumer(included);
0:         MessageConsumer consumer2 = remoteSession.createConsumer(included);
1:         MessageProducer producer = localSession.createProducer(included);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             Message test = localSession.createTextMessage("test-" + i);
/////////////////////////////////////////////////////////////////////////
0:     public void XtestDurableStoreAndForward() throws Exception {
1:         MessageConsumer remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
0:         MessageProducer producer = localSession.createProducer(included);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
0:             Message test = localSession.createTextMessage("test-" + i);
1:         remoteConsumer = remoteSession.createDurableSubscriber(included, consumerName);
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
0:             Message test = localSession.createTextMessage("test-" + i);
0:     protected void setUp() throws Exception {
0:     protected void tearDown() throws Exception {
0:     protected void doTearDown() throws Exception {
0:     protected void doSetUp() throws Exception {
0:         remoteBroker = createRemoteBroker();
0:         localBroker = createLocalBroker();
0:         URI localURI = localBroker.getVmConnectorURI();
0:         ActiveMQConnectionFactory fac = new ActiveMQConnectionFactory(localURI);
0:         localConnection = fac.createConnection();
0:         URI remoteURI = remoteBroker.getVmConnectorURI();
0:         fac = new ActiveMQConnectionFactory(remoteURI);
0:         remoteConnection = fac.createConnection();
0:         included = new ActiveMQTopic("include.test.bar");
0:         excluded = new ActiveMQTopic("exclude.test.bar");
0:         localSession = localConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         remoteSession = remoteConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
/////////////////////////////////////////////////////////////////////////
0: 
0:         Resource resource = new ClassPathResource(URI);
0:         BrokerFactoryBean factory = new BrokerFactoryBean(resource);
0:         resource = new ClassPathResource(URI);
0:         factory = new BrokerFactoryBean(resource);
0:         BrokerService result = factory.getBroker();
0: 
0: 
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
0:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
commit:93dc39b
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     
0:     protected static final Log log = LogFactory.getLog(SimpleNetworkTest.class);
0: 
/////////////////////////////////////////////////////////////////////////
0:             log.info(result.getText());
author:James Strachan
-------------------------------------------------------------------------------
commit:400b1fc
/////////////////////////////////////////////////////////////////////////
0:         Resource resource=new ClassPathResource(getLocalBrokerURI());
0:         resource=new ClassPathResource(getRemoteBrokerURI());
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected String getRemoteBrokerURI() {
0:         return "org/apache/activemq/network/remoteBroker.xml";
0:     }
0: 
0:     protected String getLocalBrokerURI() {
0:         return "org/apache/activemq/network/localBroker.xml";
0:     }
============================================================================