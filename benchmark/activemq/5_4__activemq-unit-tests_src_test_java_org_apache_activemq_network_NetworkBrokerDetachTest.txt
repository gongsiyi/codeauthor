1:9d9d4cd: /**
1:9d9d4cd:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9d9d4cd:  * contributor license agreements.  See the NOTICE file distributed with
1:9d9d4cd:  * this work for additional information regarding copyright ownership.
1:9d9d4cd:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9d9d4cd:  * (the "License"); you may not use this file except in compliance with
1:9d9d4cd:  * the License.  You may obtain a copy of the License at
1:9d9d4cd:  *
1:9d9d4cd:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9d9d4cd:  *
1:9d9d4cd:  * Unless required by applicable law or agreed to in writing, software
1:9d9d4cd:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9d9d4cd:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9d9d4cd:  * See the License for the specific language governing permissions and
1:9d9d4cd:  * limitations under the License.
1:9d9d4cd:  */
1:9d9d4cd: package org.apache.activemq.network;
18:05f82a9: 
1:e80bf00: import static org.junit.Assert.assertTrue;
1:db9533b: 
1:05f82a9: import java.io.File;
1:383c27e: import java.util.Arrays;
1:05f82a9: import java.util.concurrent.TimeUnit;
1:05f82a9: import java.util.concurrent.atomic.AtomicInteger;
1:05f82a9: 
1:9d9d4cd: import javax.jms.Connection;
1:9d9d4cd: import javax.jms.ConnectionFactory;
1:05f82a9: import javax.jms.Message;
1:05f82a9: import javax.jms.MessageListener;
1:9d9d4cd: import javax.jms.Session;
1:05f82a9: import javax.jms.TopicSubscriber;
1:9d9d4cd: import javax.management.ObjectName;
1:05f82a9: 
1:9d9d4cd: import org.apache.activemq.ActiveMQConnectionFactory;
1:9d9d4cd: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:9d9d4cd: import org.apache.activemq.broker.BrokerService;
1:7a95e18: import org.apache.activemq.broker.jmx.BrokerView;
1:7a95e18: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1:05f82a9: import org.apache.activemq.command.ActiveMQDestination;
1:05f82a9: import org.apache.activemq.command.ActiveMQTopic;
1:05f82a9: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:9086693: import org.apache.activemq.util.Wait;
1:db9533b: import org.junit.After;
1:db9533b: import org.junit.Before;
1:e80bf00: import org.junit.Test;
1:7a95e18: import org.slf4j.Logger;
1:7a95e18: import org.slf4j.LoggerFactory;
1:05f82a9: 
1:e80bf00: public class NetworkBrokerDetachTest {
1:05f82a9: 
1:7a95e18:     private final static String BROKER_NAME = "broker";
1:7a95e18:     private final static String REM_BROKER_NAME = "networkedBroker";
1:7a95e18:     private final static String DESTINATION_NAME = "testQ";
1:7a95e18:     private final static int NUM_CONSUMERS = 1;
1:7a95e18: 
1:8bf987b:     protected static final Logger LOG = LoggerFactory.getLogger(NetworkBrokerDetachTest.class);
1:9d9d4cd:     protected final int numRestarts = 3;
1:05f82a9:     protected final int networkTTL = 2;
1:05f82a9:     protected final boolean dynamicOnly = false;
1:7a95e18: 
1:db9533b:     protected BrokerService broker;
1:db9533b:     protected BrokerService networkedBroker;
1:db9533b: 
1:9d9d4cd:     protected BrokerService createBroker() throws Exception {
1:9d9d4cd:         BrokerService broker = new BrokerService();
1:9d9d4cd:         broker.setBrokerName(BROKER_NAME);
1:05f82a9:         configureBroker(broker);
1:9d9d4cd:         broker.addConnector("tcp://localhost:61617");
1:9d9d4cd:         NetworkConnector networkConnector = broker.addNetworkConnector("static:(tcp://localhost:62617?wireFormat.maxInactivityDuration=500)?useExponentialBackOff=false");
1:05f82a9:         configureNetworkConnector(networkConnector);
1:9d9d4cd:         return broker;
1:05f82a9:     }
1:7a95e18: 
1:9d9d4cd:     protected BrokerService createNetworkedBroker() throws Exception {
1:9d9d4cd:         BrokerService broker = new BrokerService();
1:9d9d4cd:         broker.setBrokerName(REM_BROKER_NAME);
1:05f82a9:         configureBroker(broker);
1:05f82a9:         broker.getManagementContext().setCreateConnector(false);
1:9d9d4cd:         broker.addConnector("tcp://localhost:62617");
1:05f82a9:         NetworkConnector networkConnector = broker.addNetworkConnector("static:(tcp://localhost:61617?wireFormat.maxInactivityDuration=500)?useExponentialBackOff=false");
1:05f82a9:         configureNetworkConnector(networkConnector);
1:9d9d4cd:         return broker;
1:05f82a9:     }
1:db9533b: 
1:05f82a9:     private void configureNetworkConnector(NetworkConnector networkConnector) {
1:05f82a9:         networkConnector.setDuplex(false);
1:05f82a9:         networkConnector.setNetworkTTL(networkTTL);
1:05f82a9:         networkConnector.setDynamicOnly(dynamicOnly);
1:05f82a9:     }
1:7a95e18: 
1:05f82a9:     // variants for each store....
1:952d036:     protected void configureBroker(BrokerService broker) throws Exception {
1:05f82a9:         KahaDBPersistenceAdapter persistenceAdapter = new KahaDBPersistenceAdapter();
1:db9533b:         persistenceAdapter.setDirectory(new File("target/activemq-data/kahadb/" + broker.getBrokerName() + "NetworBrokerDetatchTest"));
1:05f82a9:         broker.setPersistenceAdapter(persistenceAdapter);
1:05f82a9:     }
1:7a95e18: 
1:db9533b:     @Before
1:db9533b:     public void init() throws Exception {
1:db9533b:         broker = createBroker();
1:db9533b:         broker.setDeleteAllMessagesOnStartup(true);
1:db9533b:         broker.start();
1:7a95e18: 
1:db9533b:         networkedBroker = createNetworkedBroker();
1:db9533b:         networkedBroker.setDeleteAllMessagesOnStartup(true);
1:db9533b:         networkedBroker.start();
1:db9533b:     }
1:7a95e18: 
1:db9533b:     @After
1:db9533b:     public void cleanup() throws Exception {
1:38f7857:         if (networkedBroker != null) {
1:38f7857:             networkedBroker.stop();
1:38f7857:             networkedBroker.waitUntilStopped();
1:38f7857:         }
1:7a95e18: 
1:38f7857:         if (broker != null) {
1:38f7857:             broker.stop();
1:38f7857:             broker.waitUntilStopped();
1:38f7857:         }
1:db9533b:     }
1:db9533b: 
1:05f82a9:     @Test
1:9d9d4cd:     public void testNetworkedBrokerDetach() throws Exception {
1:9d9d4cd:         LOG.info("Creating Consumer on the networked broker ...");
1:7a95e18:         // Create a consumer on the networked broker
1:9d9d4cd:         ConnectionFactory consFactory = createConnectionFactory(networkedBroker);
1:9d9d4cd:         Connection consConn = consFactory.createConnection();
1:9d9d4cd:         Session consSession = consConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:05f82a9:         ActiveMQDestination destination = (ActiveMQDestination) consSession.createQueue(DESTINATION_NAME);
1:9d9d4cd:         for(int i=0; i<NUM_CONSUMERS; i++) {
1:05f82a9:             consSession.createConsumer(destination);
1:05f82a9:         }
1:7a95e18: 
1:7a95e18:         assertTrue("got expected consumer count from mbean within time limit",
1:7a95e18:                    verifyConsumerCount(1, destination, broker));
1:7a95e18: 
1:9d9d4cd:         LOG.info("Stopping Consumer on the networked broker ...");
1:7a95e18:         // Closing the connection will also close the consumer
1:9d9d4cd:         consConn.close();
1:7a95e18: 
1:9d9d4cd:         // We should have 0 consumer for the queue on the local broker
1:7a7b380:         assertTrue("got expected 0 count from mbean within time limit", verifyConsumerCount(0, destination, broker));
1:05f82a9:     }
1:db9533b: 
1:e80bf00:     @Test
1:db9533b:     public void testNetworkedBrokerDurableSubAfterRestart() throws Exception {
1:7a95e18: 
1:05f82a9:         final AtomicInteger count = new AtomicInteger(0);
1:05f82a9:         MessageListener counter = new MessageListener() {
1:7a95e18:             @Override
1:05f82a9:             public void onMessage(Message message) {
1:05f82a9:                 count.incrementAndGet();
1:05f82a9:             }
1:05f82a9:         };
1:7a95e18: 
1:05f82a9:         LOG.info("Creating durable consumer on each broker ...");
1:db9533b:         ActiveMQTopic destination = registerDurableConsumer(networkedBroker, counter);
1:db9533b:         registerDurableConsumer(broker, counter);
1:7a95e18: 
1:05f82a9:         assertTrue("got expected consumer count from local broker mbean within time limit",
1:7a7b380:                 verifyConsumerCount(2, destination, broker));
1:7a95e18: 
1:05f82a9:         assertTrue("got expected consumer count from network broker mbean within time limit",
1:7a7b380:                 verifyConsumerCount(2, destination, networkedBroker));
1:7a95e18: 
1:db9533b:         sendMessageTo(destination, broker);
1:7a95e18: 
1:05f82a9:         assertTrue("Got one message on each", verifyMessageCount(2, count));
1:7a95e18: 
1:05f82a9:         LOG.info("Stopping brokerTwo...");
1:db9533b:         networkedBroker.stop();
1:7a95e18:         networkedBroker.waitUntilStopped();
1:7a95e18: 
1:05f82a9:         LOG.info("restarting  broker Two...");
1:db9533b:         networkedBroker = createNetworkedBroker();
1:db9533b:         networkedBroker.start();
1:7a95e18: 
1:05f82a9:         LOG.info("Recreating durable Consumer on the broker after restart...");
1:db9533b:         registerDurableConsumer(networkedBroker, counter);
1:7a95e18: 
1:05f82a9:         // give advisories a chance to percolate
1:05f82a9:         TimeUnit.SECONDS.sleep(5);
1:7a95e18: 
1:db9533b:         sendMessageTo(destination, broker);
1:7a95e18: 
1:05f82a9:         // expect similar after restart
1:05f82a9:         assertTrue("got expected consumer count from local broker mbean within time limit",
1:7a7b380:                 verifyConsumerCount(2, destination, broker));
1:7a95e18: 
1:05f82a9:         // a durable sub is auto bridged on restart unless dynamicOnly=true
1:05f82a9:         assertTrue("got expected consumer count from network broker mbean within time limit",
1:7a7b380:                 verifyConsumerCount(2, destination, networkedBroker));
1:05f82a9: 
1:7a7b380:         assertTrue("got no inactive subs on broker", verifyDurableConsumerCount(0, broker));
1:7a7b380:         assertTrue("got no inactive subs on other broker", verifyDurableConsumerCount(0, networkedBroker));
1:05f82a9: 
1:05f82a9:         assertTrue("Got two more messages after restart", verifyMessageCount(4, count));
1:05f82a9:         TimeUnit.SECONDS.sleep(1);
1:05f82a9:         assertTrue("still Got just two more messages", verifyMessageCount(4, count));
1:05f82a9:     }
1:05f82a9: 
1:05f82a9:     private boolean verifyMessageCount(final int i, final AtomicInteger count) throws Exception {
1:05f82a9:         return Wait.waitFor(new Wait.Condition() {
1:7a95e18:             @Override
1:05f82a9:             public boolean isSatisified() throws Exception {
1:05f82a9:                 return i == count.get();
1:7a95e18:             }
1:05f82a9:         });
1:05f82a9:     }
1:05f82a9: 
1:05f82a9:     private ActiveMQTopic registerDurableConsumer(
1:05f82a9:             BrokerService brokerService, MessageListener listener) throws Exception {
1:05f82a9:         ConnectionFactory factory = createConnectionFactory(brokerService);
1:05f82a9:         Connection connection = factory.createConnection();
1:05f82a9:         connection.setClientID("DurableOne");
1:05f82a9:         connection.start();
1:05f82a9:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:05f82a9:         ActiveMQTopic destination = (ActiveMQTopic) session.createTopic(DESTINATION_NAME);
1:05f82a9:         // unique to a broker
1:05f82a9:         TopicSubscriber sub = session.createDurableSubscriber(destination, "SubOne" + brokerService.getBrokerName());
1:05f82a9:         sub.setMessageListener(listener);
1:05f82a9:         return destination;
1:05f82a9:     }
1:05f82a9: 
1:05f82a9:     private void sendMessageTo(ActiveMQTopic destination, BrokerService brokerService) throws Exception {
1:05f82a9:         ConnectionFactory factory = createConnectionFactory(brokerService);
1:05f82a9:         Connection conn = factory.createConnection();
1:05f82a9:         conn.start();
1:05f82a9:         Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:05f82a9:         session.createProducer(destination).send(session.createTextMessage("Hi"));
1:05f82a9:         conn.close();
1:05f82a9:     }
1:7a95e18: 
1:9d9d4cd:     protected ConnectionFactory createConnectionFactory(final BrokerService broker) throws Exception {
1:7a95e18:         String url = broker.getTransportConnectors().get(0).getServer().getConnectURI().toString();
1:9d9d4cd:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);
1:9d9d4cd:         connectionFactory.setOptimizedMessageDispatch(true);
1:9d9d4cd:         connectionFactory.setCopyMessageOnSend(false);
1:9d9d4cd:         connectionFactory.setUseCompression(false);
1:9d9d4cd:         connectionFactory.setDispatchAsync(false);
1:9d9d4cd:         connectionFactory.setUseAsyncSend(false);
1:9d9d4cd:         connectionFactory.setOptimizeAcknowledge(false);
1:9d9d4cd:         connectionFactory.setWatchTopicAdvisories(true);
1:9d9d4cd:         ActiveMQPrefetchPolicy qPrefetchPolicy= new ActiveMQPrefetchPolicy();
1:9d9d4cd:         qPrefetchPolicy.setQueuePrefetch(100);
1:9d9d4cd:         qPrefetchPolicy.setTopicPrefetch(1000);
1:9d9d4cd:         connectionFactory.setPrefetchPolicy(qPrefetchPolicy);
1:9d9d4cd:         connectionFactory.setAlwaysSyncSend(true);
1:9d9d4cd:         return connectionFactory;
1:05f82a9:     }
1:7a95e18: 
1:7a95e18:     // JMX Helper Methods
1:7a7b380:     private boolean verifyConsumerCount(final long expectedCount, final ActiveMQDestination destination, final BrokerService broker) throws Exception {
1:05f82a9:         return Wait.waitFor(new Wait.Condition() {
1:7a95e18:             @Override
1:05f82a9:             public boolean isSatisified() throws Exception {
1:05f82a9:                 boolean result = false;
1:7a7b380:                 try {
1:7a95e18: 
1:7a95e18:                     ObjectName[] destinations;
1:7a95e18: 
1:7a95e18:                     if (destination.isQueue()) {
1:7a95e18:                         destinations = broker.getAdminView().getQueues();
1:7a95e18:                     } else {
1:7a95e18:                         destinations = broker.getAdminView().getTopics();
1:7a95e18:                     }
1:7a95e18: 
1:05f82a9:                     // We should have 1 consumer for the queue on the local broker
1:7a95e18:                     for (ObjectName name : destinations) {
1:7a95e18:                         DestinationViewMBean view = (DestinationViewMBean)
1:7a95e18:                             broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
1:7a95e18: 
1:7a95e18:                         if (view.getName().equals(destination.getPhysicalName())) {
1:7a95e18:                             LOG.info("Consumers for " + destination.getPhysicalName() + " on " + broker + " : " + view.getConsumerCount());
1:383c27e:                             LOG.info("Subs: " + Arrays.asList(view.getSubscriptions()));
1:7a95e18:                             if (expectedCount == view.getConsumerCount()) {
1:7a95e18:                                 result = true;
1:7a95e18:                             }
1:05f82a9:                         }
1:05f82a9:                     }
1:7a95e18: 
1:7a7b380:                 } catch (Exception ignoreAndRetry) {
1:05f82a9:                 }
1:05f82a9:                 return result;
1:7a95e18:             }
1:05f82a9:         });
1:05f82a9:     }
1:7a95e18: 
1:7a7b380:     private boolean verifyDurableConsumerCount(final long expectedCount, final BrokerService broker) throws Exception {
1:05f82a9:         return Wait.waitFor(new Wait.Condition() {
1:7a95e18:             @Override
1:05f82a9:             public boolean isSatisified() throws Exception {
1:05f82a9:                 boolean result = false;
1:7a95e18:                 BrokerView view = broker.getAdminView();
1:7a95e18: 
1:7a95e18:                 if (view != null) {
1:7a95e18:                     ObjectName[] subs = broker.getAdminView().getInactiveDurableTopicSubscribers();
1:05f82a9:                     if (subs != null) {
1:383c27e:                         LOG.info("inactive durable subs on " + broker + " : " + Arrays.asList(subs));
1:7a95e18:                         if (expectedCount == subs.length) {
2:05f82a9:                             result = true;
1:7a95e18:                         }
1:05f82a9:                     }
1:05f82a9:                 }
1:05f82a9:                 return result;
1:05f82a9:             }
1:05f82a9:         });
1:05f82a9:     }
8:9086693: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:38f7857
/////////////////////////////////////////////////////////////////////////
1:         if (networkedBroker != null) {
1:             networkedBroker.stop();
1:             networkedBroker.waitUntilStopped();
1:         }
1:         if (broker != null) {
1:             broker.stop();
1:             broker.waitUntilStopped();
1:         }
commit:383c27e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:                             LOG.info("Subs: " + Arrays.asList(view.getSubscriptions()));
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("inactive durable subs on " + broker + " : " + Arrays.asList(subs));
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:7a95e18
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.BrokerView;
1: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private final static String BROKER_NAME = "broker";
1:     private final static String REM_BROKER_NAME = "networkedBroker";
1:     private final static String DESTINATION_NAME = "testQ";
1:     private final static int NUM_CONSUMERS = 1;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Create a consumer on the networked broker
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertTrue("got expected consumer count from mbean within time limit",
1:                    verifyConsumerCount(1, destination, broker));
1: 
1:         // Closing the connection will also close the consumer
1: 
1: 
1:             @Override
1: 
1: 
1: 
1: 
1: 
1: 
1:         networkedBroker.waitUntilStopped();
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:         String url = broker.getTransportConnectors().get(0).getServer().getConnectURI().toString();
/////////////////////////////////////////////////////////////////////////
1: 
1:     // JMX Helper Methods
1:             @Override
1: 
1:                     ObjectName[] destinations;
1: 
1:                     if (destination.isQueue()) {
1:                         destinations = broker.getAdminView().getQueues();
1:                     } else {
1:                         destinations = broker.getAdminView().getTopics();
1:                     }
1: 
1:                     for (ObjectName name : destinations) {
1:                         DestinationViewMBean view = (DestinationViewMBean)
1:                             broker.getManagementContext().newProxyInstance(name, DestinationViewMBean.class, true);
1: 
1:                         if (view.getName().equals(destination.getPhysicalName())) {
1:                             LOG.info("Consumers for " + destination.getPhysicalName() + " on " + broker + " : " + view.getConsumerCount());
1:                             if (expectedCount == view.getConsumerCount()) {
1:                                 result = true;
1:                             }
1: 
1:             }
1: 
1:             @Override
1:                 BrokerView view = broker.getAdminView();
1: 
1:                 if (view != null) {
1:                     ObjectName[] subs = broker.getAdminView().getInactiveDurableTopicSubscribers();
1:                         if (expectedCount == subs.length) {
1:             }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:bfbe90b
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     protected static final Logger LOG = LoggerFactory.getLogger(NetworkBrokerDetachTest.class);
commit:db9533b
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
1: import org.junit.Before;
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected BrokerService broker;
1:     protected BrokerService networkedBroker;
/////////////////////////////////////////////////////////////////////////
1:         persistenceAdapter.setDirectory(new File("target/activemq-data/kahadb/" + broker.getBrokerName() + "NetworBrokerDetatchTest"));
1:     
1:     @Before
1:     public void init() throws Exception {
1:         broker = createBroker();
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.start();
1:         
1:         networkedBroker = createNetworkedBroker();
1:         networkedBroker.setDeleteAllMessagesOnStartup(true);
1:         networkedBroker.start();
1:     }
1:     
1:     @After
1:     public void cleanup() throws Exception {
1:         networkedBroker.stop();
0:         networkedBroker.waitUntilStopped();
1:         
0:         broker.stop();
0:         broker.waitUntilStopped();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public void testNetworkedBrokerDurableSubAfterRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQTopic destination = registerDurableConsumer(networkedBroker, counter);
1:         registerDurableConsumer(broker, counter);
/////////////////////////////////////////////////////////////////////////
1:         sendMessageTo(destination, broker);
0:         networkedBroker.stop();
0:         networkedBroker.waitUntilStopped();           
1:         networkedBroker = createNetworkedBroker();
1:         networkedBroker.start();
1:         registerDurableConsumer(networkedBroker, counter);
1:         sendMessageTo(destination, broker);
/////////////////////////////////////////////////////////////////////////
commit:952d036
/////////////////////////////////////////////////////////////////////////
1:     protected void configureBroker(BrokerService broker) throws Exception {
author:Gary Tully
-------------------------------------------------------------------------------
commit:7a7b380
/////////////////////////////////////////////////////////////////////////
0:                 verifyConsumerCount(1, destination, broker));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("got expected 0 count from mbean within time limit", verifyConsumerCount(0, destination, broker));
/////////////////////////////////////////////////////////////////////////
1:                 verifyConsumerCount(2, destination, broker));
1:                 verifyConsumerCount(2, destination, networkedBroker));
/////////////////////////////////////////////////////////////////////////
1:                 verifyConsumerCount(2, destination, broker));
1:                 verifyConsumerCount(2, destination, networkedBroker));
1:         assertTrue("got no inactive subs on broker", verifyDurableConsumerCount(0, broker));
1:         assertTrue("got no inactive subs on other broker", verifyDurableConsumerCount(0, networkedBroker));
/////////////////////////////////////////////////////////////////////////
1:     private boolean verifyConsumerCount(final long expectedCount, final ActiveMQDestination destination, final BrokerService broker) throws Exception {
1:                 try {
0:                     Object consumers = broker.getManagementContext().getAttribute(getObjectName(broker.getBrokerName(), destination.isQueue() ? "Queue" : "Topic", "Destination=" + destination.getPhysicalName()), "ConsumerCount");
0:                         LOG.info("Consumers for " + destination.getPhysicalName() + " on " + broker + " : " + consumers);
1:                 } catch (Exception ignoreAndRetry) {
/////////////////////////////////////////////////////////////////////////
1:     private boolean verifyDurableConsumerCount(final long expectedCount, final BrokerService broker) throws Exception {
0:                     Set subs = broker.getManagementContext().queryNames(getObjectName(broker.getBrokerName(), "Subscription", "active=false,*"), null);
0:                         LOG.info("inactive durable subs on " + broker + " : " + subs);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:05f82a9
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
0: import java.util.Set;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.TopicSubscriber;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0: 	private final static String DESTINATION_NAME = "testQ";
1:     protected final int networkTTL = 2;
1:     protected final boolean dynamicOnly = false;
1:         configureBroker(broker);
1:         configureNetworkConnector(networkConnector);
1: 
1:         configureBroker(broker);
1:         broker.getManagementContext().setCreateConnector(false);
1:         NetworkConnector networkConnector = broker.addNetworkConnector("static:(tcp://localhost:61617?wireFormat.maxInactivityDuration=500)?useExponentialBackOff=false");
1:         configureNetworkConnector(networkConnector);
1:     private void configureNetworkConnector(NetworkConnector networkConnector) {
1:         networkConnector.setDuplex(false);
1:         networkConnector.setNetworkTTL(networkTTL);
1:         networkConnector.setDynamicOnly(dynamicOnly);
1:     }
1:     
1:     // variants for each store....
0:     private void configureBroker(BrokerService broker) throws Exception {
0:         //KahaPersistenceAdapter persistenceAdapter = new KahaPersistenceAdapter();
0:         //persistenceAdapter.setDirectory(new File("target/activemq-data/kaha/" + broker.getBrokerName() + "/NetworBrokerDetatchTest"));
0:         //broker.setPersistenceAdapter(persistenceAdapter);        
1:         
1:         KahaDBPersistenceAdapter persistenceAdapter = new KahaDBPersistenceAdapter();
0:         persistenceAdapter.setDirectory(new File("target/activemq-data/kahadb/NetworBrokerDetatchTest"));
1:         broker.setPersistenceAdapter(persistenceAdapter);
1:         
0:         // default AMQ
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination destination = (ActiveMQDestination) consSession.createQueue(DESTINATION_NAME);
1:             consSession.createConsumer(destination);
0:         assertTrue("got expected consumer count from mbean within time limit", 
0:                 verifyConsumerCount(1, destination, BROKER_NAME));
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("got expected 0 count from mbean within time limit", verifyConsumerCount(0, destination, BROKER_NAME));
/////////////////////////////////////////////////////////////////////////
1:     
1:     @Test
0:     public void testNetworkedBrokerDurableSubAfterRestart() throws Exception {        
0:         BrokerService brokerOne = createBroker();
0:         brokerOne.setDeleteAllMessagesOnStartup(true);
0:         brokerOne.start();
1: 
0:         BrokerService brokerTwo = createNetworkedBroker();
0:         brokerTwo.setDeleteAllMessagesOnStartup(true);
0:         brokerTwo.start();
1:         
1:         final AtomicInteger count = new AtomicInteger(0);
1:         MessageListener counter = new MessageListener() {
1:             public void onMessage(Message message) {
1:                 count.incrementAndGet();
1:             }
1:         };
1:         
1:         LOG.info("Creating durable consumer on each broker ...");
0:         ActiveMQTopic destination = registerDurableConsumer(brokerTwo, counter);
0:         registerDurableConsumer(brokerOne, counter);
1:         
1:         assertTrue("got expected consumer count from local broker mbean within time limit",
0:                 verifyConsumerCount(2, destination, BROKER_NAME));
1:         
1:         assertTrue("got expected consumer count from network broker mbean within time limit",
0:                 verifyConsumerCount(2, destination, REM_BROKER_NAME));
1:         
0:         sendMessageTo(destination, brokerOne);
1:         
1:         assertTrue("Got one message on each", verifyMessageCount(2, count));
1:         
1:         LOG.info("Stopping brokerTwo...");
0:         brokerTwo.stop();
0:         brokerTwo.waitUntilStopped();           
1:         
1:         LOG.info("restarting  broker Two...");
0:         brokerTwo = createNetworkedBroker();
0:         brokerTwo.start();
1:    
1:         LOG.info("Recreating durable Consumer on the broker after restart...");
0:         registerDurableConsumer(brokerTwo, counter);
1:         
1:         // give advisories a chance to percolate
1:         TimeUnit.SECONDS.sleep(5);
1:         
0:         sendMessageTo(destination, brokerOne);
1:         
1:         // expect similar after restart
1:         assertTrue("got expected consumer count from local broker mbean within time limit",
0:                 verifyConsumerCount(2, destination, BROKER_NAME));
1:  
1:         // a durable sub is auto bridged on restart unless dynamicOnly=true
1:         assertTrue("got expected consumer count from network broker mbean within time limit",
0:                 verifyConsumerCount(2, destination, REM_BROKER_NAME));
1: 
0:         assertTrue("got no inactive subs on broker", verifyDurableConsumerCount(0, BROKER_NAME));
0:         assertTrue("got no inactive subs on other broker", verifyDurableConsumerCount(0, REM_BROKER_NAME));
1: 
1:         assertTrue("Got two more messages after restart", verifyMessageCount(4, count));
1:         TimeUnit.SECONDS.sleep(1);
1:         assertTrue("still Got just two more messages", verifyMessageCount(4, count));
1:         
0:         brokerTwo.stop();
0:         brokerTwo.waitUntilStopped();
0:         brokerOne.stop();
0:         brokerOne.waitUntilStopped();
1:     }
1: 
1:     private boolean verifyMessageCount(final int i, final AtomicInteger count) throws Exception {
1:         return Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return i == count.get();
1:             }      
1:         });
1:     }
1: 
1:     private ActiveMQTopic registerDurableConsumer(
1:             BrokerService brokerService, MessageListener listener) throws Exception {
1:         ConnectionFactory factory = createConnectionFactory(brokerService);
1:         Connection connection = factory.createConnection();
1:         connection.setClientID("DurableOne");
1:         connection.start();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         ActiveMQTopic destination = (ActiveMQTopic) session.createTopic(DESTINATION_NAME);
1:         // unique to a broker
1:         TopicSubscriber sub = session.createDurableSubscriber(destination, "SubOne" + brokerService.getBrokerName());
1:         sub.setMessageListener(listener);
1:         return destination;
1:     }
1: 
1:     private void sendMessageTo(ActiveMQTopic destination, BrokerService brokerService) throws Exception {
1:         ConnectionFactory factory = createConnectionFactory(brokerService);
1:         Connection conn = factory.createConnection();
1:         conn.start();
1:         Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createProducer(destination).send(session.createTextMessage("Hi"));
1:         conn.close();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:     private boolean verifyConsumerCount(final long expectedCount, final ActiveMQDestination destination, final String brokerName) throws Exception {
1:         return Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 boolean result = false;
0:                 MBeanServerConnection mbsc = getMBeanServerConnection();
0:                 if (mbsc != null) {                
1:                     // We should have 1 consumer for the queue on the local broker
0:                     Object consumers = getAttribute(mbsc, brokerName, destination.isQueue() ? "Queue" : "Topic", "Destination=" + destination.getPhysicalName(), "ConsumerCount");
0:                     if (consumers != null) {
0:                         LOG.info("Consumers for " + destination.getPhysicalName() + " on " + brokerName + " : " + consumers);
0:                         if (expectedCount == ((Long)consumers).longValue()) {
1:                             result = true;
1:                         }
1:                     }
1:                 }
1:                 return result;
1:             }      
1:         });
1:     }
0:     
0:     
0:     private boolean verifyDurableConsumerCount(final long expectedCount, final String brokerName) throws Exception {
1:         return Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 boolean result = false;
0:                 MBeanServerConnection mbsc = getMBeanServerConnection();
0:                 if (mbsc != null) {
0:                     Set subs = getMbeans(mbsc, brokerName, "Subscription", "active=false,*");
1:                     if (subs != null) {
0:                         LOG.info("inactive durable subs on " + brokerName + " : " + subs);
0:                         if (expectedCount == subs.size()) {
1:                             result = true;
1:                         }
1:                     }
1:                 }
1:                 return result;
1:             }      
1:         });
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     private Set getMbeans(MBeanServerConnection mbsc, String brokerName, String type, String pattern) throws Exception {
0:         Set obj = null;
0:         try {
0:             obj = mbsc.queryMBeans(getObjectName(brokerName, type, pattern), null);
0:         } catch (InstanceNotFoundException ignored) {
0:             LOG.warn("getAttribute ex: " + ignored);
1:         }
0:         return obj;
1:     }
0:     
0:     private Object getAttribute(MBeanServerConnection mbsc, String brokerName, String type, String pattern, String attrName) throws Exception {
0:             obj = mbsc.getAttribute(getObjectName(brokerName, type, pattern), attrName);
commit:e80bf00
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assume.assumeNotNull;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
1: public class NetworkBrokerDetachTest {
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
0:         // If port 1099 is in use when the Broker starts, starting the jmx
0:         // connector will fail.  So, if we have no mbsc to query, skip the
0:         // test.
0:         assumeNotNull(mbsc);
commit:9086693
/////////////////////////////////////////////////////////////////////////
0: import javax.management.InstanceNotFoundException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
0:           consSession.createConsumer(consSession.createQueue(QUEUE_NAME));
0:         
0:         assertTrue("got expected consumer count from mbean within time limit", Wait.waitFor(new Wait.Condition() {
0:             public boolean isSatisified() throws Exception {
0:                 boolean result = false;
0:                 MBeanServerConnection mbsc = getMBeanServerConnection();
0:                 if (mbsc != null) {                
0:                     // We should have 1 consumer for the queue on the local broker
0:                     Object consumers = getAttribute(mbsc, "Queue", "Destination=" + QUEUE_NAME, "ConsumerCount");
0:                     if (consumers != null) {
0:                         LOG.info("Consumers for " + QUEUE_NAME + " on " + BROKER_NAME + " : " + consumers);
0:                         if (1L == ((Long)consumers).longValue()) {
0:                             result = true;
1:                         }
1:                     }
1:                 }
0:                 return result;
1:             }      
0:         }));
0:         assertTrue("got expected 0 count from mbean within time limit", Wait.waitFor(new Wait.Condition() {
0: 
0:             public boolean isSatisified() throws Exception {
0:                 boolean result = false;
0:                 MBeanServerConnection mbsc = getMBeanServerConnection();
0:                 if (mbsc != null) {                
0:                     // We should have 1 consumer for the queue on the local broker
0:                     Object consumers = getAttribute(mbsc, "Queue", "Destination=" + QUEUE_NAME, "ConsumerCount");
0:                     if (consumers != null) {
0:                         LOG.info("Consumers for " + QUEUE_NAME + " on " + BROKER_NAME + " : " + consumers);
0:                         if (0L == ((Long)consumers).longValue()) {
0:                             result = true;
1:                         }
1:                     }
1:                 }
0:                 return result;
1:             }      
0:         }));
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("getMBeanServer ex: " + ignored);
0:         Object obj = null;
0:         try {
0:             obj = mbsc.getAttribute(getObjectName(BROKER_NAME, type, pattern), attrName);
0:         } catch (InstanceNotFoundException ignored) {
0:             LOG.warn("getAttribute ex: " + ignored);
0:         }
commit:9d9d4cd
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network;
0: 
0: import java.net.MalformedURLException;
0: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
0: import javax.jms.MessageConsumer;
1: import javax.jms.Session;
0: import javax.management.MBeanServerConnection;
1: import javax.management.ObjectName;
0: import javax.management.remote.JMXConnector;
0: import javax.management.remote.JMXConnectorFactory;
0: import javax.management.remote.JMXServiceURL;
0: 
0: import junit.framework.TestCase;
0: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: public class NetworkBrokerDetachTest extends TestCase {
0: 
0: 	private final static String BROKER_NAME = "broker";
0: 	private final static String REM_BROKER_NAME = "networkedBroker";
0: 	private final static String QUEUE_NAME = "testQ";
0: 	private final static int    NUM_CONSUMERS = 1;
0: 	
0:     protected static final Log LOG = LogFactory.getLog(NetworkBrokerDetachTest.class);
1:     protected final int numRestarts = 3;
0: 
1:     protected BrokerService createBroker() throws Exception {
1:         BrokerService broker = new BrokerService();
1:         broker.setBrokerName(BROKER_NAME);
1:         broker.addConnector("tcp://localhost:61617");
1:         NetworkConnector networkConnector = broker.addNetworkConnector("static:(tcp://localhost:62617?wireFormat.maxInactivityDuration=500)?useExponentialBackOff=false");
0:         networkConnector.setDuplex(false);
1:         return broker;
0:     }
0:     
1:     protected BrokerService createNetworkedBroker() throws Exception {
1:         BrokerService broker = new BrokerService();
1:         broker.setBrokerName(REM_BROKER_NAME);
1:         broker.addConnector("tcp://localhost:62617");
1:         return broker;
0:     }
0:     
1:     public void testNetworkedBrokerDetach() throws Exception {
0:         BrokerService broker = createBroker();
0:         broker.start();
0:         
0:         BrokerService networkedBroker = createNetworkedBroker();
0:         networkedBroker.start();
0:         
1:         LOG.info("Creating Consumer on the networked broker ...");
0:         // Create a consumer on the networked broker 
1:         ConnectionFactory consFactory = createConnectionFactory(networkedBroker);
1:         Connection consConn = consFactory.createConnection();
1:         Session consSession = consConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         
1:         for(int i=0; i<NUM_CONSUMERS; i++) {
0:           MessageConsumer consumer = consSession.createConsumer(consSession.createQueue(QUEUE_NAME));
0:         }
0: 
0:         
0:         Thread.sleep(5000);
0:         
0:         MBeanServerConnection mbsc = getMBeanServerConnection();
0:         // We should have 1 consumer for the queue on the local broker
0:         Object consumers = getAttribute(mbsc, "Queue", "Destination=" + QUEUE_NAME, "ConsumerCount");
0:         LOG.info("Consumers for " + QUEUE_NAME + " on " + BROKER_NAME + " : " + consumers);
0:         assertEquals(1L, ((Long)consumers).longValue());       
0:         
0:         
1:         LOG.info("Stopping Consumer on the networked broker ...");
0:         // Closing the connection will also close the consumer 
1:         consConn.close();
0:         
0:         Thread.sleep(5000);
0:         
1:         // We should have 0 consumer for the queue on the local broker
0:         consumers = getAttribute(mbsc, "Queue", "Destination=" + QUEUE_NAME, "ConsumerCount");
0:         LOG.info("Consumers for " + QUEUE_NAME + " on " + BROKER_NAME + " : " + consumers);
0:         assertEquals(0L, ((Long)consumers).longValue());       
0:         
0:         networkedBroker.stop();
0:         networkedBroker.waitUntilStopped();
0:         broker.stop();
0:         broker.waitUntilStopped();
0:     }
0: 
1:     protected ConnectionFactory createConnectionFactory(final BrokerService broker) throws Exception {
0:         
0:         String url = ((TransportConnector) broker.getTransportConnectors().get(0)).getServer().getConnectURI().toString();
1:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);
1:         connectionFactory.setOptimizedMessageDispatch(true);
1:         connectionFactory.setCopyMessageOnSend(false);
1:         connectionFactory.setUseCompression(false);
1:         connectionFactory.setDispatchAsync(false);
1:         connectionFactory.setUseAsyncSend(false);
1:         connectionFactory.setOptimizeAcknowledge(false);
1:         connectionFactory.setWatchTopicAdvisories(true);
1:         ActiveMQPrefetchPolicy qPrefetchPolicy= new ActiveMQPrefetchPolicy();
1:         qPrefetchPolicy.setQueuePrefetch(100);
1:         qPrefetchPolicy.setTopicPrefetch(1000);
1:         connectionFactory.setPrefetchPolicy(qPrefetchPolicy);
1:         connectionFactory.setAlwaysSyncSend(true);
1:         return connectionFactory;
0:     }
0:     
0:     // JMX Helper Methods 
0:     
0:     private MBeanServerConnection getMBeanServerConnection() throws MalformedURLException {
0:         final JMXServiceURL url = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi");
0:         MBeanServerConnection mbsc = null;
0:         try {
0:             JMXConnector jmxc = JMXConnectorFactory.connect(url, null);
0:             mbsc = jmxc.getMBeanServerConnection();
0: 
0: //            // trace all existing MBeans
0: //            Set<?> all = mbsc.queryMBeans(null, null);
0: //            LOG.info("Total MBean count=" + all.size());
0: //            for (Object o : all) {
0: //                ObjectInstance bean = (ObjectInstance)o;
0: //                LOG.info(bean.getObjectName());
0: //            }
0:         } catch (Exception ignored) {
0:         }
0:         return mbsc;
0:     }
0:     
0:     private Object getAttribute(MBeanServerConnection mbsc, String type, String pattern, String attrName) throws Exception {
0:         Object obj = mbsc.getAttribute(getObjectName(BROKER_NAME, type, pattern), attrName);
0:         return obj;
0:     }
0:     
0:     private ObjectName getObjectName(String brokerName, String type, String pattern) throws Exception {
0:       ObjectName beanName = new ObjectName(
0:         "org.apache.activemq:BrokerName=" + brokerName + ",Type=" + type +"," + pattern
0:       );
0:       
0:       return beanName;
0:     }
0: }
============================================================================