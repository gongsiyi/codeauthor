1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker;
40:d29ca2a: 
1:d29ca2a: import java.io.ByteArrayOutputStream;
1:d29ca2a: import java.io.DataOutputStream;
1:d29ca2a: import java.io.File;
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.net.URI;
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.Iterator;
1:74a7a8b: import java.util.concurrent.TimeUnit;
1:230a86c: 
1:d29ca2a: import javax.jms.DeliveryMode;
1:d29ca2a: import javax.jms.MessageNotWriteableException;
1:93dc39b: 
1:d29ca2a: import org.apache.activemq.CombinationTestSupport;
1:d29ca2a: import org.apache.activemq.broker.region.RegionBroker;
1:f7e9206: import org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy;
1:f7e9206: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:f7e9206: import org.apache.activemq.broker.region.policy.PolicyMap;
1:f7e9206: import org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTextMessage;
1:d29ca2a: import org.apache.activemq.command.ConnectionId;
1:d29ca2a: import org.apache.activemq.command.ConnectionInfo;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.DestinationInfo;
1:d29ca2a: import org.apache.activemq.command.LocalTransactionId;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageDispatch;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:d29ca2a: import org.apache.activemq.command.ProducerInfo;
1:d29ca2a: import org.apache.activemq.command.RemoveInfo;
1:d29ca2a: import org.apache.activemq.command.SessionInfo;
1:d29ca2a: import org.apache.activemq.command.TransactionId;
1:d29ca2a: import org.apache.activemq.command.TransactionInfo;
1:d29ca2a: import org.apache.activemq.command.XATransactionId;
1:d29ca2a: import org.apache.activemq.store.PersistenceAdapter;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:d29ca2a: 
1:d29ca2a: public class BrokerTestSupport extends CombinationTestSupport {
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Setting this to false makes the test run faster but they may be less
1:230a86c:      * accurate.
1:d29ca2a:      */
1:d36c0d4:     public static final boolean FAST_NO_MESSAGE_LEFT_ASSERT = System.getProperty("FAST_NO_MESSAGE_LEFT_ASSERT", "true").equals("true");
1:fc00993: 
1:230a86c:     protected RegionBroker regionBroker;
1:bc3587c:     public BrokerService broker;
1:230a86c:     protected long idGenerator;
1:230a86c:     protected int msgIdGenerator;
1:230a86c:     protected int txGenerator;
1:230a86c:     protected int tempDestGenerator;
1:bc3587c:     public PersistenceAdapter persistenceAdapter;
1:4650f99: 
1:f6cf0ba:     protected String queueName = "TEST";
1:f6cf0ba: 
1:4650f99:     protected int maxWait = 10000;
1:fc00993: 
1:6d8e2c5:     protected SystemUsage memoryManager;
1:7631ca9:     protected PolicyMap policyMap = new PolicyMap();
1:93dc39b: 
1:4650f99:     @Override
1:d29ca2a:     protected void setUp() throws Exception {
1:d29ca2a:         super.setUp();
1:d29ca2a:         broker = createBroker();
1:9ba5e19:         policyMap.setDefaultEntry(getDefaultPolicy());
1:9ba5e19:         broker.setDestinationPolicy(policyMap);
1:d29ca2a:         broker.start();
3:d29ca2a:     }
1:230a86c: 
1:9ba5e19:     protected PolicyEntry getDefaultPolicy() {
1:9ba5e19:         PolicyEntry policy = new PolicyEntry();
1:f7e9206:         policy.setDispatchPolicy(new RoundRobinDispatchPolicy());
1:f7e9206:         policy.setSubscriptionRecoveryPolicy(new FixedCountSubscriptionRecoveryPolicy());
1:9ba5e19:         return policy;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected BrokerService createBroker() throws Exception {
1:230a86c:         BrokerService broker = BrokerFactory.createBroker(new URI("broker:()/localhost?persistent=false"));
1:230a86c:         return broker;
1:d29ca2a:     }
1:230a86c: 
1:4650f99:     @Override
1:d29ca2a:     protected void tearDown() throws Exception {
1:d29ca2a:         broker.stop();
1:645037e:         broker.waitUntilStopped();
1:230a86c:         broker = null;
1:230a86c:         regionBroker = null;
1:230a86c:         persistenceAdapter = null;
1:230a86c:         memoryManager = null;
1:d29ca2a:         super.tearDown();
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     protected ConsumerInfo createConsumerInfo(SessionInfo sessionInfo, ActiveMQDestination destination) throws Exception {
1:d29ca2a:         ConsumerInfo info = new ConsumerInfo(sessionInfo, ++idGenerator);
1:d29ca2a:         info.setBrowser(false);
1:d29ca2a:         info.setDestination(destination);
1:d29ca2a:         info.setPrefetchSize(1000);
1:d29ca2a:         info.setDispatchAsync(false);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected RemoveInfo closeConsumerInfo(ConsumerInfo consumerInfo) {
1:d29ca2a:         return consumerInfo.createRemoveCommand();
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     protected ProducerInfo createProducerInfo(SessionInfo sessionInfo) throws Exception {
1:d29ca2a:         ProducerInfo info = new ProducerInfo(sessionInfo, ++idGenerator);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     protected SessionInfo createSessionInfo(ConnectionInfo connectionInfo) throws Exception {
1:d29ca2a:         SessionInfo info = new SessionInfo(connectionInfo, ++idGenerator);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     protected ConnectionInfo createConnectionInfo() throws Exception {
1:d29ca2a:         ConnectionInfo info = new ConnectionInfo();
1:230a86c:         info.setConnectionId(new ConnectionId("connection:" + (++idGenerator)));
1:230a86c:         info.setClientId(info.getConnectionId().getValue());
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination) {
1:d29ca2a:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:d29ca2a:         message.setMessageId(new MessageId(producerInfo, ++msgIdGenerator));
1:d29ca2a:         message.setDestination(destination);
1:d29ca2a:         message.setPersistent(false);
1:d29ca2a:         try {
1:d29ca2a:             message.setText("Test Message Payload.");
1:d29ca2a:         } catch (MessageNotWriteableException e) {
1:d29ca2a:         }
1:d29ca2a:         return message;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected MessageAck createAck(ConsumerInfo consumerInfo, Message msg, int count, byte ackType) {
1:d29ca2a:         MessageAck ack = new MessageAck();
1:d29ca2a:         ack.setAckType(ackType);
1:d29ca2a:         ack.setConsumerId(consumerInfo.getConsumerId());
1:230a86c:         ack.setDestination(msg.getDestination());
1:230a86c:         ack.setLastMessageId(msg.getMessageId());
1:d29ca2a:         ack.setMessageCount(count);
1:d29ca2a:         return ack;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected void gc() {
1:d29ca2a:         regionBroker.gc();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected void profilerPause(String prompt) throws IOException {
1:230a86c:         if (System.getProperty("profiler") != null) {
1:d29ca2a:             System.out.println();
1:230a86c:             System.out.println(prompt + "> Press enter to continue: ");
1:230a86c:             while (System.in.read() != '\n') {
1:d29ca2a:             }
1:230a86c:             System.out.println(prompt + "> Done.");
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected RemoveInfo closeConnectionInfo(ConnectionInfo info) {
1:d29ca2a:         return info.createRemoveCommand();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected RemoveInfo closeSessionInfo(SessionInfo info) {
1:d29ca2a:         return info.createRemoveCommand();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected RemoveInfo closeProducerInfo(ProducerInfo info) {
1:d29ca2a:         return info.createRemoveCommand();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination, int deliveryMode) {
1:d29ca2a:         Message message = createMessage(producerInfo, destination);
1:d29ca2a:         message.setPersistent(deliveryMode == DeliveryMode.PERSISTENT);
1:d29ca2a:         return message;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected LocalTransactionId createLocalTransaction(SessionInfo info) {
1:d29ca2a:         LocalTransactionId id = new LocalTransactionId(info.getSessionId().getParentId(), ++txGenerator);
1:d29ca2a:         return id;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected XATransactionId createXATransaction(SessionInfo info) throws IOException {
1:d29ca2a:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:d29ca2a:         DataOutputStream os = new DataOutputStream(baos);
1:d29ca2a:         os.writeLong(++txGenerator);
1:d29ca2a:         os.close();
1:d29ca2a:         byte[] bs = baos.toByteArray();
1:230a86c: 
1:d29ca2a:         XATransactionId xid = new XATransactionId();
1:d29ca2a:         xid.setBranchQualifier(bs);
1:d29ca2a:         xid.setGlobalTransactionId(bs);
1:d29ca2a:         xid.setFormatId(55);
1:d29ca2a:         return xid;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected TransactionInfo createBeginTransaction(ConnectionInfo connectionInfo, TransactionId txid) {
1:d29ca2a:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.BEGIN);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected TransactionInfo createPrepareTransaction(ConnectionInfo connectionInfo, TransactionId txid) {
1:d29ca2a:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.PREPARE);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected TransactionInfo createCommitTransaction1Phase(ConnectionInfo connectionInfo, TransactionId txid) {
1:d29ca2a:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.COMMIT_ONE_PHASE);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected TransactionInfo createCommitTransaction2Phase(ConnectionInfo connectionInfo, TransactionId txid) {
1:d29ca2a:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.COMMIT_TWO_PHASE);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected TransactionInfo createRollbackTransaction(ConnectionInfo connectionInfo, TransactionId txid) {
1:d29ca2a:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.ROLLBACK);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:d29ca2a: 
1:7f5213b:     protected int countMessagesInQueue(StubConnection connection, ConnectionInfo connectionInfo, ActiveMQDestination destination) throws Exception {
1:230a86c: 
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         consumerInfo.setPrefetchSize(1);
1:d29ca2a:         consumerInfo.setBrowser(true);
1:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:933eb2f:         ArrayList<Object> skipped = new ArrayList<Object>();
1:230a86c: 
1:d29ca2a:         // Now get the messages.
1:fc00993:         Object m = connection.getDispatchQueue().poll(maxWait, TimeUnit.MILLISECONDS);
1:230a86c:         int i = 0;
1:230a86c:         while (m != null) {
1:230a86c:             if (m instanceof MessageDispatch && ((MessageDispatch)m).getConsumerId().equals(consumerInfo.getConsumerId())) {
1:230a86c:                 MessageDispatch md = (MessageDispatch)m;
1:230a86c:                 if (md.getMessage() != null) {
1:d29ca2a:                     i++;
1:d29ca2a:                     connection.send(createAck(consumerInfo, md.getMessage(), 1, MessageAck.STANDARD_ACK_TYPE));
1:d29ca2a:                 } else {
1:d29ca2a:                     break;
1:d29ca2a:                 }
1:d29ca2a:             } else {
1:d29ca2a:                 skipped.add(m);
1:d29ca2a:             }
1:fc00993:             m = connection.getDispatchQueue().poll(maxWait, TimeUnit.MILLISECONDS);
1:d29ca2a:         }
1:d29ca2a: 
1:933eb2f:         for (Iterator<Object> iter = skipped.iterator(); iter.hasNext();) {
1:d29ca2a:             connection.getDispatchQueue().put(iter.next());
1:d29ca2a:         }
1:230a86c: 
1:230a86c:         connection.send(closeSessionInfo(sessionInfo));
1:d29ca2a:         return i;
1:230a86c: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected DestinationInfo createTempDestinationInfo(ConnectionInfo connectionInfo, byte destinationType) {
1:d29ca2a:         DestinationInfo info = new DestinationInfo();
1:d29ca2a:         info.setConnectionId(connectionInfo.getConnectionId());
1:d29ca2a:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
1:230a86c:         info.setDestination(ActiveMQDestination.createDestination(info.getConnectionId() + ":" + (++tempDestGenerator), destinationType));
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     protected ActiveMQDestination createDestinationInfo(StubConnection connection, ConnectionInfo connectionInfo1, byte destinationType) throws Exception {
1:230a86c:         if ((destinationType & ActiveMQDestination.TEMP_MASK) != 0) {
1:d29ca2a:             DestinationInfo info = createTempDestinationInfo(connectionInfo1, destinationType);
1:d29ca2a:             connection.send(info);
1:d29ca2a:             return info.getDestination();
1:d29ca2a:         } else {
1:f6cf0ba:             return ActiveMQDestination.createDestination(queueName, destinationType);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected DestinationInfo closeDestinationInfo(DestinationInfo info) {
1:d29ca2a:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:d29ca2a:         info.setTimeout(0);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     protected StubConnection createConnection() throws Exception {
1:d29ca2a:         return new StubConnection(broker);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param connection
1:d29ca2a:      * @return
1:d29ca2a:      * @throws InterruptedException
1:d29ca2a:      */
1:d29ca2a:     public Message receiveMessage(StubConnection connection) throws InterruptedException {
1:fc00993:         return receiveMessage(connection, maxWait);
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public Message receiveMessage(StubConnection connection, long timeout) throws InterruptedException {
1:230a86c:         while (true) {
1:d29ca2a:             Object o = connection.getDispatchQueue().poll(timeout, TimeUnit.MILLISECONDS);
1:230a86c: 
1:fc00993:             if (o == null) {
1:d29ca2a:                 return null;
1:fc00993:             }
1:230a86c:             if (o instanceof MessageDispatch) {
1:230a86c: 
1:d29ca2a:                 MessageDispatch dispatch = (MessageDispatch)o;
1:fc00993:                 if (dispatch.getMessage() == null) {
1:d29ca2a:                     return null;
1:fc00993:                 }
1:d29ca2a:                 dispatch.setMessage(dispatch.getMessage().copy());
1:d29ca2a:                 dispatch.getMessage().setRedeliveryCounter(dispatch.getRedeliveryCounter());
1:d29ca2a:                 return dispatch.getMessage();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     };
1:d29ca2a: 
1:d29ca2a:     protected void assertNoMessagesLeft(StubConnection connection) throws InterruptedException {
1:fc00993:         long wait = FAST_NO_MESSAGE_LEFT_ASSERT ? 0 : maxWait;
1:230a86c:         while (true) {
1:d29ca2a:             Object o = connection.getDispatchQueue().poll(wait, TimeUnit.MILLISECONDS);
1:fc00993:             if (o == null) {
1:230a86c:                 return;
1:fc00993:             }
1:230a86c:             if (o instanceof MessageDispatch && ((MessageDispatch)o).getMessage() != null) {
1:efaf9cd:                 fail("Received a message: "+((MessageDispatch)o).getMessage().getMessageId() + " for: " + ((MessageDispatch)o).getMessage().getDestination().getPhysicalName());
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:efaf9cd
/////////////////////////////////////////////////////////////////////////
1:                 fail("Received a message: "+((MessageDispatch)o).getMessage().getMessageId() + " for: " + ((MessageDispatch)o).getMessage().getDestination().getPhysicalName());
commit:4c8a472
/////////////////////////////////////////////////////////////////////////
commit:bc3587c
/////////////////////////////////////////////////////////////////////////
1:     public BrokerService broker;
1:     public PersistenceAdapter persistenceAdapter;
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4650f99
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected int maxWait = 10000;
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:7631ca9
/////////////////////////////////////////////////////////////////////////
1:     protected PolicyMap policyMap = new PolicyMap();
commit:7ac1bb8
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:645037e
/////////////////////////////////////////////////////////////////////////
1:         broker.waitUntilStopped();
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:f6cf0ba
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected String queueName = "TEST";
/////////////////////////////////////////////////////////////////////////
1:             return ActiveMQDestination.createDestination(queueName, destinationType);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:01bdc52
/////////////////////////////////////////////////////////////////////////
0:                 fail("Received a message: "+((MessageDispatch)o).getMessage().getMessageId());
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Object> skipped = new ArrayList<Object>();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<Object> iter = skipped.iterator(); iter.hasNext();) {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(BrokerTestSupport.class);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected int maxWait = 4000;
/////////////////////////////////////////////////////////////////////////
1:         Object m = connection.getDispatchQueue().poll(maxWait, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:             m = connection.getDispatchQueue().poll(maxWait, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:         return receiveMessage(connection, maxWait);
1:             if (o == null) {
1:             }
1:                 if (dispatch.getMessage() == null) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         long wait = FAST_NO_MESSAGE_LEFT_ASSERT ? 0 : maxWait;
1:             if (o == null) {
1:             }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected static final Log LOG = LogFactory.getLog(BrokerTestSupport.class);
1: 
1:      * Setting this to false makes the test run faster but they may be less
1:      * accurate.
1:     protected RegionBroker regionBroker;
0:     protected BrokerService broker;
1:     protected long idGenerator;
1:     protected int msgIdGenerator;
1:     protected int txGenerator;
1:     protected int tempDestGenerator;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         BrokerService broker = BrokerFactory.createBroker(new URI("broker:()/localhost?persistent=false"));
1:         return broker;
1: 
1:         broker = null;
1:         regionBroker = null;
1:         persistenceAdapter = null;
1:         memoryManager = null;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         info.setConnectionId(new ConnectionId("connection:" + (++idGenerator)));
1:         info.setClientId(info.getConnectionId().getValue());
1: 
/////////////////////////////////////////////////////////////////////////
1:         ack.setDestination(msg.getDestination());
1:         ack.setLastMessageId(msg.getMessageId());
/////////////////////////////////////////////////////////////////////////
1:         if (System.getProperty("profiler") != null) {
1:             System.out.println(prompt + "> Press enter to continue: ");
1:             while (System.in.read() != '\n') {
1:             System.out.println(prompt + "> Done.");
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:         int i = 0;
1:         while (m != null) {
1:             if (m instanceof MessageDispatch && ((MessageDispatch)m).getConsumerId().equals(consumerInfo.getConsumerId())) {
1:                 MessageDispatch md = (MessageDispatch)m;
1:                 if (md.getMessage() != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         connection.send(closeSessionInfo(sessionInfo));
1: 
1:         info.setDestination(ActiveMQDestination.createDestination(info.getConnectionId() + ":" + (++tempDestGenerator), destinationType));
1: 
1:         if ((destinationType & ActiveMQDestination.TEMP_MASK) != 0) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         if (f.isDirectory()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         while (true) {
1: 
0:             if (o == null)
1: 
1:             if (o instanceof MessageDispatch) {
1: 
0:                 if (dispatch.getMessage() == null)
1: 
/////////////////////////////////////////////////////////////////////////
1:         while (true) {
0:             if (o == null)
1:                 return;
1:             if (o instanceof MessageDispatch && ((MessageDispatch)o).getMessage() != null) {
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:b022a9d
/////////////////////////////////////////////////////////////////////////
0:         broker=null;    
0:         regionBroker=null;    
0:         persistenceAdapter=null;
0:         memoryManager=null;
commit:93dc39b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
1: 
1:     
0:     protected static final Log log = LogFactory.getLog(BrokerTestSupport.class);
/////////////////////////////////////////////////////////////////////////
0:             System.out.println(prompt+"> Done.");
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     protected ConsumerInfo createConsumerInfo(SessionInfo sessionInfo, ActiveMQDestination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     protected ProducerInfo createProducerInfo(SessionInfo sessionInfo) throws Exception {
1:     protected SessionInfo createSessionInfo(ConnectionInfo connectionInfo) throws Exception {
1:     protected ConnectionInfo createConnectionInfo() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     protected int countMessagesInQueue(StubConnection connection, ConnectionInfo connectionInfo, ActiveMQDestination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQDestination createDestinationInfo(StubConnection connection, ConnectionInfo connectionInfo1, byte destinationType) throws Exception {
commit:c59246d
/////////////////////////////////////////////////////////////////////////
0:         info.setClientId( info.getConnectionId().getValue() );
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
1: 
1: import java.io.ByteArrayOutputStream;
1: import java.io.DataOutputStream;
1: import java.io.File;
1: import java.io.IOException;
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: 
1: import javax.jms.DeliveryMode;
1: import javax.jms.MessageNotWriteableException;
1: 
1: import org.apache.activemq.CombinationTestSupport;
0: import org.apache.activemq.broker.BrokerFactory;
0: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQTextMessage;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.command.SessionInfo;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.TransactionInfo;
1: import org.apache.activemq.command.XATransactionId;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.store.PersistenceAdapter;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: public class BrokerTestSupport extends CombinationTestSupport {
0:     private static final Log log = LogFactory.getLog(BrokerTestSupport.class);
1:     
1:     /**
0:      * Setting this to false makes the test run faster but they may be less accurate.
1:      */
0:     public static boolean FAST_NO_MESSAGE_LEFT_ASSERT = System.getProperty("FAST_NO_MESSAGE_LEFT_ASSERT", "true").equals("true");
1: 
0:     protected RegionBroker regionBroker;    
0:     protected BrokerService broker;    
0:     protected long idGenerator=0;
0:     protected int msgIdGenerator=0;
0:     protected int txGenerator=0;
0:     protected int tempDestGenerator=0;
0:     protected PersistenceAdapter persistenceAdapter;
1: 
0:     protected int MAX_WAIT = 1000;
1: 
0:     protected UsageManager memoryManager;
1: 
1: 
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         broker = createBroker();
1:         broker.start();
1:     }
1: 
1:     protected BrokerService createBroker() throws Exception {
0:         return BrokerFactory.createBroker(new URI("broker:()/localhost?persistent=false"));
1:     }
1:     
1:     protected void tearDown() throws Exception {
1:         broker.stop();
1:         super.tearDown();
1:     }
1:     
0:     protected ConsumerInfo createConsumerInfo(SessionInfo sessionInfo, ActiveMQDestination destination) throws Throwable {
1:         ConsumerInfo info = new ConsumerInfo(sessionInfo, ++idGenerator);
1:         info.setBrowser(false);
1:         info.setDestination(destination);
1:         info.setPrefetchSize(1000);
1:         info.setDispatchAsync(false);
1:         return info;
1:     }
1:     
1:     protected RemoveInfo closeConsumerInfo(ConsumerInfo consumerInfo) {
1:         return consumerInfo.createRemoveCommand();
1:     }
1: 
0:     protected ProducerInfo createProducerInfo(SessionInfo sessionInfo) throws Throwable {
1:         ProducerInfo info = new ProducerInfo(sessionInfo, ++idGenerator);
1:         return info;
1:     }
1: 
0:     protected SessionInfo createSessionInfo(ConnectionInfo connectionInfo) throws Throwable {
1:         SessionInfo info = new SessionInfo(connectionInfo, ++idGenerator);
1:         return info;
1:     }
1: 
0:     protected ConnectionInfo createConnectionInfo() throws Throwable {
1:         ConnectionInfo info = new ConnectionInfo();
0:         info.setConnectionId(new ConnectionId("connection:"+(++idGenerator)));
0:         info.setClientId( info.getConnectionId().getConnectionId() );
1:         return info;
1:     }
1:     
1:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination) {
1:         ActiveMQTextMessage message = new ActiveMQTextMessage();
1:         message.setMessageId(new MessageId(producerInfo, ++msgIdGenerator));
1:         message.setDestination(destination);
1:         message.setPersistent(false);
1:         try {
1:             message.setText("Test Message Payload.");
1:         } catch (MessageNotWriteableException e) {
1:         }
1:         return message;
1:     }
1: 
1:     protected MessageAck createAck(ConsumerInfo consumerInfo, Message msg, int count, byte ackType) {
1:         MessageAck ack = new MessageAck();
1:         ack.setAckType(ackType);
1:         ack.setConsumerId(consumerInfo.getConsumerId());
0:         ack.setDestination( msg.getDestination() );
0:         ack.setLastMessageId( msg.getMessageId() );
1:         ack.setMessageCount(count);
1:         return ack;
1:     }
1: 
1:     protected void gc() {
1:         regionBroker.gc();
1:     }
1: 
1:     protected void profilerPause(String prompt) throws IOException {
0:         if( System.getProperty("profiler")!=null ) {
1:             System.out.println();
0:             System.out.println(prompt+"> Press enter to continue: ");
0:             while( System.in.read()!='\n' ) {            
1:             }
0:             log.info(prompt+"> Done.");
1:         }
1:     }
1: 
1:     protected RemoveInfo closeConnectionInfo(ConnectionInfo info) {
1:         return info.createRemoveCommand();
1:     }
1: 
1:     protected RemoveInfo closeSessionInfo(SessionInfo info) {
1:         return info.createRemoveCommand();
1:     }
1: 
1:     protected RemoveInfo closeProducerInfo(ProducerInfo info) {
1:         return info.createRemoveCommand();
1:     }
1: 
1:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination, int deliveryMode) {
1:         Message message = createMessage(producerInfo, destination);
1:         message.setPersistent(deliveryMode == DeliveryMode.PERSISTENT);
1:         return message;
1:     }
1: 
1:     protected LocalTransactionId createLocalTransaction(SessionInfo info) {
1:         LocalTransactionId id = new LocalTransactionId(info.getSessionId().getParentId(), ++txGenerator);
1:         return id;
1:     }
1:     
1:     protected XATransactionId createXATransaction(SessionInfo info) throws IOException {
0:         long id = txGenerator;
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         DataOutputStream os = new DataOutputStream(baos);
1:         os.writeLong(++txGenerator);
1:         os.close();
1:         byte[] bs = baos.toByteArray();
1:         
1:         XATransactionId xid = new XATransactionId();
1:         xid.setBranchQualifier(bs);
1:         xid.setGlobalTransactionId(bs);
1:         xid.setFormatId(55);
1:         return xid;
1:     }
1: 
1:     protected TransactionInfo createBeginTransaction(ConnectionInfo connectionInfo, TransactionId txid) {
1:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.BEGIN);
1:         return info;
1:     }
1:     
1:     protected TransactionInfo createPrepareTransaction(ConnectionInfo connectionInfo, TransactionId txid) {
1:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.PREPARE);
1:         return info;
1:     }
1: 
1:     protected TransactionInfo createCommitTransaction1Phase(ConnectionInfo connectionInfo, TransactionId txid) {
1:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.COMMIT_ONE_PHASE);
1:         return info;
1:     }
1:     
1:     protected TransactionInfo createCommitTransaction2Phase(ConnectionInfo connectionInfo, TransactionId txid) {
1:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.COMMIT_TWO_PHASE);
1:         return info;
1:     }
1:     
1:     protected TransactionInfo createRollbackTransaction(ConnectionInfo connectionInfo, TransactionId txid) {
1:         TransactionInfo info = new TransactionInfo(connectionInfo.getConnectionId(), txid, TransactionInfo.ROLLBACK);
1:         return info;
1:     }
1: 
0:     protected int countMessagesInQueue(StubConnection connection, ConnectionInfo connectionInfo, ActiveMQDestination destination) throws Throwable {
1:         
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(sessionInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setPrefetchSize(1);
1:         consumerInfo.setBrowser(true);
1:         connection.send(consumerInfo);
1:     
0:         ArrayList skipped = new ArrayList();
1:         
1:         // Now get the messages.
0:         Object m = connection.getDispatchQueue().poll(MAX_WAIT, TimeUnit.MILLISECONDS);
0:         int i=0;
0:         while( m!=null ) {
0:             if( m instanceof MessageDispatch && ((MessageDispatch)m).getConsumerId().equals(consumerInfo.getConsumerId()) ) {
0:                 MessageDispatch md  = (MessageDispatch) m;
0:                 if( md.getMessage()!=null ) {
1:                     i++;
1:                     connection.send(createAck(consumerInfo, md.getMessage(), 1, MessageAck.STANDARD_ACK_TYPE));
1:                 } else {
1:                     break;
1:                 }
1:             } else {
1:                 skipped.add(m);
1:             }
0:             m = connection.getDispatchQueue().poll(MAX_WAIT, TimeUnit.MILLISECONDS);
1:         }
1:         
0:         for (Iterator iter = skipped.iterator(); iter.hasNext();) {
1:             connection.getDispatchQueue().put(iter.next());
1:         }
1:         
0:         connection.send(closeSessionInfo(sessionInfo));        
1:         return i;
1:         
1:     }
1: 
1:     protected DestinationInfo createTempDestinationInfo(ConnectionInfo connectionInfo, byte destinationType) {
1:         DestinationInfo info = new DestinationInfo();
1:         info.setConnectionId(connectionInfo.getConnectionId());
1:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
0:         info.setDestination(ActiveMQDestination.createDestination(info.getConnectionId()+":"+(++tempDestGenerator), destinationType));
1:         return info;
1:     }
1:     
0:     protected ActiveMQDestination createDestinationInfo(StubConnection connection, ConnectionInfo connectionInfo1, byte destinationType) throws Throwable {
0:         if( (destinationType & ActiveMQDestination.TEMP_MASK)!=0 ) {
1:             DestinationInfo info = createTempDestinationInfo(connectionInfo1, destinationType);
1:             connection.send(info);
1:             return info.getDestination();
1:         } else {
0:             return ActiveMQDestination.createDestination("TEST", destinationType);
1:         }
1:     }
1:     
1:     
1:     protected DestinationInfo closeDestinationInfo(DestinationInfo info) {
1:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:         info.setTimeout(0);
1:         return info;
1:     }
1:     
0:     public static void recursiveDelete(File f) {
0:         if( f.isDirectory() ) {
0:             File[] files = f.listFiles();
0:             for (int i = 0; i < files.length; i++) {
0:                 recursiveDelete(files[i]);
1:             }
1:         }
0:         f.delete();
1:     }
1: 
1:     protected StubConnection createConnection() throws Exception {
1:         return new StubConnection(broker);
1:     }
1: 
1:     /**
1:      * @param connection
1:      * @return
1:      * @throws InterruptedException
1:      */
1:     public Message receiveMessage(StubConnection connection) throws InterruptedException {
0:         return receiveMessage(connection, MAX_WAIT);
1:     }
1:     
1:     public Message receiveMessage(StubConnection connection, long timeout) throws InterruptedException {
0:         while( true ) {
1:             Object o = connection.getDispatchQueue().poll(timeout, TimeUnit.MILLISECONDS);
1:             
0:             if( o == null )
1:                 return null;
1:             
0:             if( o instanceof MessageDispatch ) {
1:                 
1:                 MessageDispatch dispatch = (MessageDispatch)o;
0:                 if( dispatch.getMessage()==null )
1:                     return null;
1:                 
1:                 dispatch.setMessage(dispatch.getMessage().copy());
1:                 dispatch.getMessage().setRedeliveryCounter(dispatch.getRedeliveryCounter());
1:                 return dispatch.getMessage();
1:             }
1:         }
1:     };
1: 
1:     protected void assertNoMessagesLeft(StubConnection connection) throws InterruptedException {
0:         long wait = FAST_NO_MESSAGE_LEFT_ASSERT ? 0 : MAX_WAIT;
0:         while( true ) {
1:             Object o = connection.getDispatchQueue().poll(wait, TimeUnit.MILLISECONDS);
0:             if( o == null )
0:                 return;            
0:             if( o instanceof MessageDispatch && ((MessageDispatch)o).getMessage()!=null ) {
0:                 fail("Received a message.");
1:             }
1:         }
1:     }
1: 
1: 
1: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     protected SystemUsage memoryManager;
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
1:     public static final boolean FAST_NO_MESSAGE_LEFT_ASSERT = System.getProperty("FAST_NO_MESSAGE_LEFT_ASSERT", "true").equals("true");
commit:9ba5e19
/////////////////////////////////////////////////////////////////////////
0:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.setDefaultEntry(getDefaultPolicy());
1:         broker.setDestinationPolicy(policyMap);
1:     protected PolicyEntry getDefaultPolicy() {
1:         PolicyEntry policy = new PolicyEntry();
1:         return policy;
0:     
0:   
commit:f7e9206
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy;
/////////////////////////////////////////////////////////////////////////
0:         setDefaultPolicy(broker);
0:     
0:     protected void setDefaultPolicy(BrokerService brokerService) {
0:     	PolicyEntry policy = new PolicyEntry();
1:         policy.setDispatchPolicy(new RoundRobinDispatchPolicy());
1:         policy.setSubscriptionRecoveryPolicy(new FixedCountSubscriptionRecoveryPolicy());
0:         PolicyMap pMap = new PolicyMap();
0:         pMap.setDefaultEntry(policy);
0: 
0:         broker.setDestinationPolicy(pMap);
0:     }
0:         BrokerService broker =  BrokerFactory.createBroker(new URI("broker:()/localhost?persistent=false"));
0:         return  broker;
author:James Strachan
-------------------------------------------------------------------------------
commit:8704338
/////////////////////////////////////////////////////////////////////////
0:     protected int MAX_WAIT = 4000;
============================================================================