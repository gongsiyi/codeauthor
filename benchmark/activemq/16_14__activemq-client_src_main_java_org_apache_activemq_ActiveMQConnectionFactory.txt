1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:230a86c:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
1:7653774: 
1:04ee70a: import java.io.IOException;
1:74a7a8b: import java.net.URI;
1:74a7a8b: import java.net.URISyntaxException;
1:71e4585: import java.security.AccessController;
1:71e4585: import java.security.PrivilegedAction;
1:94446e5: import java.util.*;
1:e3fcf71: import java.util.concurrent.RejectedExecutionHandler;
1:7653774: 
1:74a7a8b: import javax.jms.Connection;
1:74a7a8b: import javax.jms.ConnectionFactory;
1:8b9e755: import javax.jms.ExceptionListener;
1:74a7a8b: import javax.jms.JMSException;
1:74a7a8b: import javax.jms.QueueConnection;
1:74a7a8b: import javax.jms.QueueConnectionFactory;
1:74a7a8b: import javax.jms.TopicConnection;
1:74a7a8b: import javax.jms.TopicConnectionFactory;
1:74a7a8b: import javax.naming.Context;
1:642cc43: 
1:c9bb1c9: import org.apache.activemq.blob.BlobTransferPolicy;
1:a3836b5: import org.apache.activemq.broker.region.policy.RedeliveryPolicyMap;
1:7f0e135: import org.apache.activemq.jndi.JNDIBaseStorable;
1:d29ca2a: import org.apache.activemq.management.JMSStatsImpl;
1:d29ca2a: import org.apache.activemq.management.StatsCapable;
1:d29ca2a: import org.apache.activemq.management.StatsImpl;
1:c33231b: import org.apache.activemq.thread.TaskRunnerFactory;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:d29ca2a: import org.apache.activemq.transport.TransportFactory;
1:d483226: import org.apache.activemq.transport.TransportListener;
1:eeec0c0: import org.apache.activemq.util.*;
1:d29ca2a: import org.apache.activemq.util.URISupport.CompositeData;
1:71e4585: import org.slf4j.Logger;
1:71e4585: import org.slf4j.LoggerFactory;
1:74a7a8b: 
1:d29ca2a: /**
1:d29ca2a:  * A ConnectionFactory is an an Administered object, and is used for creating
1:d29ca2a:  * Connections. <p/> This class also implements QueueConnectionFactory and
1:d29ca2a:  * TopicConnectionFactory. You can use this connection to create both
1:d29ca2a:  * QueueConnections and TopicConnections.
1:fa40250:  *
1:fa40250:  *
1:d29ca2a:  * @see javax.jms.ConnectionFactory
1:d29ca2a:  */
1:5f5ccc0: public class ActiveMQConnectionFactory extends JNDIBaseStorable implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory, StatsCapable, Cloneable {
1:71e4585:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQConnectionFactory.class);
1:71e4585:     private static final String DEFAULT_BROKER_HOST;
1:71e4585:     private static final int DEFAULT_BROKER_PORT;
1:71e4585:     static{
1:71e4585:         String host = null;
1:71e4585:         String port = null;
1:71e4585:         try {
1:71e4585:              host = AccessController.doPrivileged(new PrivilegedAction<String>() {
1:71e4585:                  @Override
1:71e4585:                  public String run() {
1:71e4585:                      String result = System.getProperty("org.apache.activemq.AMQ_HOST");
1:71e4585:                      result = (result==null||result.isEmpty()) ?  System.getProperty("AMQ_HOST","localhost") : result;
1:71e4585:                      return result;
1:71e4585:                  }
1:71e4585:              });
1:71e4585:              port = AccessController.doPrivileged(new PrivilegedAction<String>() {
1:71e4585:                  @Override
1:71e4585:                  public String run() {
1:71e4585:                      String result = System.getProperty("org.apache.activemq.AMQ_PORT");
1:71e4585:                      result = (result==null||result.isEmpty()) ?  System.getProperty("AMQ_PORT","61616") : result;
1:71e4585:                      return result;
1:71e4585:                  }
1:71e4585:              });
1:71e4585:         }catch(Throwable e){
1:71e4585:             LOG.debug("Failed to look up System properties for host and port",e);
1:71e4585:         }
1:71e4585:         host = (host == null || host.isEmpty()) ? "localhost" : host;
1:71e4585:         port = (port == null || port.isEmpty()) ? "61616" : port;
1:71e4585:         DEFAULT_BROKER_HOST = host;
1:71e4585:         DEFAULT_BROKER_PORT = Integer.parseInt(port);
1:71e4585:     }
1:71e4585: 
1:74a7a8b: 
1:71e4585:     public static final String DEFAULT_BROKER_BIND_URL;
1:71e4585: 
1:71e4585:     static{
1:71e4585:         final String defaultURL = "tcp://" + DEFAULT_BROKER_HOST + ":" + DEFAULT_BROKER_PORT;
1:71e4585:         String bindURL = null;
1:71e4585: 
1:71e4585:         try {
1:71e4585:             bindURL = AccessController.doPrivileged(new PrivilegedAction<String>() {
1:71e4585:                 @Override
1:71e4585:                 public String run() {
1:71e4585:                     String result = System.getProperty("org.apache.activemq.BROKER_BIND_URL");
1:71e4585:                     result = (result==null||result.isEmpty()) ?  System.getProperty("BROKER_BIND_URL",defaultURL) : result;
1:71e4585:                     return result;
1:71e4585:                 }
1:71e4585:             });
1:71e4585:         }catch(Throwable e){
1:71e4585:             LOG.debug("Failed to look up System properties for host and port",e);
1:71e4585:         }
1:71e4585:         bindURL = (bindURL == null || bindURL.isEmpty()) ? defaultURL : bindURL;
1:71e4585:         DEFAULT_BROKER_BIND_URL = bindURL;
1:71e4585:     }
1:71e4585: 
1:3f98639:     public static final String DEFAULT_BROKER_URL = "failover://"+DEFAULT_BROKER_BIND_URL;
1:d29ca2a:     public static final String DEFAULT_USER = null;
1:d29ca2a:     public static final String DEFAULT_PASSWORD = null;
1:c9bb1c9:     public static final int DEFAULT_PRODUCER_WINDOW_SIZE = 0;
1:230a86c: 
1:d29ca2a:     protected URI brokerURL;
1:d29ca2a:     protected String userName;
1:d29ca2a:     protected String password;
1:d29ca2a:     protected String clientID;
1:62fb85e:     protected boolean dispatchAsync=true;
1:62fb85e:     protected boolean alwaysSessionAsync=true;
1:230a86c: 
1:230a86c:     JMSStatsImpl factoryStats = new JMSStatsImpl();
1:230a86c: 
1:230a86c:     private IdGenerator clientIdGenerator;
1:230a86c:     private String clientIDPrefix;
1:b9045db:     private IdGenerator connectionIdGenerator;
1:b9045db:     private String connectionIDPrefix;
1:c9bb1c9: 
1:05a8cba:     // client policies
1:d29ca2a:     private ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:a3836b5:     private RedeliveryPolicyMap redeliveryPolicyMap = new RedeliveryPolicyMap();
1:a3836b5:     {
1:a3836b5:         redeliveryPolicyMap.setDefaultEntry(new RedeliveryPolicy());
1:a3836b5:     }
1:05a8cba:     private BlobTransferPolicy blobTransferPolicy = new BlobTransferPolicy();
1:86faaef:     private MessageTransformer transformer;
1:c9bb1c9: 
1:230a86c:     private boolean disableTimeStampsByDefault;
1:d29ca2a:     private boolean optimizedMessageDispatch = true;
1:975fc55:     private long optimizeAcknowledgeTimeOut = 300;
1:3d5a758:     private long optimizedAckScheduledAckInterval = 0;
1:d29ca2a:     private boolean copyMessageOnSend = true;
1:230a86c:     private boolean useCompression;
1:230a86c:     private boolean objectMessageSerializationDefered;
1:230a86c:     private boolean useAsyncSend;
1:230a86c:     private boolean optimizeAcknowledge;
1:5fe0a4c:     private int closeTimeout = 15000;
1:d29ca2a:     private boolean useRetroactiveConsumer;
1:3d862f0:     private boolean exclusiveConsumer;
1:4b08ea5:     private boolean nestedMapAndListEnabled = true;
1:4e2acd4:     private boolean alwaysSyncSend;
1:230a86c:     private boolean watchTopicAdvisories = true;
1:230a86c:     private int producerWindowSize = DEFAULT_PRODUCER_WINDOW_SIZE;
1:9d53c53:     private long warnAboutUnstartedConnectionTimeout = 500L;
1:c808beb:     private int sendTimeout = 0;
1:f43c090:     private int connectResponseTimeout = 0;
1:d8b5d5c:     private boolean sendAcksAsync=true;
1:d483226:     private TransportListener transportListener;
1:c808beb:     private ExceptionListener exceptionListener;
1:2a58f4c:     private int auditDepth = ActiveMQMessageAudit.DEFAULT_WINDOW_SIZE;
1:2a58f4c:     private int auditMaximumProducerNumber = ActiveMQMessageAudit.MAXIMUM_PRODUCER_COUNT;
1:c808beb:     private boolean useDedicatedTaskRunner;
1:b836af8:     private long consumerFailoverRedeliveryWaitPeriod = 0;
1:794e62f:     private boolean checkForDuplicates = true;
1:f82dc25:     private ClientInternalExceptionListener clientInternalExceptionListener;
1:2d9959a:     private boolean messagePrioritySupported = false;
1:2030097:     private boolean transactedIndividualAck = false;
1:0b6bf7e:     private boolean nonBlockingRedelivery = false;
1:c33231b:     private int maxThreadPoolSize = ActiveMQConnection.DEFAULT_THREAD_POOL_SIZE;
1:c33231b:     private TaskRunnerFactory sessionTaskRunner;
1:e3fcf71:     private RejectedExecutionHandler rejectedTaskHandler = null;
1:b66559e:     protected int xaAckMode = -1; // ensure default init before setting via brokerUrl introspection in sub class
1:221a751:     private boolean rmIdFromConnectionId = false;
1:642cc43:     private boolean consumerExpiryCheckEnabled = true;
1:eeec0c0:     private List<String> trustedPackages = Arrays.asList(ClassLoadingAwareObjectInputStream.serializablePackages);
1:94446e5:     private boolean trustAllPackages = false;
1:7f0e135: 
1:d29ca2a:     // /////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory Methods
1:d29ca2a:     //
1:d29ca2a:     // /////////////////////////////////////////////
1:7f0e135: 
1:d29ca2a:     public ActiveMQConnectionFactory() {
1:d29ca2a:         this(DEFAULT_BROKER_URL);
1:230a86c:     }
1:7f0e135: 
1:d29ca2a:     public ActiveMQConnectionFactory(String brokerURL) {
1:d29ca2a:         this(createURI(brokerURL));
1:d29ca2a:     }
1:7f0e135: 
1:ecf89a6:     public ActiveMQConnectionFactory(URI brokerURL) {
1:ecf89a6:         setBrokerURL(brokerURL.toString());
1:ecf89a6:     }
1:ecf89a6: 
1:ecf89a6:     public ActiveMQConnectionFactory(String userName, String password, URI brokerURL) {
1:ecf89a6:         setUserName(userName);
1:ecf89a6:         setPassword(password);
1:ecf89a6:         setBrokerURL(brokerURL.toString());
1:ecf89a6:     }
1:ecf89a6: 
1:ecf89a6:     public ActiveMQConnectionFactory(String userName, String password, String brokerURL) {
1:ecf89a6:         setUserName(userName);
1:ecf89a6:         setPassword(password);
1:ecf89a6:         setBrokerURL(brokerURL);
1:ecf89a6:     }
1:ecf89a6: 
1:d29ca2a:     /**
1:5f5ccc0:      * Returns a copy of the given connection factory
1:5f5ccc0:      */
1:5f5ccc0:     public ActiveMQConnectionFactory copy() {
1:5f5ccc0:         try {
1:230a86c:             return (ActiveMQConnectionFactory)super.clone();
1:230a86c:         } catch (CloneNotSupportedException e) {
1:5f5ccc0:             throw new RuntimeException("This should never happen: " + e, e);
1:d29ca2a:         }
1:d29ca2a:     }
1:90e21b4: 
1:221a751:     /*boolean*
1:d29ca2a:      * @param brokerURL
1:d29ca2a:      * @return
1:d29ca2a:      * @throws URISyntaxException
1:d29ca2a:      */
1:d29ca2a:     private static URI createURI(String brokerURL) {
1:d29ca2a:         try {
1:d29ca2a:             return new URI(brokerURL);
1:230a86c:         } catch (URISyntaxException e) {
1:230a86c:             throw (IllegalArgumentException)new IllegalArgumentException("Invalid broker URI: " + brokerURL).initCause(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the Connection.
1:d29ca2a:      */
1:77fe814:     @Override
1:d29ca2a:     public Connection createConnection() throws JMSException {
1:cedc2fb:         return createActiveMQConnection();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the Connection.
1:d29ca2a:      */
1:77fe814:     @Override
1:d29ca2a:     public Connection createConnection(String userName, String password) throws JMSException {
4:d29ca2a:         return createActiveMQConnection(userName, password);
1:d29ca2a:     }
1:4f945cf: 
1:7653774:     /**
1:d29ca2a:      * @return Returns the QueueConnection.
1:d29ca2a:      * @throws JMSException
1:7653774:      */
1:77fe814:     @Override
1:d29ca2a:     public QueueConnection createQueueConnection() throws JMSException {
1:6da702b:         return createActiveMQConnection().enforceQueueOnlyConnection();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the QueueConnection.
1:d29ca2a:      */
1:77fe814:     @Override
1:d29ca2a:     public QueueConnection createQueueConnection(String userName, String password) throws JMSException {
1:6da702b:         return createActiveMQConnection(userName, password).enforceQueueOnlyConnection();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the TopicConnection.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:77fe814:     @Override
1:d29ca2a:     public TopicConnection createTopicConnection() throws JMSException {
1:cedc2fb:         return createActiveMQConnection();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the TopicConnection.
1:d29ca2a:      */
1:77fe814:     @Override
1:d29ca2a:     public TopicConnection createTopicConnection(String userName, String password) throws JMSException {
1:d29ca2a:         return createActiveMQConnection(userName, password);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:61b2f6b:      * @return the StatsImpl associated with this ConnectionFactory.
1:d29ca2a:      */
1:77fe814:     @Override
1:d29ca2a:     public StatsImpl getStats() {
1:7653774:         return this.factoryStats;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // /////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // Implementation methods.
1:d29ca2a:     //
1:d29ca2a:     // /////////////////////////////////////////////
1:d29ca2a: 
1:cedc2fb:     protected ActiveMQConnection createActiveMQConnection() throws JMSException {
1:d29ca2a:         return createActiveMQConnection(userName, password);
1:d29ca2a:     }
1:230a86c: 
1:4f945cf:     /**
1:230a86c:      * Creates a Transport based on this object's connection settings. Separated
1:230a86c:      * from createActiveMQConnection to allow for subclasses to override.
1:fa40250:      *
1:4f945cf:      * @return The newly created Transport.
1:4f945cf:      * @throws JMSException If unable to create trasnport.
1:4f945cf:      */
1:4f945cf:     protected Transport createTransport() throws JMSException {
1:4f945cf:         try {
1:04ee70a:             URI connectBrokerUL = brokerURL;
1:04ee70a:             String scheme = brokerURL.getScheme();
1:04ee70a:             if (scheme == null) {
1:04ee70a:                 throw new IOException("Transport not scheme specified: [" + brokerURL + "]");
1:04ee70a:             }
1:04ee70a:             if (scheme.equals("auto")) {
1:04ee70a:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto", "tcp"));
1:04ee70a:             } else if (scheme.equals("auto+ssl")) {
1:04ee70a:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto+ssl", "ssl"));
1:04ee70a:             } else if (scheme.equals("auto+nio")) {
1:04ee70a:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio", "nio"));
1:04ee70a:             } else if (scheme.equals("auto+nio+ssl")) {
1:04ee70a:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio+ssl", "nio+ssl"));
1:04ee70a:             }
1:04ee70a: 
1:04ee70a:             return TransportFactory.connect(connectBrokerUL);
1:4f945cf:         } catch (Exception e) {
1:4f945cf:             throw JMSExceptionSupport.create("Could not create Transport. Reason: " + e, e);
1:4f945cf:         }
1:4f945cf:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the Connection.
1:d29ca2a:      */
1:cedc2fb:     protected ActiveMQConnection createActiveMQConnection(String userName, String password) throws JMSException {
1:d29ca2a:         if (brokerURL == null) {
1:d29ca2a:             throw new ConfigurationException("brokerURL not set.");
1:d29ca2a:         }
1:230a86c:         ActiveMQConnection connection = null;
1:d29ca2a:         try {
1:230a86c:             Transport transport = createTransport();
1:230a86c:             connection = createActiveMQConnection(transport, factoryStats);
1:230a86c: 
1:90e21b4:             connection.setUserName(userName);
1:90e21b4:             connection.setPassword(password);
1:d29ca2a: 
1:677c22b:             configureConnection(connection);
1:d29ca2a: 
1:90e21b4:             transport.start();
1:d29ca2a: 
1:ecf89a6:             if (clientID != null) {
1:d71bc42:                 connection.setDefaultClientID(clientID);
1:ecf89a6:             }
1:d29ca2a: 
1:d29ca2a:             return connection;
1:230a86c:         } catch (JMSException e) {
1:230a86c:             // Clean up!
1:230a86c:             try {
1:230a86c:                 connection.close();
1:230a86c:             } catch (Throwable ignore) {
1:230a86c:             }
1:d29ca2a:             throw e;
1:230a86c:         } catch (Exception e) {
1:230a86c:             // Clean up!
1:230a86c:             try {
1:230a86c:                 connection.close();
1:230a86c:             } catch (Throwable ignore) {
1:230a86c:             }
1:230a86c:             throw JMSExceptionSupport.create("Could not connect to broker URL: " + brokerURL + ". Reason: " + e, e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:cedc2fb:     protected ActiveMQConnection createActiveMQConnection(Transport transport, JMSStatsImpl stats) throws Exception {
1:b9045db:         ActiveMQConnection connection = new ActiveMQConnection(transport, getClientIdGenerator(),
1:b9045db:                 getConnectionIdGenerator(), stats);
1:cedc2fb:         return connection;
1:d29ca2a:     }
1:d29ca2a: 
1:8b9e755:     protected void configureConnection(ActiveMQConnection connection) throws JMSException {
1:d29ca2a:         connection.setPrefetchPolicy(getPrefetchPolicy());
1:d29ca2a:         connection.setDisableTimeStampsByDefault(isDisableTimeStampsByDefault());
1:d29ca2a:         connection.setOptimizedMessageDispatch(isOptimizedMessageDispatch());
1:d29ca2a:         connection.setCopyMessageOnSend(isCopyMessageOnSend());
1:d29ca2a:         connection.setUseCompression(isUseCompression());
1:d29ca2a:         connection.setObjectMessageSerializationDefered(isObjectMessageSerializationDefered());
1:677c22b:         connection.setDispatchAsync(isDispatchAsync());
1:d29ca2a:         connection.setUseAsyncSend(isUseAsyncSend());
1:489f5aa:         connection.setAlwaysSyncSend(isAlwaysSyncSend());
1:d964145:         connection.setAlwaysSessionAsync(isAlwaysSessionAsync());
1:d964145:         connection.setOptimizeAcknowledge(isOptimizeAcknowledge());
1:44488a5:         connection.setOptimizeAcknowledgeTimeOut(getOptimizeAcknowledgeTimeOut());
1:3d5a758:         connection.setOptimizedAckScheduledAckInterval(getOptimizedAckScheduledAckInterval());
1:d29ca2a:         connection.setUseRetroactiveConsumer(isUseRetroactiveConsumer());
1:932ddd2:         connection.setExclusiveConsumer(isExclusiveConsumer());
1:a3836b5:         connection.setRedeliveryPolicyMap(getRedeliveryPolicyMap());
1:677c22b:         connection.setTransformer(getTransformer());
1:677c22b:         connection.setBlobTransferPolicy(getBlobTransferPolicy().copy());
1:0b769ee:         connection.setWatchTopicAdvisories(isWatchTopicAdvisories());
1:0b769ee:         connection.setProducerWindowSize(getProducerWindowSize());
1:677c22b:         connection.setWarnAboutUnstartedConnectionTimeout(getWarnAboutUnstartedConnectionTimeout());
1:114a923:         connection.setSendTimeout(getSendTimeout());
1:f937966:         connection.setCloseTimeout(getCloseTimeout());
1:d8b5d5c:         connection.setSendAcksAsync(isSendAcksAsync());
1:2a58f4c:         connection.setAuditDepth(getAuditDepth());
1:2a58f4c:         connection.setAuditMaximumProducerNumber(getAuditMaximumProducerNumber());
1:c808beb:         connection.setUseDedicatedTaskRunner(isUseDedicatedTaskRunner());
1:b836af8:         connection.setConsumerFailoverRedeliveryWaitPeriod(getConsumerFailoverRedeliveryWaitPeriod());
1:794e62f:         connection.setCheckForDuplicates(isCheckForDuplicates());
1:c14dc3a:         connection.setMessagePrioritySupported(isMessagePrioritySupported());
1:2030097:         connection.setTransactedIndividualAck(isTransactedIndividualAck());
1:0b6bf7e:         connection.setNonBlockingRedelivery(isNonBlockingRedelivery());
1:c33231b:         connection.setMaxThreadPoolSize(getMaxThreadPoolSize());
1:c33231b:         connection.setSessionTaskRunner(getSessionTaskRunner());
1:e3fcf71:         connection.setRejectedTaskHandler(getRejectedTaskHandler());
1:fefb228:         connection.setNestedMapAndListEnabled(isNestedMapAndListEnabled());
1:221a751:         connection.setRmIdFromConnectionId(isRmIdFromConnectionId());
1:642cc43:         connection.setConsumerExpiryCheckEnabled(isConsumerExpiryCheckEnabled());
1:94446e5:         connection.setTrustedPackages(getTrustedPackages());
1:94446e5:         connection.setTrustAllPackages(isTrustAllPackages());
1:f43c090:         connection.setConnectResponseTimeout(getConnectResponseTimeout());
1:d483226:         if (transportListener != null) {
1:d483226:             connection.addTransportListener(transportListener);
1:d29ca2a:         }
1:8b9e755:         if (exceptionListener != null) {
1:fa40250:             connection.setExceptionListener(exceptionListener);
1:d29ca2a:         }
1:f82dc25:         if (clientInternalExceptionListener != null) {
1:f82dc25:             connection.setClientInternalExceptionListener(clientInternalExceptionListener);
1:d29ca2a:         }
1:d29ca2a:     }
1:90e21b4: 
1:d29ca2a:     // /////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // Property Accessors
1:d29ca2a:     //
1:d29ca2a:     // /////////////////////////////////////////////
1:d29ca2a: 
1:f43c090: 	public String getBrokerURL() {
1:230a86c:         return brokerURL == null ? null : brokerURL.toString();
1:d29ca2a:     }
1:230a86c: 
1:d964145:     /**
1:4b08ea5:      * Sets the <a
1:3013c20:      * href="http://activemq.apache.org/configuring-transports.html">connection
1:4b08ea5:      * URL</a> used to connect to the ActiveMQ broker.
1:4b08ea5:      */
1:d29ca2a:     public void setBrokerURL(String brokerURL) {
1:d29ca2a:         this.brokerURL = createURI(brokerURL);
1:d29ca2a: 
1:230a86c:         // Use all the properties prefixed with 'jms.' to set the connection
1:230a86c:         // factory
1:d29ca2a:         // options.
1:230a86c:         if (this.brokerURL.getQuery() != null) {
1:d29ca2a:             // It might be a standard URI or...
1:d29ca2a:             try {
1:d29ca2a: 
1:fa40250:                 Map<String,String> map = URISupport.parseQuery(this.brokerURL.getQuery());
1:fa40250:                 Map<String,Object> jmsOptionsMap = IntrospectionSupport.extractProperties(map, "jms.");
1:fa40250:                 if (buildFromMap(jmsOptionsMap)) {
1:fa40250:                     if (!jmsOptionsMap.isEmpty()) {
1:fa40250:                         String msg = "There are " + jmsOptionsMap.size()
1:fa40250:                             + " jms options that couldn't be set on the ConnectionFactory."
1:fa40250:                             + " Check the options are spelled correctly."
1:fa40250:                             + " Unknown parameters=[" + jmsOptionsMap + "]."
1:fa40250:                             + " This connection factory cannot be started.";
1:fa40250:                         throw new IllegalArgumentException(msg);
1:fa40250:                     }
1:fa40250: 
1:d29ca2a:                     this.brokerURL = URISupport.createRemainingURI(this.brokerURL, map);
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:             } catch (URISyntaxException e) {
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:         } else {
1:d29ca2a: 
1:d29ca2a:             // It might be a composite URI.
1:d29ca2a:             try {
1:d29ca2a:                 CompositeData data = URISupport.parseComposite(this.brokerURL);
1:fa40250:                 Map<String,Object> jmsOptionsMap = IntrospectionSupport.extractProperties(data.getParameters(), "jms.");
1:fa40250:                 if (buildFromMap(jmsOptionsMap)) {
1:fa40250:                     if (!jmsOptionsMap.isEmpty()) {
1:fa40250:                         String msg = "There are " + jmsOptionsMap.size()
1:fa40250:                             + " jms options that couldn't be set on the ConnectionFactory."
1:fa40250:                             + " Check the options are spelled correctly."
1:fa40250:                             + " Unknown parameters=[" + jmsOptionsMap + "]."
1:fa40250:                             + " This connection factory cannot be started.";
1:fa40250:                         throw new IllegalArgumentException(msg);
1:fa40250:                     }
1:fa40250: 
1:d29ca2a:                     this.brokerURL = data.toURI();
1:d29ca2a:                 }
1:d29ca2a:             } catch (URISyntaxException e) {
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public String getClientID() {
1:d29ca2a:         return clientID;
1:d29ca2a:     }
1:d29ca2a: 
1:5fe0a4c:     /**
1:230a86c:      * Sets the JMS clientID to use for the created connection. Note that this
1:230a86c:      * can only be used by one connection at once so generally its a better idea
1:4b08ea5:      * to set the clientID on a Connection
1:4b08ea5:      */
1:d29ca2a:     public void setClientID(String clientID) {
1:d29ca2a:         this.clientID = clientID;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isCopyMessageOnSend() {
1:d29ca2a:         return copyMessageOnSend;
1:d29ca2a:     }
1:d29ca2a: 
1:3d862f0:     /**
1:4b08ea5:      * Should a JMS message be copied to a new JMS Message object as part of the
1:4b08ea5:      * send() method in JMS. This is enabled by default to be compliant with the
1:4b08ea5:      * JMS specification. You can disable it if you do not mutate JMS messages
1:4b08ea5:      * after they are sent for a performance boost
1:4b08ea5:      */
1:d29ca2a:     public void setCopyMessageOnSend(boolean copyMessageOnSend) {
1:d29ca2a:         this.copyMessageOnSend = copyMessageOnSend;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isDisableTimeStampsByDefault() {
1:d29ca2a:         return disableTimeStampsByDefault;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * Sets whether or not timestamps on messages should be disabled or not. If
1:4b08ea5:      * you disable them it adds a small performance boost.
1:4b08ea5:      */
1:d29ca2a:     public void setDisableTimeStampsByDefault(boolean disableTimeStampsByDefault) {
1:d29ca2a:         this.disableTimeStampsByDefault = disableTimeStampsByDefault;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isOptimizedMessageDispatch() {
1:d29ca2a:         return optimizedMessageDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * If this flag is set then an larger prefetch limit is used - only
1:4b08ea5:      * applicable for durable topic subscribers.
1:4b08ea5:      */
1:d29ca2a:     public void setOptimizedMessageDispatch(boolean optimizedMessageDispatch) {
1:d29ca2a:         this.optimizedMessageDispatch = optimizedMessageDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public String getPassword() {
1:d29ca2a:         return password;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * Sets the JMS password used for connections created from this factory
1:4b08ea5:      */
1:d29ca2a:     public void setPassword(String password) {
1:d29ca2a:         this.password = password;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public ActiveMQPrefetchPolicy getPrefetchPolicy() {
1:d29ca2a:         return prefetchPolicy;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:480433b:      * Sets the <a
1:3013c20:      * href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
1:480433b:      * policy</a> for consumers created by this connection.
1:480433b:      */
1:d29ca2a:     public void setPrefetchPolicy(ActiveMQPrefetchPolicy prefetchPolicy) {
1:d29ca2a:         this.prefetchPolicy = prefetchPolicy;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isUseAsyncSend() {
1:d29ca2a:         return useAsyncSend;
1:d29ca2a:     }
1:d29ca2a: 
1:05a8cba:     public BlobTransferPolicy getBlobTransferPolicy() {
1:05a8cba:         return blobTransferPolicy;
1:2a58f4c:     }
1:d29ca2a: 
1:05a8cba:     /**
1:230a86c:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large
1:230a86c:      * OBjects) are transferred from producers to brokers to consumers
1:05a8cba:      */
1:05a8cba:     public void setBlobTransferPolicy(BlobTransferPolicy blobTransferPolicy) {
1:05a8cba:         this.blobTransferPolicy = blobTransferPolicy;
1:f82dc25:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * Forces the use of <a
1:230a86c:      * href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
1:230a86c:      * adds a massive performance boost; but means that the send() method will
1:230a86c:      * return immediately whether the message has been sent or not which could
1:230a86c:      * lead to message loss.
1:4b08ea5:      */
1:d29ca2a:     public void setUseAsyncSend(boolean useAsyncSend) {
1:d29ca2a:         this.useAsyncSend = useAsyncSend;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public synchronized boolean isWatchTopicAdvisories() {
1:230a86c:         return watchTopicAdvisories;
1:230a86c:     }
1:230a86c: 
1:230a86c:     public synchronized void setWatchTopicAdvisories(boolean watchTopicAdvisories) {
1:230a86c:         this.watchTopicAdvisories = watchTopicAdvisories;
1:230a86c:     }
1:230a86c: 
1:4e2acd4:     /**
1:4e2acd4:      * @return true if always sync send messages
1:4e2acd4:      */
1:230a86c:     public boolean isAlwaysSyncSend() {
1:4e2acd4:         return this.alwaysSyncSend;
1:8b9e755:     }
1:d29ca2a: 
1:4e2acd4:     /**
1:4e2acd4:      * Set true if always require messages to be sync sent
1:fa40250:      *
1:4e2acd4:      * @param alwaysSyncSend
1:4e2acd4:      */
1:230a86c:     public void setAlwaysSyncSend(boolean alwaysSyncSend) {
1:230a86c:         this.alwaysSyncSend = alwaysSyncSend;
1:794e62f:     }
1:d29ca2a: 
1:d29ca2a:     public String getUserName() {
1:d29ca2a:         return userName;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * Sets the JMS userName used by connections created by this factory
1:4b08ea5:      */
1:d29ca2a:     public void setUserName(String userName) {
1:d29ca2a:         this.userName = userName;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isUseRetroactiveConsumer() {
1:d29ca2a:         return useRetroactiveConsumer;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sets whether or not retroactive consumers are enabled. Retroactive
1:230a86c:      * consumers allow non-durable topic subscribers to receive old messages
1:230a86c:      * that were published before the non-durable subscriber started.
1:d29ca2a:      */
1:d29ca2a:     public void setUseRetroactiveConsumer(boolean useRetroactiveConsumer) {
1:d29ca2a:         this.useRetroactiveConsumer = useRetroactiveConsumer;
1:d29ca2a:     }
1:d29ca2a: 
1:3d862f0:     public boolean isExclusiveConsumer() {
1:3d862f0:         return exclusiveConsumer;
1:794e62f:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Enables or disables whether or not queue consumers should be exclusive or
1:230a86c:      * not for example to preserve ordering when not using <a
1:230a86c:      * href="http://activemq.apache.org/message-groups.html">Message Groups</a>
1:fa40250:      *
1:3d862f0:      * @param exclusiveConsumer
1:d29ca2a:      */
1:3d862f0:     public void setExclusiveConsumer(boolean exclusiveConsumer) {
1:3d862f0:         this.exclusiveConsumer = exclusiveConsumer;
1:4e2acd4:     }
1:d29ca2a: 
1:ffb9d2a:     public RedeliveryPolicy getRedeliveryPolicy() {
1:a3836b5:         return redeliveryPolicyMap.getDefaultEntry();
1:4e2acd4:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:a3836b5:      * Sets the global default redelivery policy to be used when a message is delivered
1:230a86c:      * but the session is rolled back
1:3d862f0:      */
1:ffb9d2a:     public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
1:a3836b5:         this.redeliveryPolicyMap.setDefaultEntry(redeliveryPolicy);
1:a3836b5:     }
1:a3836b5: 
1:a3836b5:     public RedeliveryPolicyMap getRedeliveryPolicyMap() {
1:a3836b5:         return this.redeliveryPolicyMap;
1:a3836b5:     }
1:a3836b5: 
1:a3836b5:     /**
1:a3836b5:      * Sets the global redelivery policy mapping to be used when a message is delivered
1:a3836b5:      * but the session is rolled back
1:a3836b5:      */
1:a3836b5:     public void setRedeliveryPolicyMap(RedeliveryPolicyMap redeliveryPolicyMap) {
1:a3836b5:         this.redeliveryPolicyMap = redeliveryPolicyMap;
1:d483226:     }
1:d29ca2a: 
1:86faaef:     public MessageTransformer getTransformer() {
1:86faaef:         return transformer;
1:677c22b:     }
1:fa40250: 
1:114a923:     /**
1:b21dc69:      * @return the sendTimeout (in milliseconds)
1:114a923:      */
1:114a923:     public int getSendTimeout() {
1:114a923:         return sendTimeout;
1:114a923:     }
1:d29ca2a: 
1:114a923:     /**
1:b21dc69:      * @param sendTimeout the sendTimeout to set (in milliseconds)
1:114a923:      */
1:114a923:     public void setSendTimeout(int sendTimeout) {
1:114a923:         this.sendTimeout = sendTimeout;
1:114a923:     }
1:fa40250: 
1:d8b5d5c:     /**
1:d8b5d5c:      * @return the sendAcksAsync
1:d8b5d5c:      */
1:d8b5d5c:     public boolean isSendAcksAsync() {
1:d8b5d5c:         return sendAcksAsync;
1:d8b5d5c:     }
1:d29ca2a: 
1:d8b5d5c:     /**
1:d8b5d5c:      * @param sendAcksAsync the sendAcksAsync to set
1:d8b5d5c:      */
1:d8b5d5c:     public void setSendAcksAsync(boolean sendAcksAsync) {
1:d8b5d5c:         this.sendAcksAsync = sendAcksAsync;
1:d8b5d5c:     }
1:fa40250: 
1:c14dc3a:     /**
1:c14dc3a:      * @return the messagePrioritySupported
1:c14dc3a:      */
1:c14dc3a:     public boolean isMessagePrioritySupported() {
1:c14dc3a:         return this.messagePrioritySupported;
1:c14dc3a:     }
1:d29ca2a: 
1:c14dc3a:     /**
1:c14dc3a:      * @param messagePrioritySupported the messagePrioritySupported to set
1:c14dc3a:      */
1:c14dc3a:     public void setMessagePrioritySupported(boolean messagePrioritySupported) {
1:c14dc3a:         this.messagePrioritySupported = messagePrioritySupported;
1:c14dc3a:     }
1:d29ca2a: 
1:d29ca2a: 
1:86faaef:     /**
1:230a86c:      * Sets the transformer used to transform messages before they are sent on
1:230a86c:      * to the JMS bus or when they are received from the bus but before they are
1:230a86c:      * delivered to the JMS client
1:86faaef:      */
1:86faaef:     public void setTransformer(MessageTransformer transformer) {
1:86faaef:         this.transformer = transformer;
1:3d862f0:     }
1:d29ca2a: 
1:fa40250:     @SuppressWarnings({ "unchecked", "rawtypes" })
1:794e62f:     @Override
1:b9a4dee:     public void buildFromProperties(Properties properties) {
1:230a86c: 
1:d29ca2a:         if (properties == null) {
1:d29ca2a:             properties = new Properties();
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         String temp = properties.getProperty(Context.PROVIDER_URL);
1:d29ca2a:         if (temp == null || temp.length() == 0) {
1:d29ca2a:             temp = properties.getProperty("brokerURL");
1:d29ca2a:         }
1:d29ca2a:         if (temp != null && temp.length() > 0) {
1:d29ca2a:             setBrokerURL(temp);
1:7f0e135:         }
1:230a86c: 
1:933eb2f:         Map<String, Object> p = new HashMap(properties);
1:933eb2f:         buildFromMap(p);
1:d29ca2a:     }
1:230a86c: 
1:933eb2f:     public boolean buildFromMap(Map<String, Object> properties) {
1:230a86c:         boolean rc = false;
1:230a86c: 
1:230a86c:         ActiveMQPrefetchPolicy p = new ActiveMQPrefetchPolicy();
1:230a86c:         if (IntrospectionSupport.setProperties(p, properties, "prefetchPolicy.")) {
1:230a86c:             setPrefetchPolicy(p);
1:230a86c:             rc = true;
1:7f0e135:         }
1:7f0e135: 
1:7f0e135:         RedeliveryPolicy rp = new RedeliveryPolicy();
1:230a86c:         if (IntrospectionSupport.setProperties(rp, properties, "redeliveryPolicy.")) {
1:7f0e135:             setRedeliveryPolicy(rp);
1:7f0e135:             rc = true;
1:7f0e135:         }
1:7f0e135: 
1:52c22cc:         BlobTransferPolicy blobTransferPolicy = new BlobTransferPolicy();
1:230a86c:         if (IntrospectionSupport.setProperties(blobTransferPolicy, properties, "blobTransferPolicy.")) {
1:52c22cc:             setBlobTransferPolicy(blobTransferPolicy);
1:7f0e135:             rc = true;
1:d29ca2a:         }
1:d29ca2a: 
1:7f0e135:         rc |= IntrospectionSupport.setProperties(this, properties);
1:7f0e135: 
1:7f0e135:         return rc;
1:d29ca2a:     }
1:d29ca2a: 
1:794e62f:     @Override
1:b9a4dee:     public void populateProperties(Properties props) {
1:480433b:         props.setProperty("dispatchAsync", Boolean.toString(isDispatchAsync()));
1:d29ca2a: 
1:0f59ecc:         if (getBrokerURL() != null) {
1:0f59ecc:             props.setProperty(Context.PROVIDER_URL, getBrokerURL());
1:0f59ecc:             props.setProperty("brokerURL", getBrokerURL());
1:d29ca2a:         }
1:d29ca2a: 
1:0f59ecc:         if (getClientID() != null) {
1:b9a4dee:             props.setProperty("clientID", getClientID());
1:3d862f0:         }
1:d29ca2a: 
1:7f0e135:         IntrospectionSupport.getProperties(getPrefetchPolicy(), props, "prefetchPolicy.");
1:7f0e135:         IntrospectionSupport.getProperties(getRedeliveryPolicy(), props, "redeliveryPolicy.");
1:3753442:         IntrospectionSupport.getProperties(getBlobTransferPolicy(), props, "blobTransferPolicy.");
1:7f0e135: 
1:2ddd372:         props.setProperty("copyMessageOnSend", Boolean.toString(isCopyMessageOnSend()));
1:2ddd372:         props.setProperty("disableTimeStampsByDefault", Boolean.toString(isDisableTimeStampsByDefault()));
1:2ddd372:         props.setProperty("objectMessageSerializationDefered", Boolean.toString(isObjectMessageSerializationDefered()));
1:2ddd372:         props.setProperty("optimizedMessageDispatch", Boolean.toString(isOptimizedMessageDispatch()));
1:d29ca2a: 
1:0f59ecc:         if (getPassword() != null) {
1:0f59ecc:             props.setProperty("password", getPassword());
1:9d53c53:         }
1:c33231b: 
1:2ddd372:         props.setProperty("useAsyncSend", Boolean.toString(isUseAsyncSend()));
1:2ddd372:         props.setProperty("useCompression", Boolean.toString(isUseCompression()));
1:2ddd372:         props.setProperty("useRetroactiveConsumer", Boolean.toString(isUseRetroactiveConsumer()));
1:bd7d59c:         props.setProperty("watchTopicAdvisories", Boolean.toString(isWatchTopicAdvisories()));
1:230a86c: 
1:0f59ecc:         if (getUserName() != null) {
1:0f59ecc:             props.setProperty("userName", getUserName());
1:9d53c53:         }
1:230a86c: 
1:5fe0a4c:         props.setProperty("closeTimeout", Integer.toString(getCloseTimeout()));
1:d964145:         props.setProperty("alwaysSessionAsync", Boolean.toString(isAlwaysSessionAsync()));
1:d964145:         props.setProperty("optimizeAcknowledge", Boolean.toString(isOptimizeAcknowledge()));
1:230a86c:         props.setProperty("statsEnabled", Boolean.toString(isStatsEnabled()));
1:230a86c:         props.setProperty("alwaysSyncSend", Boolean.toString(isAlwaysSyncSend()));
1:a3e3821:         props.setProperty("producerWindowSize", Integer.toString(getProducerWindowSize()));
1:114a923:         props.setProperty("sendTimeout", Integer.toString(getSendTimeout()));
1:f43c090:         props.setProperty("connectResponseTimeout", Integer.toString(getConnectResponseTimeout()));
1:d8b5d5c:         props.setProperty("sendAcksAsync",Boolean.toString(isSendAcksAsync()));
1:2a58f4c:         props.setProperty("auditDepth", Integer.toString(getAuditDepth()));
1:2a58f4c:         props.setProperty("auditMaximumProducerNumber", Integer.toString(getAuditMaximumProducerNumber()));
1:794e62f:         props.setProperty("checkForDuplicates", Boolean.toString(isCheckForDuplicates()));
1:c14dc3a:         props.setProperty("messagePrioritySupported", Boolean.toString(isMessagePrioritySupported()));
1:2030097:         props.setProperty("transactedIndividualAck", Boolean.toString(isTransactedIndividualAck()));
1:0b6bf7e:         props.setProperty("nonBlockingRedelivery", Boolean.toString(isNonBlockingRedelivery()));
1:9cda426:         props.setProperty("maxThreadPoolSize", Integer.toString(getMaxThreadPoolSize()));
1:fefb228:         props.setProperty("nestedMapAndListEnabled", Boolean.toString(isNestedMapAndListEnabled()));
1:77fe814:         props.setProperty("consumerFailoverRedeliveryWaitPeriod", Long.toString(getConsumerFailoverRedeliveryWaitPeriod()));
1:221a751:         props.setProperty("rmIdFromConnectionId", Boolean.toString(isRmIdFromConnectionId()));
1:642cc43:         props.setProperty("consumerExpiryCheckEnabled", Boolean.toString(isConsumerExpiryCheckEnabled()));
1:52c22cc:     }
1:2030097: 
1:d29ca2a:     public boolean isUseCompression() {
1:d29ca2a:         return useCompression;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * Enables the use of compression of the message bodies
1:4b08ea5:      */
1:d29ca2a:     public void setUseCompression(boolean useCompression) {
1:d29ca2a:         this.useCompression = useCompression;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isObjectMessageSerializationDefered() {
1:d29ca2a:         return objectMessageSerializationDefered;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * When an object is set on an ObjectMessage, the JMS spec requires the
1:4b08ea5:      * object to be serialized by that set method. Enabling this flag causes the
1:4b08ea5:      * object to not get serialized. The object may subsequently get serialized
1:4b08ea5:      * if the message needs to be sent over a socket or stored to disk.
1:4b08ea5:      */
1:d29ca2a:     public void setObjectMessageSerializationDefered(boolean objectMessageSerializationDefered) {
1:d29ca2a:         this.objectMessageSerializationDefered = objectMessageSerializationDefered;
1:d29ca2a:     }
1:d29ca2a: 
1:480433b:     public boolean isDispatchAsync() {
1:480433b:         return dispatchAsync;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:480433b:      * Enables or disables the default setting of whether or not consumers have
1:480433b:      * their messages <a
1:3013c20:      * href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
1:230a86c:      * synchronously or asynchronously by the broker</a>. For non-durable
1:230a86c:      * topics for example we typically dispatch synchronously by default to
1:230a86c:      * minimize context switches which boost performance. However sometimes its
1:230a86c:      * better to go slower to ensure that a single blocked consumer socket does
1:230a86c:      * not block delivery to other consumers.
1:fa40250:      *
1:230a86c:      * @param asyncDispatch If true then consumers created on this connection
1:230a86c:      *                will default to having their messages dispatched
1:09ff99f:      *                asynchronously. The default value is true.
1:480433b:      */
1:480433b:     public void setDispatchAsync(boolean asyncDispatch) {
1:480433b:         this.dispatchAsync = asyncDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:480433b:     /**
1:5fe0a4c:      * @return Returns the closeTimeout.
1:5fe0a4c:      */
1:230a86c:     public int getCloseTimeout() {
1:5fe0a4c:         return closeTimeout;
1:d29ca2a:     }
1:f82dc25: 
1:5fe0a4c:     /**
1:4b08ea5:      * Sets the timeout before a close is considered complete. Normally a
1:4b08ea5:      * close() on a connection waits for confirmation from the broker; this
1:4b08ea5:      * allows that operation to timeout to save the client hanging if there is
1:4b08ea5:      * no broker
1:5fe0a4c:      */
1:230a86c:     public void setCloseTimeout(int closeTimeout) {
1:230a86c:         this.closeTimeout = closeTimeout;
1:5fe0a4c:     }
1:b836af8: 
1:480433b:     /**
1:d964145:      * @return Returns the alwaysSessionAsync.
1:d964145:      */
1:230a86c:     public boolean isAlwaysSessionAsync() {
1:d964145:         return alwaysSessionAsync;
1:d964145:     }
1:8b9e755: 
1:d964145:     /**
1:de7617e:      * If this flag is not set then a separate thread is not used for dispatching messages for each Session in
1:de7617e:      * the Connection. However, a separate thread is always used if there is more than one session, or the session
1:de7617e:      * isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
1:de7617e:      * happens asynchronously.
1:d964145:      */
1:230a86c:     public void setAlwaysSessionAsync(boolean alwaysSessionAsync) {
1:230a86c:         this.alwaysSessionAsync = alwaysSessionAsync;
1:d964145:     }
1:8b9e755: 
1:d964145:     /**
1:d964145:      * @return Returns the optimizeAcknowledge.
1:d964145:      */
1:230a86c:     public boolean isOptimizeAcknowledge() {
1:d964145:         return optimizeAcknowledge;
1:d964145:     }
1:8b9e755: 
1:d964145:     /**
1:d964145:      * @param optimizeAcknowledge The optimizeAcknowledge to set.
1:d964145:      */
1:230a86c:     public void setOptimizeAcknowledge(boolean optimizeAcknowledge) {
1:230a86c:         this.optimizeAcknowledge = optimizeAcknowledge;
1:d964145:     }
1:230a86c: 
1:975fc55:     /**
1:975fc55:      * The max time in milliseconds between optimized ack batches
1:975fc55:      * @param optimizeAcknowledgeTimeOut
1:975fc55:      */
1:44488a5:     public void setOptimizeAcknowledgeTimeOut(long optimizeAcknowledgeTimeOut) {
1:975fc55:         this.optimizeAcknowledgeTimeOut =  optimizeAcknowledgeTimeOut;
1:975fc55:     }
1:975fc55: 
1:975fc55:     public long getOptimizeAcknowledgeTimeOut() {
1:975fc55:         return optimizeAcknowledgeTimeOut;
1:975fc55:     }
1:975fc55: 
1:4b08ea5:     public boolean isNestedMapAndListEnabled() {
1:230a86c:         return nestedMapAndListEnabled;
1:5fe0a4c:     }
1:c14dc3a: 
1:4b08ea5:     /**
1:4b08ea5:      * Enables/disables whether or not Message properties and MapMessage entries
1:4b08ea5:      * support <a
1:3013c20:      * href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
1:4b08ea5:      * Structures</a> of Map and List objects
1:4b08ea5:      */
1:4b08ea5:     public void setNestedMapAndListEnabled(boolean structuredMapsEnabled) {
1:4b08ea5:         this.nestedMapAndListEnabled = structuredMapsEnabled;
1:05a8cba:     }
1:c14dc3a: 
1:7339c6e:     public String getClientIDPrefix() {
1:7339c6e:         return clientIDPrefix;
1:05a8cba:     }
1:794e62f: 
1:7339c6e:     /**
1:230a86c:      * Sets the prefix used by autogenerated JMS Client ID values which are used
1:230a86c:      * if the JMS client does not explicitly specify on.
1:fa40250:      *
1:7339c6e:      * @param clientIDPrefix
1:7339c6e:      */
1:7339c6e:     public void setClientIDPrefix(String clientIDPrefix) {
1:7339c6e:         this.clientIDPrefix = clientIDPrefix;
1:86faaef:     }
1:230a86c: 
1:7339c6e:     protected synchronized IdGenerator getClientIdGenerator() {
1:7339c6e:         if (clientIdGenerator == null) {
1:7339c6e:             if (clientIDPrefix != null) {
1:7339c6e:                 clientIdGenerator = new IdGenerator(clientIDPrefix);
1:230a86c:             } else {
1:7339c6e:                 clientIdGenerator = new IdGenerator();
1:86faaef:             }
5:7339c6e:         }
1:7339c6e:         return clientIdGenerator;
1:7339c6e:     }
1:794e62f: 
1:7339c6e:     protected void setClientIdGenerator(IdGenerator clientIdGenerator) {
1:7339c6e:         this.clientIdGenerator = clientIdGenerator;
1:7339c6e:     }
1:d8b5d5c: 
1:526cb5b:     /**
1:b9045db:      * Sets the prefix used by connection id generator
1:b9045db:      * @param connectionIDPrefix
1:b9045db:      */
1:b9045db:     public void setConnectionIDPrefix(String connectionIDPrefix) {
1:b9045db:         this.connectionIDPrefix = connectionIDPrefix;
1:b9045db:     }
1:b9045db: 
1:b9045db:     protected synchronized IdGenerator getConnectionIdGenerator() {
1:b9045db:         if (connectionIdGenerator == null) {
1:b9045db:             if (connectionIDPrefix != null) {
1:b9045db:                 connectionIdGenerator = new IdGenerator(connectionIDPrefix);
1:b9045db:             } else {
1:b9045db:                 connectionIdGenerator = new IdGenerator();
1:b9045db:             }
1:b9045db:         }
1:b9045db:         return connectionIdGenerator;
1:b9045db:     }
1:b9045db: 
1:b9045db:     protected void setConnectionIdGenerator(IdGenerator connectionIdGenerator) {
1:b9045db:         this.connectionIdGenerator = connectionIdGenerator;
1:b9045db:     }
1:b9045db: 
1:b9045db:     /**
1:526cb5b:      * @return the statsEnabled
1:526cb5b:      */
1:230a86c:     public boolean isStatsEnabled() {
1:526cb5b:         return this.factoryStats.isEnabled();
1:526cb5b:     }
1:d8b5d5c: 
1:526cb5b:     /**
1:526cb5b:      * @param statsEnabled the statsEnabled to set
1:526cb5b:      */
1:230a86c:     public void setStatsEnabled(boolean statsEnabled) {
1:526cb5b:         this.factoryStats.setEnabled(statsEnabled);
1:c9bb1c9:     }
1:c9bb1c9: 
1:fc00993:     public synchronized int getProducerWindowSize() {
1:230a86c:         return producerWindowSize;
1:230a86c:     }
1:c9bb1c9: 
1:fc00993:     public synchronized void setProducerWindowSize(int producerWindowSize) {
1:230a86c:         this.producerWindowSize = producerWindowSize;
1:230a86c:     }
1:114a923: 
1:9d53c53:     public long getWarnAboutUnstartedConnectionTimeout() {
1:9d53c53:         return warnAboutUnstartedConnectionTimeout;
1:c9bb1c9:     }
1:114a923: 
1:9d53c53:     /**
1:230a86c:      * Enables the timeout from a connection creation to when a warning is
1:230a86c:      * generated if the connection is not properly started via
1:230a86c:      * {@link Connection#start()} and a message is received by a consumer. It is
1:230a86c:      * a very common gotcha to forget to <a
1:230a86c:      * href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
1:230a86c:      * the connection</a> so this option makes the default case to create a
1:230a86c:      * warning if the user forgets. To disable the warning just set the value to <
1:230a86c:      * 0 (say -1).
1:9d53c53:      */
1:9d53c53:     public void setWarnAboutUnstartedConnectionTimeout(long warnAboutUnstartedConnectionTimeout) {
1:9d53c53:         this.warnAboutUnstartedConnectionTimeout = warnAboutUnstartedConnectionTimeout;
1:526cb5b:     }
1:114a923: 
1:d483226:     public TransportListener getTransportListener() {
1:d483226:         return transportListener;
1:d483226:     }
2:4e2acd4: 
1:d483226:     /**
1:d483226:      * Allows a listener to be configured on the ConnectionFactory so that when this factory is used
1:d483226:      * with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
1:d483226:      * a transport listener.
1:230a86c:      *
1:d483226:      * @param transportListener sets the listener to be registered on all connections
1:d483226:      * created by this factory
1:d483226:      */
1:d483226:     public void setTransportListener(TransportListener transportListener) {
1:d483226:         this.transportListener = transportListener;
1:d483226:     }
1:fa40250: 
1:fa40250: 
1:8b9e755:     public ExceptionListener getExceptionListener() {
1:8b9e755:         return exceptionListener;
1:8b9e755:     }
1:fa40250: 
1:8b9e755:     /**
1:8b9e755:      * Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
1:8b9e755:      * is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
1:8b9e755:      * an exception listener.
1:8b9e755:      * <p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
1:8b9e755:      * on connection (as it will be if more than one connection is subsequently created by this connection factory)
1:8b9e755:      * @param exceptionListener sets the exception listener to be registered on all connections
1:8b9e755:      * created by this factory
1:8b9e755:      */
1:8b9e755:     public void setExceptionListener(ExceptionListener exceptionListener) {
1:fa40250:         this.exceptionListener = exceptionListener;
1:2a58f4c:     }
1:2a58f4c: 
1:fa40250:     public int getAuditDepth() {
1:fa40250:         return auditDepth;
1:fa40250:     }
1:2a58f4c: 
1:fa40250:     public void setAuditDepth(int auditDepth) {
1:fa40250:         this.auditDepth = auditDepth;
1:fa40250:     }
1:2a58f4c: 
1:fa40250:     public int getAuditMaximumProducerNumber() {
1:fa40250:         return auditMaximumProducerNumber;
1:fa40250:     }
1:2a58f4c: 
1:fa40250:     public void setAuditMaximumProducerNumber(int auditMaximumProducerNumber) {
1:fa40250:         this.auditMaximumProducerNumber = auditMaximumProducerNumber;
1:fa40250:     }
1:c808beb: 
1:c808beb:     public void setUseDedicatedTaskRunner(boolean useDedicatedTaskRunner) {
1:c808beb:         this.useDedicatedTaskRunner = useDedicatedTaskRunner;
1:2a58f4c:     }
1:fa40250: 
1:c808beb:     public boolean isUseDedicatedTaskRunner() {
1:c808beb:         return useDedicatedTaskRunner;
1:2a58f4c:     }
1:fa40250: 
1:b836af8:     public void setConsumerFailoverRedeliveryWaitPeriod(long consumerFailoverRedeliveryWaitPeriod) {
1:b836af8:         this.consumerFailoverRedeliveryWaitPeriod = consumerFailoverRedeliveryWaitPeriod;
1:b836af8:     }
1:fa40250: 
1:b836af8:     public long getConsumerFailoverRedeliveryWaitPeriod() {
1:b836af8:         return consumerFailoverRedeliveryWaitPeriod;
1:b836af8:     }
1:f82dc25: 
1:f82dc25:     public ClientInternalExceptionListener getClientInternalExceptionListener() {
1:f82dc25:         return clientInternalExceptionListener;
1:f82dc25:     }
1:fa40250: 
1:f82dc25:     /**
1:f82dc25:      * Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
1:f82dc25:      * is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
1:f82dc25:      * an exception listener.
1:f82dc25:      * <p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
1:f82dc25:      * on connection (as it will be if more than one connection is subsequently created by this connection factory)
1:f82dc25:      * @param clientInternalExceptionListener sets the exception listener to be registered on all connections
1:f82dc25:      * created by this factory
1:f82dc25:      */
1:f82dc25:     public void setClientInternalExceptionListener(
1:f82dc25:             ClientInternalExceptionListener clientInternalExceptionListener) {
1:f82dc25:         this.clientInternalExceptionListener = clientInternalExceptionListener;
1:f82dc25:     }
1:b836af8: 
1:794e62f:     /**
1:794e62f:      * @return the checkForDuplicates
1:794e62f:      */
1:794e62f:     public boolean isCheckForDuplicates() {
1:794e62f:         return this.checkForDuplicates;
1:c808beb:     }
1:c808beb: 
1:794e62f:     /**
1:794e62f:      * @param checkForDuplicates the checkForDuplicates to set
1:794e62f:      */
1:794e62f:     public void setCheckForDuplicates(boolean checkForDuplicates) {
1:794e62f:         this.checkForDuplicates = checkForDuplicates;
1:c808beb:     }
1:2030097: 
1:2030097:     public boolean isTransactedIndividualAck() {
1:2030097:          return transactedIndividualAck;
1:2030097:      }
1:2030097: 
1:2030097:      /**
1:2030097:       * when true, submit individual transacted acks immediately rather than with transaction completion.
1:2030097:       * This allows the acks to represent delivery status which can be persisted on rollback
1:2030097:       * Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true
1:2030097:       */
1:2030097:      public void setTransactedIndividualAck(boolean transactedIndividualAck) {
1:2030097:          this.transactedIndividualAck = transactedIndividualAck;
1:2030097:      }
1:0b6bf7e: 
1:2030097: 
1:0b6bf7e:      public boolean isNonBlockingRedelivery() {
1:0b6bf7e:          return nonBlockingRedelivery;
1:0b6bf7e:      }
1:0b6bf7e: 
1:0b6bf7e:      /**
1:0b6bf7e:       * When true a MessageConsumer will not stop Message delivery before re-delivering Messages
1:0b6bf7e:       * from a rolled back transaction.  This implies that message order will not be preserved and
1:0b6bf7e:       * also will result in the TransactedIndividualAck option to be enabled.
1:0b6bf7e:       */
1:0b6bf7e:      public void setNonBlockingRedelivery(boolean nonBlockingRedelivery) {
1:0b6bf7e:          this.nonBlockingRedelivery = nonBlockingRedelivery;
1:0b6bf7e:      }
1:0b6bf7e: 
1:c33231b:     public int getMaxThreadPoolSize() {
1:c33231b:         return maxThreadPoolSize;
1:c33231b:     }
1:c33231b: 
1:c33231b:     public void setMaxThreadPoolSize(int maxThreadPoolSize) {
1:c33231b:         this.maxThreadPoolSize = maxThreadPoolSize;
1:c33231b:     }
1:c33231b: 
1:c33231b:     public TaskRunnerFactory getSessionTaskRunner() {
1:c33231b:         return sessionTaskRunner;
1:c33231b:     }
1:c33231b: 
1:c33231b:     public void setSessionTaskRunner(TaskRunnerFactory sessionTaskRunner) {
1:c33231b:         this.sessionTaskRunner = sessionTaskRunner;
1:c33231b:     }
1:e3fcf71: 
1:e3fcf71:     public RejectedExecutionHandler getRejectedTaskHandler() {
1:e3fcf71:         return rejectedTaskHandler;
1:e3fcf71:     }
1:e3fcf71: 
1:e3fcf71:     public void setRejectedTaskHandler(RejectedExecutionHandler rejectedTaskHandler) {
1:e3fcf71:         this.rejectedTaskHandler = rejectedTaskHandler;
1:e3fcf71:     }
1:3d5a758: 
1:3d5a758:     /**
1:3d5a758:      * Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
1:3d5a758:      * to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
1:3d5a758:      * will not do any background Message acknowledgment.
1:3d5a758:      *
1:3d5a758:      * @return the scheduledOptimizedAckInterval
1:3d5a758:      */
1:3d5a758:     public long getOptimizedAckScheduledAckInterval() {
1:3d5a758:         return optimizedAckScheduledAckInterval;
1:3d5a758:     }
1:3d5a758: 
1:3d5a758:     /**
1:3d5a758:      * Sets the amount of time between scheduled sends of any outstanding Message Acks for consumers that
1:3d5a758:      * have been configured with optimizeAcknowledge enabled.
1:3d5a758:      *
1:9a8f6e4:      * @param optimizedAckScheduledAckInterval the scheduledOptimizedAckInterval to set
1:3d5a758:      */
1:3d5a758:     public void setOptimizedAckScheduledAckInterval(long optimizedAckScheduledAckInterval) {
1:3d5a758:         this.optimizedAckScheduledAckInterval = optimizedAckScheduledAckInterval;
1:3d5a758:     }
1:221a751: 
1:221a751: 
1:221a751:     public boolean isRmIdFromConnectionId() {
1:221a751:         return rmIdFromConnectionId;
1:221a751:     }
1:221a751: 
1:221a751:     /**
1:221a751:      * uses the connection id as the resource identity for XAResource.isSameRM
1:221a751:      * ensuring join will only occur on a single connection
1:221a751:      */
1:221a751:     public void setRmIdFromConnectionId(boolean rmIdFromConnectionId) {
1:221a751:         this.rmIdFromConnectionId = rmIdFromConnectionId;
1:221a751:     }
1:221a751: 
1:642cc43:     /**
1:642cc43:      * @return true if MessageConsumer instance will check for expired messages before dispatch.
1:642cc43:      */
1:642cc43:     public boolean isConsumerExpiryCheckEnabled() {
1:642cc43:         return consumerExpiryCheckEnabled;
1:642cc43:     }
1:642cc43: 
1:642cc43:     /**
1:642cc43:      * Controls whether message expiration checking is done in each MessageConsumer
1:642cc43:      * prior to dispatching a message.  Disabling this check can lead to consumption
1:642cc43:      * of expired messages.
1:642cc43:      *
1:642cc43:      * @param consumerExpiryCheckEnabled
1:642cc43:      *        controls whether expiration checking is done prior to dispatch.
1:642cc43:      */
1:642cc43:     public void setConsumerExpiryCheckEnabled(boolean consumerExpiryCheckEnabled) {
1:642cc43:         this.consumerExpiryCheckEnabled = consumerExpiryCheckEnabled;
1:642cc43:     }
1:94446e5: 
1:94446e5:     public List<String> getTrustedPackages() {
1:94446e5:         return trustedPackages;
1:94446e5:     }
1:94446e5: 
1:94446e5:     public void setTrustedPackages(List<String> trustedPackages) {
1:94446e5:         this.trustedPackages = trustedPackages;
1:94446e5:     }
1:94446e5: 
1:94446e5:     public boolean isTrustAllPackages() {
1:94446e5:         return trustAllPackages;
1:94446e5:     }
1:94446e5: 
1:94446e5:     public void setTrustAllPackages(boolean trustAllPackages) {
1:94446e5:         this.trustAllPackages = trustAllPackages;
1:94446e5:     }
1:f43c090: 
1:f43c090: 	public int getConnectResponseTimeout() {
1:f43c090: 		return connectResponseTimeout;
1:f43c090: 	}
1:f43c090: 
1:f43c090: 	public void setConnectResponseTimeout(int connectResponseTimeout) {
1:f43c090: 		this.connectResponseTimeout = connectResponseTimeout;
1:f43c090: 	}
1:8b9e755: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:f43c090
/////////////////////////////////////////////////////////////////////////
1:     private int connectResponseTimeout = 0;
/////////////////////////////////////////////////////////////////////////
1:         connection.setConnectResponseTimeout(getConnectResponseTimeout());
/////////////////////////////////////////////////////////////////////////
1: 	public String getBrokerURL() {
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("connectResponseTimeout", Integer.toString(getConnectResponseTimeout()));
/////////////////////////////////////////////////////////////////////////
1: 
1: 	public int getConnectResponseTimeout() {
1: 		return connectResponseTimeout;
1: 	}
1: 
1: 	public void setConnectResponseTimeout(int connectResponseTimeout) {
1: 		this.connectResponseTimeout = connectResponseTimeout;
1: 	}
commit:61b2f6b
/////////////////////////////////////////////////////////////////////////
1:      * @return the StatsImpl associated with this ConnectionFactory.
commit:642cc43
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     private boolean consumerExpiryCheckEnabled = true;
/////////////////////////////////////////////////////////////////////////
1:         connection.setConsumerExpiryCheckEnabled(isConsumerExpiryCheckEnabled());
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("consumerExpiryCheckEnabled", Boolean.toString(isConsumerExpiryCheckEnabled()));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return true if MessageConsumer instance will check for expired messages before dispatch.
1:      */
1:     public boolean isConsumerExpiryCheckEnabled() {
1:         return consumerExpiryCheckEnabled;
1:     }
1: 
1:     /**
1:      * Controls whether message expiration checking is done in each MessageConsumer
1:      * prior to dispatching a message.  Disabling this check can lead to consumption
1:      * of expired messages.
1:      *
1:      * @param consumerExpiryCheckEnabled
1:      *        controls whether expiration checking is done prior to dispatch.
1:      */
1:     public void setConsumerExpiryCheckEnabled(boolean consumerExpiryCheckEnabled) {
1:         this.consumerExpiryCheckEnabled = consumerExpiryCheckEnabled;
1:     }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:eeec0c0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.*;
/////////////////////////////////////////////////////////////////////////
1:     private List<String> trustedPackages = Arrays.asList(ClassLoadingAwareObjectInputStream.serializablePackages);
commit:94446e5
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:     private List<String> trustedPackages = new ArrayList<String>();
1:     private boolean trustAllPackages = false;
/////////////////////////////////////////////////////////////////////////
1:         connection.setTrustedPackages(getTrustedPackages());
1:         connection.setTrustAllPackages(isTrustAllPackages());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public List<String> getTrustedPackages() {
1:         return trustedPackages;
1:     }
1: 
1:     public void setTrustedPackages(List<String> trustedPackages) {
1:         this.trustedPackages = trustedPackages;
1:     }
1: 
1:     public boolean isTrustAllPackages() {
1:         return trustAllPackages;
1:     }
1: 
1:     public void setTrustAllPackages(boolean trustAllPackages) {
1:         this.trustAllPackages = trustAllPackages;
1:     }
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:04ee70a
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1:             URI connectBrokerUL = brokerURL;
1:             String scheme = brokerURL.getScheme();
1:             if (scheme == null) {
1:                 throw new IOException("Transport not scheme specified: [" + brokerURL + "]");
1:             }
1:             if (scheme.equals("auto")) {
1:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto", "tcp"));
1:             } else if (scheme.equals("auto+ssl")) {
1:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto+ssl", "ssl"));
1:             } else if (scheme.equals("auto+nio")) {
1:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio", "nio"));
1:             } else if (scheme.equals("auto+nio+ssl")) {
1:                 connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio+ssl", "nio+ssl"));
1:             }
1: 
1:             return TransportFactory.connect(connectBrokerUL);
author:gtully
-------------------------------------------------------------------------------
commit:2d9959a
/////////////////////////////////////////////////////////////////////////
1:     private boolean messagePrioritySupported = false;
commit:221a751
/////////////////////////////////////////////////////////////////////////
1:     private boolean rmIdFromConnectionId = false;
/////////////////////////////////////////////////////////////////////////
1:     /*boolean*
/////////////////////////////////////////////////////////////////////////
1:         connection.setRmIdFromConnectionId(isRmIdFromConnectionId());
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("rmIdFromConnectionId", Boolean.toString(isRmIdFromConnectionId()));
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public boolean isRmIdFromConnectionId() {
1:         return rmIdFromConnectionId;
1:     }
1: 
1:     /**
1:      * uses the connection id as the resource identity for XAResource.isSameRM
1:      * ensuring join will only occur on a single connection
1:      */
1:     public void setRmIdFromConnectionId(boolean rmIdFromConnectionId) {
1:         this.rmIdFromConnectionId = rmIdFromConnectionId;
1:     }
1: 
commit:b66559e
/////////////////////////////////////////////////////////////////////////
1:     protected int xaAckMode = -1; // ensure default init before setting via brokerUrl introspection in sub class
author:rajdavies
-------------------------------------------------------------------------------
commit:71e4585
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQConnectionFactory.class);
1:     private static final String DEFAULT_BROKER_HOST;
1:     private static final int DEFAULT_BROKER_PORT;
1:     static{
1:         String host = null;
1:         String port = null;
1:         try {
1:              host = AccessController.doPrivileged(new PrivilegedAction<String>() {
1:                  @Override
1:                  public String run() {
1:                      String result = System.getProperty("org.apache.activemq.AMQ_HOST");
1:                      result = (result==null||result.isEmpty()) ?  System.getProperty("AMQ_HOST","localhost") : result;
1:                      return result;
1:                  }
1:              });
1:              port = AccessController.doPrivileged(new PrivilegedAction<String>() {
1:                  @Override
1:                  public String run() {
1:                      String result = System.getProperty("org.apache.activemq.AMQ_PORT");
1:                      result = (result==null||result.isEmpty()) ?  System.getProperty("AMQ_PORT","61616") : result;
1:                      return result;
1:                  }
1:              });
1:         }catch(Throwable e){
1:             LOG.debug("Failed to look up System properties for host and port",e);
1:         }
1:         host = (host == null || host.isEmpty()) ? "localhost" : host;
1:         port = (port == null || port.isEmpty()) ? "61616" : port;
1:         DEFAULT_BROKER_HOST = host;
1:         DEFAULT_BROKER_PORT = Integer.parseInt(port);
1:     }
1: 
1:     public static final String DEFAULT_BROKER_BIND_URL;
1: 
1:     static{
1:         final String defaultURL = "tcp://" + DEFAULT_BROKER_HOST + ":" + DEFAULT_BROKER_PORT;
1:         String bindURL = null;
1: 
1:         try {
1:             bindURL = AccessController.doPrivileged(new PrivilegedAction<String>() {
1:                 @Override
1:                 public String run() {
1:                     String result = System.getProperty("org.apache.activemq.BROKER_BIND_URL");
1:                     result = (result==null||result.isEmpty()) ?  System.getProperty("BROKER_BIND_URL",defaultURL) : result;
1:                     return result;
1:                 }
1:             });
1:         }catch(Throwable e){
1:             LOG.debug("Failed to look up System properties for host and port",e);
1:         }
1:         bindURL = (bindURL == null || bindURL.isEmpty()) ? defaultURL : bindURL;
1:         DEFAULT_BROKER_BIND_URL = bindURL;
1:     }
1: 
author:Christian Posta
-------------------------------------------------------------------------------
commit:b21dc69
/////////////////////////////////////////////////////////////////////////
1:      * @return the sendTimeout (in milliseconds)
1:      * @param sendTimeout the sendTimeout to set (in milliseconds)
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:77fe814
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("consumerFailoverRedeliveryWaitPeriod", Long.toString(getConsumerFailoverRedeliveryWaitPeriod()));
commit:de7617e
/////////////////////////////////////////////////////////////////////////
1:      * If this flag is not set then a separate thread is not used for dispatching messages for each Session in
1:      * the Connection. However, a separate thread is always used if there is more than one session, or the session
1:      * isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
1:      * happens asynchronously.
commit:3d5a758
/////////////////////////////////////////////////////////////////////////
1:     private long optimizedAckScheduledAckInterval = 0;
/////////////////////////////////////////////////////////////////////////
1:         connection.setOptimizedAckScheduledAckInterval(getOptimizedAckScheduledAckInterval());
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
1:      * to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
1:      * will not do any background Message acknowledgment.
1:      *
1:      * @return the scheduledOptimizedAckInterval
1:      */
1:     public long getOptimizedAckScheduledAckInterval() {
1:         return optimizedAckScheduledAckInterval;
1:     }
1: 
1:     /**
1:      * Sets the amount of time between scheduled sends of any outstanding Message Acks for consumers that
1:      * have been configured with optimizeAcknowledge enabled.
1:      *
0:      * @param scheduledOptimizedAckInterval the scheduledOptimizedAckInterval to set
1:      */
1:     public void setOptimizedAckScheduledAckInterval(long optimizedAckScheduledAckInterval) {
1:         this.optimizedAckScheduledAckInterval = optimizedAckScheduledAckInterval;
1:     }
commit:fefb228
/////////////////////////////////////////////////////////////////////////
1:         connection.setNestedMapAndListEnabled(isNestedMapAndListEnabled());
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("nestedMapAndListEnabled", Boolean.toString(isNestedMapAndListEnabled()));
commit:6da702b
/////////////////////////////////////////////////////////////////////////
1:         return createActiveMQConnection().enforceQueueOnlyConnection();
1:         return createActiveMQConnection(userName, password).enforceQueueOnlyConnection();
commit:a3836b5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.RedeliveryPolicyMap;
/////////////////////////////////////////////////////////////////////////
1:     private RedeliveryPolicyMap redeliveryPolicyMap = new RedeliveryPolicyMap();
1:     {
1:         redeliveryPolicyMap.setDefaultEntry(new RedeliveryPolicy());
1:     }
/////////////////////////////////////////////////////////////////////////
1:         connection.setRedeliveryPolicyMap(getRedeliveryPolicyMap());
/////////////////////////////////////////////////////////////////////////
1:         return redeliveryPolicyMap.getDefaultEntry();
1:      * Sets the global default redelivery policy to be used when a message is delivered
1:         this.redeliveryPolicyMap.setDefaultEntry(redeliveryPolicy);
1:     }
1: 
1:     public RedeliveryPolicyMap getRedeliveryPolicyMap() {
1:         return this.redeliveryPolicyMap;
1:     }
1: 
1:     /**
1:      * Sets the global redelivery policy mapping to be used when a message is delivered
1:      * but the session is rolled back
1:      */
1:     public void setRedeliveryPolicyMap(RedeliveryPolicyMap redeliveryPolicyMap) {
1:         this.redeliveryPolicyMap = redeliveryPolicyMap;
commit:7653774
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @returns the StatsImpl associated with this ConnectionFactory.
1:      */
1:         return this.factoryStats;
commit:0b6bf7e
/////////////////////////////////////////////////////////////////////////
1:     private boolean nonBlockingRedelivery = false;
/////////////////////////////////////////////////////////////////////////
1:         connection.setNonBlockingRedelivery(isNonBlockingRedelivery());
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("nonBlockingRedelivery", Boolean.toString(isNonBlockingRedelivery()));
/////////////////////////////////////////////////////////////////////////
1: 
1:      public boolean isNonBlockingRedelivery() {
1:          return nonBlockingRedelivery;
1:      }
1: 
1:      /**
1:       * When true a MessageConsumer will not stop Message delivery before re-delivering Messages
1:       * from a rolled back transaction.  This implies that message order will not be preserved and
1:       * also will result in the TransactedIndividualAck option to be enabled.
1:       */
1:      public void setNonBlockingRedelivery(boolean nonBlockingRedelivery) {
1:          this.nonBlockingRedelivery = nonBlockingRedelivery;
1:      }
1: 
commit:fa40250
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:             connection.setExceptionListener(exceptionListener);
/////////////////////////////////////////////////////////////////////////
1:                 Map<String,String> map = URISupport.parseQuery(this.brokerURL.getQuery());
1:                 Map<String,Object> jmsOptionsMap = IntrospectionSupport.extractProperties(map, "jms.");
1:                 if (buildFromMap(jmsOptionsMap)) {
1:                     if (!jmsOptionsMap.isEmpty()) {
1:                         String msg = "There are " + jmsOptionsMap.size()
1:                             + " jms options that couldn't be set on the ConnectionFactory."
1:                             + " Check the options are spelled correctly."
1:                             + " Unknown parameters=[" + jmsOptionsMap + "]."
1:                             + " This connection factory cannot be started.";
1:                         throw new IllegalArgumentException(msg);
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 Map<String,Object> jmsOptionsMap = IntrospectionSupport.extractProperties(data.getParameters(), "jms.");
1:                 if (buildFromMap(jmsOptionsMap)) {
1:                     if (!jmsOptionsMap.isEmpty()) {
1:                         String msg = "There are " + jmsOptionsMap.size()
1:                             + " jms options that couldn't be set on the ConnectionFactory."
1:                             + " Check the options are spelled correctly."
1:                             + " Unknown parameters=[" + jmsOptionsMap + "]."
1:                             + " This connection factory cannot be started.";
1:                         throw new IllegalArgumentException(msg);
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "unchecked", "rawtypes" })
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.exceptionListener = exceptionListener;
1:     public int getAuditDepth() {
1:         return auditDepth;
1:     }
1:     public void setAuditDepth(int auditDepth) {
1:         this.auditDepth = auditDepth;
1:     }
1:     public int getAuditMaximumProducerNumber() {
1:         return auditMaximumProducerNumber;
1:     }
1:     public void setAuditMaximumProducerNumber(int auditMaximumProducerNumber) {
1:         this.auditMaximumProducerNumber = auditMaximumProducerNumber;
1:     }
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1:      * @param optimizedAckScheduledAckInterval the scheduledOptimizedAckInterval to set
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:         Map<String, Object> p = new HashMap(properties);
1:         buildFromMap(p);
1:     public boolean buildFromMap(Map<String, Object> properties) {
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQConnectionFactory(URI brokerURL) {
1:         setBrokerURL(brokerURL.toString());
1:     }
1: 
1:     public ActiveMQConnectionFactory(String userName, String password, URI brokerURL) {
1:         setUserName(userName);
1:         setPassword(password);
1:         setBrokerURL(brokerURL.toString());
1:     }
1: 
1:     public ActiveMQConnectionFactory(String userName, String password, String brokerURL) {
1:         setUserName(userName);
1:         setPassword(password);
1:         setBrokerURL(brokerURL);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (clientID != null) {
1:             }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     protected static final Executor DEFAULT_CONNECTION_EXECUTOR = new ScheduledThreadPoolExecutor(5, new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized int getProducerWindowSize() {
1:     public synchronized void setProducerWindowSize(int producerWindowSize) {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.net.URISyntaxException;
0: import java.util.Map;
0: import java.util.Properties;
0: import java.util.concurrent.Executor;
0: import java.util.concurrent.ScheduledThreadPoolExecutor;
0: import java.util.concurrent.ThreadFactory;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.JMSException;
1: import javax.jms.QueueConnection;
1: import javax.jms.QueueConnectionFactory;
1: import javax.jms.TopicConnection;
1: import javax.jms.TopicConnectionFactory;
1: import javax.naming.Context;
1: 
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:  * 
/////////////////////////////////////////////////////////////////////////
0:     static protected final Executor DEFAULT_CONNECTION_EXECUTOR = new ScheduledThreadPoolExecutor(5, new ThreadFactory() {
0:         public Thread newThread(Runnable run) {
0:             Thread thread = new Thread(run);
0:             thread.setPriority(ThreadPriorities.INBOUND_CLIENT_CONNECTION);
0:             return thread;
1:         }
0:     });
1: 
0:     protected boolean dispatchAsync;
0:     protected boolean alwaysSessionAsync = true;
1: 
1:     JMSStatsImpl factoryStats = new JMSStatsImpl();
1: 
1:     private IdGenerator clientIdGenerator;
1:     private String clientIDPrefix;
/////////////////////////////////////////////////////////////////////////
1:     private boolean disableTimeStampsByDefault;
1:     private boolean useCompression;
1:     private boolean objectMessageSerializationDefered;
1:     private boolean useAsyncSend;
1:     private boolean optimizeAcknowledge;
1:     private boolean watchTopicAdvisories = true;
1:     private int producerWindowSize = DEFAULT_PRODUCER_WINDOW_SIZE;
/////////////////////////////////////////////////////////////////////////
1:             return (ActiveMQConnectionFactory)super.clone();
1:         } catch (CloneNotSupportedException e) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (URISyntaxException e) {
1:             throw (IllegalArgumentException)new IllegalArgumentException("Invalid broker URI: " + brokerURL).initCause(e);
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Creates a Transport based on this object's connection settings. Separated
1:      * from createActiveMQConnection to allow for subclasses to override.
0:             return TransportFactory.connect(brokerURL, DEFAULT_CONNECTION_EXECUTOR);
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnection connection = null;
1:             Transport transport = createTransport();
1:             connection = createActiveMQConnection(transport, factoryStats);
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (clientID != null)
1:         } catch (JMSException e) {
1:             // Clean up!
1:             try {
1:                 connection.close();
1:             } catch (Throwable ignore) {
1:             }
1:         } catch (Exception e) {
1:             // Clean up!
1:             try {
1:                 connection.close();
1:             } catch (Throwable ignore) {
1:             }
1:             throw JMSExceptionSupport.create("Could not connect to broker URL: " + brokerURL + ". Reason: " + e, e);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return brokerURL == null ? null : brokerURL.toString();
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Use all the properties prefixed with 'jms.' to set the connection
1:         // factory
1:         if (this.brokerURL.getQuery() != null) {
0:                 if (buildFromMap(IntrospectionSupport.extractProperties(map, "jms."))) {
/////////////////////////////////////////////////////////////////////////
0:                 if (buildFromMap(IntrospectionSupport.extractProperties(data.getParameters(), "jms."))) {
/////////////////////////////////////////////////////////////////////////
1:      * Sets the JMS clientID to use for the created connection. Note that this
1:      * can only be used by one connection at once so generally its a better idea
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQPrefetchPolicy getPrefetchPolicy() {
/////////////////////////////////////////////////////////////////////////
1:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large
1:      * OBjects) are transferred from producers to brokers to consumers
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
1:      * adds a massive performance boost; but means that the send() method will
1:      * return immediately whether the message has been sent or not which could
1:      * lead to message loss.
1:     public synchronized boolean isWatchTopicAdvisories() {
1:         return watchTopicAdvisories;
1:     }
1: 
1:     public synchronized void setWatchTopicAdvisories(boolean watchTopicAdvisories) {
1:         this.watchTopicAdvisories = watchTopicAdvisories;
1:     }
1: 
1:     public boolean isAlwaysSyncSend() {
1:      * 
1:     public void setAlwaysSyncSend(boolean alwaysSyncSend) {
1:         this.alwaysSyncSend = alwaysSyncSend;
/////////////////////////////////////////////////////////////////////////
1:      * Sets whether or not retroactive consumers are enabled. Retroactive
1:      * consumers allow non-durable topic subscribers to receive old messages
1:      * that were published before the non-durable subscriber started.
/////////////////////////////////////////////////////////////////////////
1:      * Enables or disables whether or not queue consumers should be exclusive or
1:      * not for example to preserve ordering when not using <a
1:      * href="http://activemq.apache.org/message-groups.html">Message Groups</a>
0:      * 
/////////////////////////////////////////////////////////////////////////
0:      * Sets the global redelivery policy to be used when a message is delivered
1:      * but the session is rolled back
/////////////////////////////////////////////////////////////////////////
1:      * Sets the transformer used to transform messages before they are sent on
1:      * to the JMS bus or when they are received from the bus but before they are
1:      * delivered to the JMS client
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         buildFromMap(properties);
1: 
1:         boolean rc = false;
1: 
1:         ActiveMQPrefetchPolicy p = new ActiveMQPrefetchPolicy();
1:         if (IntrospectionSupport.setProperties(p, properties, "prefetchPolicy.")) {
1:             setPrefetchPolicy(p);
1:             rc = true;
1:         if (IntrospectionSupport.setProperties(rp, properties, "redeliveryPolicy.")) {
1:         if (IntrospectionSupport.setProperties(blobTransferPolicy, properties, "blobTransferPolicy.")) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         props.setProperty("statsEnabled", Boolean.toString(isStatsEnabled()));
1:         props.setProperty("alwaysSyncSend", Boolean.toString(isAlwaysSyncSend()));
/////////////////////////////////////////////////////////////////////////
1:      * synchronously or asynchronously by the broker</a>. For non-durable
1:      * topics for example we typically dispatch synchronously by default to
1:      * minimize context switches which boost performance. However sometimes its
1:      * better to go slower to ensure that a single blocked consumer socket does
1:      * not block delivery to other consumers.
1:      * @param asyncDispatch If true then consumers created on this connection
1:      *                will default to having their messages dispatched
0:      *                asynchronously. The default value is false.
/////////////////////////////////////////////////////////////////////////
1:     public int getCloseTimeout() {
/////////////////////////////////////////////////////////////////////////
1:     public void setCloseTimeout(int closeTimeout) {
1:         this.closeTimeout = closeTimeout;
1:     public boolean isAlwaysSessionAsync() {
/////////////////////////////////////////////////////////////////////////
1:     public void setAlwaysSessionAsync(boolean alwaysSessionAsync) {
1:         this.alwaysSessionAsync = alwaysSessionAsync;
1:     public boolean isOptimizeAcknowledge() {
1:     public void setOptimizeAcknowledge(boolean optimizeAcknowledge) {
1:         this.optimizeAcknowledge = optimizeAcknowledge;
1: 
1:         return nestedMapAndListEnabled;
/////////////////////////////////////////////////////////////////////////
1:      * Sets the prefix used by autogenerated JMS Client ID values which are used
1:      * if the JMS client does not explicitly specify on.
1: 
1:             } else {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isStatsEnabled() {
1:     public void setStatsEnabled(boolean statsEnabled) {
0:     synchronized public int getProducerWindowSize() {
1:         return producerWindowSize;
1:     }
0:     synchronized public void setProducerWindowSize(int producerWindowSize) {
1:         this.producerWindowSize = producerWindowSize;
1:     }
1:      * Enables the timeout from a connection creation to when a warning is
1:      * generated if the connection is not properly started via
1:      * {@link Connection#start()} and a message is received by a consumer. It is
1:      * a very common gotcha to forget to <a
1:      * href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
1:      * the connection</a> so this option makes the default case to create a
1:      * warning if the user forgets. To disable the warning just set the value to <
1:      * 0 (say -1).
commit:489f5aa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             connection.setAlwaysSyncSend(isAlwaysSyncSend());
/////////////////////////////////////////////////////////////////////////
commit:c9bb1c9
/////////////////////////////////////////////////////////////////////////
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Map;
0: import java.util.Properties;
0: import java.util.concurrent.Executor;
0: import java.util.concurrent.ScheduledThreadPoolExecutor;
0: import java.util.concurrent.ThreadFactory;
1: 
0: import javax.jms.Connection;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.JMSException;
0: import javax.jms.QueueConnection;
0: import javax.jms.QueueConnectionFactory;
0: import javax.jms.TopicConnection;
0: import javax.jms.TopicConnectionFactory;
0: import javax.naming.Context;
1: 
1: import org.apache.activemq.blob.BlobTransferPolicy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static final int DEFAULT_PRODUCER_WINDOW_SIZE = 0;
/////////////////////////////////////////////////////////////////////////
0:     private int producerWindowSize=DEFAULT_PRODUCER_WINDOW_SIZE;
/////////////////////////////////////////////////////////////////////////
0:             connection.setProducerWindowSize(producerWindowSize);
/////////////////////////////////////////////////////////////////////////
0:         props.setProperty("producerWindowSize", Integer.toString(producerWindowSize));
/////////////////////////////////////////////////////////////////////////
1: 
0: 	synchronized public int getProducerWindowSize() {
0: 		return producerWindowSize;
1: 	}
1: 
0: 	synchronized public void setProducerWindowSize(int producerWindowSize) {
0: 		this.producerWindowSize = producerWindowSize;
1: 	}
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Executor;
0: import java.util.concurrent.ScheduledThreadPoolExecutor;
0: import java.util.concurrent.ThreadFactory;
commit:d71bc42
/////////////////////////////////////////////////////////////////////////
1:                 connection.setDefaultClientID(clientID);
commit:4f945cf
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Creates a Transport based on this object's connection settings.
0:      * 
0:      * Separated from createActiveMQConnection to allow for subclasses to
0:      *      override.
0:      * 
1:      * @return The newly created Transport.
1:      * @throws JMSException If unable to create trasnport.
0:      * 
0:      * @author sepandm@gmail.com
1:      */
1:     protected Transport createTransport() throws JMSException {
1:         try {
0:             return TransportFactory.connect(brokerURL,DEFAULT_CONNECTION_EXECUTOR);
1:         } catch (Exception e) {
1:             throw JMSExceptionSupport.create("Could not create Transport. Reason: " + e, e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:             transport = createTransport();
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:7f0e135
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.jndi.JNDIBaseStorable;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if( buildFromMap(IntrospectionSupport.extractProperties(map, "jms.")) ) {
/////////////////////////////////////////////////////////////////////////
0:                 if( buildFromMap(IntrospectionSupport.extractProperties(data.getParameters(), "jms.")) ) {
/////////////////////////////////////////////////////////////////////////
0:     public  ActiveMQPrefetchPolicy getPrefetchPolicy() {
/////////////////////////////////////////////////////////////////////////
1:     	
/////////////////////////////////////////////////////////////////////////
1:         
0:         buildFromMap(properties);    	
1:     }
1:     
0:     public boolean buildFromMap(Map properties) {
0:     	boolean rc=false;
1:     	
0:         ActiveMQPrefetchPolicy p = new ActiveMQPrefetchPolicy(); 
0:         if( IntrospectionSupport.setProperties(p, properties, "prefetchPolicy.") ) {
0:         	setPrefetchPolicy(p);
1:         	rc = true;
1:         }
1: 
1:         RedeliveryPolicy rp = new RedeliveryPolicy();
0:         if ( IntrospectionSupport.setProperties(rp, properties, "redeliveryPolicy.") ) {
1:             setRedeliveryPolicy(rp);
1:             rc = true;
1:         }
1:         
1:         rc |= IntrospectionSupport.setProperties(this, properties);
1:         
1:         return rc;
/////////////////////////////////////////////////////////////////////////
1:         IntrospectionSupport.getProperties(getPrefetchPolicy(), props, "prefetchPolicy.");
1:         IntrospectionSupport.getProperties(getRedeliveryPolicy(), props, "redeliveryPolicy.");
1:         
commit:1b4eb12
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c6e0984
/////////////////////////////////////////////////////////////////////////
0:     private boolean optimizeAcknowledge = true;
commit:653a779
/////////////////////////////////////////////////////////////////////////
0:     private boolean optimizeAcknowledge = false;
commit:90e21b4
/////////////////////////////////////////////////////////////////////////
0:     private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQConnection connection = new ActiveMQConnection(transport, factoryStats);
1:             connection.setUserName(userName);
1:             connection.setPassword(password);
/////////////////////////////////////////////////////////////////////////
0:             connection.setRedeliveryPolicy(getRedeliveryPolicy());
1:             
1:             transport.start();
1: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Map;
0: import java.util.Properties;
1: 
0: import javax.jms.Connection;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.JMSException;
0: import javax.jms.QueueConnection;
0: import javax.jms.QueueConnectionFactory;
0: import javax.jms.TopicConnection;
0: import javax.jms.TopicConnectionFactory;
0: import javax.naming.Context;
1: 
1: import org.apache.activemq.management.JMSStatsImpl;
1: import org.apache.activemq.management.StatsCapable;
1: import org.apache.activemq.management.StatsImpl;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportFactory;
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.activemq.util.JMSExceptionSupport;
0: import org.apache.activemq.util.URISupport;
1: import org.apache.activemq.util.URISupport.CompositeData;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.Executor;
0: import edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
1: 
1: /**
1:  * A ConnectionFactory is an an Administered object, and is used for creating
1:  * Connections. <p/> This class also implements QueueConnectionFactory and
1:  * TopicConnectionFactory. You can use this connection to create both
1:  * QueueConnections and TopicConnections.
0:  * 
0:  * @version $Revision: 1.9 $
1:  * @see javax.jms.ConnectionFactory
1:  */
0: public class ActiveMQConnectionFactory implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory, StatsCapable {
1: 
0:     public static final String DEFAULT_BROKER_URL = "tcp://localhost:61616";
1:     public static final String DEFAULT_USER = null;
1:     public static final String DEFAULT_PASSWORD = null;
1: 
1:     protected URI brokerURL;
1:     protected String userName;
1:     protected String password;
1:     protected String clientID;
1: 
0:     // optimization flags
1:     private ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
0:     private boolean disableTimeStampsByDefault = false;
0:     private boolean onSendPrepareMessageBody = true;
1:     private boolean optimizedMessageDispatch = true;
1:     private boolean copyMessageOnSend = true;
0:     private boolean useCompression = false;
0:     private boolean objectMessageSerializationDefered = false;
0:     protected boolean asyncDispatch = true;
0:     private boolean useAsyncSend = false;
1:     private boolean useRetroactiveConsumer;
1: 
0:     JMSStatsImpl factoryStats = new JMSStatsImpl();
1:      
0:     static protected final Executor DEFAULT_CONNECTION_EXECUTOR = new ScheduledThreadPoolExecutor(5, new ThreadFactory() {
0:             public Thread newThread(Runnable run) {
0:                 Thread thread = new Thread(run);
0:                 thread.setPriority(ThreadPriorities.INBOUND_CLIENT_CONNECTION);
0:                 return thread;
1:             }
0:         });
1: 
1:     // /////////////////////////////////////////////
1:     //
1:     // ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory Methods
1:     //
1:     // /////////////////////////////////////////////
1: 
1:     public ActiveMQConnectionFactory() {
1:         this(DEFAULT_BROKER_URL);
1:     }
1: 
1:     public ActiveMQConnectionFactory(String brokerURL) {
1:         this(createURI(brokerURL));
1:     }
1: 
1:     /**
1:      * @param brokerURL
1:      * @return
1:      * @throws URISyntaxException
1:      */
1:     private static URI createURI(String brokerURL) {
1:         try {
1:             return new URI(brokerURL);
1:         }
0:         catch (URISyntaxException e) {
0:             throw (IllegalArgumentException) new IllegalArgumentException("Invalid broker URI: " + brokerURL).initCause(e);
1:         }
1:     }
1: 
0:     public ActiveMQConnectionFactory(URI brokerURL) {
0:         setBrokerURL(brokerURL.toString());
1:     }
1: 
0:     public ActiveMQConnectionFactory(String userName, String password, URI brokerURL) {
0:         setUserName(userName);
0:         setPassword(password);
0:         setBrokerURL(brokerURL.toString());
1:     }
1: 
0:     public ActiveMQConnectionFactory(String userName, String password, String brokerURL) {
0:         setUserName(userName);
0:         setPassword(password);
0:         setBrokerURL(brokerURL);
1:     }
1: 
1:     /**
1:      * @return Returns the Connection.
1:      */
1:     public Connection createConnection() throws JMSException {
1:         return createActiveMQConnection(userName, password);
1:     }
1: 
1:     /**
1:      * @return Returns the Connection.
1:      */
1:     public Connection createConnection(String userName, String password) throws JMSException {
1:         return createActiveMQConnection(userName, password);
1:     }
1: 
1:     /**
1:      * @return Returns the QueueConnection.
1:      * @throws JMSException
1:      */
1:     public QueueConnection createQueueConnection() throws JMSException {
1:         return createActiveMQConnection(userName, password);
1:     }
1: 
1:     /**
1:      * @return Returns the QueueConnection.
1:      */
1:     public QueueConnection createQueueConnection(String userName, String password) throws JMSException {
1:         return createActiveMQConnection(userName, password);
1:     }
1: 
1:     /**
1:      * @return Returns the TopicConnection.
1:      * @throws JMSException
1:      */
1:     public TopicConnection createTopicConnection() throws JMSException {
1:         return createActiveMQConnection(userName, password);
1:     }
1: 
1:     /**
1:      * @return Returns the TopicConnection.
1:      */
1:     public TopicConnection createTopicConnection(String userName, String password) throws JMSException {
1:         return createActiveMQConnection(userName, password);
1:     }
1: 
1:     public StatsImpl getStats() {
0:         // TODO
0:         return null;
1:     }
1: 
1:     // /////////////////////////////////////////////
1:     //
1:     // Implementation methods.
1:     //
1:     // /////////////////////////////////////////////
1: 
1:     /**
1:      * @return Returns the Connection.
1:      */
0:     private ActiveMQConnection createActiveMQConnection(String userName, String password) throws JMSException {
1:         if (brokerURL == null) {
1:             throw new ConfigurationException("brokerURL not set.");
1:         }
0:         Transport transport;
1:         try {
0:             transport = TransportFactory.connect(brokerURL,DEFAULT_CONNECTION_EXECUTOR);
0:             ActiveMQConnection connection = new ActiveMQConnection(transport, userName, password, factoryStats);
1: 
1:             connection.setPrefetchPolicy(getPrefetchPolicy());
1:             connection.setDisableTimeStampsByDefault(isDisableTimeStampsByDefault());
0:             connection.setOnSendPrepareMessageBody(isOnSendPrepareMessageBody());
1:             connection.setOptimizedMessageDispatch(isOptimizedMessageDispatch());
1:             connection.setCopyMessageOnSend(isCopyMessageOnSend());
1:             connection.setUseCompression(isUseCompression());
1:             connection.setObjectMessageSerializationDefered(isObjectMessageSerializationDefered());
0:             connection.setAsyncDispatch(isAsyncDispatch());
1:             connection.setUseAsyncSend(isUseAsyncSend());
1:             connection.setUseRetroactiveConsumer(isUseRetroactiveConsumer());
1: 
0:             if( clientID !=null )
0:                 connection.setClientID(clientID);
1:             
1:             return connection;
1:         }
0:         catch (JMSException e) {
1:             throw e;
1:         }
0:         catch (Exception e) {
0:             throw JMSExceptionSupport.create("Could not connect to broker URL: " + brokerURL + ". Reason: " + e, e);
1:         }
1:     }
1: 
1:     // /////////////////////////////////////////////
1:     //
1:     // Property Accessors
1:     //
1:     // /////////////////////////////////////////////
1: 
0:     public String getBrokerURL() {
0:         return brokerURL==null?null:brokerURL.toString();
1:     }
1:     public void setBrokerURL(String brokerURL) {
1:         this.brokerURL = createURI(brokerURL);
1:         
0:         // Use all the properties prefixed with 'jms.' to set the connection factory
1:         // options.
0:         if( this.brokerURL.getQuery() !=null ) {
1:             // It might be a standard URI or...
1:             try {
1:                 
0:                 Map map = URISupport.parseQuery(this.brokerURL.getQuery());
0:                 if( IntrospectionSupport.setProperties(this, map, "jms.") ) {
1:                     this.brokerURL = URISupport.createRemainingURI(this.brokerURL, map);
1:                 }
1:                 
1:             } catch (URISyntaxException e) {
1:             }
1:             
1:         } else {
1:             
1:             // It might be a composite URI.
1:             try {
1:                 CompositeData data = URISupport.parseComposite(this.brokerURL);
0:                 if( IntrospectionSupport.setProperties(this, data.getParameters(), "jms.") ) {
1:                     this.brokerURL = data.toURI();
1:                 }
1:             } catch (URISyntaxException e) {
1:             }
1:         }
1:     }
1: 
1:     public String getClientID() {
1:         return clientID;
1:     }
1: 
1:     public void setClientID(String clientID) {
1:         this.clientID = clientID;
1:     }
1: 
1:     public boolean isCopyMessageOnSend() {
1:         return copyMessageOnSend;
1:     }
1: 
1:     public void setCopyMessageOnSend(boolean copyMessageOnSend) {
1:         this.copyMessageOnSend = copyMessageOnSend;
1:     }
1: 
1:     public boolean isDisableTimeStampsByDefault() {
1:         return disableTimeStampsByDefault;
1:     }
1: 
1:     public void setDisableTimeStampsByDefault(boolean disableTimeStampsByDefault) {
1:         this.disableTimeStampsByDefault = disableTimeStampsByDefault;
1:     }
1: 
1:     public boolean isOptimizedMessageDispatch() {
1:         return optimizedMessageDispatch;
1:     }
1: 
1:     public void setOptimizedMessageDispatch(boolean optimizedMessageDispatch) {
1:         this.optimizedMessageDispatch = optimizedMessageDispatch;
1:     }
1: 
1:     public String getPassword() {
1:         return password;
1:     }
1: 
1:     public void setPassword(String password) {
1:         this.password = password;
1:     }
1: 
0:     public ActiveMQPrefetchPolicy getPrefetchPolicy() {
1:         return prefetchPolicy;
1:     }
1: 
1:     public void setPrefetchPolicy(ActiveMQPrefetchPolicy prefetchPolicy) {
1:         this.prefetchPolicy = prefetchPolicy;
1:     }
1: 
1:     public boolean isUseAsyncSend() {
1:         return useAsyncSend;
1:     }
1: 
1:     public void setUseAsyncSend(boolean useAsyncSend) {
1:         this.useAsyncSend = useAsyncSend;
1:     }
1: 
1:     public String getUserName() {
1:         return userName;
1:     }
1: 
1:     public void setUserName(String userName) {
1:         this.userName = userName;
1:     }
1:     
1:     public boolean isUseRetroactiveConsumer() {
1:         return useRetroactiveConsumer;
1:     }
1: 
1:     /**
0:      * Sets whether or not retroactive consumers are enabled. Retroactive consumers allow
0:      * non-durable topic subscribers to receive old messages that were published before the
0:      * non-durable subscriber started.
1:      */
1:     public void setUseRetroactiveConsumer(boolean useRetroactiveConsumer) {
1:         this.useRetroactiveConsumer = useRetroactiveConsumer;
1:     }
1: 
1:     /**
0:      * set the properties for this instance as retrieved from JNDI
0:      * 
0:      * @param properties
1:      */
0:     public void setProperties(Properties properties) throws URISyntaxException {
1:         
1:         if (properties == null) {
1:             properties = new Properties();
1:         }
1:         
0:         IntrospectionSupport.setProperties(this, properties);
1:         
1:         String temp = properties.getProperty(Context.PROVIDER_URL);
1:         if (temp == null || temp.length() == 0) {
1:             temp = properties.getProperty("brokerURL");
1:         }
1:         if (temp != null && temp.length() > 0) {
1:             setBrokerURL(temp);
1:         }
1:     }
1: 
0:     public boolean isOnSendPrepareMessageBody() {
0:         return onSendPrepareMessageBody;
1:     }
1: 
0:     public void setOnSendPrepareMessageBody(boolean onSendPrepareMessageBody) {
0:         this.onSendPrepareMessageBody = onSendPrepareMessageBody;
1:     }
1: 
1:     public boolean isUseCompression() {
1:         return useCompression;
1:     }
1: 
1:     public void setUseCompression(boolean useCompression) {
1:         this.useCompression = useCompression;
1:     }
1: 
1:     public boolean isObjectMessageSerializationDefered() {
1:         return objectMessageSerializationDefered;
1:     }
1: 
1:     public void setObjectMessageSerializationDefered(boolean objectMessageSerializationDefered) {
1:         this.objectMessageSerializationDefered = objectMessageSerializationDefered;
1:     }
1: 
0:     public boolean isAsyncDispatch() {
0:         return asyncDispatch;
1:     }
1: 
0:     public void setAsyncDispatch(boolean asyncDispatch) {
0:         this.asyncDispatch = asyncDispatch;
1:     }
1: 
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:c30dd0c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return TransportFactory.connect(brokerURL);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:9cda426
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("maxThreadPoolSize", Integer.toString(getMaxThreadPoolSize()));
commit:e3fcf71
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.RejectedExecutionHandler;
/////////////////////////////////////////////////////////////////////////
1:     private RejectedExecutionHandler rejectedTaskHandler = null;
/////////////////////////////////////////////////////////////////////////
1:         connection.setRejectedTaskHandler(getRejectedTaskHandler());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public RejectedExecutionHandler getRejectedTaskHandler() {
1:         return rejectedTaskHandler;
1:     }
1: 
1:     public void setRejectedTaskHandler(RejectedExecutionHandler rejectedTaskHandler) {
1:         this.rejectedTaskHandler = rejectedTaskHandler;
1:     }
commit:c33231b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     private int maxThreadPoolSize = ActiveMQConnection.DEFAULT_THREAD_POOL_SIZE;
1:     private TaskRunnerFactory sessionTaskRunner;
/////////////////////////////////////////////////////////////////////////
1:         connection.setMaxThreadPoolSize(getMaxThreadPoolSize());
1:         connection.setSessionTaskRunner(getSessionTaskRunner());
/////////////////////////////////////////////////////////////////////////
1:     public int getMaxThreadPoolSize() {
1:         return maxThreadPoolSize;
1:     }
1: 
1:     public void setMaxThreadPoolSize(int maxThreadPoolSize) {
1:         this.maxThreadPoolSize = maxThreadPoolSize;
1:     }
1: 
1:     public TaskRunnerFactory getSessionTaskRunner() {
1:         return sessionTaskRunner;
1:     }
1: 
1:     public void setSessionTaskRunner(TaskRunnerFactory sessionTaskRunner) {
1:         this.sessionTaskRunner = sessionTaskRunner;
1:     }
commit:d3649fc
/////////////////////////////////////////////////////////////////////////
commit:2a58f4c
/////////////////////////////////////////////////////////////////////////
1: 	private int auditDepth = ActiveMQMessageAudit.DEFAULT_WINDOW_SIZE;
1: 	private int auditMaximumProducerNumber = ActiveMQMessageAudit.MAXIMUM_PRODUCER_COUNT;
/////////////////////////////////////////////////////////////////////////
1:         connection.setAuditDepth(getAuditDepth());
1:         connection.setAuditMaximumProducerNumber(getAuditMaximumProducerNumber());
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("auditDepth", Integer.toString(getAuditDepth()));
1:         props.setProperty("auditMaximumProducerNumber", Integer.toString(getAuditMaximumProducerNumber()));
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public int getAuditDepth() {
0: 		return auditDepth;
1: 	}
1: 
0: 	public void setAuditDepth(int auditDepth) {
0: 		this.auditDepth = auditDepth;
1: 	}
1: 
0: 	public int getAuditMaximumProducerNumber() {
0: 		return auditMaximumProducerNumber;
1: 	}
1: 
0: 	public void setAuditMaximumProducerNumber(int auditMaximumProducerNumber) {
0: 		this.auditMaximumProducerNumber = auditMaximumProducerNumber;
1: 	}
author:Gary Tully
-------------------------------------------------------------------------------
commit:09ff99f
/////////////////////////////////////////////////////////////////////////
1:      *                asynchronously. The default value is true.
commit:44488a5
/////////////////////////////////////////////////////////////////////////
1:         connection.setOptimizeAcknowledgeTimeOut(getOptimizeAcknowledgeTimeOut());
/////////////////////////////////////////////////////////////////////////
1:     public void setOptimizeAcknowledgeTimeOut(long optimizeAcknowledgeTimeOut) {
commit:2030097
/////////////////////////////////////////////////////////////////////////
1:     private boolean transactedIndividualAck = false;
/////////////////////////////////////////////////////////////////////////
1:         connection.setTransactedIndividualAck(isTransactedIndividualAck());
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("transactedIndividualAck", Boolean.toString(isTransactedIndividualAck()));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isTransactedIndividualAck() {
1:          return transactedIndividualAck;
1:      }
1: 
1:      /**
1:       * when true, submit individual transacted acks immediately rather than with transaction completion.
1:       * This allows the acks to represent delivery status which can be persisted on rollback
1:       * Used in conjunction with org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter#setRewriteOnRedelivery(boolean)  true
1:       */
1:      public void setTransactedIndividualAck(boolean transactedIndividualAck) {
1:          this.transactedIndividualAck = transactedIndividualAck;
1:      }
1: 
commit:975fc55
/////////////////////////////////////////////////////////////////////////
1:     private long optimizeAcknowledgeTimeOut = 300;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The max time in milliseconds between optimized ack batches
1:      * @param optimizeAcknowledgeTimeOut
1:      */
0:     public void setOptimizeAcknowledgeTimeOut(int optimizeAcknowledgeTimeOut) {
1:         this.optimizeAcknowledgeTimeOut =  optimizeAcknowledgeTimeOut;
1:     }
1: 
1:     public long getOptimizeAcknowledgeTimeOut() {
1:         return optimizeAcknowledgeTimeOut;
1:     }
1: 
commit:b9045db
/////////////////////////////////////////////////////////////////////////
1:     private IdGenerator connectionIdGenerator;
1:     private String connectionIDPrefix;
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnection connection = new ActiveMQConnection(transport, getClientIdGenerator(),
1:                 getConnectionIdGenerator(), stats);
/////////////////////////////////////////////////////////////////////////
1:      * Sets the prefix used by connection id generator
1:      * @param connectionIDPrefix
1:      */
1:     public void setConnectionIDPrefix(String connectionIDPrefix) {
1:         this.connectionIDPrefix = connectionIDPrefix;
1:     }
1: 
1:     protected synchronized IdGenerator getConnectionIdGenerator() {
1:         if (connectionIdGenerator == null) {
1:             if (connectionIDPrefix != null) {
1:                 connectionIdGenerator = new IdGenerator(connectionIDPrefix);
1:             } else {
1:                 connectionIdGenerator = new IdGenerator();
1:             }
1:         }
1:         return connectionIdGenerator;
1:     }
1: 
1:     protected void setConnectionIdGenerator(IdGenerator connectionIdGenerator) {
1:         this.connectionIdGenerator = connectionIdGenerator;
1:     }
1: 
1:     /**
commit:f937966
/////////////////////////////////////////////////////////////////////////
1:         connection.setCloseTimeout(getCloseTimeout());
commit:f82dc25
/////////////////////////////////////////////////////////////////////////
1:     private ClientInternalExceptionListener clientInternalExceptionListener;
/////////////////////////////////////////////////////////////////////////
1:         if (clientInternalExceptionListener != null) {
1:             connection.setClientInternalExceptionListener(clientInternalExceptionListener);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public ClientInternalExceptionListener getClientInternalExceptionListener() {
1:         return clientInternalExceptionListener;
1:     }
1:     
1:     /**
1:      * Allows an {@link ClientInternalExceptionListener} to be configured on the ConnectionFactory so that when this factory
1:      * is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
1:      * an exception listener.
1:      * <p> Note: access to this clientInternalExceptionListener will <b>not</b> be serialized if it is associated with more than
1:      * on connection (as it will be if more than one connection is subsequently created by this connection factory)
1:      * @param clientInternalExceptionListener sets the exception listener to be registered on all connections
1:      * created by this factory
1:      */
1:     public void setClientInternalExceptionListener(
1:             ClientInternalExceptionListener clientInternalExceptionListener) {
1:         this.clientInternalExceptionListener = clientInternalExceptionListener;
1:     }
commit:b836af8
/////////////////////////////////////////////////////////////////////////
1:     private long consumerFailoverRedeliveryWaitPeriod = 0;
/////////////////////////////////////////////////////////////////////////
1:         connection.setConsumerFailoverRedeliveryWaitPeriod(getConsumerFailoverRedeliveryWaitPeriod());
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void setConsumerFailoverRedeliveryWaitPeriod(long consumerFailoverRedeliveryWaitPeriod) {
1:         this.consumerFailoverRedeliveryWaitPeriod = consumerFailoverRedeliveryWaitPeriod;
1:     }
1:     
1:     public long getConsumerFailoverRedeliveryWaitPeriod() {
1:         return consumerFailoverRedeliveryWaitPeriod;
1:     }
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1:     private int sendTimeout = 0;
1:     private ExceptionListener exceptionListener;
0:     private int auditDepth = ActiveMQMessageAudit.DEFAULT_WINDOW_SIZE;
0:     private int auditMaximumProducerNumber = ActiveMQMessageAudit.MAXIMUM_PRODUCER_COUNT;
1:     private boolean useDedicatedTaskRunner;
/////////////////////////////////////////////////////////////////////////
1:         connection.setUseDedicatedTaskRunner(isUseDedicatedTaskRunner());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setUseDedicatedTaskRunner(boolean useDedicatedTaskRunner) {
1:         this.useDedicatedTaskRunner = useDedicatedTaskRunner;
1:     }
1:     
1:     public boolean isUseDedicatedTaskRunner() {
1:         return useDedicatedTaskRunner;
1:     }
commit:8b9e755
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.ExceptionListener;
/////////////////////////////////////////////////////////////////////////
0: 	private ExceptionListener exceptionListener;
/////////////////////////////////////////////////////////////////////////
1:     protected void configureConnection(ActiveMQConnection connection) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:         if (exceptionListener != null) {
0:         	connection.setExceptionListener(exceptionListener);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     public ExceptionListener getExceptionListener() {
1:         return exceptionListener;
1:     }
1:     
1:     /**
1:      * Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory
1:      * is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register
1:      * an exception listener.
1:      * <p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than
1:      * on connection (as it will be if more than one connection is subsequently created by this connection factory)
1:      * @param exceptionListener sets the exception listener to be registered on all connections
1:      * created by this factory
1:      */
1:     public void setExceptionListener(ExceptionListener exceptionListener) {
0:     	this.exceptionListener = exceptionListener;
1:     }
author:Robert Davies
-------------------------------------------------------------------------------
commit:c14dc3a
/////////////////////////////////////////////////////////////////////////
0:     private boolean messagePrioritySupported = true;
/////////////////////////////////////////////////////////////////////////
1:         connection.setMessagePrioritySupported(isMessagePrioritySupported());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return the messagePrioritySupported
1:      */
1:     public boolean isMessagePrioritySupported() {
1:         return this.messagePrioritySupported;
1:     }
1: 
1:     /**
1:      * @param messagePrioritySupported the messagePrioritySupported to set
1:      */
1:     public void setMessagePrioritySupported(boolean messagePrioritySupported) {
1:         this.messagePrioritySupported = messagePrioritySupported;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("messagePrioritySupported", Boolean.toString(isMessagePrioritySupported()));
commit:794e62f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean checkForDuplicates = true;
/////////////////////////////////////////////////////////////////////////
1:         connection.setCheckForDuplicates(isCheckForDuplicates());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("checkForDuplicates", Boolean.toString(isCheckForDuplicates()));
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the checkForDuplicates
1:      */
1:     public boolean isCheckForDuplicates() {
1:         return this.checkForDuplicates;
1:     }
1: 
1:     /**
1:      * @param checkForDuplicates the checkForDuplicates to set
1:      */
1:     public void setCheckForDuplicates(boolean checkForDuplicates) {
1:         this.checkForDuplicates = checkForDuplicates;
1:     }
commit:932ddd2
/////////////////////////////////////////////////////////////////////////
1:         connection.setExclusiveConsumer(isExclusiveConsumer());
commit:d8a0ca2
/////////////////////////////////////////////////////////////////////////
0:  * @org.apache.xbean.XBean element="connectionFactory"
commit:d8b5d5c
/////////////////////////////////////////////////////////////////////////
1:     private boolean sendAcksAsync=true;
/////////////////////////////////////////////////////////////////////////
1:         connection.setSendAcksAsync(isSendAcksAsync());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return the sendAcksAsync
1:      */
1:     public boolean isSendAcksAsync() {
1:         return sendAcksAsync;
1:     }
1: 
1:     /**
1:      * @param sendAcksAsync the sendAcksAsync to set
1:      */
1:     public void setSendAcksAsync(boolean sendAcksAsync) {
1:         this.sendAcksAsync = sendAcksAsync;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("sendAcksAsync",Boolean.toString(isSendAcksAsync()));
commit:114a923
/////////////////////////////////////////////////////////////////////////
0:     private int sendTimeout =0;
/////////////////////////////////////////////////////////////////////////
1:         connection.setSendTimeout(getSendTimeout());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * @return the sendTimeout
1:      */
1:     public int getSendTimeout() {
1:         return sendTimeout;
1:     }
1: 
1:     /**
0:      * @param sendTimeout the sendTimeout to set
1:      */
1:     public void setSendTimeout(int sendTimeout) {
1:         this.sendTimeout = sendTimeout;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("sendTimeout", Integer.toString(getSendTimeout()));
commit:3f98639
/////////////////////////////////////////////////////////////////////////
0:     public static final String DEFAULT_BROKER_BIND_URL = "tcp://localhost:61616";
1:     public static final String DEFAULT_BROKER_URL = "failover://"+DEFAULT_BROKER_BIND_URL;
commit:62fb85e
/////////////////////////////////////////////////////////////////////////
1:     protected boolean dispatchAsync=true;
1:     protected boolean alwaysSessionAsync=true;
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("producerWindowSize", Integer.toString(getProducerWindowSize()));
commit:0b769ee
/////////////////////////////////////////////////////////////////////////
1:             connection.setWatchTopicAdvisories(isWatchTopicAdvisories());
1:             connection.setProducerWindowSize(getProducerWindowSize());
commit:4e2acd4
/////////////////////////////////////////////////////////////////////////
1:     private boolean alwaysSyncSend;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return true if always sync send messages
1:      */
0:     public boolean isAlwaysSyncSend(){
1:         return this.alwaysSyncSend;
1:     }
1: 
1:     /**
1:      * Set true if always require messages to be sync sent
1:      * @param alwaysSyncSend
1:      */
0:     public void setAlwaysSyncSend(boolean alwaysSyncSend){
0:         this.alwaysSyncSend=alwaysSyncSend;
1:     }
/////////////////////////////////////////////////////////////////////////
0:         props.setProperty("alwaysSyncSend",Boolean.toString(isAlwaysSyncSend()));
commit:526cb5b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         props.setProperty("statsEnabled",Boolean.toString(isStatsEnabled()));
/////////////////////////////////////////////////////////////////////////
0: 
0:     
1:     /**
1:      * @return the statsEnabled
1:      */
0:     public boolean isStatsEnabled(){
1:         return this.factoryStats.isEnabled();
1:     }
0: 
0:     
1:     /**
1:      * @param statsEnabled the statsEnabled to set
1:      */
0:     public void setStatsEnabled(boolean statsEnabled){
1:         this.factoryStats.setEnabled(statsEnabled);
1:     }
commit:7a386be
/////////////////////////////////////////////////////////////////////////
0:     private boolean optimizeAcknowledge = false;
commit:d964145
/////////////////////////////////////////////////////////////////////////
0:     protected boolean asyncDispatch = false;
0:     protected boolean alwaysSessionAsync=true;
0:     private boolean optimizeAcknowledge = true;
/////////////////////////////////////////////////////////////////////////
1:             connection.setAlwaysSessionAsync(isAlwaysSessionAsync());
1:             connection.setOptimizeAcknowledge(isOptimizeAcknowledge());
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("alwaysSessionAsync", Boolean.toString(isAlwaysSessionAsync()));
1:         props.setProperty("optimizeAcknowledge", Boolean.toString(isOptimizeAcknowledge()));
0:         
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * @return Returns the alwaysSessionAsync.
1:      */
0:     public boolean isAlwaysSessionAsync(){
1:         return alwaysSessionAsync;
1:     }
0: 
1:     /**
0:      * @param alwaysSessionAsync The alwaysSessionAsync to set.
1:      */
0:     public void setAlwaysSessionAsync(boolean alwaysSessionAsync){
0:         this.alwaysSessionAsync=alwaysSessionAsync;
1:     }
0: 
1:     /**
1:      * @return Returns the optimizeAcknowledge.
1:      */
0:     public boolean isOptimizeAcknowledge(){
1:         return optimizeAcknowledge;
1:     }
0: 
1:     /**
1:      * @param optimizeAcknowledge The optimizeAcknowledge to set.
1:      */
0:     public void setOptimizeAcknowledge(boolean optimizeAcknowledge){
0:         this.optimizeAcknowledge=optimizeAcknowledge;
1:     }
commit:5fe0a4c
/////////////////////////////////////////////////////////////////////////
1:     private int closeTimeout = 15000;
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("closeTimeout", Integer.toString(getCloseTimeout()));
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * @return Returns the closeTimeout.
1:      */
0:     public int getCloseTimeout(){
1:         return closeTimeout;
1:     }
0: 
1:     /**
0:      * @param closeTimeout The closeTimeout to set.
1:      */
0:     public void setCloseTimeout(int closeTimeout){
0:         this.closeTimeout=closeTimeout;
1:     }
author:James Strachan
-------------------------------------------------------------------------------
commit:d483226
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransportListener;
/////////////////////////////////////////////////////////////////////////
1:     private TransportListener transportListener;
/////////////////////////////////////////////////////////////////////////
1:         if (transportListener != null) {
1:             connection.addTransportListener(transportListener);
1:         }
/////////////////////////////////////////////////////////////////////////
0: 
1:     public TransportListener getTransportListener() {
1:         return transportListener;
1:     }
0: 
1:     /**
1:      * Allows a listener to be configured on the ConnectionFactory so that when this factory is used
1:      * with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register
1:      * a transport listener.
0:      *
1:      * @param transportListener sets the listener to be registered on all connections
1:      * created by this factory
1:      */
1:     public void setTransportListener(TransportListener transportListener) {
1:         this.transportListener = transportListener;
1:     }
commit:677c22b
/////////////////////////////////////////////////////////////////////////
0: 
1:             configureConnection(connection);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected void configureConnection(ActiveMQConnection connection) {
0:         connection.setPrefetchPolicy(getPrefetchPolicy());
0:         connection.setDisableTimeStampsByDefault(isDisableTimeStampsByDefault());
0:         connection.setOptimizedMessageDispatch(isOptimizedMessageDispatch());
0:         connection.setCopyMessageOnSend(isCopyMessageOnSend());
0:         connection.setUseCompression(isUseCompression());
0:         connection.setObjectMessageSerializationDefered(isObjectMessageSerializationDefered());
1:         connection.setDispatchAsync(isDispatchAsync());
0:         connection.setUseAsyncSend(isUseAsyncSend());
0:         connection.setAlwaysSyncSend(isAlwaysSyncSend());
0:         connection.setAlwaysSessionAsync(isAlwaysSessionAsync());
0:         connection.setOptimizeAcknowledge(isOptimizeAcknowledge());
0:         connection.setUseRetroactiveConsumer(isUseRetroactiveConsumer());
0:         connection.setRedeliveryPolicy(getRedeliveryPolicy());
1:         connection.setTransformer(getTransformer());
1:         connection.setBlobTransferPolicy(getBlobTransferPolicy().copy());
0:         connection.setWatchTopicAdvisories(isWatchTopicAdvisories());
0:         connection.setProducerWindowSize(getProducerWindowSize());
1:         connection.setWarnAboutUnstartedConnectionTimeout(getWarnAboutUnstartedConnectionTimeout());
1:     }
0: 
commit:3d862f0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Connection;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.JMSException;
0: import javax.jms.QueueConnection;
0: import javax.jms.QueueConnectionFactory;
0: import javax.jms.TopicConnection;
0: import javax.jms.TopicConnectionFactory;
0: import javax.naming.Context;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Map;
0: import java.util.Properties;
0: import java.util.concurrent.Executor;
0: import java.util.concurrent.ScheduledThreadPoolExecutor;
0: import java.util.concurrent.ThreadFactory;
0: 
/////////////////////////////////////////////////////////////////////////
1:     private boolean exclusiveConsumer;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isExclusiveConsumer() {
1:         return exclusiveConsumer;
1:     }
0: 
1:     /**
0:      * Enables or disables whether or not queue consumers should be exclusive or not
0:      * for example to preserve ordering when not using
0:      * <a href="http://activemq.apache.org/message-groups.html">Message Groups</a>
0:      *
1:      * @param exclusiveConsumer
1:      */
1:     public void setExclusiveConsumer(boolean exclusiveConsumer) {
1:         this.exclusiveConsumer = exclusiveConsumer;
1:     }
0: 
commit:a92fb28
/////////////////////////////////////////////////////////////////////////
0:      * if the connection is not properly started via {@link Connection#start()} and a message is received by a consumer.
0:      *
0:      * It is a very common gotcha to forget to
commit:72cee90
/////////////////////////////////////////////////////////////////////////
0:      * Enables the timeout from a connection creation to when a warning is generated
commit:9d53c53
/////////////////////////////////////////////////////////////////////////
1:     private long warnAboutUnstartedConnectionTimeout = 500L;
/////////////////////////////////////////////////////////////////////////
0:             connection.setWarnAboutUnstartedConnectionTimeout(getWarnAboutUnstartedConnectionTimeout());
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:     public long getWarnAboutUnstartedConnectionTimeout() {
1:         return warnAboutUnstartedConnectionTimeout;
1:     }
0: 
1:     /**
0:      * Enables the timemout from a connection creation to when a warning is generated
0:      * if the connection is not properly started via {@link Connection#start()}. It is a very
0:      * common gotcha to forget to
0:      * <a href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start the connection</a>
0:      * so this option makes the default case to create a warning if the user forgets.
0:      * To disable the warning just set the value to < 0 (say -1).
1:      */
1:     public void setWarnAboutUnstartedConnectionTimeout(long warnAboutUnstartedConnectionTimeout) {
1:         this.warnAboutUnstartedConnectionTimeout = warnAboutUnstartedConnectionTimeout;
1:     }
commit:3753442
/////////////////////////////////////////////////////////////////////////
1:         IntrospectionSupport.getProperties(getBlobTransferPolicy(), props, "blobTransferPolicy.");
0: 
commit:52c22cc
/////////////////////////////////////////////////////////////////////////
0: 
1:         BlobTransferPolicy blobTransferPolicy = new BlobTransferPolicy();
0:         if ( IntrospectionSupport.setProperties(blobTransferPolicy, properties, "blobTransferPolicy.") ) {
1:             setBlobTransferPolicy(blobTransferPolicy);
0:             rc = true;
1:         }
0: 
0: 
commit:3013c20
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/configuring-transports.html">connection
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
/////////////////////////////////////////////////////////////////////////
0:      * href="http://activemq.apache.org/async-sends.html">Async Sends</a>
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
commit:05a8cba
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.blob.BlobTransferPolicy;
0: import javax.jms.Connection;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.JMSException;
0: import javax.jms.QueueConnection;
0: import javax.jms.QueueConnectionFactory;
0: import javax.jms.TopicConnection;
0: import javax.jms.TopicConnectionFactory;
0: import javax.naming.Context;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.Map;
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1:     // client policies
1:     private BlobTransferPolicy blobTransferPolicy = new BlobTransferPolicy();
/////////////////////////////////////////////////////////////////////////
0:             connection.setBlobTransferPolicy(getBlobTransferPolicy().copy());
/////////////////////////////////////////////////////////////////////////
1:     public BlobTransferPolicy getBlobTransferPolicy() {
1:         return blobTransferPolicy;
1:     }
0: 
1:     /**
0:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large OBjects)
0:      * are transferred from producers to brokers to consumers
1:      */
1:     public void setBlobTransferPolicy(BlobTransferPolicy blobTransferPolicy) {
1:         this.blobTransferPolicy = blobTransferPolicy;
1:     }
0: 
commit:86faaef
/////////////////////////////////////////////////////////////////////////
1:     private MessageTransformer transformer;
/////////////////////////////////////////////////////////////////////////
0:             connection.setTransformer(getTransformer());
/////////////////////////////////////////////////////////////////////////
1:     public MessageTransformer getTransformer() {
1:         return transformer;
1:     }
0: 
1:     /**
0:      * Sets the transformer used to transform messages before they are sent on to the JMS bus
0:      * or when they are received from the bus but before they are delivered to the JMS client
1:      */
1:     public void setTransformer(MessageTransformer transformer) {
1:         this.transformer = transformer;
1:     }
0: 
commit:7339c6e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IdGenerator;
/////////////////////////////////////////////////////////////////////////
0:     private IdGenerator clientIdGenerator;
0:     private String clientIDPrefix;
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQConnection connection = new ActiveMQConnection(transport, getClientIdGenerator(), stats);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public String getClientIDPrefix() {
1:         return clientIDPrefix;
1:     }
0: 
1:     /**
0:      * Sets the prefix used by autogenerated JMS Client ID values which are
0:      * used if the JMS client does not explicitly specify on.
0:      * 
1:      * @param clientIDPrefix
1:      */
1:     public void setClientIDPrefix(String clientIDPrefix) {
1:         this.clientIDPrefix = clientIDPrefix;
1:     }
0:     
1:     protected synchronized IdGenerator getClientIdGenerator() {
1:         if (clientIdGenerator == null) {
1:             if (clientIDPrefix != null) {
1:                 clientIdGenerator = new IdGenerator(clientIDPrefix);
1:             }
0:             else {
1:                 clientIdGenerator = new IdGenerator();
1:             }
1:         }
1:         return clientIdGenerator;
1:     }
0: 
1:     protected void setClientIdGenerator(IdGenerator clientIdGenerator) {
1:         this.clientIdGenerator = clientIdGenerator;
1:     }
commit:4b08ea5
/////////////////////////////////////////////////////////////////////////
1:     private boolean nestedMapAndListEnabled = true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Sets the <a
0:      * href="http://incubator.apache.org/activemq/configuring-transports.html">connection
1:      * URL</a> used to connect to the ActiveMQ broker.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Sets the JMS clientID to use for the created connection. Note that this can only be used by one connection at once so generally its a better idea
1:      * to set the clientID on a Connection
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Should a JMS message be copied to a new JMS Message object as part of the
1:      * send() method in JMS. This is enabled by default to be compliant with the
1:      * JMS specification. You can disable it if you do not mutate JMS messages
1:      * after they are sent for a performance boost
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets whether or not timestamps on messages should be disabled or not. If
1:      * you disable them it adds a small performance boost.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * If this flag is set then an larger prefetch limit is used - only
1:      * applicable for durable topic subscribers.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the JMS password used for connections created from this factory
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Forces the use of <a
0:      * href="http://incubator.apache.org/activemq/async-sends.html">Async Sends</a>
0:      * which adds a massive performance boost; but means that the send() method
0:      * will return immediately whether the message has been sent or not which
0:      * could lead to message loss.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the JMS userName used by connections created by this factory
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Enables the use of compression of the message bodies
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * When an object is set on an ObjectMessage, the JMS spec requires the
1:      * object to be serialized by that set method. Enabling this flag causes the
1:      * object to not get serialized. The object may subsequently get serialized
1:      * if the message needs to be sent over a socket or stored to disk.
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * Sets the timeout before a close is considered complete. Normally a
1:      * close() on a connection waits for confirmation from the broker; this
1:      * allows that operation to timeout to save the client hanging if there is
1:      * no broker
/////////////////////////////////////////////////////////////////////////
0:      * If this flag is set then a separate thread is not used for dispatching
0:      * messages for each Session in the Connection. However, a separate thread
0:      * is always used if there is more than one session, or the session isn't in
0:      * auto acknowledge or duplicates ok mode
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isNestedMapAndListEnabled() {
0:         return nestedMapAndListEnabled ;
0:     }
0: 
1:     /**
1:      * Enables/disables whether or not Message properties and MapMessage entries
1:      * support <a
0:      * href="http://incubator.apache.org/activemq/structured-message-properties-and-mapmessages.html">Nested
1:      * Structures</a> of Map and List objects
1:      */
1:     public void setNestedMapAndListEnabled(boolean structuredMapsEnabled) {
1:         this.nestedMapAndListEnabled = structuredMapsEnabled;
0:     }
commit:480433b
/////////////////////////////////////////////////////////////////////////
0:     protected boolean dispatchAsync = false;
/////////////////////////////////////////////////////////////////////////
0:             connection.setDispatchAsync(isDispatchAsync());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the <a
0:      * href="http://incubator.apache.org/activemq/what-is-the-prefetch-limit-for.html">prefetch
1:      * policy</a> for consumers created by this connection.
1:      */
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("dispatchAsync", Boolean.toString(isDispatchAsync()));
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDispatchAsync() {
1:         return dispatchAsync;
1:     /**
1:      * Enables or disables the default setting of whether or not consumers have
1:      * their messages <a
0:      * href="http://incubator.apache.org/activemq/consumer-dispatch-async.html">dispatched
0:      * synchronously or asynchronously by the broker</a>.
0:      * 
0:      * For non-durable topics for example we typically dispatch synchronously by
0:      * default to minimize context switches which boost performance. However
0:      * sometimes its better to go slower to ensure that a single blocked
0:      * consumer socket does not block delivery to other consumers.
0:      * 
0:      * @param asyncDispatch
0:      *            If true then consumers created on this connection will default
0:      *            to having their messages dispatched asynchronously. The
0:      *            default value is false.
1:      */
1:     public void setDispatchAsync(boolean asyncDispatch) {
1:         this.dispatchAsync = asyncDispatch;
commit:cedc2fb
/////////////////////////////////////////////////////////////////////////
1:         return createActiveMQConnection();
/////////////////////////////////////////////////////////////////////////
1:         return createActiveMQConnection();
/////////////////////////////////////////////////////////////////////////
0:         return createActiveMQConnection();
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected ActiveMQConnection createActiveMQConnection() throws JMSException {
0:         return createActiveMQConnection(userName, password);
0:     }
0: 
1:     protected ActiveMQConnection createActiveMQConnection(String userName, String password) throws JMSException {
0:             ActiveMQConnection connection = createActiveMQConnection(transport, factoryStats);
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQConnection createActiveMQConnection(Transport transport, JMSStatsImpl stats) throws Exception {
0:         ActiveMQConnection connection = new ActiveMQConnection(transport, stats);
1:         return connection;
0:     }
0: 
commit:5f5ccc0
/////////////////////////////////////////////////////////////////////////
1: public class ActiveMQConnectionFactory extends JNDIBaseStorable implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory, StatsCapable, Cloneable {
/////////////////////////////////////////////////////////////////////////
1:      * Returns a copy of the given connection factory
1:      */
1:     public ActiveMQConnectionFactory copy() {
1:         try {
0:             return (ActiveMQConnectionFactory) super.clone();
0:         }
0:         catch (CloneNotSupportedException e) {
1:             throw new RuntimeException("This should never happen: " + e, e);
0:         }
0:     }
0:     
0:     /**
commit:c8d74e7
/////////////////////////////////////////////////////////////////////////
commit:de7f650
/////////////////////////////////////////////////////////////////////////
0:             if (getRedeliveryPolicy() != null) {
0:                 connection.setRedeliveryPolicy(getRedeliveryPolicy());
0:             }
commit:ffb9d2a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.RedeliveryPolicy;
/////////////////////////////////////////////////////////////////////////
0:     private RedeliveryPolicy redeliveryPolicy;
0: 
/////////////////////////////////////////////////////////////////////////
0:             connection.setRedeliveryPolicy(getRedeliveryPolicy());
/////////////////////////////////////////////////////////////////////////
1:     public RedeliveryPolicy getRedeliveryPolicy() {
0:         return redeliveryPolicy;
0:     }
0: 
0:     /**
0:      * Sets the global redelivery policy to be used when a message is delivered but the session is rolled back
0:      */
1:     public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
0:         this.redeliveryPolicy = redeliveryPolicy;
0:     }
0: 
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:bd7d59c
/////////////////////////////////////////////////////////////////////////
0:     private boolean useSyncSend=false;
0:     private boolean watchTopicAdvisories=true;
/////////////////////////////////////////////////////////////////////////
0:             connection.setWatchTopicAdvisories(watchTopicAdvisories);
0:             
/////////////////////////////////////////////////////////////////////////
0: 	public void setUseSyncSend(boolean forceSyncSend) {
0: 		this.useSyncSend = forceSyncSend;
0: 	}
0: 
0: 	public synchronized boolean isWatchTopicAdvisories() {
0: 		return watchTopicAdvisories;
0: 	}
0: 
0: 	public synchronized void setWatchTopicAdvisories(boolean watchTopicAdvisories) {
0: 		this.watchTopicAdvisories = watchTopicAdvisories;
0: 	}    
0:     
/////////////////////////////////////////////////////////////////////////
1:         props.setProperty("watchTopicAdvisories", Boolean.toString(isWatchTopicAdvisories()));
0:         
commit:e5b45f6
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQConnection connection=null;
0:         	Transport transport = createTransport();
0:         	connection = createActiveMQConnection(transport, factoryStats);
0:         	
/////////////////////////////////////////////////////////////////////////
0:         	// Clean up!
0:         	try { connection.close(); } catch ( Throwable ignore ) {}
0:         	// Clean up!
0:         	try { connection.close(); } catch ( Throwable ignore ) {}
0:         	throw JMSExceptionSupport.create("Could not connect to broker URL: " + brokerURL + ". Reason: " + e, e);
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:0f59ecc
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (getBrokerURL() != null) {
1:             props.setProperty(Context.PROVIDER_URL, getBrokerURL());
1:             props.setProperty("brokerURL", getBrokerURL());
0:         }
0: 
1:         if (getClientID() != null) {
0:         }
0: 
0: 
1:         if (getPassword() != null) {
1:             props.setProperty("password", getPassword());
0:         }
0: 
0: 
1:         if (getUserName() != null) {
1:             props.setProperty("userName", getUserName());
0:         }
0:         
0: 
commit:b9a4dee
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.jndi.JNDIBaseStorable;
/////////////////////////////////////////////////////////////////////////
0: public class ActiveMQConnectionFactory extends JNDIBaseStorable implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory, StatsCapable {
/////////////////////////////////////////////////////////////////////////
1:     public void buildFromProperties(Properties properties) {
/////////////////////////////////////////////////////////////////////////
1:     public void populateProperties(Properties props) {
0:         props.setProperty(Context.PROVIDER_URL, getBrokerURL());
0:         if (getClientID() != null)
1:             props.setProperty("clientID", getClientID());
/////////////////////////////////////////////////////////////////////////
0:         props.setProperty("userName", getUserName());
/////////////////////////////////////////////////////////////////////////
commit:2ddd372
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
0: import javax.naming.Referenceable;
0: import javax.naming.Reference;
0: import javax.naming.NamingException;
/////////////////////////////////////////////////////////////////////////
0: public class ActiveMQConnectionFactory implements ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory, StatsCapable, Referenceable {
/////////////////////////////////////////////////////////////////////////
0:     public Properties getProperties() {
0:         Properties props = new Properties();
0:         props.setProperty("asyncDispatch", Boolean.toString(isAsyncDispatch()));
0:         props.setProperty("brokerURL", getBrokerURL());
0:         props.setProperty("clientID", getClientID());
1:         props.setProperty("copyMessageOnSend", Boolean.toString(isCopyMessageOnSend()));
1:         props.setProperty("disableTimeStampsByDefault", Boolean.toString(isDisableTimeStampsByDefault()));
1:         props.setProperty("objectMessageSerializationDefered", Boolean.toString(isObjectMessageSerializationDefered()));
0:         props.setProperty("onSendPrepareMessageBody", Boolean.toString(isOnSendPrepareMessageBody()));
1:         props.setProperty("optimizedMessageDispatch", Boolean.toString(isOptimizedMessageDispatch()));
0:         props.setProperty("password", getPassword());
1:         props.setProperty("useAsyncSend", Boolean.toString(isUseAsyncSend()));
1:         props.setProperty("useCompression", Boolean.toString(isUseCompression()));
1:         props.setProperty("useRetroactiveConsumer", Boolean.toString(isUseRetroactiveConsumer()));
0:         props.setProperty("username", getUserName());
0: 
0:         return props;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Retrieve a Reference for this instance to store in JNDI
0:      *
0:      * @return the built Reference
0:      * @throws NamingException if error on building Reference
0:      */
0:     public Reference getReference() throws NamingException {
0:         Reference ref = new Reference(this.getClass().getName());
0: 
0:         try {
0:             Properties props = getProperties();
0:             for (Enumeration iter = props.propertyNames(); iter.hasMoreElements();) {
0:                 String key = (String) iter.nextElement();
0:                 String value = props.getProperty(key);
0:                 javax.naming.StringRefAddr addr = new javax.naming.StringRefAddr(key, value);
0:                 ref.add(addr);
0:             }
0:         } catch (Exception e) {
0:             throw new NamingException(e.getMessage());
0:         }
0:         return ref;
0:     }
0: 
============================================================================