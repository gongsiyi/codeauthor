3:7ae2055: /**
1:7ae2055:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7ae2055:  * contributor license agreements.  See the NOTICE file distributed with
1:7ae2055:  * this work for additional information regarding copyright ownership.
1:7ae2055:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7ae2055:  * (the "License"); you may not use this file except in compliance with
1:7ae2055:  * the License.  You may obtain a copy of the License at
1:7ae2055:  *
1:7ae2055:  *      http://www.apache.org/licenses/LICENSE-2.0
1:7ae2055:  *
1:7ae2055:  * Unless required by applicable law or agreed to in writing, software
1:7ae2055:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7ae2055:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ae2055:  * See the License for the specific language governing permissions and
1:7ae2055:  * limitations under the License.
3:7ae2055:  */
1:7ae2055: package org.apache.activemq.broker.scheduler;
1:c7c8e53: 
1:f21992e: import java.io.IOException;
1:7ae2055: import java.util.concurrent.atomic.AtomicBoolean;
1:667f26a: 
1:7ae2055: import org.apache.activemq.ScheduledMessage;
1:667f26a: import org.apache.activemq.advisory.AdvisorySupport;
1:7ae2055: import org.apache.activemq.broker.Broker;
1:7ae2055: import org.apache.activemq.broker.BrokerFilter;
1:f21992e: import org.apache.activemq.broker.BrokerService;
1:74a5381: import org.apache.activemq.broker.Connection;
1:7ae2055: import org.apache.activemq.broker.ConnectionContext;
1:74a5381: import org.apache.activemq.broker.Connector;
1:7ae2055: import org.apache.activemq.broker.ProducerBrokerExchange;
1:74a5381: import org.apache.activemq.broker.region.ConnectionStatistics;
1:667f26a: import org.apache.activemq.command.ActiveMQDestination;
1:74a5381: import org.apache.activemq.command.Command;
1:74a5381: import org.apache.activemq.command.ConnectionControl;
1:74a5381: import org.apache.activemq.command.ExceptionResponse;
1:7ae2055: import org.apache.activemq.command.Message;
1:7ae2055: import org.apache.activemq.command.MessageId;
1:7ae2055: import org.apache.activemq.command.ProducerId;
1:7ae2055: import org.apache.activemq.command.ProducerInfo;
1:74a5381: import org.apache.activemq.command.Response;
1:7ae2055: import org.apache.activemq.openwire.OpenWireFormat;
1:7ae2055: import org.apache.activemq.security.SecurityContext;
1:7ae2055: import org.apache.activemq.state.ProducerState;
1:7a11f59: import org.apache.activemq.transaction.Synchronization;
1:f21992e: import org.apache.activemq.usage.JobSchedulerUsage;
1:f21992e: import org.apache.activemq.usage.SystemUsage;
1:f21992e: import org.apache.activemq.util.ByteSequence;
1:7ae2055: import org.apache.activemq.util.IdGenerator;
1:7ae2055: import org.apache.activemq.util.LongSequenceGenerator;
1:7ae2055: import org.apache.activemq.util.TypeConversionSupport;
1:7ae2055: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:e3154c3: 
1:7ae2055: public class SchedulerBroker extends BrokerFilter implements JobListener {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(SchedulerBroker.class);
1:7ae2055:     private static final IdGenerator ID_GENERATOR = new IdGenerator();
1:76490a2:     private static final LongSequenceGenerator longGenerator = new LongSequenceGenerator();
1:7ae2055:     private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
1:7ae2055:     private final AtomicBoolean started = new AtomicBoolean();
1:7ae2055:     private final WireFormat wireFormat = new OpenWireFormat();
1:7ae2055:     private final ConnectionContext context = new ConnectionContext();
1:7ae2055:     private final ProducerId producerId = new ProducerId();
1:f21992e:     private final SystemUsage systemUsage;
1:c7c8e53: 
1:f21992e:     private final JobSchedulerStore store;
1:7ae2055:     private JobScheduler scheduler;
1:c7c8e53: 
1:f21992e:     public SchedulerBroker(BrokerService brokerService, Broker next, JobSchedulerStore store) throws Exception {
1:7ae2055:         super(next);
1:f21992e: 
1:f21992e:         this.store = store;
1:7ae2055:         this.producerId.setConnectionId(ID_GENERATOR.generateId());
1:7ae2055:         this.context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
1:74a5381:         // we only get response on unexpected error
1:74a5381:         this.context.setConnection(new Connection() {
1:74a5381:             @Override
1:74a5381:             public Connector getConnector() {
1:74a5381:                 return null;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public void dispatchSync(Command message) {
1:74a5381:                 if (message instanceof ExceptionResponse) {
1:74a5381:                     LOG.warn("Unexpected response: " + message);
1:74a5381:                 }
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public void dispatchAsync(Command command) {
1:74a5381:                 if (command instanceof ExceptionResponse) {
1:74a5381:                     LOG.warn("Unexpected response: " + command);
1:74a5381:                 }
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public Response service(Command command) {
1:74a5381:                 return null;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public void serviceException(Throwable error) {
1:74a5381:                 LOG.warn("Unexpected exception: " + error, error);
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public boolean isSlow() {
1:74a5381:                 return false;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public boolean isBlocked() {
1:74a5381:                 return false;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public boolean isConnected() {
1:74a5381:                 return false;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public boolean isActive() {
1:74a5381:                 return false;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public int getDispatchQueueSize() {
1:74a5381:                 return 0;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public ConnectionStatistics getStatistics() {
1:74a5381:                 return null;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public boolean isManageable() {
1:74a5381:                 return false;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public String getRemoteAddress() {
1:74a5381:                 return null;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public void serviceExceptionAsync(IOException e) {
1:74a5381:                 LOG.warn("Unexpected async ioexception: " + e, e);
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public String getConnectionId() {
1:74a5381:                 return null;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public boolean isNetworkConnection() {
1:74a5381:                 return false;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public boolean isFaultTolerantConnection() {
1:74a5381:                 return false;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public void updateClient(ConnectionControl control) {}
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public int getActiveTransactionCount() {
1:74a5381:                 return 0;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public Long getOldestActiveTransactionDuration() {
1:74a5381:                 return null;
1:74a5381:             }
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public void start() throws Exception {}
1:74a5381: 
1:74a5381:             @Override
1:74a5381:             public void stop() throws Exception {}
1:74a5381:         });
1:f21992e:         this.context.setBroker(next);
1:f21992e:         this.systemUsage = brokerService.getSystemUsage();
1:f21992e: 
1:ec9975c:         wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
1:667f26a:     }
1:667f26a: 
1:e3154c3:     public synchronized JobScheduler getJobScheduler() throws Exception {
1:c7c8e53:         return new JobSchedulerFacade(this);
1:667f26a:     }
1:667f26a: 
1:7ae2055:     @Override
1:7ae2055:     public void start() throws Exception {
1:7ae2055:         this.started.set(true);
1:e8a4a32:         getInternalScheduler();
1:7ae2055:         super.start();
1:667f26a:     }
1:ec9975c: 
1:7ae2055:     @Override
1:7ae2055:     public void stop() throws Exception {
1:7ae2055:         if (this.started.compareAndSet(true, false)) {
1:e3154c3: 
1:7ae2055:             if (this.store != null) {
1:7ae2055:                 this.store.stop();
1:667f26a:             }
1:7ae2055:             if (this.scheduler != null) {
1:7ae2055:                 this.scheduler.removeListener(this);
1:7ae2055:                 this.scheduler = null;
1:667f26a:             }
1:667f26a:         }
1:7ae2055:         super.stop();
1:667f26a:     }
1:e3154c3: 
1:7ae2055:     @Override
1:7a11f59:     public void send(ProducerBrokerExchange producerExchange, final Message messageSend) throws Exception {
1:7a11f59:         ConnectionContext context = producerExchange.getConnectionContext();
1:7a11f59: 
1:7a11f59:         final String jobId = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_ID);
1:7a11f59:         final Object cronValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);
1:7a11f59:         final Object periodValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD);
1:7a11f59:         final Object delayValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY);
1:e3154c3: 
1:667f26a:         String physicalName = messageSend.getDestination().getPhysicalName();
1:f21992e:         boolean schedularManage = physicalName.regionMatches(true, 0, ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION, 0,
1:f21992e:             ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION.length());
1:667f26a: 
1:667f26a:         if (schedularManage == true) {
1:667f26a: 
1:315b00f:             JobScheduler scheduler = getInternalScheduler();
1:315b00f:             ActiveMQDestination replyTo = messageSend.getReplyTo();
1:667f26a: 
1:315b00f:             String action = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION);
1:667f26a: 
1:f21992e:             if (action != null) {
1:667f26a: 
1:315b00f:                 Object startTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME);
1:315b00f:                 Object endTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME);
1:667f26a: 
1:315b00f:                 if (replyTo != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE)) {
1:667f26a: 
1:f21992e:                     if (startTime != null && endTime != null) {
1:667f26a: 
1:315b00f:                         long start = (Long) TypeConversionSupport.convert(startTime, Long.class);
1:315b00f:                         long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);
1:667f26a: 
1:315b00f:                         for (Job job : scheduler.getAllJobs(start, finish)) {
1:315b00f:                             sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);
1:315b00f:                         }
1:315b00f:                     } else {
1:315b00f:                         for (Job job : scheduler.getAllJobs()) {
1:315b00f:                             sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);
1:315b00f:                         }
1:315b00f:                     }
1:315b00f:                 }
1:315b00f:                 if (jobId != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE)) {
1:315b00f:                     scheduler.remove(jobId);
1:315b00f:                 } else if (action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL)) {
1:667f26a: 
1:f21992e:                     if (startTime != null && endTime != null) {
1:667f26a: 
1:315b00f:                         long start = (Long) TypeConversionSupport.convert(startTime, Long.class);
1:315b00f:                         long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);
1:667f26a: 
1:315b00f:                         scheduler.removeAllJobs(start, finish);
1:315b00f:                     } else {
1:315b00f:                         scheduler.removeAllJobs();
1:315b00f:                     }
1:315b00f:                 }
1:315b00f:             }
1:667f26a: 
1:667f26a:         } else if ((cronValue != null || periodValue != null || delayValue != null) && jobId == null) {
1:e3154c3: 
1:1359e8e:             // Check for room in the job scheduler store
1:1359e8e:             if (systemUsage.getJobSchedulerUsage() != null) {
1:1359e8e:                 JobSchedulerUsage usage = systemUsage.getJobSchedulerUsage();
1:1359e8e:                 if (usage.isFull()) {
1:1359e8e:                     final String logMessage = "Job Scheduler Store is Full (" +
1:1359e8e:                         usage.getPercentUsage() + "% of " + usage.getLimit() +
1:1359e8e:                         "). Stopping producer (" + messageSend.getProducerId() +
1:1359e8e:                         ") to prevent flooding of the job scheduler store." +
1:1359e8e:                         " See http://activemq.apache.org/producer-flow-control.html for more info";
1:1359e8e: 
1:1359e8e:                     long start = System.currentTimeMillis();
1:1359e8e:                     long nextWarn = start;
1:1359e8e:                     while (!usage.waitForSpace(1000)) {
1:1359e8e:                         if (context.getStopping().get()) {
1:1359e8e:                             throw new IOException("Connection closed, send aborted.");
1:1359e8e:                         }
1:1359e8e: 
1:1359e8e:                         long now = System.currentTimeMillis();
1:1359e8e:                         if (now >= nextWarn) {
1:1359e8e:                             LOG.info("" + usage + ": " + logMessage + " (blocking for: " + (now - start) / 1000 + "s)");
1:1359e8e:                             nextWarn = now + 30000l;
1:1359e8e:                         }
1:1359e8e:                     }
1:1359e8e:                 }
1:1359e8e:             }
1:1359e8e: 
1:7a11f59:             if (context.isInTransaction()) {
1:7a11f59:                 context.getTransaction().addSynchronization(new Synchronization() {
1:7a11f59:                     @Override
1:7a11f59:                     public void afterCommit() throws Exception {
1:7a11f59:                         doSchedule(messageSend, cronValue, periodValue, delayValue);
1:7a11f59:                     }
1:7a11f59:                 });
1:7a11f59:             } else {
1:7a11f59:                 doSchedule(messageSend, cronValue, periodValue, delayValue);
1:7a11f59:             }
2:667f26a:         } else {
1:7ae2055:             super.send(producerExchange, messageSend);
1:f21992e:         }
1:f21992e:     }
1:f21992e: 
1:7a11f59:     private void doSchedule(Message messageSend, Object cronValue, Object periodValue, Object delayValue) throws Exception {
1:7a11f59:         long delay = 0;
1:7a11f59:         long period = 0;
1:7a11f59:         int repeat = 0;
1:7a11f59:         String cronEntry = "";
1:7a11f59: 
1:7a11f59:         // clear transaction context
1:7a11f59:         Message msg = messageSend.copy();
1:7a11f59:         msg.setTransactionId(null);
1:7a11f59:         org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(msg);
1:7a11f59:         if (cronValue != null) {
1:7a11f59:             cronEntry = cronValue.toString();
1:7a11f59:         }
1:7a11f59:         if (periodValue != null) {
1:7a11f59:             period = (Long) TypeConversionSupport.convert(periodValue, Long.class);
1:7a11f59:         }
1:7a11f59:         if (delayValue != null) {
1:7a11f59:             delay = (Long) TypeConversionSupport.convert(delayValue, Long.class);
1:7a11f59:         }
1:7a11f59:         Object repeatValue = msg.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
1:7a11f59:         if (repeatValue != null) {
1:7a11f59:             repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
1:7a11f59:         }
1:7a11f59: 
1:76490a2:         //job id should be unique for every job (Same format as MessageId)
1:76490a2:         MessageId jobId = new MessageId(messageSend.getMessageId().getProducerId(), longGenerator.getNextSequenceId());
1:76490a2: 
1:76490a2:         getInternalScheduler().schedule(jobId.toString(),
1:e0aa091:                 new ByteSequence(packet.data, packet.offset, packet.length), cronEntry, delay, period, repeat);
1:7a11f59:     }
1:7a11f59: 
1:f21992e:     @Override
1:7ae2055:     public void scheduledJob(String id, ByteSequence job) {
1:f21992e:         org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(job.getData(), job.getOffset(), job.getLength());
1:667f26a:         try {
1:014d559:             Message messageSend = (Message) wireFormat.unmarshal(packet);
1:7ae2055:             messageSend.setOriginalTransactionId(null);
1:e3154c3:             Object repeatValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
1:315b00f:             Object cronValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);
1:e3154c3:             String cronStr = cronValue != null ? cronValue.toString() : null;
1:e3154c3:             int repeat = 0;
1:667f26a:             if (repeatValue != null) {
1:667f26a:                 repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
1:f21992e:             }
1:f21992e: 
1:667f26a:             if (repeat != 0 || cronStr != null && cronStr.length() > 0) {
1:667f26a:                 // create a unique id - the original message could be sent
1:667f26a:                 // lots of times
1:014d559:                 messageSend.setMessageId(new MessageId(producerId, messageIdGenerator.getNextSequenceId()));
1:f21992e:             }
1:667f26a: 
1:e3154c3:             // Add the jobId as a property
1:c7c8e53:             messageSend.setProperty("scheduledJobId", id);
1:667f26a: 
1:e3154c3:             // if this goes across a network - we don't want it rescheduled
1:7ae2055:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD);
1:e3154c3:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY);
1:7ae2055:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
1:e3154c3:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);
1:e3154c3: 
1:315b00f:             if (messageSend.getTimestamp() > 0 && messageSend.getExpiration() > 0) {
1:315b00f: 
1:315b00f:                 long oldExpiration = messageSend.getExpiration();
1:315b00f:                 long newTimeStamp = System.currentTimeMillis();
1:315b00f:                 long timeToLive = 0;
1:315b00f:                 long oldTimestamp = messageSend.getTimestamp();
1:315b00f: 
1:315b00f:                 if (oldExpiration > 0) {
1:315b00f:                     timeToLive = oldExpiration - oldTimestamp;
1:f21992e:                 }
1:315b00f: 
1:315b00f:                 long expiration = timeToLive + newTimeStamp;
1:315b00f: 
1:f21992e:                 if (expiration > oldExpiration) {
1:315b00f:                     if (timeToLive > 0 && expiration > 0) {
1:315b00f:                         messageSend.setExpiration(expiration);
1:315b00f:                     }
1:315b00f:                     messageSend.setTimestamp(newTimeStamp);
1:e1bbde7:                     LOG.debug("Set message {} timestamp from {} to {}", new Object[]{ messageSend.getMessageId(), oldTimestamp, newTimeStamp });
1:315b00f:                 }
1:315b00f:             }
1:315b00f: 
1:014d559:             // Repackage the message contents prior to send now that all updates are complete.
1:014d559:             messageSend.beforeMarshall(wireFormat);
1:014d559: 
1:667f26a:             final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:667f26a:             producerExchange.setConnectionContext(context);
1:667f26a:             producerExchange.setMutable(true);
1:667f26a:             producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:7ae2055:             super.send(producerExchange, messageSend);
1:7ae2055:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Failed to send scheduled message {}", id, e);
1:315b00f:         }
1:315b00f:     }
1:e3154c3: 
1:e3154c3:     protected synchronized JobScheduler getInternalScheduler() throws Exception {
1:7ae2055:         if (this.started.get()) {
1:8635a06:             if (this.scheduler == null && store != null) {
1:f21992e:                 this.scheduler = store.getJobScheduler("JMS");
1:7ae2055:                 this.scheduler.addListener(this);
1:2d861da:                 this.scheduler.startDispatching();
1:667f26a:             }
1:7ae2055:             return this.scheduler;
1:667f26a:         }
2:7ae2055:         return null;
1:667f26a:     }
1:e3154c3: 
1:f21992e:     protected void sendScheduledJob(ConnectionContext context, Job job, ActiveMQDestination replyTo) throws Exception {
1:e3154c3: 
1:667f26a:         org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(job.getPayload());
1:667f26a:         try {
1:667f26a:             Message msg = (Message) this.wireFormat.unmarshal(packet);
1:667f26a:             msg.setOriginalTransactionId(null);
1:315b00f:             msg.setPersistent(false);
1:315b00f:             msg.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);
1:315b00f:             msg.setMessageId(new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
1:c691124: 
1:c691124:             // Preserve original destination
1:c691124:             msg.setOriginalDestination(msg.getDestination());
1:c691124: 
1:315b00f:             msg.setDestination(replyTo);
1:315b00f:             msg.setResponseRequired(false);
1:315b00f:             msg.setProducerId(this.producerId);
1:667f26a: 
1:667f26a:             // Add the jobId as a property
1:315b00f:             msg.setProperty("scheduledJobId", job.getJobId());
1:667f26a: 
1:315b00f:             final boolean originalFlowControl = context.isProducerFlowControl();
1:315b00f:             final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:315b00f:             producerExchange.setConnectionContext(context);
1:315b00f:             producerExchange.setMutable(true);
1:315b00f:             producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:315b00f:             try {
1:315b00f:                 context.setProducerFlowControl(false);
1:315b00f:                 this.next.send(producerExchange, msg);
1:315b00f:             } finally {
1:315b00f:                 context.setProducerFlowControl(originalFlowControl);
1:315b00f:             }
1:667f26a:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Failed to send scheduled message {}", job.getJobId(), e);
1:315b00f:         }
1:667f26a:     }
1:667f26a: }
============================================================================
author:Jeff Genender
-------------------------------------------------------------------------------
commit:76490a2
/////////////////////////////////////////////////////////////////////////
1:     private static final LongSequenceGenerator longGenerator = new LongSequenceGenerator();
/////////////////////////////////////////////////////////////////////////
1:         //job id should be unique for every job (Same format as MessageId)
1:         MessageId jobId = new MessageId(messageSend.getMessageId().getProducerId(), longGenerator.getNextSequenceId());
1: 
1:         getInternalScheduler().schedule(jobId.toString(),
author:gtully
-------------------------------------------------------------------------------
commit:e0aa091
/////////////////////////////////////////////////////////////////////////
0:         String jobId = ID_GENERATOR.generateId();
0:         getInternalScheduler().schedule(jobId,
1:                 new ByteSequence(packet.data, packet.offset, packet.length), cronEntry, delay, period, repeat);
commit:74a5381
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Connection;
1: import org.apache.activemq.broker.Connector;
1: import org.apache.activemq.broker.region.ConnectionStatistics;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConnectionControl;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
1:         // we only get response on unexpected error
1:         this.context.setConnection(new Connection() {
1:             @Override
1:             public Connector getConnector() {
1:                 return null;
1:             }
1: 
1:             @Override
1:             public void dispatchSync(Command message) {
1:                 if (message instanceof ExceptionResponse) {
1:                     LOG.warn("Unexpected response: " + message);
1:                 }
1:             }
1: 
1:             @Override
1:             public void dispatchAsync(Command command) {
1:                 if (command instanceof ExceptionResponse) {
1:                     LOG.warn("Unexpected response: " + command);
1:                 }
1:             }
1: 
1:             @Override
1:             public Response service(Command command) {
1:                 return null;
1:             }
1: 
1:             @Override
1:             public void serviceException(Throwable error) {
1:                 LOG.warn("Unexpected exception: " + error, error);
1:             }
1: 
1:             @Override
1:             public boolean isSlow() {
1:                 return false;
1:             }
1: 
1:             @Override
1:             public boolean isBlocked() {
1:                 return false;
1:             }
1: 
1:             @Override
1:             public boolean isConnected() {
1:                 return false;
1:             }
1: 
1:             @Override
1:             public boolean isActive() {
1:                 return false;
1:             }
1: 
1:             @Override
1:             public int getDispatchQueueSize() {
1:                 return 0;
1:             }
1: 
1:             @Override
1:             public ConnectionStatistics getStatistics() {
1:                 return null;
1:             }
1: 
1:             @Override
1:             public boolean isManageable() {
1:                 return false;
1:             }
1: 
1:             @Override
1:             public String getRemoteAddress() {
1:                 return null;
1:             }
1: 
1:             @Override
1:             public void serviceExceptionAsync(IOException e) {
1:                 LOG.warn("Unexpected async ioexception: " + e, e);
1:             }
1: 
1:             @Override
1:             public String getConnectionId() {
1:                 return null;
1:             }
1: 
1:             @Override
1:             public boolean isNetworkConnection() {
1:                 return false;
1:             }
1: 
1:             @Override
1:             public boolean isFaultTolerantConnection() {
1:                 return false;
1:             }
1: 
1:             @Override
1:             public void updateClient(ConnectionControl control) {}
1: 
1:             @Override
1:             public int getActiveTransactionCount() {
1:                 return 0;
1:             }
1: 
1:             @Override
1:             public Long getOldestActiveTransactionDuration() {
1:                 return null;
1:             }
1: 
1:             @Override
1:             public void start() throws Exception {}
1: 
1:             @Override
1:             public void stop() throws Exception {}
1:         });
commit:1359e8e
/////////////////////////////////////////////////////////////////////////
1:             // Check for room in the job scheduler store
1:             if (systemUsage.getJobSchedulerUsage() != null) {
1:                 JobSchedulerUsage usage = systemUsage.getJobSchedulerUsage();
1:                 if (usage.isFull()) {
1:                     final String logMessage = "Job Scheduler Store is Full (" +
1:                         usage.getPercentUsage() + "% of " + usage.getLimit() +
1:                         "). Stopping producer (" + messageSend.getProducerId() +
1:                         ") to prevent flooding of the job scheduler store." +
1:                         " See http://activemq.apache.org/producer-flow-control.html for more info";
1: 
1:                     long start = System.currentTimeMillis();
1:                     long nextWarn = start;
1:                     while (!usage.waitForSpace(1000)) {
1:                         if (context.getStopping().get()) {
1:                             throw new IOException("Connection closed, send aborted.");
1:                         }
1: 
1:                         long now = System.currentTimeMillis();
1:                         if (now >= nextWarn) {
1:                             LOG.info("" + usage + ": " + logMessage + " (blocking for: " + (now - start) / 1000 + "s)");
1:                             nextWarn = now + 30000l;
1:                         }
1:                     }
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
author:Erik Wramner
-------------------------------------------------------------------------------
commit:c691124
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Preserve original destination
1:             msg.setOriginalDestination(msg.getDestination());
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:014d559
/////////////////////////////////////////////////////////////////////////
1:             Message messageSend = (Message) wireFormat.unmarshal(packet);
/////////////////////////////////////////////////////////////////////////
1:                 messageSend.setMessageId(new MessageId(producerId, messageIdGenerator.getNextSequenceId()));
/////////////////////////////////////////////////////////////////////////
1:             // Repackage the message contents prior to send now that all updates are complete.
1:             messageSend.beforeMarshall(wireFormat);
1: 
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Set message {} timestamp from {} to {}", new Object[]{ messageSend.getMessageId(), oldTimestamp, newTimeStamp });
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Failed to send scheduled message {}", id, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Failed to send scheduled message {}", job.getJobId(), e);
author:Gary Tully
-------------------------------------------------------------------------------
commit:8635a06
/////////////////////////////////////////////////////////////////////////
1:             if (this.scheduler == null && store != null) {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2d861da
/////////////////////////////////////////////////////////////////////////
1:                 this.scheduler.startDispatching();
commit:7a11f59
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transaction.Synchronization;
/////////////////////////////////////////////////////////////////////////
1:     public void send(ProducerBrokerExchange producerExchange, final Message messageSend) throws Exception {
1:         ConnectionContext context = producerExchange.getConnectionContext();
1: 
1:         final String jobId = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_ID);
1:         final Object cronValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);
1:         final Object periodValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD);
1:         final Object delayValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY);
/////////////////////////////////////////////////////////////////////////
1:             if (context.isInTransaction()) {
1:                 context.getTransaction().addSynchronization(new Synchronization() {
1:                     @Override
1:                     public void afterCommit() throws Exception {
1:                         doSchedule(messageSend, cronValue, periodValue, delayValue);
1:                     }
1:                 });
1:             } else {
1:                 doSchedule(messageSend, cronValue, periodValue, delayValue);
1:             }
1:     private void doSchedule(Message messageSend, Object cronValue, Object periodValue, Object delayValue) throws Exception {
1:         long delay = 0;
1:         long period = 0;
1:         int repeat = 0;
1:         String cronEntry = "";
1: 
1:         // clear transaction context
1:         Message msg = messageSend.copy();
1:         msg.setTransactionId(null);
1:         org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(msg);
1:         if (cronValue != null) {
1:             cronEntry = cronValue.toString();
1:         }
1:         if (periodValue != null) {
1:             period = (Long) TypeConversionSupport.convert(periodValue, Long.class);
1:         }
1:         if (delayValue != null) {
1:             delay = (Long) TypeConversionSupport.convert(delayValue, Long.class);
1:         }
1:         Object repeatValue = msg.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
1:         if (repeatValue != null) {
1:             repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
1:         }
1: 
0:         getInternalScheduler().schedule(msg.getMessageId().toString(),
0:             new ByteSequence(packet.data, packet.offset, packet.length), cronEntry, delay, period, repeat);
1:     }
1: 
commit:df2c7bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f21992e
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.JobSchedulerUsage;
1: import org.apache.activemq.usage.SystemUsage;
1: import org.apache.activemq.util.ByteSequence;
/////////////////////////////////////////////////////////////////////////
1:     private final SystemUsage systemUsage;
1:     private final JobSchedulerStore store;
1:     public SchedulerBroker(BrokerService brokerService, Broker next, JobSchedulerStore store) throws Exception {
1: 
1:         this.store = store;
1:         this.context.setBroker(next);
1:         this.systemUsage = brokerService.getSystemUsage();
/////////////////////////////////////////////////////////////////////////
1:         boolean schedularManage = physicalName.regionMatches(true, 0, ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION, 0,
1:             ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION.length());
/////////////////////////////////////////////////////////////////////////
1:             if (action != null) {
1:                     if (startTime != null && endTime != null) {
/////////////////////////////////////////////////////////////////////////
1:                     if (startTime != null && endTime != null) {
/////////////////////////////////////////////////////////////////////////
0:             // clear transaction context
/////////////////////////////////////////////////////////////////////////
0:                 period = (Long) TypeConversionSupport.convert(periodValue, Long.class);
/////////////////////////////////////////////////////////////////////////
0:             getInternalScheduler().schedule(msg.getMessageId().toString(), new ByteSequence(packet.data, packet.offset, packet.length), cronEntry, delay,
0:                 period, repeat);
1:     @Override
1:         org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(job.getData(), job.getOffset(), job.getLength());
/////////////////////////////////////////////////////////////////////////
0:             // Check for room in the job scheduler store
0:             if (systemUsage.getJobSchedulerUsage() != null) {
0:                 JobSchedulerUsage usage = systemUsage.getJobSchedulerUsage();
0:                 if (usage.isFull()) {
0:                     final String logMessage = "Job Scheduler Store is Full (" +
0:                         usage.getPercentUsage() + "% of " + usage.getLimit() +
0:                         "). Stopping producer (" + messageSend.getProducerId() +
0:                         ") to prevent flooding of the job scheduler store." +
0:                         " See http://activemq.apache.org/producer-flow-control.html for more info";
1: 
0:                     long start = System.currentTimeMillis();
0:                     long nextWarn = start;
0:                     while (!usage.waitForSpace(1000)) {
0:                         if (context.getStopping().get()) {
0:                             throw new IOException("Connection closed, send aborted.");
1:                         }
1: 
0:                         long now = System.currentTimeMillis();
0:                         if (now >= nextWarn) {
0:                             LOG.info("" + usage + ": " + logMessage + " (blocking for: " + (now - start) / 1000 + "s)");
0:                             nextWarn = now + 30000l;
1:                         }
1:                     }
1:                 }
1:             }
1: 
0:                 messageSend.setMessageId(new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
/////////////////////////////////////////////////////////////////////////
1:                 if (expiration > oldExpiration) {
/////////////////////////////////////////////////////////////////////////
1:                 this.scheduler = store.getJobScheduler("JMS");
/////////////////////////////////////////////////////////////////////////
1:     protected void sendScheduledJob(ConnectionContext context, Job job, ActiveMQDestination replyTo) throws Exception {
commit:315b00f
/////////////////////////////////////////////////////////////////////////
0:                 ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION, 0,
0:                 ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION.length());
1:             JobScheduler scheduler = getInternalScheduler();
1:             ActiveMQDestination replyTo = messageSend.getReplyTo();
1:             String action = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION);
0:             if (action != null ) {
1:                 Object startTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME);
1:                 Object endTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME);
1:                 if (replyTo != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE)) {
0:                     if( startTime != null && endTime != null ) {
1:                         long start = (Long) TypeConversionSupport.convert(startTime, Long.class);
1:                         long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);
1:                         for (Job job : scheduler.getAllJobs(start, finish)) {
1:                             sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);
1:                         }
1:                     } else {
1:                         for (Job job : scheduler.getAllJobs()) {
1:                             sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);
1:                         }
1:                     }
1:                 }
1:                 if (jobId != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE)) {
1:                     scheduler.remove(jobId);
1:                 } else if (action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL)) {
0:                     if( startTime != null && endTime != null ) {
1:                         long start = (Long) TypeConversionSupport.convert(startTime, Long.class);
1:                         long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);
1:                         scheduler.removeAllJobs(start, finish);
1:                     } else {
1:                         scheduler.removeAllJobs();
1:                     }
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:             Object cronValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);
/////////////////////////////////////////////////////////////////////////
0:                         new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
/////////////////////////////////////////////////////////////////////////
1:             if (messageSend.getTimestamp() > 0 && messageSend.getExpiration() > 0) {
1: 
1:                 long oldExpiration = messageSend.getExpiration();
1:                 long newTimeStamp = System.currentTimeMillis();
1:                 long timeToLive = 0;
1:                 long oldTimestamp = messageSend.getTimestamp();
1: 
1:                 if (oldExpiration > 0) {
1:                     timeToLive = oldExpiration - oldTimestamp;
1:                 }
1: 
1:                 long expiration = timeToLive + newTimeStamp;
1: 
0:                 if(expiration > oldExpiration) {
1:                     if (timeToLive > 0 && expiration > 0) {
1:                         messageSend.setExpiration(expiration);
1:                     }
1:                     messageSend.setTimestamp(newTimeStamp);
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Set message " + messageSend.getMessageId() + " timestamp from " + oldTimestamp + " to " + newTimeStamp);
1:                     }
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected void sendScheduledJob(ConnectionContext context, Job job, ActiveMQDestination replyTo)
0:             throws Exception {
1:             msg.setPersistent(false);
1:             msg.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);
1:             msg.setMessageId(new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
1:             msg.setDestination(replyTo);
1:             msg.setResponseRequired(false);
1:             msg.setProducerId(this.producerId);
1:             msg.setProperty("scheduledJobId", job.getJobId());
1:             final boolean originalFlowControl = context.isProducerFlowControl();
1:             final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:             producerExchange.setConnectionContext(context);
1:             producerExchange.setMutable(true);
1:             producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:             try {
1:                 context.setProducerFlowControl(false);
1:                 this.next.send(producerExchange, msg);
1:             } finally {
1:                 context.setProducerFlowControl(originalFlowControl);
1:             }
1:     }
commit:667f26a
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.advisory.AdvisorySupport;
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
0:         String jobId = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_ID);
1:         String physicalName = messageSend.getDestination().getPhysicalName();
0:         boolean schedularManage = physicalName.regionMatches(true, 0,
0:         		ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION, 0,
0:         		ScheduledMessage.AMQ_SCHEDULER_MANAGEMENT_DESTINATION.length());
1: 
1:         if (schedularManage == true) {
1: 
0:         	JobScheduler scheduler = getInternalScheduler();
0: 	        ActiveMQDestination replyTo = messageSend.getReplyTo();
1: 
0: 	        String action = (String) messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION);
1: 
0: 	        if (action != null ) {
1: 
0: 	        	Object startTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_START_TIME);
0: 	        	Object endTime = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULER_ACTION_END_TIME);
1: 
0: 		        if (replyTo != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_BROWSE)) {
1: 
0: 		        	if( startTime != null && endTime != null ) {
1: 
0: 		                long start = (Long) TypeConversionSupport.convert(startTime, Long.class);
0: 		                long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);
1: 
0: 			        	for (Job job : scheduler.getAllJobs(start, finish)) {
0: 			        		sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);
1: 			        	}
1: 		        	} else {
0: 			        	for (Job job : scheduler.getAllJobs()) {
0: 			        		sendScheduledJob(producerExchange.getConnectionContext(), job, replyTo);
1: 			        	}
1: 		        	}
1: 		        }
0: 		        if (jobId != null && action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVE)) {
0: 		        	scheduler.remove(jobId);
0: 		        } else if (action.equals(ScheduledMessage.AMQ_SCHEDULER_ACTION_REMOVEALL)) {
1: 
0: 		        	if( startTime != null && endTime != null ) {
1: 
0: 		                long start = (Long) TypeConversionSupport.convert(startTime, Long.class);
0: 		                long finish = (Long) TypeConversionSupport.convert(endTime, Long.class);
1: 
0: 		                scheduler.removeAllJobs(start, finish);
1: 		        	} else {
0: 			        	scheduler.removeAllJobs();
1: 		        	}
1: 		        }
1: 	        }
1: 
1:         } else if ((cronValue != null || periodValue != null || delayValue != null) && jobId == null) {
0:             if (cronValue != null) {
0:                 cronEntry = cronValue.toString();
1:             }
0:             if (periodValue != null) {
0:               period = (Long) TypeConversionSupport.convert(periodValue, Long.class);
1:             }
0:             if (delayValue != null) {
0:                 delay = (Long) TypeConversionSupport.convert(delayValue, Long.class);
1:             }
0:             Object repeatValue = msg.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
1:             if (repeatValue != null) {
1:                 repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
1:             }
0:             getInternalScheduler().schedule(msg.getMessageId().toString(),
0:                     new ByteSequence(packet.data, packet.offset, packet.length),cronEntry, delay, period, repeat);
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (repeat != 0 || cronStr != null && cronStr.length() > 0) {
1:                 // create a unique id - the original message could be sent
1:                 // lots of times
0:                 messageSend.setMessageId(
0:                 		new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	protected void sendScheduledJob(ConnectionContext context, Job job, ActiveMQDestination replyTo)
0: 			throws Exception {
1: 
1:         org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(job.getPayload());
1:         try {
1:             Message msg = (Message) this.wireFormat.unmarshal(packet);
1:             msg.setOriginalTransactionId(null);
0:     		msg.setPersistent(false);
0:     		msg.setType(AdvisorySupport.ADIVSORY_MESSAGE_TYPE);
0:     		msg.setMessageId(new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
0:     		msg.setDestination(replyTo);
0:     		msg.setResponseRequired(false);
0:     		msg.setProducerId(this.producerId);
1: 
1:             // Add the jobId as a property
0:     		msg.setProperty("scheduledJobId", job.getJobId());
1: 
0:     		final boolean originalFlowControl = context.isProducerFlowControl();
1:     		final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:     		producerExchange.setConnectionContext(context);
1:     		producerExchange.setMutable(true);
1:     		producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:     		try {
0:     			context.setProducerFlowControl(false);
0:     			this.next.send(producerExchange, msg);
0:     		} finally {
0:     			context.setProducerFlowControl(originalFlowControl);
0:     		}
1:         } catch (Exception e) {
0:             LOG.error("Failed to send scheduled message " + job.getJobId(), e);
0:         }
1: 
0: 	}
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
1: 
1:         wireFormat.setVersion(brokerService.getStoreOpenWireVersion());
commit:58aca86
commit:0484af1
/////////////////////////////////////////////////////////////////////////
0:                 String clazz = "org.apache.activemq.store.kahadb.scheduler.JobSchedulerStoreImpl";
0:                 this.store = (JobSchedulerStore) getClass().getClassLoader().loadClass(clazz).newInstance();
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ByteSequence;
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(SchedulerBroker.class);
commit:e8a4a32
/////////////////////////////////////////////////////////////////////////
1:         getInternalScheduler();
author:Robert Davies
-------------------------------------------------------------------------------
commit:cc40251
/////////////////////////////////////////////////////////////////////////
0:             //clear transaction context
0:             Message msg = messageSend.copy();
0:             msg.setTransactionId(null);
0:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(msg);
/////////////////////////////////////////////////////////////////////////
0:                 Object repeatValue = msg.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
0:                 getInternalScheduler().schedule(msg.getMessageId().toString(),
commit:e75affa
/////////////////////////////////////////////////////////////////////////
0:         Object delayValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY);
0:         if (cronValue != null || periodValue != null || delayValue != null) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e3154c3
/////////////////////////////////////////////////////////////////////////
1: 
1:     public synchronized JobScheduler getJobScheduler() throws Exception {
1: 
/////////////////////////////////////////////////////////////////////////
0:         long delay = 0;
0:         String cronEntry = "";
0:         Object cronValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);
0:         if (cronValue != null || periodValue != null) {
0:                 if (cronValue != null) {
0:                     cronEntry = cronValue.toString();
0:                 }
0:                 if (periodValue != null) {      
0:                   period = (Long) TypeConversionSupport.convert(periodValue, Long.class);
0:                 }
0:                 Object delayValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY);
0:                 if (delayValue != null) {
0:                     delay = (Long) TypeConversionSupport.convert(delayValue, Long.class);
0:                 }
1:                 Object repeatValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
0:                 if (repeatValue != null) {
0:                     repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
0:                 }
1:                 
0:                 getInternalScheduler().schedule(messageSend.getMessageId().toString(),
0:                         new ByteSequence(packet.data, packet.offset, packet.length),cronEntry, delay, period, repeat);
1:             
/////////////////////////////////////////////////////////////////////////
0:             Object cronValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
1:             String cronStr = cronValue != null ? cronValue.toString() : null;
1:             int repeat = 0;
0:                 repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
0:             }
1:   
0:                 if (repeat != 0 || cronStr != null && cronStr.length() > 0) {
0:                     // create a unique id - the original message could be sent
0:                     // lots of times
0:                     messageSend
0:                             .setMessageId(new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
1:             
1:             // Add the jobId as a property
1: 
1:             // if this goes across a network - we don't want it rescheduled
1:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY);
1:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_CRON);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected synchronized JobScheduler getInternalScheduler() throws Exception {
/////////////////////////////////////////////////////////////////////////
commit:c7c8e53
/////////////////////////////////////////////////////////////////////////
1:    
0:     public synchronized  JobScheduler getJobScheduler() throws Exception {
1:         return new JobSchedulerFacade(this);
0:     }
1:    
/////////////////////////////////////////////////////////////////////////
0:             getInternalScheduler().schedule( messageSend.getMessageId().toString(),
/////////////////////////////////////////////////////////////////////////
0:             //Add the jobId as a property
1:             messageSend.setProperty("scheduledJobId", id);
1:             
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected synchronized  JobScheduler getInternalScheduler() throws Exception {
0:                 this.scheduler = getStore().getJobScheduler("JMS");
/////////////////////////////////////////////////////////////////////////
0:     
0: 
commit:7ae2055
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.scheduler;
0: 
0: import java.io.File;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import org.apache.activemq.ScheduledMessage;
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerFilter;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.ProducerBrokerExchange;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.openwire.OpenWireFormat;
1: import org.apache.activemq.security.SecurityContext;
1: import org.apache.activemq.state.ProducerState;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.util.LongSequenceGenerator;
1: import org.apache.activemq.util.TypeConversionSupport;
1: import org.apache.activemq.wireformat.WireFormat;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.kahadb.util.ByteSequence;
0: 
1: public class SchedulerBroker extends BrokerFilter implements JobListener {
0:     private static final Log LOG = LogFactory.getLog(SchedulerBroker.class);
1:     private static final IdGenerator ID_GENERATOR = new IdGenerator();
1:     private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
1:     private final AtomicBoolean started = new AtomicBoolean();
1:     private final WireFormat wireFormat = new OpenWireFormat();
1:     private final ConnectionContext context = new ConnectionContext();
1:     private final ProducerId producerId = new ProducerId();
0:     private File directory;
0: 
0:     private JobSchedulerStore store;
1:     private JobScheduler scheduler;
0: 
0:     public SchedulerBroker(Broker next, File directory) throws Exception {
1:         super(next);
0:         this.directory = directory;
1:         this.producerId.setConnectionId(ID_GENERATOR.generateId());
1:         this.context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
0:         context.setBroker(next);
0:         LOG.info("Scheduler using directory: " + directory);
0: 
0:     }
1:     /**
0:      * @return the directory
1:      */
0:     public File getDirectory() {
0:         return this.directory;
0:     }
1:     /**
0:      * @param directory
0:      *            the directory to set
1:      */
0:     public void setDirectory(File directory) {
0:         this.directory = directory;
0:     }
0: 
1:     @Override
1:     public void start() throws Exception {
1:         this.started.set(true);
1:         super.start();
0:     }
0: 
1:     @Override
1:     public void stop() throws Exception {
1:         if (this.started.compareAndSet(true, false)) {
0: 
1:             if (this.store != null) {
1:                 this.store.stop();
0:             }
1:             if (this.scheduler != null) {
1:                 this.scheduler.removeListener(this);
1:                 this.scheduler = null;
0:             }
0:         }
1:         super.stop();
0:     }
0: 
1:     @Override
0:     public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {
0:         long start = 0;
0:         long period = 0;
0:         int repeat = 0;
0: 
0:         Object periodValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD);
0: 
0:         if (periodValue != null) {
0:             period = (Long) TypeConversionSupport.convert(periodValue, Long.class);
0:             Object startValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_START);
0:             if (startValue != null) {
0:                 start = (Long) TypeConversionSupport.convert(startValue, Long.class);
0:             }
0:             Object repeatValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
0:             if (repeatValue != null) {
0:                 repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
0:             }
0:             org.apache.activemq.util.ByteSequence packet = wireFormat.marshal(messageSend);
0:             getScheduler().schedule( messageSend.getMessageId().toString(),
0:                     new ByteSequence(packet.data, packet.offset, packet.length),start, period, repeat);
0: 
0:         } else {
0: 
1:             super.send(producerExchange, messageSend);
0:         }
0:     }
0: 
1:     public void scheduledJob(String id, ByteSequence job) {
0:         org.apache.activemq.util.ByteSequence packet = new org.apache.activemq.util.ByteSequence(job.getData(), job
0:                 .getOffset(), job.getLength());
0:         try {
0:             Message messageSend = (Message) this.wireFormat.unmarshal(packet);
1:             messageSend.setOriginalTransactionId(null);
0:             Object repeatValue = messageSend.getProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
0:             if (repeatValue != null) {
0:                 int repeat = (Integer) TypeConversionSupport.convert(repeatValue, Integer.class);
0:                 if (repeat != 0) {
0:                     //create a unique id - the original message could be sent lots of times
0:                     messageSend.setMessageId(new MessageId(this.producerId, this.messageIdGenerator.getNextSequenceId()));
0:                 }
0:             }   
0:            
0:             //if this goes across a network - we don't want it rescheduled
1:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD);
0:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_START);
1:             messageSend.removeProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT);
0:             
0:             final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
0:             producerExchange.setConnectionContext(context);
0:             producerExchange.setMutable(true);
0:             producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:             super.send(producerExchange, messageSend);
1:         } catch (Exception e) {
0:             LOG.error("Failed to send scheduled message " + id, e);
0:         }
0: 
0:     }
0: 
0:     private JobScheduler getScheduler() throws Exception {
1:         if (this.started.get()) {
0:             if (this.scheduler == null) {
0:                 this.scheduler = getStore().getJobScheduler("ActiveMQ");
1:                 this.scheduler.addListener(this);
0:             }
1:             return this.scheduler;
0:         }
1:         return null;
0:     }
0: 
0:     private JobSchedulerStore getStore() throws Exception {
0:         if (started.get()) {
0:             if (this.store == null) {
0:                 this.store = new JobSchedulerStore();
0:                 this.store.setDirectory(directory);
0:                 this.store.start();
0:             }
0:             return this.store;
0:         }
1:         return null;
0:     }
0: 
0: }
============================================================================