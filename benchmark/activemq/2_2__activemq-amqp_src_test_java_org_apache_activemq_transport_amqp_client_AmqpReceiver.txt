1:cec3245: /*
1:72839b7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:72839b7:  * contributor license agreements.  See the NOTICE file distributed with
1:72839b7:  * this work for additional information regarding copyright ownership.
1:72839b7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:72839b7:  * (the "License"); you may not use this file except in compliance with
1:72839b7:  * the License.  You may obtain a copy of the License at
2:72839b7:  *
1:72839b7:  *      http://www.apache.org/licenses/LICENSE-2.0
1:72839b7:  *
1:72839b7:  * Unless required by applicable law or agreed to in writing, software
1:72839b7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72839b7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72839b7:  * See the License for the specific language governing permissions and
1:72839b7:  * limitations under the License.
1:72839b7:  */
1:72839b7: package org.apache.activemq.transport.amqp.client;
3:72839b7: 
1:72839b7: import static org.apache.activemq.transport.amqp.AmqpSupport.COPY;
1:72839b7: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_NAME;
1:72839b7: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_NAME;
1:72839b7: 
1:72839b7: import java.io.ByteArrayOutputStream;
1:72839b7: import java.io.IOException;
1:72839b7: import java.util.HashMap;
1:72839b7: import java.util.Map;
1:72839b7: import java.util.concurrent.BlockingQueue;
1:72839b7: import java.util.concurrent.LinkedBlockingDeque;
1:8448cf1: import java.util.concurrent.ScheduledFuture;
1:72839b7: import java.util.concurrent.TimeUnit;
1:72839b7: import java.util.concurrent.atomic.AtomicBoolean;
1:72839b7: 
1:72839b7: import javax.jms.InvalidDestinationException;
1:72839b7: 
1:8448cf1: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
1:72839b7: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
1:82a5839: import org.apache.activemq.transport.amqp.client.util.IOExceptionSupport;
1:fddbac2: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
1:8448cf1: import org.apache.qpid.jms.JmsOperationTimedOutException;
1:272fb2b: import org.apache.qpid.proton.amqp.Binary;
1:72839b7: import org.apache.qpid.proton.amqp.DescribedType;
1:72839b7: import org.apache.qpid.proton.amqp.Symbol;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Accepted;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Modified;
1:6a2ffca: import org.apache.qpid.proton.amqp.messaging.Rejected;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Released;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Source;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.Target;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
1:272fb2b: import org.apache.qpid.proton.amqp.transaction.TransactionalState;
1:72839b7: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1:72839b7: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1:72839b7: import org.apache.qpid.proton.engine.Delivery;
1:72839b7: import org.apache.qpid.proton.engine.Receiver;
1:72839b7: import org.apache.qpid.proton.message.Message;
1:72839b7: import org.slf4j.Logger;
1:72839b7: import org.slf4j.LoggerFactory;
1:72839b7: 
2:72839b7: /**
1:72839b7:  * Receiver class that manages a Proton receiver endpoint.
1:72839b7:  */
1:72839b7: public class AmqpReceiver extends AmqpAbstractResource<Receiver> {
1:72839b7: 
1:72839b7:     private static final Logger LOG = LoggerFactory.getLogger(AmqpReceiver.class);
1:72839b7: 
1:72839b7:     private final AtomicBoolean closed = new AtomicBoolean();
1:381a1ae:     private final BlockingQueue<AmqpMessage> prefetch = new LinkedBlockingDeque<>();
1:72839b7: 
1:72839b7:     private final AmqpSession session;
1:72839b7:     private final String address;
1:72839b7:     private final String receiverId;
1:381a1ae: 
1:8e6a404:     private final Source userSpecifiedSource;
1:381a1ae:     private final SenderSettleMode userSpecifiedSenderSettlementMode;
1:381a1ae:     private final ReceiverSettleMode userSpecifiedReceiverSettlementMode;
1:72839b7: 
1:72839b7:     private String subscriptionName;
1:72839b7:     private String selector;
1:72839b7:     private boolean presettle;
1:72839b7:     private boolean noLocal;
1:72839b7: 
1:8448cf1:     private AsyncResult pullRequest;
1:8448cf1:     private AsyncResult stopRequest;
1:8448cf1: 
1:72839b7:     /**
1:72839b7:      * Create a new receiver instance.
1:72839b7:      *
1:72839b7:      * @param session
1:381a1ae:      *        The parent session that created the receiver.
1:72839b7:      * @param address
1:72839b7:      *        The address that this receiver should listen on.
1:72839b7:      * @param receiverId
1:72839b7:      *        The unique ID assigned to this receiver.
1:72839b7:      */
1:72839b7:     public AmqpReceiver(AmqpSession session, String address, String receiverId) {
1:381a1ae:         this(session, address, receiverId, null, null);
1:381a1ae:     }
1:381a1ae: 
1:381a1ae:     /**
1:381a1ae:      * Create a new receiver instance.
1:381a1ae:      *
1:381a1ae:      * @param session
1:381a1ae:      * 		  The parent session that created the receiver.
1:381a1ae:      * @param address
1:381a1ae:      *        The address that this receiver should listen on.
1:381a1ae:      * @param receiverId
1:381a1ae:      *        The unique ID assigned to this receiver.
1:381a1ae:      * @param senderMode
1:381a1ae:      *        The {@link SenderSettleMode} to use on open.
1:381a1ae:      * @param receiverMode
1:381a1ae:      *        The {@link ReceiverSettleMode} to use on open.
1:381a1ae:      */
1:381a1ae:     public AmqpReceiver(AmqpSession session, String address, String receiverId, SenderSettleMode senderMode, ReceiverSettleMode receiverMode) {
1:4228e3d: 
1:4228e3d:         if (address != null && address.isEmpty()) {
1:4228e3d:             throw new IllegalArgumentException("Address cannot be empty.");
1:4228e3d:         }
1:4228e3d: 
1:8e6a404:         this.userSpecifiedSource = null;
1:72839b7:         this.session = session;
1:72839b7:         this.address = address;
1:72839b7:         this.receiverId = receiverId;
1:381a1ae:         this.userSpecifiedSenderSettlementMode = senderMode;
1:381a1ae:         this.userSpecifiedReceiverSettlementMode = receiverMode;
2:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:ca456c4:      * Create a new receiver instance.
1:ca456c4:      *
1:ca456c4:      * @param session
1:ca456c4:      *        The parent session that created the receiver.
1:ca456c4:      * @param source
1:ca456c4:      *        The Source instance to use instead of creating and configuring one.
1:ca456c4:      * @param receiverId
1:ca456c4:      *        The unique ID assigned to this receiver.
1:ca456c4:      */
1:ca456c4:     public AmqpReceiver(AmqpSession session, Source source, String receiverId) {
1:ca456c4: 
1:ca456c4:         if (source == null) {
1:ca456c4:             throw new IllegalArgumentException("User specified Source cannot be null");
1:ca456c4:         }
1:ca456c4: 
1:ca456c4:         this.session = session;
1:ca456c4:         this.userSpecifiedSource = source;
1:ca456c4:         this.address = source.getAddress();
1:ca456c4:         this.receiverId = receiverId;
1:381a1ae:         this.userSpecifiedSenderSettlementMode = null;
1:381a1ae:         this.userSpecifiedReceiverSettlementMode = null;
1:ca456c4:     }
1:ca456c4: 
1:ca456c4:     /**
1:934ad44:      * Close the receiver, a closed receiver will throw exceptions if any further send
1:72839b7:      * calls are made.
1:72839b7:      *
1:934ad44:      * @throws IOException if an error occurs while closing the receiver.
1:72839b7:      */
1:72839b7:     public void close() throws IOException {
1:72839b7:         if (closed.compareAndSet(false, true)) {
1:72839b7:             final ClientFuture request = new ClientFuture();
1:72839b7:             session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:                 @Override
1:72839b7:                 public void run() {
1:72839b7:                     checkClosed();
1:72839b7:                     close(request);
1:8448cf1:                     session.pumpToProtonTransport(request);
1:72839b7:                 }
1:72839b7:             });
1:72839b7: 
1:72839b7:             request.sync();
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:934ad44:      * Detach the receiver, a closed receiver will throw exceptions if any further send
1:934ad44:      * calls are made.
1:934ad44:      *
1:934ad44:      * @throws IOException if an error occurs while closing the receiver.
1:934ad44:      */
1:934ad44:     public void detach() throws IOException {
1:934ad44:         if (closed.compareAndSet(false, true)) {
1:934ad44:             final ClientFuture request = new ClientFuture();
1:934ad44:             session.getScheduler().execute(new Runnable() {
1:934ad44: 
1:934ad44:                 @Override
1:934ad44:                 public void run() {
1:934ad44:                     checkClosed();
1:934ad44:                     detach(request);
1:8448cf1:                     session.pumpToProtonTransport(request);
1:934ad44:                 }
1:934ad44:             });
1:934ad44: 
1:934ad44:             request.sync();
1:934ad44:         }
1:934ad44:     }
1:934ad44: 
1:934ad44:     /**
1:72839b7:      * @return this session's parent AmqpSession.
1:72839b7:      */
1:72839b7:     public AmqpSession getSession() {
1:72839b7:         return session;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the address that this receiver has been configured to listen on.
1:72839b7:      */
1:72839b7:     public String getAddress() {
1:72839b7:         return address;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Attempts to wait on a message to be delivered to this receiver.  The receive
1:72839b7:      * call will wait indefinitely for a message to be delivered.
1:72839b7:      *
1:72839b7:      * @return a newly received message sent to this receiver.
1:72839b7:      *
1:72839b7:      * @throws Exception if an error occurs during the receive attempt.
1:72839b7:      */
1:72839b7:     public AmqpMessage receive() throws Exception {
1:72839b7:         checkClosed();
1:72839b7:         return prefetch.take();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Attempts to receive a message sent to this receiver, waiting for the given
1:72839b7:      * timeout value before giving up and returning null.
1:72839b7:      *
1:72839b7:      * @param timeout
1:72839b7:      * 	      the time to wait for a new message to arrive.
1:72839b7:      * @param unit
1:72839b7:      * 		  the unit of time that the timeout value represents.
1:72839b7:      *
1:72839b7:      * @return a newly received message or null if the time to wait period expires.
1:72839b7:      *
1:72839b7:      * @throws Exception if an error occurs during the receive attempt.
1:72839b7:      */
1:72839b7:     public AmqpMessage receive(long timeout, TimeUnit unit) throws Exception {
1:72839b7:         checkClosed();
1:72839b7:         return prefetch.poll(timeout, unit);
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * If a message is already available in this receiver's prefetch buffer then
1:72839b7:      * it is returned immediately otherwise this methods return null without waiting.
1:72839b7:      *
1:72839b7:      * @return a newly received message or null if there is no currently available message.
1:72839b7:      *
1:72839b7:      * @throws Exception if an error occurs during the receive attempt.
1:72839b7:      */
1:72839b7:     public AmqpMessage receiveNoWait() throws Exception {
1:72839b7:         checkClosed();
1:72839b7:         return prefetch.poll();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:8448cf1:      * Request a remote peer send a Message to this client waiting until one arrives.
1:8448cf1:      *
1:8448cf1:      * @return the pulled AmqpMessage or null if none was pulled from the remote.
1:8448cf1:      *
1:8448cf1:      * @throws IOException if an error occurs
1:8448cf1:      */
1:8448cf1:     public AmqpMessage pull() throws IOException {
1:8448cf1:         return pull(-1, TimeUnit.MILLISECONDS);
1:8448cf1:     }
1:8448cf1: 
1:8448cf1:     /**
1:8448cf1:      * Request a remote peer send a Message to this client using an immediate drain request.
1:8448cf1:      *
1:8448cf1:      * @return the pulled AmqpMessage or null if none was pulled from the remote.
1:8448cf1:      *
1:8448cf1:      * @throws IOException if an error occurs
1:8448cf1:      */
1:8448cf1:     public AmqpMessage pullImmediate() throws IOException {
1:8448cf1:         return pull(0, TimeUnit.MILLISECONDS);
1:8448cf1:     }
1:8448cf1: 
1:8448cf1:     /**
1:8448cf1:      * Request a remote peer send a Message to this client.
1:8448cf1:      *
1:8448cf1:      *   {@literal timeout < 0} then it should remain open until a message is received.
1:8448cf1:      *   {@literal timeout = 0} then it returns a message or null if none available
1:8448cf1:      *   {@literal timeout > 0} then it should remain open for timeout amount of time.
1:8448cf1:      *
1:8448cf1:      * The timeout value when positive is given in milliseconds.
1:8448cf1:      *
1:8448cf1:      * @param timeout
1:8448cf1:      *        the amount of time to tell the remote peer to keep this pull request valid.
1:8448cf1:      * @param unit
1:8448cf1:      *        the unit of measure that the timeout represents.
1:8448cf1:      *
1:8448cf1:      * @return the pulled AmqpMessage or null if none was pulled from the remote.
1:8448cf1:      *
1:8448cf1:      * @throws IOException if an error occurs
1:8448cf1:      */
1:8448cf1:     public AmqpMessage pull(final long timeout, final TimeUnit unit) throws IOException {
1:8448cf1:         checkClosed();
1:8448cf1:         final ClientFuture request = new ClientFuture();
1:8448cf1:         session.getScheduler().execute(new Runnable() {
1:8448cf1: 
1:8448cf1:             @Override
1:8448cf1:             public void run() {
1:8448cf1:                 checkClosed();
1:8448cf1: 
1:8448cf1:                 long timeoutMills = unit.toMillis(timeout);
1:8448cf1: 
1:8448cf1:                 try {
1:8448cf1:                     LOG.trace("Pull on Receiver {} with timeout = {}", getSubscriptionName(), timeoutMills);
1:8448cf1:                     if (timeoutMills < 0) {
1:8448cf1:                         // Wait until message arrives. Just give credit if needed.
1:8448cf1:                         if (getEndpoint().getCredit() == 0) {
1:8448cf1:                             LOG.trace("Receiver {} granting 1 additional credit for pull.", getSubscriptionName());
1:8448cf1:                             getEndpoint().flow(1);
1:8448cf1:                         }
1:8448cf1: 
1:8448cf1:                         // Await the message arrival
1:8448cf1:                         pullRequest = request;
1:8448cf1:                     } else if (timeoutMills == 0) {
1:8448cf1:                         // If we have no credit then we need to issue some so that we can
1:8448cf1:                         // try to fulfill the request, then drain down what is there to
1:8448cf1:                         // ensure we consume what is available and remove all credit.
1:8448cf1:                         if (getEndpoint().getCredit() == 0){
1:8448cf1:                             LOG.trace("Receiver {} granting 1 additional credit for pull.", getSubscriptionName());
1:8448cf1:                             getEndpoint().flow(1);
1:8448cf1:                         }
1:8448cf1: 
1:8448cf1:                         // Drain immediately and wait for the message(s) to arrive,
1:8448cf1:                         // or a flow indicating removal of the remaining credit.
1:8448cf1:                         stop(request);
1:8448cf1:                     } else if (timeoutMills > 0) {
1:8448cf1:                         // If we have no credit then we need to issue some so that we can
1:8448cf1:                         // try to fulfill the request, then drain down what is there to
1:8448cf1:                         // ensure we consume what is available and remove all credit.
1:8448cf1:                         if (getEndpoint().getCredit() == 0) {
1:8448cf1:                             LOG.trace("Receiver {} granting 1 additional credit for pull.", getSubscriptionName());
1:8448cf1:                             getEndpoint().flow(1);
1:8448cf1:                         }
1:8448cf1: 
1:8448cf1:                         // Wait for the timeout for the message(s) to arrive, then drain if required
1:8448cf1:                         // and wait for remaining message(s) to arrive or a flow indicating
1:8448cf1:                         // removal of the remaining credit.
1:8448cf1:                         stopOnSchedule(timeoutMills, request);
1:8448cf1:                     }
1:8448cf1: 
1:8448cf1:                     session.pumpToProtonTransport(request);
1:8448cf1:                 } catch (Exception e) {
1:8448cf1:                     request.onFailure(e);
1:8448cf1:                 }
1:8448cf1:             }
1:8448cf1:         });
1:8448cf1: 
1:8448cf1:         request.sync();
1:8448cf1: 
1:8448cf1:         return prefetch.poll();
1:8448cf1:     }
1:8448cf1: 
1:8448cf1: 
1:8448cf1:     /**
1:72839b7:      * Controls the amount of credit given to the receiver link.
1:72839b7:      *
1:72839b7:      * @param credit
1:72839b7:      *        the amount of credit to grant.
1:72839b7:      *
1:72839b7:      * @throws IOException if an error occurs while sending the flow.
1:72839b7:      */
1:72839b7:     public void flow(final int credit) throws IOException {
1:72839b7:         checkClosed();
1:72839b7:         final ClientFuture request = new ClientFuture();
1:72839b7:         session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:72839b7:                 try {
1:72839b7:                     getEndpoint().flow(credit);
1:8448cf1:                     session.pumpToProtonTransport(request);
1:72839b7:                     request.onSuccess();
1:72839b7:                 } catch (Exception e) {
1:72839b7:                     request.onFailure(e);
1:72839b7:                 }
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Attempts to drain a given amount of credit from the link.
1:72839b7:      *
1:72839b7:      * @param credit
1:72839b7:      *        the amount of credit to drain.
1:72839b7:      *
1:72839b7:      * @throws IOException if an error occurs while sending the drain.
1:72839b7:      */
1:72839b7:     public void drain(final int credit) throws IOException {
1:72839b7:         checkClosed();
1:72839b7:         final ClientFuture request = new ClientFuture();
1:72839b7:         session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:72839b7:                 try {
1:72839b7:                     getEndpoint().drain(credit);
1:8448cf1:                     session.pumpToProtonTransport(request);
1:72839b7:                     request.onSuccess();
1:72839b7:                 } catch (Exception e) {
1:72839b7:                     request.onFailure(e);
1:72839b7:                 }
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:8448cf1:      * Stops the receiver, using all link credit and waiting for in-flight messages to arrive.
1:8448cf1:      *
1:8448cf1:      * @throws IOException if an error occurs while sending the drain.
1:8448cf1:      */
1:8448cf1:     public void stop() throws IOException {
1:8448cf1:         checkClosed();
1:8448cf1:         final ClientFuture request = new ClientFuture();
1:8448cf1:         session.getScheduler().execute(new Runnable() {
1:8448cf1: 
1:8448cf1:             @Override
1:8448cf1:             public void run() {
1:8448cf1:                 checkClosed();
1:8448cf1:                 try {
1:8448cf1:                     stop(request);
1:8448cf1:                     session.pumpToProtonTransport(request);
1:8448cf1:                 } catch (Exception e) {
1:8448cf1:                     request.onFailure(e);
1:8448cf1:                 }
1:8448cf1:             }
1:8448cf1:         });
1:8448cf1: 
1:8448cf1:         request.sync();
1:8448cf1:     }
1:8448cf1: 
1:8448cf1:     /**
1:5d53aa2:      * Accepts a message that was dispatched under the given Delivery instance and settles the delivery.
1:72839b7:      *
1:72839b7:      * @param delivery
1:72839b7:      *        the Delivery instance to accept.
1:72839b7:      *
1:72839b7:      * @throws IOException if an error occurs while sending the accept.
1:72839b7:      */
1:5d53aa2:     public void accept(Delivery delivery) throws IOException {
1:5d53aa2:         accept(delivery, this.session, true);
1:b4ab0e1:     }
1:b4ab0e1: 
1:b4ab0e1:     /**
1:b4ab0e1:      * Accepts a message that was dispatched under the given Delivery instance.
1:b4ab0e1:      *
1:5d53aa2:      * @param delivery
1:5d53aa2:      *        the Delivery instance to accept.
1:5d53aa2:      * @param settle
1:5d53aa2:      *        true if the receiver should settle the delivery or just send the disposition.
1:5d53aa2:      *
1:5d53aa2:      * @throws IOException if an error occurs while sending the accept.
1:5d53aa2:      */
1:5d53aa2:     public void accept(Delivery delivery, boolean settle) throws IOException {
1:5d53aa2:         accept(delivery, this.session, settle);
1:5d53aa2:     }
1:5d53aa2: 
1:5d53aa2:     /**
1:5d53aa2:      * Accepts a message that was dispatched under the given Delivery instance and settles the delivery.
1:5d53aa2:      *
1:b4ab0e1:      * This method allows for the session that is used in the accept to be specified by the
1:b4ab0e1:      * caller.  This allows for an accepted message to be involved in a transaction that is
1:b4ab0e1:      * being managed by some other session other than the one that created this receiver.
1:b4ab0e1:      *
1:b4ab0e1:      * @param delivery
1:b4ab0e1:      *        the Delivery instance to accept.
1:b4ab0e1:      * @param session
1:b4ab0e1:      *        the session under which the message is being accepted.
1:b4ab0e1:      *
1:b4ab0e1:      * @throws IOException if an error occurs while sending the accept.
1:b4ab0e1:      */
1:b4ab0e1:     public void accept(final Delivery delivery, final AmqpSession session) throws IOException {
1:5d53aa2:         accept(delivery, session, true);
1:5d53aa2:     }
1:5d53aa2: 
1:5d53aa2:     /**
1:5d53aa2:      * Accepts a message that was dispatched under the given Delivery instance.
1:5d53aa2:      *
1:5d53aa2:      * This method allows for the session that is used in the accept to be specified by the
1:5d53aa2:      * caller.  This allows for an accepted message to be involved in a transaction that is
1:5d53aa2:      * being managed by some other session other than the one that created this receiver.
1:5d53aa2:      *
1:5d53aa2:      * @param delivery
1:5d53aa2:      *        the Delivery instance to accept.
1:5d53aa2:      * @param session
1:5d53aa2:      *        the session under which the message is being accepted.
1:5d53aa2:      * @param settle
1:5d53aa2:      *        true if the receiver should settle the delivery or just send the disposition.
1:5d53aa2:      *
1:5d53aa2:      * @throws IOException if an error occurs while sending the accept.
1:5d53aa2:      */
1:5d53aa2:     public void accept(final Delivery delivery, final AmqpSession session, final boolean settle) throws IOException {
1:72839b7:         checkClosed();
1:72839b7: 
1:72839b7:         if (delivery == null) {
1:72839b7:             throw new IllegalArgumentException("Delivery to accept cannot be null");
1:72839b7:         }
1:72839b7: 
1:b4ab0e1:         if (session == null) {
1:b4ab0e1:             throw new IllegalArgumentException("Session given cannot be null");
1:b4ab0e1:         }
1:b4ab0e1: 
1:b4ab0e1:         if (session.getConnection() != this.session.getConnection()) {
1:b4ab0e1:             throw new IllegalArgumentException("The session used for accept must originate from the connection that created this receiver.");
1:b4ab0e1:         }
1:b4ab0e1: 
1:72839b7:         final ClientFuture request = new ClientFuture();
1:72839b7:         session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:72839b7:                 try {
1:72839b7:                     if (!delivery.isSettled()) {
1:272fb2b:                         if (session.isInTransaction()) {
1:272fb2b:                             Binary txnId = session.getTransactionId().getRemoteTxId();
1:272fb2b:                             if (txnId != null) {
1:272fb2b:                                 TransactionalState txState = new TransactionalState();
1:272fb2b:                                 txState.setOutcome(Accepted.getInstance());
1:272fb2b:                                 txState.setTxnId(txnId);
1:272fb2b:                                 delivery.disposition(txState);
1:272fb2b:                                 session.getTransactionContext().registerTxConsumer(AmqpReceiver.this);
1:272fb2b:                             }
1:272fb2b:                         } else {
1:272fb2b:                             delivery.disposition(Accepted.getInstance());
1:5d53aa2:                         }
1:5d53aa2: 
1:5d53aa2:                         if (settle) {
1:272fb2b:                             delivery.settle();
1:272fb2b:                         }
1:72839b7:                     }
1:8448cf1:                     session.pumpToProtonTransport(request);
1:72839b7:                     request.onSuccess();
1:72839b7:                 } catch (Exception e) {
1:72839b7:                     request.onFailure(e);
1:72839b7:                 }
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:0cfd225:      * Mark a message that was dispatched under the given Delivery instance as Modified.
1:72839b7:      *
1:72839b7:      * @param delivery
1:0cfd225:      *        the Delivery instance to mark modified.
1:72839b7:      * @param deliveryFailed
1:72839b7:      *        indicates that the delivery failed for some reason.
1:72839b7:      * @param undeliverableHere
1:72839b7:      *        marks the delivery as not being able to be process by link it was sent to.
1:72839b7:      * @throws IOException if an error occurs while sending the reject.
1:72839b7:      */
1:0cfd225:     public void modified(final Delivery delivery, final Boolean deliveryFailed, final Boolean undeliverableHere) throws IOException {
1:72839b7:         checkClosed();
1:72839b7: 
1:72839b7:         if (delivery == null) {
1:72839b7:             throw new IllegalArgumentException("Delivery to reject cannot be null");
1:72839b7:         }
1:72839b7: 
1:72839b7:         final ClientFuture request = new ClientFuture();
1:72839b7:         session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:72839b7:                 try {
1:72839b7:                     if (!delivery.isSettled()) {
1:72839b7:                         Modified disposition = new Modified();
1:72839b7:                         disposition.setUndeliverableHere(undeliverableHere);
1:72839b7:                         disposition.setDeliveryFailed(deliveryFailed);
1:72839b7:                         delivery.disposition(disposition);
1:272fb2b:                         delivery.settle();
1:8448cf1:                         session.pumpToProtonTransport(request);
1:72839b7:                     }
1:72839b7:                     request.onSuccess();
1:72839b7:                 } catch (Exception e) {
1:72839b7:                     request.onFailure(e);
1:72839b7:                 }
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Release a message that was dispatched under the given Delivery instance.
1:72839b7:      *
1:72839b7:      * @param delivery
1:72839b7:      *        the Delivery instance to release.
1:72839b7:      *
1:72839b7:      * @throws IOException if an error occurs while sending the release.
1:72839b7:      */
1:72839b7:     public void release(final Delivery delivery) throws IOException {
1:f71e0ee:         checkClosed();
1:f71e0ee: 
1:72839b7:         if (delivery == null) {
1:72839b7:             throw new IllegalArgumentException("Delivery to release cannot be null");
1:f71e0ee:         }
1:72839b7: 
1:72839b7:         final ClientFuture request = new ClientFuture();
1:72839b7:         session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:72839b7:                 try {
1:72839b7:                     if (!delivery.isSettled()) {
1:72839b7:                         delivery.disposition(Released.getInstance());
3:72839b7:                         delivery.settle();
1:8448cf1:                         session.pumpToProtonTransport(request);
1:72839b7:                     }
1:72839b7:                     request.onSuccess();
1:72839b7:                 } catch (Exception e) {
1:72839b7:                     request.onFailure(e);
1:72839b7:                 }
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:f71e0ee:      * Reject a message that was dispatched under the given Delivery instance.
1:f71e0ee:      *
1:f71e0ee:      * @param delivery
1:f71e0ee:      *        the Delivery instance to reject.
1:f71e0ee:      *
1:f71e0ee:      * @throws IOException if an error occurs while sending the release.
1:f71e0ee:      */
1:f71e0ee:     public void reject(final Delivery delivery) throws IOException {
1:f71e0ee:         checkClosed();
1:f71e0ee: 
1:f71e0ee:         if (delivery == null) {
1:f71e0ee:             throw new IllegalArgumentException("Delivery to release cannot be null");
1:f71e0ee:         }
1:f71e0ee: 
1:f71e0ee:         final ClientFuture request = new ClientFuture();
1:f71e0ee:         session.getScheduler().execute(new Runnable() {
1:72839b7: 
1:f71e0ee:             @Override
1:f71e0ee:             public void run() {
1:72839b7:                 checkClosed();
1:f71e0ee:                 try {
1:f71e0ee:                     if (!delivery.isSettled()) {
1:f71e0ee:                         delivery.disposition(new Rejected());
1:f71e0ee:                         delivery.settle();
1:f71e0ee:                         session.pumpToProtonTransport(request);
1:f71e0ee:                     }
1:f71e0ee:                     request.onSuccess();
1:f71e0ee:                 } catch (Exception e) {
1:f71e0ee:                     request.onFailure(e);
1:f71e0ee:                 }
1:f71e0ee:             }
1:f71e0ee:         });
1:f71e0ee: 
1:f71e0ee:         request.sync();
1:72839b7:     }
1:f71e0ee: 
1:f71e0ee:     /**
1:72839b7:      * @return an unmodifiable view of the underlying Receiver instance.
1:72839b7:      */
1:72839b7:     public Receiver getReceiver() {
1:fddbac2:         return UnmodifiableProxy.receiverProxy(getEndpoint());
1:72839b7:     }
1:72839b7: 
1:72839b7:     //----- Receiver configuration properties --------------------------------//
1:72839b7: 
1:72839b7:     public boolean isPresettle() {
1:72839b7:         return presettle;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setPresettle(boolean presettle) {
1:72839b7:         this.presettle = presettle;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public boolean isDurable() {
1:72839b7:         return subscriptionName != null;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public String getSubscriptionName() {
1:72839b7:         return subscriptionName;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setSubscriptionName(String subscriptionName) {
1:72839b7:         this.subscriptionName = subscriptionName;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public String getSelector() {
1:72839b7:         return selector;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setSelector(String selector) {
1:72839b7:         this.selector = selector;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public boolean isNoLocal() {
1:72839b7:         return noLocal;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setNoLocal(boolean noLocal) {
1:72839b7:         this.noLocal = noLocal;
1:72839b7:     }
1:72839b7: 
1:8448cf1:     public long getDrainTimeout() {
1:8448cf1:         return session.getConnection().getDrainTimeout();
1:8448cf1:     }
1:8448cf1: 
1:72839b7:     //----- Internal implementation ------------------------------------------//
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doOpen() {
1:72839b7: 
1:ca456c4:         Source source = userSpecifiedSource;
1:72839b7:         Target target = new Target();
1:72839b7: 
1:8e6a404:         if (source == null && address != null) {
1:ca456c4:             source = new Source();
1:ca456c4:             source.setAddress(address);
1:ca456c4:             configureSource(source);
1:ca456c4:         }
1:72839b7: 
1:72839b7:         String receiverName = receiverId + ":" + address;
1:72839b7: 
1:72839b7:         if (getSubscriptionName() != null && !getSubscriptionName().isEmpty()) {
1:72839b7:             // In the case of Durable Topic Subscriptions the client must use the same
1:72839b7:             // receiver name which is derived from the subscription name property.
1:72839b7:             receiverName = getSubscriptionName();
1:72839b7:         }
1:72839b7: 
1:72839b7:         Receiver receiver = session.getEndpoint().receiver(receiverName);
1:72839b7:         receiver.setSource(source);
1:72839b7:         receiver.setTarget(target);
1:381a1ae: 
1:381a1ae:         if (userSpecifiedSenderSettlementMode != null) {
1:381a1ae:             receiver.setSenderSettleMode(userSpecifiedSenderSettlementMode);
1:381a1ae:             if (SenderSettleMode.SETTLED.equals(userSpecifiedSenderSettlementMode)) {
1:381a1ae:                 setPresettle(true);
1:381a1ae:             }
2:72839b7:         } else {
1:381a1ae:             if (isPresettle()) {
1:381a1ae:                 receiver.setSenderSettleMode(SenderSettleMode.SETTLED);
1:381a1ae:             } else {
1:381a1ae:                 receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);
1:381a1ae:             }
1:72839b7:         }
1:381a1ae: 
1:381a1ae:         if (userSpecifiedReceiverSettlementMode != null) {
1:381a1ae:             receiver.setReceiverSettleMode(userSpecifiedReceiverSettlementMode);
1:381a1ae:         } else {
1:381a1ae:             receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1:381a1ae:         }
1:72839b7: 
1:72839b7:         setEndpoint(receiver);
1:72839b7: 
1:72839b7:         super.doOpen();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doOpenCompletion() {
1:72839b7:         // Verify the attach response contained a non-null Source
1:72839b7:         org.apache.qpid.proton.amqp.transport.Source s = getEndpoint().getRemoteSource();
1:72839b7:         if (s != null) {
1:72839b7:             super.doOpenCompletion();
1:72839b7:         } else {
1:72839b7:             // No link terminus was created, the peer will now detach/close us.
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doClose() {
1:934ad44:         getEndpoint().close();
1:934ad44:     }
1:934ad44: 
1:934ad44:     @Override
1:934ad44:     protected void doDetach() {
1:934ad44:         getEndpoint().detach();
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected Exception getOpenAbortException() {
1:72839b7:         // Verify the attach response contained a non-null Source
1:72839b7:         org.apache.qpid.proton.amqp.transport.Source s = getEndpoint().getRemoteSource();
1:72839b7:         if (s != null) {
1:72839b7:             return super.getOpenAbortException();
1:72839b7:         } else {
1:72839b7:             // No link terminus was created, the peer has detach/closed us, create IDE.
1:72839b7:             return new InvalidDestinationException("Link creation was refused");
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doOpenInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectOpenedResource(getReceiver());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doClosedInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectClosedResource(getReceiver());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doDetachedInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectDetachedResource(getReceiver());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     protected void configureSource(Source source) {
1:381a1ae:         Map<Symbol, DescribedType> filters = new HashMap<>();
1:6a2ffca:         Symbol[] outcomes = new Symbol[]{Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL,
1:6a2ffca:                                          Released.DESCRIPTOR_SYMBOL, Modified.DESCRIPTOR_SYMBOL};
1:72839b7: 
1:72839b7:         if (getSubscriptionName() != null && !getSubscriptionName().isEmpty()) {
1:72839b7:             source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
1:72839b7:             source.setDurable(TerminusDurability.UNSETTLED_STATE);
1:72839b7:             source.setDistributionMode(COPY);
1:72839b7:         } else {
1:72839b7:             source.setDurable(TerminusDurability.NONE);
1:72839b7:             source.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
1:72839b7:         }
1:72839b7: 
1:72839b7:         source.setOutcomes(outcomes);
1:72839b7: 
1:72839b7:         Modified modified = new Modified();
1:72839b7:         modified.setDeliveryFailed(true);
1:72839b7:         modified.setUndeliverableHere(false);
1:72839b7: 
1:72839b7:         source.setDefaultOutcome(modified);
1:72839b7: 
1:72839b7:         if (isNoLocal()) {
1:ca456c4:             filters.put(NO_LOCAL_NAME, AmqpNoLocalFilter.NO_LOCAL);
1:72839b7:         }
1:72839b7: 
1:72839b7:         if (getSelector() != null && !getSelector().trim().equals("")) {
1:ca456c4:             filters.put(JMS_SELECTOR_NAME, new AmqpJmsSelectorFilter(getSelector()));
1:72839b7:         }
1:72839b7: 
1:72839b7:         if (!filters.isEmpty()) {
1:72839b7:             source.setFilter(filters);
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     public void processDeliveryUpdates(AmqpConnection connection) throws IOException {
1:72839b7:         Delivery incoming = null;
1:72839b7:         do {
1:72839b7:             incoming = getEndpoint().current();
1:72839b7:             if (incoming != null) {
1:72839b7:                 if(incoming.isReadable() && !incoming.isPartial()) {
1:72839b7:                     LOG.trace("{} has incoming Message(s).", this);
1:72839b7:                     try {
1:72839b7:                         processDelivery(incoming);
1:72839b7:                     } catch (Exception e) {
1:72839b7:                         throw IOExceptionSupport.create(e);
1:72839b7:                     }
1:72839b7:                     getEndpoint().advance();
1:72839b7:                 } else {
1:72839b7:                     LOG.trace("{} has a partial incoming Message(s), deferring.", this);
1:72839b7:                     incoming = null;
1:72839b7:                 }
1:8448cf1:             } else {
1:8448cf1:                 // We have exhausted the locally queued messages on this link.
1:8448cf1:                 // Check if we tried to stop and have now run out of credit.
1:8448cf1:                 if (getEndpoint().getRemoteCredit() <= 0) {
1:8448cf1:                     if (stopRequest != null) {
1:8448cf1:                         stopRequest.onSuccess();
1:8448cf1:                         stopRequest = null;
1:8448cf1:                     }
1:8448cf1:                 }
1:72839b7:             }
1:72839b7:         } while (incoming != null);
1:72839b7: 
1:72839b7:         super.processDeliveryUpdates(connection);
1:72839b7:     }
1:72839b7: 
1:72839b7:     private void processDelivery(Delivery incoming) throws Exception {
1:cec3245:         doDeliveryInspection(incoming);
1:cec3245: 
1:72839b7:         Message message = null;
1:72839b7:         try {
1:72839b7:             message = decodeIncomingMessage(incoming);
1:72839b7:         } catch (Exception e) {
1:72839b7:             LOG.warn("Error on transform: {}", e.getMessage());
1:72839b7:             deliveryFailed(incoming, true);
1:72839b7:             return;
1:72839b7:         }
1:72839b7: 
1:72839b7:         AmqpMessage amqpMessage = new AmqpMessage(this, message, incoming);
1:72839b7:         // Store reference to envelope in delivery context for recovery
1:72839b7:         incoming.setContext(amqpMessage);
1:72839b7:         prefetch.add(amqpMessage);
1:8448cf1: 
1:8448cf1:         // We processed a message, signal completion
1:8448cf1:         // of a message pull request if there is one.
1:8448cf1:         if (pullRequest != null) {
1:8448cf1:             pullRequest.onSuccess();
1:8448cf1:             pullRequest = null;
1:8448cf1:         }
1:8448cf1:     }
1:8448cf1: 
1:cec3245:     private void doDeliveryInspection(Delivery delivery) {
1:cec3245:         try {
1:cec3245:             getStateInspector().inspectDelivery(getReceiver(), delivery);
1:cec3245:         } catch (Throwable error) {
1:cec3245:             getStateInspector().markAsInvalid(error.getMessage());
1:cec3245:         }
1:cec3245:     }
1:cec3245: 
1:8448cf1:     @Override
1:8448cf1:     public void processFlowUpdates(AmqpConnection connection) throws IOException {
1:8448cf1:         if (pullRequest != null || stopRequest != null) {
1:8448cf1:             Receiver receiver = getEndpoint();
1:8448cf1:             if (receiver.getRemoteCredit() <= 0 && receiver.getQueued() == 0) {
1:8448cf1:                 if (pullRequest != null) {
1:8448cf1:                     pullRequest.onSuccess();
1:8448cf1:                     pullRequest = null;
1:8448cf1:                 }
1:8448cf1: 
1:8448cf1:                 if (stopRequest != null) {
1:8448cf1:                     stopRequest.onSuccess();
1:8448cf1:                     stopRequest = null;
1:8448cf1:                 }
1:8448cf1:             }
1:8448cf1:         }
1:8448cf1: 
1:8448cf1:         LOG.trace("Consumer {} flow updated, remote credit = {}", getSubscriptionName(), getEndpoint().getRemoteCredit());
1:8448cf1: 
1:8448cf1:         super.processFlowUpdates(connection);
1:72839b7:     }
1:72839b7: 
1:72839b7:     protected Message decodeIncomingMessage(Delivery incoming) {
1:72839b7:         int count;
1:72839b7: 
1:72839b7:         byte[] chunk = new byte[2048];
1:72839b7:         ByteArrayOutputStream stream = new ByteArrayOutputStream();
1:72839b7: 
1:72839b7:         while ((count = getEndpoint().recv(chunk, 0, chunk.length)) > 0) {
1:72839b7:             stream.write(chunk, 0, count);
1:72839b7:         }
1:72839b7: 
1:72839b7:         byte[] messageBytes = stream.toByteArray();
1:72839b7: 
1:72839b7:         try {
1:72839b7:             Message protonMessage = Message.Factory.create();
1:72839b7:             protonMessage.decode(messageBytes, 0, messageBytes.length);
1:72839b7:             return protonMessage;
1:72839b7:         } finally {
1:72839b7:             try {
1:72839b7:                 stream.close();
1:72839b7:             } catch (IOException e) {
1:72839b7:             }
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     protected void deliveryFailed(Delivery incoming, boolean expandCredit) {
1:72839b7:         Modified disposition = new Modified();
1:72839b7:         disposition.setUndeliverableHere(true);
1:72839b7:         disposition.setDeliveryFailed(true);
1:72839b7:         incoming.disposition(disposition);
1:72839b7:         incoming.settle();
1:72839b7:         if (expandCredit) {
1:72839b7:             getEndpoint().flow(1);
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:8448cf1:     private void stop(final AsyncResult request) {
1:8448cf1:         Receiver receiver = getEndpoint();
1:8448cf1:         if (receiver.getRemoteCredit() <= 0) {
1:8448cf1:             if (receiver.getQueued() == 0) {
1:8448cf1:                 // We have no remote credit and all the deliveries have been processed.
1:8448cf1:                 request.onSuccess();
1:8448cf1:             } else {
1:8448cf1:                 // There are still deliveries to process, wait for them to be.
1:8448cf1:                 stopRequest = request;
1:8448cf1:             }
1:8448cf1:         } else {
1:8448cf1:             // TODO: We don't actually want the additional messages that could be sent while
1:8448cf1:             // draining. We could explicitly reduce credit first, or possibly use 'echo' instead
1:8448cf1:             // of drain if it was supported. We would first need to understand what happens
1:8448cf1:             // if we reduce credit below the number of messages already in-flight before
1:8448cf1:             // the peer sees the update.
1:8448cf1:             stopRequest = request;
1:8448cf1:             receiver.drain(0);
1:8448cf1: 
1:8448cf1:             if (getDrainTimeout() > 0) {
1:8448cf1:                 // If the remote doesn't respond we will close the consumer and break any
1:8448cf1:                 // blocked receive or stop calls that are waiting.
1:8448cf1:                 final ScheduledFuture<?> future = getSession().getScheduler().schedule(new Runnable() {
1:8448cf1:                     @Override
1:8448cf1:                     public void run() {
1:8448cf1:                         LOG.trace("Consumer {} drain request timed out", this);
1:8448cf1:                         Exception cause = new JmsOperationTimedOutException("Remote did not respond to a drain request in time");
1:8448cf1:                         locallyClosed(session.getConnection(), cause);
1:8448cf1:                         stopRequest.onFailure(cause);
1:8448cf1:                         session.pumpToProtonTransport(stopRequest);
1:8448cf1:                     }
1:8448cf1:                 }, getDrainTimeout(), TimeUnit.MILLISECONDS);
1:8448cf1: 
1:8448cf1:                 stopRequest = new ScheduledRequest(future, stopRequest);
1:8448cf1:             }
1:8448cf1:         }
1:8448cf1:     }
1:8448cf1: 
1:8448cf1:     private void stopOnSchedule(long timeout, final AsyncResult request) {
1:8448cf1:         LOG.trace("Receiver {} scheduling stop", this);
1:8448cf1:         // We need to drain the credit if no message(s) arrive to use it.
1:8448cf1:         final ScheduledFuture<?> future = getSession().getScheduler().schedule(new Runnable() {
1:8448cf1:             @Override
1:8448cf1:             public void run() {
1:8448cf1:                 LOG.trace("Receiver {} running scheduled stop", this);
1:8448cf1:                 if (getEndpoint().getRemoteCredit() != 0) {
1:8448cf1:                     stop(request);
1:8448cf1:                     session.pumpToProtonTransport(request);
1:8448cf1:                 }
1:8448cf1:             }
1:8448cf1:         }, timeout, TimeUnit.MILLISECONDS);
1:8448cf1: 
1:8448cf1:         stopRequest = new ScheduledRequest(future, request);
1:8448cf1:     }
1:8448cf1: 
1:72839b7:     @Override
1:72839b7:     public String toString() {
1:72839b7:         return getClass().getSimpleName() + "{ address = " + address + "}";
1:72839b7:     }
1:72839b7: 
1:72839b7:     private void checkClosed() {
1:72839b7:         if (isClosed()) {
1:72839b7:             throw new IllegalStateException("Receiver is already closed");
1:72839b7:         }
1:72839b7:     }
1:272fb2b: 
1:272fb2b:     //----- Internal Transaction state callbacks -----------------------------//
1:272fb2b: 
1:272fb2b:     void preCommit() {
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     void preRollback() {
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     void postCommit() {
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     void postRollback() {
1:272fb2b:     }
1:8448cf1: 
1:8448cf1:     //----- Inner classes used in message pull operations --------------------//
1:8448cf1: 
1:8448cf1:     protected static final class ScheduledRequest implements AsyncResult {
1:8448cf1: 
1:8448cf1:         private final ScheduledFuture<?> sheduledTask;
1:8448cf1:         private final AsyncResult origRequest;
1:8448cf1: 
1:8448cf1:         public ScheduledRequest(ScheduledFuture<?> completionTask, AsyncResult origRequest) {
1:8448cf1:             this.sheduledTask = completionTask;
1:8448cf1:             this.origRequest = origRequest;
1:8448cf1:         }
1:8448cf1: 
1:8448cf1:         @Override
1:8448cf1:         public void onFailure(Throwable cause) {
1:8448cf1:             sheduledTask.cancel(false);
1:8448cf1:             origRequest.onFailure(cause);
1:8448cf1:         }
1:8448cf1: 
1:8448cf1:         @Override
1:8448cf1:         public void onSuccess() {
1:8448cf1:             boolean cancelled = sheduledTask.cancel(false);
1:8448cf1:             if (cancelled) {
1:8448cf1:                 // Signal completion. Otherwise wait for the scheduled task to do it.
1:8448cf1:                 origRequest.onSuccess();
1:8448cf1:             }
1:8448cf1:         }
1:8448cf1: 
1:8448cf1:         @Override
1:8448cf1:         public boolean isComplete() {
1:8448cf1:             return origRequest.isComplete();
1:8448cf1:         }
1:8448cf1:     }
1:72839b7: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:fddbac2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
/////////////////////////////////////////////////////////////////////////
1:         return UnmodifiableProxy.receiverProxy(getEndpoint());
commit:381a1ae
/////////////////////////////////////////////////////////////////////////
1:     private final BlockingQueue<AmqpMessage> prefetch = new LinkedBlockingDeque<>();
1: 
1:     private final SenderSettleMode userSpecifiedSenderSettlementMode;
1:     private final ReceiverSettleMode userSpecifiedReceiverSettlementMode;
/////////////////////////////////////////////////////////////////////////
1:      *        The parent session that created the receiver.
1:         this(session, address, receiverId, null, null);
1:     }
1: 
1:     /**
1:      * Create a new receiver instance.
1:      *
1:      * @param session
1:      * 		  The parent session that created the receiver.
1:      * @param address
1:      *        The address that this receiver should listen on.
1:      * @param receiverId
1:      *        The unique ID assigned to this receiver.
1:      * @param senderMode
1:      *        The {@link SenderSettleMode} to use on open.
1:      * @param receiverMode
1:      *        The {@link ReceiverSettleMode} to use on open.
1:      */
1:     public AmqpReceiver(AmqpSession session, String address, String receiverId, SenderSettleMode senderMode, ReceiverSettleMode receiverMode) {
/////////////////////////////////////////////////////////////////////////
1:         this.userSpecifiedSenderSettlementMode = senderMode;
1:         this.userSpecifiedReceiverSettlementMode = receiverMode;
/////////////////////////////////////////////////////////////////////////
1:         this.userSpecifiedSenderSettlementMode = null;
1:         this.userSpecifiedReceiverSettlementMode = null;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (userSpecifiedSenderSettlementMode != null) {
1:             receiver.setSenderSettleMode(userSpecifiedSenderSettlementMode);
1:             if (SenderSettleMode.SETTLED.equals(userSpecifiedSenderSettlementMode)) {
1:                 setPresettle(true);
1:             }
1:             if (isPresettle()) {
1:                 receiver.setSenderSettleMode(SenderSettleMode.SETTLED);
1:             } else {
1:                 receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);
1:             }
1: 
1:         if (userSpecifiedReceiverSettlementMode != null) {
1:             receiver.setReceiverSettleMode(userSpecifiedReceiverSettlementMode);
1:         } else {
1:             receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         Map<Symbol, DescribedType> filters = new HashMap<>();
commit:cec3245
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:         doDeliveryInspection(incoming);
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void doDeliveryInspection(Delivery delivery) {
1:         try {
1:             getStateInspector().inspectDelivery(getReceiver(), delivery);
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:     }
1: 
commit:f71e0ee
/////////////////////////////////////////////////////////////////////////
1:      * Reject a message that was dispatched under the given Delivery instance.
1:      *
1:      * @param delivery
1:      *        the Delivery instance to reject.
1:      *
1:      * @throws IOException if an error occurs while sending the release.
1:      */
1:     public void reject(final Delivery delivery) throws IOException {
1:         checkClosed();
1: 
1:         if (delivery == null) {
1:             throw new IllegalArgumentException("Delivery to release cannot be null");
1:         }
1: 
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
1:                     if (!delivery.isSettled()) {
1:                         delivery.disposition(new Rejected());
1:                         delivery.settle();
1:                         session.pumpToProtonTransport(request);
1:                     }
1:                     request.onSuccess();
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
1:     /**
commit:5d53aa2
/////////////////////////////////////////////////////////////////////////
1:      * Accepts a message that was dispatched under the given Delivery instance and settles the delivery.
1:     public void accept(Delivery delivery) throws IOException {
1:         accept(delivery, this.session, true);
1:      * @param delivery
1:      *        the Delivery instance to accept.
1:      * @param settle
1:      *        true if the receiver should settle the delivery or just send the disposition.
1:      *
1:      * @throws IOException if an error occurs while sending the accept.
1:      */
1:     public void accept(Delivery delivery, boolean settle) throws IOException {
1:         accept(delivery, this.session, settle);
1:     }
1: 
1:     /**
1:      * Accepts a message that was dispatched under the given Delivery instance and settles the delivery.
1:      *
/////////////////////////////////////////////////////////////////////////
1:         accept(delivery, session, true);
1:     }
1: 
1:     /**
1:      * Accepts a message that was dispatched under the given Delivery instance.
1:      *
1:      * This method allows for the session that is used in the accept to be specified by the
1:      * caller.  This allows for an accepted message to be involved in a transaction that is
1:      * being managed by some other session other than the one that created this receiver.
1:      *
1:      * @param delivery
1:      *        the Delivery instance to accept.
1:      * @param session
1:      *        the session under which the message is being accepted.
1:      * @param settle
1:      *        true if the receiver should settle the delivery or just send the disposition.
1:      *
1:      * @throws IOException if an error occurs while sending the accept.
1:      */
1:     public void accept(final Delivery delivery, final AmqpSession session, final boolean settle) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                         }
1: 
1:                         if (settle) {
commit:b4ab0e1
/////////////////////////////////////////////////////////////////////////
0:         accept(delivery, this.session);
1:     }
1: 
1:     /**
1:      * Accepts a message that was dispatched under the given Delivery instance.
1:      *
1:      * This method allows for the session that is used in the accept to be specified by the
1:      * caller.  This allows for an accepted message to be involved in a transaction that is
1:      * being managed by some other session other than the one that created this receiver.
1:      *
1:      * @param delivery
1:      *        the Delivery instance to accept.
1:      * @param session
1:      *        the session under which the message is being accepted.
1:      *
1:      * @throws IOException if an error occurs while sending the accept.
1:      */
1:     public void accept(final Delivery delivery, final AmqpSession session) throws IOException {
1:         if (session == null) {
1:             throw new IllegalArgumentException("Session given cannot be null");
1:         }
1: 
1:         if (session.getConnection() != this.session.getConnection()) {
1:             throw new IllegalArgumentException("The session used for accept must originate from the connection that created this receiver.");
1:         }
1: 
commit:8448cf1
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ScheduledFuture;
1: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
1: import org.apache.qpid.jms.JmsOperationTimedOutException;
/////////////////////////////////////////////////////////////////////////
1:     private AsyncResult pullRequest;
1:     private AsyncResult stopRequest;
1: 
/////////////////////////////////////////////////////////////////////////
1:                     session.pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                     session.pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:      * Request a remote peer send a Message to this client waiting until one arrives.
1:      *
1:      * @return the pulled AmqpMessage or null if none was pulled from the remote.
1:      *
1:      * @throws IOException if an error occurs
1:      */
1:     public AmqpMessage pull() throws IOException {
1:         return pull(-1, TimeUnit.MILLISECONDS);
1:     }
1: 
1:     /**
1:      * Request a remote peer send a Message to this client using an immediate drain request.
1:      *
1:      * @return the pulled AmqpMessage or null if none was pulled from the remote.
1:      *
1:      * @throws IOException if an error occurs
1:      */
1:     public AmqpMessage pullImmediate() throws IOException {
1:         return pull(0, TimeUnit.MILLISECONDS);
1:     }
1: 
1:     /**
1:      * Request a remote peer send a Message to this client.
1:      *
1:      *   {@literal timeout < 0} then it should remain open until a message is received.
1:      *   {@literal timeout = 0} then it returns a message or null if none available
1:      *   {@literal timeout > 0} then it should remain open for timeout amount of time.
1:      *
1:      * The timeout value when positive is given in milliseconds.
1:      *
1:      * @param timeout
1:      *        the amount of time to tell the remote peer to keep this pull request valid.
1:      * @param unit
1:      *        the unit of measure that the timeout represents.
1:      *
1:      * @return the pulled AmqpMessage or null if none was pulled from the remote.
1:      *
1:      * @throws IOException if an error occurs
1:      */
1:     public AmqpMessage pull(final long timeout, final TimeUnit unit) throws IOException {
1:         checkClosed();
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1: 
1:                 long timeoutMills = unit.toMillis(timeout);
1: 
1:                 try {
1:                     LOG.trace("Pull on Receiver {} with timeout = {}", getSubscriptionName(), timeoutMills);
1:                     if (timeoutMills < 0) {
1:                         // Wait until message arrives. Just give credit if needed.
1:                         if (getEndpoint().getCredit() == 0) {
1:                             LOG.trace("Receiver {} granting 1 additional credit for pull.", getSubscriptionName());
1:                             getEndpoint().flow(1);
1:                         }
1: 
1:                         // Await the message arrival
1:                         pullRequest = request;
1:                     } else if (timeoutMills == 0) {
1:                         // If we have no credit then we need to issue some so that we can
1:                         // try to fulfill the request, then drain down what is there to
1:                         // ensure we consume what is available and remove all credit.
1:                         if (getEndpoint().getCredit() == 0){
1:                             LOG.trace("Receiver {} granting 1 additional credit for pull.", getSubscriptionName());
1:                             getEndpoint().flow(1);
1:                         }
1: 
1:                         // Drain immediately and wait for the message(s) to arrive,
1:                         // or a flow indicating removal of the remaining credit.
1:                         stop(request);
1:                     } else if (timeoutMills > 0) {
1:                         // If we have no credit then we need to issue some so that we can
1:                         // try to fulfill the request, then drain down what is there to
1:                         // ensure we consume what is available and remove all credit.
1:                         if (getEndpoint().getCredit() == 0) {
1:                             LOG.trace("Receiver {} granting 1 additional credit for pull.", getSubscriptionName());
1:                             getEndpoint().flow(1);
1:                         }
1: 
1:                         // Wait for the timeout for the message(s) to arrive, then drain if required
1:                         // and wait for remaining message(s) to arrive or a flow indicating
1:                         // removal of the remaining credit.
1:                         stopOnSchedule(timeoutMills, request);
1:                     }
1: 
1:                     session.pumpToProtonTransport(request);
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return prefetch.poll();
1:     }
1: 
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:                     session.pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                     session.pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:      * Stops the receiver, using all link credit and waiting for in-flight messages to arrive.
1:      *
1:      * @throws IOException if an error occurs while sending the drain.
1:      */
1:     public void stop() throws IOException {
1:         checkClosed();
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
1:                     stop(request);
1:                     session.pumpToProtonTransport(request);
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:                     session.pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                         session.pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                         session.pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:     public long getDrainTimeout() {
1:         return session.getConnection().getDrainTimeout();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 // We have exhausted the locally queued messages on this link.
1:                 // Check if we tried to stop and have now run out of credit.
1:                 if (getEndpoint().getRemoteCredit() <= 0) {
1:                     if (stopRequest != null) {
1:                         stopRequest.onSuccess();
1:                         stopRequest = null;
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
1:         // We processed a message, signal completion
1:         // of a message pull request if there is one.
1:         if (pullRequest != null) {
1:             pullRequest.onSuccess();
1:             pullRequest = null;
1:         }
1:     }
1: 
1:     @Override
1:     public void processFlowUpdates(AmqpConnection connection) throws IOException {
1:         if (pullRequest != null || stopRequest != null) {
1:             Receiver receiver = getEndpoint();
1:             if (receiver.getRemoteCredit() <= 0 && receiver.getQueued() == 0) {
1:                 if (pullRequest != null) {
1:                     pullRequest.onSuccess();
1:                     pullRequest = null;
1:                 }
1: 
1:                 if (stopRequest != null) {
1:                     stopRequest.onSuccess();
1:                     stopRequest = null;
1:                 }
1:             }
1:         }
1: 
1:         LOG.trace("Consumer {} flow updated, remote credit = {}", getSubscriptionName(), getEndpoint().getRemoteCredit());
1: 
1:         super.processFlowUpdates(connection);
/////////////////////////////////////////////////////////////////////////
1:     private void stop(final AsyncResult request) {
1:         Receiver receiver = getEndpoint();
1:         if (receiver.getRemoteCredit() <= 0) {
1:             if (receiver.getQueued() == 0) {
1:                 // We have no remote credit and all the deliveries have been processed.
1:                 request.onSuccess();
1:             } else {
1:                 // There are still deliveries to process, wait for them to be.
1:                 stopRequest = request;
1:             }
1:         } else {
1:             // TODO: We don't actually want the additional messages that could be sent while
1:             // draining. We could explicitly reduce credit first, or possibly use 'echo' instead
1:             // of drain if it was supported. We would first need to understand what happens
1:             // if we reduce credit below the number of messages already in-flight before
1:             // the peer sees the update.
1:             stopRequest = request;
1:             receiver.drain(0);
1: 
1:             if (getDrainTimeout() > 0) {
1:                 // If the remote doesn't respond we will close the consumer and break any
1:                 // blocked receive or stop calls that are waiting.
1:                 final ScheduledFuture<?> future = getSession().getScheduler().schedule(new Runnable() {
1:                     @Override
1:                     public void run() {
1:                         LOG.trace("Consumer {} drain request timed out", this);
1:                         Exception cause = new JmsOperationTimedOutException("Remote did not respond to a drain request in time");
1:                         locallyClosed(session.getConnection(), cause);
1:                         stopRequest.onFailure(cause);
1:                         session.pumpToProtonTransport(stopRequest);
1:                     }
1:                 }, getDrainTimeout(), TimeUnit.MILLISECONDS);
1: 
1:                 stopRequest = new ScheduledRequest(future, stopRequest);
1:             }
1:         }
1:     }
1: 
1:     private void stopOnSchedule(long timeout, final AsyncResult request) {
1:         LOG.trace("Receiver {} scheduling stop", this);
1:         // We need to drain the credit if no message(s) arrive to use it.
1:         final ScheduledFuture<?> future = getSession().getScheduler().schedule(new Runnable() {
1:             @Override
1:             public void run() {
1:                 LOG.trace("Receiver {} running scheduled stop", this);
1:                 if (getEndpoint().getRemoteCredit() != 0) {
1:                     stop(request);
1:                     session.pumpToProtonTransport(request);
1:                 }
1:             }
1:         }, timeout, TimeUnit.MILLISECONDS);
1: 
1:         stopRequest = new ScheduledRequest(future, request);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     //----- Inner classes used in message pull operations --------------------//
1: 
1:     protected static final class ScheduledRequest implements AsyncResult {
1: 
1:         private final ScheduledFuture<?> sheduledTask;
1:         private final AsyncResult origRequest;
1: 
1:         public ScheduledRequest(ScheduledFuture<?> completionTask, AsyncResult origRequest) {
1:             this.sheduledTask = completionTask;
1:             this.origRequest = origRequest;
1:         }
1: 
1:         @Override
1:         public void onFailure(Throwable cause) {
1:             sheduledTask.cancel(false);
1:             origRequest.onFailure(cause);
1:         }
1: 
1:         @Override
1:         public void onSuccess() {
1:             boolean cancelled = sheduledTask.cancel(false);
1:             if (cancelled) {
1:                 // Signal completion. Otherwise wait for the scheduled task to do it.
1:                 origRequest.onSuccess();
1:             }
1:         }
1: 
1:         @Override
1:         public boolean isComplete() {
1:             return origRequest.isComplete();
1:         }
1:     }
commit:272fb2b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.Binary;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.transaction.TransactionalState;
/////////////////////////////////////////////////////////////////////////
1:                         if (session.isInTransaction()) {
1:                             Binary txnId = session.getTransactionId().getRemoteTxId();
1:                             if (txnId != null) {
1:                                 TransactionalState txState = new TransactionalState();
1:                                 txState.setOutcome(Accepted.getInstance());
1:                                 txState.setTxnId(txnId);
1:                                 delivery.disposition(txState);
1:                                 delivery.settle();
1:                                 session.getTransactionContext().registerTxConsumer(AmqpReceiver.this);
1:                             }
1:                         } else {
1:                             delivery.disposition(Accepted.getInstance());
1:                             delivery.settle();
1:                         }
0:                     session.pumpToProtonTransport();
/////////////////////////////////////////////////////////////////////////
1: 
1:     //----- Internal Transaction state callbacks -----------------------------//
1: 
1:     void preCommit() {
1:     }
1: 
1:     void preRollback() {
1:     }
1: 
1:     void postCommit() {
1:     }
1: 
1:     void postRollback() {
1:     }
commit:82a5839
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.IOExceptionSupport;
commit:7c06d8d
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             getStateInspector().inspectOpenedResource(getReceiver());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:         try {
1:             getStateInspector().inspectClosedResource(getReceiver());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:         try {
1:             getStateInspector().inspectDetachedResource(getReceiver());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
commit:6a2ffca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.messaging.Rejected;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Symbol[] outcomes = new Symbol[]{Accepted.DESCRIPTOR_SYMBOL, Rejected.DESCRIPTOR_SYMBOL,
1:                                          Released.DESCRIPTOR_SYMBOL, Modified.DESCRIPTOR_SYMBOL};
commit:8e6a404
/////////////////////////////////////////////////////////////////////////
1:     private final Source userSpecifiedSource;
/////////////////////////////////////////////////////////////////////////
1:         this.userSpecifiedSource = null;
/////////////////////////////////////////////////////////////////////////
1:         if (source == null && address != null) {
commit:4228e3d
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (address != null && address.isEmpty()) {
1:             throw new IllegalArgumentException("Address cannot be empty.");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (userSpecifiedSource == null && address != null) {
commit:ca456c4
/////////////////////////////////////////////////////////////////////////
0:     private Source userSpecifiedSource;
/////////////////////////////////////////////////////////////////////////
1:      * Create a new receiver instance.
1:      *
1:      * @param session
1:      *        The parent session that created the receiver.
1:      * @param source
1:      *        The Source instance to use instead of creating and configuring one.
1:      * @param receiverId
1:      *        The unique ID assigned to this receiver.
1:      */
1:     public AmqpReceiver(AmqpSession session, Source source, String receiverId) {
1: 
1:         if (source == null) {
1:             throw new IllegalArgumentException("User specified Source cannot be null");
1:         }
1: 
1:         this.session = session;
1:         this.userSpecifiedSource = source;
1:         this.address = source.getAddress();
1:         this.receiverId = receiverId;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         Source source = userSpecifiedSource;
0:         if (userSpecifiedSource == null) {
1:             source = new Source();
1:             source.setAddress(address);
1:             configureSource(source);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             filters.put(NO_LOCAL_NAME, AmqpNoLocalFilter.NO_LOCAL);
1:             filters.put(JMS_SELECTOR_NAME, new AmqpJmsSelectorFilter(getSelector()));
commit:934ad44
/////////////////////////////////////////////////////////////////////////
1:      * Close the receiver, a closed receiver will throw exceptions if any further send
1:      * @throws IOException if an error occurs while closing the receiver.
/////////////////////////////////////////////////////////////////////////
1:      * Detach the receiver, a closed receiver will throw exceptions if any further send
1:      * calls are made.
1:      *
1:      * @throws IOException if an error occurs while closing the receiver.
1:      */
1:     public void detach() throws IOException {
1:         if (closed.compareAndSet(false, true)) {
1:             final ClientFuture request = new ClientFuture();
1:             session.getScheduler().execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     checkClosed();
1:                     detach(request);
0:                     session.pumpToProtonTransport();
1:                 }
1:             });
1: 
1:             request.sync();
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         getEndpoint().close();
1:     }
1: 
1:     @Override
1:     protected void doDetach() {
1:         getEndpoint().detach();
commit:72839b7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.client;
1: 
1: import static org.apache.activemq.transport.amqp.AmqpSupport.COPY;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_NAME;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_NAME;
1: 
1: import java.io.ByteArrayOutputStream;
1: import java.io.IOException;
1: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.concurrent.BlockingQueue;
1: import java.util.concurrent.LinkedBlockingDeque;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import javax.jms.InvalidDestinationException;
1: 
1: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
0: import org.apache.activemq.transport.amqp.client.util.UnmodifiableReceiver;
0: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.qpid.proton.amqp.DescribedType;
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.amqp.messaging.Accepted;
1: import org.apache.qpid.proton.amqp.messaging.Modified;
1: import org.apache.qpid.proton.amqp.messaging.Released;
1: import org.apache.qpid.proton.amqp.messaging.Source;
1: import org.apache.qpid.proton.amqp.messaging.Target;
1: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
1: import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
1: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1: import org.apache.qpid.proton.engine.Delivery;
1: import org.apache.qpid.proton.engine.Receiver;
1: import org.apache.qpid.proton.message.Message;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Receiver class that manages a Proton receiver endpoint.
1:  */
1: public class AmqpReceiver extends AmqpAbstractResource<Receiver> {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AmqpReceiver.class);
1: 
0:     // TODO: Use constants available from Proton 0.9
0:     private static final Symbol ACCEPTED_DESCRIPTOR_SYMBOL = Symbol.valueOf("amqp:accepted:list");
0:     private static final Symbol REJECTED_DESCRIPTOR_SYMBOL = Symbol.valueOf("amqp:rejected:list");
0:     private static final Symbol MODIFIED_DESCRIPTOR_SYMBOL = Symbol.valueOf("amqp:modified:list");
0:     private static final Symbol RELEASED_DESCRIPTOR_SYMBOL = Symbol.valueOf("amqp:released:list");
1: 
1:     private final AtomicBoolean closed = new AtomicBoolean();
1: 
0:     private final BlockingQueue<AmqpMessage> prefetch = new LinkedBlockingDeque<AmqpMessage>();
1: 
1:     private final AmqpSession session;
1:     private final String address;
1:     private final String receiverId;
1: 
1:     private String subscriptionName;
1:     private String selector;
1:     private boolean presettle;
1:     private boolean noLocal;
1: 
1:     /**
1:      * Create a new receiver instance.
1:      *
1:      * @param session
0:      * 		  The parent session that created the receiver.
1:      * @param address
1:      *        The address that this receiver should listen on.
1:      * @param receiverId
1:      *        The unique ID assigned to this receiver.
1:      */
1:     public AmqpReceiver(AmqpSession session, String address, String receiverId) {
1:         this.session = session;
1:         this.address = address;
1:         this.receiverId = receiverId;
1:     }
1: 
1:     /**
0:      * Close the sender, a closed sender will throw exceptions if any further send
1:      * calls are made.
1:      *
0:      * @throws IOException if an error occurs while closing the sender.
1:      */
1:     public void close() throws IOException {
1:         if (closed.compareAndSet(false, true)) {
1:             final ClientFuture request = new ClientFuture();
1:             session.getScheduler().execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     checkClosed();
1:                     close(request);
0:                     session.pumpToProtonTransport();
1:                 }
1:             });
1: 
1:             request.sync();
1:         }
1:     }
1: 
1:     /**
1:      * @return this session's parent AmqpSession.
1:      */
1:     public AmqpSession getSession() {
1:         return session;
1:     }
1: 
1:     /**
1:      * @return the address that this receiver has been configured to listen on.
1:      */
1:     public String getAddress() {
1:         return address;
1:     }
1: 
1:     /**
1:      * Attempts to wait on a message to be delivered to this receiver.  The receive
1:      * call will wait indefinitely for a message to be delivered.
1:      *
1:      * @return a newly received message sent to this receiver.
1:      *
1:      * @throws Exception if an error occurs during the receive attempt.
1:      */
1:     public AmqpMessage receive() throws Exception {
1:         checkClosed();
1:         return prefetch.take();
1:     }
1: 
1:     /**
1:      * Attempts to receive a message sent to this receiver, waiting for the given
1:      * timeout value before giving up and returning null.
1:      *
1:      * @param timeout
1:      * 	      the time to wait for a new message to arrive.
1:      * @param unit
1:      * 		  the unit of time that the timeout value represents.
1:      *
1:      * @return a newly received message or null if the time to wait period expires.
1:      *
1:      * @throws Exception if an error occurs during the receive attempt.
1:      */
1:     public AmqpMessage receive(long timeout, TimeUnit unit) throws Exception {
1:         checkClosed();
1:         return prefetch.poll(timeout, unit);
1:     }
1: 
1:     /**
1:      * If a message is already available in this receiver's prefetch buffer then
1:      * it is returned immediately otherwise this methods return null without waiting.
1:      *
1:      * @return a newly received message or null if there is no currently available message.
1:      *
1:      * @throws Exception if an error occurs during the receive attempt.
1:      */
1:     public AmqpMessage receiveNoWait() throws Exception {
1:         checkClosed();
1:         return prefetch.poll();
1:     }
1: 
1:     /**
1:      * Controls the amount of credit given to the receiver link.
1:      *
1:      * @param credit
1:      *        the amount of credit to grant.
1:      *
1:      * @throws IOException if an error occurs while sending the flow.
1:      */
1:     public void flow(final int credit) throws IOException {
1:         checkClosed();
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
1:                     getEndpoint().flow(credit);
0:                     session.pumpToProtonTransport();
1:                     request.onSuccess();
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
1:     /**
1:      * Attempts to drain a given amount of credit from the link.
1:      *
1:      * @param credit
1:      *        the amount of credit to drain.
1:      *
1:      * @throws IOException if an error occurs while sending the drain.
1:      */
1:     public void drain(final int credit) throws IOException {
1:         checkClosed();
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
1:                     getEndpoint().drain(credit);
0:                     session.pumpToProtonTransport();
1:                     request.onSuccess();
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
1:     /**
0:      * Accepts a message that was dispatched under the given Delivery instance.
1:      *
1:      * @param delivery
1:      *        the Delivery instance to accept.
1:      *
1:      * @throws IOException if an error occurs while sending the accept.
1:      */
0:     public void accept(final Delivery delivery) throws IOException {
1:         checkClosed();
1: 
1:         if (delivery == null) {
1:             throw new IllegalArgumentException("Delivery to accept cannot be null");
1:         }
1: 
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
1:                     if (!delivery.isSettled()) {
0:                         delivery.disposition(Accepted.getInstance());
1:                         delivery.settle();
0:                         session.pumpToProtonTransport();
1:                     }
1:                     request.onSuccess();
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
1:     /**
0:      * Reject a message that was dispatched under the given Delivery instance.
1:      *
1:      * @param delivery
0:      *        the Delivery instance to reject.
1:      * @param undeliverableHere
1:      *        marks the delivery as not being able to be process by link it was sent to.
1:      * @param deliveryFailed
1:      *        indicates that the delivery failed for some reason.
1:      *
1:      * @throws IOException if an error occurs while sending the reject.
1:      */
0:     public void reject(final Delivery delivery, final boolean undeliverableHere, final boolean deliveryFailed) throws IOException {
1:         checkClosed();
1: 
1:         if (delivery == null) {
1:             throw new IllegalArgumentException("Delivery to reject cannot be null");
1:         }
1: 
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
1:                     if (!delivery.isSettled()) {
1:                         Modified disposition = new Modified();
1:                         disposition.setUndeliverableHere(undeliverableHere);
1:                         disposition.setDeliveryFailed(deliveryFailed);
1:                         delivery.disposition(disposition);
1:                         delivery.settle();
0:                         session.pumpToProtonTransport();
1:                     }
1:                     request.onSuccess();
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
1:     /**
1:      * Release a message that was dispatched under the given Delivery instance.
1:      *
1:      * @param delivery
1:      *        the Delivery instance to release.
1:      *
1:      * @throws IOException if an error occurs while sending the release.
1:      */
1:     public void release(final Delivery delivery) throws IOException {
1:         checkClosed();
1: 
1:         if (delivery == null) {
1:             throw new IllegalArgumentException("Delivery to release cannot be null");
1:         }
1: 
1:         final ClientFuture request = new ClientFuture();
1:         session.getScheduler().execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
1:                     if (!delivery.isSettled()) {
1:                         delivery.disposition(Released.getInstance());
1:                         delivery.settle();
0:                         session.pumpToProtonTransport();
1:                     }
1:                     request.onSuccess();
1:                 } catch (Exception e) {
1:                     request.onFailure(e);
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
1:     /**
1:      * @return an unmodifiable view of the underlying Receiver instance.
1:      */
1:     public Receiver getReceiver() {
0:         return new UnmodifiableReceiver(getEndpoint());
1:     }
1: 
1:     //----- Receiver configuration properties --------------------------------//
1: 
1:     public boolean isPresettle() {
1:         return presettle;
1:     }
1: 
1:     public void setPresettle(boolean presettle) {
1:         this.presettle = presettle;
1:     }
1: 
1:     public boolean isDurable() {
1:         return subscriptionName != null;
1:     }
1: 
1:     public String getSubscriptionName() {
1:         return subscriptionName;
1:     }
1: 
1:     public void setSubscriptionName(String subscriptionName) {
1:         this.subscriptionName = subscriptionName;
1:     }
1: 
1:     public String getSelector() {
1:         return selector;
1:     }
1: 
1:     public void setSelector(String selector) {
1:         this.selector = selector;
1:     }
1: 
1:     public boolean isNoLocal() {
1:         return noLocal;
1:     }
1: 
1:     public void setNoLocal(boolean noLocal) {
1:         this.noLocal = noLocal;
1:     }
1: 
1:     //----- Internal implementation ------------------------------------------//
1: 
1:     @Override
1:     protected void doOpen() {
1: 
0:         Source source = new Source();
0:         source.setAddress(address);
1:         Target target = new Target();
1: 
0:         configureSource(source);
1: 
1:         String receiverName = receiverId + ":" + address;
1: 
1:         if (getSubscriptionName() != null && !getSubscriptionName().isEmpty()) {
1:             // In the case of Durable Topic Subscriptions the client must use the same
1:             // receiver name which is derived from the subscription name property.
1:             receiverName = getSubscriptionName();
1:         }
1: 
1:         Receiver receiver = session.getEndpoint().receiver(receiverName);
1:         receiver.setSource(source);
1:         receiver.setTarget(target);
0:         if (isPresettle()) {
0:             receiver.setSenderSettleMode(SenderSettleMode.SETTLED);
1:         } else {
0:             receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);
1:         }
0:         receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1: 
1:         setEndpoint(receiver);
1: 
1:         super.doOpen();
1:     }
1: 
1:     @Override
1:     protected void doOpenCompletion() {
1:         // Verify the attach response contained a non-null Source
1:         org.apache.qpid.proton.amqp.transport.Source s = getEndpoint().getRemoteSource();
1:         if (s != null) {
1:             super.doOpenCompletion();
1:         } else {
1:             // No link terminus was created, the peer will now detach/close us.
1:         }
1:     }
1: 
1:     @Override
1:     protected void doClose() {
0:         if (isDurable()) {
0:             getEndpoint().detach();
1:         } else {
0:             getEndpoint().close();
1:         }
1:     }
1: 
1:     @Override
1:     protected Exception getOpenAbortException() {
1:         // Verify the attach response contained a non-null Source
1:         org.apache.qpid.proton.amqp.transport.Source s = getEndpoint().getRemoteSource();
1:         if (s != null) {
1:             return super.getOpenAbortException();
1:         } else {
1:             // No link terminus was created, the peer has detach/closed us, create IDE.
1:             return new InvalidDestinationException("Link creation was refused");
1:         }
1:     }
1: 
1:     @Override
1:     protected void doOpenInspection() {
0:         getStateInspector().inspectOpenedResource(getReceiver());
1:     }
1: 
1:     @Override
1:     protected void doClosedInspection() {
0:         getStateInspector().inspectClosedResource(getReceiver());
1:     }
1: 
1:     @Override
1:     protected void doDetachedInspection() {
0:         getStateInspector().inspectDetachedResource(getReceiver());
1:     }
1: 
1:     protected void configureSource(Source source) {
0:         Map<Symbol, DescribedType> filters = new HashMap<Symbol, DescribedType>();
0:         Symbol[] outcomes = new Symbol[]{ACCEPTED_DESCRIPTOR_SYMBOL, REJECTED_DESCRIPTOR_SYMBOL,
0:                                          RELEASED_DESCRIPTOR_SYMBOL, MODIFIED_DESCRIPTOR_SYMBOL};
1: 
1:         if (getSubscriptionName() != null && !getSubscriptionName().isEmpty()) {
1:             source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
1:             source.setDurable(TerminusDurability.UNSETTLED_STATE);
1:             source.setDistributionMode(COPY);
1:         } else {
1:             source.setDurable(TerminusDurability.NONE);
1:             source.setExpiryPolicy(TerminusExpiryPolicy.LINK_DETACH);
1:         }
1: 
1:         source.setOutcomes(outcomes);
1: 
1:         Modified modified = new Modified();
1:         modified.setDeliveryFailed(true);
1:         modified.setUndeliverableHere(false);
1: 
1:         source.setDefaultOutcome(modified);
1: 
1:         if (isNoLocal()) {
0:             filters.put(NO_LOCAL_NAME, AmqpNoLocalType.NO_LOCAL);
1:         }
1: 
1:         if (getSelector() != null && !getSelector().trim().equals("")) {
0:             filters.put(JMS_SELECTOR_NAME, new AmqpJmsSelectorType(getSelector()));
1:         }
1: 
1:         if (!filters.isEmpty()) {
1:             source.setFilter(filters);
1:         }
1:     }
1: 
1:     @Override
1:     public void processDeliveryUpdates(AmqpConnection connection) throws IOException {
1:         Delivery incoming = null;
1:         do {
1:             incoming = getEndpoint().current();
1:             if (incoming != null) {
1:                 if(incoming.isReadable() && !incoming.isPartial()) {
1:                     LOG.trace("{} has incoming Message(s).", this);
1:                     try {
1:                         processDelivery(incoming);
1:                     } catch (Exception e) {
1:                         throw IOExceptionSupport.create(e);
1:                     }
1:                     getEndpoint().advance();
1:                 } else {
1:                     LOG.trace("{} has a partial incoming Message(s), deferring.", this);
1:                     incoming = null;
1:                 }
1:             }
1:         } while (incoming != null);
1: 
1:         super.processDeliveryUpdates(connection);
1:     }
1: 
1:     private void processDelivery(Delivery incoming) throws Exception {
1:         Message message = null;
1:         try {
1:             message = decodeIncomingMessage(incoming);
1:         } catch (Exception e) {
1:             LOG.warn("Error on transform: {}", e.getMessage());
1:             deliveryFailed(incoming, true);
1:             return;
1:         }
1: 
1:         AmqpMessage amqpMessage = new AmqpMessage(this, message, incoming);
1:         // Store reference to envelope in delivery context for recovery
1:         incoming.setContext(amqpMessage);
1:         prefetch.add(amqpMessage);
1:     }
1: 
1:     protected Message decodeIncomingMessage(Delivery incoming) {
1:         int count;
1: 
1:         byte[] chunk = new byte[2048];
1:         ByteArrayOutputStream stream = new ByteArrayOutputStream();
1: 
1:         while ((count = getEndpoint().recv(chunk, 0, chunk.length)) > 0) {
1:             stream.write(chunk, 0, count);
1:         }
1: 
1:         byte[] messageBytes = stream.toByteArray();
1: 
1:         try {
1:             Message protonMessage = Message.Factory.create();
1:             protonMessage.decode(messageBytes, 0, messageBytes.length);
1:             return protonMessage;
1:         } finally {
1:             try {
1:                 stream.close();
1:             } catch (IOException e) {
1:             }
1:         }
1:     }
1: 
1:     protected void deliveryFailed(Delivery incoming, boolean expandCredit) {
1:         Modified disposition = new Modified();
1:         disposition.setUndeliverableHere(true);
1:         disposition.setDeliveryFailed(true);
1:         incoming.disposition(disposition);
1:         incoming.settle();
1:         if (expandCredit) {
1:             getEndpoint().flow(1);
1:         }
1:     }
1: 
1:     @Override
1:     public String toString() {
1:         return getClass().getSimpleName() + "{ address = " + address + "}";
1:     }
1: 
1:     private void checkClosed() {
1:         if (isClosed()) {
1:             throw new IllegalStateException("Receiver is already closed");
1:         }
1:     }
1: }
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:0cfd225
/////////////////////////////////////////////////////////////////////////
1:      * Mark a message that was dispatched under the given Delivery instance as Modified.
1:      *        the Delivery instance to mark modified.
0:      * @param undeliverableHere
0:      *        marks the delivery as not being able to be process by link it was sent to.
1:     public void modified(final Delivery delivery, final Boolean deliveryFailed, final Boolean undeliverableHere) throws IOException {
============================================================================