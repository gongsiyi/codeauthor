1:fc00993: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b0c2a40:  *
1:d1a18f5:  *      http://www.apache.org/licenses/LICENSE-2.0
4:d1a18f5:  *
1:d1a18f5:  * Unless required by applicable law or agreed to in writing, software
1:d1a18f5:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d1a18f5:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d1a18f5:  * See the License for the specific language governing permissions and
1:d1a18f5:  * limitations under the License.
1:d1a18f5:  */
1:d1a18f5: package org.apache.activemq.broker.view;
19:d1a18f5: 
1:38ab4b1: import java.io.IOException;
1:38ab4b1: import java.io.PrintWriter;
1:38ab4b1: import java.util.Collection;
1:38ab4b1: import java.util.HashMap;
1:38ab4b1: import java.util.HashSet;
1:38ab4b1: import java.util.Iterator;
1:38ab4b1: import java.util.Map;
1:38ab4b1: import java.util.Set;
1:38ab4b1: 
1:38ab4b1: import javax.management.ObjectName;
1:38ab4b1: 
1:d1a18f5: import org.apache.activemq.broker.Broker;
1:d1a18f5: import org.apache.activemq.broker.ConnectionContext;
1:84eb9f8: import org.apache.activemq.broker.ProducerBrokerExchange;
1:d1a18f5: import org.apache.activemq.broker.jmx.BrokerViewMBean;
1:d1a18f5: import org.apache.activemq.broker.jmx.SubscriptionViewMBean;
1:d1a18f5: import org.apache.activemq.broker.region.Subscription;
1:d1a18f5: import org.apache.activemq.command.ActiveMQDestination;
1:d1a18f5: import org.apache.activemq.command.ConsumerInfo;
1:8c20a11: import org.apache.activemq.command.Message;
1:8c20a11: import org.apache.activemq.command.ProducerId;
1:d1a18f5: import org.apache.activemq.command.ProducerInfo;
1:d1a18f5: import org.apache.activemq.filter.DestinationMapNode;
1:75270af: 
1:d1a18f5: /**
1:38ab4b1:  *
1:d1a18f5:  */
1:d1a18f5: public class ConnectionDotFileInterceptor extends DotFileInterceptorSupport {
1:75270af: 
1:d1a18f5:     protected static final String ID_SEPARATOR = "_";
1:8c20a11: 
1:d1a18f5:     private final boolean redrawOnRemove;
1:230a86c:     private boolean clearProducerCacheAfterRender;
1:38ab4b1:     private final String domain = "org.apache.activemq";
1:d1a18f5:     private BrokerViewMBean brokerView;
1:d1a18f5: 
1:8c20a11:     // until we have some MBeans for producers, lets do it all ourselves
1:38ab4b1:     private final Map<ProducerId, ProducerInfo> producers = new HashMap<ProducerId, ProducerInfo>();
1:38ab4b1:     private final Map<ProducerId, Set<ActiveMQDestination>> producerDestinations = new HashMap<ProducerId, Set<ActiveMQDestination>>();
1:38ab4b1:     private final Object lock = new Object();
1:8c20a11: 
1:21b44e9:     public ConnectionDotFileInterceptor(Broker next, String file, boolean redrawOnRemove) throws IOException {
1:d1a18f5:         super(next, file);
1:d1a18f5:         this.redrawOnRemove = redrawOnRemove;
1:38ab4b1: 
6:d1a18f5:     }
1:1ec71bd: 
1:38ab4b1:     @Override
1:d1a18f5:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:d1a18f5:         Subscription answer = super.addConsumer(context, info);
1:d1a18f5:         generateFile();
1:d1a18f5:         return answer;
1:d1a18f5:     }
1:1ec71bd: 
1:38ab4b1:     @Override
1:d1a18f5:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:d1a18f5:         super.addProducer(context, info);
1:8c20a11:         ProducerId producerId = info.getProducerId();
1:230a86c:         synchronized (lock) {
1:8c20a11:             producers.put(producerId, info);
1:8c20a11:         }
1:d1a18f5:         generateFile();
1:d1a18f5:     }
1:d1a18f5: 
1:38ab4b1:     @Override
1:d1a18f5:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:d1a18f5:         super.removeConsumer(context, info);
1:d1a18f5:         if (redrawOnRemove) {
1:d1a18f5:             generateFile();
1:d1a18f5:         }
1:d1a18f5:     }
1:d1a18f5: 
1:38ab4b1:     @Override
1:d1a18f5:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:d1a18f5:         super.removeProducer(context, info);
1:8c20a11:         ProducerId producerId = info.getProducerId();
1:d1a18f5:         if (redrawOnRemove) {
1:8c20a11:             synchronized (lock) {
1:8c20a11:                 producerDestinations.remove(producerId);
1:8c20a11:                 producers.remove(producerId);
1:8c20a11:             }
1:d1a18f5:             generateFile();
1:d1a18f5:         }
1:d1a18f5:     }
1:d1a18f5: 
1:38ab4b1:     @Override
1:84eb9f8:     public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {
1:84eb9f8:         super.send(producerExchange, messageSend);
1:8c20a11:         ProducerId producerId = messageSend.getProducerId();
1:8c20a11:         ActiveMQDestination destination = messageSend.getDestination();
1:8c20a11:         synchronized (lock) {
1:ecf89a6:             Set<ActiveMQDestination> destinations = producerDestinations.get(producerId);
1:8c20a11:             if (destinations == null) {
1:ecf89a6:                 destinations = new HashSet<ActiveMQDestination>();
1:8c20a11:             }
1:8c20a11:             producerDestinations.put(producerId, destinations);
1:8c20a11:             destinations.add(destination);
1:8c20a11:         }
1:8c20a11:     }
1:8c20a11: 
1:38ab4b1:     @Override
1:d1a18f5:     protected void generateFile(PrintWriter writer) throws Exception {
1:d1a18f5: 
1:d1a18f5:         writer.println("digraph \"ActiveMQ Connections\" {");
3:d1a18f5:         writer.println();
1:1ec71bd:         writer.println("label=\"ActiveMQ Broker: " + getBrokerView().getBrokerId() + "\"];");
1:8c20a11:         writer.println();
1:d1a18f5:         writer.println("node [style = \"rounded,filled\", fillcolor = yellow, fontname=\"Helvetica-Oblique\"];");
1:d1a18f5:         writer.println();
1:8c20a11: 
1:ecf89a6:         Map<String, String> clients = new HashMap<String, String>();
1:ecf89a6:         Map<String, String> queues = new HashMap<String, String>();
1:ecf89a6:         Map<String, String> topics = new HashMap<String, String>();
1:8c20a11: 
1:1ec71bd:         printSubscribers(writer, clients, queues, "queue_", getBrokerView().getQueueSubscribers());
1:d1a18f5:         writer.println();
1:d1a18f5: 
1:1ec71bd:         printSubscribers(writer, clients, topics, "topic_", getBrokerView().getTopicSubscribers());
1:d1a18f5:         writer.println();
1:d1a18f5: 
1:8c20a11:         printProducers(writer, clients, queues, topics);
1:8c20a11:         writer.println();
1:8c20a11: 
1:d1a18f5:         writeLabels(writer, "green", "Client: ", clients);
1:d1a18f5:         writer.println();
1:d1a18f5: 
1:8c20a11:         writeLabels(writer, "red", "Queue: ", queues);
1:8c20a11:         writeLabels(writer, "blue", "Topic: ", topics);
1:d1a18f5:         writer.println("}");
1:d1a18f5: 
1:8c20a11:         if (clearProducerCacheAfterRender) {
1:8c20a11:             producerDestinations.clear();
1:d1a18f5:         }
1:d1a18f5:     }
1:d1a18f5: 
1:ecf89a6:     protected void printProducers(PrintWriter writer, Map<String, String> clients, Map<String, String> queues, Map<String, String> topics) {
1:8c20a11:         synchronized (lock) {
1:75270af:             for (Iterator iter = producerDestinations.entrySet().iterator(); iter.hasNext();) {
1:230a86c:                 Map.Entry entry = (Map.Entry)iter.next();
1:230a86c:                 ProducerId producerId = (ProducerId)entry.getKey();
1:230a86c:                 Set destinationSet = (Set)entry.getValue();
1:75270af:                 printProducers(writer, clients, queues, topics, producerId, destinationSet);
1:75270af:             }
1:8c20a11:         }
1:8c20a11:     }
1:8c20a11: 
1:ecf89a6:     protected void printProducers(PrintWriter writer, Map<String, String> clients, Map<String, String> queues, Map<String, String> topics, ProducerId producerId, Set destinationSet) {
1:8c20a11:         for (Iterator iter = destinationSet.iterator(); iter.hasNext();) {
1:230a86c:             ActiveMQDestination destination = (ActiveMQDestination)iter.next();
1:8c20a11: 
1:8c20a11:             // TODO use clientId one day
1:8c20a11:             String clientId = producerId.getConnectionId();
1:8c20a11:             String safeClientId = asID(clientId);
1:8c20a11:             clients.put(safeClientId, clientId);
1:8c20a11: 
1:8c20a11:             String physicalName = destination.getPhysicalName();
1:8c20a11:             String safeDestinationId = asID(physicalName);
1:8c20a11:             if (destination.isTopic()) {
1:8c20a11:                 safeDestinationId = "topic_" + safeDestinationId;
1:8c20a11:                 topics.put(safeDestinationId, physicalName);
1:230a86c:             } else {
1:8c20a11:                 safeDestinationId = "queue_" + safeDestinationId;
1:8c20a11:                 queues.put(safeDestinationId, physicalName);
1:8c20a11:             }
1:8c20a11: 
1:8c20a11:             String safeProducerId = asID(producerId.toString());
1:230a86c: 
1:8c20a11:             // lets write out the links
1:8c20a11: 
1:8c20a11:             writer.print(safeClientId);
1:8c20a11:             writer.print(" -> ");
1:8c20a11:             writer.print(safeProducerId);
1:8c20a11:             writer.println(";");
1:8c20a11: 
1:8c20a11:             writer.print(safeProducerId);
1:8c20a11:             writer.print(" -> ");
1:8c20a11:             writer.print(safeDestinationId);
1:8c20a11:             writer.println(";");
1:8c20a11: 
1:8c20a11:             // now lets write out the label
1:8c20a11:             writer.print(safeProducerId);
1:8c20a11:             writer.print(" [label = \"");
1:8c20a11:             String label = "Producer: " + producerId.getSessionId() + "-" + producerId.getValue();
1:8c20a11:             writer.print(label);
1:8c20a11:             writer.println("\"];");
1:8c20a11: 
1:8c20a11:         }
1:8c20a11:     }
1:8c20a11: 
1:ecf89a6:     protected void printSubscribers(PrintWriter writer, Map<String, String> clients, Map<String, String> destinations, String type, ObjectName[] subscribers) {
1:d1a18f5:         for (int i = 0; i < subscribers.length; i++) {
1:d1a18f5:             ObjectName name = subscribers[i];
1:1ec71bd:             SubscriptionViewMBean subscriber = (SubscriptionViewMBean)getBrokerService().getManagementContext().newProxyInstance(name, SubscriptionViewMBean.class, true);
1:8c20a11: 
1:d1a18f5:             String clientId = subscriber.getClientId();
1:d1a18f5:             String safeClientId = asID(clientId);
1:d1a18f5:             clients.put(safeClientId, clientId);
1:230a86c: 
1:8c20a11:             String destination = subscriber.getDestinationName();
1:d1a18f5:             String safeDestinationId = type + asID(destination);
1:d1a18f5:             destinations.put(safeDestinationId, destination);
1:230a86c: 
1:8c20a11:             String selector = subscriber.getSelector();
1:8c20a11: 
1:d1a18f5:             // lets write out the links
1:38ab4b1:             String subscriberId = safeClientId + "_" + subscriber.getSessionId() + "_" + subscriber.getSubscriptionId();
1:8c20a11: 
1:d1a18f5:             writer.print(subscriberId);
1:8c20a11:             writer.print(" -> ");
1:8c20a11:             writer.print(safeClientId);
1:d1a18f5:             writer.println(";");
1:d1a18f5: 
1:d1a18f5:             writer.print(safeDestinationId);
2:d1a18f5:             writer.print(" -> ");
1:d1a18f5:             writer.print(subscriberId);
1:d1a18f5:             writer.println(";");
1:d1a18f5: 
1:d1a18f5:             // now lets write out the label
1:d1a18f5:             writer.print(subscriberId);
1:d1a18f5:             writer.print(" [label = \"");
1:38ab4b1:             String label = "Subscription: " + subscriber.getSessionId() + "-" + subscriber.getSubscriptionId();
1:d1a18f5:             if (selector != null && selector.length() > 0) {
1:d1a18f5:                 label = label + "\\nSelector: " + selector;
1:8c20a11:             }
2:d1a18f5:             writer.print(label);
2:d1a18f5:             writer.println("\"];");
1:d1a18f5:         }
1:d1a18f5:     }
1:d1a18f5: 
1:ecf89a6:     protected void writeLabels(PrintWriter writer, String color, String prefix, Map<String, String> map) {
1:8c20a11:         for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
1:230a86c:             Map.Entry entry = (Map.Entry)iter.next();
1:230a86c:             String id = (String)entry.getKey();
1:230a86c:             String label = (String)entry.getValue();
1:8c20a11: 
1:8c20a11:             writer.print(id);
1:8c20a11:             writer.print(" [ fillcolor = ");
1:8c20a11:             writer.print(color);
1:8c20a11:             writer.print(", label = \"");
1:8c20a11:             writer.print(prefix);
1:8c20a11:             writer.print(label);
1:8c20a11:             writer.println("\"];");
1:8c20a11:         }
1:8c20a11:     }
1:8c20a11: 
1:d1a18f5:     /**
1:d1a18f5:      * Lets strip out any non supported characters
1:d1a18f5:      */
1:d1a18f5:     protected String asID(String name) {
1:d1a18f5:         StringBuffer buffer = new StringBuffer();
1:933eb2f:         int size = name.length();
1:933eb2f:         for (int i = 0; i < size; i++) {
1:d1a18f5:             char ch = name.charAt(i);
1:d1a18f5:             if (Character.isLetterOrDigit(ch) || ch == '_') {
1:d1a18f5:                 buffer.append(ch);
1:230a86c:             } else {
1:d1a18f5:                 buffer.append('_');
1:d1a18f5:             }
1:d1a18f5:         }
1:d1a18f5:         return buffer.toString();
1:d1a18f5:     }
1:d1a18f5: 
1:d1a18f5:     protected void printNodes(PrintWriter writer, DestinationMapNode node, String prefix) {
1:d1a18f5:         String path = getPath(node);
1:d1a18f5:         writer.print("  ");
2:d1a18f5:         writer.print(prefix);
1:d1a18f5:         writer.print(ID_SEPARATOR);
1:d1a18f5:         writer.print(path);
1:d1a18f5:         String label = path;
1:d1a18f5:         if (prefix.equals("topic")) {
1:d1a18f5:             label = "Topics";
1:230a86c:         } else if (prefix.equals("queue")) {
1:d1a18f5:             label = "Queues";
1:d1a18f5:         }
1:d1a18f5:         writer.print("[ label = \"");
1:d1a18f5:         writer.print(label);
1:d1a18f5:         writer.println("\" ];");
1:d1a18f5: 
1:d1a18f5:         Collection children = node.getChildren();
1:d1a18f5:         for (Iterator iter = children.iterator(); iter.hasNext();) {
1:230a86c:             DestinationMapNode child = (DestinationMapNode)iter.next();
1:d1a18f5:             printNodes(writer, child, prefix + ID_SEPARATOR + path);
1:d1a18f5:         }
1:d1a18f5:     }
1:d1a18f5: 
1:d1a18f5:     protected void printNodeLinks(PrintWriter writer, DestinationMapNode node, String prefix) {
1:d1a18f5:         String path = getPath(node);
1:d1a18f5:         Collection children = node.getChildren();
1:d1a18f5:         for (Iterator iter = children.iterator(); iter.hasNext();) {
1:230a86c:             DestinationMapNode child = (DestinationMapNode)iter.next();
1:d1a18f5: 
1:d1a18f5:             writer.print("  ");
1:d1a18f5:             writer.print(prefix);
1:d1a18f5:             writer.print(ID_SEPARATOR);
1:d1a18f5:             writer.print(path);
1:d1a18f5:             writer.print(" -> ");
1:d1a18f5:             writer.print(prefix);
1:d1a18f5:             writer.print(ID_SEPARATOR);
1:d1a18f5:             writer.print(path);
1:d1a18f5:             writer.print(ID_SEPARATOR);
1:d1a18f5:             writer.print(getPath(child));
1:d1a18f5:             writer.println(";");
1:d1a18f5: 
1:d1a18f5:             printNodeLinks(writer, child, prefix + ID_SEPARATOR + path);
1:d1a18f5:         }
1:d1a18f5:     }
1:d1a18f5: 
1:d1a18f5:     protected String getPath(DestinationMapNode node) {
1:d1a18f5:         String path = node.getPath();
1:d1a18f5:         if (path.equals("*")) {
1:d1a18f5:             return "root";
1:d1a18f5:         }
1:d1a18f5:         return path;
1:d1a18f5:     }
1:38ab4b1: 
1:1ec71bd:     BrokerViewMBean getBrokerView() throws Exception {
1:1ec71bd:         if (this.brokerView == null) {
1:1ec71bd:             ObjectName brokerName = getBrokerService().getBrokerObjectName();
1:1ec71bd:             this.brokerView = (BrokerViewMBean) getBrokerService().getManagementContext().newProxyInstance(brokerName,
1:1ec71bd:                     BrokerViewMBean.class, true);
1:1ec71bd:         }
1:1ec71bd:         return this.brokerView;
1:1ec71bd:     }
1:d1a18f5: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:38ab4b1
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.Set;
1: 
1: import javax.management.ObjectName;
1: 
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:     private final String domain = "org.apache.activemq";
1:     private final Map<ProducerId, ProducerInfo> producers = new HashMap<ProducerId, ProducerInfo>();
1:     private final Map<ProducerId, Set<ActiveMQDestination>> producerDestinations = new HashMap<ProducerId, Set<ActiveMQDestination>>();
1:     private final Object lock = new Object();
1: 
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             String subscriberId = safeClientId + "_" + subscriber.getSessionId() + "_" + subscriber.getSubscriptionId();
/////////////////////////////////////////////////////////////////////////
1:             String label = "Subscription: " + subscriber.getSessionId() + "-" + subscriber.getSubscriptionId();
/////////////////////////////////////////////////////////////////////////
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private Map<ProducerId, Set<ActiveMQDestination>> producerDestinations = new HashMap<ProducerId, Set<ActiveMQDestination>>();
/////////////////////////////////////////////////////////////////////////
1:         int size = name.length();
1:         for (int i = 0; i < size; i++) {
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     private Map<ProducerId, ProducerInfo> producers = new HashMap<ProducerId, ProducerInfo>();
0:     private Map<ProducerId, Set> producerDestinations = new HashMap<ProducerId, Set>();
/////////////////////////////////////////////////////////////////////////
1:             Set<ActiveMQDestination> destinations = producerDestinations.get(producerId);
1:                 destinations = new HashSet<ActiveMQDestination>();
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> clients = new HashMap<String, String>();
1:         Map<String, String> queues = new HashMap<String, String>();
1:         Map<String, String> topics = new HashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
1:     protected void printProducers(PrintWriter writer, Map<String, String> clients, Map<String, String> queues, Map<String, String> topics) {
/////////////////////////////////////////////////////////////////////////
1:     protected void printProducers(PrintWriter writer, Map<String, String> clients, Map<String, String> queues, Map<String, String> topics, ProducerId producerId, Set destinationSet) {
/////////////////////////////////////////////////////////////////////////
1:     protected void printSubscribers(PrintWriter writer, Map<String, String> clients, Map<String, String> destinations, String type, ObjectName[] subscribers) {
/////////////////////////////////////////////////////////////////////////
1:     protected void writeLabels(PrintWriter writer, String color, String prefix, Map<String, String> map) {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1: /**
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean clearProducerCacheAfterRender;
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionDotFileInterceptor(Broker next, String file, boolean redrawOnRemove) throws MalformedObjectNameException {
0:         brokerView = (BrokerViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName, BrokerViewMBean.class, true);
/////////////////////////////////////////////////////////////////////////
0:             Set destinations = (Set)producerDestinations.get(producerId);
/////////////////////////////////////////////////////////////////////////
1:         synchronized (lock) {
1:                 Map.Entry entry = (Map.Entry)iter.next();
1:                 ProducerId producerId = (ProducerId)entry.getKey();
1:                 Set destinationSet = (Set)entry.getValue();
/////////////////////////////////////////////////////////////////////////
1:             ActiveMQDestination destination = (ActiveMQDestination)iter.next();
/////////////////////////////////////////////////////////////////////////
1:             } else {
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected void printSubscribers(PrintWriter writer, Map clients, Map destinations, String type, ObjectName[] subscribers) {
0:             SubscriptionViewMBean subscriber = (SubscriptionViewMBean)MBeanServerInvocationHandler.newProxyInstance(mbeanServer, name, SubscriptionViewMBean.class, true);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             Map.Entry entry = (Map.Entry)iter.next();
1:             String id = (String)entry.getKey();
1:             String label = (String)entry.getValue();
/////////////////////////////////////////////////////////////////////////
1:             } else {
/////////////////////////////////////////////////////////////////////////
1:         } else if (prefix.equals("queue")) {
/////////////////////////////////////////////////////////////////////////
1:             DestinationMapNode child = (DestinationMapNode)iter.next();
/////////////////////////////////////////////////////////////////////////
1:             DestinationMapNode child = (DestinationMapNode)iter.next();
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:75270af
/////////////////////////////////////////////////////////////////////////
0: import java.io.PrintWriter;
0: import java.util.Collection;
0: import java.util.HashMap;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.Map;
0: import java.util.Set;
1: 
0: import javax.management.MBeanServer;
0: import javax.management.MBeanServerInvocationHandler;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         synchronized(lock) {
1:             for (Iterator iter = producerDestinations.entrySet().iterator(); iter.hasNext();) {
0:                 Map.Entry entry = (Map.Entry) iter.next();
0:                 ProducerId producerId = (ProducerId) entry.getKey();
0:                 Set destinationSet = (Set) entry.getValue();
1:                 printProducers(writer, clients, queues, topics, producerId, destinationSet);
1:             }
author:Robert Davies
-------------------------------------------------------------------------------
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.io.PrintWriter;
0: import java.util.Collection;
0: import java.util.HashMap;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.Map;
0: import java.util.Set;
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         writer.println("label=\"ActiveMQ Broker: " + getBrokerView().getBrokerId() + "\"];");
/////////////////////////////////////////////////////////////////////////
1:         printSubscribers(writer, clients, queues, "queue_", getBrokerView().getQueueSubscribers());
1:         printSubscribers(writer, clients, topics, "topic_", getBrokerView().getTopicSubscribers());
/////////////////////////////////////////////////////////////////////////
1:             SubscriptionViewMBean subscriber = (SubscriptionViewMBean)getBrokerService().getManagementContext().newProxyInstance(name, SubscriptionViewMBean.class, true);
/////////////////////////////////////////////////////////////////////////
1:     
1:     BrokerViewMBean getBrokerView() throws Exception {
1:         if (this.brokerView == null) {
1:             ObjectName brokerName = getBrokerService().getBrokerObjectName();
1:             this.brokerView = (BrokerViewMBean) getBrokerService().getManagementContext().newProxyInstance(brokerName,
1:                     BrokerViewMBean.class, true);
1:         }
1:         return this.brokerView;
1:     }
commit:21b44e9
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1:     public ConnectionDotFileInterceptor(Broker next, String file, boolean redrawOnRemove) throws IOException {
0:         ObjectName brokerName = next.getBrokerService().getBrokerObjectName();
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.ProducerBrokerExchange;
/////////////////////////////////////////////////////////////////////////
1:     public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {
1:         super.send(producerExchange, messageSend);
author:James Strachan
-------------------------------------------------------------------------------
commit:8c20a11
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.ProducerId;
/////////////////////////////////////////////////////////////////////////
0:     private boolean clearProducerCacheAfterRender = false;
1:     // until we have some MBeans for producers, lets do it all ourselves
0:     private Map producers = new HashMap();
0:     private Map producerDestinations = new HashMap();
0:     private Object lock = new Object();
1: 
/////////////////////////////////////////////////////////////////////////
1:         ProducerId producerId = info.getProducerId();
1:         synchronized (lock) {
1:             producers.put(producerId, info);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         ProducerId producerId = info.getProducerId();
1:             synchronized (lock) {
1:                 producerDestinations.remove(producerId);
1:                 producers.remove(producerId);
1:             }
0:     public void send(ConnectionContext context, Message messageSend) throws Exception {
0:         super.send(context, messageSend);
1:         ProducerId producerId = messageSend.getProducerId();
1:         ActiveMQDestination destination = messageSend.getDestination();
1:         synchronized (lock) {
0:             Set destinations = (Set) producerDestinations.get(producerId);
1:             if (destinations == null) {
0:                 destinations = new HashSet();
1:             }
1:             producerDestinations.put(producerId, destinations);
1:             destinations.add(destination);
1:         }
1:     }
1: 
0:         writer.println("label=\"ActiveMQ Broker: " + brokerView.getBrokerId() + "\"];");
1:         writer.println();
0:         Map queues = new HashMap();
0:         Map topics = new HashMap();
1: 
0:         printSubscribers(writer, clients, queues, "queue_", brokerView.getQueueSubscribers());
0:         printSubscribers(writer, clients, topics, "topic_", brokerView.getTopicSubscribers());
1: 
1:         printProducers(writer, clients, queues, topics);
1:         writer.println();
1: 
1:         writeLabels(writer, "red", "Queue: ", queues);
1:         writeLabels(writer, "blue", "Topic: ", topics);
1:         if (clearProducerCacheAfterRender) {
1:             producerDestinations.clear();
0:     protected void printProducers(PrintWriter writer, Map clients, Map queues, Map topics) {
0:         for (Iterator iter = producerDestinations.entrySet().iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Map.Entry) iter.next();
0:             ProducerId producerId = (ProducerId) entry.getKey();
0:             Set destinationSet = (Set) entry.getValue();
0:             printProducers(writer, clients, queues, topics, producerId, destinationSet);
1:         }
1:     }
1: 
0:     protected void printProducers(PrintWriter writer, Map clients, Map queues, Map topics, ProducerId producerId, Set destinationSet) {
1:         for (Iterator iter = destinationSet.iterator(); iter.hasNext();) {
0:             ActiveMQDestination destination = (ActiveMQDestination) iter.next();
1: 
1:             // TODO use clientId one day
1:             String clientId = producerId.getConnectionId();
1:             String safeClientId = asID(clientId);
1:             clients.put(safeClientId, clientId);
1: 
1:             String physicalName = destination.getPhysicalName();
1:             String safeDestinationId = asID(physicalName);
1:             if (destination.isTopic()) {
1:                 safeDestinationId = "topic_" + safeDestinationId;
1:                 topics.put(safeDestinationId, physicalName);
1:             }
0:             else {
1:                 safeDestinationId = "queue_" + safeDestinationId;
1:                 queues.put(safeDestinationId, physicalName);
1:             }
1: 
1:             String safeProducerId = asID(producerId.toString());
1:             
1:             // lets write out the links
1: 
1:             writer.print(safeClientId);
1:             writer.print(" -> ");
1:             writer.print(safeProducerId);
1:             writer.println(";");
1: 
1:             writer.print(safeProducerId);
1:             writer.print(" -> ");
1:             writer.print(safeDestinationId);
1:             writer.println(";");
1: 
1:             // now lets write out the label
1:             writer.print(safeProducerId);
1:             writer.print(" [label = \"");
1:             String label = "Producer: " + producerId.getSessionId() + "-" + producerId.getValue();
1:             writer.print(label);
1:             writer.println("\"];");
1: 
1:         }
1:     }
1: 
1:     
/////////////////////////////////////////////////////////////////////////
1:             
1:             String destination = subscriber.getDestinationName();
1:             
1:             String selector = subscriber.getSelector();
1:             writer.print(" -> ");
1:             writer.print(safeClientId);
/////////////////////////////////////////////////////////////////////////
0:     protected void writeLabels(PrintWriter writer, String color, String prefix, Map map) {
1:         for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Map.Entry) iter.next();
0:             String id = (String) entry.getKey();
0:             String label = (String) entry.getValue();
1: 
1:             writer.print(id);
1:             writer.print(" [ fillcolor = ");
1:             writer.print(color);
1:             writer.print(", label = \"");
1:             writer.print(prefix);
1:             writer.print(label);
1:             writer.println("\"];");
1:         }
1:     }
1: 
commit:d1a18f5
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * Copyright 2005-2006 The Apache Software Foundation.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.view;
1: 
1: import org.apache.activemq.broker.Broker;
0: import org.apache.activemq.broker.Connection;
1: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.broker.Connector;
1: import org.apache.activemq.broker.jmx.BrokerViewMBean;
0: import org.apache.activemq.broker.jmx.ManagementContext;
1: import org.apache.activemq.broker.jmx.SubscriptionViewMBean;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.filter.DestinationMap;
1: import org.apache.activemq.filter.DestinationMapNode;
1: 
0: import javax.management.MBeanServer;
0: import javax.management.MBeanServerFactory;
0: import javax.management.MBeanServerInvocationHandler;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
1: 
0: import java.io.PrintWriter;
0: import java.util.*;
1: 
1: /**
1:  * 
0:  * @version $Revision: $
1:  */
1: public class ConnectionDotFileInterceptor extends DotFileInterceptorSupport {
1: 
1:     protected static final String ID_SEPARATOR = "_";
1: 
1:     private final boolean redrawOnRemove;
0:     private String domain = "org.apache.activemq";
1:     private BrokerViewMBean brokerView;
0:     private MBeanServer mbeanServer;
1: 
0:     public ConnectionDotFileInterceptor(Broker next, String file, boolean redrawOnRemove)
0:             throws MalformedObjectNameException {
1:         super(next, file);
1:         this.redrawOnRemove = redrawOnRemove;
1: 
0:         mbeanServer = new ManagementContext().getMBeanServer();
0:         ObjectName brokerName = new ObjectName(domain + ":Type=Broker,BrokerName=localhost");
0:         brokerView = (BrokerViewMBean) MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName,
0:                 BrokerViewMBean.class, true);
1:     }
1: 
1:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:         Subscription answer = super.addConsumer(context, info);
1:         generateFile();
1:         return answer;
1:     }
1: 
1:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:         super.addProducer(context, info);
1:         generateFile();
1:     }
1: 
1:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:         super.removeConsumer(context, info);
1:         if (redrawOnRemove) {
1:             generateFile();
1:         }
1:     }
1: 
1:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:         super.removeProducer(context, info);
1:         if (redrawOnRemove) {
1:             generateFile();
1:         }
1:     }
1: 
1:     protected void generateFile(PrintWriter writer) throws Exception {
1: 
1:         writer.println("digraph \"ActiveMQ Connections\" {");
1:         writer.println();
1:         writer.println("node [style = \"rounded,filled\", fillcolor = yellow, fontname=\"Helvetica-Oblique\"];");
1:         writer.println();
1: 
0:         writer.println("broker [fillcolor = deepskyblue, label=\"ActiveMQ Broker\\n" + brokerView.getBrokerId() + "\"];");
1:         writer.println();
1: 
0:         Map clients = new HashMap();
0:         Map destinations = new HashMap();
0:         printSubscribers(writer, clients, destinations, "queue_", brokerView.getQueueSubscribers());
1:         writer.println();
1:         
0:         printSubscribers(writer, clients, destinations, "topic_", brokerView.getTopicSubscribers());
1:         writer.println();
1: 
0:         // lets print the broker links
0:         for (Iterator iter = clients.keySet().iterator(); iter.hasNext();) {
0:             String clientId = (String) iter.next();
0:             writer.print(clientId);
0:             writer.println(" -> broker");
1:         }
1:         writer.println();
1:         
1:         writeLabels(writer, "green", "Client: ", clients);
1:         writer.println();
1: 
0:         writeLabels(writer, "red", "Queue: ", destinations);
1:         writer.println("}");
1:     }
1: 
0:     protected void writeLabels(PrintWriter writer, String color, String prefix, Map map) {
0:         for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Map.Entry) iter.next();
0:             String id = (String) entry.getKey();
0:             String label = (String) entry.getValue();
1: 
0:             writer.print(id);
0:             writer.print(" [ fillcolor = ");
0:             writer.print(color);
0:             writer.print(", label = \"");
1:             writer.print(prefix);
1:             writer.print(label);
1:             writer.println("\"];");
1:         }
1:     }
1: 
0:     protected void printSubscribers(PrintWriter writer, Map clients, Map destinations, String type,
0:             ObjectName[] subscribers) {
1:         for (int i = 0; i < subscribers.length; i++) {
1:             ObjectName name = subscribers[i];
0:             SubscriptionViewMBean subscriber = (SubscriptionViewMBean) MBeanServerInvocationHandler.newProxyInstance(
0:                     mbeanServer, name, SubscriptionViewMBean.class, true);
1: 
1:             String clientId = subscriber.getClientId();
0:             String destination = subscriber.getDestinationName();
0:             String selector = subscriber.getSelector();
1: 
1:             String safeClientId = asID(clientId);
1:             clients.put(safeClientId, clientId);
1: 
1:             String safeDestinationId = type + asID(destination);
1:             destinations.put(safeDestinationId, destination);
1: 
1:             // lets write out the links
1: 
0:             String subscriberId = safeClientId + "_" + subscriber.getSessionId() + "_" + subscriber.getSubcriptionId();
1: 
0:             writer.print(safeClientId);
1:             writer.print(" -> ");
1:             writer.print(subscriberId);
1:             writer.println(";");
1: 
1:             writer.print(safeDestinationId);
1:             writer.print(" -> ");
1:             writer.print(subscriberId);
1:             writer.println(";");
1: 
1:             // now lets write out the label
1:             writer.print(subscriberId);
1:             writer.print(" [label = \"");
0:             String label = "Subscription: " + subscriber.getSessionId() + "-" + subscriber.getSubcriptionId();
1:             if (selector != null && selector.length() > 0) {
1:                 label = label + "\\nSelector: " + selector;
1:             }
1:             writer.print(label);
1:             writer.println("\"];");
1:         }
1:     }
1: 
1:     /**
1:      * Lets strip out any non supported characters
1:      */
1:     protected String asID(String name) {
1:         StringBuffer buffer = new StringBuffer();
0:         for (int i = 0, size = name.length(); i < size; i++) {
1:             char ch = name.charAt(i);
1:             if (Character.isLetterOrDigit(ch) || ch == '_') {
1:                 buffer.append(ch);
1:             }
0:             else {
1:                 buffer.append('_');
1:             }
1:         }
1:         return buffer.toString();
1:     }
1: 
1:     protected void printNodes(PrintWriter writer, DestinationMapNode node, String prefix) {
1:         String path = getPath(node);
1:         writer.print("  ");
1:         writer.print(prefix);
1:         writer.print(ID_SEPARATOR);
1:         writer.print(path);
1:         String label = path;
1:         if (prefix.equals("topic")) {
1:             label = "Topics";
1:         }
0:         else if (prefix.equals("queue")) {
1:             label = "Queues";
1:         }
1:         writer.print("[ label = \"");
1:         writer.print(label);
1:         writer.println("\" ];");
1: 
1:         Collection children = node.getChildren();
1:         for (Iterator iter = children.iterator(); iter.hasNext();) {
0:             DestinationMapNode child = (DestinationMapNode) iter.next();
1:             printNodes(writer, child, prefix + ID_SEPARATOR + path);
1:         }
1:     }
1: 
1:     protected void printNodeLinks(PrintWriter writer, DestinationMapNode node, String prefix) {
1:         String path = getPath(node);
1:         Collection children = node.getChildren();
1:         for (Iterator iter = children.iterator(); iter.hasNext();) {
0:             DestinationMapNode child = (DestinationMapNode) iter.next();
1: 
1:             writer.print("  ");
1:             writer.print(prefix);
1:             writer.print(ID_SEPARATOR);
1:             writer.print(path);
1:             writer.print(" -> ");
1:             writer.print(prefix);
1:             writer.print(ID_SEPARATOR);
1:             writer.print(path);
1:             writer.print(ID_SEPARATOR);
1:             writer.print(getPath(child));
1:             writer.println(";");
1: 
1:             printNodeLinks(writer, child, prefix + ID_SEPARATOR + path);
1:         }
1:     }
1: 
1:     protected String getPath(DestinationMapNode node) {
1:         String path = node.getPath();
1:         if (path.equals("*")) {
1:             return "root";
1:         }
1:         return path;
1:     }
1: }
============================================================================