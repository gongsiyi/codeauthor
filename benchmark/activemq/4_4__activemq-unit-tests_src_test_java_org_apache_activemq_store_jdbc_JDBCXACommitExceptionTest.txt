1:e5896c0: /**
1:e5896c0:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:e5896c0:  * contributor license agreements.  See the NOTICE file distributed with
1:e5896c0:  * this work for additional information regarding copyright ownership.
1:e5896c0:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:e5896c0:  * (the "License"); you may not use this file except in compliance with
1:e5896c0:  * the License.  You may obtain a copy of the License at
1:e5896c0:  *
1:e5896c0:  *      http://www.apache.org/licenses/LICENSE-2.0
1:e5896c0:  *
1:e5896c0:  * Unless required by applicable law or agreed to in writing, software
1:e5896c0:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e5896c0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e5896c0:  * See the License for the specific language governing permissions and
1:e5896c0:  * limitations under the License.
1:e5896c0:  */
12:e5896c0: 
1:e5896c0: package org.apache.activemq.store.jdbc;
1:e5896c0: 
1:e5896c0: import javax.jms.Destination;
1:e5896c0: import javax.jms.Message;
1:e5896c0: import javax.jms.MessageConsumer;
1:ea70e82: import javax.jms.MessageProducer;
1:bd45d93: import javax.jms.Session;
1:e5896c0: import javax.jms.XAConnection;
1:e5896c0: import javax.jms.XASession;
1:bd45d93: import javax.management.ObjectName;
1:bd45d93: import javax.sql.DataSource;
1:e5896c0: import javax.transaction.xa.XAException;
1:e5896c0: import javax.transaction.xa.XAResource;
1:e5896c0: import javax.transaction.xa.Xid;
1:e5896c0: 
1:bd45d93: import java.io.InputStream;
1:bd45d93: import java.io.PrintWriter;
1:bd45d93: import java.io.Reader;
1:bd45d93: import java.math.BigDecimal;
1:bd45d93: import java.net.URL;
1:bd45d93: import java.sql.Array;
1:bd45d93: import java.sql.Blob;
1:bd45d93: import java.sql.CallableStatement;
1:bd45d93: import java.sql.Clob;
1:bd45d93: import java.sql.Connection;
1:bd45d93: import java.sql.DatabaseMetaData;
1:bd45d93: import java.sql.Date;
1:bd45d93: import java.sql.NClob;
1:bd45d93: import java.sql.ParameterMetaData;
1:bd45d93: import java.sql.PreparedStatement;
1:bd45d93: import java.sql.Ref;
1:bd45d93: import java.sql.ResultSet;
1:bd45d93: import java.sql.ResultSetMetaData;
1:bd45d93: import java.sql.RowId;
1:bd45d93: import java.sql.SQLClientInfoException;
1:bd45d93: import java.sql.SQLException;
1:bd45d93: import java.sql.SQLFeatureNotSupportedException;
1:bd45d93: import java.sql.SQLRecoverableException;
1:bd45d93: import java.sql.SQLWarning;
1:bd45d93: import java.sql.SQLXML;
1:bd45d93: import java.sql.Savepoint;
1:bd45d93: import java.sql.Statement;
1:bd45d93: import java.sql.Struct;
1:bd45d93: import java.sql.Time;
1:bd45d93: import java.sql.Timestamp;
1:bd45d93: import java.util.ArrayList;
1:bd45d93: import java.util.Arrays;
1:bd45d93: import java.util.Calendar;
1:bd45d93: import java.util.Map;
1:bd45d93: import java.util.Properties;
1:bd45d93: import java.util.concurrent.Executor;
1:bd45d93: import java.util.concurrent.atomic.AtomicBoolean;
1:bd45d93: import java.util.concurrent.atomic.AtomicInteger;
1:bd45d93: 
1:bd45d93: import org.apache.activemq.ActiveMQConnection;
1:bd45d93: import org.apache.activemq.ActiveMQConnectionFactory;
1:e5896c0: import org.apache.activemq.ActiveMQXAConnectionFactory;
1:bd45d93: import org.apache.activemq.broker.BrokerService;
1:bd45d93: import org.apache.activemq.broker.TransportConnector;
1:bd45d93: import org.apache.activemq.broker.jmx.QueueViewMBean;
1:ea70e82: import org.apache.activemq.broker.region.RegionBroker;
1:bd45d93: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
1:bd45d93: import org.apache.activemq.broker.region.policy.DiscardingDeadLetterStrategy;
1:bd45d93: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:bd45d93: import org.apache.activemq.broker.region.policy.PolicyMap;
1:bd45d93: import org.apache.activemq.command.ActiveMQDestination;
1:ea70e82: import org.apache.activemq.command.ActiveMQMessage;
1:bd45d93: import org.apache.activemq.command.ActiveMQQueue;
1:ea70e82: import org.apache.activemq.command.XATransactionId;
1:bd45d93: import org.apache.activemq.network.NetworkConnector;
1:bd45d93: import org.apache.activemq.util.DefaultIOExceptionHandler;
1:bd45d93: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:e5896c0: 
1:2a815c2: import static org.apache.activemq.util.TestUtils.createXid;
1:2a815c2: 
1:e5896c0: // https://issues.apache.org/activemq/browse/AMQ-2880
1:e5896c0: public class JDBCXACommitExceptionTest extends JDBCCommitExceptionTest {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JDBCXACommitExceptionTest.class);
1:e5896c0: 
1:2d46399:     protected ActiveMQXAConnectionFactory factory;
1:e5896c0: 
1:e5896c0:     boolean onePhase = true;
1:e5896c0: 
1:2d46399:     @Override
1:2d46399:     public void setUp() throws Exception {
1:2d46399:         super.setUp();
1:ea70e82:         onePhase = true;
1:2d46399:         factory = new ActiveMQXAConnectionFactory(
1:2d46399:             connectionUri + "?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries="+messagesExpected);
1:2d46399:     }
1:2d46399: 
1:e5896c0:     public void testTwoPhaseSqlException() throws Exception {
1:e5896c0:         onePhase = false;
1:e5896c0:         doTestSqlException();
5:e5896c0:     }
1:2d46399: 
3:4743a20:     @Override
1:e5896c0:     protected int receiveMessages(int messagesExpected) throws Exception {
1:ea70e82:         XAConnection connection = factory.createXAConnection();
1:e5896c0:         connection.start();
1:e5896c0:         XASession session = connection.createXASession();
1:4743a20: 
1:e5896c0:         jdbc.setShouldBreak(true);
1:e5896c0: 
1:e5896c0:         // first try and receive these messages, they'll continually fail
1:e5896c0:         receiveMessages(messagesExpected, session, onePhase);
1:e5896c0: 
1:e5896c0:         jdbc.setShouldBreak(false);
1:e5896c0: 
1:e5896c0:         // now that the store is sane, try and get all the messages sent
1:e5896c0:         return receiveMessages(messagesExpected, session, onePhase);
1:e5896c0:     }
1:e5896c0: 
1:e5896c0:     protected int receiveMessages(int messagesExpected, XASession session, boolean onePhase) throws Exception {
1:e5896c0:         int messagesReceived = 0;
1:e5896c0: 
1:e5896c0:         for (int i=0; i<messagesExpected; i++) {
1:e5896c0:             Destination destination = session.createQueue("TEST");
1:e5896c0:             MessageConsumer consumer = session.createConsumer(destination);
1:e5896c0: 
1:e5896c0:             XAResource resource = session.getXAResource();
1:e5896c0:             resource.recover(XAResource.TMSTARTRSCAN);
1:e5896c0:             resource.recover(XAResource.TMNOFLAGS);
1:e5896c0: 
1:e5896c0:             Xid tid = createXid();
1:e5896c0: 
1:e5896c0:             Message message = null;
1:e5896c0:             try {
1:e5896c0:                 LOG.debug("Receiving message " + (messagesReceived+1) + " of " + messagesExpected);
1:e5896c0:                 resource.start(tid, XAResource.TMNOFLAGS);
1:e5896c0:                 message = consumer.receive(2000);
1:e5896c0:                 LOG.info("Received : " + message);
1:e5896c0:                 resource.end(tid, XAResource.TMSUCCESS);
1:e5896c0:                 if (message != null) {
1:e5896c0:                     if (onePhase) {
1:e5896c0:                         resource.commit(tid, true);
1:e5896c0:                     } else {
1:e5896c0:                         resource.prepare(tid);
1:e5896c0:                         resource.commit(tid, false);
1:e5896c0:                     }
1:e5896c0:                     messagesReceived++;
1:e5896c0:                 }
1:e5896c0:             } catch (Exception e) {
1:e5896c0:                 LOG.debug("Caught exception:", e);
1:e5896c0: 
1:e5896c0:                 try {
1:aae3ea2:                     LOG.debug("Rolling back transaction (just in case, no need to do this as it is implicit in a 1pc commit failure) " + tid);
1:e5896c0:                     resource.rollback(tid);
1:e5896c0:                 }
1:e5896c0:                 catch (XAException ex) {
1:e5896c0:                     try {
1:e5896c0:                         LOG.debug("Caught exception during rollback: " + ex + " forgetting transaction " + tid);
1:e5896c0:                         resource.forget(tid);
1:e5896c0:                     }
1:e5896c0:                     catch (XAException ex1) {
1:e5896c0:                         LOG.debug("rollback/forget failed: " + ex1.errorCode);
1:e5896c0:                     }
1:e5896c0:                 }
1:e5896c0:             } finally {
1:e5896c0:                 if (consumer != null) {
1:e5896c0:                     consumer.close();
1:e5896c0:                 }
1:e5896c0:             }
1:e5896c0:         }
1:e5896c0:         return messagesReceived;
1:e5896c0:     }
1:e5896c0: 
1:e5896c0: 
1:ea70e82:     public void testCommitSendErrorRecovery() throws Exception {
1:ea70e82: 
1:bd45d93:         XAConnection connection = factory.createXAConnection();
1:ea70e82:         connection.start();
1:ea70e82:         XASession session = connection.createXASession();
1:ea70e82: 
1:ea70e82:         Destination destination = session.createQueue("TEST");
1:ea70e82:         MessageProducer producer = session.createProducer(destination);
1:ea70e82: 
1:ea70e82:         XAResource resource = session.getXAResource();
1:ea70e82: 
1:ea70e82:         Xid tid = createXid();
1:ea70e82:         resource.start(tid, XAResource.TMNOFLAGS);
1:ea70e82:         ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1:ea70e82:         message.setTransactionId(new XATransactionId(tid));
1:ea70e82:         producer.send(message);
1:ea70e82: 
1:ea70e82:         resource.end(tid, XAResource.TMSUCCESS);
1:ea70e82:         resource.prepare(tid);
1:ea70e82: 
1:ea70e82:         jdbc.setShouldBreak(true);
1:ea70e82:         try {
1:ea70e82:             resource.commit(tid, true);
1:ea70e82:         } catch (Exception expected) {
1:ea70e82:             expected.printStackTrace();
1:ea70e82:         }
1:ea70e82: 
1:ea70e82:         // recover
1:ea70e82:         Xid[] recovered = resource.recover(XAResource.TMSTARTRSCAN);
1:ea70e82:         resource.recover(XAResource.TMNOFLAGS);
1:ea70e82: 
1:ea70e82:         jdbc.setShouldBreak(false);
1:ea70e82:         resource.commit(recovered[0], false);
1:ea70e82: 
1:ea70e82:         assertEquals("one enque", 1, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:ea70e82:     }
1:bd45d93: 
1:ea70e82: 
1:bd45d93:     final AtomicInteger getAutoCommitCount = new AtomicInteger();
1:bd45d93:     private ArrayList<Integer> getAutoCommitErrors = new ArrayList<Integer>();
1:bd45d93:     private ArrayList<Integer> executeUpdateErrorOps = new ArrayList<Integer>();
1:bd45d93:     final AtomicInteger executeUpdateErrorOpsCount = new AtomicInteger();
1:bd45d93:     private ArrayList<Integer> executeBatchErrorOps = new ArrayList<Integer>();
1:bd45d93:     final AtomicInteger executeBatchErrorOpsCount = new AtomicInteger();
1:bd45d93: 
1:bd45d93:     public void testXAEnqueueErrors() throws Exception {
1:bd45d93:         getAutoCommitCount.set(0);
1:bd45d93:         getAutoCommitErrors.clear();
1:bd45d93:         executeUpdateErrorOpsCount.set(0);
1:bd45d93:         executeUpdateErrorOps.clear();
1:bd45d93: 
1:bd45d93:         broker.stop();
1:bd45d93:         broker = new BrokerService();
1:bd45d93:         broker.setAdvisorySupport(false);
1:bd45d93:         PolicyMap policyMap = new PolicyMap();
1:bd45d93:         PolicyEntry policyEntry = new PolicyEntry();
1:bd45d93:         policyEntry.setExpireMessagesPeriod(0);
1:bd45d93:         policyMap.setDefaultEntry(policyEntry);
1:bd45d93:         broker.setDestinationPolicy(policyMap);
1:bd45d93: 
1:bd45d93:         //broker.setDeleteAllMessagesOnStartup(true);
1:bd45d93: 
1:bd45d93:         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
1:bd45d93:         DataSource realDataSource = jdbc.getDataSource();
1:bd45d93:         jdbcPersistenceAdapter.setDataSource(new TestDataSource(realDataSource));
1:bd45d93:         jdbcPersistenceAdapter.setUseLock(false);
1:bd45d93:         broker.setPersistenceAdapter(jdbcPersistenceAdapter);
1:bd45d93:         connectionUri = broker.addConnector("tcp://localhost:0").getPublishableConnectString();
1:bd45d93:         broker.start();
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         // inject error
1:bd45d93:         executeUpdateErrorOps.add(5);
1:bd45d93:         executeUpdateErrorOps.add(9);
1:bd45d93:         executeUpdateErrorOps.add(12);
1:bd45d93: 
1:bd45d93:         getAutoCommitErrors.add(59);
1:bd45d93:         getAutoCommitErrors.add(60);
1:bd45d93: 
1:bd45d93: 
2:bd45d93:         factory = new ActiveMQXAConnectionFactory(connectionUri);
1:bd45d93: 
1:bd45d93:         XAConnection c = factory.createXAConnection();
1:bd45d93:         c.start();
1:bd45d93:         XASession s = c.createXASession();
1:bd45d93:         final XAResource recoveryResource = s.getXAResource();
1:bd45d93: 
1:bd45d93:         for (int i = 0; i < 10; i++) {
1:bd45d93:             XAConnection connection = factory.createXAConnection();
1:bd45d93:             connection.start();
1:bd45d93:             XASession session = connection.createXASession();
1:bd45d93: 
1:bd45d93:             Destination destination = session.createQueue("TEST");
1:bd45d93:             MessageProducer producer = session.createProducer(destination);
1:bd45d93: 
1:bd45d93:             XAResource resource = session.getXAResource();
1:bd45d93: 
1:bd45d93:             Xid tid = createXid();
1:bd45d93:             resource.start(tid, XAResource.TMNOFLAGS);
1:bd45d93:             ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1:bd45d93:             message.setTransactionId(new XATransactionId(tid));
1:bd45d93:             producer.send(message);
1:bd45d93: 
1:bd45d93:             resource.end(tid, XAResource.TMSUCCESS);
1:bd45d93:             resource.prepare(tid);
1:bd45d93: 
1:bd45d93:             try {
1:bd45d93:                 resource.commit(tid, false);
1:bd45d93:             } catch (Exception expected) {
1:bd45d93:                 expected.printStackTrace();
1:bd45d93: 
1:bd45d93:                 dumpMessages();
1:bd45d93: 
1:bd45d93:                 boolean done = false;
1:bd45d93:                 while (!done) {
1:bd45d93:                     // recover
1:bd45d93:                     Xid[] recovered = recoveryResource.recover(XAResource.TMSTARTRSCAN);
1:bd45d93:                     recoveryResource.recover(XAResource.TMNOFLAGS);
1:bd45d93: 
1:bd45d93:                     try {
1:bd45d93:                         recoveryResource.commit(recovered[0], false);
1:bd45d93:                         done = true;
1:bd45d93:                     } catch (XAException ok) {
1:bd45d93:                         ok.printStackTrace();
1:bd45d93:                     }
1:bd45d93:                 }
1:bd45d93:             }
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         dumpMessages();
1:bd45d93: 
1:bd45d93:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:bd45d93:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");
1:bd45d93:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext()
1:bd45d93:            .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1:bd45d93: 
1:bd45d93:         assertEquals("qs", 10, proxy.getQueueSize());
1:bd45d93:         assertEquals("enq", 10, proxy.getEnqueueCount());
1:bd45d93:         assertEquals("curs", 10, proxy.cursorSize());
1:bd45d93:     }
1:bd45d93: 
1:bd45d93:     public void testNonTxEnqueueErrors() throws Exception {
1:bd45d93:         getAutoCommitCount.set(0);
1:bd45d93:         getAutoCommitErrors.clear();
1:bd45d93:         executeUpdateErrorOpsCount.set(0);
1:bd45d93:         executeUpdateErrorOps.clear();
1:bd45d93:         executeBatchErrorOps.clear();
1:bd45d93:         executeBatchErrorOpsCount.set(0);
1:bd45d93: 
1:bd45d93:         broker.stop();
1:bd45d93:         broker = new BrokerService();
1:bd45d93:         broker.setAdvisorySupport(false);
1:bd45d93:         PolicyMap policyMap = new PolicyMap();
1:bd45d93:         PolicyEntry policyEntry = new PolicyEntry();
1:bd45d93:         policyEntry.setExpireMessagesPeriod(0);
1:bd45d93:         policyMap.setDefaultEntry(policyEntry);
1:bd45d93:         broker.setDestinationPolicy(policyMap);
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
1:bd45d93:         DataSource realDataSource = jdbc.getDataSource();
1:bd45d93:         jdbcPersistenceAdapter.setDataSource(new TestDataSource(realDataSource));
1:bd45d93:         jdbcPersistenceAdapter.setUseLock(false);
1:bd45d93:         jdbcPersistenceAdapter.setCleanupPeriod(0);
1:bd45d93:         broker.setPersistenceAdapter(jdbcPersistenceAdapter);
1:bd45d93:         connectionUri = broker.addConnector("tcp://localhost:0").getPublishableConnectString();
1:bd45d93:         broker.start();
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         executeBatchErrorOps.add(2);
1:bd45d93:         executeBatchErrorOps.add(3);
1:bd45d93:         getAutoCommitCount.set(0);
1:bd45d93:         getAutoCommitErrors.add(10);
1:bd45d93: 
1:bd45d93: 
1:004be56:         ActiveMQConnectionFactory nonTxFactory = new ActiveMQConnectionFactory(connectionUri);
1:bd45d93: 
1:bd45d93:         for (int i = 0; i < 10; i++) {
1:004be56:             javax.jms.Connection connection = nonTxFactory.createConnection();
1:bd45d93:             connection.start();
1:bd45d93:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:bd45d93: 
1:bd45d93:             Destination destination = session.createQueue("TEST");
1:bd45d93:             MessageProducer producer = session.createProducer(destination);
1:bd45d93:             ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1:bd45d93: 
1:bd45d93:             try {
1:bd45d93:                 producer.send(message);
1:bd45d93:             } catch (Exception expected) {
1:bd45d93:                 expected.printStackTrace();
1:bd45d93: 
1:bd45d93:                 dumpMessages();
1:bd45d93: 
1:bd45d93:                 boolean done = false;
1:bd45d93:                 while (!done) {
1:bd45d93:                     try {
1:bd45d93:                         producer.send(message);
1:bd45d93:                         done = true;
1:bd45d93:                     } catch (Exception ok) {
1:bd45d93:                         ok.printStackTrace();
1:bd45d93:                     }
1:bd45d93:                 }
1:bd45d93:             }
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         assertEquals("messages in db", 10, dumpMessages());
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:bd45d93:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");
1:bd45d93:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext()
1:bd45d93:            .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1:bd45d93: 
1:bd45d93:         assertEquals("qs", 10, proxy.getQueueSize());
1:bd45d93:         assertEquals("enq", 10, proxy.getEnqueueCount());
1:bd45d93:         assertEquals("curs", 10, proxy.cursorSize());
1:bd45d93:     }
1:bd45d93: 
1:bd45d93:     public void testNonTxEnqueueOverNetworkErrorsRestart() throws Exception {
1:bd45d93:         getAutoCommitCount.set(0);
1:bd45d93:         getAutoCommitErrors.clear();
1:bd45d93:         executeUpdateErrorOpsCount.set(0);
1:bd45d93:         executeUpdateErrorOps.clear();
1:bd45d93:         executeBatchErrorOps.clear();
1:bd45d93:         executeBatchErrorOpsCount.set(0);
1:bd45d93: 
1:bd45d93:         broker.stop();
1:bd45d93: 
1:bd45d93:         final AtomicBoolean done = new AtomicBoolean(false);
1:bd45d93:         Thread thread = new Thread() {
1:bd45d93:             @Override
1:bd45d93:             public void run() {
1:bd45d93: 
1:bd45d93:                 while (!done.get()) {
1:bd45d93:                     try {
1:bd45d93: 
1:bd45d93:                         broker = new BrokerService();
1:bd45d93:                         broker.setAdvisorySupport(false);
1:bd45d93:                         PolicyMap policyMap = new PolicyMap();
1:bd45d93:                         PolicyEntry policyEntry = new PolicyEntry();
1:bd45d93:                         policyEntry.setUseCache(false);
1:bd45d93:                         policyEntry.setExpireMessagesPeriod(0);
1:bd45d93:                         policyEntry.setDeadLetterStrategy(new DiscardingDeadLetterStrategy());
1:bd45d93:                         policyMap.setDefaultEntry(policyEntry);
1:bd45d93:                         broker.setDestinationPolicy(policyMap);
1:bd45d93: 
1:bd45d93:                         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
1:bd45d93:                         DataSource realDataSource = jdbc.getDataSource();
1:bd45d93:                         jdbcPersistenceAdapter.setDataSource(new TestDataSource(realDataSource));
1:bd45d93:                         jdbcPersistenceAdapter.setUseLock(false);
1:bd45d93:                         jdbcPersistenceAdapter.setCleanupPeriod(0);
1:bd45d93:                         broker.setPersistenceAdapter(jdbcPersistenceAdapter);
1:bd45d93:                         TransportConnector transportConnector = broker.addConnector("tcp://localhost:61616");
1:bd45d93:                         //transportConnector.setAuditNetworkProducers(true);
1:bd45d93:                         connectionUri = transportConnector.getPublishableConnectString();
1:bd45d93:                         DefaultIOExceptionHandler stopOnIOEx = new DefaultIOExceptionHandler();
1:bd45d93:                         stopOnIOEx.setIgnoreSQLExceptions(false);
1:bd45d93:                         stopOnIOEx.setStopStartConnectors(false);
1:bd45d93:                         broker.setIoExceptionHandler(stopOnIOEx);
1:bd45d93:                         broker.start();
1:bd45d93: 
1:bd45d93:                         broker.waitUntilStopped();
1:bd45d93: 
1:bd45d93:                     } catch (Exception oops) {
1:bd45d93:                         oops.printStackTrace();
1:bd45d93:                         done.set(true);
1:bd45d93:                     }
1:bd45d93:                 }
1:bd45d93:             }
1:bd45d93:         };
1:bd45d93:         thread.start();
1:bd45d93: 
1:bd45d93:         //executeBatchErrorOps.add(5);
1:bd45d93:         //executeBatchErrorOps.add(3);
1:bd45d93:         getAutoCommitCount.set(0);
1:bd45d93:         getAutoCommitErrors.add(39);
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         // network broker to push messages
1:bd45d93:         final BrokerService other = new BrokerService();
1:bd45d93:         other.setBrokerName("other");
1:bd45d93:         other.setAdvisorySupport(false);
1:bd45d93:         other.setUseJmx(false);
1:bd45d93:         other.setPersistent(false);
1:bd45d93:         NetworkConnector netwokConnector = other.addNetworkConnector("static://tcp://localhost:61616");
1:bd45d93:         netwokConnector.setStaticBridge(true);
1:bd45d93:         netwokConnector.setStaticallyIncludedDestinations(Arrays.asList(new ActiveMQDestination[]{new ActiveMQQueue("TEST")}));
1:bd45d93:         other.start();
1:bd45d93: 
1:bd45d93:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://other");
1:bd45d93:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) connectionFactory.createConnection();
1:bd45d93:         activeMQConnection.setWatchTopicAdvisories(false);
1:bd45d93:         Session session = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:bd45d93:         activeMQConnection.start();
1:bd45d93:         Destination destination = session.createQueue("TEST");
1:bd45d93:         MessageProducer producer = session.createProducer(destination);
1:bd45d93:         ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1:bd45d93: 
1:bd45d93:         for (int i = 0; i < 10; i++) {
1:bd45d93:             producer.send(message);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         Wait.waitFor(new Wait.Condition() {
1:bd45d93:             @Override
1:bd45d93:             public boolean isSatisified() throws Exception {
1:bd45d93:                 LOG.info("MESSAGES DRAINED :" + ((RegionBroker)other.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:bd45d93:                 return 0 == ((RegionBroker)other.getRegionBroker()).getDestinationStatistics().getMessages().getCount();
1:bd45d93:             }
1:bd45d93:         });
1:bd45d93:         activeMQConnection.close();
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         assertEquals("db", 10, dumpMessages());
1:bd45d93:         assertEquals("messages count", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:bd45d93: 
1:bd45d93: 
1:bd45d93:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");
1:bd45d93:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext()
1:bd45d93:            .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1:bd45d93: 
1:bd45d93:         assertEquals("qs", 10, proxy.getQueueSize());
1:bd45d93:         assertEquals("curs", 10, proxy.cursorSize());
1:bd45d93: 
1:bd45d93:         done.set(true);
1:bd45d93:         other.stop();
1:bd45d93:     }
1:bd45d93: 
1:bd45d93: 
1:bd45d93:     private class TestDataSource implements javax.sql.DataSource {
1:bd45d93: 
1:bd45d93:         private final javax.sql.DataSource realDataSource;
1:bd45d93: 
1:bd45d93:         public TestDataSource(javax.sql.DataSource dataSource) {
1:bd45d93:             realDataSource = dataSource;
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Connection getConnection() throws SQLException {
1:bd45d93:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection());
1:bd45d93:             return autoCommitCheckConnection;
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Connection getConnection(String username, String password) throws SQLException {
1:bd45d93:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection(username, password));
1:bd45d93: 
1:bd45d93:             return autoCommitCheckConnection;
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public PrintWriter getLogWriter() throws SQLException {
1:bd45d93:             return realDataSource.getLogWriter();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setLogWriter(PrintWriter out) throws SQLException {
1:bd45d93:             realDataSource.setLogWriter(out);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setLoginTimeout(int seconds) throws SQLException {
1:bd45d93:             realDataSource.setLoginTimeout(seconds);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public int getLoginTimeout() throws SQLException {
1:bd45d93:             return realDataSource.getLoginTimeout();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException {
1:bd45d93:             return realDataSource.getParentLogger();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:bd45d93:             return realDataSource.unwrap(iface);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:bd45d93:             return realDataSource.isWrapperFor(iface);
1:bd45d93:         }
1:bd45d93:     }
1:bd45d93: 
1:bd45d93:     private class AutoCommitCheckConnection implements Connection {
1:bd45d93: 
1:bd45d93:         private final Connection realConnection;
1:bd45d93: 
1:bd45d93:         public AutoCommitCheckConnection(Connection connection) {
1:bd45d93:             this.realConnection = connection;
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void commit() throws SQLException {
1:bd45d93:             realConnection.commit();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         // Just plumbing for wrapper. Might have been better to do a Dynamic Proxy here.
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Statement createStatement() throws SQLException {
1:bd45d93:             return realConnection.createStatement();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public PreparedStatement prepareStatement(String sql) throws SQLException {
1:bd45d93:             //final AtomicInteger executeCount = new AtomicInteger();
1:bd45d93: 
1:bd45d93:             final PreparedStatement delegate = realConnection.prepareStatement(sql);
1:bd45d93:             return new PreparedStatement() {
1:bd45d93:                 public ResultSet executeQuery() throws SQLException {
1:bd45d93:                     return delegate.executeQuery();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 final
1:bd45d93:                 public int executeUpdate() throws SQLException {
1:bd45d93:                     int ret = delegate.executeUpdate();
1:bd45d93:                     if (executeUpdateErrorOps.contains(executeUpdateErrorOpsCount.incrementAndGet())) {
1:bd45d93:                         throw new SQLRecoverableException("SOME executeUpdate ERROR[" + executeUpdateErrorOpsCount.get() +"]");
1:bd45d93:                     }
1:bd45d93:                     return ret;
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNull(int parameterIndex, int sqlType) throws SQLException {
1:bd45d93:                     delegate.setNull(parameterIndex, sqlType);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1:bd45d93:                     delegate.setBoolean(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setByte(int parameterIndex, byte x) throws SQLException {
1:bd45d93:                     delegate.setByte(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setShort(int parameterIndex, short x) throws SQLException {
1:bd45d93:                     delegate.setShort(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setInt(int parameterIndex, int x) throws SQLException {
1:bd45d93:                     delegate.setInt(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setLong(int parameterIndex, long x) throws SQLException {
1:bd45d93:                     delegate.setLong(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setFloat(int parameterIndex, float x) throws SQLException {
1:bd45d93:                     delegate.setFloat(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setDouble(int parameterIndex, double x) throws SQLException {
1:bd45d93:                     delegate.setDouble(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
1:bd45d93:                     delegate.setBigDecimal(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setString(int parameterIndex, String x) throws SQLException {
1:bd45d93:                     delegate.setString(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBytes(int parameterIndex, byte[] x) throws SQLException {
1:bd45d93:                     delegate.setBytes(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setDate(int parameterIndex, Date x) throws SQLException {
1:bd45d93:                     delegate.setDate(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setTime(int parameterIndex, Time x) throws SQLException {
1:bd45d93:                     delegate.setTime(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
1:bd45d93:                     delegate.setTimestamp(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
1:bd45d93:                     delegate.setAsciiStream(parameterIndex, x, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 @Deprecated
1:bd45d93:                 public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
1:bd45d93:                     delegate.setUnicodeStream(parameterIndex, x, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
1:bd45d93:                     delegate.setBinaryStream(parameterIndex, x, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void clearParameters() throws SQLException {
1:bd45d93:                     delegate.clearParameters();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
1:bd45d93:                     delegate.setObject(parameterIndex, x, targetSqlType);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setObject(int parameterIndex, Object x) throws SQLException {
1:bd45d93:                     delegate.setObject(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean execute() throws SQLException {
1:bd45d93:                     return delegate.execute();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void addBatch() throws SQLException {
1:bd45d93:                     delegate.addBatch();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
1:bd45d93:                     delegate.setCharacterStream(parameterIndex, reader, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setRef(int parameterIndex, Ref x) throws SQLException {
1:bd45d93:                     delegate.setRef(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBlob(int parameterIndex, Blob x) throws SQLException {
1:bd45d93:                     delegate.setBlob(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setClob(int parameterIndex, Clob x) throws SQLException {
1:bd45d93:                     delegate.setClob(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setArray(int parameterIndex, Array x) throws SQLException {
1:bd45d93:                     delegate.setArray(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public ResultSetMetaData getMetaData() throws SQLException {
1:bd45d93:                     return delegate.getMetaData();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
1:bd45d93:                     delegate.setDate(parameterIndex, x, cal);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
1:bd45d93:                     delegate.setTime(parameterIndex, x, cal);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
1:bd45d93:                     delegate.setTimestamp(parameterIndex, x, cal);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
1:bd45d93:                     delegate.setNull(parameterIndex, sqlType, typeName);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setURL(int parameterIndex, URL x) throws SQLException {
1:bd45d93:                     delegate.setURL(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public ParameterMetaData getParameterMetaData() throws SQLException {
1:bd45d93:                     return delegate.getParameterMetaData();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setRowId(int parameterIndex, RowId x) throws SQLException {
1:bd45d93:                     delegate.setRowId(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNString(int parameterIndex, String value) throws SQLException {
1:bd45d93:                     delegate.setNString(parameterIndex, value);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
1:bd45d93:                     delegate.setNCharacterStream(parameterIndex, value, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNClob(int parameterIndex, NClob value) throws SQLException {
1:bd45d93:                     delegate.setNClob(parameterIndex, value);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
1:bd45d93:                     delegate.setClob(parameterIndex, reader, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
1:bd45d93:                     delegate.setBlob(parameterIndex, inputStream, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
1:bd45d93:                     delegate.setNClob(parameterIndex, reader, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
1:bd45d93:                     delegate.setSQLXML(parameterIndex, xmlObject);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setObject(int parameterIndex,
1:bd45d93:                                       Object x,
1:bd45d93:                                       int targetSqlType,
1:bd45d93:                                       int scaleOrLength) throws SQLException {
1:bd45d93:                     delegate.setObject(parameterIndex, x, targetSqlType, scaleOrLength);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
1:bd45d93:                     delegate.setAsciiStream(parameterIndex, x, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
1:bd45d93:                     delegate.setBinaryStream(parameterIndex, x, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
1:bd45d93:                     delegate.setCharacterStream(parameterIndex, reader, length);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
1:bd45d93:                     delegate.setAsciiStream(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
1:bd45d93:                     delegate.setBinaryStream(parameterIndex, x);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
1:bd45d93:                     delegate.setCharacterStream(parameterIndex, reader);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
1:bd45d93:                     delegate.setNCharacterStream(parameterIndex, value);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setClob(int parameterIndex, Reader reader) throws SQLException {
1:bd45d93:                     delegate.setClob(parameterIndex, reader);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
1:bd45d93:                     delegate.setBlob(parameterIndex, inputStream);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setNClob(int parameterIndex, Reader reader) throws SQLException {
1:bd45d93:                     delegate.setNClob(parameterIndex, reader);
1:bd45d93:                 }
1:bd45d93: /*
1:bd45d93:                 public void setObject(int parameterIndex,
1:bd45d93:                                       Object x,
1:bd45d93:                                       SQLType targetSqlType,
1:bd45d93:                                       int scaleOrLength) throws SQLException {
1:bd45d93:                     delegate.setObject(parameterIndex, x, targetSqlType, scaleOrLength);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setObject(int parameterIndex, Object x, SQLType targetSqlType) throws SQLException {
1:bd45d93:                     delegate.setObject(parameterIndex, x, targetSqlType);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public long executeLargeUpdate() throws SQLException {
1:bd45d93:                     return delegate.executeLargeUpdate();
1:bd45d93:                 }
1:bd45d93: */
1:bd45d93:                 public ResultSet executeQuery(String sql) throws SQLException {
1:bd45d93:                     return delegate.executeQuery(sql);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int executeUpdate(String sql) throws SQLException {
1:bd45d93:                     return delegate.executeUpdate(sql);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void close() throws SQLException {
1:bd45d93:                     delegate.close();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getMaxFieldSize() throws SQLException {
1:bd45d93:                     return delegate.getMaxFieldSize();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setMaxFieldSize(int max) throws SQLException {
1:bd45d93:                     delegate.setMaxFieldSize(max);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getMaxRows() throws SQLException {
1:bd45d93:                     return delegate.getMaxRows();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setMaxRows(int max) throws SQLException {
1:bd45d93:                     delegate.setMaxRows(max);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setEscapeProcessing(boolean enable) throws SQLException {
1:bd45d93:                     delegate.setEscapeProcessing(enable);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getQueryTimeout() throws SQLException {
1:bd45d93:                     return delegate.getQueryTimeout();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setQueryTimeout(int seconds) throws SQLException {
1:bd45d93:                     delegate.setQueryTimeout(seconds);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void cancel() throws SQLException {
1:bd45d93:                     delegate.cancel();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public SQLWarning getWarnings() throws SQLException {
1:bd45d93:                     return delegate.getWarnings();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void clearWarnings() throws SQLException {
1:bd45d93:                     delegate.clearWarnings();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setCursorName(String name) throws SQLException {
1:bd45d93:                     delegate.setCursorName(name);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean execute(String sql) throws SQLException {
1:bd45d93:                     return delegate.execute(sql);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public ResultSet getResultSet() throws SQLException {
1:bd45d93:                     return delegate.getResultSet();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getUpdateCount() throws SQLException {
1:bd45d93:                     return delegate.getUpdateCount();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean getMoreResults() throws SQLException {
1:bd45d93:                     return delegate.getMoreResults();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setFetchDirection(int direction) throws SQLException {
1:bd45d93:                     delegate.setFetchDirection(direction);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getFetchDirection() throws SQLException {
1:bd45d93:                     return delegate.getFetchDirection();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setFetchSize(int rows) throws SQLException {
1:bd45d93:                     delegate.setFetchSize(rows);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getFetchSize() throws SQLException {
1:bd45d93:                     return delegate.getFetchSize();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getResultSetConcurrency() throws SQLException {
1:bd45d93:                     return delegate.getResultSetConcurrency();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getResultSetType() throws SQLException {
1:bd45d93:                     return delegate.getResultSetType();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void addBatch(String sql) throws SQLException {
1:bd45d93:                     delegate.addBatch(sql);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void clearBatch() throws SQLException {
1:bd45d93:                     delegate.clearBatch();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int[] executeBatch() throws SQLException {
1:bd45d93:                     if (executeBatchErrorOps.contains(executeBatchErrorOpsCount.incrementAndGet())) {
1:bd45d93:                         throw new SQLRecoverableException("SOME executeBatch ERROR[" + executeBatchErrorOpsCount.get() +"]");
1:bd45d93:                     }
1:bd45d93:                     return delegate.executeBatch();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public Connection getConnection() throws SQLException {
1:bd45d93:                     return delegate.getConnection();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean getMoreResults(int current) throws SQLException {
1:bd45d93:                     return delegate.getMoreResults(current);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public ResultSet getGeneratedKeys() throws SQLException {
1:bd45d93:                     return delegate.getGeneratedKeys();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
1:bd45d93:                     return delegate.executeUpdate(sql, autoGeneratedKeys);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
1:bd45d93:                     return delegate.executeUpdate(sql, columnIndexes);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int executeUpdate(String sql, String[] columnNames) throws SQLException {
1:bd45d93:                     return delegate.executeUpdate(sql, columnNames);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
1:bd45d93:                     return delegate.execute(sql, autoGeneratedKeys);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean execute(String sql, int[] columnIndexes) throws SQLException {
1:bd45d93:                     return delegate.execute(sql, columnIndexes);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean execute(String sql, String[] columnNames) throws SQLException {
1:bd45d93:                     return delegate.execute(sql, columnNames);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public int getResultSetHoldability() throws SQLException {
1:bd45d93:                     return delegate.getResultSetHoldability();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean isClosed() throws SQLException {
1:bd45d93:                     return delegate.isClosed();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setPoolable(boolean poolable) throws SQLException {
1:bd45d93:                     delegate.setPoolable(poolable);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean isPoolable() throws SQLException {
1:bd45d93:                     return delegate.isPoolable();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void closeOnCompletion() throws SQLException {
1:bd45d93:                     delegate.closeOnCompletion();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean isCloseOnCompletion() throws SQLException {
1:bd45d93:                     return delegate.isCloseOnCompletion();
1:bd45d93:                 }
1:bd45d93: /*
1:bd45d93:                 public long getLargeUpdateCount() throws SQLException {
1:bd45d93:                     return delegate.getLargeUpdateCount();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public void setLargeMaxRows(long max) throws SQLException {
1:bd45d93:                     delegate.setLargeMaxRows(max);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public long getLargeMaxRows() throws SQLException {
1:bd45d93:                     return delegate.getLargeMaxRows();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public long[] executeLargeBatch() throws SQLException {
1:bd45d93:                     return delegate.executeLargeBatch();
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public long executeLargeUpdate(String sql) throws SQLException {
1:bd45d93:                     return delegate.executeLargeUpdate(sql);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
1:bd45d93:                     return delegate.executeLargeUpdate(sql, autoGeneratedKeys);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
1:bd45d93:                     return delegate.executeLargeUpdate(sql, columnIndexes);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
1:bd45d93:                     return delegate.executeLargeUpdate(sql, columnNames);
1:bd45d93:                 }
1:bd45d93: */
1:bd45d93:                 public <T> T unwrap(Class<T> iface) throws SQLException {
1:bd45d93:                     return delegate.unwrap(iface);
1:bd45d93:                 }
1:bd45d93: 
1:bd45d93:                 public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:bd45d93:                     return delegate.isWrapperFor(iface);
1:bd45d93:                 }
1:bd45d93:             };
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public CallableStatement prepareCall(String sql) throws SQLException {
1:bd45d93:             return realConnection.prepareCall(sql);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public String nativeSQL(String sql) throws SQLException {
1:bd45d93:             return realConnection.nativeSQL(sql);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setAutoCommit(boolean autoCommit) throws SQLException {
1:bd45d93:             realConnection.setAutoCommit(autoCommit);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public boolean getAutoCommit() throws SQLException {
1:bd45d93:             if (getAutoCommitErrors.contains(getAutoCommitCount.incrementAndGet())) {
1:bd45d93:                 throw new SQLRecoverableException("AutoCommit[" + getAutoCommitCount.get() +"]");
1:bd45d93:             }
1:bd45d93:             return realConnection.getAutoCommit();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void rollback() throws SQLException {
1:bd45d93:             realConnection.rollback();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void close() throws SQLException {
1:bd45d93:             realConnection.close();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public boolean isClosed() throws SQLException {
1:bd45d93:             return realConnection.isClosed();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public DatabaseMetaData getMetaData() throws SQLException {
1:bd45d93:             return realConnection.getMetaData();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setReadOnly(boolean readOnly) throws SQLException {
1:bd45d93:             realConnection.setReadOnly(readOnly);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public boolean isReadOnly() throws SQLException {
1:bd45d93:             return realConnection.isReadOnly();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setCatalog(String catalog) throws SQLException {
1:bd45d93:             realConnection.setCatalog(catalog);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public String getCatalog() throws SQLException {
1:bd45d93:             return realConnection.getCatalog();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setTransactionIsolation(int level) throws SQLException {
1:bd45d93:             realConnection.setTransactionIsolation(level);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public int getTransactionIsolation() throws SQLException {
1:bd45d93:             return realConnection.getTransactionIsolation();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public SQLWarning getWarnings() throws SQLException {
1:bd45d93:             return realConnection.getWarnings();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void clearWarnings() throws SQLException {
1:bd45d93:             realConnection.clearWarnings();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
1:bd45d93:             return realConnection.createStatement(resultSetType, resultSetConcurrency);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:bd45d93:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:bd45d93:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Map<String, Class<?>> getTypeMap() throws SQLException {
1:bd45d93:             return realConnection.getTypeMap();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
1:bd45d93:             realConnection.setTypeMap(map);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setHoldability(int holdability) throws SQLException {
1:bd45d93:             realConnection.setHoldability(holdability);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public int getHoldability() throws SQLException {
1:bd45d93:             return realConnection.getHoldability();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Savepoint setSavepoint() throws SQLException {
1:bd45d93:             return realConnection.setSavepoint();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Savepoint setSavepoint(String name) throws SQLException {
1:bd45d93:             return realConnection.setSavepoint(name);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void rollback(Savepoint savepoint) throws SQLException {
1:bd45d93:             realConnection.rollback();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void releaseSavepoint(Savepoint savepoint) throws SQLException {
1:bd45d93:             realConnection.releaseSavepoint(savepoint);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:bd45d93:             return realConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:bd45d93:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:bd45d93:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
1:bd45d93:             return realConnection.prepareStatement(sql, autoGeneratedKeys);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
1:bd45d93:             return realConnection.prepareStatement(sql, columnIndexes);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
1:bd45d93:             return realConnection.prepareStatement(sql, columnNames);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Clob createClob() throws SQLException {
1:bd45d93:             return realConnection.createClob();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Blob createBlob() throws SQLException {
1:bd45d93:             return realConnection.createBlob();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public NClob createNClob() throws SQLException {
1:bd45d93:             return realConnection.createNClob();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public SQLXML createSQLXML() throws SQLException {
1:bd45d93:             return realConnection.createSQLXML();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public boolean isValid(int timeout) throws SQLException {
1:bd45d93:             return realConnection.isValid(timeout);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setClientInfo(String name, String value) throws SQLClientInfoException {
1:bd45d93:             realConnection.setClientInfo(name, value);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setClientInfo(Properties properties) throws SQLClientInfoException {
1:bd45d93:             realConnection.setClientInfo(properties);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public String getClientInfo(String name) throws SQLException {
1:bd45d93:             return realConnection.getClientInfo(name);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Properties getClientInfo() throws SQLException {
1:bd45d93:             return realConnection.getClientInfo();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
1:bd45d93:             return realConnection.createArrayOf(typeName, elements);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
1:bd45d93:             return realConnection.createStruct(typeName, attributes);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setSchema(String schema) throws SQLException {
1:bd45d93:             realConnection.setSchema(schema);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public String getSchema() throws SQLException {
1:bd45d93:             return realConnection.getSchema();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void abort(Executor executor) throws SQLException {
1:bd45d93:             realConnection.abort(executor);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
1:bd45d93:             realConnection.setNetworkTimeout(executor, milliseconds);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public int getNetworkTimeout() throws SQLException {
1:bd45d93:             return realConnection.getNetworkTimeout();
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:bd45d93:             return realConnection.unwrap(iface);
1:bd45d93:         }
1:bd45d93: 
1:bd45d93:         @Override
1:bd45d93:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:bd45d93:             return realConnection.isWrapperFor(iface);
1:bd45d93:         }
1:bd45d93:     }
1:e5896c0: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:004be56
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory nonTxFactory = new ActiveMQConnectionFactory(connectionUri);
1:             javax.jms.Connection connection = nonTxFactory.createConnection();
commit:bd45d93
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Session;
1: import javax.management.ObjectName;
1: import javax.sql.DataSource;
1: import java.io.InputStream;
1: import java.io.PrintWriter;
1: import java.io.Reader;
1: import java.math.BigDecimal;
1: import java.net.URL;
1: import java.sql.Array;
1: import java.sql.Blob;
1: import java.sql.CallableStatement;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.Date;
1: import java.sql.NClob;
1: import java.sql.ParameterMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.Ref;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.RowId;
1: import java.sql.SQLClientInfoException;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.SQLRecoverableException;
1: import java.sql.SQLWarning;
1: import java.sql.SQLXML;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
1: import java.sql.Struct;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Calendar;
1: import java.util.Map;
1: import java.util.Properties;
1: import java.util.concurrent.Executor;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.jmx.QueueViewMBean;
1: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
1: import org.apache.activemq.broker.region.policy.DiscardingDeadLetterStrategy;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.util.DefaultIOExceptionHandler;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1: 
1:     final AtomicInteger getAutoCommitCount = new AtomicInteger();
1:     private ArrayList<Integer> getAutoCommitErrors = new ArrayList<Integer>();
1:     private ArrayList<Integer> executeUpdateErrorOps = new ArrayList<Integer>();
1:     final AtomicInteger executeUpdateErrorOpsCount = new AtomicInteger();
1:     private ArrayList<Integer> executeBatchErrorOps = new ArrayList<Integer>();
1:     final AtomicInteger executeBatchErrorOpsCount = new AtomicInteger();
1: 
1:     public void testXAEnqueueErrors() throws Exception {
1:         getAutoCommitCount.set(0);
1:         getAutoCommitErrors.clear();
1:         executeUpdateErrorOpsCount.set(0);
1:         executeUpdateErrorOps.clear();
1: 
1:         broker.stop();
1:         broker = new BrokerService();
1:         broker.setAdvisorySupport(false);
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setExpireMessagesPeriod(0);
1:         policyMap.setDefaultEntry(policyEntry);
1:         broker.setDestinationPolicy(policyMap);
1: 
1:         //broker.setDeleteAllMessagesOnStartup(true);
1: 
1:         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
1:         DataSource realDataSource = jdbc.getDataSource();
1:         jdbcPersistenceAdapter.setDataSource(new TestDataSource(realDataSource));
1:         jdbcPersistenceAdapter.setUseLock(false);
1:         broker.setPersistenceAdapter(jdbcPersistenceAdapter);
1:         connectionUri = broker.addConnector("tcp://localhost:0").getPublishableConnectString();
1:         broker.start();
1: 
1: 
1:         // inject error
1:         executeUpdateErrorOps.add(5);
1:         executeUpdateErrorOps.add(9);
1:         executeUpdateErrorOps.add(12);
1: 
1:         getAutoCommitErrors.add(59);
1:         getAutoCommitErrors.add(60);
1: 
1: 
1:         factory = new ActiveMQXAConnectionFactory(connectionUri);
1: 
1:         XAConnection c = factory.createXAConnection();
1:         c.start();
1:         XASession s = c.createXASession();
1:         final XAResource recoveryResource = s.getXAResource();
1: 
1:         for (int i = 0; i < 10; i++) {
1:             XAConnection connection = factory.createXAConnection();
1:             connection.start();
1:             XASession session = connection.createXASession();
1: 
1:             Destination destination = session.createQueue("TEST");
1:             MessageProducer producer = session.createProducer(destination);
1: 
1:             XAResource resource = session.getXAResource();
1: 
1:             Xid tid = createXid();
1:             resource.start(tid, XAResource.TMNOFLAGS);
1:             ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1:             message.setTransactionId(new XATransactionId(tid));
1:             producer.send(message);
1: 
1:             resource.end(tid, XAResource.TMSUCCESS);
1:             resource.prepare(tid);
1: 
1:             try {
1:                 resource.commit(tid, false);
1:             } catch (Exception expected) {
1:                 expected.printStackTrace();
1: 
1:                 dumpMessages();
1: 
1:                 boolean done = false;
1:                 while (!done) {
1:                     // recover
1:                     Xid[] recovered = recoveryResource.recover(XAResource.TMSTARTRSCAN);
1:                     recoveryResource.recover(XAResource.TMNOFLAGS);
1: 
1:                     try {
1:                         recoveryResource.commit(recovered[0], false);
1:                         done = true;
1:                     } catch (XAException ok) {
1:                         ok.printStackTrace();
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         dumpMessages();
1: 
1:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1: 
1: 
1:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");
1:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext()
1:            .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1: 
1:         assertEquals("qs", 10, proxy.getQueueSize());
1:         assertEquals("enq", 10, proxy.getEnqueueCount());
1:         assertEquals("curs", 10, proxy.cursorSize());
1:     }
1: 
1:     public void testNonTxEnqueueErrors() throws Exception {
1:         getAutoCommitCount.set(0);
1:         getAutoCommitErrors.clear();
1:         executeUpdateErrorOpsCount.set(0);
1:         executeUpdateErrorOps.clear();
1:         executeBatchErrorOps.clear();
1:         executeBatchErrorOpsCount.set(0);
1: 
1:         broker.stop();
1:         broker = new BrokerService();
1:         broker.setAdvisorySupport(false);
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setExpireMessagesPeriod(0);
1:         policyMap.setDefaultEntry(policyEntry);
1:         broker.setDestinationPolicy(policyMap);
1: 
1: 
1:         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
1:         DataSource realDataSource = jdbc.getDataSource();
1:         jdbcPersistenceAdapter.setDataSource(new TestDataSource(realDataSource));
1:         jdbcPersistenceAdapter.setUseLock(false);
1:         jdbcPersistenceAdapter.setCleanupPeriod(0);
1:         broker.setPersistenceAdapter(jdbcPersistenceAdapter);
1:         connectionUri = broker.addConnector("tcp://localhost:0").getPublishableConnectString();
1:         broker.start();
1: 
1: 
1:         executeBatchErrorOps.add(2);
1:         executeBatchErrorOps.add(3);
1:         getAutoCommitCount.set(0);
1:         getAutoCommitErrors.add(10);
1: 
1: 
1:         factory = new ActiveMQXAConnectionFactory(connectionUri);
1: 
1:         for (int i = 0; i < 10; i++) {
1:             XAConnection connection = factory.createXAConnection();
1:             connection.start();
1:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:             Destination destination = session.createQueue("TEST");
1:             MessageProducer producer = session.createProducer(destination);
1:             ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1: 
1:             try {
1:                 producer.send(message);
1:             } catch (Exception expected) {
1:                 expected.printStackTrace();
1: 
1:                 dumpMessages();
1: 
1:                 boolean done = false;
1:                 while (!done) {
1:                     try {
1:                         producer.send(message);
1:                         done = true;
1:                     } catch (Exception ok) {
1:                         ok.printStackTrace();
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         assertEquals("messages in db", 10, dumpMessages());
1: 
1: 
1:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:         assertEquals("en-queue", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1: 
1: 
1:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");
1:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext()
1:            .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1: 
1:         assertEquals("qs", 10, proxy.getQueueSize());
1:         assertEquals("enq", 10, proxy.getEnqueueCount());
1:         assertEquals("curs", 10, proxy.cursorSize());
1:     }
1: 
1:     public void testNonTxEnqueueOverNetworkErrorsRestart() throws Exception {
1:         getAutoCommitCount.set(0);
1:         getAutoCommitErrors.clear();
1:         executeUpdateErrorOpsCount.set(0);
1:         executeUpdateErrorOps.clear();
1:         executeBatchErrorOps.clear();
1:         executeBatchErrorOpsCount.set(0);
1: 
1:         broker.stop();
1: 
1:         final AtomicBoolean done = new AtomicBoolean(false);
1:         Thread thread = new Thread() {
1:             @Override
1:             public void run() {
1: 
1:                 while (!done.get()) {
1:                     try {
1: 
1:                         broker = new BrokerService();
1:                         broker.setAdvisorySupport(false);
1:                         PolicyMap policyMap = new PolicyMap();
1:                         PolicyEntry policyEntry = new PolicyEntry();
1:                         policyEntry.setUseCache(false);
1:                         policyEntry.setExpireMessagesPeriod(0);
1:                         policyEntry.setDeadLetterStrategy(new DiscardingDeadLetterStrategy());
1:                         policyMap.setDefaultEntry(policyEntry);
1:                         broker.setDestinationPolicy(policyMap);
1: 
1:                         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
1:                         DataSource realDataSource = jdbc.getDataSource();
1:                         jdbcPersistenceAdapter.setDataSource(new TestDataSource(realDataSource));
1:                         jdbcPersistenceAdapter.setUseLock(false);
1:                         jdbcPersistenceAdapter.setCleanupPeriod(0);
1:                         broker.setPersistenceAdapter(jdbcPersistenceAdapter);
1:                         TransportConnector transportConnector = broker.addConnector("tcp://localhost:61616");
1:                         //transportConnector.setAuditNetworkProducers(true);
1:                         connectionUri = transportConnector.getPublishableConnectString();
1:                         DefaultIOExceptionHandler stopOnIOEx = new DefaultIOExceptionHandler();
1:                         stopOnIOEx.setIgnoreSQLExceptions(false);
1:                         stopOnIOEx.setStopStartConnectors(false);
1:                         broker.setIoExceptionHandler(stopOnIOEx);
1:                         broker.start();
1: 
1:                         broker.waitUntilStopped();
1: 
1:                     } catch (Exception oops) {
1:                         oops.printStackTrace();
1:                         done.set(true);
1:                     }
1:                 }
1:             }
1:         };
1:         thread.start();
1: 
1:         //executeBatchErrorOps.add(5);
1:         //executeBatchErrorOps.add(3);
1:         getAutoCommitCount.set(0);
1:         getAutoCommitErrors.add(39);
1: 
1: 
1:         // network broker to push messages
1:         final BrokerService other = new BrokerService();
1:         other.setBrokerName("other");
1:         other.setAdvisorySupport(false);
1:         other.setUseJmx(false);
1:         other.setPersistent(false);
1:         NetworkConnector netwokConnector = other.addNetworkConnector("static://tcp://localhost:61616");
1:         netwokConnector.setStaticBridge(true);
1:         netwokConnector.setStaticallyIncludedDestinations(Arrays.asList(new ActiveMQDestination[]{new ActiveMQQueue("TEST")}));
1:         other.start();
1: 
1:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://other");
1:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) connectionFactory.createConnection();
1:         activeMQConnection.setWatchTopicAdvisories(false);
1:         Session session = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         activeMQConnection.start();
1:         Destination destination = session.createQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1:         ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1: 
1:         for (int i = 0; i < 10; i++) {
1:             producer.send(message);
1:         }
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("MESSAGES DRAINED :" + ((RegionBroker)other.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:                 return 0 == ((RegionBroker)other.getRegionBroker()).getDestinationStatistics().getMessages().getCount();
1:             }
1:         });
1:         activeMQConnection.close();
1: 
1: 
1:         assertEquals("db", 10, dumpMessages());
1:         assertEquals("messages count", 10, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1: 
1: 
1:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=TEST");
1:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext()
1:            .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1: 
1:         assertEquals("qs", 10, proxy.getQueueSize());
1:         assertEquals("curs", 10, proxy.cursorSize());
1: 
1:         done.set(true);
1:         other.stop();
1:     }
1: 
1: 
1:     private class TestDataSource implements javax.sql.DataSource {
1: 
1:         private final javax.sql.DataSource realDataSource;
1: 
1:         public TestDataSource(javax.sql.DataSource dataSource) {
1:             realDataSource = dataSource;
1:         }
1: 
1:         @Override
1:         public Connection getConnection() throws SQLException {
1:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection());
1:             return autoCommitCheckConnection;
1:         }
1: 
1:         @Override
1:         public Connection getConnection(String username, String password) throws SQLException {
1:             Connection autoCommitCheckConnection = new AutoCommitCheckConnection(realDataSource.getConnection(username, password));
1: 
1:             return autoCommitCheckConnection;
1:         }
1: 
1:         @Override
1:         public PrintWriter getLogWriter() throws SQLException {
1:             return realDataSource.getLogWriter();
1:         }
1: 
1:         @Override
1:         public void setLogWriter(PrintWriter out) throws SQLException {
1:             realDataSource.setLogWriter(out);
1:         }
1: 
1:         @Override
1:         public void setLoginTimeout(int seconds) throws SQLException {
1:             realDataSource.setLoginTimeout(seconds);
1:         }
1: 
1:         @Override
1:         public int getLoginTimeout() throws SQLException {
1:             return realDataSource.getLoginTimeout();
1:         }
1: 
1:         @Override
1:         public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException {
1:             return realDataSource.getParentLogger();
1:         }
1: 
1:         @Override
1:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:             return realDataSource.unwrap(iface);
1:         }
1: 
1:         @Override
1:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:             return realDataSource.isWrapperFor(iface);
1:         }
1:     }
1: 
1:     private class AutoCommitCheckConnection implements Connection {
1: 
1:         private final Connection realConnection;
1: 
1:         public AutoCommitCheckConnection(Connection connection) {
1:             this.realConnection = connection;
1:         }
1: 
1:         @Override
1:         public void commit() throws SQLException {
1:             realConnection.commit();
1:         }
1: 
1:         // Just plumbing for wrapper. Might have been better to do a Dynamic Proxy here.
1: 
1:         @Override
1:         public Statement createStatement() throws SQLException {
1:             return realConnection.createStatement();
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql) throws SQLException {
1:             //final AtomicInteger executeCount = new AtomicInteger();
1: 
1:             final PreparedStatement delegate = realConnection.prepareStatement(sql);
1:             return new PreparedStatement() {
1:                 public ResultSet executeQuery() throws SQLException {
1:                     return delegate.executeQuery();
1:                 }
1: 
1:                 final
1:                 public int executeUpdate() throws SQLException {
1:                     int ret = delegate.executeUpdate();
1:                     if (executeUpdateErrorOps.contains(executeUpdateErrorOpsCount.incrementAndGet())) {
1:                         throw new SQLRecoverableException("SOME executeUpdate ERROR[" + executeUpdateErrorOpsCount.get() +"]");
1:                     }
1:                     return ret;
1:                 }
1: 
1:                 public void setNull(int parameterIndex, int sqlType) throws SQLException {
1:                     delegate.setNull(parameterIndex, sqlType);
1:                 }
1: 
1:                 public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1:                     delegate.setBoolean(parameterIndex, x);
1:                 }
1: 
1:                 public void setByte(int parameterIndex, byte x) throws SQLException {
1:                     delegate.setByte(parameterIndex, x);
1:                 }
1: 
1:                 public void setShort(int parameterIndex, short x) throws SQLException {
1:                     delegate.setShort(parameterIndex, x);
1:                 }
1: 
1:                 public void setInt(int parameterIndex, int x) throws SQLException {
1:                     delegate.setInt(parameterIndex, x);
1:                 }
1: 
1:                 public void setLong(int parameterIndex, long x) throws SQLException {
1:                     delegate.setLong(parameterIndex, x);
1:                 }
1: 
1:                 public void setFloat(int parameterIndex, float x) throws SQLException {
1:                     delegate.setFloat(parameterIndex, x);
1:                 }
1: 
1:                 public void setDouble(int parameterIndex, double x) throws SQLException {
1:                     delegate.setDouble(parameterIndex, x);
1:                 }
1: 
1:                 public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
1:                     delegate.setBigDecimal(parameterIndex, x);
1:                 }
1: 
1:                 public void setString(int parameterIndex, String x) throws SQLException {
1:                     delegate.setString(parameterIndex, x);
1:                 }
1: 
1:                 public void setBytes(int parameterIndex, byte[] x) throws SQLException {
1:                     delegate.setBytes(parameterIndex, x);
1:                 }
1: 
1:                 public void setDate(int parameterIndex, Date x) throws SQLException {
1:                     delegate.setDate(parameterIndex, x);
1:                 }
1: 
1:                 public void setTime(int parameterIndex, Time x) throws SQLException {
1:                     delegate.setTime(parameterIndex, x);
1:                 }
1: 
1:                 public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
1:                     delegate.setTimestamp(parameterIndex, x);
1:                 }
1: 
1:                 public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
1:                     delegate.setAsciiStream(parameterIndex, x, length);
1:                 }
1: 
1:                 @Deprecated
1:                 public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
1:                     delegate.setUnicodeStream(parameterIndex, x, length);
1:                 }
1: 
1:                 public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
1:                     delegate.setBinaryStream(parameterIndex, x, length);
1:                 }
1: 
1:                 public void clearParameters() throws SQLException {
1:                     delegate.clearParameters();
1:                 }
1: 
1:                 public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
1:                     delegate.setObject(parameterIndex, x, targetSqlType);
1:                 }
1: 
1:                 public void setObject(int parameterIndex, Object x) throws SQLException {
1:                     delegate.setObject(parameterIndex, x);
1:                 }
1: 
1:                 public boolean execute() throws SQLException {
1:                     return delegate.execute();
1:                 }
1: 
1:                 public void addBatch() throws SQLException {
1:                     delegate.addBatch();
1:                 }
1: 
1:                 public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
1:                     delegate.setCharacterStream(parameterIndex, reader, length);
1:                 }
1: 
1:                 public void setRef(int parameterIndex, Ref x) throws SQLException {
1:                     delegate.setRef(parameterIndex, x);
1:                 }
1: 
1:                 public void setBlob(int parameterIndex, Blob x) throws SQLException {
1:                     delegate.setBlob(parameterIndex, x);
1:                 }
1: 
1:                 public void setClob(int parameterIndex, Clob x) throws SQLException {
1:                     delegate.setClob(parameterIndex, x);
1:                 }
1: 
1:                 public void setArray(int parameterIndex, Array x) throws SQLException {
1:                     delegate.setArray(parameterIndex, x);
1:                 }
1: 
1:                 public ResultSetMetaData getMetaData() throws SQLException {
1:                     return delegate.getMetaData();
1:                 }
1: 
1:                 public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
1:                     delegate.setDate(parameterIndex, x, cal);
1:                 }
1: 
1:                 public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
1:                     delegate.setTime(parameterIndex, x, cal);
1:                 }
1: 
1:                 public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
1:                     delegate.setTimestamp(parameterIndex, x, cal);
1:                 }
1: 
1:                 public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
1:                     delegate.setNull(parameterIndex, sqlType, typeName);
1:                 }
1: 
1:                 public void setURL(int parameterIndex, URL x) throws SQLException {
1:                     delegate.setURL(parameterIndex, x);
1:                 }
1: 
1:                 public ParameterMetaData getParameterMetaData() throws SQLException {
1:                     return delegate.getParameterMetaData();
1:                 }
1: 
1:                 public void setRowId(int parameterIndex, RowId x) throws SQLException {
1:                     delegate.setRowId(parameterIndex, x);
1:                 }
1: 
1:                 public void setNString(int parameterIndex, String value) throws SQLException {
1:                     delegate.setNString(parameterIndex, value);
1:                 }
1: 
1:                 public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
1:                     delegate.setNCharacterStream(parameterIndex, value, length);
1:                 }
1: 
1:                 public void setNClob(int parameterIndex, NClob value) throws SQLException {
1:                     delegate.setNClob(parameterIndex, value);
1:                 }
1: 
1:                 public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
1:                     delegate.setClob(parameterIndex, reader, length);
1:                 }
1: 
1:                 public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
1:                     delegate.setBlob(parameterIndex, inputStream, length);
1:                 }
1: 
1:                 public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
1:                     delegate.setNClob(parameterIndex, reader, length);
1:                 }
1: 
1:                 public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
1:                     delegate.setSQLXML(parameterIndex, xmlObject);
1:                 }
1: 
1:                 public void setObject(int parameterIndex,
1:                                       Object x,
1:                                       int targetSqlType,
1:                                       int scaleOrLength) throws SQLException {
1:                     delegate.setObject(parameterIndex, x, targetSqlType, scaleOrLength);
1:                 }
1: 
1:                 public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
1:                     delegate.setAsciiStream(parameterIndex, x, length);
1:                 }
1: 
1:                 public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
1:                     delegate.setBinaryStream(parameterIndex, x, length);
1:                 }
1: 
1:                 public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
1:                     delegate.setCharacterStream(parameterIndex, reader, length);
1:                 }
1: 
1:                 public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
1:                     delegate.setAsciiStream(parameterIndex, x);
1:                 }
1: 
1:                 public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
1:                     delegate.setBinaryStream(parameterIndex, x);
1:                 }
1: 
1:                 public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
1:                     delegate.setCharacterStream(parameterIndex, reader);
1:                 }
1: 
1:                 public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
1:                     delegate.setNCharacterStream(parameterIndex, value);
1:                 }
1: 
1:                 public void setClob(int parameterIndex, Reader reader) throws SQLException {
1:                     delegate.setClob(parameterIndex, reader);
1:                 }
1: 
1:                 public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
1:                     delegate.setBlob(parameterIndex, inputStream);
1:                 }
1: 
1:                 public void setNClob(int parameterIndex, Reader reader) throws SQLException {
1:                     delegate.setNClob(parameterIndex, reader);
1:                 }
1: /*
1:                 public void setObject(int parameterIndex,
1:                                       Object x,
1:                                       SQLType targetSqlType,
1:                                       int scaleOrLength) throws SQLException {
1:                     delegate.setObject(parameterIndex, x, targetSqlType, scaleOrLength);
1:                 }
1: 
1:                 public void setObject(int parameterIndex, Object x, SQLType targetSqlType) throws SQLException {
1:                     delegate.setObject(parameterIndex, x, targetSqlType);
1:                 }
1: 
1:                 public long executeLargeUpdate() throws SQLException {
1:                     return delegate.executeLargeUpdate();
1:                 }
1: */
1:                 public ResultSet executeQuery(String sql) throws SQLException {
1:                     return delegate.executeQuery(sql);
1:                 }
1: 
1:                 public int executeUpdate(String sql) throws SQLException {
1:                     return delegate.executeUpdate(sql);
1:                 }
1: 
1:                 public void close() throws SQLException {
1:                     delegate.close();
1:                 }
1: 
1:                 public int getMaxFieldSize() throws SQLException {
1:                     return delegate.getMaxFieldSize();
1:                 }
1: 
1:                 public void setMaxFieldSize(int max) throws SQLException {
1:                     delegate.setMaxFieldSize(max);
1:                 }
1: 
1:                 public int getMaxRows() throws SQLException {
1:                     return delegate.getMaxRows();
1:                 }
1: 
1:                 public void setMaxRows(int max) throws SQLException {
1:                     delegate.setMaxRows(max);
1:                 }
1: 
1:                 public void setEscapeProcessing(boolean enable) throws SQLException {
1:                     delegate.setEscapeProcessing(enable);
1:                 }
1: 
1:                 public int getQueryTimeout() throws SQLException {
1:                     return delegate.getQueryTimeout();
1:                 }
1: 
1:                 public void setQueryTimeout(int seconds) throws SQLException {
1:                     delegate.setQueryTimeout(seconds);
1:                 }
1: 
1:                 public void cancel() throws SQLException {
1:                     delegate.cancel();
1:                 }
1: 
1:                 public SQLWarning getWarnings() throws SQLException {
1:                     return delegate.getWarnings();
1:                 }
1: 
1:                 public void clearWarnings() throws SQLException {
1:                     delegate.clearWarnings();
1:                 }
1: 
1:                 public void setCursorName(String name) throws SQLException {
1:                     delegate.setCursorName(name);
1:                 }
1: 
1:                 public boolean execute(String sql) throws SQLException {
1:                     return delegate.execute(sql);
1:                 }
1: 
1:                 public ResultSet getResultSet() throws SQLException {
1:                     return delegate.getResultSet();
1:                 }
1: 
1:                 public int getUpdateCount() throws SQLException {
1:                     return delegate.getUpdateCount();
1:                 }
1: 
1:                 public boolean getMoreResults() throws SQLException {
1:                     return delegate.getMoreResults();
1:                 }
1: 
1:                 public void setFetchDirection(int direction) throws SQLException {
1:                     delegate.setFetchDirection(direction);
1:                 }
1: 
1:                 public int getFetchDirection() throws SQLException {
1:                     return delegate.getFetchDirection();
1:                 }
1: 
1:                 public void setFetchSize(int rows) throws SQLException {
1:                     delegate.setFetchSize(rows);
1:                 }
1: 
1:                 public int getFetchSize() throws SQLException {
1:                     return delegate.getFetchSize();
1:                 }
1: 
1:                 public int getResultSetConcurrency() throws SQLException {
1:                     return delegate.getResultSetConcurrency();
1:                 }
1: 
1:                 public int getResultSetType() throws SQLException {
1:                     return delegate.getResultSetType();
1:                 }
1: 
1:                 public void addBatch(String sql) throws SQLException {
1:                     delegate.addBatch(sql);
1:                 }
1: 
1:                 public void clearBatch() throws SQLException {
1:                     delegate.clearBatch();
1:                 }
1: 
1:                 public int[] executeBatch() throws SQLException {
1:                     if (executeBatchErrorOps.contains(executeBatchErrorOpsCount.incrementAndGet())) {
1:                         throw new SQLRecoverableException("SOME executeBatch ERROR[" + executeBatchErrorOpsCount.get() +"]");
1:                     }
1:                     return delegate.executeBatch();
1:                 }
1: 
1:                 public Connection getConnection() throws SQLException {
1:                     return delegate.getConnection();
1:                 }
1: 
1:                 public boolean getMoreResults(int current) throws SQLException {
1:                     return delegate.getMoreResults(current);
1:                 }
1: 
1:                 public ResultSet getGeneratedKeys() throws SQLException {
1:                     return delegate.getGeneratedKeys();
1:                 }
1: 
1:                 public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
1:                     return delegate.executeUpdate(sql, autoGeneratedKeys);
1:                 }
1: 
1:                 public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
1:                     return delegate.executeUpdate(sql, columnIndexes);
1:                 }
1: 
1:                 public int executeUpdate(String sql, String[] columnNames) throws SQLException {
1:                     return delegate.executeUpdate(sql, columnNames);
1:                 }
1: 
1:                 public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
1:                     return delegate.execute(sql, autoGeneratedKeys);
1:                 }
1: 
1:                 public boolean execute(String sql, int[] columnIndexes) throws SQLException {
1:                     return delegate.execute(sql, columnIndexes);
1:                 }
1: 
1:                 public boolean execute(String sql, String[] columnNames) throws SQLException {
1:                     return delegate.execute(sql, columnNames);
1:                 }
1: 
1:                 public int getResultSetHoldability() throws SQLException {
1:                     return delegate.getResultSetHoldability();
1:                 }
1: 
1:                 public boolean isClosed() throws SQLException {
1:                     return delegate.isClosed();
1:                 }
1: 
1:                 public void setPoolable(boolean poolable) throws SQLException {
1:                     delegate.setPoolable(poolable);
1:                 }
1: 
1:                 public boolean isPoolable() throws SQLException {
1:                     return delegate.isPoolable();
1:                 }
1: 
1:                 public void closeOnCompletion() throws SQLException {
1:                     delegate.closeOnCompletion();
1:                 }
1: 
1:                 public boolean isCloseOnCompletion() throws SQLException {
1:                     return delegate.isCloseOnCompletion();
1:                 }
1: /*
1:                 public long getLargeUpdateCount() throws SQLException {
1:                     return delegate.getLargeUpdateCount();
1:                 }
1: 
1:                 public void setLargeMaxRows(long max) throws SQLException {
1:                     delegate.setLargeMaxRows(max);
1:                 }
1: 
1:                 public long getLargeMaxRows() throws SQLException {
1:                     return delegate.getLargeMaxRows();
1:                 }
1: 
1:                 public long[] executeLargeBatch() throws SQLException {
1:                     return delegate.executeLargeBatch();
1:                 }
1: 
1:                 public long executeLargeUpdate(String sql) throws SQLException {
1:                     return delegate.executeLargeUpdate(sql);
1:                 }
1: 
1:                 public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
1:                     return delegate.executeLargeUpdate(sql, autoGeneratedKeys);
1:                 }
1: 
1:                 public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {
1:                     return delegate.executeLargeUpdate(sql, columnIndexes);
1:                 }
1: 
1:                 public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {
1:                     return delegate.executeLargeUpdate(sql, columnNames);
1:                 }
1: */
1:                 public <T> T unwrap(Class<T> iface) throws SQLException {
1:                     return delegate.unwrap(iface);
1:                 }
1: 
1:                 public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:                     return delegate.isWrapperFor(iface);
1:                 }
1:             };
1:         }
1: 
1:         @Override
1:         public CallableStatement prepareCall(String sql) throws SQLException {
1:             return realConnection.prepareCall(sql);
1:         }
1: 
1:         @Override
1:         public String nativeSQL(String sql) throws SQLException {
1:             return realConnection.nativeSQL(sql);
1:         }
1: 
1:         @Override
1:         public void setAutoCommit(boolean autoCommit) throws SQLException {
1:             realConnection.setAutoCommit(autoCommit);
1:         }
1: 
1:         @Override
1:         public boolean getAutoCommit() throws SQLException {
1:             if (getAutoCommitErrors.contains(getAutoCommitCount.incrementAndGet())) {
1:                 throw new SQLRecoverableException("AutoCommit[" + getAutoCommitCount.get() +"]");
1:             }
1:             return realConnection.getAutoCommit();
1:         }
1: 
1:         @Override
1:         public void rollback() throws SQLException {
1:             realConnection.rollback();
1:         }
1: 
1:         @Override
1:         public void close() throws SQLException {
1:             realConnection.close();
1:         }
1: 
1:         @Override
1:         public boolean isClosed() throws SQLException {
1:             return realConnection.isClosed();
1:         }
1: 
1:         @Override
1:         public DatabaseMetaData getMetaData() throws SQLException {
1:             return realConnection.getMetaData();
1:         }
1: 
1:         @Override
1:         public void setReadOnly(boolean readOnly) throws SQLException {
1:             realConnection.setReadOnly(readOnly);
1:         }
1: 
1:         @Override
1:         public boolean isReadOnly() throws SQLException {
1:             return realConnection.isReadOnly();
1:         }
1: 
1:         @Override
1:         public void setCatalog(String catalog) throws SQLException {
1:             realConnection.setCatalog(catalog);
1:         }
1: 
1:         @Override
1:         public String getCatalog() throws SQLException {
1:             return realConnection.getCatalog();
1:         }
1: 
1:         @Override
1:         public void setTransactionIsolation(int level) throws SQLException {
1:             realConnection.setTransactionIsolation(level);
1:         }
1: 
1:         @Override
1:         public int getTransactionIsolation() throws SQLException {
1:             return realConnection.getTransactionIsolation();
1:         }
1: 
1:         @Override
1:         public SQLWarning getWarnings() throws SQLException {
1:             return realConnection.getWarnings();
1:         }
1: 
1:         @Override
1:         public void clearWarnings() throws SQLException {
1:             realConnection.clearWarnings();
1:         }
1: 
1:         @Override
1:         public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
1:             return realConnection.createStatement(resultSetType, resultSetConcurrency);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency);
1:         }
1: 
1:         @Override
1:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
1:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency);
1:         }
1: 
1:         @Override
1:         public Map<String, Class<?>> getTypeMap() throws SQLException {
1:             return realConnection.getTypeMap();
1:         }
1: 
1:         @Override
1:         public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
1:             realConnection.setTypeMap(map);
1:         }
1: 
1:         @Override
1:         public void setHoldability(int holdability) throws SQLException {
1:             realConnection.setHoldability(holdability);
1:         }
1: 
1:         @Override
1:         public int getHoldability() throws SQLException {
1:             return realConnection.getHoldability();
1:         }
1: 
1:         @Override
1:         public Savepoint setSavepoint() throws SQLException {
1:             return realConnection.setSavepoint();
1:         }
1: 
1:         @Override
1:         public Savepoint setSavepoint(String name) throws SQLException {
1:             return realConnection.setSavepoint(name);
1:         }
1: 
1:         @Override
1:         public void rollback(Savepoint savepoint) throws SQLException {
1:             realConnection.rollback();
1:         }
1: 
1:         @Override
1:         public void releaseSavepoint(Savepoint savepoint) throws SQLException {
1:             realConnection.releaseSavepoint(savepoint);
1:         }
1: 
1:         @Override
1:         public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:             return realConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:             return realConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
1: 
1:         @Override
1:         public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
1:             return realConnection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
1:             return realConnection.prepareStatement(sql, autoGeneratedKeys);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
1:             return realConnection.prepareStatement(sql, columnIndexes);
1:         }
1: 
1:         @Override
1:         public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
1:             return realConnection.prepareStatement(sql, columnNames);
1:         }
1: 
1:         @Override
1:         public Clob createClob() throws SQLException {
1:             return realConnection.createClob();
1:         }
1: 
1:         @Override
1:         public Blob createBlob() throws SQLException {
1:             return realConnection.createBlob();
1:         }
1: 
1:         @Override
1:         public NClob createNClob() throws SQLException {
1:             return realConnection.createNClob();
1:         }
1: 
1:         @Override
1:         public SQLXML createSQLXML() throws SQLException {
1:             return realConnection.createSQLXML();
1:         }
1: 
1:         @Override
1:         public boolean isValid(int timeout) throws SQLException {
1:             return realConnection.isValid(timeout);
1:         }
1: 
1:         @Override
1:         public void setClientInfo(String name, String value) throws SQLClientInfoException {
1:             realConnection.setClientInfo(name, value);
1:         }
1: 
1:         @Override
1:         public void setClientInfo(Properties properties) throws SQLClientInfoException {
1:             realConnection.setClientInfo(properties);
1:         }
1: 
1:         @Override
1:         public String getClientInfo(String name) throws SQLException {
1:             return realConnection.getClientInfo(name);
1:         }
1: 
1:         @Override
1:         public Properties getClientInfo() throws SQLException {
1:             return realConnection.getClientInfo();
1:         }
1: 
1:         @Override
1:         public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
1:             return realConnection.createArrayOf(typeName, elements);
1:         }
1: 
1:         @Override
1:         public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
1:             return realConnection.createStruct(typeName, attributes);
1:         }
1: 
1:         @Override
1:         public void setSchema(String schema) throws SQLException {
1:             realConnection.setSchema(schema);
1:         }
1: 
1:         @Override
1:         public String getSchema() throws SQLException {
1:             return realConnection.getSchema();
1:         }
1: 
1:         @Override
1:         public void abort(Executor executor) throws SQLException {
1:             realConnection.abort(executor);
1:         }
1: 
1:         @Override
1:         public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
1:             realConnection.setNetworkTimeout(executor, milliseconds);
1:         }
1: 
1:         @Override
1:         public int getNetworkTimeout() throws SQLException {
1:             return realConnection.getNetworkTimeout();
1:         }
1: 
1:         @Override
1:         public <T> T unwrap(Class<T> iface) throws SQLException {
1:             return realConnection.unwrap(iface);
1:         }
1: 
1:         @Override
1:         public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:             return realConnection.isWrapperFor(iface);
1:         }
1:     }
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.MessageProducer;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.XATransactionId;
/////////////////////////////////////////////////////////////////////////
1:         onePhase = true;
/////////////////////////////////////////////////////////////////////////
1:     public void testCommitSendErrorRecovery() throws Exception {
1: 
1:         XAConnection connection = factory.createXAConnection();
1:         connection.start();
1:         XASession session = connection.createXASession();
1: 
1:         Destination destination = session.createQueue("TEST");
1:         MessageProducer producer = session.createProducer(destination);
1: 
1:         XAResource resource = session.getXAResource();
1: 
1:         Xid tid = createXid();
1:         resource.start(tid, XAResource.TMNOFLAGS);
1:         ActiveMQMessage message = (ActiveMQMessage) session.createMessage();
1:         message.setTransactionId(new XATransactionId(tid));
1:         producer.send(message);
1: 
1:         resource.end(tid, XAResource.TMSUCCESS);
1:         resource.prepare(tid);
1: 
1:         jdbc.setShouldBreak(true);
1:         try {
1:             resource.commit(tid, true);
1:         } catch (Exception expected) {
1:             expected.printStackTrace();
1:         }
1: 
1:         // recover
1:         Xid[] recovered = resource.recover(XAResource.TMSTARTRSCAN);
1:         resource.recover(XAResource.TMNOFLAGS);
1: 
1:         jdbc.setShouldBreak(false);
1:         resource.commit(recovered[0], false);
1: 
1:         assertEquals("one enque", 1, ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics().getEnqueues().getCount());
1:     }
1: 
commit:2a815c2
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.util.TestUtils.createXid;
1: 
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2d46399
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQXAConnectionFactory factory;
1:     @Override
1:     public void setUp() throws Exception {
1:         super.setUp();
1: 
1:         factory = new ActiveMQXAConnectionFactory(
1:             connectionUri + "?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries="+messagesExpected);
1:     }
1: 
commit:4743a20
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             "tcp://localhost:61616?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries="+messagesExpected);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
1:             @Override
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JDBCXACommitExceptionTest.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:aae3ea2
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Rolling back transaction (just in case, no need to do this as it is implicit in a 1pc commit failure) " + tid);
commit:e5896c0
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.store.jdbc;
1: 
0: import java.io.ByteArrayOutputStream;
0: import java.io.DataOutputStream;
0: import java.io.IOException;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.util.Properties;
1: 
0: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
0: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
1: import javax.jms.XAConnection;
1: import javax.jms.XASession;
1: import javax.transaction.xa.XAException;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: 
1: import org.apache.activemq.ActiveMQXAConnectionFactory;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import junit.framework.TestCase;
1: 
1: // https://issues.apache.org/activemq/browse/AMQ-2880
1: public class JDBCXACommitExceptionTest extends JDBCCommitExceptionTest {
0:     private static final Log LOG = LogFactory.getLog(JDBCXACommitExceptionTest.class);
1: 
0:     private long txGenerator = System.currentTimeMillis();
1: 
0:     protected ActiveMQXAConnectionFactory factory = new ActiveMQXAConnectionFactory(
0:             "tcp://localhost:61616?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries="+messagesExpected); 
1: 
1:     boolean onePhase = true;
1: 
1:     public void testTwoPhaseSqlException() throws Exception {
1:         onePhase = false;
1:         doTestSqlException();
1:     }
1: 
0:     @Override
1:     protected int receiveMessages(int messagesExpected) throws Exception {
0:         XAConnection connection = factory.createXAConnection();
1:         connection.start();
1:         XASession session = connection.createXASession();
1: 
1:         jdbc.setShouldBreak(true);
1: 
1:         // first try and receive these messages, they'll continually fail
1:         receiveMessages(messagesExpected, session, onePhase);
1: 
1:         jdbc.setShouldBreak(false);
1: 
1:         // now that the store is sane, try and get all the messages sent
1:         return receiveMessages(messagesExpected, session, onePhase);
1:     }
1: 
1:     protected int receiveMessages(int messagesExpected, XASession session, boolean onePhase) throws Exception {
1:         int messagesReceived = 0;
1: 
1:         for (int i=0; i<messagesExpected; i++) {
1:             Destination destination = session.createQueue("TEST");
1:             MessageConsumer consumer = session.createConsumer(destination);
1: 
1:             XAResource resource = session.getXAResource();
1:             resource.recover(XAResource.TMSTARTRSCAN);
1:             resource.recover(XAResource.TMNOFLAGS);
1: 
1:             Xid tid = createXid();
1: 
1:             Message message = null;
1:             try {
1:                 LOG.debug("Receiving message " + (messagesReceived+1) + " of " + messagesExpected);
1:                 resource.start(tid, XAResource.TMNOFLAGS);
1:                 message = consumer.receive(2000);
1:                 LOG.info("Received : " + message);
1:                 resource.end(tid, XAResource.TMSUCCESS);
1:                 if (message != null) {
1:                     if (onePhase) {
1:                         resource.commit(tid, true);
1:                     } else {
1:                         resource.prepare(tid);
1:                         resource.commit(tid, false);
1:                     }
1:                     messagesReceived++;
1:                 }
1:             } catch (Exception e) {
1:                 LOG.debug("Caught exception:", e);
1: 
1:                 try {
0:                     LOG.debug("Rolling back transaction (just in case, no need to do this as it is implicit in a commit failure) " + tid);
1:                     resource.rollback(tid);
1:                 }
1:                 catch (XAException ex) {
1:                     try {
1:                         LOG.debug("Caught exception during rollback: " + ex + " forgetting transaction " + tid);
1:                         resource.forget(tid);
1:                     }
1:                     catch (XAException ex1) {
1:                         LOG.debug("rollback/forget failed: " + ex1.errorCode);
1:                     }
1:                 }
1:             } finally {
1:                 if (consumer != null) {
1:                     consumer.close();
1:                 }
1:             }
1:         }
1:         return messagesReceived;
1:     }
1: 
0:     public Xid createXid() throws IOException {
1:         
0:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
0:         DataOutputStream os = new DataOutputStream(baos);
0:         os.writeLong(++txGenerator);
0:         os.close();
0:         final byte[] bs = baos.toByteArray();
1: 
0:         return new Xid() {
0:             public int getFormatId() {
0:                 return 86;
1:             }
1: 
0:             public byte[] getGlobalTransactionId() {
0:                 return bs;
1:             }
1: 
0:             public byte[] getBranchQualifier() {
0:                 return bs;
1:             }
0:         };
1: 
1:     }
1: 
1: 
1: }
============================================================================