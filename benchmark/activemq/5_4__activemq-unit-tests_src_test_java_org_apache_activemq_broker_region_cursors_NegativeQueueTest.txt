1:c2922ad: /**
1:c2922ad:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c2922ad:  * contributor license agreements.  See the NOTICE file distributed with
1:c2922ad:  * this work for additional information regarding copyright ownership.
1:c2922ad:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c2922ad:  * (the "License"); you may not use this file except in compliance with
1:c2922ad:  * the License.  You may obtain a copy of the License at
4:c2922ad:  *
1:c2922ad:  *      http://www.apache.org/licenses/LICENSE-2.0
1:c2922ad:  *
1:c2922ad:  * Unless required by applicable law or agreed to in writing, software
1:c2922ad:  * distributed under the License is distributed on an "AS IS" BASIS,
1:c2922ad:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c2922ad:  * See the License for the specific language governing permissions and
1:c2922ad:  * limitations under the License.
1:c2922ad:  */
1:c2922ad: package org.apache.activemq.broker.region.cursors;
1:fb591e7: 
1:c2922ad: import java.text.SimpleDateFormat;
1:c2922ad: import java.util.ArrayList;
1:c2922ad: import java.util.Date;
1:c2922ad: import java.util.List;
1:c2922ad: import java.util.Properties;
1:c2922ad: import java.util.concurrent.CountDownLatch;
1:c2922ad: import java.util.concurrent.TimeUnit;
1:19bf943: 
1:c2922ad: import javax.jms.Connection;
1:c2922ad: import javax.jms.ConnectionFactory;
1:c2922ad: import javax.jms.Destination;
1:c2922ad: import javax.jms.JMSException;
1:c2922ad: import javax.jms.Message;
1:c2922ad: import javax.jms.MessageConsumer;
1:c2922ad: import javax.jms.MessageListener;
1:c2922ad: import javax.jms.MessageProducer;
1:c2922ad: import javax.jms.Queue;
1:c2922ad: import javax.jms.Session;
1:c2922ad: import javax.jms.TextMessage;
1:c2922ad: import javax.management.MalformedObjectNameException;
1:c2922ad: import javax.management.ObjectName;
1:24a7626: 
1:c2922ad: import org.apache.activemq.ActiveMQConnectionFactory;
1:46e2e6e: import org.apache.activemq.AutoFailTestSupport;
1:c2922ad: import org.apache.activemq.broker.BrokerService;
1:c2922ad: import org.apache.activemq.broker.jmx.QueueViewMBean;
1:c2922ad: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:c2922ad: import org.apache.activemq.broker.region.policy.PolicyMap;
1:c2922ad: import org.apache.activemq.broker.region.policy.StorePendingQueueMessageStoragePolicy;
1:c2922ad: import org.apache.activemq.usage.MemoryUsage;
1:c2922ad: import org.apache.activemq.usage.StoreUsage;
1:c2922ad: import org.apache.activemq.usage.SystemUsage;
1:c2922ad: import org.apache.activemq.usage.TempUsage;
1:ce17f58: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
41:c2922ad: 
1:c2922ad: /**
1:c2922ad:  * Modified CursorSupport Unit test to reproduce the negative queue issue.
1:19bf943:  *
1:c2922ad:  * Keys to reproducing:
1:c2922ad:  * 1) Consecutive queues with listener on first sending to second queue
1:c2922ad:  * 2) Push each queue to the memory limit
1:c2922ad:  *      This seems to help reproduce the issue more consistently, but
1:c2922ad:  *      we have seen times in our production environment where the
1:c2922ad:  *      negative queue can occur without. Our memory limits are
1:19bf943:  *      very high in production and it still happens in varying
1:c2922ad:  *      frequency.
1:c2922ad:  * 3) Prefetch
1:19bf943:  *      Lowering the prefetch down to 10 and below seems to help
1:19bf943:  *      reduce occurrences.
1:c2922ad:  * 4) # of consumers per queue
1:c2922ad:  *      The issue occurs less with fewer consumers
1:19bf943:  *
1:c2922ad:  * Things that do not affect reproduction:
1:c2922ad:  * 1) Spring - we use spring in our production applications, but this test case works
1:c2922ad:  *      with or without it.
1:c2922ad:  * 2) transacted
1:19bf943:  *
1:c2922ad:  */
1:46e2e6e: public class NegativeQueueTest extends AutoFailTestSupport {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(NegativeQueueTest.class);
1:19bf943: 
1:c2922ad:     public static SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMdd,hh:mm:ss:SSS");
1:19bf943: 
1:c2922ad:     private static final String QUEUE_1_NAME = "conn.test.queue.1";
1:c2922ad:     private static final String QUEUE_2_NAME = "conn.test.queue.2";
1:19bf943: 
1:c2922ad:     private static final long QUEUE_MEMORY_LIMIT = 2097152;
1:c2922ad:     private static final long MEMORY_USAGE = 400000000;
1:c2922ad:     private static final long TEMP_USAGE = 200000000;
1:c2922ad:     private static final long STORE_USAGE = 1000000000;
1:66e8011:     // ensure we exceed the cache 70%
1:66e8011:     private static final int MESSAGE_COUNT = 2100;
1:19bf943: 
1:c2922ad:     protected static final boolean TRANSACTED = true;
1:46e2e6e:     protected static final boolean DEBUG = true;
1:19bf943:     protected static int NUM_CONSUMERS = 20;
1:19bf943:     protected static int PREFETCH_SIZE = 1000;
1:19bf943: 
1:c2922ad:     protected BrokerService broker;
1:3ddb71c:     protected String bindAddress = "tcp://localhost:0";
1:19bf943: 
1:c2922ad:     public void testWithDefaultPrefetch() throws Exception{
1:c2922ad:         PREFETCH_SIZE = 1000;
1:c2922ad:         NUM_CONSUMERS = 20;
1:c2922ad:         blastAndConsume();
4:c2922ad:     }
1:19bf943: 
1:c709527:     public void x_testWithDefaultPrefetchFiveConsumers() throws Exception{
1:c2922ad:         PREFETCH_SIZE = 1000;
1:c2922ad:         NUM_CONSUMERS = 5;
1:c2922ad:         blastAndConsume();
1:19bf943:     }
1:19bf943: 
1:c709527:     public void x_testWithDefaultPrefetchTwoConsumers() throws Exception{
1:c2922ad:         PREFETCH_SIZE = 1000;
1:c2922ad:         NUM_CONSUMERS = 2;
1:c2922ad:         blastAndConsume();
1:8bf987b:     }
1:19bf943: 
1:c2922ad:     public void testWithDefaultPrefetchOneConsumer() throws Exception{
1:c2922ad:         PREFETCH_SIZE = 1000;
1:c2922ad:         NUM_CONSUMERS = 1;
1:c2922ad:         blastAndConsume();
1:c2922ad:     }
1:19bf943: 
1:c2922ad:     public void testWithMediumPrefetch() throws Exception{
1:c2922ad:         PREFETCH_SIZE = 50;
1:c2922ad:         NUM_CONSUMERS = 20;
1:c2922ad:         blastAndConsume();
1:19bf943:     }
1:19bf943: 
1:c709527:     public void x_testWithSmallPrefetch() throws Exception{
1:c2922ad:         PREFETCH_SIZE = 10;
1:c2922ad:         NUM_CONSUMERS = 20;
1:c2922ad:         blastAndConsume();
1:c2922ad:     }
1:19bf943: 
1:c2922ad:     public void testWithNoPrefetch() throws Exception{
1:c2922ad:         PREFETCH_SIZE = 1;
1:24a7626:         NUM_CONSUMERS = 20;
1:c2922ad:         blastAndConsume();
1:c2922ad:     }
1:19bf943: 
1:c2922ad:     public void blastAndConsume() throws Exception {
1:fb591e7:         LOG.info(getName());
1:c2922ad:         ConnectionFactory factory = createConnectionFactory();
1:19bf943: 
1:c2922ad:         //get proxy queues for statistics lookups
1:c2922ad:         Connection proxyConnection = factory.createConnection();
1:c2922ad:         proxyConnection.start();
1:c2922ad:         Session proxySession = proxyConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:19bf943:         final QueueViewMBean proxyQueue1 = getProxyToQueueViewMBean(proxySession.createQueue(QUEUE_1_NAME));
1:19bf943:         final QueueViewMBean proxyQueue2 = getProxyToQueueViewMBean(proxySession.createQueue(QUEUE_2_NAME));
1:19bf943: 
1:c2922ad:         // LOAD THE QUEUE
1:c2922ad:         Connection producerConnection = factory.createConnection();
1:c2922ad:         producerConnection.start();
1:c2922ad:         Session session = producerConnection.createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:c2922ad:         Destination queue = session.createQueue(QUEUE_1_NAME);
1:c2922ad:         MessageProducer producer = session.createProducer(queue);
1:c2922ad:         List<TextMessage> senderList = new ArrayList<TextMessage>();
1:c2922ad:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:5170a8b:             TextMessage msg = session.createTextMessage(i + " " + formatter.format(new Date()));
1:c2922ad:             senderList.add(msg);
1:c2922ad:             producer.send(msg);
1:c2922ad:             if(TRANSACTED) session.commit();
1:c2922ad:             if(DEBUG && i%100 == 0){
1:c2922ad:                 int index = (i/100)+1;
1:c2922ad:                 System.out.print(index-((index/10)*10));
1:c2922ad:             }
1:c2922ad:         }
1:19bf943: 
1:c2922ad:         //get access to the Queue info
1:c2922ad:         if(DEBUG){
1:c2922ad:             System.out.println("");
1:c2922ad:             System.out.println("Queue1 Size = "+proxyQueue1.getQueueSize());
1:c2922ad:             System.out.println("Queue1 Memory % Used = "+proxyQueue1.getMemoryPercentUsage());
1:c2922ad:             System.out.println("Queue1 Memory Available = "+proxyQueue1.getMemoryLimit());
1:c2922ad:         }
1:19bf943: 
1:c2922ad:         // FLUSH THE QUEUE
1:c2922ad:         final CountDownLatch latch1 = new CountDownLatch(1);
1:19bf943:         final CountDownLatch latch2 = new CountDownLatch(1);
1:c2922ad:         Connection[] consumerConnections1 = new Connection[NUM_CONSUMERS];
1:c2922ad:         List<Message> consumerList1 = new ArrayList<Message>();
1:c2922ad:         Connection[] consumerConnections2 = new Connection[NUM_CONSUMERS];
1:c2922ad:         Connection[] producerConnections2 = new Connection[NUM_CONSUMERS];
1:c2922ad:         List<Message> consumerList2 = new ArrayList<Message>();
1:19bf943: 
1:c2922ad:         for(int ix=0; ix<NUM_CONSUMERS; ix++){
1:c2922ad:             producerConnections2[ix] = factory.createConnection();
1:c2922ad:             producerConnections2[ix].start();
1:c2922ad:             consumerConnections1[ix] = getConsumerConnection(factory);
1:c2922ad:             Session consumerSession = consumerConnections1[ix].createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:c2922ad:             MessageConsumer consumer = consumerSession.createConsumer(session.createQueue(QUEUE_1_NAME));
1:c2922ad:             consumer.setMessageListener(new SessionAwareMessageListener(producerConnections2[ix], consumerSession, QUEUE_2_NAME, latch1, consumerList1));
1:c2922ad:         }
1:19bf943: 
1:24a7626:         latch1.await(200000, TimeUnit.MILLISECONDS);
1:c2922ad:         if(DEBUG){
1:c2922ad:             System.out.println("");
1:c2922ad:             System.out.println("Queue2 Size = "+proxyQueue2.getQueueSize());
1:c2922ad:             System.out.println("Queue2 Memory % Used = "+proxyQueue2.getMemoryPercentUsage());
1:c2922ad:             System.out.println("Queue2 Memory Available = "+proxyQueue2.getMemoryLimit());
1:c2922ad:         }
1:ce17f58: 
1:c2922ad:         for(int ix=0; ix<NUM_CONSUMERS; ix++){
1:c2922ad:             consumerConnections2[ix] = getConsumerConnection(factory);
1:c2922ad:             Session consumerSession = consumerConnections2[ix].createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:c2922ad:             MessageConsumer consumer = consumerSession.createConsumer(session.createQueue(QUEUE_2_NAME));
1:c2922ad:             consumer.setMessageListener(new SessionAwareMessageListener(consumerSession, latch2, consumerList2));
1:c2922ad:         }
1:19bf943: 
1:46e2e6e:         boolean success = Wait.waitFor(new Wait.Condition() {
1:19bf943:             @Override
1:46e2e6e:             public boolean isSatisified() throws Exception {
1:46e2e6e:                 boolean done = latch2.await(10, TimeUnit.SECONDS);
1:46e2e6e:                 if(DEBUG){
1:46e2e6e:                     System.out.println("");
1:46e2e6e:                     System.out.println("Queue1 Size = "+proxyQueue1.getQueueSize());
1:46e2e6e:                     System.out.println("Queue1 Memory % Used = "+proxyQueue1.getMemoryPercentUsage());
1:46e2e6e:                     System.out.println("Queue2 Size = "+proxyQueue2.getQueueSize());
1:46e2e6e:                     System.out.println("Queue2 Memory % Used = "+proxyQueue2.getMemoryPercentUsage());
1:46e2e6e:                     System.out.println("Queue2 Memory Available = "+proxyQueue2.getMemoryLimit());
1:46e2e6e:                 }
1:46e2e6e:                 return done;
1:46e2e6e:             }
1:46e2e6e:         }, 300 * 1000);
1:46e2e6e:         if (!success) {
1:46e2e6e:             dumpAllThreads("blocked waiting on 2");
1:46e2e6e:         }
1:46e2e6e:         assertTrue("got all expected messages on 2", success);
1:46e2e6e: 
1:c2922ad:         producerConnection.close();
1:c2922ad:         for(int ix=0; ix<NUM_CONSUMERS; ix++){
1:c2922ad:             consumerConnections1[ix].close();
1:c2922ad:             consumerConnections2[ix].close();
1:c2922ad:             producerConnections2[ix].close();
1:c2922ad:         }
1:19bf943: 
1:c2922ad:         //let the consumer statistics on queue2 have time to update
1:c2922ad:         Thread.sleep(500);
1:19bf943: 
1:c2922ad:         if(DEBUG){
1:c2922ad:             System.out.println("");
1:c2922ad:             System.out.println("Queue1 Size = "+proxyQueue1.getQueueSize());
1:c2922ad:             System.out.println("Queue1 Memory % Used = "+proxyQueue1.getMemoryPercentUsage());
1:c2922ad:             System.out.println("Queue2 Size = "+proxyQueue2.getQueueSize());
1:c2922ad:             System.out.println("Queue2 Memory % Used = "+proxyQueue2.getMemoryPercentUsage());
1:c2922ad:         }
1:19bf943: 
1:ce17f58:         Wait.waitFor(new Wait.Condition() {
1:19bf943:             @Override
1:ce17f58:             public boolean isSatisified() throws Exception {
1:ce17f58:                 return 0 == proxyQueue1.getQueueSize();
1:ce17f58:             }});
1:c2922ad:         assertEquals("Queue1 has gone negative,",0, proxyQueue1.getQueueSize());
1:ce17f58: 
1:ce17f58:         Wait.waitFor(new Wait.Condition() {
1:19bf943:             @Override
1:ce17f58:             public boolean isSatisified() throws Exception {
1:ce17f58:                 return 0 == proxyQueue2.getQueueSize();
1:ce17f58:             }});
1:c2922ad:         assertEquals("Queue2 has gone negative,",0, proxyQueue2.getQueueSize());
1:c2922ad:         proxyConnection.close();
1:19bf943: 
1:c2922ad:     }
1:19bf943: 
1:19bf943:     private QueueViewMBean getProxyToQueueViewMBean(Queue queue) throws MalformedObjectNameException, JMSException {
1:19bf943:         final String prefix = "org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=";
1:19bf943: 
1:19bf943:         ObjectName queueViewMBeanName = new ObjectName(prefix + queue.getQueueName());
1:19bf943:         QueueViewMBean proxy = (QueueViewMBean)
1:19bf943:             broker.getManagementContext().newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1:19bf943: 
1:c2922ad:         return proxy;
1:c2922ad:     }
1:19bf943: 
1:c2922ad:    protected Connection getConsumerConnection(ConnectionFactory fac) throws JMSException {
1:c2922ad:         Connection connection = fac.createConnection();
1:c2922ad:         connection.start();
1:c2922ad:         return connection;
1:c2922ad:     }
1:c2922ad: 
1:19bf943:     @Override
1:c2922ad:     protected void setUp() throws Exception {
1:c2922ad:         if (broker == null) {
1:c2922ad:             broker = createBroker();
1:c2922ad:         }
1:c2922ad:         super.setUp();
1:c2922ad:     }
1:c2922ad: 
1:19bf943:     @Override
1:c2922ad:     protected void tearDown() throws Exception {
1:c2922ad:         super.tearDown();
1:c2922ad:         if (broker != null) {
1:c2922ad:             broker.stop();
1:5170a8b:             broker.waitUntilStopped();
1:c2922ad:         }
1:c2922ad:     }
1:c2922ad: 
1:c2922ad:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
1:c2922ad:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(bindAddress);
1:c2922ad:         Properties props = new Properties();
1:c2922ad:         props.setProperty("prefetchPolicy.durableTopicPrefetch", "" + PREFETCH_SIZE);
1:c2922ad:         props.setProperty("prefetchPolicy.optimizeDurableTopicPrefetch", "" + PREFETCH_SIZE);
1:c2922ad:         props.setProperty("prefetchPolicy.queuePrefetch", "" + PREFETCH_SIZE);
1:c2922ad:         cf.setProperties(props);
1:c2922ad:         return cf;
1:c2922ad:     }
1:c2922ad: 
1:c2922ad:     protected BrokerService createBroker() throws Exception {
1:c2922ad:         BrokerService answer = new BrokerService();
1:c2922ad:         configureBroker(answer);
1:c2922ad:         answer.start();
1:5170a8b:         answer.waitUntilStarted();
1:3ddb71c:         bindAddress = answer.getTransportConnectors().get(0).getConnectUri().toString();
1:c2922ad:         return answer;
1:c2922ad:     }
1:19bf943: 
1:c2922ad:     protected void configureBroker(BrokerService answer) throws Exception {
1:c2922ad:         PolicyEntry policy = new PolicyEntry();
1:19bf943:         policy.setMemoryLimit(QUEUE_MEMORY_LIMIT);
1:c2922ad:         policy.setPendingQueuePolicy(new StorePendingQueueMessageStoragePolicy());
1:19bf943: 
1:24a7626:         // disable the cache to be sure setBatch is the problem
1:24a7626:         // will get lots of duplicates
1:fb591e7:         // real problem is sync between cursor and store add - leads to out or order messages
1:fb591e7:         // in the cursor so setBatch can break.
1:24a7626:         // policy.setUseCache(false);
1:19bf943: 
1:c2922ad:         PolicyMap pMap = new PolicyMap();
1:c2922ad:         pMap.setDefaultEntry(policy);
1:c2922ad:         answer.setDestinationPolicy(pMap);
1:c2922ad:         answer.setDeleteAllMessagesOnStartup(true);
1:3ddb71c:         answer.addConnector("tcp://localhost:0");
1:24a7626: 
1:c2922ad:         MemoryUsage memoryUsage = new MemoryUsage();
1:19bf943:         memoryUsage.setLimit(MEMORY_USAGE);
1:c2922ad:         memoryUsage.setPercentUsageMinDelta(20);
1:c2922ad: 
1:c2922ad:         TempUsage tempUsage = new TempUsage();
1:19bf943:         tempUsage.setLimit(TEMP_USAGE);
1:c2922ad: 
1:c2922ad:         StoreUsage storeUsage = new StoreUsage();
1:19bf943:         storeUsage.setLimit(STORE_USAGE);
1:c2922ad: 
1:c2922ad:         SystemUsage systemUsage = new SystemUsage();
1:c2922ad:         systemUsage.setMemoryUsage(memoryUsage);
1:c2922ad:         systemUsage.setTempUsage(tempUsage);
1:c2922ad:         systemUsage.setStoreUsage(storeUsage);
1:c2922ad:         answer.setSystemUsage(systemUsage);
1:c2922ad:     }
1:19bf943: 
1:c2922ad:     /**
1:c2922ad:      * Message listener that is given the Session for transacted consumers
1:c2922ad:      */
1:c2922ad:     class SessionAwareMessageListener implements MessageListener{
1:19bf943:         private final List<Message> consumerList;
1:19bf943:         private final CountDownLatch latch;
1:19bf943:         private final Session consumerSession;
1:c2922ad:         private Session producerSession;
1:c2922ad:         private MessageProducer producer;
1:19bf943: 
1:c2922ad:         public SessionAwareMessageListener(Session consumerSession, CountDownLatch latch, List<Message> consumerList){
1:c2922ad:             this(null, consumerSession, null, latch, consumerList);
1:c2922ad:         }
1:19bf943: 
1:19bf943:         public SessionAwareMessageListener(Connection producerConnection, Session consumerSession, String outQueueName,
1:c2922ad:                 CountDownLatch latch, List<Message> consumerList){
1:c2922ad:             this.consumerList = consumerList;
1:c2922ad:             this.latch = latch;
1:c2922ad:             this.consumerSession = consumerSession;
1:19bf943: 
1:c2922ad:             if(producerConnection != null){
1:c2922ad:                 try {
1:c2922ad:                     producerSession = producerConnection.createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:c2922ad:                     Destination queue = producerSession.createQueue(outQueueName);
1:c2922ad:                     producer = producerSession.createProducer(queue);
1:c2922ad:                 } catch (JMSException e) {
1:c2922ad:                     e.printStackTrace();
1:c2922ad:                 }
1:c2922ad:             }
1:c2922ad:         }
1:c2922ad: 
1:19bf943:         @Override
1:c2922ad:         public void onMessage(Message msg) {
1:c2922ad:             try {
1:c2922ad:                 if(producer == null){
1:c2922ad:                     // sleep to act as a slow consumer
1:c2922ad:                     // which will force a mix of direct and polled dispatching
1:c2922ad:                     // using the cursor on the broker
1:c2922ad:                     Thread.sleep(50);
1:c2922ad:                 }else{
1:c2922ad:                     producer.send(msg);
1:c2922ad:                     if(TRANSACTED) producerSession.commit();
1:c2922ad:                 }
1:c2922ad:             } catch (Exception e) {
1:c2922ad:                 e.printStackTrace();
1:c2922ad:             }
1:19bf943: 
1:c2922ad:             synchronized(consumerList){
1:c2922ad:                 consumerList.add(msg);
1:c2922ad:                 if(DEBUG && consumerList.size()%100 == 0) {
1:c2922ad:                     int index = consumerList.size()/100;
1:c2922ad:                     System.out.print(index-((index/10)*10));
1:c2922ad:                 }
1:c2922ad:                 if (consumerList.size() == MESSAGE_COUNT) {
1:c2922ad:                     latch.countDown();
1:c2922ad:                 }
1:c2922ad:             }
1:c2922ad:             if(TRANSACTED){
1:c2922ad:                 try {
1:c2922ad:                     consumerSession.commit();
1:c2922ad:                 } catch (JMSException e) {
1:c2922ad:                     e.printStackTrace();
1:c2922ad:                 }
1:c2922ad:             }
1:c2922ad:         }
1:c2922ad:     }
1:c2922ad: }
============================================================================
author:Gary Tully
-------------------------------------------------------------------------------
commit:66e8011
/////////////////////////////////////////////////////////////////////////
1:     // ensure we exceed the cache 70%
1:     private static final int MESSAGE_COUNT = 2100;
commit:c709527
/////////////////////////////////////////////////////////////////////////
0:     private static final int MESSAGE_COUNT = 1100;
/////////////////////////////////////////////////////////////////////////
1:     public void x_testWithDefaultPrefetchFiveConsumers() throws Exception{
1:     public void x_testWithDefaultPrefetchTwoConsumers() throws Exception{
/////////////////////////////////////////////////////////////////////////
1:     public void x_testWithSmallPrefetch() throws Exception{
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1:     protected String bindAddress = "tcp://localhost:0";
/////////////////////////////////////////////////////////////////////////
1:         bindAddress = answer.getTransportConnectors().get(0).getConnectUri().toString();
/////////////////////////////////////////////////////////////////////////
1:         answer.addConnector("tcp://localhost:0");
commit:46e2e6e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.AutoFailTestSupport;
/////////////////////////////////////////////////////////////////////////
1: public class NegativeQueueTest extends AutoFailTestSupport {
/////////////////////////////////////////////////////////////////////////
1:     protected static final boolean DEBUG = true;
/////////////////////////////////////////////////////////////////////////
1:         boolean success = Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 boolean done = latch2.await(10, TimeUnit.SECONDS);
1:                 if(DEBUG){
1:                     System.out.println("");
1:                     System.out.println("Queue1 Size = "+proxyQueue1.getQueueSize());
1:                     System.out.println("Queue1 Memory % Used = "+proxyQueue1.getMemoryPercentUsage());
1:                     System.out.println("Queue2 Size = "+proxyQueue2.getQueueSize());
1:                     System.out.println("Queue2 Memory % Used = "+proxyQueue2.getMemoryPercentUsage());
1:                     System.out.println("Queue2 Memory Available = "+proxyQueue2.getMemoryLimit());
1:                 }
1:                 return done;
1:             }
1:         }, 300 * 1000);
1:         if (!success) {
1:             dumpAllThreads("blocked waiting on 2");
1:         }
1:         assertTrue("got all expected messages on 2", success);
1: 
commit:fb591e7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(NegativeQueueTest.class);
1:     
/////////////////////////////////////////////////////////////////////////
1:         LOG.info(getName());
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("got all expected messages on 2", latch2.await(300000, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
1:         // real problem is sync between cursor and store add - leads to out or order messages
1:         // in the cursor so setBatch can break.
commit:ce17f58
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == proxyQueue1.getQueueSize();
1:             }});
1:         
1:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return 0 == proxyQueue2.getQueueSize();
1:             }});
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:19bf943
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *      very high in production and it still happens in varying
1:  *      Lowering the prefetch down to 10 and below seems to help
1:  *      reduce occurrences.
1:  *
1:  *
1: 
1: 
1: 
1: 
1:     protected static int NUM_CONSUMERS = 20;
1:     protected static int PREFETCH_SIZE = 1000;
1: 
1: 
1: 
1: 
1: 
1: 
1:     }
1: 
1: 
1: 
1: 
1:         final QueueViewMBean proxyQueue1 = getProxyToQueueViewMBean(proxySession.createQueue(QUEUE_1_NAME));
1:         final QueueViewMBean proxyQueue2 = getProxyToQueueViewMBean(proxySession.createQueue(QUEUE_2_NAME));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         final CountDownLatch latch2 = new CountDownLatch(1);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
1: 
1:             @Override
1: 
1:     private QueueViewMBean getProxyToQueueViewMBean(Queue queue) throws MalformedObjectNameException, JMSException {
1:         final String prefix = "org.apache.activemq:type=Broker,brokerName=localhost,destinationType=Queue,destinationName=";
1: 
1:         ObjectName queueViewMBeanName = new ObjectName(prefix + queue.getQueueName());
1:         QueueViewMBean proxy = (QueueViewMBean)
1:             broker.getManagementContext().newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
1: 
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:         policy.setMemoryLimit(QUEUE_MEMORY_LIMIT);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         memoryUsage.setLimit(MEMORY_USAGE);
1:         tempUsage.setLimit(TEMP_USAGE);
1:         storeUsage.setLimit(STORE_USAGE);
/////////////////////////////////////////////////////////////////////////
1: 
1:         private final List<Message> consumerList;
1:         private final CountDownLatch latch;
1:         private final Session consumerSession;
1: 
1: 
1:         public SessionAwareMessageListener(Connection producerConnection, Session consumerSession, String outQueueName,
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(NegativeQueueTest.class);
/////////////////////////////////////////////////////////////////////////
1: }
commit:24a7626
/////////////////////////////////////////////////////////////////////////
1:         NUM_CONSUMERS = 20;
/////////////////////////////////////////////////////////////////////////
1:         latch1.await(200000, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:         
1:         // disable the cache to be sure setBatch is the problem
1:         // will get lots of duplicates
1:         // policy.setUseCache(false);
1:         
commit:5170a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1:             TextMessage msg = session.createTextMessage(i + " " + formatter.format(new Date()));
/////////////////////////////////////////////////////////////////////////
1:             broker.waitUntilStopped();
/////////////////////////////////////////////////////////////////////////
1:         answer.waitUntilStarted();
author:Robert Davies
-------------------------------------------------------------------------------
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
0:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext().newProxyInstance(queueViewMBeanName,
0:                 QueueViewMBean.class, true);
commit:c2922ad
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region.cursors;
1: 
1: import java.text.SimpleDateFormat;
1: import java.util.ArrayList;
1: import java.util.Date;
1: import java.util.List;
1: import java.util.Properties;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
0: import javax.management.MBeanServerInvocationHandler;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
1: 
0: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.jmx.QueueViewMBean;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.broker.region.policy.StorePendingQueueMessageStoragePolicy;
1: import org.apache.activemq.usage.MemoryUsage;
1: import org.apache.activemq.usage.StoreUsage;
1: import org.apache.activemq.usage.SystemUsage;
1: import org.apache.activemq.usage.TempUsage;
1: 
1: /**
1:  * Modified CursorSupport Unit test to reproduce the negative queue issue.
1:  * 
1:  * Keys to reproducing:
1:  * 1) Consecutive queues with listener on first sending to second queue
1:  * 2) Push each queue to the memory limit
1:  *      This seems to help reproduce the issue more consistently, but
1:  *      we have seen times in our production environment where the
1:  *      negative queue can occur without. Our memory limits are
0:  *      very high in production and it still happens in varying 
1:  *      frequency.
1:  * 3) Prefetch
0:  *      Lowering the prefetch down to 10 and below seems to help 
0:  *      reduce occurrences. 
1:  * 4) # of consumers per queue
1:  *      The issue occurs less with fewer consumers
1:  * 
1:  * Things that do not affect reproduction:
1:  * 1) Spring - we use spring in our production applications, but this test case works
1:  *      with or without it.
1:  * 2) transacted
1:  * 
1:  */
0: public class NegativeQueueTest extends TestCase {
1: 
1:     public static SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMdd,hh:mm:ss:SSS");
1:     
1:     private static final String QUEUE_1_NAME = "conn.test.queue.1";
1:     private static final String QUEUE_2_NAME = "conn.test.queue.2";
1:     
1:     private static final long QUEUE_MEMORY_LIMIT = 2097152;
1:     private static final long MEMORY_USAGE = 400000000;
1:     private static final long TEMP_USAGE = 200000000;
1:     private static final long STORE_USAGE = 1000000000;
0:     private static final int MESSAGE_COUNT = 2000;  
1:     
1:     protected static final boolean TRANSACTED = true;
0:     protected static final boolean DEBUG = false;
0:     protected static int NUM_CONSUMERS = 20;    
0:     protected static int PREFETCH_SIZE = 1000;  
1:     
1:     protected BrokerService broker;
0:     protected String bindAddress = "tcp://localhost:60706";
1:     
1:     public void testWithDefaultPrefetch() throws Exception{
1:         PREFETCH_SIZE = 1000;
1:         NUM_CONSUMERS = 20;
1:         blastAndConsume();
1:     }
1:     
0:     public void testWithDefaultPrefetchFiveConsumers() throws Exception{
1:         PREFETCH_SIZE = 1000;
1:         NUM_CONSUMERS = 5;
1:         blastAndConsume();
1:     }
1:     
0:     public void testWithDefaultPrefetchTwoConsumers() throws Exception{
1:         PREFETCH_SIZE = 1000;
1:         NUM_CONSUMERS = 2;
1:         blastAndConsume();
1:     }
1:     
1:     public void testWithDefaultPrefetchOneConsumer() throws Exception{
1:         PREFETCH_SIZE = 1000;
1:         NUM_CONSUMERS = 1;
1:         blastAndConsume();
1:     }
1:     
1:     public void testWithMediumPrefetch() throws Exception{
1:         PREFETCH_SIZE = 50;
1:         NUM_CONSUMERS = 20;
1:         blastAndConsume();
1:     }   
1:     
0:     public void testWithSmallPrefetch() throws Exception{
1:         PREFETCH_SIZE = 10;
1:         NUM_CONSUMERS = 20;
1:         blastAndConsume();
1:     }
1:     
1:     public void testWithNoPrefetch() throws Exception{
1:         PREFETCH_SIZE = 1;
1:         blastAndConsume();
1:     }
1:     
1:     public void blastAndConsume() throws Exception {
1:         ConnectionFactory factory = createConnectionFactory();
1:         
1:         //get proxy queues for statistics lookups
1:         Connection proxyConnection = factory.createConnection();
1:         proxyConnection.start();
1:         Session proxySession = proxyConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         final QueueViewMBean proxyQueue1 = getProxyToQueueViewMBean((Queue)proxySession.createQueue(QUEUE_1_NAME));
0:         final QueueViewMBean proxyQueue2 = getProxyToQueueViewMBean((Queue)proxySession.createQueue(QUEUE_2_NAME));
1:         
1:         // LOAD THE QUEUE
1:         Connection producerConnection = factory.createConnection();
1:         producerConnection.start();
1:         Session session = producerConnection.createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:         Destination queue = session.createQueue(QUEUE_1_NAME);
1:         MessageProducer producer = session.createProducer(queue);
1:         List<TextMessage> senderList = new ArrayList<TextMessage>();
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
0:             TextMessage msg = session.createTextMessage(formatter.format(new Date()));
1:             senderList.add(msg);
1:             producer.send(msg);
1:             if(TRANSACTED) session.commit();
1:             if(DEBUG && i%100 == 0){
1:                 int index = (i/100)+1;
1:                 System.out.print(index-((index/10)*10));
1:             }
1:         }
1:         
1:         //get access to the Queue info
1:         if(DEBUG){
1:             System.out.println("");
1:             System.out.println("Queue1 Size = "+proxyQueue1.getQueueSize());
1:             System.out.println("Queue1 Memory % Used = "+proxyQueue1.getMemoryPercentUsage());
1:             System.out.println("Queue1 Memory Available = "+proxyQueue1.getMemoryLimit());
1:         }
1:         
1:         // FLUSH THE QUEUE
1:         final CountDownLatch latch1 = new CountDownLatch(1);
0:         final CountDownLatch latch2 = new CountDownLatch(1);        
1:         Connection[] consumerConnections1 = new Connection[NUM_CONSUMERS];
1:         List<Message> consumerList1 = new ArrayList<Message>();
1:         Connection[] consumerConnections2 = new Connection[NUM_CONSUMERS];
1:         Connection[] producerConnections2 = new Connection[NUM_CONSUMERS];
1:         List<Message> consumerList2 = new ArrayList<Message>();
1:         
1:         for(int ix=0; ix<NUM_CONSUMERS; ix++){
1:             producerConnections2[ix] = factory.createConnection();
1:             producerConnections2[ix].start();
1:             consumerConnections1[ix] = getConsumerConnection(factory);
1:             Session consumerSession = consumerConnections1[ix].createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer consumer = consumerSession.createConsumer(session.createQueue(QUEUE_1_NAME));
1:             consumer.setMessageListener(new SessionAwareMessageListener(producerConnections2[ix], consumerSession, QUEUE_2_NAME, latch1, consumerList1));
1:         }
1:         
0:         latch1.await(300000, TimeUnit.MILLISECONDS);
1:         if(DEBUG){
1:             System.out.println("");
1:             System.out.println("Queue2 Size = "+proxyQueue2.getQueueSize());
1:             System.out.println("Queue2 Memory % Used = "+proxyQueue2.getMemoryPercentUsage());
1:             System.out.println("Queue2 Memory Available = "+proxyQueue2.getMemoryLimit());
1:         }
1:         
1:         for(int ix=0; ix<NUM_CONSUMERS; ix++){
1:             consumerConnections2[ix] = getConsumerConnection(factory);
1:             Session consumerSession = consumerConnections2[ix].createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:             MessageConsumer consumer = consumerSession.createConsumer(session.createQueue(QUEUE_2_NAME));
1:             consumer.setMessageListener(new SessionAwareMessageListener(consumerSession, latch2, consumerList2));
1:         }
1:         
0:         latch2.await(300000, TimeUnit.MILLISECONDS);
1:         producerConnection.close();
1:         for(int ix=0; ix<NUM_CONSUMERS; ix++){
1:             consumerConnections1[ix].close();
1:             consumerConnections2[ix].close();
1:             producerConnections2[ix].close();
1:         }
1:         
1:         //let the consumer statistics on queue2 have time to update
1:         Thread.sleep(500);
1:         
1:         if(DEBUG){
1:             System.out.println("");
1:             System.out.println("Queue1 Size = "+proxyQueue1.getQueueSize());
1:             System.out.println("Queue1 Memory % Used = "+proxyQueue1.getMemoryPercentUsage());
1:             System.out.println("Queue2 Size = "+proxyQueue2.getQueueSize());
1:             System.out.println("Queue2 Memory % Used = "+proxyQueue2.getMemoryPercentUsage());
1:         }
1:         
1:         assertEquals("Queue1 has gone negative,",0, proxyQueue1.getQueueSize());
1:         assertEquals("Queue2 has gone negative,",0, proxyQueue2.getQueueSize());
1:         proxyConnection.close();
1:         
1:     }
1: 
0:     private QueueViewMBean getProxyToQueueViewMBean(Queue queue)
0:         throws MalformedObjectNameException, JMSException {
1:         
0:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq" + ":Type=Queue,Destination=" + 
0:             queue.getQueueName() + ",BrokerName=localhost");
0:         QueueViewMBean proxy = (QueueViewMBean)MBeanServerInvocationHandler.newProxyInstance(
0:                 broker.getManagementContext().getMBeanServer(), 
0:             queueViewMBeanName, QueueViewMBean.class, true);
1:      
1:         return proxy;
1:     }
1:     
1:    protected Connection getConsumerConnection(ConnectionFactory fac) throws JMSException {
1:         Connection connection = fac.createConnection();
1:         connection.start();
1:         return connection;
1:     }
1: 
1:     protected void setUp() throws Exception {
1:         if (broker == null) {
1:             broker = createBroker();
1:         }
1:         super.setUp();
1:     }
1: 
1:     protected void tearDown() throws Exception {
1:         super.tearDown();
1:         if (broker != null) {
1:             broker.stop();
1:         }
1:     }
1: 
1:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(bindAddress);
1:         Properties props = new Properties();
1:         props.setProperty("prefetchPolicy.durableTopicPrefetch", "" + PREFETCH_SIZE);
1:         props.setProperty("prefetchPolicy.optimizeDurableTopicPrefetch", "" + PREFETCH_SIZE);
1:         props.setProperty("prefetchPolicy.queuePrefetch", "" + PREFETCH_SIZE);
1:         cf.setProperties(props);
1:         return cf;
1:     }
1: 
1:     protected BrokerService createBroker() throws Exception {
1:         BrokerService answer = new BrokerService();
1:         configureBroker(answer);
1:         answer.start();
1:         return answer;
1:     }
1:     
1:     protected void configureBroker(BrokerService answer) throws Exception {
1:         PolicyEntry policy = new PolicyEntry();
0:         policy.setMemoryLimit(QUEUE_MEMORY_LIMIT); 
1:         policy.setPendingQueuePolicy(new StorePendingQueueMessageStoragePolicy());
1:         PolicyMap pMap = new PolicyMap();
1:         pMap.setDefaultEntry(policy);
1:         answer.setDestinationPolicy(pMap);
1:         answer.setDeleteAllMessagesOnStartup(true);
0:         answer.addConnector(bindAddress);
1: 
1:         MemoryUsage memoryUsage = new MemoryUsage();
0:         memoryUsage.setLimit(MEMORY_USAGE); 
1:         memoryUsage.setPercentUsageMinDelta(20);
1: 
1:         TempUsage tempUsage = new TempUsage();
0:         tempUsage.setLimit(TEMP_USAGE); 
1: 
1:         StoreUsage storeUsage = new StoreUsage();
0:         storeUsage.setLimit(STORE_USAGE); 
1: 
1:         SystemUsage systemUsage = new SystemUsage();
1:         systemUsage.setMemoryUsage(memoryUsage);
1:         systemUsage.setTempUsage(tempUsage);
1:         systemUsage.setStoreUsage(storeUsage);
1:         answer.setSystemUsage(systemUsage);
1:     }
1:     
1:     /**
1:      * Message listener that is given the Session for transacted consumers
1:      */
1:     class SessionAwareMessageListener implements MessageListener{
0:         private List<Message> consumerList;
0:         private CountDownLatch latch;
0:         private Session consumerSession;
1:         private Session producerSession;
1:         private MessageProducer producer;
1:         
1:         public SessionAwareMessageListener(Session consumerSession, CountDownLatch latch, List<Message> consumerList){
1:             this(null, consumerSession, null, latch, consumerList);
1:         }
1:         
0:         public SessionAwareMessageListener(Connection producerConnection, Session consumerSession, String outQueueName, 
1:                 CountDownLatch latch, List<Message> consumerList){
1:             this.consumerList = consumerList;
1:             this.latch = latch;
1:             this.consumerSession = consumerSession;
1:             
1:             if(producerConnection != null){
1:                 try {
1:                     producerSession = producerConnection.createSession(TRANSACTED, Session.AUTO_ACKNOWLEDGE);
1:                     Destination queue = producerSession.createQueue(outQueueName);
1:                     producer = producerSession.createProducer(queue);
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         }
1:         
1:         public void onMessage(Message msg) {
1:             try {
1:                 if(producer == null){
1:                     // sleep to act as a slow consumer
1:                     // which will force a mix of direct and polled dispatching
1:                     // using the cursor on the broker
1:                     Thread.sleep(50);
1:                 }else{
1:                     producer.send(msg);
1:                     if(TRANSACTED) producerSession.commit();
1:                 }
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:             }
1:             
1:             synchronized(consumerList){
1:                 consumerList.add(msg);
1:                 if(DEBUG && consumerList.size()%100 == 0) {
1:                     int index = consumerList.size()/100;
1:                     System.out.print(index-((index/10)*10));
1:                 }
1:                 if (consumerList.size() == MESSAGE_COUNT) {
1:                     latch.countDown();
1:                 }
1:             }
1:             if(TRANSACTED){
1:                 try {
1:                     consumerSession.commit();
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         }
1:     }    
1: }
============================================================================