1:ab434ee: /*
1:bc9751a:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:bc9751a:  * contributor license agreements.  See the NOTICE file distributed with
1:bc9751a:  * this work for additional information regarding copyright ownership.
1:bc9751a:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:bc9751a:  * (the "License"); you may not use this file except in compliance with
1:bc9751a:  * the License.  You may obtain a copy of the License at
1:bc9751a:  *
1:bc9751a:  *      http://www.apache.org/licenses/LICENSE-2.0
1:bc9751a:  *
1:bc9751a:  * Unless required by applicable law or agreed to in writing, software
1:bc9751a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:bc9751a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:bc9751a:  * See the License for the specific language governing permissions and
1:bc9751a:  * limitations under the License.
1:bc9751a:  */
1:bc9751a: package org.apache.activemq.transport.mqtt;
1:28b4534: 
1:91d277c: import static org.junit.Assert.assertEquals;
1:91d277c: import static org.junit.Assert.assertNotNull;
1:91d277c: import static org.junit.Assert.assertNull;
1:91d277c: import static org.junit.Assert.assertTrue;
1:05c3112: 
1:ab434ee: import java.nio.charset.StandardCharsets;
1:a0a23b9: import java.util.AbstractMap;
1:ab434ee: import java.util.concurrent.ArrayBlockingQueue;
1:ab434ee: import java.util.concurrent.BlockingQueue;
1:4f57744: import java.util.concurrent.CountDownLatch;
1:4f57744: import java.util.concurrent.TimeUnit;
1:4f57744: import java.util.concurrent.atomic.AtomicInteger;
1:4f57744: import java.util.concurrent.atomic.AtomicReference;
1:05c3112: 
1:91d277c: import javax.jms.Message;
1:91d277c: import javax.jms.MessageConsumer;
1:91d277c: import javax.jms.MessageListener;
1:91d277c: import javax.jms.Session;
1:05c3112: 
1:4f57744: import org.apache.activemq.ActiveMQConnection;
1:4f57744: import org.apache.activemq.util.Wait;
1:91d277c: import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
1:91d277c: import org.eclipse.paho.client.mqttv3.MqttCallback;
1:91d277c: import org.eclipse.paho.client.mqttv3.MqttClient;
1:91d277c: import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
1:91d277c: import org.eclipse.paho.client.mqttv3.MqttMessage;
1:4f57744: import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
1:4f57744: import org.junit.Test;
1:4f57744: import org.slf4j.Logger;
1:4f57744: import org.slf4j.LoggerFactory;
1:05c3112: 
1:fb569e3: public class PahoMQTTTest extends MQTTTestSupport {
1:05c3112: 
1:fb569e3:     private static final Logger LOG = LoggerFactory.getLogger(PahoMQTTTest.class);
1:05c3112: 
1:aa743cb:     protected MessageConsumer createConsumer(Session s, String topic) throws Exception {
1:aa743cb:         return s.createConsumer(s.createTopic(topic));
1:aa743cb:     }
1:aa743cb: 
1:ab434ee:     @Test(timeout = 90000)
1:fb569e3:     public void testLotsOfClients() throws Exception {
1:4a8fec4: 
1:fb569e3:         final int CLIENTS = Integer.getInteger("PahoMQTTTest.CLIENTS", 100);
1:fb569e3:         LOG.info("Using: {} clients", CLIENTS);
1:4a8fec4: 
1:fb569e3:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
1:bc9751a:         activeMQConnection.start();
1:bc9751a:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:aa743cb:         MessageConsumer consumer = createConsumer(s, "test");
1:4a8fec4: 
1:fb569e3:         final AtomicInteger receiveCounter = new AtomicInteger();
1:fb569e3:         consumer.setMessageListener(new MessageListener() {
1:aa743cb:             @Override
1:fb569e3:             public void onMessage(Message message) {
1:fb569e3:                 receiveCounter.incrementAndGet();
1:4a8fec4:             }
6:05c3112:         });
1:4a8fec4: 
1:fb569e3:         final AtomicReference<Throwable> asyncError = new AtomicReference<Throwable>();
1:fb569e3:         final CountDownLatch connectedDoneLatch = new CountDownLatch(CLIENTS);
1:fb569e3:         final CountDownLatch disconnectDoneLatch = new CountDownLatch(CLIENTS);
1:fb569e3:         final CountDownLatch sendBarrier = new CountDownLatch(1);
1:fb569e3:         for (int i = 0; i < CLIENTS; i++) {
1:fb569e3:             Thread.sleep(10);
1:fb569e3:             new Thread(null, null, "client:" + i) {
1:4f57744:                 @Override
1:fb569e3:                 public void run() {
1:fb569e3:                     try {
1:101b712:                         MqttClient client = new MqttClient("tcp://localhost:" + getPort(), Thread.currentThread().getName(), new MemoryPersistence());
1:fb569e3:                         client.connect();
1:fb569e3:                         connectedDoneLatch.countDown();
1:fb569e3:                         sendBarrier.await();
1:fb569e3:                         for (int i = 0; i < 10; i++) {
1:fb569e3:                             Thread.sleep(1000);
1:ab434ee:                             client.publish("test", "hello".getBytes(StandardCharsets.UTF_8), 1, false);
1:4a8fec4:                         }
1:fb569e3:                         client.disconnect();
1:fb569e3:                         client.close();
1:fb569e3:                     } catch (Throwable e) {
1:fb569e3:                         e.printStackTrace();
1:fb569e3:                         asyncError.set(e);
1:fb569e3:                     } finally {
1:fb569e3:                         disconnectDoneLatch.countDown();
1:05c3112:                     }
1:05c3112:                 }
1:fb569e3:             }.start();
1:28b4534:         }
1:4f57744: 
1:fb569e3:         connectedDoneLatch.await();
1:fb569e3:         assertNull("Async error: " + asyncError.get(), asyncError.get());
1:fb569e3:         sendBarrier.countDown();
1:05c3112: 
1:fb569e3:         LOG.info("All clients connected... waiting to receive sent messages...");
1:05c3112: 
1:fb569e3:         // We should eventually get all the messages.
1:fb569e3:         within(30, TimeUnit.SECONDS, new Task() {
2:05c3112:             @Override
1:fb569e3:             public void run() throws Exception {
1:fb569e3:                 assertTrue(receiveCounter.get() == CLIENTS * 10);
5:28b4534:             }
1:05c3112:         });
1:28b4534: 
1:fb569e3:         LOG.info("All messages received.");
1:28b4534: 
1:fb569e3:         disconnectDoneLatch.await();
1:fb569e3:         assertNull("Async error: " + asyncError.get(), asyncError.get());
1:28b4534:     }
1:ab434ee: 
1:ab434ee:     @Test(timeout = 90000)
1:fb569e3:     public void testSendAndReceiveMQTT() throws Exception {
1:ab434ee: 
1:fb569e3:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
1:fb569e3:         activeMQConnection.start();
1:fb569e3:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:aa743cb:         MessageConsumer consumer = createConsumer(s, "test");
1:ab434ee: 
1:fb569e3:         MqttClient client = new MqttClient("tcp://localhost:" + getPort(), "clientid", new MemoryPersistence());
1:bc9751a:         client.connect();
1:ab434ee:         client.publish("test", "hello".getBytes(StandardCharsets.UTF_8), 1, false);
1:ab434ee: 
1:bc9751a:         Message msg = consumer.receive(100 * 5);
1:bc9751a:         assertNotNull(msg);
1:ab434ee: 
1:bc9751a:         client.disconnect();
1:ab434ee:         client.close();
1:28b4534:     }
1:91d277c: 
1:ab434ee:     @Test(timeout = 90000)
1:05c3112:     public void testSubs() throws Exception {
1:101b712: 
1:05c3112:         final DefaultListener listener = new DefaultListener();
1:05c3112:         // subscriber connects and creates durable sub
1:05c3112:         MqttClient client = createClient(false, "receive", listener);
2:101b712: 
1:101b712:         final String ACCOUNT_PREFIX = "test/";
1:101b712: 
1:101b712:         client.subscribe(ACCOUNT_PREFIX + "1/2/3");
1:101b712:         client.subscribe(ACCOUNT_PREFIX + "a/+/#");
1:101b712:         client.subscribe(ACCOUNT_PREFIX + "#");
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:4f57744: 
1:05c3112:         String expectedResult = "should get everything";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "1/2/3/4", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:05c3112: 
1:ab434ee:         // One delivery for topic  ACCOUNT_PREFIX + "#"
1:a0a23b9:         String result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:ab434ee:         assertEquals(expectedResult, result);
1:05c3112: 
1:4f57744:         expectedResult = "should get everything";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "a/1/2", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:4f57744: 
1:ab434ee:         // One delivery for topic  ACCOUNT_PREFIX + "a/1/2"
1:a0a23b9:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:ab434ee:         // One delivery for topic  ACCOUNT_PREFIX + "#"
1:a0a23b9:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:4f57744:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:05c3112: 
1:4f57744:         client.unsubscribe(ACCOUNT_PREFIX + "a/+/#");
1:4f57744:         client.unsubscribe(ACCOUNT_PREFIX + "#");
1:4f57744:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:28b4534: 
1:4f57744:         expectedResult = "should still get 1/2/3";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "1/2/3", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:28b4534: 
1:ab434ee:         // One delivery for topic  ACCOUNT_PREFIX + "1/2/3"
1:a0a23b9:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:28b4534:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:28b4534: 
1:ab434ee:         client.disconnect();
1:ab434ee:         client.close();
1:05c3112:     }
1:28b4534: 
1:ab434ee:     @Test(timeout = 90000)
1:05c3112:     public void testOverlappingTopics() throws Exception {
1:05c3112: 
1:05c3112:         final DefaultListener listener = new DefaultListener();
1:05c3112:         // subscriber connects and creates durable sub
1:05c3112:         MqttClient client = createClient(false, "receive", listener);
1:05c3112: 
1:101b712:         final String ACCOUNT_PREFIX = "test/";
1:05c3112: 
1:05c3112:         // *****************************************
1:05c3112:         // check a simple # subscribe works
1:05c3112:         // *****************************************
1:101b712:         client.subscribe(ACCOUNT_PREFIX + "#");
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:05c3112:         String expectedResult = "hello mqtt broker on hash";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "a/b/c", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:05c3112: 
1:a0a23b9:         String result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:28b4534: 
1:05c3112:         expectedResult = "hello mqtt broker on a different topic";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "1/2/3/4/5/6", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:a0a23b9:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:05c3112: 
1:05c3112:         // *****************************************
1:101b712:         // now subscribe on a topic that overlaps the root # wildcard - we
1:101b712:         // should still get everything
1:05c3112:         // *****************************************
1:101b712:         client.subscribe(ACCOUNT_PREFIX + "1/2/3");
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:05c3112: 
1:05c3112:         expectedResult = "hello mqtt broker on explicit topic";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "1/2/3", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:05c3112: 
1:ab434ee:         // One message from topic subscription on ACCOUNT_PREFIX + "#"
1:a0a23b9:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:28b4534: 
1:ab434ee:         // One message from topic subscription on ACCOUNT_PREFIX + "1/2/3"
1:a0a23b9:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:ab434ee: 
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:ab434ee: 
1:05c3112:         expectedResult = "hello mqtt broker on some other topic";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "a/b/c/d/e", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:a0a23b9:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(expectedResult, result);
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:ab434ee: 
1:05c3112:         // *****************************************
1:05c3112:         // now unsub hash - we should only get called back on 1/2/3
1:05c3112:         // *****************************************
1:101b712:         client.unsubscribe(ACCOUNT_PREFIX + "#");
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:ab434ee: 
1:05c3112:         expectedResult = "this should not come back...";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "1/2/3/4", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:a0a23b9:         assertNull(listener.messageQ.poll(3, TimeUnit.SECONDS));
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:101b712: 
1:05c3112:         expectedResult = "this should not come back either...";
1:ab434ee:         client.publish(ACCOUNT_PREFIX + "a/b/c", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:a0a23b9:         assertNull(listener.messageQ.poll(3, TimeUnit.SECONDS));
1:05c3112:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:ab434ee: 
1:ab434ee:         client.disconnect();
1:ab434ee:         client.close();
1:05c3112:     }
1:101b712: 
1:ab434ee:     @Test(timeout = 90000)
1:28b4534:     public void testCleanSession() throws Exception {
1:28b4534:         String topic = "test";
1:28b4534:         final DefaultListener listener = new DefaultListener();
1:28b4534: 
1:28b4534:         // subscriber connects and creates durable sub
1:28b4534:         LOG.info("Connecting durable subscriber...");
1:28b4534:         MqttClient client = createClient(false, "receive", listener);
1:28b4534:         // subscribe and wait for the retain message to arrive
1:28b4534:         LOG.info("Subscribing durable subscriber...");
1:28b4534:         client.subscribe(topic, 1);
1:28b4534:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:28b4534:         disconnect(client);
1:28b4534:         LOG.info("Disconnected durable subscriber.");
1:28b4534: 
1:28b4534:         // Publish message with QoS 1
1:28b4534:         MqttClient client2 = createClient(true, "publish", listener);
1:28b4534: 
1:28b4534:         LOG.info("Publish message with QoS 1...");
1:28b4534:         String expectedResult = "QOS 1 message";
1:ab434ee:         client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 1, false);
1:28b4534:         waitForDelivery(client2);
1:28b4534: 
1:28b4534:         // Publish message with QoS 0
1:28b4534:         LOG.info("Publish message with QoS 0...");
1:28b4534:         expectedResult = "QOS 0 message";
1:ab434ee:         client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:28b4534:         waitForDelivery(client2);
1:28b4534: 
1:28b4534:         // subscriber reconnects
1:28b4534:         LOG.info("Reconnecting durable subscriber...");
1:28b4534:         MqttClient client3 = createClient(false, "receive", listener);
1:28b4534: 
1:28b4534:         LOG.info("Subscribing durable subscriber...");
1:28b4534:         client3.subscribe(topic, 1);
1:28b4534: 
2:aa743cb:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:aa743cb:             @Override
1:aa743cb:             public boolean isSatisified() throws Exception {
1:ab434ee:                 return listener.received.get() == 2;
1:aa743cb:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100)));
1:ab434ee:         assertEquals(2, listener.received.get());
1:28b4534:         disconnect(client3);
1:28b4534:         LOG.info("Disconnected durable subscriber.");
1:4f57744: 
1:28b4534:         // make sure we consumed everything
1:ab434ee:         assertTrue(listener.received.compareAndSet(2, 0));
1:05c3112: 
1:28b4534:         LOG.info("Reconnecting durable subscriber...");
1:28b4534:         MqttClient client4 = createClient(false, "receive", listener);
1:28b4534: 
1:28b4534:         LOG.info("Subscribing durable subscriber...");
1:28b4534:         client4.subscribe(topic, 1);
1:ab434ee:         TimeUnit.SECONDS.sleep(3);
1:ab434ee:         assertEquals(0, listener.received.get());
1:28b4534: 
1:ab434ee:         client2.disconnect();
1:ab434ee:         client2.close();
1:ab434ee:         client4.disconnect();
1:ab434ee:         client4.close();
1:4f57744:     }
1:28b4534: 
1:ab434ee:     @Test(timeout = 90000)
1:aa743cb:     public void testClientIdSpecialChars() throws Exception {
1:aa743cb:         testClientIdSpecialChars(MqttConnectOptions.MQTT_VERSION_3_1);
1:aa743cb:         testClientIdSpecialChars(MqttConnectOptions.MQTT_VERSION_3_1_1);
1:aa743cb:     }
1:28b4534: 
1:aa743cb:     protected void testClientId(String clientId, int mqttVersion, final DefaultListener clientAdminMqttCallback) throws Exception {
1:4a8fec4:         MqttConnectOptions options1 = new MqttConnectOptions();
1:4a8fec4:         options1.setCleanSession(false);
1:aa743cb:         options1.setUserName("client1");
1:aa743cb:         options1.setPassword("client1".toCharArray());
1:aa743cb:         options1.setMqttVersion(mqttVersion);
1:aa743cb:         final DefaultListener client1MqttCallback = new DefaultListener();
1:aa743cb:         MqttClient client1 = createClient(options1, clientId, client1MqttCallback);
1:aa743cb:         client1.setCallback(client1MqttCallback);
1:4a8fec4: 
1:aa743cb:         String topic = "client1/" + clientId + "/topic";
1:aa743cb:         client1.subscribe(topic, 1);
1:4a8fec4: 
1:aa743cb:         String message = "Message from client: " + clientId;
1:ab434ee:         client1.publish(topic, message.getBytes(StandardCharsets.UTF_8), 1, false);
1:aa743cb: 
1:a0a23b9:         String result = client1MqttCallback.messageQ.poll(10, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(message, result);
1:ab434ee:         assertEquals(1, client1MqttCallback.received.get());
1:aa743cb: 
1:a0a23b9:         result = clientAdminMqttCallback.messageQ.poll(10, TimeUnit.SECONDS).getValue();
1:ab434ee:         assertEquals(message, result);
1:4a8fec4: 
1:aa743cb:         assertTrue(client1.isConnected());
1:aa743cb:         client1.disconnect();
1:ab434ee:         client1.close();
1:aa743cb:     }
1:4a8fec4: 
1:aa743cb:     protected void testClientIdSpecialChars(int mqttVersion) throws Exception {
1:aa743cb: 
1:aa743cb:         LOG.info("Test MQTT version {}", mqttVersion);
1:aa743cb:         MqttConnectOptions optionsAdmin = new MqttConnectOptions();
1:aa743cb:         optionsAdmin.setCleanSession(false);
1:aa743cb:         optionsAdmin.setUserName("admin");
1:aa743cb:         optionsAdmin.setPassword("admin".toCharArray());
1:aa743cb: 
1:aa743cb:         DefaultListener clientAdminMqttCallback = new DefaultListener();
1:aa743cb:         MqttClient clientAdmin = createClient(optionsAdmin, "admin", clientAdminMqttCallback);
1:aa743cb:         clientAdmin.subscribe("#", 1);
1:aa743cb: 
1:aa743cb:         testClientId(":%&&@.:llll", mqttVersion, clientAdminMqttCallback);
1:aa743cb:         testClientId("Consumer:id:AT_LEAST_ONCE", mqttVersion, clientAdminMqttCallback);
1:aa743cb:         testClientId("Consumer:qid:EXACTLY_ONCE:VirtualTopic", mqttVersion, clientAdminMqttCallback);
1:aa743cb:         testClientId("Consumertestmin:testst:AT_LEAST_ONCE.VirtualTopic::AT_LEAST_ONCE", mqttVersion, clientAdminMqttCallback);
1:aa743cb: 
1:ab434ee:         clientAdmin.disconnect();
1:ab434ee:         clientAdmin.close();
1:aa743cb:     }
1:aa743cb: 
1:a0a23b9:     @Test(timeout = 300000)
1:a0a23b9:     public void testActiveMQWildCards1() throws Exception {
1:a0a23b9:         final DefaultListener listener = new DefaultListener();
1:a0a23b9:         MqttClient client = createClient(false, "receive", listener);
1:a0a23b9:         final String ACCOUNT_PREFIX = "test/";
1:a0a23b9:         client.subscribe(ACCOUNT_PREFIX+"a/#");
1:a0a23b9:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:a0a23b9:         String expectedResult = "should get this 1";
1:a0a23b9:         String topic = ACCOUNT_PREFIX+"a/b/1.2.3*4>";
1:a0a23b9:         client.publish(topic, expectedResult.getBytes(), 0, false);
1:a0a23b9:         AbstractMap.SimpleEntry<String,String> entry = listener.messageQ.poll(20, TimeUnit.SECONDS);
1:a0a23b9:         assertEquals(topic, entry.getKey());
1:a0a23b9:         assertEquals(expectedResult, entry.getValue());
1:a0a23b9:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:a0a23b9:     }
1:a0a23b9: 
1:28b4534:     protected MqttClient createClient(boolean cleanSession, String clientId, MqttCallback listener) throws Exception {
1:28b4534:         MqttConnectOptions options = new MqttConnectOptions();
1:28b4534:         options.setCleanSession(cleanSession);
1:aa743cb:         return createClient(options, clientId, listener);
1:aa743cb:     }
1:aa743cb: 
1:aa743cb:     protected MqttClient createClient(MqttConnectOptions options, String clientId, MqttCallback listener) throws Exception {
1:28b4534:         final MqttClient client = new MqttClient("tcp://localhost:" + getPort(), clientId, new MemoryPersistence());
1:28b4534:         client.setCallback(listener);
1:28b4534:         client.connect(options);
1:4f57744:         Wait.waitFor(new Wait.Condition() {
1:4f57744:             @Override
1:aa743cb:             public boolean isSatisified() throws Exception {
1:28b4534:                 return client.isConnected();
1:4f57744:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100));
1:28b4534:         return client;
1:05c3112:     }
1:05c3112: 
1:28b4534:     protected void disconnect(final MqttClient client) throws Exception {
1:28b4534:         client.disconnect();
1:28b4534:         client.close();
1:4f57744:         Wait.waitFor(new Wait.Condition() {
1:05c3112:             @Override
1:4f57744:             public boolean isSatisified() throws Exception {
1:28b4534:                 return !client.isConnected();
1:05c3112:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100));
1:05c3112:     }
1:05c3112: 
1:28b4534:     protected void waitForDelivery(final MqttClient client) throws Exception {
7:05c3112:         Wait.waitFor(new Wait.Condition() {
1:05c3112:             @Override
1:4f57744:             public boolean isSatisified() throws Exception {
1:28b4534:                 return client.getPendingDeliveryTokens().length == 0;
1:05c3112:             }
1:ab434ee:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100));
1:4f57744:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:05c3112:     }
1:05c3112: 
1:28b4534:     static class DefaultListener implements MqttCallback {
1:28b4534: 
1:ab434ee:         final AtomicInteger received = new AtomicInteger();
1:a0a23b9:         final BlockingQueue<AbstractMap.SimpleEntry<String, String>> messageQ = new ArrayBlockingQueue<AbstractMap.SimpleEntry<String, String>>(10);
1:28b4534: 
1:05c3112:         @Override
1:28b4534:         public void connectionLost(Throwable cause) {
1:28b4534:         }
1:28b4534: 
1:05c3112:         @Override
1:28b4534:         public void messageArrived(String topic, MqttMessage message) throws Exception {
1:ab434ee:             LOG.info("Received: {}", message);
1:ab434ee:             received.incrementAndGet();
1:a0a23b9:             messageQ.put(new AbstractMap.SimpleEntry(topic, new String(message.getPayload(), StandardCharsets.UTF_8)));
1:28b4534:         }
1:28b4534: 
1:05c3112:         @Override
1:28b4534:         public void deliveryComplete(IMqttDeliveryToken token) {
1:28b4534:         }
1:28b4534:     }
1:28b4534: }
============================================================================
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:a0a23b9
/////////////////////////////////////////////////////////////////////////
1: import java.util.AbstractMap;
/////////////////////////////////////////////////////////////////////////
1:         String result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
/////////////////////////////////////////////////////////////////////////
1:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
/////////////////////////////////////////////////////////////////////////
1:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
/////////////////////////////////////////////////////////////////////////
1:         String result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
/////////////////////////////////////////////////////////////////////////
1:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
1:         result = listener.messageQ.poll(20, TimeUnit.SECONDS).getValue();
/////////////////////////////////////////////////////////////////////////
1:         assertNull(listener.messageQ.poll(3, TimeUnit.SECONDS));
1:         assertNull(listener.messageQ.poll(3, TimeUnit.SECONDS));
/////////////////////////////////////////////////////////////////////////
1:         String result = client1MqttCallback.messageQ.poll(10, TimeUnit.SECONDS).getValue();
1:         result = clientAdminMqttCallback.messageQ.poll(10, TimeUnit.SECONDS).getValue();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 300000)
1:     public void testActiveMQWildCards1() throws Exception {
1:         final DefaultListener listener = new DefaultListener();
1:         MqttClient client = createClient(false, "receive", listener);
1:         final String ACCOUNT_PREFIX = "test/";
1:         client.subscribe(ACCOUNT_PREFIX+"a/#");
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:         String expectedResult = "should get this 1";
1:         String topic = ACCOUNT_PREFIX+"a/b/1.2.3*4>";
1:         client.publish(topic, expectedResult.getBytes(), 0, false);
1:         AbstractMap.SimpleEntry<String,String> entry = listener.messageQ.poll(20, TimeUnit.SECONDS);
1:         assertEquals(topic, entry.getKey());
1:         assertEquals(expectedResult, entry.getValue());
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         final BlockingQueue<AbstractMap.SimpleEntry<String, String>> messageQ = new ArrayBlockingQueue<AbstractMap.SimpleEntry<String, String>>(10);
/////////////////////////////////////////////////////////////////////////
1:             messageQ.put(new AbstractMap.SimpleEntry(topic, new String(message.getPayload(), StandardCharsets.UTF_8)));
commit:aa743cb
/////////////////////////////////////////////////////////////////////////
1:     protected MessageConsumer createConsumer(Session s, String topic) throws Exception {
1:         return s.createConsumer(s.createTopic(topic));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer = createConsumer(s, "test");
/////////////////////////////////////////////////////////////////////////
1:         MessageConsumer consumer = createConsumer(s, "test");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         }, TimeUnit.SECONDS.toMillis(5)));
/////////////////////////////////////////////////////////////////////////
0:         }, TimeUnit.SECONDS.toMillis(5)));
/////////////////////////////////////////////////////////////////////////
1:     public void testClientIdSpecialChars() throws Exception {
1:         testClientIdSpecialChars(MqttConnectOptions.MQTT_VERSION_3_1);
1:         testClientIdSpecialChars(MqttConnectOptions.MQTT_VERSION_3_1_1);
1:     }
1:     protected void testClientId(String clientId, int mqttVersion, final DefaultListener clientAdminMqttCallback) throws Exception {
1:         options1.setUserName("client1");
1:         options1.setPassword("client1".toCharArray());
1:         options1.setMqttVersion(mqttVersion);
1:         final DefaultListener client1MqttCallback = new DefaultListener();
1:         MqttClient client1 = createClient(options1, clientId, client1MqttCallback);
1:         client1.setCallback(client1MqttCallback);
1:         String topic = "client1/" + clientId + "/topic";
1:         client1.subscribe(topic, 1);
1:         String message = "Message from client: " + clientId;
0:         client1.publish(topic, message.getBytes(), 1, false);
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return client1MqttCallback.result != null;
1:             }
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200)));
0:         assertEquals(message, client1MqttCallback.result);
0:         assertEquals(1, client1MqttCallback.received);
1: 
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return clientAdminMqttCallback.result != null;
1:             }
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200)));
0:         assertEquals(message, clientAdminMqttCallback.result);
1: 
1:         assertTrue(client1.isConnected());
1:         client1.disconnect();
1:     protected void testClientIdSpecialChars(int mqttVersion) throws Exception {
1: 
1:         LOG.info("Test MQTT version {}", mqttVersion);
1:         MqttConnectOptions optionsAdmin = new MqttConnectOptions();
1:         optionsAdmin.setCleanSession(false);
1:         optionsAdmin.setUserName("admin");
1:         optionsAdmin.setPassword("admin".toCharArray());
1: 
1:         DefaultListener clientAdminMqttCallback = new DefaultListener();
1:         MqttClient clientAdmin = createClient(optionsAdmin, "admin", clientAdminMqttCallback);
1:         clientAdmin.subscribe("#", 1);
1: 
1:         testClientId(":%&&@.:llll", mqttVersion, clientAdminMqttCallback);
1:         testClientId("Consumer:id:AT_LEAST_ONCE", mqttVersion, clientAdminMqttCallback);
1:         testClientId("Consumer:qid:EXACTLY_ONCE:VirtualTopic", mqttVersion, clientAdminMqttCallback);
1:         testClientId("Consumertestmin:testst:AT_LEAST_ONCE.VirtualTopic::AT_LEAST_ONCE", mqttVersion, clientAdminMqttCallback);
1:     }
1: 
1: 
1:         return createClient(options, clientId, listener);
1:     }
1: 
1:     protected MqttClient createClient(MqttConnectOptions options, String clientId, MqttCallback listener) throws Exception {
commit:4a8fec4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.command.ActiveMQQueue;
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 300000)
0:     public void testVirtualTopicQueueRestore() throws Exception {
1: 
0:         stopBroker();
0:         protocolConfig = "transport.subscriptionStrategy=mqtt-virtual-topic-subscriptions";
0:         startBroker();
1: 
0:         String user10 = "user10";
0:         String password10 = "user10";
0:         String clientId10 = "client-10";
0:         String topic10 = "user10/";
0:         MqttConnectOptions options10 = new MqttConnectOptions();
0:         options10.setCleanSession(false);
0:         options10.setUserName(user10);
0:         options10.setPassword(password10.toCharArray());
0:         MqttClient client10 = createClient(false, clientId10, null);
0:         client10.subscribe(topic10 + clientId10 + "/#", 1);
0:         client10.subscribe(topic10 + "#", 1);
1: 
0:         String user1 = "user1";
0:         String password1 = "user1";
0:         String clientId1 = "client-1";
0:         String topic1 = "user1/";
1:         MqttConnectOptions options1 = new MqttConnectOptions();
1:         options1.setCleanSession(false);
0:         options1.setUserName(user1);
0:         options1.setPassword(password1.toCharArray());
1: 
0:         MqttClient client1 = createClient(false, clientId1, null);
0:         client1.subscribe(topic1 + clientId1 + "/#", 1);
0:         client1.subscribe(topic1 + "#", 1);
1: 
0:         RegionBroker regionBroker = (RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class);
1: 
0:         String[] queues = new String[]{"Consumer.client-10:AT_LEAST_ONCE.VirtualTopic.user10.>",
0:                 "Consumer.client-10:AT_LEAST_ONCE.VirtualTopic.user10.client-10.>",
0:                 "Consumer.client-1:AT_LEAST_ONCE.VirtualTopic.user1.>",
0:                 "Consumer.client-1:AT_LEAST_ONCE.VirtualTopic.user1.client-1.>"};
1: 
0:         for (String queueName : queues) {
0:             Destination queue = regionBroker.getQueueRegion().getDestinations(new ActiveMQQueue(queueName)).iterator().next();
0:             assertEquals("Queue " + queueName + " have more than one consumer", 1, queue.getConsumers().size());
1:         }
1:     }
1: 
commit:4f57744
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.util.Wait;
0: import org.eclipse.paho.client.mqttv3.*;
1: import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.atomic.AtomicReference;
0: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200));
1: 
1: 
1:         expectedResult = "should get everything";
0:         listener.result = null;
0:         client.publish(ACCOUNT_PREFIX + "a/1/2", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200));
0:         assertEquals(expectedResult, listener.result);
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:         client.unsubscribe(ACCOUNT_PREFIX + "a/+/#");
1:         client.unsubscribe(ACCOUNT_PREFIX + "#");
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:         expectedResult = "should still get 1/2/3";
0:         listener.result = null;
0:         client.publish(ACCOUNT_PREFIX + "1/2/3", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200));
0:         assertEquals(expectedResult, listener.result);
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
commit:05c3112
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.util.Wait;
0: import org.eclipse.paho.client.mqttv3.*;
0: import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
0: import org.junit.Test;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicInteger;
0: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public void testSubs() throws Exception {
1: 
0:         stopBroker();
0:         protocolConfig = "transport.subscriptionStrategy=mqtt-virtual-topic-subscriptions";
0:         startBroker();
1: 
1:         final DefaultListener listener = new DefaultListener();
1:         // subscriber connects and creates durable sub
1:         MqttClient client = createClient(false, "receive", listener);
1: 
0:         final String ACCOUNT_PREFIX     = "test/";
1: 
1: 
0:        client.subscribe(ACCOUNT_PREFIX+"1/2/3");
0:        client.subscribe(ACCOUNT_PREFIX+"a/+/#");
0:        client.subscribe(ACCOUNT_PREFIX+"#");
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        String expectedResult = "should get everything";
0:        client.publish(ACCOUNT_PREFIX+"1/2/3/4", expectedResult.getBytes(), 0, false);
1: 
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
1:         });
1: 
1:        assertTrue(client.getPendingDeliveryTokens().length == 0);
0:        assertEquals(expectedResult, listener.result);
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testOverlappingTopics() throws Exception {
1: 
0:         stopBroker();
0:         protocolConfig = "transport.subscriptionStrategy=mqtt-virtual-topic-subscriptions";
0:         startBroker();
1: 
1:         final DefaultListener listener = new DefaultListener();
1:         // subscriber connects and creates durable sub
1:         MqttClient client = createClient(false, "receive", listener);
1: 
0:         final String ACCOUNT_PREFIX     = "test/";
1: 
1:        // *****************************************
1:        // check a simple # subscribe works
1:        // *****************************************
0:        client.subscribe(ACCOUNT_PREFIX+"#");
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:        String expectedResult = "hello mqtt broker on hash";
0:        client.publish(ACCOUNT_PREFIX+"a/b/c", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
1:         });
0:        assertEquals(expectedResult, listener.result);
1:        assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        expectedResult = "hello mqtt broker on a different topic";
0:        listener.result = null;
0:        client.publish(ACCOUNT_PREFIX+"1/2/3/4/5/6", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
1:         });
0:        assertEquals(expectedResult, listener.result);
1:        assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        // *****************************************
0:        // now subscribe on a topic that overlaps the root # wildcard - we should still get everything
1:        // *****************************************
0:        client.subscribe(ACCOUNT_PREFIX+"1/2/3");
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        expectedResult = "hello mqtt broker on explicit topic";
0:        listener.result = null;
0:        client.publish(ACCOUNT_PREFIX+"1/2/3", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
1:         });
0:        assertEquals(expectedResult, listener.result);
1:        assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        expectedResult = "hello mqtt broker on some other topic";
0:        listener.result = null;
0:        client.publish(ACCOUNT_PREFIX+"a/b/c/d/e", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
1:         });
0:        assertEquals(expectedResult, listener.result);
1:        assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        // *****************************************
1:        // now unsub hash - we should only get called back on 1/2/3
1:        // *****************************************
0:        client.unsubscribe(ACCOUNT_PREFIX+"#");
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        expectedResult = "this should not come back...";
0:         listener.result = null;
0:        client.publish(ACCOUNT_PREFIX+"1/2/3/4", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
1:         });
0:        assertNull(listener.result);
1:        assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
1:        expectedResult = "this should not come back either...";
0:         listener.result = null;
0:        client.publish(ACCOUNT_PREFIX+"a/b/c", expectedResult.getBytes(), 0, false);
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
1:             }
1:         });
0:        assertNull(listener.result);
1:        assertTrue(client.getPendingDeliveryTokens().length == 0);
1:     }
1: 
0:     @Test(timeout = 300000)
/////////////////////////////////////////////////////////////////////////
0:         String result;
/////////////////////////////////////////////////////////////////////////
0:             result = new String(message.getPayload());
commit:28b4534
/////////////////////////////////////////////////////////////////////////
0: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.Wait;
0: import org.eclipse.paho.client.mqttv3.*;
0: import org.eclipse.paho.client.mqttv3.persist.MqttDefaultFilePersistence;
0: import org.junit.Before;
0: import static org.junit.Assert.*;
1: 
0:     @Override
0:     @Before
0:     public void setUp() throws Exception {
0:         protocolConfig = "transport.activeMQSubscriptionPrefetch=32766";
0:         super.setUp();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Test(timeout = 300000)
1:     public void testCleanSession() throws Exception {
1:         String topic = "test";
1:         final DefaultListener listener = new DefaultListener();
1: 
1:         // subscriber connects and creates durable sub
1:         LOG.info("Connecting durable subscriber...");
1:         MqttClient client = createClient(false, "receive", listener);
1:         // subscribe and wait for the retain message to arrive
1:         LOG.info("Subscribing durable subscriber...");
1:         client.subscribe(topic, 1);
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:         disconnect(client);
1:         LOG.info("Disconnected durable subscriber.");
1: 
1:         // Publish message with QoS 1
1:         MqttClient client2 = createClient(true, "publish", listener);
1: 
1:         LOG.info("Publish message with QoS 1...");
1:         String expectedResult = "QOS 1 message";
0:         client2.publish(topic, expectedResult.getBytes(), 1, false);
1:         waitForDelivery(client2);
1: 
1:         // Publish message with QoS 0
1:         LOG.info("Publish message with QoS 0...");
1:         expectedResult = "QOS 0 message";
0:         client2.publish(topic, expectedResult.getBytes(), 0, false);
1:         waitForDelivery(client2);
1: 
1:         // subscriber reconnects
1:         LOG.info("Reconnecting durable subscriber...");
1:         MqttClient client3 = createClient(false, "receive", listener);
1: 
1:         LOG.info("Subscribing durable subscriber...");
1:         client3.subscribe(topic, 1);
1: 
0:         Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.received == 2;
1:             }
0:         });
0:         assertEquals(2, listener.received);
1:         disconnect(client3);
1:         LOG.info("Disconnected durable subscriber.");
1: 
1:         // make sure we consumed everything
0:         listener.received = 0;
1: 
1:         LOG.info("Reconnecting durable subscriber...");
1:         MqttClient client4 = createClient(false, "receive", listener);
1: 
1:         LOG.info("Subscribing durable subscriber...");
1:         client4.subscribe(topic, 1);
0:         Thread.sleep(3 * 1000);
0:         assertEquals(0, listener.received);
1:     }
1: 
1:     protected MqttClient createClient(boolean cleanSession, String clientId, MqttCallback listener) throws Exception {
1:         MqttConnectOptions options = new MqttConnectOptions();
1:         options.setCleanSession(cleanSession);
1:         final MqttClient client = new MqttClient("tcp://localhost:" + getPort(), clientId, new MemoryPersistence());
1:         client.setCallback(listener);
1:         client.connect(options);
0:         Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
1:                 return client.isConnected();
1:             }
0:         });
1:         return client;
1:     }
1: 
1:     protected void disconnect(final MqttClient client) throws Exception {
1:         client.disconnect();
1:         client.close();
0:         Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
1:                 return !client.isConnected();
1:             }
0:         });
1:     }
1: 
1:     protected void waitForDelivery(final MqttClient client) throws Exception {
0:         Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
1:                 return client.getPendingDeliveryTokens().length == 0;
1:             }
0:         });
1:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1:     }
1: 
1:     static class DefaultListener implements MqttCallback {
1: 
0:         int received = 0;
1: 
0:         @Override
1:         public void connectionLost(Throwable cause) {
1: 
1:         }
1: 
0:         @Override
1:         public void messageArrived(String topic, MqttMessage message) throws Exception {
0:             LOG.info("Received: " + message);
0:             received++;
1:         }
1: 
0:         @Override
1:         public void deliveryComplete(IMqttDeliveryToken token) {
1: 
1:         }
1:     }
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:d9c4048
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         String result = listener.messageQ.poll(20, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:         result = listener.messageQ.poll(20, TimeUnit.SECONDS);
0:         result = listener.messageQ.poll(20, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:         result = listener.messageQ.poll(20, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         String result = listener.messageQ.poll(20, TimeUnit.SECONDS);
0:         result = listener.messageQ.poll(20, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:         result = listener.messageQ.poll(20, TimeUnit.SECONDS);
0:         result = listener.messageQ.poll(20, TimeUnit.SECONDS);
0:         result = listener.messageQ.poll(20, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:         String result = client1MqttCallback.messageQ.poll(10, TimeUnit.SECONDS);
0:         result = clientAdminMqttCallback.messageQ.poll(10, TimeUnit.SECONDS);
commit:ab434ee
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.StandardCharsets;
1: import java.util.concurrent.ArrayBlockingQueue;
1: import java.util.concurrent.BlockingQueue;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 90000)
/////////////////////////////////////////////////////////////////////////
1:                             client.publish("test", "hello".getBytes(StandardCharsets.UTF_8), 1, false);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 90000)
/////////////////////////////////////////////////////////////////////////
1:         client.publish("test", "hello".getBytes(StandardCharsets.UTF_8), 1, false);
1:         client.close();
1:     @Test(timeout = 90000)
/////////////////////////////////////////////////////////////////////////
1:         client.publish(ACCOUNT_PREFIX + "1/2/3/4", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1:         // One delivery for topic  ACCOUNT_PREFIX + "#"
0:         String result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
1:         client.publish(ACCOUNT_PREFIX + "a/1/2", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1: 
1:         // One delivery for topic  ACCOUNT_PREFIX + "a/1/2"
0:         result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
1:         // One delivery for topic  ACCOUNT_PREFIX + "#"
0:         result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
/////////////////////////////////////////////////////////////////////////
1:         client.publish(ACCOUNT_PREFIX + "1/2/3", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1: 
1:         // One delivery for topic  ACCOUNT_PREFIX + "1/2/3"
0:         result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
1: 
1:         client.disconnect();
1:         client.close();
0:     @Ignore
0:     public void testOverlappingTopicsLooped() throws Exception {
0:         for (int i = 0; i < 100; ++i) {
0:             LOG.info("Running test iteration: {}", i);
0:             testOverlappingTopics();
0:         }
0:     }
1: 
1:     @Test(timeout = 90000)
/////////////////////////////////////////////////////////////////////////
1:         client.publish(ACCOUNT_PREFIX + "a/b/c", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1: 
0:         String result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
1:         client.publish(ACCOUNT_PREFIX + "1/2/3/4/5/6", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
0:         result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
/////////////////////////////////////////////////////////////////////////
1:         client.publish(ACCOUNT_PREFIX + "1/2/3", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
1: 
1:         // One message from topic subscription on ACCOUNT_PREFIX + "#"
0:         result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
1: 
1:         // One message from topic subscription on ACCOUNT_PREFIX + "1/2/3"
0:         result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
1: 
1:         client.publish(ACCOUNT_PREFIX + "a/b/c/d/e", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
0:         result = listener.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(expectedResult, result);
/////////////////////////////////////////////////////////////////////////
1:         client.publish(ACCOUNT_PREFIX + "1/2/3/4", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
0:         result = listener.messageQ.poll(3, TimeUnit.SECONDS);
0:         assertNull(result);
1:         client.publish(ACCOUNT_PREFIX + "a/b/c", expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
0:         result = listener.messageQ.poll(3, TimeUnit.SECONDS);
0:         assertNull(result);
1: 
1:         client.disconnect();
1:         client.close();
1:     @Test(timeout = 90000)
/////////////////////////////////////////////////////////////////////////
1:         client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 1, false);
1:         client2.publish(topic, expectedResult.getBytes(StandardCharsets.UTF_8), 0, false);
/////////////////////////////////////////////////////////////////////////
1:                 return listener.received.get() == 2;
1:         assertEquals(2, listener.received.get());
1:         assertTrue(listener.received.compareAndSet(2, 0));
1:         TimeUnit.SECONDS.sleep(3);
1:         assertEquals(0, listener.received.get());
1: 
1:         client2.disconnect();
1:         client2.close();
1:         client4.disconnect();
1:         client4.close();
1:     @Test(timeout = 90000)
/////////////////////////////////////////////////////////////////////////
1:         client1.publish(topic, message.getBytes(StandardCharsets.UTF_8), 1, false);
0:         String result = client1MqttCallback.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(message, result);
1:         assertEquals(1, client1MqttCallback.received.get());
0:         result = clientAdminMqttCallback.messageQ.poll(45, TimeUnit.MILLISECONDS);
1:         assertEquals(message, result);
1:         client1.close();
/////////////////////////////////////////////////////////////////////////
1:         clientAdmin.disconnect();
1:         clientAdmin.close();
0:     }
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100));
1:         final AtomicInteger received = new AtomicInteger();
0:         final BlockingQueue<String> messageQ = new ArrayBlockingQueue<String>(10);
1:             LOG.info("Received: {}", message);
1:             received.incrementAndGet();
0:             messageQ.put(new String(message.getPayload(), StandardCharsets.UTF_8));
commit:91d277c
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.Session;
1: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.util.Wait;
1: import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
1: import org.eclipse.paho.client.mqttv3.MqttCallback;
1: import org.eclipse.paho.client.mqttv3.MqttClient;
1: import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
1: import org.eclipse.paho.client.mqttv3.MqttMessage;
0: import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
0: import org.junit.Test;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:         volatile String result;
commit:101b712
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
0: import javax.jms.Session;
1: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.util.Wait;
0: import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
0: import org.eclipse.paho.client.mqttv3.MqttCallback;
0: import org.eclipse.paho.client.mqttv3.MqttClient;
0: import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
0: import org.eclipse.paho.client.mqttv3.MqttMessage;
0: import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
0: import org.junit.Test;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:                         MqttClient client = new MqttClient("tcp://localhost:" + getPort(), Thread.currentThread().getName(), new MemoryPersistence());
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 300000)
/////////////////////////////////////////////////////////////////////////
0:     public void testSubs() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         final String ACCOUNT_PREFIX = "test/";
1:         client.subscribe(ACCOUNT_PREFIX + "1/2/3");
1:         client.subscribe(ACCOUNT_PREFIX + "a/+/#");
1:         client.subscribe(ACCOUNT_PREFIX + "#");
0:         String expectedResult = "should get everything";
0:         client.publish(ACCOUNT_PREFIX + "1/2/3/4", expectedResult.getBytes(), 0, false);
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
0:         assertEquals(expectedResult, listener.result);
0:     @Test(timeout = 300000)
/////////////////////////////////////////////////////////////////////////
1:         final String ACCOUNT_PREFIX = "test/";
0:         // *****************************************
0:         // check a simple # subscribe works
0:         // *****************************************
1:         client.subscribe(ACCOUNT_PREFIX + "#");
0:         String expectedResult = "hello mqtt broker on hash";
0:         client.publish(ACCOUNT_PREFIX + "a/b/c", expectedResult.getBytes(), 0, false);
0:         assertTrue(Wait.waitFor(new Wait.Condition() {
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200)));
0:         assertEquals(expectedResult, listener.result);
0:         expectedResult = "hello mqtt broker on a different topic";
0:         client.publish(ACCOUNT_PREFIX + "1/2/3/4/5/6", expectedResult.getBytes(), 0, false);
0:         assertTrue(Wait.waitFor(new Wait.Condition() {
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200)));
0:         assertEquals(expectedResult, listener.result);
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
0:         // *****************************************
1:         // now subscribe on a topic that overlaps the root # wildcard - we
1:         // should still get everything
0:         // *****************************************
1:         client.subscribe(ACCOUNT_PREFIX + "1/2/3");
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
0:         expectedResult = "hello mqtt broker on explicit topic";
0:         client.publish(ACCOUNT_PREFIX + "1/2/3", expectedResult.getBytes(), 0, false);
0:         assertTrue(Wait.waitFor(new Wait.Condition() {
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200)));
0:         assertEquals(expectedResult, listener.result);
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
0:         expectedResult = "hello mqtt broker on some other topic";
0:         listener.result = null;
0:         client.publish(ACCOUNT_PREFIX + "a/b/c/d/e", expectedResult.getBytes(), 0, false);
0:         assertTrue(Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
0:             }
0:         }, TimeUnit.SECONDS.toMillis(45), TimeUnit.MILLISECONDS.toMillis(200)));
0:         assertEquals(expectedResult, listener.result);
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
0:         // *****************************************
0:         // now unsub hash - we should only get called back on 1/2/3
0:         // *****************************************
1:         client.unsubscribe(ACCOUNT_PREFIX + "#");
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
0:         expectedResult = "this should not come back...";
0:         listener.result = null;
0:         client.publish(ACCOUNT_PREFIX + "1/2/3/4", expectedResult.getBytes(), 0, false);
0:         assertFalse(Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
0:             }
0:         }, TimeUnit.SECONDS.toMillis(20)));
0:         assertNull(listener.result);
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
1: 
0:         expectedResult = "this should not come back either...";
0:         listener.result = null;
0:         client.publish(ACCOUNT_PREFIX + "a/b/c", expectedResult.getBytes(), 0, false);
0:         assertFalse(Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return listener.result != null;
0:             }
0:         }, TimeUnit.SECONDS.toMillis(20)));
0:         assertNull(listener.result);
0:         assertTrue(client.getPendingDeliveryTokens().length == 0);
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100)));
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100));
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(15), TimeUnit.MILLISECONDS.toMillis(100));
/////////////////////////////////////////////////////////////////////////
0:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(200));
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Received: " + message);
/////////////////////////////////////////////////////////////////////////
commit:829a186
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:fb569e3
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: 
0: import java.util.Arrays;
0: import java.util.Collection;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicInteger;
0: import java.util.concurrent.atomic.AtomicReference;
0: 
0: import javax.jms.MessageListener;
0: import org.junit.runner.RunWith;
0: import org.junit.runners.Parameterized;
0: import org.junit.runners.Parameterized.Parameters;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: @RunWith(Parameterized.class)
1: public class PahoMQTTTest extends MQTTTestSupport {
1:     private static final Logger LOG = LoggerFactory.getLogger(PahoMQTTTest.class);
0:     @Parameters(name= "{index}: scheme({0})")
0:     public static Collection<Object[]> data() {
0:         return Arrays.asList(new Object[][] {
0:                 {"mqtt", false},
0:                 {"mqtt+nio", false}
0:             });
0:     }
0: 
0:     @Test(timeout = 300000)
1:     public void testLotsOfClients() throws Exception {
0: 
1:         final int CLIENTS = Integer.getInteger("PahoMQTTTest.CLIENTS", 100);
1:         LOG.info("Using: {} clients", CLIENTS);
0: 
1:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
1:         final AtomicInteger receiveCounter = new AtomicInteger();
1:         consumer.setMessageListener(new MessageListener() {
0:             @Override
1:             public void onMessage(Message message) {
1:                 receiveCounter.incrementAndGet();
0:             }
0:         });
0: 
1:         final AtomicReference<Throwable> asyncError = new AtomicReference<Throwable>();
1:         final CountDownLatch connectedDoneLatch = new CountDownLatch(CLIENTS);
1:         final CountDownLatch disconnectDoneLatch = new CountDownLatch(CLIENTS);
1:         final CountDownLatch sendBarrier = new CountDownLatch(1);
1:         for (int i = 0; i < CLIENTS; i++) {
1:             Thread.sleep(10);
1:             new Thread(null, null, "client:" + i) {
0:                 @Override
1:                 public void run() {
1:                     try {
0:                         MqttClient client = new MqttClient("tcp://localhost:" + getPort(),
0:                                                            Thread.currentThread().getName(),
0:                                                            new MemoryPersistence());
1:                         client.connect();
1:                         connectedDoneLatch.countDown();
1:                         sendBarrier.await();
1:                         for (int i = 0; i < 10; i++) {
1:                             Thread.sleep(1000);
0:                             client.publish("test", "hello".getBytes(), 1, false);
0:                         }
1:                         client.disconnect();
1:                         client.close();
1:                     } catch (Throwable e) {
1:                         e.printStackTrace();
1:                         asyncError.set(e);
1:                     } finally {
1:                         disconnectDoneLatch.countDown();
0:                     }
0:                 }
1:             }.start();
0:         }
0: 
1:         connectedDoneLatch.await();
1:         assertNull("Async error: " + asyncError.get(), asyncError.get());
1:         sendBarrier.countDown();
0: 
1:         LOG.info("All clients connected... waiting to receive sent messages...");
0: 
1:         // We should eventually get all the messages.
1:         within(30, TimeUnit.SECONDS, new Task() {
0:             @Override
1:             public void run() throws Exception {
1:                 assertTrue(receiveCounter.get() == CLIENTS * 10);
0:             }
0:         });
0: 
1:         LOG.info("All messages received.");
0: 
1:         disconnectDoneLatch.await();
1:         assertNull("Async error: " + asyncError.get(), asyncError.get());
0:     }
0: 
0:     @Test(timeout=300000)
1:     public void testSendAndReceiveMQTT() throws Exception {
0: 
1:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
1:         activeMQConnection.start();
1:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = s.createConsumer(s.createTopic("test"));
0: 
1:         MqttClient client = new MqttClient("tcp://localhost:" + getPort(), "clientid", new MemoryPersistence());
commit:93f686c
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.Session;
0: 
/////////////////////////////////////////////////////////////////////////
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:61fadba
/////////////////////////////////////////////////////////////////////////
0: import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
/////////////////////////////////////////////////////////////////////////
0:         MqttClient client = new MqttClient("tcp://localhost:" + mqttConnector.getConnectUri().getPort(), "clientid", new MemoryPersistence());
commit:bc9751a
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.mqtt;
0: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.TransportConnector;
0: import org.eclipse.paho.client.mqttv3.MqttClient;
0: import org.junit.Test;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: import javax.jms.Message;
0: import javax.jms.MessageConsumer;
0: import javax.jms.Session;
0: 
0: public class PahoMQTTTest extends AbstractMQTTTest {
0: 
0:     private static final Logger LOG = LoggerFactory.getLogger(PahoMQTTTest.class);
0: 
0: 
0:     @Test(timeout=300000)
0:     public void testSendAndReceiveMQTT() throws Exception {
0:         addMQTTConnector();
0:         TransportConnector openwireTransport = brokerService.addConnector("tcp://localhost:0");
0:         brokerService.start();
0: 
0:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory(openwireTransport.getConnectUri()).createConnection();
1:         activeMQConnection.start();
1:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = s.createConsumer(s.createTopic("test"));
0: 
0:         MqttClient client = new MqttClient("tcp://localhost:" + mqttConnector.getConnectUri().getPort(), "clientid");
1:         client.connect();
0:         client.publish("test", "hello".getBytes(), 1, false);
0: 
1:         Message msg = consumer.receive(100 * 5);
1:         assertNotNull(msg);
0: 
1:         client.disconnect();
0:         client.close();
0:     }
0: 
0: 
0: }
============================================================================