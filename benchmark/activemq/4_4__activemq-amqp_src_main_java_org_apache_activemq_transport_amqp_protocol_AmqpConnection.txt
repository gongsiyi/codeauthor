1:10fc397: /*
1:3306467:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3306467:  * contributor license agreements.  See the NOTICE file distributed with
1:3306467:  * this work for additional information regarding copyright ownership.
1:3306467:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3306467:  * (the "License"); you may not use this file except in compliance with
1:3306467:  * the License.  You may obtain a copy of the License at
1:3306467:  *
1:3306467:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3306467:  *
1:3306467:  * Unless required by applicable law or agreed to in writing, software
1:3306467:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3306467:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3306467:  * See the License for the specific language governing permissions and
1:3306467:  * limitations under the License.
1:3306467:  */
1:3306467: package org.apache.activemq.transport.amqp.protocol;
10:3306467: 
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.ANONYMOUS_RELAY;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.CONNECTION_OPEN_FAILED;
1:138e52b: import static org.apache.activemq.transport.amqp.AmqpSupport.CONTAINER_ID;
1:4a1f2f7: import static org.apache.activemq.transport.amqp.AmqpSupport.DELAYED_DELIVERY;
1:138e52b: import static org.apache.activemq.transport.amqp.AmqpSupport.INVALID_FIELD;
1:c231039: import static org.apache.activemq.transport.amqp.AmqpSupport.PLATFORM;
1:c231039: import static org.apache.activemq.transport.amqp.AmqpSupport.PRODUCT;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.QUEUE_PREFIX;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.TEMP_QUEUE_CAPABILITY;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.TEMP_TOPIC_CAPABILITY;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.TOPIC_PREFIX;
1:c231039: import static org.apache.activemq.transport.amqp.AmqpSupport.VERSION;
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.contains;
1:3306467: 
1:c231039: import java.io.BufferedReader;
1:3306467: import java.io.IOException;
1:c231039: import java.io.InputStream;
1:c231039: import java.io.InputStreamReader;
1:3306467: import java.nio.ByteBuffer;
1:3306467: import java.util.HashMap;
1:3306467: import java.util.Map;
1:3306467: import java.util.concurrent.ConcurrentHashMap;
1:3306467: import java.util.concurrent.ConcurrentMap;
1:037f91d: import java.util.concurrent.TimeUnit;
1:3306467: import java.util.concurrent.atomic.AtomicInteger;
1:3306467: 
1:3306467: import javax.jms.InvalidClientIDException;
1:3306467: 
1:3306467: import org.apache.activemq.broker.BrokerService;
1:88daeec: import org.apache.activemq.broker.region.AbstractRegion;
1:3306467: import org.apache.activemq.broker.region.DurableTopicSubscription;
1:3306467: import org.apache.activemq.broker.region.RegionBroker;
1:88daeec: import org.apache.activemq.broker.region.Subscription;
1:3306467: import org.apache.activemq.broker.region.TopicRegion;
1:3306467: import org.apache.activemq.command.ActiveMQDestination;
1:3306467: import org.apache.activemq.command.ActiveMQTempDestination;
1:3306467: import org.apache.activemq.command.ActiveMQTempQueue;
1:3306467: import org.apache.activemq.command.ActiveMQTempTopic;
1:3306467: import org.apache.activemq.command.Command;
1:3306467: import org.apache.activemq.command.ConnectionError;
1:3306467: import org.apache.activemq.command.ConnectionId;
1:3306467: import org.apache.activemq.command.ConnectionInfo;
1:25c99a6: import org.apache.activemq.command.ConsumerControl;
1:3306467: import org.apache.activemq.command.ConsumerId;
1:b5c6264: import org.apache.activemq.command.ConsumerInfo;
1:3306467: import org.apache.activemq.command.DestinationInfo;
1:3306467: import org.apache.activemq.command.ExceptionResponse;
1:ed26683: import org.apache.activemq.command.LocalTransactionId;
1:3306467: import org.apache.activemq.command.MessageDispatch;
1:3306467: import org.apache.activemq.command.RemoveInfo;
1:3306467: import org.apache.activemq.command.Response;
1:3306467: import org.apache.activemq.command.SessionId;
1:3306467: import org.apache.activemq.command.ShutdownInfo;
1:ed26683: import org.apache.activemq.command.TransactionId;
1:4b4cf7c: import org.apache.activemq.transport.InactivityIOException;
1:3306467: import org.apache.activemq.transport.amqp.AmqpHeader;
1:3306467: import org.apache.activemq.transport.amqp.AmqpInactivityMonitor;
1:3306467: import org.apache.activemq.transport.amqp.AmqpProtocolConverter;
1:3306467: import org.apache.activemq.transport.amqp.AmqpProtocolException;
1:3306467: import org.apache.activemq.transport.amqp.AmqpTransport;
1:3306467: import org.apache.activemq.transport.amqp.AmqpTransportFilter;
1:3306467: import org.apache.activemq.transport.amqp.AmqpWireFormat;
1:3306467: import org.apache.activemq.transport.amqp.ResponseHandler;
1:e333fd9: import org.apache.activemq.transport.amqp.sasl.AmqpAuthenticator;
1:3306467: import org.apache.activemq.util.IOExceptionSupport;
1:3306467: import org.apache.activemq.util.IdGenerator;
1:3306467: import org.apache.qpid.proton.Proton;
1:3306467: import org.apache.qpid.proton.amqp.Symbol;
1:3306467: import org.apache.qpid.proton.amqp.transaction.Coordinator;
1:3306467: import org.apache.qpid.proton.amqp.transport.AmqpError;
1:3306467: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
1:3306467: import org.apache.qpid.proton.engine.Collector;
1:3306467: import org.apache.qpid.proton.engine.Connection;
1:3306467: import org.apache.qpid.proton.engine.Delivery;
1:4b4cf7c: import org.apache.qpid.proton.engine.EndpointState;
1:3306467: import org.apache.qpid.proton.engine.Event;
1:3306467: import org.apache.qpid.proton.engine.Link;
1:3306467: import org.apache.qpid.proton.engine.Receiver;
1:3306467: import org.apache.qpid.proton.engine.Sender;
1:3306467: import org.apache.qpid.proton.engine.Session;
1:3306467: import org.apache.qpid.proton.engine.Transport;
1:3306467: import org.apache.qpid.proton.engine.impl.CollectorImpl;
1:3306467: import org.apache.qpid.proton.engine.impl.ProtocolTracer;
1:3306467: import org.apache.qpid.proton.engine.impl.TransportImpl;
1:3306467: import org.apache.qpid.proton.framing.TransportFrame;
1:3306467: import org.fusesource.hawtbuf.Buffer;
1:3306467: import org.slf4j.Logger;
1:3306467: import org.slf4j.LoggerFactory;
1:3306467: 
2:3306467: /**
1:3306467:  * Implements the mechanics of managing a single remote peer connection.
1:3306467:  */
1:3306467: public class AmqpConnection implements AmqpProtocolConverter {
1:3306467: 
1:3306467:     private static final Logger TRACE_FRAMES = AmqpTransportFilter.TRACE_FRAMES;
1:3306467:     private static final Logger LOG = LoggerFactory.getLogger(AmqpConnection.class);
1:3306467:     private static final int CHANNEL_MAX = 32767;
1:c231039:     private static final String BROKER_VERSION;
1:c231039:     private static final String BROKER_PLATFORM;
1:c231039: 
1:c231039:     static {
1:c231039:         String javaVersion = System.getProperty("java.version");
1:c231039: 
1:c231039:         BROKER_PLATFORM = "Java/" + (javaVersion == null ? "unknown" : javaVersion);
1:c231039: 
1:c231039:         InputStream in = null;
1:1fd2450:         String version = "<unknown-5.x>";
1:c231039:         if ((in = AmqpConnection.class.getResourceAsStream("/org/apache/activemq/version.txt")) != null) {
1:c231039:             BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1:c231039:             try {
1:c231039:                 version = reader.readLine();
1:c231039:             } catch(Exception e) {
1:c231039:             }
1:c231039:         }
1:c231039:         BROKER_VERSION = version;
1:c231039:     }
1:3306467: 
1:3306467:     private final Transport protonTransport = Proton.transport();
1:3306467:     private final Connection protonConnection = Proton.connection();
1:3306467:     private final Collector eventCollector = new CollectorImpl();
1:3306467: 
1:3306467:     private final AmqpTransport amqpTransport;
1:3306467:     private final AmqpWireFormat amqpWireFormat;
1:3306467:     private final BrokerService brokerService;
1:3306467: 
1:3306467:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1:3306467:     private final AtomicInteger lastCommandId = new AtomicInteger();
1:3306467:     private final ConnectionId connectionId = new ConnectionId(CONNECTION_ID_GENERATOR.generateId());
1:3306467:     private final ConnectionInfo connectionInfo = new ConnectionInfo();
1:e333fd9:     private long nextSessionId;
1:e333fd9:     private long nextTempDestinationId;
1:ed26683:     private long nextTransactionId;
1:e333fd9:     private boolean closing;
1:e333fd9:     private boolean closedSocket;
1:e333fd9:     private AmqpAuthenticator authenticator;
1:3306467: 
1:1fd2450:     private final Map<TransactionId, AmqpTransactionCoordinator> transactions = new HashMap<>();
1:1fd2450:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<>();
1:1fd2450:     private final ConcurrentMap<ConsumerId, AmqpSender> subscriptionsByConsumerId = new ConcurrentHashMap<>();
1:3306467: 
1:3306467:     public AmqpConnection(AmqpTransport transport, BrokerService brokerService) {
1:3306467:         this.amqpTransport = transport;
1:e333fd9: 
1:3306467:         AmqpInactivityMonitor monitor = transport.getInactivityMonitor();
1:3306467:         if (monitor != null) {
1:4b4cf7c:             monitor.setAmqpTransport(amqpTransport);
18:3306467:         }
1:e333fd9: 
1:3306467:         this.amqpWireFormat = transport.getWireFormat();
1:3306467:         this.brokerService = brokerService;
1:3306467: 
1:3306467:         // the configured maxFrameSize on the URI.
1:3306467:         int maxFrameSize = amqpWireFormat.getMaxAmqpFrameSize();
1:3306467:         if (maxFrameSize > AmqpWireFormat.NO_AMQP_MAX_FRAME_SIZE) {
1:3306467:             this.protonTransport.setMaxFrameSize(maxFrameSize);
1:b29d2ea:             try {
1:b29d2ea:                 this.protonTransport.setOutboundFrameSizeLimit(maxFrameSize);
1:b29d2ea:             } catch (Throwable e) {
1:b29d2ea:                 // Ignore if older proton-j was injected.
1:b29d2ea:             }
1:3306467:         }
1:3306467: 
1:3306467:         this.protonTransport.bind(this.protonConnection);
1:3306467:         this.protonTransport.setChannelMax(CHANNEL_MAX);
1:8448cf1:         this.protonTransport.setEmitFlowEventOnSend(false);
1:3306467: 
1:3306467:         this.protonConnection.collect(eventCollector);
1:3306467: 
1:3306467:         updateTracer();
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * Load and return a <code>[]Symbol</code> that contains the connection capabilities
1:3306467:      * offered to new connections
1:3306467:      *
1:3306467:      * @return the capabilities that are offered to new clients on connect.
1:3306467:      */
1:3306467:     protected Symbol[] getConnectionCapabilitiesOffered() {
1:4a1f2f7:         return new Symbol[]{ ANONYMOUS_RELAY, DELAYED_DELIVERY };
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * Load and return a <code>Map<Symbol, Object></code> that contains the properties
1:3306467:      * that this connection supplies to incoming connections.
1:3306467:      *
1:3306467:      * @return the properties that are offered to the incoming connection.
1:3306467:      */
1:3306467:     protected Map<Symbol, Object> getConnetionProperties() {
1:1fd2450:         Map<Symbol, Object> properties = new HashMap<>();
1:3306467: 
1:3306467:         properties.put(QUEUE_PREFIX, "queue://");
1:3306467:         properties.put(TOPIC_PREFIX, "topic://");
1:c231039:         properties.put(PRODUCT, "ActiveMQ");
1:c231039:         properties.put(VERSION, BROKER_VERSION);
1:c231039:         properties.put(PLATFORM, BROKER_PLATFORM);
1:3306467: 
1:3306467:         return properties;
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * Load and return a <code>Map<Symbol, Object></code> that contains the properties
1:3306467:      * that this connection supplies to incoming connections when the open has failed
1:3306467:      * and the remote should expect a close to follow.
1:3306467:      *
1:3306467:      * @return the properties that are offered to the incoming connection.
1:3306467:      */
1:3306467:     protected Map<Symbol, Object> getFailedConnetionProperties() {
1:1fd2450:         Map<Symbol, Object> properties = new HashMap<>();
1:3306467: 
1:3306467:         properties.put(CONNECTION_OPEN_FAILED, true);
1:3306467: 
1:3306467:         return properties;
1:3306467:     }
1:3306467: 
1:4b4cf7c:     @Override
1:3306467:     public void updateTracer() {
2:3306467:         if (amqpTransport.isTrace()) {
1:3306467:             ((TransportImpl) protonTransport).setProtocolTracer(new ProtocolTracer() {
3:3306467:                 @Override
1:3306467:                 public void receivedFrame(TransportFrame transportFrame) {
1:3306467:                     TRACE_FRAMES.trace("{} | RECV: {}", AmqpConnection.this.amqpTransport.getRemoteAddress(), transportFrame.getBody());
1:3306467:                 }
1:3306467: 
1:3306467:                 @Override
1:3306467:                 public void sentFrame(TransportFrame transportFrame) {
1:3306467:                     TRACE_FRAMES.trace("{} | SENT: {}", AmqpConnection.this.amqpTransport.getRemoteAddress(), transportFrame.getBody());
1:3306467:                 }
1:3306467:             });
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:4b4cf7c:     public long keepAlive() throws IOException {
1:4b4cf7c:         long rescheduleAt = 0l;
1:4b4cf7c: 
1:4b4cf7c:         LOG.trace("Performing connection:{} keep-alive processing", amqpTransport.getRemoteAddress());
1:4b4cf7c: 
1:4b4cf7c:         if (protonConnection.getLocalState() != EndpointState.CLOSED) {
1:037f91d:             // Using nano time since it is not related to the wall clock, which may change
1:037f91d:             long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
1:f82eccd:             long deadline = protonTransport.tick(now);
1:4b4cf7c:             pumpProtonToSocket();
1:4b4cf7c:             if (protonTransport.isClosed()) {
1:4b4cf7c:                 LOG.debug("Transport closed after inactivity check.");
1:f82eccd:                 throw new InactivityIOException("Channel was inactive for too long");
2:3306467:             } else {
1:f82eccd:                 if(deadline != 0) {
1:f82eccd:                     // caller treats 0 as no-work, ensure value is at least 1 as there was a deadline
1:f82eccd:                     rescheduleAt = Math.max(deadline - now, 1);
1:4b4cf7c:                 }
1:4b4cf7c:             }
1:3306467:         }
1:4b4cf7c: 
1:4b4cf7c:         LOG.trace("Connection:{} keep alive processing done, next update in {} milliseconds.",
1:4b4cf7c:                   amqpTransport.getRemoteAddress(), rescheduleAt);
1:4b4cf7c: 
1:4b4cf7c:         return rescheduleAt;
1:4b4cf7c:     }
1:4b4cf7c: 
1:3306467:     //----- Connection Properties Accessors ----------------------------------//
1:3306467: 
1:3306467:     /**
1:3306467:      * @return the amount of credit assigned to AMQP receiver links created from
1:3306467:      *         sender links on the remote peer.
1:3306467:      */
1:3306467:     public int getConfiguredReceiverCredit() {
1:3306467:         return amqpWireFormat.getProducerCredit();
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * @return the transformer type that was configured for this AMQP transport.
1:3306467:      */
1:3306467:     public String getConfiguredTransformer() {
1:3306467:         return amqpWireFormat.getTransformer();
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * @return the ActiveMQ ConnectionId that identifies this AMQP Connection.
1:3306467:      */
1:3306467:     public ConnectionId getConnectionId() {
1:3306467:         return connectionId;
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:3306467:      * @return the Client ID used to create the connection with ActiveMQ
1:3306467:      */
1:3306467:     public String getClientId() {
1:3306467:         return connectionInfo.getClientId();
1:3306467:     }
1:3306467: 
1:7c41ebc:     /**
1:7c41ebc:      * @return the configured max frame size allowed for incoming messages.
1:7c41ebc:      */
1:7c41ebc:     public long getMaxFrameSize() {
1:7c41ebc:         return amqpWireFormat.getMaxFrameSize();
1:7c41ebc:     }
1:7c41ebc: 
1:3306467:     //----- Proton Event handling and IO support -----------------------------//
1:3306467: 
1:3306467:     void pumpProtonToSocket() {
4:3306467:         try {
1:3306467:             boolean done = false;
1:3306467:             while (!done) {
1:3306467:                 ByteBuffer toWrite = protonTransport.getOutputBuffer();
1:3306467:                 if (toWrite != null && toWrite.hasRemaining()) {
1:31c55f7:                     LOG.trace("Server: Sending {} bytes out", toWrite.limit());
1:3306467:                     amqpTransport.sendToAmqp(toWrite);
1:3306467:                     protonTransport.outputConsumed();
1:3306467:                 } else {
1:3306467:                     done = true;
1:3306467:                 }
1:3306467:             }
1:3306467:         } catch (IOException e) {
1:3306467:             amqpTransport.onException(e);
1:3306467:         }
1:3306467:     }
1:3306467: 
1:b29d2ea:     @SuppressWarnings("deprecation")
1:3306467:     @Override
1:3306467:     public void onAMQPData(Object command) throws Exception {
1:3306467:         Buffer frame;
1:3306467:         if (command.getClass() == AmqpHeader.class) {
1:3306467:             AmqpHeader header = (AmqpHeader) command;
1:3306467: 
1:c599844:             if (amqpWireFormat.isHeaderValid(header, authenticator != null)) {
1:3306467:                 LOG.trace("Connection from an AMQP v1.0 client initiated. {}", header);
1:3306467:             } else {
1:3306467:                 LOG.warn("Connection attempt from non AMQP v1.0 client. {}", header);
1:3306467:                 AmqpHeader reply = amqpWireFormat.getMinimallySupportedHeader();
1:3306467:                 amqpTransport.sendToAmqp(reply.getBuffer());
1:3306467:                 handleException(new AmqpProtocolException(
1:3306467:                     "Connection from client using unsupported AMQP attempted", true));
1:3306467:             }
1:3306467: 
1:3306467:             switch (header.getProtocolId()) {
1:3306467:                 case 0:
1:e333fd9:                     authenticator = null;
1:3306467:                     break; // nothing to do..
1:3306467:                 case 3: // Client will be using SASL for auth..
1:e333fd9:                     authenticator = new AmqpAuthenticator(amqpTransport, protonTransport.sasl(), brokerService);
11:3306467:                     break;
2:3306467:                 default:
1:3306467:             }
1:3306467:             frame = header.getBuffer();
1:3306467:         } else {
1:3306467:             frame = (Buffer) command;
1:3306467:         }
1:3306467: 
1:4b4cf7c:         if (protonTransport.isClosed()) {
1:4b4cf7c:             LOG.debug("Ignoring incoming AMQP data, transport is closed.");
1:4b4cf7c:             return;
1:4b4cf7c:         }
1:4b4cf7c: 
1:31c55f7:         LOG.trace("Server: Received from client: {} bytes", frame.getLength());
1:31c55f7: 
1:3306467:         while (frame.length > 0) {
1:3306467:             try {
1:3306467:                 int count = protonTransport.input(frame.data, frame.offset, frame.length);
1:3306467:                 frame.moveHead(count);
3:3306467:             } catch (Throwable e) {
1:3306467:                 handleException(new AmqpProtocolException("Could not decode AMQP frame: " + frame, true, e));
1:3306467:                 return;
1:3306467:             }
1:3306467: 
1:e333fd9:             if (authenticator != null) {
1:e333fd9:                 processSaslExchange();
1:e333fd9:             } else {
1:e333fd9:                 processProtonEvents();
1:e333fd9:             }
1:e333fd9:         }
1:e333fd9:     }
1:3306467: 
1:e333fd9:     private void processSaslExchange() throws Exception {
1:e333fd9:         authenticator.processSaslExchange(connectionInfo);
1:e333fd9:         if (authenticator.isDone()) {
1:e333fd9:             amqpTransport.getWireFormat().resetMagicRead();
1:e333fd9:         }
1:e333fd9:         pumpProtonToSocket();
1:e333fd9:     }
1:3306467: 
1:e333fd9:     private void processProtonEvents() throws Exception {
1:e333fd9:         try {
1:e333fd9:             Event event = null;
1:e333fd9:             while ((event = eventCollector.peek()) != null) {
1:e333fd9:                 if (amqpTransport.isTrace()) {
1:31c55f7:                     LOG.trace("Server: Processing event: {}", event.getType());
1:e333fd9:                 }
1:e333fd9:                 switch (event.getType()) {
1:e333fd9:                     case CONNECTION_REMOTE_OPEN:
1:e333fd9:                         processConnectionOpen(event.getConnection());
1:e333fd9:                         break;
1:e333fd9:                     case CONNECTION_REMOTE_CLOSE:
1:e333fd9:                         processConnectionClose(event.getConnection());
1:e333fd9:                         break;
1:e333fd9:                     case SESSION_REMOTE_OPEN:
1:e333fd9:                         processSessionOpen(event.getSession());
1:e333fd9:                         break;
1:e333fd9:                     case SESSION_REMOTE_CLOSE:
1:e333fd9:                         processSessionClose(event.getSession());
1:e333fd9:                         break;
1:e333fd9:                     case LINK_REMOTE_OPEN:
1:e333fd9:                         processLinkOpen(event.getLink());
1:e333fd9:                         break;
1:e333fd9:                     case LINK_REMOTE_DETACH:
1:e333fd9:                         processLinkDetach(event.getLink());
1:e333fd9:                         break;
1:e333fd9:                     case LINK_REMOTE_CLOSE:
1:e333fd9:                         processLinkClose(event.getLink());
1:e333fd9:                         break;
1:e333fd9:                     case LINK_FLOW:
1:e333fd9:                         processLinkFlow(event.getLink());
1:e333fd9:                         break;
1:e333fd9:                     case DELIVERY:
1:e333fd9:                         processDelivery(event.getDelivery());
1:e333fd9:                         break;
1:e333fd9:                     default:
1:e333fd9:                         break;
1:3306467:                 }
1:3306467: 
1:e333fd9:                 eventCollector.pop();
1:3306467:             }
1:3306467: 
1:e333fd9:         } catch (Throwable e) {
1:e333fd9:             handleException(new AmqpProtocolException("Could not process AMQP commands", true, e));
1:3306467:         }
1:e333fd9: 
1:e333fd9:         pumpProtonToSocket();
1:3306467:     }
1:3306467: 
1:3306467:     protected void processConnectionOpen(Connection connection) throws Exception {
1:3306467: 
1:4b4cf7c:         stopConnectionTimeoutChecker();
1:4b4cf7c: 
1:3306467:         connectionInfo.setResponseRequired(true);
1:3306467:         connectionInfo.setConnectionId(connectionId);
1:3306467: 
1:3306467:         String clientId = protonConnection.getRemoteContainer();
1:3306467:         if (clientId != null && !clientId.isEmpty()) {
1:3306467:             connectionInfo.setClientId(clientId);
1:3306467:         }
1:3306467: 
1:3306467:         connectionInfo.setTransportContext(amqpTransport.getPeerCertificates());
1:3306467: 
1:4b4cf7c:         if (connection.getTransport().getRemoteIdleTimeout() > 0 && !amqpTransport.isUseInactivityMonitor()) {
1:4b4cf7c:             // We cannot meet the requested Idle processing because the inactivity monitor is
1:4b4cf7c:             // disabled so we won't send idle frames to match the request.
1:4b4cf7c:             protonConnection.setProperties(getFailedConnetionProperties());
1:4b4cf7c:             protonConnection.open();
1:4b4cf7c:             protonConnection.setCondition(new ErrorCondition(AmqpError.PRECONDITION_FAILED, "Cannot send idle frames"));
1:4b4cf7c:             protonConnection.close();
1:4b4cf7c:             pumpProtonToSocket();
1:4b4cf7c: 
1:4b4cf7c:             amqpTransport.onException(new IOException(
1:4b4cf7c:                 "Connection failed, remote requested idle processing but inactivity monitoring is disbaled."));
1:4b4cf7c:             return;
1:4b4cf7c:         }
1:4b4cf7c: 
1:3306467:         sendToActiveMQ(connectionInfo, new ResponseHandler() {
1:3306467:             @Override
1:3306467:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:3306467:                 Throwable exception = null;
1:3306467:                 try {
1:3306467:                     if (response.isException()) {
1:3306467:                         protonConnection.setProperties(getFailedConnetionProperties());
1:3306467:                         protonConnection.open();
1:4b4cf7c: 
1:3306467:                         exception = ((ExceptionResponse) response).getException();
1:3306467:                         if (exception instanceof SecurityException) {
1:3306467:                             protonConnection.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
1:3306467:                         } else if (exception instanceof InvalidClientIDException) {
1:138e52b:                             ErrorCondition condition = new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage());
1:3306467: 
1:1fd2450:                             Map<Symbol, Object> infoMap = new HashMap<> ();
1:138e52b:                             infoMap.put(INVALID_FIELD, CONTAINER_ID);
1:138e52b:                             condition.setInfo(infoMap);
1:3306467: 
1:138e52b:                             protonConnection.setCondition(condition);
1:3306467:                         } else {
1:3306467:                             protonConnection.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, exception.getMessage()));
1:3306467:                         }
1:3306467: 
1:3306467:                         protonConnection.close();
1:3306467:                     } else {
1:4b4cf7c:                         if (amqpTransport.isUseInactivityMonitor() && amqpWireFormat.getIdleTimeout() > 0) {
1:4b4cf7c:                             LOG.trace("Connection requesting Idle timeout of: {} mills", amqpWireFormat.getIdleTimeout());
1:4b4cf7c:                             protonTransport.setIdleTimeout(amqpWireFormat.getIdleTimeout());
1:4b4cf7c:                         }
1:4b4cf7c: 
1:3306467:                         protonConnection.setOfferedCapabilities(getConnectionCapabilitiesOffered());
1:3306467:                         protonConnection.setProperties(getConnetionProperties());
1:76b7054:                         protonConnection.setContainer(brokerService.getBrokerName());
1:3306467:                         protonConnection.open();
1:4b4cf7c: 
1:4b4cf7c:                         configureInactivityMonitor();
1:3306467:                     }
1:3306467:                 } finally {
2:3306467:                     pumpProtonToSocket();
1:3306467: 
1:3306467:                     if (response.isException()) {
1:3306467:                         amqpTransport.onException(IOExceptionSupport.create(exception));
1:3306467:                     }
1:3306467:                 }
1:3306467:             }
1:3306467:         });
1:3306467:     }
1:3306467: 
1:3306467:     protected void processConnectionClose(Connection connection) throws Exception {
1:3306467:         if (!closing) {
1:3306467:             closing = true;
1:3306467:             sendToActiveMQ(new RemoveInfo(connectionId), new ResponseHandler() {
1:3306467:                 @Override
1:3306467:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:3306467:                     protonConnection.close();
1:3306467:                     protonConnection.free();
1:3306467: 
1:3306467:                     if (!closedSocket) {
1:3306467:                         pumpProtonToSocket();
1:3306467:                     }
1:3306467:                 }
1:3306467:             });
1:3306467: 
1:31834ed:             sendToActiveMQ(new ShutdownInfo());
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     protected void processSessionOpen(Session protonSession) throws Exception {
1:3306467:         new AmqpSession(this, getNextSessionId(), protonSession).open();
1:3306467:     }
1:3306467: 
1:3306467:     protected void processSessionClose(Session protonSession) throws Exception {
1:3306467:         if (protonSession.getContext() != null) {
1:3306467:             ((AmqpResource) protonSession.getContext()).close();
1:3306467:         } else {
1:3306467:             protonSession.close();
1:3306467:             protonSession.free();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     protected void processLinkOpen(Link link) throws Exception {
1:3306467:         link.setSource(link.getRemoteSource());
1:3306467:         link.setTarget(link.getRemoteTarget());
1:3306467: 
1:3306467:         AmqpSession session = (AmqpSession) link.getSession().getContext();
1:3306467:         if (link instanceof Receiver) {
1:3306467:             if (link.getRemoteTarget() instanceof Coordinator) {
1:3306467:                 session.createCoordinator((Receiver) link);
1:3306467:             } else {
1:3306467:                 session.createReceiver((Receiver) link);
1:3306467:             }
1:3306467:         } else {
1:3306467:             session.createSender((Sender) link);
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     protected void processLinkDetach(Link link) throws Exception {
1:3306467:         Object context = link.getContext();
1:3306467: 
1:3306467:         if (context instanceof AmqpLink) {
1:3306467:             ((AmqpLink) context).detach();
1:3306467:         } else {
1:3306467:             link.detach();
1:3306467:             link.free();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     protected void processLinkClose(Link link) throws Exception {
1:3306467:         Object context = link.getContext();
1:3306467: 
1:3306467:         if (context instanceof AmqpLink) {
1:3306467:             ((AmqpLink) context).close();;
1:3306467:         } else {
1:3306467:             link.close();
1:3306467:             link.free();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     protected void processLinkFlow(Link link) throws Exception {
1:3306467:         Object context = link.getContext();
1:3306467:         if (context instanceof AmqpLink) {
1:3306467:             ((AmqpLink) context).flow();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     protected void processDelivery(Delivery delivery) throws Exception {
1:3306467:         if (!delivery.isPartial()) {
1:3306467:             Object context = delivery.getLink().getContext();
1:3306467:             if (context instanceof AmqpLink) {
1:3306467:                 AmqpLink amqpLink = (AmqpLink) context;
1:3306467:                 amqpLink.delivery(delivery);
1:3306467:             }
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     //----- Event entry points for ActiveMQ commands and errors --------------//
1:3306467: 
1:3306467:     @Override
1:3306467:     public void onAMQPException(IOException error) {
1:3306467:         closedSocket = true;
1:3306467:         if (!closing) {
1:a5c2f3f:             try {
1:a5c2f3f:                 closing = true;
1:a5c2f3f:                 // Attempt to inform the other end that we are going to close
1:a5c2f3f:                 // so that the client doesn't wait around forever.
1:a5c2f3f:                 protonConnection.setCondition(new ErrorCondition(AmqpError.DECODE_ERROR, error.getMessage()));
1:a5c2f3f:                 protonConnection.close();
1:a5c2f3f:                 pumpProtonToSocket();
1:a5c2f3f:             } catch (Exception ignore) {
1:a5c2f3f:             }
1:3306467:             amqpTransport.sendToActiveMQ(error);
1:3306467:         } else {
1:3306467:             try {
2:3306467:                 amqpTransport.stop();
1:3306467:             } catch (Exception ignore) {
1:3306467:             }
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public void onActiveMQCommand(Command command) throws Exception {
1:3306467:         if (command.isResponse()) {
1:3306467:             Response response = (Response) command;
1:3306467:             ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
1:3306467:             if (rh != null) {
1:3306467:                 rh.onResponse(this, response);
1:3306467:             } else {
1:3306467:                 // Pass down any unexpected errors. Should this close the connection?
1:3306467:                 if (response.isException()) {
1:3306467:                     Throwable exception = ((ExceptionResponse) response).getException();
1:3306467:                     handleException(exception);
1:3306467:                 }
1:3306467:             }
1:3306467:         } else if (command.isMessageDispatch()) {
1:3306467:             MessageDispatch dispatch = (MessageDispatch) command;
1:3306467:             AmqpSender sender = subscriptionsByConsumerId.get(dispatch.getConsumerId());
1:3306467:             if (sender != null) {
1:3306467:                 // End of Queue Browse will have no Message object.
1:3306467:                 if (dispatch.getMessage() != null) {
1:3306467:                     LOG.trace("Dispatching MessageId: {} to consumer", dispatch.getMessage().getMessageId());
1:3306467:                 } else {
1:3306467:                     LOG.trace("Dispatching End of Browse Command to consumer {}", dispatch.getConsumerId());
1:3306467:                 }
1:3306467:                 sender.onMessageDispatch(dispatch);
1:3306467:                 if (dispatch.getMessage() != null) {
1:3306467:                     LOG.trace("Finished Dispatch of MessageId: {} to consumer", dispatch.getMessage().getMessageId());
1:3306467:                 }
1:3306467:             }
1:3306467:         } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
1:3306467:             // Pass down any unexpected async errors. Should this close the connection?
1:3306467:             Throwable exception = ((ConnectionError) command).getException();
1:3306467:             handleException(exception);
1:25c99a6:         } else if (command.isConsumerControl()) {
1:25c99a6:             ConsumerControl control = (ConsumerControl) command;
1:25c99a6:             AmqpSender sender = subscriptionsByConsumerId.get(control.getConsumerId());
1:25c99a6:             if (sender != null) {
1:25c99a6:                 sender.onConsumerControl(control);
1:25c99a6:             }
1:3306467:         } else if (command.isBrokerInfo()) {
1:3306467:             // ignore
1:3306467:         } else {
1:3306467:             LOG.debug("Do not know how to process ActiveMQ Command {}", command);
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     //----- Utility methods for connection resources to use ------------------//
1:3306467: 
1:3a5f127:     void registerSender(ConsumerId consumerId, AmqpSender sender) {
1:3306467:         subscriptionsByConsumerId.put(consumerId, sender);
1:3306467:     }
1:3306467: 
1:3a5f127:     void unregisterSender(ConsumerId consumerId) {
1:3306467:         subscriptionsByConsumerId.remove(consumerId);
1:3306467:     }
1:3306467: 
1:ed26683:     void registerTransaction(TransactionId txId, AmqpTransactionCoordinator coordinator) {
1:ed26683:         transactions.put(txId, coordinator);
1:ed26683:     }
1:ed26683: 
1:ed26683:     void unregisterTransaction(TransactionId txId) {
1:ed26683:         transactions.remove(txId);
1:ed26683:     }
1:ed26683: 
1:ed26683:     AmqpTransactionCoordinator getTxCoordinator(TransactionId txId) {
1:ed26683:         return transactions.get(txId);
1:ed26683:     }
1:ed26683: 
1:ed26683:     LocalTransactionId getNextTransactionId() {
1:ed26683:         return new LocalTransactionId(getConnectionId(), ++nextTransactionId);
1:ed26683:     }
1:ed26683: 
1:b5c6264:     ConsumerInfo lookupSubscription(String subscriptionName) throws AmqpProtocolException {
1:b5c6264:         ConsumerInfo result = null;
1:3306467:         RegionBroker regionBroker;
1:3306467: 
1:3306467:         try {
1:3306467:             regionBroker = (RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class);
1:3306467:         } catch (Exception e) {
1:3306467:             throw new AmqpProtocolException("Error finding subscription: " + subscriptionName + ": " + e.getMessage(), false, e);
1:3306467:         }
1:3306467: 
1:3306467:         final TopicRegion topicRegion = (TopicRegion) regionBroker.getTopicRegion();
1:3306467:         DurableTopicSubscription subscription = topicRegion.lookupSubscription(subscriptionName, connectionInfo.getClientId());
1:3306467:         if (subscription != null) {
1:b5c6264:             result = subscription.getConsumerInfo();
1:3306467:         }
1:3306467: 
1:3306467:         return result;
1:3306467:     }
1:3306467: 
1:3306467: 
1:88daeec:     Subscription lookupPrefetchSubscription(ConsumerInfo consumerInfo)  {
1:88daeec:         Subscription subscription = null;
1:3306467:         try {
1:88daeec:             subscription = ((AbstractRegion)((RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class)).getRegion(consumerInfo.getDestination())).getSubscriptions().get(consumerInfo.getConsumerId());
1:3306467:         } catch (Exception e) {
1:88daeec:             LOG.warn("Error finding subscription for: " + consumerInfo + ": " + e.getMessage(), false, e);
1:3306467:         }
1:88daeec:         return subscription;
1:3306467:     }
1:3306467: 
1:3306467:     ActiveMQDestination createTemporaryDestination(final Link link, Symbol[] capabilities) {
1:3306467:         ActiveMQDestination rc = null;
1:3306467:         if (contains(capabilities, TEMP_TOPIC_CAPABILITY)) {
1:3306467:             rc = new ActiveMQTempTopic(connectionId, nextTempDestinationId++);
1:3306467:         } else if (contains(capabilities, TEMP_QUEUE_CAPABILITY)) {
1:3306467:             rc = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
1:3306467:         } else {
1:3306467:             LOG.debug("Dynamic link request with no type capability, defaults to Temporary Queue");
1:3306467:             rc = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
1:3306467:         }
1:3306467: 
1:3306467:         DestinationInfo info = new DestinationInfo();
1:3306467:         info.setConnectionId(connectionId);
1:3306467:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
1:3306467:         info.setDestination(rc);
1:3306467: 
1:3306467:         sendToActiveMQ(info, new ResponseHandler() {
1:3306467: 
1:3306467:             @Override
1:3306467:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:3306467:                 if (response.isException()) {
1:3306467:                     link.setSource(null);
1:3306467: 
1:3306467:                     Throwable exception = ((ExceptionResponse) response).getException();
1:3306467:                     if (exception instanceof SecurityException) {
1:3306467:                         link.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
1:3306467:                     } else {
1:3306467:                         link.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
1:3306467:                     }
1:3306467: 
1:3306467:                     link.close();
1:3306467:                     link.free();
1:3306467:                 }
1:3306467:             }
1:3306467:         });
1:3306467: 
1:3306467:         return rc;
1:3306467:     }
1:3306467: 
1:3306467:     void deleteTemporaryDestination(ActiveMQTempDestination destination) {
1:3306467:         DestinationInfo info = new DestinationInfo();
1:3306467:         info.setConnectionId(connectionId);
1:3306467:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:3306467:         info.setDestination(destination);
1:3306467: 
1:3306467:         sendToActiveMQ(info, new ResponseHandler() {
1:3306467: 
1:3306467:             @Override
1:3306467:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:3306467:                 if (response.isException()) {
1:3306467:                     Throwable exception = ((ExceptionResponse) response).getException();
1:3306467:                     LOG.debug("Error during temp destination removeal: {}", exception.getMessage());
1:3306467:                 }
1:3306467:             }
1:3306467:         });
1:3306467:     }
1:3306467: 
1:3306467:     void sendToActiveMQ(Command command) {
1:3306467:         sendToActiveMQ(command, null);
1:3306467:     }
1:3306467: 
1:3306467:     void sendToActiveMQ(Command command, ResponseHandler handler) {
1:3306467:         command.setCommandId(lastCommandId.incrementAndGet());
1:3306467:         if (handler != null) {
1:3306467:             command.setResponseRequired(true);
1:3306467:             resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
1:3306467:         }
1:3306467:         amqpTransport.sendToActiveMQ(command);
1:3306467:     }
1:3306467: 
1:3306467:     void handleException(Throwable exception) {
1:3306467:         LOG.debug("Exception detail", exception);
1:7c41ebc:         if (exception instanceof AmqpProtocolException) {
1:7c41ebc:             onAMQPException((IOException) exception);
1:7c41ebc:         } else {
1:7c41ebc:             try {
1:7c41ebc:                 // Must ensure that the broker removes Connection resources.
1:7c41ebc:                 sendToActiveMQ(new ShutdownInfo());
1:7c41ebc:                 amqpTransport.stop();
1:7c41ebc:             } catch (Throwable e) {
1:7c41ebc:                 LOG.error("Failed to stop AMQP Transport ", e);
1:7c41ebc:             }
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     //----- Internal implementation ------------------------------------------//
1:3306467: 
1:3306467:     private SessionId getNextSessionId() {
1:3306467:         return new SessionId(connectionId, nextSessionId++);
1:3306467:     }
1:3306467: 
1:4b4cf7c:     private void stopConnectionTimeoutChecker() {
1:4b4cf7c:         AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();
1:4b4cf7c:         if (monitor != null) {
1:4b4cf7c:             monitor.stopConnectionTimeoutChecker();
1:4b4cf7c:         }
1:4b4cf7c:     }
1:4b4cf7c: 
1:3306467:     private void configureInactivityMonitor() {
1:3306467:         AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();
1:3306467:         if (monitor == null) {
1:3306467:             return;
1:3306467:         }
1:3306467: 
1:4b4cf7c:         // If either end has idle timeout requirements then the tick method
1:4b4cf7c:         // will give us a deadline on the next time we need to tick() in order
1:4b4cf7c:         // to meet those obligations.
1:037f91d:         // Using nano time since it is not related to the wall clock, which may change
1:037f91d:         long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
1:037f91d:         long nextIdleCheck = protonTransport.tick(now);
1:f82eccd:         if (nextIdleCheck != 0) {
1:f82eccd:             // monitor treats <= 0 as no work, ensure value is at least 1 as there was a deadline
1:f82eccd:             long delay = Math.max(nextIdleCheck - now, 1);
1:037f91d:             LOG.trace("Connection keep-alive processing starts in: {}", delay);
1:037f91d:             monitor.startKeepAliveTask(delay);
1:4b4cf7c:         } else {
1:4b4cf7c:             LOG.trace("Connection does not require keep-alive processing");
1:4b4cf7c:         }
1:3306467:     }
1:3306467: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:b29d2ea
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 this.protonTransport.setOutboundFrameSizeLimit(maxFrameSize);
1:             } catch (Throwable e) {
1:                 // Ignore if older proton-j was injected.
1:             }
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("deprecation")
commit:1fd2450
/////////////////////////////////////////////////////////////////////////
1:         String version = "<unknown-5.x>";
/////////////////////////////////////////////////////////////////////////
1:     private final Map<TransactionId, AmqpTransactionCoordinator> transactions = new HashMap<>();
1:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<>();
1:     private final ConcurrentMap<ConsumerId, AmqpSender> subscriptionsByConsumerId = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         Map<Symbol, Object> properties = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         Map<Symbol, Object> properties = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                             Map<Symbol, Object> infoMap = new HashMap<> ();
commit:10fc397
/////////////////////////////////////////////////////////////////////////
1: /*
commit:4a1f2f7
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.AmqpSupport.DELAYED_DELIVERY;
/////////////////////////////////////////////////////////////////////////
1:         return new Symbol[]{ ANONYMOUS_RELAY, DELAYED_DELIVERY };
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1:                     LOG.trace("Server: Sending {} bytes out", toWrite.limit());
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("Server: Received from client: {} bytes", frame.getLength());
1: 
/////////////////////////////////////////////////////////////////////////
1:                     LOG.trace("Server: Processing event: {}", event.getType());
/////////////////////////////////////////////////////////////////////////
commit:c599844
/////////////////////////////////////////////////////////////////////////
1:             if (amqpWireFormat.isHeaderValid(header, authenticator != null)) {
commit:76b7054
/////////////////////////////////////////////////////////////////////////
1:                         protonConnection.setContainer(brokerService.getBrokerName());
commit:8448cf1
/////////////////////////////////////////////////////////////////////////
1:         this.protonTransport.setEmitFlowEventOnSend(false);
commit:08f266d
/////////////////////////////////////////////////////////////////////////
commit:ed26683
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
1:     private long nextTransactionId;
0:     private final Map<TransactionId, AmqpTransactionCoordinator> transactions = new HashMap<TransactionId, AmqpTransactionCoordinator>();
/////////////////////////////////////////////////////////////////////////
1:     void registerTransaction(TransactionId txId, AmqpTransactionCoordinator coordinator) {
1:         transactions.put(txId, coordinator);
1:     }
1: 
1:     void unregisterTransaction(TransactionId txId) {
1:         transactions.remove(txId);
1:     }
1: 
1:     AmqpTransactionCoordinator getTxCoordinator(TransactionId txId) {
1:         return transactions.get(txId);
1:     }
1: 
1:     LocalTransactionId getNextTransactionId() {
1:         return new LocalTransactionId(getConnectionId(), ++nextTransactionId);
1:     }
1: 
commit:c231039
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.AmqpSupport.PLATFORM;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.PRODUCT;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.VERSION;
1: import java.io.BufferedReader;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
/////////////////////////////////////////////////////////////////////////
1:     private static final String BROKER_VERSION;
1:     private static final String BROKER_PLATFORM;
1: 
1:     static {
1:         String javaVersion = System.getProperty("java.version");
1: 
1:         BROKER_PLATFORM = "Java/" + (javaVersion == null ? "unknown" : javaVersion);
1: 
1:         InputStream in = null;
0:         String version = "5.12.0";
1:         if ((in = AmqpConnection.class.getResourceAsStream("/org/apache/activemq/version.txt")) != null) {
1:             BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1:             try {
1:                 version = reader.readLine();
1:             } catch(Exception e) {
1:             }
1:         }
1:         BROKER_VERSION = version;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         properties.put(PRODUCT, "ActiveMQ");
1:         properties.put(VERSION, BROKER_VERSION);
1:         properties.put(PLATFORM, BROKER_PLATFORM);
commit:b5c6264
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerInfo;
/////////////////////////////////////////////////////////////////////////
1:     ConsumerInfo lookupSubscription(String subscriptionName) throws AmqpProtocolException {
1:         ConsumerInfo result = null;
/////////////////////////////////////////////////////////////////////////
1:             result = subscription.getConsumerInfo();
commit:7c41ebc
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the configured max frame size allowed for incoming messages.
1:      */
1:     public long getMaxFrameSize() {
1:         return amqpWireFormat.getMaxFrameSize();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (exception instanceof AmqpProtocolException) {
1:             onAMQPException((IOException) exception);
1:         } else {
1:             try {
1:                 // Must ensure that the broker removes Connection resources.
1:                 sendToActiveMQ(new ShutdownInfo());
1:                 amqpTransport.stop();
1:             } catch (Throwable e) {
1:                 LOG.error("Failed to stop AMQP Transport ", e);
1:             }
commit:4b4cf7c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Date;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.InactivityIOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.engine.EndpointState;
/////////////////////////////////////////////////////////////////////////
1:             monitor.setAmqpTransport(amqpTransport);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public long keepAlive() throws IOException {
1:         long rescheduleAt = 0l;
1: 
1:         LOG.trace("Performing connection:{} keep-alive processing", amqpTransport.getRemoteAddress());
1: 
1:         if (protonConnection.getLocalState() != EndpointState.CLOSED) {
0:             rescheduleAt = protonTransport.tick(System.currentTimeMillis()) - System.currentTimeMillis();
1:             pumpProtonToSocket();
1:             if (protonTransport.isClosed()) {
0:                 rescheduleAt = 0;
1:                 LOG.debug("Transport closed after inactivity check.");
0:                 throw new InactivityIOException("Channel was inactive for to long");
1:             }
1:         }
1: 
1:         LOG.trace("Connection:{} keep alive processing done, next update in {} milliseconds.",
1:                   amqpTransport.getRemoteAddress(), rescheduleAt);
1: 
1:         return rescheduleAt;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (protonTransport.isClosed()) {
1:             LOG.debug("Ignoring incoming AMQP data, transport is closed.");
1:             return;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         stopConnectionTimeoutChecker();
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (connection.getTransport().getRemoteIdleTimeout() > 0 && !amqpTransport.isUseInactivityMonitor()) {
1:             // We cannot meet the requested Idle processing because the inactivity monitor is
1:             // disabled so we won't send idle frames to match the request.
1:             protonConnection.setProperties(getFailedConnetionProperties());
1:             protonConnection.open();
1:             protonConnection.setCondition(new ErrorCondition(AmqpError.PRECONDITION_FAILED, "Cannot send idle frames"));
1:             protonConnection.close();
1:             pumpProtonToSocket();
1: 
1:             amqpTransport.onException(new IOException(
1:                 "Connection failed, remote requested idle processing but inactivity monitoring is disbaled."));
1:             return;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                         if (amqpTransport.isUseInactivityMonitor() && amqpWireFormat.getIdleTimeout() > 0) {
1:                             LOG.trace("Connection requesting Idle timeout of: {} mills", amqpWireFormat.getIdleTimeout());
1:                             protonTransport.setIdleTimeout(amqpWireFormat.getIdleTimeout());
1:                         }
1: 
1: 
1:                         configureInactivityMonitor();
/////////////////////////////////////////////////////////////////////////
1:     private void stopConnectionTimeoutChecker() {
1:         AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();
1:         if (monitor != null) {
1:             monitor.stopConnectionTimeoutChecker();
1:         }
1:     }
1: 
1:         // If either end has idle timeout requirements then the tick method
1:         // will give us a deadline on the next time we need to tick() in order
1:         // to meet those obligations.
0:         long nextIdleCheck = protonTransport.tick(System.currentTimeMillis());
0:         if (nextIdleCheck > 0) {
0:             LOG.trace("Connection keep-alive processing starts at: {}", new Date(nextIdleCheck));
0:             monitor.startKeepAliveTask(nextIdleCheck - System.currentTimeMillis());
1:         } else {
1:             LOG.trace("Connection does not require keep-alive processing");
1:         }
commit:a5c2f3f
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 closing = true;
1:                 // Attempt to inform the other end that we are going to close
1:                 // so that the client doesn't wait around forever.
1:                 protonConnection.setCondition(new ErrorCondition(AmqpError.DECODE_ERROR, error.getMessage()));
1:                 protonConnection.close();
1:                 pumpProtonToSocket();
1:             } catch (Exception ignore) {
1:             }
commit:31834ed
/////////////////////////////////////////////////////////////////////////
1:             sendToActiveMQ(new ShutdownInfo());
/////////////////////////////////////////////////////////////////////////
0:             // Must ensure that the broker removes Connection resources.
0:             sendToActiveMQ(new ShutdownInfo());
commit:25c99a6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
1:         } else if (command.isConsumerControl()) {
1:             ConsumerControl control = (ConsumerControl) command;
1:             AmqpSender sender = subscriptionsByConsumerId.get(control.getConsumerId());
1:             if (sender != null) {
1:                 sender.onConsumerControl(control);
1:             }
commit:e333fd9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.sasl.AmqpAuthenticator;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private long nextSessionId;
1:     private long nextTempDestinationId;
1:     private boolean closing;
1:     private boolean closedSocket;
1:     private AmqpAuthenticator authenticator;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                     authenticator = null;
1:                     authenticator = new AmqpAuthenticator(amqpTransport, protonTransport.sasl(), brokerService);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (authenticator != null) {
1:                 processSaslExchange();
1:             } else {
1:                 processProtonEvents();
1:             }
1:         }
1:     }
1:     private void processSaslExchange() throws Exception {
1:         authenticator.processSaslExchange(connectionInfo);
1:         if (authenticator.isDone()) {
1:             amqpTransport.getWireFormat().resetMagicRead();
1:         }
1:         pumpProtonToSocket();
1:     }
1:     private void processProtonEvents() throws Exception {
1:         try {
1:             Event event = null;
1:             while ((event = eventCollector.peek()) != null) {
1:                 if (amqpTransport.isTrace()) {
0:                     LOG.trace("Processing event: {}", event.getType());
1:                 }
1:                 switch (event.getType()) {
1:                     case CONNECTION_REMOTE_OPEN:
1:                         processConnectionOpen(event.getConnection());
1:                         break;
1:                     case CONNECTION_REMOTE_CLOSE:
1:                         processConnectionClose(event.getConnection());
1:                         break;
1:                     case SESSION_REMOTE_OPEN:
1:                         processSessionOpen(event.getSession());
1:                         break;
1:                     case SESSION_REMOTE_CLOSE:
1:                         processSessionClose(event.getSession());
1:                         break;
1:                     case LINK_REMOTE_OPEN:
1:                         processLinkOpen(event.getLink());
1:                         break;
1:                     case LINK_REMOTE_DETACH:
1:                         processLinkDetach(event.getLink());
1:                         break;
1:                     case LINK_REMOTE_CLOSE:
1:                         processLinkClose(event.getLink());
1:                         break;
1:                     case LINK_FLOW:
1:                         processLinkFlow(event.getLink());
1:                         break;
1:                     case DELIVERY:
1:                         processDelivery(event.getDelivery());
1:                         break;
1:                     default:
1:                         break;
1:                 eventCollector.pop();
1:         } catch (Throwable e) {
1:             handleException(new AmqpProtocolException("Could not process AMQP commands", true, e));
1: 
1:         pumpProtonToSocket();
/////////////////////////////////////////////////////////////////////////
commit:3306467
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.protocol;
1: 
1: import static org.apache.activemq.transport.amqp.AmqpSupport.ANONYMOUS_RELAY;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.CONNECTION_OPEN_FAILED;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.QUEUE_PREFIX;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.TEMP_QUEUE_CAPABILITY;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.TEMP_TOPIC_CAPABILITY;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.TOPIC_PREFIX;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.contains;
1: 
1: import java.io.IOException;
1: import java.nio.ByteBuffer;
0: import java.security.Principal;
0: import java.security.cert.X509Certificate;
1: import java.util.HashMap;
1: import java.util.Map;
0: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import javax.jms.InvalidClientIDException;
1: 
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.DurableTopicSubscription;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.region.TopicRegion;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQTempDestination;
1: import org.apache.activemq.command.ActiveMQTempQueue;
1: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConnectionError;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.security.AuthenticationBroker;
0: import org.apache.activemq.security.SecurityContext;
1: import org.apache.activemq.transport.amqp.AmqpHeader;
1: import org.apache.activemq.transport.amqp.AmqpInactivityMonitor;
1: import org.apache.activemq.transport.amqp.AmqpProtocolConverter;
1: import org.apache.activemq.transport.amqp.AmqpProtocolException;
1: import org.apache.activemq.transport.amqp.AmqpTransport;
1: import org.apache.activemq.transport.amqp.AmqpTransportFilter;
1: import org.apache.activemq.transport.amqp.AmqpWireFormat;
1: import org.apache.activemq.transport.amqp.ResponseHandler;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.qpid.proton.Proton;
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.amqp.transaction.Coordinator;
1: import org.apache.qpid.proton.amqp.transport.AmqpError;
1: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
1: import org.apache.qpid.proton.engine.Collector;
1: import org.apache.qpid.proton.engine.Connection;
1: import org.apache.qpid.proton.engine.Delivery;
1: import org.apache.qpid.proton.engine.Event;
1: import org.apache.qpid.proton.engine.Link;
1: import org.apache.qpid.proton.engine.Receiver;
0: import org.apache.qpid.proton.engine.Sasl;
1: import org.apache.qpid.proton.engine.Sender;
1: import org.apache.qpid.proton.engine.Session;
1: import org.apache.qpid.proton.engine.Transport;
1: import org.apache.qpid.proton.engine.impl.CollectorImpl;
1: import org.apache.qpid.proton.engine.impl.ProtocolTracer;
1: import org.apache.qpid.proton.engine.impl.TransportImpl;
1: import org.apache.qpid.proton.framing.TransportFrame;
1: import org.fusesource.hawtbuf.Buffer;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Implements the mechanics of managing a single remote peer connection.
1:  */
1: public class AmqpConnection implements AmqpProtocolConverter {
1: 
1:     private static final Logger TRACE_FRAMES = AmqpTransportFilter.TRACE_FRAMES;
1:     private static final Logger LOG = LoggerFactory.getLogger(AmqpConnection.class);
1:     private static final int CHANNEL_MAX = 32767;
1: 
1:     private final Transport protonTransport = Proton.transport();
1:     private final Connection protonConnection = Proton.connection();
1:     private final Collector eventCollector = new CollectorImpl();
1: 
1:     private final AmqpTransport amqpTransport;
1:     private final AmqpWireFormat amqpWireFormat;
1:     private final BrokerService brokerService;
0:     private AuthenticationBroker authenticator;
0:     private Sasl sasl;
1: 
1:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1:     private final AtomicInteger lastCommandId = new AtomicInteger();
1:     private final ConnectionId connectionId = new ConnectionId(CONNECTION_ID_GENERATOR.generateId());
1:     private final ConnectionInfo connectionInfo = new ConnectionInfo();
0:     private long nextSessionId = 0;
0:     private long nextTempDestinationId = 0;
0:     private boolean closing = false;
0:     private boolean closedSocket = false;
1: 
0:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
0:     private final ConcurrentMap<ConsumerId, AmqpSender> subscriptionsByConsumerId = new ConcurrentHashMap<ConsumerId, AmqpSender>();
1: 
1:     public AmqpConnection(AmqpTransport transport, BrokerService brokerService) {
1:         this.amqpTransport = transport;
1:         AmqpInactivityMonitor monitor = transport.getInactivityMonitor();
1:         if (monitor != null) {
0:             monitor.setProtocolConverter(this);
1:         }
1:         this.amqpWireFormat = transport.getWireFormat();
1:         this.brokerService = brokerService;
1: 
1:         // the configured maxFrameSize on the URI.
1:         int maxFrameSize = amqpWireFormat.getMaxAmqpFrameSize();
1:         if (maxFrameSize > AmqpWireFormat.NO_AMQP_MAX_FRAME_SIZE) {
1:             this.protonTransport.setMaxFrameSize(maxFrameSize);
1:         }
1: 
1:         this.protonTransport.bind(this.protonConnection);
1:         this.protonTransport.setChannelMax(CHANNEL_MAX);
1: 
1:         this.protonConnection.collect(eventCollector);
1: 
1:         updateTracer();
1:     }
1: 
1:     /**
1:      * Load and return a <code>[]Symbol</code> that contains the connection capabilities
1:      * offered to new connections
1:      *
1:      * @return the capabilities that are offered to new clients on connect.
1:      */
1:     protected Symbol[] getConnectionCapabilitiesOffered() {
0:         return new Symbol[]{ ANONYMOUS_RELAY };
1:     }
1: 
1:     /**
1:      * Load and return a <code>Map<Symbol, Object></code> that contains the properties
1:      * that this connection supplies to incoming connections.
1:      *
1:      * @return the properties that are offered to the incoming connection.
1:      */
1:     protected Map<Symbol, Object> getConnetionProperties() {
0:         Map<Symbol, Object> properties = new HashMap<Symbol, Object>();
1: 
1:         properties.put(QUEUE_PREFIX, "queue://");
1:         properties.put(TOPIC_PREFIX, "topic://");
1: 
1:         return properties;
1:     }
1: 
1:     /**
1:      * Load and return a <code>Map<Symbol, Object></code> that contains the properties
1:      * that this connection supplies to incoming connections when the open has failed
1:      * and the remote should expect a close to follow.
1:      *
1:      * @return the properties that are offered to the incoming connection.
1:      */
1:     protected Map<Symbol, Object> getFailedConnetionProperties() {
0:         Map<Symbol, Object> properties = new HashMap<Symbol, Object>();
1: 
1:         properties.put(CONNECTION_OPEN_FAILED, true);
1: 
1:         return properties;
1:     }
1: 
1:     @Override
1:     public void updateTracer() {
1:         if (amqpTransport.isTrace()) {
1:             ((TransportImpl) protonTransport).setProtocolTracer(new ProtocolTracer() {
1:                 @Override
1:                 public void receivedFrame(TransportFrame transportFrame) {
1:                     TRACE_FRAMES.trace("{} | RECV: {}", AmqpConnection.this.amqpTransport.getRemoteAddress(), transportFrame.getBody());
1:                 }
1: 
1:                 @Override
1:                 public void sentFrame(TransportFrame transportFrame) {
1:                     TRACE_FRAMES.trace("{} | SENT: {}", AmqpConnection.this.amqpTransport.getRemoteAddress(), transportFrame.getBody());
1:                 }
1:             });
1:         }
1:     }
1: 
1:     //----- Connection Properties Accessors ----------------------------------//
1: 
1:     /**
1:      * @return the amount of credit assigned to AMQP receiver links created from
1:      *         sender links on the remote peer.
1:      */
1:     public int getConfiguredReceiverCredit() {
1:         return amqpWireFormat.getProducerCredit();
1:     }
1: 
1:     /**
1:      * @return the transformer type that was configured for this AMQP transport.
1:      */
1:     public String getConfiguredTransformer() {
1:         return amqpWireFormat.getTransformer();
1:     }
1: 
1:     /**
1:      * @return the ActiveMQ ConnectionId that identifies this AMQP Connection.
1:      */
1:     public ConnectionId getConnectionId() {
1:         return connectionId;
1:     }
1: 
1:     /**
1:      * @return the Client ID used to create the connection with ActiveMQ
1:      */
1:     public String getClientId() {
1:         return connectionInfo.getClientId();
1:     }
1: 
1:     //----- Proton Event handling and IO support -----------------------------//
1: 
1:     void pumpProtonToSocket() {
1:         try {
1:             boolean done = false;
1:             while (!done) {
1:                 ByteBuffer toWrite = protonTransport.getOutputBuffer();
1:                 if (toWrite != null && toWrite.hasRemaining()) {
0:                     LOG.trace("Sending {} bytes out", toWrite.limit());
1:                     amqpTransport.sendToAmqp(toWrite);
1:                     protonTransport.outputConsumed();
1:                 } else {
1:                     done = true;
1:                 }
1:             }
1:         } catch (IOException e) {
1:             amqpTransport.onException(e);
1:         }
1:     }
1: 
1:     @Override
1:     public void onAMQPData(Object command) throws Exception {
1:         Buffer frame;
1:         if (command.getClass() == AmqpHeader.class) {
1:             AmqpHeader header = (AmqpHeader) command;
1: 
0:             if (amqpWireFormat.isHeaderValid(header)) {
1:                 LOG.trace("Connection from an AMQP v1.0 client initiated. {}", header);
1:             } else {
1:                 LOG.warn("Connection attempt from non AMQP v1.0 client. {}", header);
1:                 AmqpHeader reply = amqpWireFormat.getMinimallySupportedHeader();
1:                 amqpTransport.sendToAmqp(reply.getBuffer());
1:                 handleException(new AmqpProtocolException(
1:                     "Connection from client using unsupported AMQP attempted", true));
1:             }
1: 
1:             switch (header.getProtocolId()) {
1:                 case 0:
1:                     break; // nothing to do..
1:                 case 3: // Client will be using SASL for auth..
0:                     sasl = protonTransport.sasl();
0:                     sasl.setMechanisms(new String[] { "ANONYMOUS", "PLAIN" });
0:                     sasl.server();
1:                     break;
1:                 default:
1:             }
1:             frame = header.getBuffer();
1:         } else {
1:             frame = (Buffer) command;
1:         }
1: 
0:         onFrame(frame);
1:     }
1: 
0:     public void onFrame(Buffer frame) throws Exception {
1:         while (frame.length > 0) {
1:             try {
1:                 int count = protonTransport.input(frame.data, frame.offset, frame.length);
1:                 frame.moveHead(count);
1:             } catch (Throwable e) {
1:                 handleException(new AmqpProtocolException("Could not decode AMQP frame: " + frame, true, e));
1:                 return;
1:             }
1: 
1:             try {
0:                 if (sasl != null) {
0:                     // Lets try to complete the sasl handshake.
0:                     if (sasl.getRemoteMechanisms().length > 0) {
0:                         if ("PLAIN".equals(sasl.getRemoteMechanisms()[0])) {
0:                             byte[] data = new byte[sasl.pending()];
0:                             sasl.recv(data, 0, data.length);
0:                             Buffer[] parts = new Buffer(data).split((byte) 0);
0:                             if (parts.length > 0) {
0:                                 connectionInfo.setUserName(parts[0].utf8().toString());
1:                             }
0:                             if (parts.length > 1) {
0:                                 connectionInfo.setPassword(parts[1].utf8().toString());
1:                             }
1: 
0:                             if (tryAuthenticate(connectionInfo, amqpTransport.getPeerCertificates())) {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_OK);
1:                             } else {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_AUTH);
1:                             }
1: 
0:                             amqpTransport.getWireFormat().resetMagicRead();
0:                             sasl = null;
0:                             LOG.debug("SASL [PLAIN] Handshake complete.");
0:                         } else if ("ANONYMOUS".equals(sasl.getRemoteMechanisms()[0])) {
0:                             if (tryAuthenticate(connectionInfo, amqpTransport.getPeerCertificates())) {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_OK);
1:                             } else {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_AUTH);
1:                             }
0:                             amqpTransport.getWireFormat().resetMagicRead();
0:                             sasl = null;
0:                             LOG.debug("SASL [ANONYMOUS] Handshake complete.");
1:                         }
1:                     }
1:                 }
1: 
0:                 Event event = null;
0:                 while ((event = eventCollector.peek()) != null) {
1:                     if (amqpTransport.isTrace()) {
0:                         LOG.trace("Processing event: {}", event.getType());
1:                     }
0:                     switch (event.getType()) {
0:                         case CONNECTION_REMOTE_OPEN:
0:                             processConnectionOpen(event.getConnection());
1:                             break;
0:                         case CONNECTION_REMOTE_CLOSE:
0:                             processConnectionClose(event.getConnection());
1:                             break;
0:                         case SESSION_REMOTE_OPEN:
0:                             processSessionOpen(event.getSession());
1:                             break;
0:                         case SESSION_REMOTE_CLOSE:
0:                             processSessionClose(event.getSession());
1:                             break;
0:                         case LINK_REMOTE_OPEN:
0:                             processLinkOpen(event.getLink());
1:                             break;
0:                         case LINK_REMOTE_DETACH:
0:                             processLinkDetach(event.getLink());
1:                             break;
0:                         case LINK_REMOTE_CLOSE:
0:                             processLinkClose(event.getLink());
1:                             break;
0:                         case LINK_FLOW:
0:                             processLinkFlow(event.getLink());
1:                             break;
0:                         case DELIVERY:
0:                             processDelivery(event.getDelivery());
1:                             break;
1:                         default:
1:                             break;
1:                     }
1: 
0:                     eventCollector.pop();
1:                 }
1: 
1:             } catch (Throwable e) {
0:                 handleException(new AmqpProtocolException("Could not process AMQP commands", true, e));
1:             }
1: 
1:             pumpProtonToSocket();
1:         }
1:     }
1: 
1:     protected void processConnectionOpen(Connection connection) throws Exception {
1: 
1:         connectionInfo.setResponseRequired(true);
1:         connectionInfo.setConnectionId(connectionId);
1: 
0:         configureInactivityMonitor();
1: 
1:         String clientId = protonConnection.getRemoteContainer();
1:         if (clientId != null && !clientId.isEmpty()) {
1:             connectionInfo.setClientId(clientId);
1:         }
1: 
1:         connectionInfo.setTransportContext(amqpTransport.getPeerCertificates());
1: 
1:         sendToActiveMQ(connectionInfo, new ResponseHandler() {
1:             @Override
1:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                 Throwable exception = null;
1:                 try {
1:                     if (response.isException()) {
1:                         protonConnection.setProperties(getFailedConnetionProperties());
1:                         protonConnection.open();
1: 
1:                         exception = ((ExceptionResponse) response).getException();
1:                         if (exception instanceof SecurityException) {
1:                             protonConnection.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
1:                         } else if (exception instanceof InvalidClientIDException) {
0:                             protonConnection.setCondition(new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage()));
1:                         } else {
1:                             protonConnection.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, exception.getMessage()));
1:                         }
1: 
1:                         protonConnection.close();
1:                     } else {
1:                         protonConnection.setOfferedCapabilities(getConnectionCapabilitiesOffered());
1:                         protonConnection.setProperties(getConnetionProperties());
1:                         protonConnection.open();
1:                     }
1:                 } finally {
1:                     pumpProtonToSocket();
1: 
1:                     if (response.isException()) {
1:                         amqpTransport.onException(IOExceptionSupport.create(exception));
1:                     }
1:                 }
1:             }
1:         });
1:     }
1: 
1:     protected void processConnectionClose(Connection connection) throws Exception {
1:         if (!closing) {
1:             closing = true;
1:             sendToActiveMQ(new RemoveInfo(connectionId), new ResponseHandler() {
1:                 @Override
1:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                     protonConnection.close();
1:                     protonConnection.free();
1: 
1:                     if (!closedSocket) {
1:                         pumpProtonToSocket();
1:                     }
1:                 }
1:             });
1: 
0:             sendToActiveMQ(new ShutdownInfo(), null);
1:         }
1:     }
1: 
1:     protected void processSessionOpen(Session protonSession) throws Exception {
1:         new AmqpSession(this, getNextSessionId(), protonSession).open();
1:     }
1: 
1:     protected void processSessionClose(Session protonSession) throws Exception {
1:         if (protonSession.getContext() != null) {
1:             ((AmqpResource) protonSession.getContext()).close();
1:         } else {
1:             protonSession.close();
1:             protonSession.free();
1:         }
1:     }
1: 
1:     protected void processLinkOpen(Link link) throws Exception {
1:         link.setSource(link.getRemoteSource());
1:         link.setTarget(link.getRemoteTarget());
1: 
1:         AmqpSession session = (AmqpSession) link.getSession().getContext();
1:         if (link instanceof Receiver) {
1:             if (link.getRemoteTarget() instanceof Coordinator) {
1:                 session.createCoordinator((Receiver) link);
1:             } else {
1:                 session.createReceiver((Receiver) link);
1:             }
1:         } else {
1:             session.createSender((Sender) link);
1:         }
1:     }
1: 
1:     protected void processLinkDetach(Link link) throws Exception {
1:         Object context = link.getContext();
1: 
1:         if (context instanceof AmqpLink) {
1:             ((AmqpLink) context).detach();
1:         } else {
1:             link.detach();
1:             link.free();
1:         }
1:     }
1: 
1:     protected void processLinkClose(Link link) throws Exception {
1:         Object context = link.getContext();
1: 
1:         if (context instanceof AmqpLink) {
1:             ((AmqpLink) context).close();;
1:         } else {
1:             link.close();
1:             link.free();
1:         }
1:     }
1: 
1:     protected void processLinkFlow(Link link) throws Exception {
1:         Object context = link.getContext();
1:         if (context instanceof AmqpLink) {
1:             ((AmqpLink) context).flow();
1:         }
1:     }
1: 
1:     protected void processDelivery(Delivery delivery) throws Exception {
1:         if (!delivery.isPartial()) {
1:             Object context = delivery.getLink().getContext();
1:             if (context instanceof AmqpLink) {
1:                 AmqpLink amqpLink = (AmqpLink) context;
1:                 amqpLink.delivery(delivery);
1:             }
1:         }
1:     }
1: 
1:     //----- Event entry points for ActiveMQ commands and errors --------------//
1: 
1:     @Override
1:     public void onAMQPException(IOException error) {
1:         closedSocket = true;
1:         if (!closing) {
1:             amqpTransport.sendToActiveMQ(error);
1:         } else {
1:             try {
1:                 amqpTransport.stop();
1:             } catch (Exception ignore) {
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     public void onActiveMQCommand(Command command) throws Exception {
1:         if (command.isResponse()) {
1:             Response response = (Response) command;
1:             ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
1:             if (rh != null) {
1:                 rh.onResponse(this, response);
1:             } else {
1:                 // Pass down any unexpected errors. Should this close the connection?
1:                 if (response.isException()) {
1:                     Throwable exception = ((ExceptionResponse) response).getException();
1:                     handleException(exception);
1:                 }
1:             }
1:         } else if (command.isMessageDispatch()) {
1:             MessageDispatch dispatch = (MessageDispatch) command;
1:             AmqpSender sender = subscriptionsByConsumerId.get(dispatch.getConsumerId());
1:             if (sender != null) {
1:                 // End of Queue Browse will have no Message object.
1:                 if (dispatch.getMessage() != null) {
1:                     LOG.trace("Dispatching MessageId: {} to consumer", dispatch.getMessage().getMessageId());
1:                 } else {
1:                     LOG.trace("Dispatching End of Browse Command to consumer {}", dispatch.getConsumerId());
1:                 }
1:                 sender.onMessageDispatch(dispatch);
1:                 if (dispatch.getMessage() != null) {
1:                     LOG.trace("Finished Dispatch of MessageId: {} to consumer", dispatch.getMessage().getMessageId());
1:                 }
1:             }
1:         } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
1:             // Pass down any unexpected async errors. Should this close the connection?
1:             Throwable exception = ((ConnectionError) command).getException();
1:             handleException(exception);
1:         } else if (command.isBrokerInfo()) {
1:             // ignore
1:         } else {
1:             LOG.debug("Do not know how to process ActiveMQ Command {}", command);
1:         }
1:     }
1: 
1:     //----- Utility methods for connection resources to use ------------------//
1: 
0:     void regosterSender(ConsumerId consumerId, AmqpSender sender) {
1:         subscriptionsByConsumerId.put(consumerId, sender);
1:     }
1: 
0:     void unregosterSender(ConsumerId consumerId) {
1:         subscriptionsByConsumerId.remove(consumerId);
1:     }
1: 
0:     ActiveMQDestination lookupSubscription(String subscriptionName) throws AmqpProtocolException {
0:         ActiveMQDestination result = null;
1:         RegionBroker regionBroker;
1: 
1:         try {
1:             regionBroker = (RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class);
1:         } catch (Exception e) {
1:             throw new AmqpProtocolException("Error finding subscription: " + subscriptionName + ": " + e.getMessage(), false, e);
1:         }
1: 
1:         final TopicRegion topicRegion = (TopicRegion) regionBroker.getTopicRegion();
1:         DurableTopicSubscription subscription = topicRegion.lookupSubscription(subscriptionName, connectionInfo.getClientId());
1:         if (subscription != null) {
0:             result = subscription.getActiveMQDestination();
1:         }
1: 
1:         return result;
1:     }
1: 
1:     ActiveMQDestination createTemporaryDestination(final Link link, Symbol[] capabilities) {
1:         ActiveMQDestination rc = null;
1:         if (contains(capabilities, TEMP_TOPIC_CAPABILITY)) {
1:             rc = new ActiveMQTempTopic(connectionId, nextTempDestinationId++);
1:         } else if (contains(capabilities, TEMP_QUEUE_CAPABILITY)) {
1:             rc = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
1:         } else {
1:             LOG.debug("Dynamic link request with no type capability, defaults to Temporary Queue");
1:             rc = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
1:         }
1: 
1:         DestinationInfo info = new DestinationInfo();
1:         info.setConnectionId(connectionId);
1:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
1:         info.setDestination(rc);
1: 
1:         sendToActiveMQ(info, new ResponseHandler() {
1: 
1:             @Override
1:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                 if (response.isException()) {
1:                     link.setSource(null);
1: 
1:                     Throwable exception = ((ExceptionResponse) response).getException();
1:                     if (exception instanceof SecurityException) {
1:                         link.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
1:                     } else {
1:                         link.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
1:                     }
1: 
1:                     link.close();
1:                     link.free();
1:                 }
1:             }
1:         });
1: 
1:         return rc;
1:     }
1: 
1:     void deleteTemporaryDestination(ActiveMQTempDestination destination) {
1:         DestinationInfo info = new DestinationInfo();
1:         info.setConnectionId(connectionId);
1:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:         info.setDestination(destination);
1: 
1:         sendToActiveMQ(info, new ResponseHandler() {
1: 
1:             @Override
1:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                 if (response.isException()) {
1:                     Throwable exception = ((ExceptionResponse) response).getException();
1:                     LOG.debug("Error during temp destination removeal: {}", exception.getMessage());
1:                 }
1:             }
1:         });
1:     }
1: 
1:     void sendToActiveMQ(Command command) {
1:         sendToActiveMQ(command, null);
1:     }
1: 
1:     void sendToActiveMQ(Command command, ResponseHandler handler) {
1:         command.setCommandId(lastCommandId.incrementAndGet());
1:         if (handler != null) {
1:             command.setResponseRequired(true);
1:             resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
1:         }
1:         amqpTransport.sendToActiveMQ(command);
1:     }
1: 
1:     void handleException(Throwable exception) {
0:         exception.printStackTrace();
1:         LOG.debug("Exception detail", exception);
1:         try {
1:             amqpTransport.stop();
1:         } catch (Throwable e) {
0:             LOG.error("Failed to stop AMQP Transport ", e);
1:         }
1:     }
1: 
1:     //----- Internal implementation ------------------------------------------//
1: 
1:     private SessionId getNextSessionId() {
1:         return new SessionId(connectionId, nextSessionId++);
1:     }
1: 
1:     private void configureInactivityMonitor() {
1:         AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();
1:         if (monitor == null) {
1:             return;
1:         }
1: 
0:         monitor.stopConnectChecker();
1:     }
1: 
0:     private boolean tryAuthenticate(ConnectionInfo info, X509Certificate[] peerCertificates) {
1:         try {
0:             if (getAuthenticator().authenticate(info.getUserName(), info.getPassword(), peerCertificates) != null) {
0:                 return true;
1:             }
1: 
0:             return false;
0:         } catch (Throwable error) {
0:             return false;
1:         }
1:     }
1: 
0:     private AuthenticationBroker getAuthenticator() {
0:         if (authenticator == null) {
1:             try {
0:                 authenticator = (AuthenticationBroker) brokerService.getBroker().getAdaptor(AuthenticationBroker.class);
1:             } catch (Exception e) {
0:                 LOG.debug("Failed to lookup AuthenticationBroker from Broker, will use a default Noop version.");
1:             }
1: 
0:             if (authenticator == null) {
0:                 authenticator = new DefaultAuthenticationBroker();
1:             }
1:         }
1: 
0:         return authenticator;
1:     }
1: 
0:     private class DefaultAuthenticationBroker implements AuthenticationBroker {
1: 
1:         @Override
0:         public SecurityContext authenticate(String username, String password, X509Certificate[] peerCertificates) throws SecurityException {
0:             return new SecurityContext(username) {
1: 
1:                 @Override
0:                 public Set<Principal> getPrincipals() {
0:                     return null;
1:                 }
0:             };
1:         }
1:     }
1: }
author:Robbie Gemmell
-------------------------------------------------------------------------------
commit:f82eccd
/////////////////////////////////////////////////////////////////////////
1:             long deadline = protonTransport.tick(now);
1:                 throw new InactivityIOException("Channel was inactive for too long");
0:             } else {
1:                 if(deadline != 0) {
1:                     // caller treats 0 as no-work, ensure value is at least 1 as there was a deadline
1:                     rescheduleAt = Math.max(deadline - now, 1);
0:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (nextIdleCheck != 0) {
1:             // monitor treats <= 0 as no work, ensure value is at least 1 as there was a deadline
1:             long delay = Math.max(nextIdleCheck - now, 1);
author:gtully
-------------------------------------------------------------------------------
commit:88daeec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.AbstractRegion;
1: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
0: 
1:     Subscription lookupPrefetchSubscription(ConsumerInfo consumerInfo)  {
1:         Subscription subscription = null;
0:         try {
1:             subscription = ((AbstractRegion)((RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class)).getRegion(consumerInfo.getDestination())).getSubscriptions().get(consumerInfo.getConsumerId());
0:         } catch (Exception e) {
1:             LOG.warn("Error finding subscription for: " + consumerInfo + ": " + e.getMessage(), false, e);
0:         }
1:         return subscription;
0:     }
0: 
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:037f91d
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:             // Using nano time since it is not related to the wall clock, which may change
1:             long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
0:             rescheduleAt = protonTransport.tick(now) - now;
/////////////////////////////////////////////////////////////////////////
1:         // Using nano time since it is not related to the wall clock, which may change
1:         long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
1:         long nextIdleCheck = protonTransport.tick(now);
0:             long delay = nextIdleCheck - now;
1:             LOG.trace("Connection keep-alive processing starts in: {}", delay);
1:             monitor.startKeepAliveTask(delay);
commit:138e52b
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.transport.amqp.AmqpSupport.CONTAINER_ID;
1: import static org.apache.activemq.transport.amqp.AmqpSupport.INVALID_FIELD;
/////////////////////////////////////////////////////////////////////////
1:                             ErrorCondition condition = new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage());
0: 
0:                             Map<Symbol, Object> infoMap = new HashMap<Symbol, Object> ();
1:                             infoMap.put(INVALID_FIELD, CONTAINER_ID);
1:                             condition.setInfo(infoMap);
0: 
1:                             protonConnection.setCondition(condition);
commit:3a5f127
/////////////////////////////////////////////////////////////////////////
1:     void registerSender(ConsumerId consumerId, AmqpSender sender) {
1:     void unregisterSender(ConsumerId consumerId) {
============================================================================