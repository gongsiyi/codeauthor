1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
2:90bab0f:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0bbc0ac:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:90bab0f:  */
1:d29ca2a: package org.apache.activemq.security;
1:f812e34: 
1:a38a7c0: import java.util.Arrays;
1:f812e34: import java.util.Set;
1:a38a7c0: 
1:d29ca2a: import org.apache.activemq.broker.Broker;
1:d29ca2a: import org.apache.activemq.broker.BrokerFilter;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:84eb9f8: import org.apache.activemq.broker.ProducerBrokerExchange;
1:a38a7c0: import org.apache.activemq.broker.region.CompositeDestinationInterceptor;
1:d29ca2a: import org.apache.activemq.broker.region.Destination;
1:a38a7c0: import org.apache.activemq.broker.region.DestinationInterceptor;
1:a38a7c0: import org.apache.activemq.broker.region.RegionBroker;
1:0def1d4: import org.apache.activemq.broker.region.Subscription;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQQueue;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTopic;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:3a1bdc6: import org.apache.activemq.command.DestinationInfo;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.ProducerInfo;
19:d29ca2a: 
1:d29ca2a: /**
1:f812e34:  * Verifies if a authenticated user can do an operation against the broker using
1:f812e34:  * an authorization map.
1:9ef4259:  *
1:9ef4259:  *
2:d29ca2a:  */
1:9f59397: public class AuthorizationBroker extends BrokerFilter implements SecurityAdminMBean {
1:f812e34: 
1:8d480b4:     private volatile AuthorizationMap authorizationMap;
1:d29ca2a: 
1:9f59397:     public AuthorizationBroker(Broker next, AuthorizationMap authorizationMap) {
1:d29ca2a:         super(next);
1:9f59397:         this.authorizationMap = authorizationMap;
1:a38a7c0: 
1:a38a7c0:         // add DestinationInterceptor
1:a38a7c0:         final RegionBroker regionBroker = (RegionBroker) next.getAdaptor(RegionBroker.class);
1:a38a7c0:         final CompositeDestinationInterceptor compositeInterceptor = (CompositeDestinationInterceptor) regionBroker.getDestinationInterceptor();
1:a38a7c0:         DestinationInterceptor[] interceptors = compositeInterceptor.getInterceptors();
1:a38a7c0:         interceptors = Arrays.copyOf(interceptors, interceptors.length + 1);
1:a38a7c0:         interceptors[interceptors.length - 1] = new AuthorizationDestinationInterceptor(this);
1:a38a7c0:         compositeInterceptor.setInterceptors(interceptors);
1:a38a7c0:     }
1:a38a7c0: 
1:a38a7c0:     public AuthorizationMap getAuthorizationMap() {
1:a38a7c0:         return authorizationMap;
1:f812e34:     }
1:f812e34: 
1:8d480b4:     public void setAuthorizationMap(AuthorizationMap map) {
1:8d480b4:         authorizationMap = map;
1:8d480b4:     }
1:8d480b4: 
1:94b404d:     protected SecurityContext checkSecurityContext(ConnectionContext context) throws SecurityException {
1:204f91f:         final SecurityContext securityContext = context.getSecurityContext();
2:f812e34:         if (securityContext == null) {
2:f812e34:             throw new SecurityException("User is not authenticated.");
2:d29ca2a:         }
1:205699e:         return securityContext;
1:d29ca2a:     }
1:d29ca2a: 
1:205699e:     protected boolean checkDestinationAdmin(SecurityContext securityContext, ActiveMQDestination destination) {
1:27b3a7c:         Destination existing = this.getDestinationMap(destination).get(destination);
1:041b1b8:         if (existing != null) {
1:205699e:             return true;
1:d29ca2a:         }
1:9ef4259: 
1:1d882e9:         if (!securityContext.isBrokerContext()) {
1:933eb2f:             Set<?> allowedACLs = null;
2:f812e34:             if (!destination.isTemporary()) {
1:e78e72f:                 allowedACLs = authorizationMap.getAdminACLs(destination);
1:e78e72f:             } else {
1:f812e34:                 allowedACLs = authorizationMap.getTempDestinationAdminACLs();
1:d29ca2a:             }
1:f812e34: 
1:f812e34:             if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:d29ca2a:                 return false;
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return true;
1:d29ca2a:     }
1:d29ca2a: 
1:205699e:     @Override
1:205699e:     public void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
1:205699e:         final SecurityContext securityContext = checkSecurityContext(context);
1:d29ca2a: 
1:205699e:         if (!checkDestinationAdmin(securityContext, info.getDestination())) {
1:205699e:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to create: " + info.getDestination());
1:d29ca2a:         }
1:d29ca2a: 
1:205699e:         super.addDestinationInfo(context, info);
1:d29ca2a:     }
1:d29ca2a: 
1:205699e:     @Override
1:205699e:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,boolean create) throws Exception {
1:205699e:         final SecurityContext securityContext = checkSecurityContext(context);
1:9ef4259: 
1:205699e:         if (!checkDestinationAdmin(securityContext, destination)) {
1:f812e34:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to create: " + destination);
1:f812e34:         }
1:d29ca2a: 
1:204f91f:         return super.addDestination(context, destination,create);
1:f812e34:     }
1:d29ca2a: 
1:204f91f:     @Override
1:f812e34:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {
1:205699e:         final SecurityContext securityContext = checkSecurityContext(context);
1:f812e34: 
1:205699e:         if (!checkDestinationAdmin(securityContext, destination)) {
1:f812e34:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to remove: " + destination);
1:f812e34:         }
1:d29ca2a: 
1:5f8a3df:         securityContext.getAuthorizedWriteDests().remove(destination);
1:5f8a3df: 
1:d29ca2a:         super.removeDestination(context, destination, timeout);
1:f812e34:     }
1:f812e34: 
1:204f91f:     @Override
1:205699e:     public void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
1:205699e:         final SecurityContext securityContext = checkSecurityContext(context);
1:d29ca2a: 
1:205699e:         if (!checkDestinationAdmin(securityContext, info.getDestination())) {
1:205699e:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to remove: " + info.getDestination());
1:d29ca2a:         }
1:d29ca2a: 
1:5f8a3df:         securityContext.getAuthorizedWriteDests().remove(info.getDestination());
1:5f8a3df: 
1:205699e:         super.removeDestinationInfo(context, info);
1:d29ca2a:     }
1:d29ca2a: 
1:205699e:     @Override
1:205699e:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:205699e:         final SecurityContext securityContext = checkSecurityContext(context);
1:f812e34: 
1:933eb2f:         Set<?> allowedACLs = null;
1:f812e34:         if (!info.getDestination().isTemporary()) {
1:e78e72f:             allowedACLs = authorizationMap.getReadACLs(info.getDestination());
1:f812e34:         } else {
1:f812e34:             allowedACLs = authorizationMap.getTempDestinationReadACLs();
1:f812e34:         }
1:f812e34: 
1:0525772:         if (!securityContext.isBrokerContext() && allowedACLs != null && !securityContext.isInOneOf(allowedACLs) ) {
1:205699e:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to read from: " + info.getDestination());
1:d29ca2a:         }
1:d29ca2a: 
1:f812e34:         /*
1:f812e34:          * Need to think about this a little more. We could do per message
1:f812e34:          * security checking to implement finer grained security checking. For
1:f812e34:          * example a user can only see messages with price>1000 . Perhaps this
1:f812e34:          * should just be another additional broker filter that installs this
1:f812e34:          * type of feature. If we did want to do that, then we would install a
1:f812e34:          * predicate. We should be careful since there may be an existing
1:f812e34:          * predicate already assigned and the consumer info may be sent to a
1:f812e34:          * remote broker, so it also needs to support being marshaled.
1:f812e34:          * info.setAdditionalPredicate(new BooleanExpression() { public boolean
1:f812e34:          * matches(MessageEvaluationContext message) throws JMSException { if(
1:f812e34:          * !subject.getAuthorizedReadDests().contains(message.getDestination()) ) {
1:f812e34:          * Set allowedACLs =
1:f812e34:          * authorizationMap.getReadACLs(message.getDestination());
1:f812e34:          * if(allowedACLs!=null && !subject.isInOneOf(allowedACLs)) return
1:f812e34:          * false; subject.getAuthorizedReadDests().put(message.getDestination(),
1:f812e34:          * message.getDestination()); } return true; } public Object
1:f812e34:          * evaluate(MessageEvaluationContext message) throws JMSException {
1:f812e34:          * return matches(message) ? Boolean.TRUE : Boolean.FALSE; } });
1:f812e34:          */
1:f812e34: 
1:0def1d4:         return super.addConsumer(context, info);
1:f812e34:     }
1:f812e34: 
1:204f91f:     @Override
1:7f5213b:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:205699e:         final SecurityContext securityContext = checkSecurityContext(context);
1:f812e34: 
1:205699e:         if (!securityContext.isBrokerContext() && info.getDestination() != null) {
1:f812e34: 
1:933eb2f:             Set<?> allowedACLs = null;
1:f812e34:             if (!info.getDestination().isTemporary()) {
1:f812e34:                 allowedACLs = authorizationMap.getWriteACLs(info.getDestination());
1:f812e34:             } else {
1:f812e34:                 allowedACLs = authorizationMap.getTempDestinationWriteACLs();
1:f812e34:             }
1:f812e34:             if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:205699e:                 throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to write to: " + info.getDestination());
1:f812e34:             }
1:205699e:             securityContext.getAuthorizedWriteDests().put(info.getDestination(), info.getDestination());
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         super.addProducer(context, info);
1:f812e34:     }
1:d29ca2a: 
1:204f91f:     @Override
1:f812e34:     public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {
1:205699e:         final SecurityContext securityContext = checkSecurityContext(producerExchange.getConnectionContext());
1:f812e34: 
1:9ef4259:         if (!securityContext.isBrokerContext() && !securityContext.getAuthorizedWriteDests().containsValue(messageSend.getDestination())) {
1:d29ca2a: 
1:933eb2f:             Set<?> allowedACLs = null;
1:f812e34:             if (!messageSend.getDestination().isTemporary()) {
1:f812e34:                 allowedACLs = authorizationMap.getWriteACLs(messageSend.getDestination());
1:f812e34:             } else {
1:f812e34:                 allowedACLs = authorizationMap.getTempDestinationWriteACLs();
1:f812e34:             }
1:f812e34: 
1:205699e:             if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:205699e:                 throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to write to: " + messageSend.getDestination());
1:f812e34:             }
1:205699e:             securityContext.getAuthorizedWriteDests().put(messageSend.getDestination(), messageSend.getDestination());
1:d29ca2a:         }
1:d29ca2a: 
1:84eb9f8:         super.send(producerExchange, messageSend);
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     // SecurityAdminMBean interface
2:d29ca2a:     // -------------------------------------------------------------------------
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void addQueueRole(String queue, String operation, String role) {
1:d29ca2a:         addDestinationRole(new ActiveMQQueue(queue), operation, role);
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void addTopicRole(String topic, String operation, String role) {
1:d29ca2a:         addDestinationRole(new ActiveMQTopic(topic), operation, role);
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void removeQueueRole(String queue, String operation, String role) {
1:d29ca2a:         removeDestinationRole(new ActiveMQQueue(queue), operation, role);
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void removeTopicRole(String topic, String operation, String role) {
1:d29ca2a:         removeDestinationRole(new ActiveMQTopic(topic), operation, role);
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     public void addDestinationRole(javax.jms.Destination destination, String operation, String role) {
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     public void removeDestinationRole(javax.jms.Destination destination, String operation, String role) {
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void addRole(String role) {
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void addUserRole(String user, String role) {
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void removeRole(String role) {
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void removeUserRole(String user, String role) {
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a: }
============================================================================
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:5f8a3df
/////////////////////////////////////////////////////////////////////////
1:         securityContext.getAuthorizedWriteDests().remove(destination);
1: 
/////////////////////////////////////////////////////////////////////////
1:         securityContext.getAuthorizedWriteDests().remove(info.getDestination());
1: 
/////////////////////////////////////////////////////////////////////////
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (!securityContext.isBrokerContext() && !securityContext.getAuthorizedWriteDests().containsValue(messageSend.getDestination())) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
author:gtully
-------------------------------------------------------------------------------
commit:27b3a7c
/////////////////////////////////////////////////////////////////////////
1:         Destination existing = this.getDestinationMap(destination).get(destination);
commit:0525772
/////////////////////////////////////////////////////////////////////////
1:         if (!securityContext.isBrokerContext() && allowedACLs != null && !securityContext.isInOneOf(allowedACLs) ) {
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:94b404d
/////////////////////////////////////////////////////////////////////////
1:     protected SecurityContext checkSecurityContext(ConnectionContext context) throws SecurityException {
commit:a38a7c0
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: 
1: import org.apache.activemq.broker.region.CompositeDestinationInterceptor;
1: import org.apache.activemq.broker.region.DestinationInterceptor;
1: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // add DestinationInterceptor
1:         final RegionBroker regionBroker = (RegionBroker) next.getAdaptor(RegionBroker.class);
1:         final CompositeDestinationInterceptor compositeInterceptor = (CompositeDestinationInterceptor) regionBroker.getDestinationInterceptor();
1:         DestinationInterceptor[] interceptors = compositeInterceptor.getInterceptors();
1:         interceptors = Arrays.copyOf(interceptors, interceptors.length + 1);
1:         interceptors[interceptors.length - 1] = new AuthorizationDestinationInterceptor(this);
1:         compositeInterceptor.setInterceptors(interceptors);
1:     }
1: 
1:     public AuthorizationMap getAuthorizationMap() {
1:         return authorizationMap;
0:     public SecurityContext checkSecurityContext(ConnectionContext context) throws SecurityException {
author:Gary Tully
-------------------------------------------------------------------------------
commit:8d480b4
/////////////////////////////////////////////////////////////////////////
1:     private volatile AuthorizationMap authorizationMap;
1:     public void setAuthorizationMap(AuthorizationMap map) {
1:         authorizationMap = map;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (!securityContext.isBrokerContext() && (allowedACLs == null || !securityContext.isInOneOf(allowedACLs))) {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:             Set<?> allowedACLs = null;
/////////////////////////////////////////////////////////////////////////
1:         Set<?> allowedACLs = null;
/////////////////////////////////////////////////////////////////////////
1:         Set<?> allowedACLs = null;
/////////////////////////////////////////////////////////////////////////
1:             Set<?> allowedACLs = null;
/////////////////////////////////////////////////////////////////////////
0:             Set<?> allowedACLs = null;
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0:             if (allowedACLs != null && !subject.isInOneOf(allowedACLs)) {
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
1: 
/////////////////////////////////////////////////////////////////////////
1:  * Verifies if a authenticated user can do an operation against the broker using
1:  * an authorization map.
1: 
1: 
0:         final SecurityContext securityContext = (SecurityContext)context.getSecurityContext();
1:         if (securityContext == null) {
1:         }
0:         // if(!((ActiveMQTempDestination)destination).getConnectionId().equals(context.getConnectionId().getValue())
0:         // ) {
1:             if (!destination.isTemporary()) {
1: 
1:             if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:                 throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to create: " + destination);
1:             }
1:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {
1: 
0:         final SecurityContext securityContext = (SecurityContext)context.getSecurityContext();
1:         if (securityContext == null) {
1:             throw new SecurityException("User is not authenticated.");
1:         }
1:         if (!destination.isTemporary()) {
1:             allowedACLs = authorizationMap.getTempDestinationAdminACLs();
1:         if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to remove: " + destination);
1:         }
1: 
1: 
0:         final SecurityContext subject = (SecurityContext)context.getSecurityContext();
0:         if (subject == null) {
1:         }
1:         if (!info.getDestination().isTemporary()) {
1:         } else {
1:             allowedACLs = authorizationMap.getTempDestinationReadACLs();
0:         if (allowedACLs != null && !subject.isInOneOf(allowedACLs)) {
0:             throw new SecurityException("User " + subject.getUserName() + " is not authorized to read from: " + info.getDestination());
1:         }
1: 
1:         /*
1:          * Need to think about this a little more. We could do per message
1:          * security checking to implement finer grained security checking. For
1:          * example a user can only see messages with price>1000 . Perhaps this
1:          * should just be another additional broker filter that installs this
1:          * type of feature. If we did want to do that, then we would install a
1:          * predicate. We should be careful since there may be an existing
1:          * predicate already assigned and the consumer info may be sent to a
1:          * remote broker, so it also needs to support being marshaled.
1:          * info.setAdditionalPredicate(new BooleanExpression() { public boolean
1:          * matches(MessageEvaluationContext message) throws JMSException { if(
1:          * !subject.getAuthorizedReadDests().contains(message.getDestination()) ) {
1:          * Set allowedACLs =
1:          * authorizationMap.getReadACLs(message.getDestination());
1:          * if(allowedACLs!=null && !subject.isInOneOf(allowedACLs)) return
1:          * false; subject.getAuthorizedReadDests().put(message.getDestination(),
1:          * message.getDestination()); } return true; } public Object
1:          * evaluate(MessageEvaluationContext message) throws JMSException {
1:          * return matches(message) ? Boolean.TRUE : Boolean.FALSE; } });
1:          */
1: 
1: 
1: 
0:         SecurityContext subject = (SecurityContext)context.getSecurityContext();
0:         if (subject == null) {
1:         }
0:         if (info.getDestination() != null) {
1: 
0:             Set allowedACLs = null;
1:             if (!info.getDestination().isTemporary()) {
1:                 allowedACLs = authorizationMap.getWriteACLs(info.getDestination());
1:             } else {
1:                 allowedACLs = authorizationMap.getTempDestinationWriteACLs();
1:             }
0:             if (allowedACLs != null && !subject.isInOneOf(allowedACLs)){
0:                 throw new SecurityException("User " + subject.getUserName() + " is not authorized to write to: " + info.getDestination());
1:             }
1: 
1:     public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {
0:         SecurityContext subject = (SecurityContext)producerExchange.getConnectionContext().getSecurityContext();
0:         if (subject == null) {
1:             throw new SecurityException("User is not authenticated.");
1:         }
0:         if (!subject.getAuthorizedWriteDests().contains(messageSend.getDestination())) {
1: 
0:             Set allowedACLs = null;
1:             if (!messageSend.getDestination().isTemporary()) {
1:                 allowedACLs = authorizationMap.getWriteACLs(messageSend.getDestination());
1:             } else {
1:                 allowedACLs = authorizationMap.getTempDestinationWriteACLs();
1:             }
1: 
0:             if (allowedACLs != null && !subject.isInOneOf(allowedACLs)) {
0:                 throw new SecurityException("User " + subject.getUserName() + " is not authorized to write to: " + messageSend.getDestination());
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:90bab0f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         /* 
0:          * Need to think about this a little more.  We could do per message security checking
0:          * to implement finer grained security checking. For example a user can only see messages
0:          * with price>1000 .  Perhaps this should just be another additional broker filter that installs 
0:          * this type of feature.
1:          * 
0:          * If we did want to do that, then we would install a predicate.  We should be careful since
0:          * there may be an existing predicate already assigned and the consumer info may be sent to a remote 
0:          * broker, so it also needs to support being marshaled.
1:          * 
/////////////////////////////////////////////////////////////////////////
1:         */
/////////////////////////////////////////////////////////////////////////
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void send(ConnectionContext context, Message messageSend) throws Exception {
commit:c59246d
/////////////////////////////////////////////////////////////////////////
0:             || !((ActiveMQTempDestination)destination).getConnectionId().equals(context.getConnectionId().getValue()) ) {
/////////////////////////////////////////////////////////////////////////
0:             || !((ActiveMQTempDestination)destination).getConnectionId().equals(context.getConnectionId().getValue()) ) {
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.security;
1: 
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerFilter;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTempDestination;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.filter.BooleanExpression;
0: import org.apache.activemq.filter.DestinationMap;
0: import org.apache.activemq.filter.MessageEvaluationContext;
1: 
0: import javax.jms.JMSException;
1: 
0: import java.util.Set;
1: 
1: 
1: /**
0:  * Verifies if a authenticated user can do an operation against the broker.
0:  * 
0:  * @version $Revision$
1:  */
0: public class SimpleAuthorizationBroker extends BrokerFilter implements SecurityAdminMBean {
1:     
0:     private final DestinationMap writeACLs;
0:     private final DestinationMap readACLs;
0:     private final DestinationMap adminACLs;
0:     private boolean filterReads = true;
1: 
0:     public SimpleAuthorizationBroker(Broker next, DestinationMap writeACLs, DestinationMap readACLs, DestinationMap adminACLs) {
1:         super(next);
0:         this.writeACLs = writeACLs;
0:         this.readACLs = readACLs;
0:         this.adminACLs = adminACLs;
1:     }
1:     
0:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination) throws Throwable {
0:         final SecurityContext securityContext = (SecurityContext) context.getSecurityContext();
0:         if( securityContext == null )
0:             throw new SecurityException("User is not authenticated.");
1: 
0:         // You don't need to be an admin to create temp destinations.
0:         if( !destination.isTemporary() 
0:             || !((ActiveMQTempDestination)destination).getConnectionId().equals(context.getConnectionId().getConnectionId()) ) {
1:             
0:             Set allowedACLs = adminACLs.get(destination);
0:             if(allowedACLs!=null && !securityContext.isInOneOf(allowedACLs))
0:                 throw new SecurityException("User "+securityContext.getUserName()+" is not authorized to create: "+destination);
1:         }
1:         
0:         return super.addDestination(context, destination);
1:     }
1:     
0:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Throwable {
1:         
0:         final SecurityContext securityContext = (SecurityContext) context.getSecurityContext();
0:         if( securityContext == null )
0:             throw new SecurityException("User is not authenticated.");
1: 
0:         // You don't need to be an admin to remove temp destinations.
0:         if( !destination.isTemporary() 
0:             || !((ActiveMQTempDestination)destination).getConnectionId().equals(context.getConnectionId().getConnectionId()) ) {
1:             
0:             Set allowedACLs = adminACLs.get(destination);
0:             if(allowedACLs!=null && !securityContext.isInOneOf(allowedACLs))
0:                 throw new SecurityException("User "+securityContext.getUserName()+" is not authorized to remove: "+destination);
1:         }
1: 
1:         super.removeDestination(context, destination, timeout);
1:     }
1:     
0:     public void addConsumer(ConnectionContext context, ConsumerInfo info) throws Throwable {
1:         
0:         final SecurityContext subject = (SecurityContext) context.getSecurityContext();
0:         if( subject == null )
0:             throw new SecurityException("User is not authenticated.");
1:         
0:         Set allowedACLs = readACLs.get(info.getDestination());
0:         if(allowedACLs!=null && !subject.isInOneOf(allowedACLs))
0:             throw new SecurityException("User "+subject.getUserName()+" is not authorized to read from: "+info.getDestination());
0:         subject.getAuthorizedReadDests().put(info.getDestination(), info.getDestination());
1:         
0:         // Should we install a additional predicate on the consumer?
0:         // This adds a little more overhead, but is more secure.
0:         if( filterReads ) {
1:             
0:             info.setAdditionalPredicate(new BooleanExpression() {
0:                 public boolean matches(MessageEvaluationContext message) throws JMSException {
0:                     if( !subject.getAuthorizedReadDests().contains(message.getDestination()) ) {
0:                         Set allowedACLs = readACLs.get(message.getDestination());
0:                         if(allowedACLs!=null && !subject.isInOneOf(allowedACLs))
1:                             return false;
0:                         subject.getAuthorizedReadDests().put(message.getDestination(), message.getDestination());
1:                     }
1:                     return true;
1:                 }
0:                 public Object evaluate(MessageEvaluationContext message) throws JMSException {
0:                     return matches(message) ? Boolean.TRUE : Boolean.FALSE;
1:                 }
0:             });
1:             
1:         }
1:         
0:         super.addConsumer(context, info);
1:     }
1:     
0:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Throwable {
1:         
0:         SecurityContext subject = (SecurityContext) context.getSecurityContext();
0:         if( subject == null )
0:             throw new SecurityException("User is not authenticated.");
1:         
0:         if( info.getDestination()!=null ) {
0:             Set allowedACLs = writeACLs.get(info.getDestination());
0:             if(allowedACLs!=null && !subject.isInOneOf(allowedACLs))
0:                 throw new SecurityException("User "+subject.getUserName()+" is not authorized to write to: "+info.getDestination());
0:             subject.getAuthorizedWriteDests().put(info.getDestination(), info.getDestination());
1:         }
1:         
1:         super.addProducer(context, info);
1:     }
1:         
0:     public void send(ConnectionContext context, Message messageSend) throws Throwable {
0:         SecurityContext subject = (SecurityContext) context.getSecurityContext();
0:         if( subject == null )
0:             throw new SecurityException("User is not authenticated.");
1:         
0:         if( !subject.getAuthorizedWriteDests().contains(messageSend.getDestination()) ) {
0:             Set allowedACLs = writeACLs.get(messageSend.getDestination());            
0:             if(allowedACLs!=null && !subject.isInOneOf(allowedACLs))
0:                 throw new SecurityException("User "+subject.getUserName()+" is not authorized to write to: "+messageSend.getDestination());
0:             subject.getAuthorizedWriteDests().put(messageSend.getDestination(), messageSend.getDestination());
1:         }
1: 
0:         super.send(context, messageSend);
1:     }
1:     
1:     // SecurityAdminMBean interface
1:     // -------------------------------------------------------------------------
1: 
1:     public void addQueueRole(String queue, String operation, String role) {
1:         addDestinationRole(new ActiveMQQueue(queue), operation, role);
1:     }
1: 
1:     public void addTopicRole(String topic, String operation, String role) {
1:         addDestinationRole(new ActiveMQTopic(topic), operation, role);
1:     }
1: 
1:     public void removeQueueRole(String queue, String operation, String role) {
1:         removeDestinationRole(new ActiveMQQueue(queue), operation, role);
1:     }
1: 
1:     public void removeTopicRole(String topic, String operation, String role) {
1:         removeDestinationRole(new ActiveMQTopic(topic), operation, role);
1:     }
1:     
1:     public void addDestinationRole(javax.jms.Destination destination, String operation, String role) {
1:     }
1:     
1:     public void removeDestinationRole(javax.jms.Destination destination, String operation, String role) {
1:     }
1: 
1: 
1:     public void addRole(String role) {
1:     }
1: 
1:     public void addUserRole(String user, String role) {
1:     }
1: 
1:     public void removeRole(String role) {
1:     }
1: 
1:     public void removeUserRole(String user, String role) {
1:     }
1: 
0:     // Properties
1:     // -------------------------------------------------------------------------
0:     public boolean isFilterReads() {
0:         return filterReads;
1:     }
1: 
0:     public void setFilterReads(boolean filterReads) {
0:         this.filterReads = filterReads;
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:205699e
/////////////////////////////////////////////////////////////////////////
0:     protected SecurityContext checkSecurityContext(ConnectionContext context) throws SecurityException {
1:         return securityContext;
0:     }
0: 
1:     protected boolean checkDestinationAdmin(SecurityContext securityContext, ActiveMQDestination destination) {
1:             return true;
0: 
/////////////////////////////////////////////////////////////////////////
0:                 return false;
0:         }
0:         return true;
0:     }
0:            
1:     @Override
1:     public void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
1:         final SecurityContext securityContext = checkSecurityContext(context);
1:         if (!checkDestinationAdmin(securityContext, info.getDestination())) {
1:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to create: " + info.getDestination());
0:         }
0: 
1:         super.addDestinationInfo(context, info);
0:     }
0: 
1:     @Override
1:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,boolean create) throws Exception {
1:         final SecurityContext securityContext = checkSecurityContext(context);
0:         
1:         if (!checkDestinationAdmin(securityContext, destination)) {
0:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to create: " + destination);
/////////////////////////////////////////////////////////////////////////
1:         final SecurityContext securityContext = checkSecurityContext(context);
1:         if (!checkDestinationAdmin(securityContext, destination)) {
0: 
1:     public void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
1:         final SecurityContext securityContext = checkSecurityContext(context);
1:         if (!checkDestinationAdmin(securityContext, info.getDestination())) {
1:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to remove: " + info.getDestination());
0: 
1:         super.removeDestinationInfo(context, info);
0:     }
0: 
1:     @Override
1:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:         final SecurityContext securityContext = checkSecurityContext(context);
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (!securityContext.isBrokerContext() && allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:             throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to read from: " + info.getDestination());
0:         securityContext.getAuthorizedReadDests().put(info.getDestination(), info.getDestination());
/////////////////////////////////////////////////////////////////////////
1:         final SecurityContext securityContext = checkSecurityContext(context);
1:         if (!securityContext.isBrokerContext() && info.getDestination() != null) {
/////////////////////////////////////////////////////////////////////////
1:             if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:                 throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to write to: " + info.getDestination());
1:             securityContext.getAuthorizedWriteDests().put(info.getDestination(), info.getDestination());
/////////////////////////////////////////////////////////////////////////
1:         final SecurityContext securityContext = checkSecurityContext(producerExchange.getConnectionContext());
0: 
0:         if (!securityContext.isBrokerContext() && !securityContext.getAuthorizedWriteDests().contains(messageSend.getDestination())) {
/////////////////////////////////////////////////////////////////////////
0:             if (allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
1:                 throw new SecurityException("User " + securityContext.getUserName() + " is not authorized to write to: " + messageSend.getDestination());
1:             securityContext.getAuthorizedWriteDests().put(messageSend.getDestination(), messageSend.getDestination());
commit:3a1bdc6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.DestinationInfo;
/////////////////////////////////////////////////////////////////////////
0:            
0:     public void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
0:         addDestination(context, info.getDestination());
0:         super.addDestinationInfo(context, info);
0:     }
commit:c43eda3
/////////////////////////////////////////////////////////////////////////
0:         if (!securityContext.isBrokerContext() && allowedACLs != null && !securityContext.isInOneOf(allowedACLs)) {
/////////////////////////////////////////////////////////////////////////
0:         if (!subject.isBrokerContext() && allowedACLs != null && !subject.isInOneOf(allowedACLs)) {
/////////////////////////////////////////////////////////////////////////
0:         if (!subject.isBrokerContext() && info.getDestination() != null) {
/////////////////////////////////////////////////////////////////////////
0:         if (!subject.isBrokerContext() && !subject.getAuthorizedWriteDests().contains(messageSend.getDestination())) {
commit:4199c95
/////////////////////////////////////////////////////////////////////////
0:         	return super.addDestination(context, destination);
/////////////////////////////////////////////////////////////////////////
author:Robert Davies
-------------------------------------------------------------------------------
commit:204f91f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:         addDestination(context, info.getDestination(),true);
1:     @Override
0:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,boolean create) throws Exception {
1:         final SecurityContext securityContext = context.getSecurityContext();
1:         	return super.addDestination(context, destination,create);
/////////////////////////////////////////////////////////////////////////
0:         return super.addDestination(context, destination,create);
1:     @Override
0:         final SecurityContext securityContext = context.getSecurityContext();
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:         final SecurityContext subject = context.getSecurityContext();
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:         SecurityContext subject = context.getSecurityContext();
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:         SecurityContext subject = producerExchange.getConnectionContext().getSecurityContext();
commit:041b1b8
/////////////////////////////////////////////////////////////////////////
0:         
0:         Destination existing = this.getDestinationMap().get(destination);
1:         if (existing != null) {
0:         	return existing;
0:         }
0:         
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.ProducerBrokerExchange;
/////////////////////////////////////////////////////////////////////////
0:     public void send(ProducerBrokerExchange producerExchange, Message messageSend) throws Exception {
0:         SecurityContext subject = (SecurityContext) producerExchange.getConnectionContext().getSecurityContext();
/////////////////////////////////////////////////////////////////////////
1:         super.send(producerExchange, messageSend);
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:ee64b03
/////////////////////////////////////////////////////////////////////////
0:         	allowedACLs = authorizationMap.getTempDestinationReadACLs();
commit:e78e72f
/////////////////////////////////////////////////////////////////////////
0: 
0:         //if(!((ActiveMQTempDestination)destination).getConnectionId().equals(context.getConnectionId().getValue()) ) {
0:         Set allowedACLs = null;
0:         if(!destination.isTemporary()) {
1:             allowedACLs = authorizationMap.getAdminACLs(destination);
1:         } else {
0:         	allowedACLs = authorizationMap.getTempDestinationAdminACLs();
0:      
0:         if(allowedACLs!=null && !securityContext.isInOneOf(allowedACLs))
0:             throw new SecurityException("User "+securityContext.getUserName()+" is not authorized to create: "+destination);
0: 
0:        // }
/////////////////////////////////////////////////////////////////////////
0:         Set allowedACLs = null;
0:         if(!destination.isTemporary()) {
0:             allowedACLs = authorizationMap.getAdminACLs(destination);
0:         } else {
0:         	allowedACLs = authorizationMap.getTempDestinationAdminACLs();
0:         
0:     	if(allowedACLs!=null && !securityContext.isInOneOf(allowedACLs))
0:             throw new SecurityException("User "+securityContext.getUserName()+" is not authorized to remove: "+destination);
/////////////////////////////////////////////////////////////////////////
0:         Set allowedACLs = null;
0:         if(!info.getDestination().isTemporary()) {
1:             allowedACLs = authorizationMap.getReadACLs(info.getDestination());
0:         }else {
0:         	allowedACLs = authorizationMap.getTempDestinationWriteACLs();
0:         }
0: 
0:         
/////////////////////////////////////////////////////////////////////////
0:         	
0:         	Set allowedACLs = null;
0:         	if(!info.getDestination().isTemporary()) {
0:         		allowedACLs = authorizationMap.getWriteACLs(info.getDestination());          
0:         	}else {
0:         	   	allowedACLs = authorizationMap.getTempDestinationWriteACLs();
0:         	}
0:             if(allowedACLs!=null && !subject.isInOneOf(allowedACLs)) 
0:             
0:             
/////////////////////////////////////////////////////////////////////////
0: 
0:         	
0:         	Set allowedACLs = null;
0:         	if(!messageSend.getDestination().isTemporary()) {
0:                 allowedACLs = authorizationMap.getWriteACLs(messageSend.getDestination());            
0:         	}else {
0:         		allowedACLs = authorizationMap.getTempDestinationWriteACLs();
0:         	}
0:             
0:         	if(allowedACLs!=null && !subject.isInOneOf(allowedACLs))
0:         	
author:James Strachan
-------------------------------------------------------------------------------
commit:1d882e9
/////////////////////////////////////////////////////////////////////////
1:         if (!securityContext.isBrokerContext()) {
0:             Set allowedACLs = null;
0:             if(!destination.isTemporary()) {
0:                 allowedACLs = authorizationMap.getAdminACLs(destination);
0:             } else {
0:                 allowedACLs = authorizationMap.getTempDestinationAdminACLs();
0:             }
0:          
0:             if(allowedACLs!=null && !securityContext.isInOneOf(allowedACLs))
0:                 throw new SecurityException("User "+securityContext.getUserName()+" is not authorized to create: "+destination);
0:         }
0:         // }
0: 
commit:0def1d4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
0:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         return super.addConsumer(context, info);
commit:9f59397
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  * Verifies if a authenticated user can do an operation against the broker using an authorization map.
1: public class AuthorizationBroker extends BrokerFilter implements SecurityAdminMBean {
0:     private final AuthorizationMap authorizationMap;
1:     public AuthorizationBroker(Broker next, AuthorizationMap authorizationMap) {
1:         this.authorizationMap = authorizationMap;
/////////////////////////////////////////////////////////////////////////
0:             Set allowedACLs = authorizationMap.getAdminACLs(destination);
/////////////////////////////////////////////////////////////////////////
0:             Set allowedACLs = authorizationMap.getAdminACLs(destination);
/////////////////////////////////////////////////////////////////////////
0:         Set allowedACLs = authorizationMap.getReadACLs(info.getDestination());
/////////////////////////////////////////////////////////////////////////
0:                         Set allowedACLs = authorizationMap.getReadACLs(message.getDestination());
/////////////////////////////////////////////////////////////////////////
0:             Set allowedACLs = authorizationMap.getWriteACLs(info.getDestination());
/////////////////////////////////////////////////////////////////////////
0:             Set allowedACLs = authorizationMap.getWriteACLs(messageSend.getDestination());            
============================================================================