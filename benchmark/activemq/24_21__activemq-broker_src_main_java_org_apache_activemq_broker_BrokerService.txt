1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f0d9f83:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:145c80a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker;
1:2251ba0: 
1:f21992e: import java.io.BufferedReader;
1:f21992e: import java.io.File;
1:f21992e: import java.io.IOException;
1:f21992e: import java.io.InputStream;
1:f21992e: import java.io.InputStreamReader;
1:f21992e: import java.net.URI;
1:f21992e: import java.net.URISyntaxException;
1:f21992e: import java.net.UnknownHostException;
1:ff9b800: import java.security.Provider;
1:ff9b800: import java.security.Security;
1:f21992e: import java.util.ArrayList;
1:f2225c2: import java.util.Date;
1:f21992e: import java.util.HashMap;
1:b6f63b0: import java.util.HashSet;
1:f21992e: import java.util.Iterator;
1:f21992e: import java.util.List;
1:4b44d31: import java.util.Locale;
1:f21992e: import java.util.Map;
1:f21992e: import java.util.Set;
1:f21992e: import java.util.concurrent.CopyOnWriteArrayList;
1:f21992e: import java.util.concurrent.CountDownLatch;
1:f21992e: import java.util.concurrent.LinkedBlockingQueue;
1:f21992e: import java.util.concurrent.RejectedExecutionException;
1:f21992e: import java.util.concurrent.RejectedExecutionHandler;
1:f38908e: import java.util.concurrent.SynchronousQueue;
1:f21992e: import java.util.concurrent.ThreadFactory;
1:f21992e: import java.util.concurrent.ThreadPoolExecutor;
1:31c7e62: import java.util.concurrent.TimeUnit;
1:f21992e: import java.util.concurrent.atomic.AtomicBoolean;
1:fde22a8: import java.util.concurrent.atomic.AtomicInteger;
1:fde22a8: import java.util.concurrent.atomic.AtomicLong;
1:f21992e: 
1:f21992e: import javax.annotation.PostConstruct;
1:f21992e: import javax.annotation.PreDestroy;
1:bab0887: import javax.management.InstanceNotFoundException;
1:f21992e: import javax.management.MalformedObjectNameException;
1:f21992e: import javax.management.ObjectName;
1:174fe15: 
1:d29ca2a: import org.apache.activemq.ActiveMQConnectionMetaData;
1:f528aa5: import org.apache.activemq.ConfigurationException;
1:d29ca2a: import org.apache.activemq.Service;
1:d29ca2a: import org.apache.activemq.advisory.AdvisoryBroker;
1:88fbb05: import org.apache.activemq.broker.cluster.ConnectionSplitBroker;
1:fde22a8: import org.apache.activemq.broker.jmx.AnnotatedMBean;
1:fde22a8: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1:fde22a8: import org.apache.activemq.broker.jmx.BrokerView;
1:fde22a8: import org.apache.activemq.broker.jmx.ConnectorView;
1:fde22a8: import org.apache.activemq.broker.jmx.ConnectorViewMBean;
1:fde22a8: import org.apache.activemq.broker.jmx.HealthView;
1:fde22a8: import org.apache.activemq.broker.jmx.HealthViewMBean;
1:fde22a8: import org.apache.activemq.broker.jmx.JmsConnectorView;
1:fde22a8: import org.apache.activemq.broker.jmx.JobSchedulerView;
1:fde22a8: import org.apache.activemq.broker.jmx.JobSchedulerViewMBean;
1:25f1fe8: import org.apache.activemq.broker.jmx.Log4JConfigView;
1:fde22a8: import org.apache.activemq.broker.jmx.ManagedRegionBroker;
1:fde22a8: import org.apache.activemq.broker.jmx.ManagementContext;
1:fde22a8: import org.apache.activemq.broker.jmx.NetworkConnectorView;
1:fde22a8: import org.apache.activemq.broker.jmx.NetworkConnectorViewMBean;
1:fde22a8: import org.apache.activemq.broker.jmx.ProxyConnectorView;
1:f21992e: import org.apache.activemq.broker.region.CompositeDestinationInterceptor;
1:f21992e: import org.apache.activemq.broker.region.Destination;
1:f21992e: import org.apache.activemq.broker.region.DestinationFactory;
1:f21992e: import org.apache.activemq.broker.region.DestinationFactoryImpl;
1:f21992e: import org.apache.activemq.broker.region.DestinationInterceptor;
1:f21992e: import org.apache.activemq.broker.region.RegionBroker;
1:d29ca2a: import org.apache.activemq.broker.region.policy.PolicyMap;
1:42b768a: import org.apache.activemq.broker.region.virtual.MirroredQueue;
1:7d1e6bc: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1:7d1e6bc: import org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor;
1:7d1e6bc: import org.apache.activemq.broker.region.virtual.VirtualTopic;
1:f21992e: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
1:7ae2055: import org.apache.activemq.broker.scheduler.SchedulerBroker;
1:433912f: import org.apache.activemq.broker.scheduler.memory.InMemoryJobSchedulerStore;
1:370734c: import org.apache.activemq.command.ActiveMQDestination;
1:b6f63b0: import org.apache.activemq.command.ActiveMQQueue;
1:23d80b3: import org.apache.activemq.command.BrokerId;
1:0736953: import org.apache.activemq.command.ProducerInfo;
1:b6f63b0: import org.apache.activemq.filter.DestinationFilter;
1:47853d3: import org.apache.activemq.network.ConnectionFilter;
1:400b1fc: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:d29ca2a: import org.apache.activemq.network.NetworkConnector;
1:d29ca2a: import org.apache.activemq.network.jms.JmsConnector;
1:ec9975c: import org.apache.activemq.openwire.OpenWireFormat;
1:d29ca2a: import org.apache.activemq.proxy.ProxyConnector;
1:a640ff5: import org.apache.activemq.security.MessageAuthorizationPolicy;
1:62e1abf: import org.apache.activemq.selector.SelectorParser;
1:d5dd937: import org.apache.activemq.store.JournaledStore;
1:d5dd937: import org.apache.activemq.store.PListStore;
1:d29ca2a: import org.apache.activemq.store.PersistenceAdapter;
1:609681a: import org.apache.activemq.store.PersistenceAdapterFactory;
1:d29ca2a: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
1:1a5ad28: import org.apache.activemq.thread.Scheduler;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:9a8f6e4: import org.apache.activemq.transport.TransportFactorySupport;
1:d29ca2a: import org.apache.activemq.transport.TransportServer;
1:5a429d9: import org.apache.activemq.transport.vm.VMTransportFactory;
1:8a28c06: import org.apache.activemq.usage.PercentLimitUsage;
1:4cddd2c: import org.apache.activemq.usage.StoreUsage;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:fde22a8: import org.apache.activemq.util.BrokerSupport;
1:fde22a8: import org.apache.activemq.util.DefaultIOExceptionHandler;
1:fde22a8: import org.apache.activemq.util.IOExceptionHandler;
1:fde22a8: import org.apache.activemq.util.IOExceptionSupport;
1:fde22a8: import org.apache.activemq.util.IOHelper;
1:fde22a8: import org.apache.activemq.util.InetAddressUtil;
1:fde22a8: import org.apache.activemq.util.ServiceStopper;
1:4cddd2c: import org.apache.activemq.util.StoreUtil;
1:fde22a8: import org.apache.activemq.util.ThreadPoolUtils;
1:fde22a8: import org.apache.activemq.util.TimeUtils;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:f0429be: import org.slf4j.MDC;
1:f21992e: 
1:d29ca2a: /**
1:174fe15:  * Manages the life-cycle of an ActiveMQ Broker. A BrokerService consists of a
1:230a86c:  * number of transport connectors, network connectors and a bunch of properties
1:230a86c:  * which can be used to configure the broker as its lazily created.
1:f0d9f83:  *
1:09fab74:  * @org.apache.xbean.XBean
1:230a86c:  */
1:2bed73b: public class BrokerService implements Service {
1:bc03f37:     public static final String DEFAULT_PORT = "61616";
1:bc03f37:     public static final String LOCAL_HOST_NAME;
1:2251ba0:     public static final String BROKER_VERSION;
1:bc03f37:     public static final String DEFAULT_BROKER_NAME = "localhost";
1:d5dd937:     public static final int DEFAULT_MAX_FILE_LENGTH = 1024 * 1024 * 32;
1:6521549:     public static final long DEFAULT_START_TIMEOUT = 600000L;
1:df19a38: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(BrokerService.class);
1:174fe15: 
1:174fe15:     @SuppressWarnings("unused")
1:b765307:     private static final long serialVersionUID = 7353129142305630237L;
1:174fe15: 
1:dba3ea8:     private boolean useJmx = true;
1:1dc9d9d:     private boolean enableStatistics = true;
1:d29ca2a:     private boolean persistent = true;
1:230a86c:     private boolean populateJMSXUserID;
1:286c9d0:     private boolean useAuthenticatedPrincipalForJMSXUserID;
1:f5dcc9d:     private boolean populateUserNameInMBeans;
1:584c133:     private long mbeanInvocationTimeout = 0;
1:6f68a94: 
1:d29ca2a:     private boolean useShutdownHook = true;
1:230a86c:     private boolean useLoggingForShutdownErrors;
1:230a86c:     private boolean shutdownOnMasterFailure;
1:d14e4ae:     private boolean shutdownOnSlaveFailure;
1:d14e4ae:     private boolean waitForSlave;
1:6521549:     private long waitForSlaveTimeout = DEFAULT_START_TIMEOUT;
1:4228281:     private boolean passiveSlave;
1:bc03f37:     private String brokerName = DEFAULT_BROKER_NAME;
1:9dccfa4:     private File dataDirectoryFile;
1:7d1e6bc:     private File tmpDataDirectory;
1:d29ca2a:     private Broker broker;
1:8ad6fd3:     private BrokerView adminView;
1:d29ca2a:     private ManagementContext managementContext;
1:d29ca2a:     private ObjectName brokerObjectName;
1:d29ca2a:     private TaskRunnerFactory taskRunnerFactory;
1:3fe77a2:     private TaskRunnerFactory persistenceTaskRunnerFactory;
1:2b0024c:     private SystemUsage systemUsage;
1:6d8e2c5:     private SystemUsage producerSystemUsage;
1:f472000:     private SystemUsage consumerSystemUsaage;
1:d29ca2a:     private PersistenceAdapter persistenceAdapter;
1:609681a:     private PersistenceAdapterFactory persistenceFactory;
1:1096564:     protected DestinationFactory destinationFactory;
1:a640ff5:     private MessageAuthorizationPolicy messageAuthorizationPolicy;
1:56917c0:     private final List<TransportConnector> transportConnectors = new CopyOnWriteArrayList<>();
1:56917c0:     private final List<NetworkConnector> networkConnectors = new CopyOnWriteArrayList<>();
1:56917c0:     private final List<ProxyConnector> proxyConnectors = new CopyOnWriteArrayList<>();
1:56917c0:     private final List<JmsConnector> jmsConnectors = new CopyOnWriteArrayList<>();
1:56917c0:     private final List<Service> services = new ArrayList<>();
1:b765307:     private transient Thread shutdownHook;
1:d29ca2a:     private String[] transportConnectorURIs;
1:d29ca2a:     private String[] networkConnectorURIs;
1:230a86c:     private JmsConnector[] jmsBridgeConnectors; // these are Jms to Jms bridges
1:f21992e:     // to other jms messaging systems
1:d29ca2a:     private boolean deleteAllMessagesOnStartup;
1:466ccdd:     private boolean advisorySupport = true;
1:d29ca2a:     private URI vmConnectorURI;
1:0ed0ba5:     private String defaultSocketURIString;
1:d29ca2a:     private PolicyMap destinationPolicy;
1:7ae2055:     private final AtomicBoolean started = new AtomicBoolean(false);
1:7ae2055:     private final AtomicBoolean stopped = new AtomicBoolean(false);
1:4260034:     private final AtomicBoolean stopping = new AtomicBoolean(false);
1:2311749:     private final AtomicBoolean preShutdownHooksInvoked = new AtomicBoolean(false);
1:4686ec5:     private BrokerPlugin[] plugins;
1:230a86c:     private boolean keepDurableSubsActive = true;
1:230a86c:     private boolean useVirtualTopics = true;
1:42b768a:     private boolean useMirroredQueues = false;
1:1ec71bd:     private boolean useTempMirroredQueues = true;
1:cc81680:     /**
1:cc81680:      * Whether or not virtual destination subscriptions should cause network demand
1:cc81680:      */
1:cc81680:     private boolean useVirtualDestSubs = false;
1:cc81680:     /**
1:5772e7b:      * Whether or not the creation of destinations that match virtual destinations
1:cc81680:      * should cause network demand
1:cc81680:      */
1:cc81680:     private boolean useVirtualDestSubsOnCreation = false;
1:23d80b3:     private BrokerId brokerId;
1:8d480b4:     private volatile DestinationInterceptor[] destinationInterceptors;
1:370734c:     private ActiveMQDestination[] destinations;
1:ee55abb:     private PListStore tempDataStore;
1:3fe77a2:     private int persistenceThreadPriority = Thread.MAX_PRIORITY;
1:230a86c:     private boolean useLocalHostBrokerName;
1:7ae2055:     private final CountDownLatch stoppedLatch = new CountDownLatch(1);
1:7ae2055:     private final CountDownLatch startedLatch = new CountDownLatch(1);
1:13829ef:     private Broker regionBroker;
1:c427689:     private int producerSystemUsagePortion = 60;
1:c427689:     private int consumerSystemUsagePortion = 40;
1:c427689:     private boolean splitSystemUsageForProducersConsumers;
1:1ec71bd:     private boolean monitorConnectionSplits = false;
1:88fbb05:     private int taskRunnerPriority = Thread.NORM_PRIORITY;
1:88fbb05:     private boolean dedicatedTaskRunner;
1:1ec71bd:     private boolean cacheTempDestinations = false;// useful for failover
1:e4621e3:     private int timeBeforePurgeTempDestinations = 5000;
1:56917c0:     private final List<Runnable> shutdownHooks = new ArrayList<>();
1:b4f65ba:     private boolean systemExitOnShutdown;
1:139a220:     private int systemExitOnShutdownExitCode;
1:6453ebb:     private SslContext sslContext;
1:62e1abf:     private boolean forceStart = false;
1:e8a641c:     private IOExceptionHandler ioExceptionHandler;
1:92b3ae2:     private boolean schedulerSupport = false;
1:7ae2055:     private File schedulerDirectoryFile;
1:1a5ad28:     private Scheduler scheduler;
1:1a5ad28:     private ThreadPoolExecutor executor;
1:6813691:     private int schedulePeriodForDestinationPurge= 0;
1:f0d9f83:     private int maxPurgedDestinationsPerSweep = 0;
1:61fd811:     private int schedulePeriodForDiskUsageCheck = 0;
1:4cddd2c:     private int diskUsageCheckRegrowThreshold = -1;
1:d7febdd:     private boolean adjustUsageLimits = true;
1:11705e7:     private BrokerContext brokerContext;
1:f38908e:     private boolean networkConnectorStartAsync = false;
1:254d920:     private boolean allowTempAutoCreationOnSend;
1:f21992e:     private JobSchedulerStore jobSchedulerStore;
1:fde22a8:     private final AtomicLong totalConnections = new AtomicLong();
1:fde22a8:     private final AtomicInteger currentConnections = new AtomicInteger();
1:39ff4d9: 
1:3cd8da8:     private long offlineDurableSubscriberTimeout = -1;
1:3cd8da8:     private long offlineDurableSubscriberTaskSchedule = 300000;
1:b6f63b0:     private DestinationFilter virtualConsumerDestinationFilter;
1:2db7df7: 
1:35b82e5:     private final AtomicBoolean persistenceAdapterStarted = new AtomicBoolean(false);
1:ed58e9a:     private Throwable startException = null;
1:eebe135:     private boolean startAsync = false;
1:f2225c2:     private Date startDate;
1:d75e418:     private boolean slave = true;
1:f38908e: 
1:4a16c1f:     private boolean restartAllowed = true;
1:4a16c1f:     private boolean restartRequested = false;
1:741e3aa:     private boolean rejectDurableConsumers = false;
1:fe9d99e:     private boolean rollbackOnlyOnAsyncException = true;
1:2705e36: 
1:13044de:     private int storeOpenWireVersion = OpenWireFormat.DEFAULT_STORE_VERSION;
1:2311749:     private final List<Runnable> preShutdownHooks = new CopyOnWriteArrayList<>();
1:1a5ad28: 
1:f0d9f83:     static {
1:ff9b800: 
1:c395917:         try {
1:ff9b800:             ClassLoader loader = BrokerService.class.getClassLoader();
1:ff9b800:             Class<?> clazz = loader.loadClass("org.bouncycastle.jce.provider.BouncyCastleProvider");
1:ff9b800:             Provider bouncycastle = (Provider) clazz.newInstance();
1:5009b0c:             Security.insertProviderAt(bouncycastle,
1:5009b0c:                 Integer.getInteger("org.apache.activemq.broker.BouncyCastlePosition", 2));
1:ff9b800:             LOG.info("Loaded the Bouncy Castle security provider.");
1:ff9b800:         } catch(Throwable e) {
1:ff9b800:             // No BouncyCastle found so we use the default Java Security Provider
1:e80bf00:         }
1:61fd811: 
1:bc03f37:         String localHostName = "localhost";
1:2030097:         try {
1:8a1f994:             localHostName =  InetAddressUtil.getLocalHostName();
1:230a86c:         } catch (UnknownHostException e) {
1:230a86c:             LOG.error("Failed to resolve localhost");
1:61fd811:         }
1:bc03f37:         LOCAL_HOST_NAME = localHostName;
1:61fd811: 
1:2251ba0:         String version = null;
1:12b26b6:         try(InputStream in = BrokerService.class.getResourceAsStream("/org/apache/activemq/version.txt")) {
1:12b26b6:             if (in != null) {
1:12b26b6:                 try(InputStreamReader isr = new InputStreamReader(in);
1:12b26b6:                     BufferedReader reader = new BufferedReader(isr)) {
1:12b26b6:                     version = reader.readLine();
1:12b26b6:                 }
1:61fd811:             }
1:12b26b6:         } catch (IOException ie) {
1:12b26b6:             LOG.warn("Error reading broker version ", ie);
1:e80bf00:         }
1:2251ba0:         BROKER_VERSION = version;
1:ff9b800:     }
1:3630a41: 
1:f21992e:     @Override
1:a640190:     public String toString() {
1:a640190:         return "BrokerService[" + getBrokerName() + "]";
1:dbc661f:     }
1:3630a41: 
1:2251ba0:     private String getBrokerVersion() {
1:2251ba0:         String version = ActiveMQConnectionMetaData.PROVIDER_VERSION;
1:2251ba0:         if (version == null) {
1:2251ba0:             version = BROKER_VERSION;
1:2251ba0:         }
1:f38908e: 
1:2251ba0:         return version;
1:2251ba0:     }
1:31c7e62: 
1:61fd811:     /**
1:d29ca2a:      * Adds a new transport connector for the given bind address
1:f0d9f83:      *
1:d29ca2a:      * @return the newly created and added transport connector
1:4098942:      * @throws Exception
1:83a6eff:      */
1:d29ca2a:     public TransportConnector addConnector(String bindAddress) throws Exception {
1:d29ca2a:         return addConnector(new URI(bindAddress));
1:dbc661f:     }
1:43880af: 
1:61fd811:     /**
1:d29ca2a:      * Adds a new transport connector for the given bind address
1:f0d9f83:      *
1:d29ca2a:      * @return the newly created and added transport connector
1:d29ca2a:      * @throws Exception
1:83a6eff:      */
1:d29ca2a:     public TransportConnector addConnector(URI bindAddress) throws Exception {
1:5d99c99:         return addConnector(createTransportConnector(bindAddress));
1:1a5ad28:     }
1:ff9b800: 
1:61fd811:     /**
1:d29ca2a:      * Adds a new transport connector for the given TransportServer transport
1:f0d9f83:      *
1:d29ca2a:      * @return the newly created and added transport connector
1:d29ca2a:      * @throws Exception
1:25a252f:      */
1:d29ca2a:     public TransportConnector addConnector(TransportServer transport) throws Exception {
1:5d99c99:         return addConnector(new TransportConnector(transport));
1:98497b1:     }
1:f21992e: 
1:31c7e62:     /**
1:d29ca2a:      * Adds a new transport connector
1:f0d9f83:      *
1:d29ca2a:      * @return the transport connector
1:d29ca2a:      * @throws Exception
1:25a252f:      */
1:d29ca2a:     public TransportConnector addConnector(TransportConnector connector) throws Exception {
1:d29ca2a:         transportConnectors.add(connector);
1:d29ca2a:         return connector;
1:d14e4ae:     }
1:2251ba0: 
1:155461a:     /**
1:c9b8905:      * Stops and removes a transport connector from the broker.
1:f0d9f83:      *
1:c9b8905:      * @param connector
1:c9b8905:      * @return true if the connector has been previously added to the broker
1:d29ca2a:      * @throws Exception
1:3a9299b:      */
1:230a86c:     public boolean removeConnector(TransportConnector connector) throws Exception {
1:c9b8905:         boolean rc = transportConnectors.remove(connector);
1:230a86c:         if (rc) {
1:230a86c:             unregisterConnectorMBean(connector);
1:d14e4ae:         }
1:c9b8905:         return rc;
1:d14e4ae:     }
1:2251ba0: 
1:4228281:     /**
1:d29ca2a:      * Adds a new network connector using the given discovery address
1:f0d9f83:      *
1:d29ca2a:      * @return the newly created and added network connector
1:d29ca2a:      * @throws Exception
1:3a9299b:      */
1:d29ca2a:     public NetworkConnector addNetworkConnector(String discoveryAddress) throws Exception {
1:d29ca2a:         return addNetworkConnector(new URI(discoveryAddress));
1:d14e4ae:     }
1:df19a38: 
1:83a6eff:     /**
1:d29ca2a:      * Adds a new proxy connector using the given bind address
1:f0d9f83:      *
1:d29ca2a:      * @return the newly created and added network connector
1:d29ca2a:      * @throws Exception
1:3a9299b:      */
1:d29ca2a:     public ProxyConnector addProxyConnector(String bindAddress) throws Exception {
1:d29ca2a:         return addProxyConnector(new URI(bindAddress));
1:8bf9c17:     }
1:df19a38: 
1:83a6eff:     /**
1:d29ca2a:      * Adds a new network connector using the given discovery address
1:f0d9f83:      *
1:d29ca2a:      * @return the newly created and added network connector
1:d29ca2a:      * @throws Exception
1:4098942:      */
1:230a86c:     public NetworkConnector addNetworkConnector(URI discoveryAddress) throws Exception {
1:230a86c:         NetworkConnector connector = new DiscoveryNetworkConnector(discoveryAddress);
1:d29ca2a:         return addNetworkConnector(connector);
1:88fbb05:     }
1:f6caba7: 
1:25a252f:     /**
1:d29ca2a:      * Adds a new proxy connector using the given bind address
1:f0d9f83:      *
1:d29ca2a:      * @return the newly created and added network connector
1:d29ca2a:      * @throws Exception
1:4098942:      */
1:230a86c:     public ProxyConnector addProxyConnector(URI bindAddress) throws Exception {
1:230a86c:         ProxyConnector connector = new ProxyConnector();
1:d29ca2a:         connector.setBind(bindAddress);
1:d29ca2a:         connector.setRemote(new URI("fanout:multicast://default"));
1:d29ca2a:         return addProxyConnector(connector);
1:88fbb05:     }
1:d403f10: 
1:25a252f:     /**
1:d29ca2a:      * Adds a new network connector to connect this broker to a federated
1:d29ca2a:      * network
1:d29ca2a:      */
1:d29ca2a:     public NetworkConnector addNetworkConnector(NetworkConnector connector) throws Exception {
1:30f531d:         connector.setBrokerService(this);
1:3100909:         connector.setLocalUri(getVmConnectorURI());
1:230a86c:         // Set a connection filter so that the connector does not establish loop
1:230a86c:         // back connections.
1:47853d3:         connector.setConnectionFilter(new ConnectionFilter() {
1:f21992e:             @Override
1:47853d3:             public boolean connectTo(URI location) {
1:ecf89a6:                 List<TransportConnector> transportConnectors = getTransportConnectors();
1:ecf89a6:                 for (Iterator<TransportConnector> iter = transportConnectors.iterator(); iter.hasNext();) {
1:ff9b800:                     try {
1:ecf89a6:                         TransportConnector tc = iter.next();
1:230a86c:                         if (location.equals(tc.getConnectUri())) {
1:47853d3:                             return false;
1:5f4db41:                         }
1:ed96e2e:                     } catch (Throwable e) {
1:2cb2119:                     }
1:1e3e5b7:                 }
1:47853d3:                 return true;
1:1e3e5b7:             }
1:5cd9eba:         });
1:d29ca2a:         networkConnectors.add(connector);
1:d29ca2a:         return connector;
1:1e3e5b7:     }
1:7b90f41: 
1:14c605f:     /**
1:230a86c:      * Removes the given network connector without stopping it. The caller
1:230a86c:      * should call {@link NetworkConnector#stop()} to close the connector
1:d29ca2a:      */
1:53082e6:     public boolean removeNetworkConnector(NetworkConnector connector) {
1:53082e6:         boolean answer = networkConnectors.remove(connector);
1:53082e6:         if (answer) {
1:319966c:             unregisterNetworkConnectorMBean(connector);
1:1e3e5b7:         }
1:53082e6:         return answer;
1:1e3e5b7:     }
1:f0d9f83: 
1:d29ca2a:     public ProxyConnector addProxyConnector(ProxyConnector connector) throws Exception {
1:4757541:         URI uri = getVmConnectorURI();
1:98497b1:         connector.setLocalUri(uri);
1:d29ca2a:         proxyConnectors.add(connector);
1:4098942:         if (isUseJmx()) {
1:d29ca2a:             registerProxyConnectorMBean(connector);
1:f392884:         }
1:d29ca2a:         return connector;
1:83a6eff:     }
1:f0d9f83: 
1:230a86c:     public JmsConnector addJmsConnector(JmsConnector connector) throws Exception {
1:3910056:         connector.setBrokerService(this);
1:d29ca2a:         jmsConnectors.add(connector);
1:4098942:         if (isUseJmx()) {
1:4098942:             registerJmsConnectorMBean(connector);
1:83a6eff:         }
1:d29ca2a:         return connector;
1:83a6eff:     }
1:f0d9f83: 
1:bc03f37:     /**
1:155461a:      * Adds a {@link Runnable} hook that will be invoked before the
1:155461a:      * broker is stopped. This allows performing cleanup actions
1:155461a:      * before the broker is stopped. The hook should not throw
1:155461a:      * exceptions or block.
1:155461a:      */
1:155461a:     public final void addPreShutdownHook(final Runnable hook) {
1:155461a:         preShutdownHooks.add(hook);
1:155461a:     }
1:155461a: 
1:230a86c:     public JmsConnector removeJmsConnector(JmsConnector connector) {
1:230a86c:         if (jmsConnectors.remove(connector)) {
1:d29ca2a:             return connector;
1:25a252f:         }
1:222daf2:         return null;
1:25a252f:     }
1:f0d9f83: 
1:230a86c:     public void masterFailed() {
1:230a86c:         if (shutdownOnMasterFailure) {
1:8bf987b:             LOG.error("The Master has failed ... shutting down");
1:f21992e:             try {
1:4098942:                 stop();
1:c129051:             } catch (Exception e) {
1:230a86c:                 LOG.error("Failed to stop for master failure", e);
1:f21992e:             }
1:f6caba7:         } else {
1:230a86c:             LOG.warn("Master Failed - starting all connectors");
1:2251ba0:             try {
1:f1b6362:                 startAllConnectors();
1:4ee029e:                 broker.nowMasterBroker();
1:c395917:             } catch (Exception e) {
1:0782204:                 LOG.error("Failed to startAllConnectors", e);
1:f21992e:             }
1:f6caba7:         }
1:55409bd:     }
1:f21992e: 
1:f2225c2:     public String getUptime() {
1:8e0865d:         long delta = getUptimeMillis();
1:8e0865d: 
1:8e0865d:         if (delta == 0) {
1:f2225c2:             return "not started";
1:f2225c2:         }
1:8e0865d: 
1:f2225c2:         return TimeUtils.printDuration(delta);
1:f2225c2:     }
1:f2225c2: 
1:8e0865d:     public long getUptimeMillis() {
1:8e0865d:         if (startDate == null) {
1:8e0865d:             return 0;
1:8e0865d:         }
1:8e0865d: 
1:8e0865d:         return new Date().getTime() - startDate.getTime();
1:8e0865d:     }
1:8e0865d: 
1:ea1dad7:     public boolean isStarted() {
1:428a063:         return started.get() && startedLatch.getCount() == 0;
1:25a252f:     }
1:f6caba7: 
1:3a9299b:     /**
1:7b90f41:      * Forces a start of the broker.
1:7b90f41:      * By default a BrokerService instance that was
1:2f72b71:      * previously stopped using BrokerService.stop() cannot be restarted
1:7b90f41:      * using BrokerService.start().
1:7b90f41:      * This method enforces a restart.
1:2f72b71:      * It is not recommended to force a restart of the broker and will not work
1:7b90f41:      * for most but some very trivial broker configurations.
1:2f72b71:      * For restarting a broker instance we recommend to first call stop() on
1:2f72b71:      * the old instance and then recreate a new BrokerService instance.
1:7b90f41:      *
1:2f72b71:      * @param force - if true enforces a restart.
1:2f72b71:      * @throws Exception
1:4098942:      */
1:62e1abf:     public void start(boolean force) throws Exception {
1:1ec71bd:         forceStart = force;
1:72b9416:         stopped.set(false);
1:72b9416:         started.set(false);
1:1ec71bd:         start();
1:14c605f:     }
1:f0d9f83: 
1:d29ca2a:     // Service interface
1:d29ca2a:     // -------------------------------------------------------------------------
1:39ff4d9: 
1:20118f2:     protected boolean shouldAutostart() {
1:20118f2:         return true;
1:bc03f37:     }
1:39ff4d9: 
1:3a9299b:     /**
1:174fe15:      * JSR-250 callback wrapper; converts checked exceptions to runtime exceptions
1:174fe15:      *
1:174fe15:      * delegates to autoStart, done to prevent backwards incompatible signature change
1:174fe15:      */
1:174fe15:     @PostConstruct
1:174fe15:     private void postConstruct() {
1:174fe15:         try {
1:174fe15:             autoStart();
1:174fe15:         } catch (Exception ex) {
1:174fe15:             throw new RuntimeException(ex);
1:174fe15:         }
1:174fe15:     }
1:174fe15: 
1:174fe15:     /**
1:174fe15:      *
1:09fab74:      * @throws Exception
1:09fab74:      * @org. apache.xbean.InitMethod
1:4098942:      */
1:20118f2:     public void autoStart() throws Exception {
1:20118f2:         if(shouldAutostart()) {
1:eebe135:             start();
1:bc03f37:         }
1:3a9299b:     }
1:dbc661f: 
1:f21992e:     @Override
1:62e1abf:     public void start() throws Exception {
1:98497b1:         if (stopped.get() || !started.compareAndSet(false, true)) {
1:d29ca2a:             // lets just ignore redundant start() calls
1:230a86c:             // as its way too easy to not be completely sure if start() has been
1:230a86c:             // called or not with the gazillion of different configuration
1:230a86c:             // mechanisms
1:eea9fca:             // throw new IllegalStateException("Already started.");
1:7f89b33:             return;
1:da076f4:         }
1:1a5ad28: 
1:da076f4:         setStartException(null);
1:4260034:         stopping.set(false);
1:2311749:         preShutdownHooksInvoked.set(false);
1:f2225c2:         startDate = new Date();
1:3da9f1c:         MDC.put("activemq.broker", brokerName);
1:ff9b800: 
1:1a5ad28:         try {
1:d7febdd:             checkMemorySystemUsageLimits();
1:f0d9f83:             if (systemExitOnShutdown && useShutdownHook) {
1:f0d9f83:                 throw new ConfigurationException("'useShutdownHook' property cannot be be used with 'systemExitOnShutdown', please turn it off (useShutdownHook=false)");
1:f0d9f83:             }
1:d29ca2a:             processHelperProperties();
1:7f89b33:             if (isUseJmx()) {
1:eea9fca:                 // need to remove MDC during starting JMX, as that would otherwise causes leaks, as spawned threads inheirt the MDC and
1:eea9fca:                 // we cannot cleanup clear that during shutdown of the broker.
1:eea9fca:                 MDC.remove("activemq.broker");
1:eea9fca:                 try {
1:eea9fca:                     startManagementContext();
1:6b1ffae:                     for (NetworkConnector connector : getNetworkConnectors()) {
1:6b1ffae:                         registerNetworkConnectorMBean(connector);
1:3a9299b:                     }
1:eea9fca:                 } finally {
1:eea9fca:                     MDC.put("activemq.broker", brokerName);
1:eea9fca:                 }
1:3a9299b:             }
1:dbc661f: 
1:0051c4e:             // in jvm master slave, lets not publish over existing broker till we get the lock
1:0051c4e:             final BrokerRegistry brokerRegistry = BrokerRegistry.getInstance();
1:0051c4e:             if (brokerRegistry.lookup(getBrokerName()) == null) {
1:0051c4e:                 brokerRegistry.bind(getBrokerName(), BrokerService.this);
1:0051c4e:             }
1:eebe135:             startPersistenceAdapter(startAsync);
1:eebe135:             startBroker(startAsync);
1:0051c4e:             brokerRegistry.bind(getBrokerName(), BrokerService.this);
1:f21992e:         } catch (Exception e) {
1:56917c0:             LOG.error("Failed to start Apache ActiveMQ ({}, {})", getBrokerName(), brokerId, e);
1:1ec71bd:             try {
1:98497b1:                 if (!stopped.get()) {
1:98497b1:                     stop();
1:98497b1:                 }
1:1ec71bd:             } catch (Exception ex) {
1:c9cc85b:                 LOG.warn("Failed to stop broker after failure in start. This exception will be ignored.", ex);
1:98497b1:             }
1:364337b:             throw e;
1:7f89b33:         } finally {
1:3da9f1c:             MDC.remove("activemq.broker");
1:8610db3:         }
1:4098942:     }
1:f392884: 
1:ed58e9a:     private void startPersistenceAdapter(boolean async) throws Exception {
1:ed58e9a:         if (async) {
1:ed58e9a:             new Thread("Persistence Adapter Starting Thread") {
1:5cd9eba:                 @Override
1:ed58e9a:                 public void run() {
1:d14e4ae:                     try {
1:ed58e9a:                         doStartPersistenceAdapter();
1:1ec71bd:                     } catch (Throwable e) {
1:da076f4:                         setStartException(e);
1:ed58e9a:                     } finally {
1:35b82e5:                         synchronized (persistenceAdapterStarted) {
1:35b82e5:                             persistenceAdapterStarted.set(true);
1:35b82e5:                             persistenceAdapterStarted.notifyAll();
1:4098942:                         }
1:4098942:                     }
1:4098942:                 }
1:ed58e9a:             }.start();
1:ed58e9a:         } else {
1:ed58e9a:             doStartPersistenceAdapter();
1:2251ba0:         }
1:4098942:     }
1:2251ba0: 
1:ed58e9a:     private void doStartPersistenceAdapter() throws Exception {
1:455a628:         PersistenceAdapter persistenceAdapterToStart = getPersistenceAdapter();
1:455a628:         if (persistenceAdapterToStart == null) {
1:455a628:             checkStartException();
1:455a628:             throw new ConfigurationException("Cannot start null persistence adapter");
1:455a628:         }
1:455a628:         persistenceAdapterToStart.setUsageManager(getProducerSystemUsage());
1:455a628:         persistenceAdapterToStart.setBrokerName(getBrokerName());
1:455a628:         LOG.info("Using Persistence Adapter: {}", persistenceAdapterToStart);
1:ed58e9a:         if (deleteAllMessagesOnStartup) {
1:9c42236:             deleteAllMessages();
1:4098942:         }
1:455a628:         persistenceAdapterToStart.start();
1:c129051: 
1:768fa17:         getTempDataStore();
1:768fa17:         if (tempDataStore != null) {
1:768fa17:             try {
1:768fa17:                 // start after we have the store lock
1:768fa17:                 tempDataStore.start();
1:768fa17:             } catch (Exception e) {
1:768fa17:                 RuntimeException exception = new RuntimeException(
1:768fa17:                         "Failed to start temp data store: " + tempDataStore, e);
1:768fa17:                 LOG.error(exception.getLocalizedMessage(), e);
1:768fa17:                 throw exception;
1:768fa17:             }
1:768fa17:         }
1:768fa17: 
1:c129051:         getJobSchedulerStore();
1:c129051:         if (jobSchedulerStore != null) {
1:c129051:             try {
1:c129051:                 jobSchedulerStore.start();
1:d7febdd:             } catch (Exception e) {
1:c129051:                 RuntimeException exception = new RuntimeException(
1:c129051:                         "Failed to start job scheduler store: " + jobSchedulerStore, e);
1:c129051:                 LOG.error(exception.getLocalizedMessage(), e);
1:c129051:                 throw exception;
1:c129051:             }
1:c129051:         }
1:4098942:     }
1:f392884: 
1:ed58e9a:     private void startBroker(boolean async) throws Exception {
1:ed58e9a:         if (async) {
1:ed58e9a:             new Thread("Broker Starting Thread") {
1:5cd9eba:                 @Override
1:ed58e9a:                 public void run() {
1:4098942:                     try {
1:35b82e5:                         synchronized (persistenceAdapterStarted) {
1:35b82e5:                             if (!persistenceAdapterStarted.get()) {
1:35b82e5:                                 persistenceAdapterStarted.wait();
1:35b82e5:                             }
1:4098942:                         }
1:ed58e9a:                         doStartBroker();
1:ed58e9a:                     } catch (Throwable t) {
1:da076f4:                         setStartException(t);
1:4098942:                     }
1:4098942:                 }
1:ed58e9a:             }.start();
1:ed58e9a:         } else {
1:ed58e9a:             doStartBroker();
1:4098942:         }
1:4098942:     }
1:c7c8e53: 
1:ed58e9a:     private void doStartBroker() throws Exception {
1:da076f4:         checkStartException();
1:ed58e9a:         startDestinations();
1:ed58e9a:         addShutdownHook();
1:c9cc85b: 
1:c9cc85b:         broker = getBroker();
1:c9cc85b:         brokerId = broker.getBrokerId();
1:c9cc85b: 
1:c9cc85b:         // need to log this after creating the broker so we have its id and name
1:e1bbde7:         LOG.info("Apache ActiveMQ {} ({}, {}) is starting", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId });
1:c9cc85b:         broker.start();
1:c9cc85b: 
1:ed58e9a:         if (isUseJmx()) {
1:f0d9f83:             if (getManagementContext().isCreateConnector() && !getManagementContext().isConnectorStarted()) {
1:f0d9f83:                 // try to restart management context
1:f0d9f83:                 // typical for slaves that use the same ports as master
1:f0d9f83:                 managementContext.stop();
1:f0d9f83:                 startManagementContext();
1:c9cc85b:             }
1:1ec71bd:             ManagedRegionBroker managedBroker = (ManagedRegionBroker) regionBroker;
1:ed58e9a:             managedBroker.setContextBroker(broker);
1:f0d9f83:             adminView.setBroker(managedBroker);
1:f0d9f83:         }
1:39ff4d9: 
1:ed58e9a:         if (ioExceptionHandler == null) {
1:f0d9f83:             setIoExceptionHandler(new DefaultIOExceptionHandler());
1:2251ba0:         }
1:27c424c: 
1:25f1fe8:         if (isUseJmx() && Log4JConfigView.isLog4JAvailable()) {
1:25f1fe8:             ObjectName objectName = BrokerMBeanSupport.createLog4JConfigViewName(getBrokerObjectName().toString());
1:25f1fe8:             Log4JConfigView log4jConfigView = new Log4JConfigView();
1:25f1fe8:             AnnotatedMBean.registerMBean(getManagementContext(), log4jConfigView, objectName);
1:25f1fe8:         }
1:25f1fe8: 
1:27c424c:         startAllConnectors();
1:2251ba0: 
1:e1bbde7:         LOG.info("Apache ActiveMQ {} ({}, {}) started", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId});
1:e1bbde7:         LOG.info("For help or more information please see: http://activemq.apache.org");
1:2251ba0: 
1:25a252f:         getBroker().brokerServiceStarted();
1:d7febdd:         checkStoreSystemUsageLimits();
1:31c7e62:         startedLatch.countDown();
1:69d8258:         getBroker().nowMasterBroker();
1:4098942:     }
1:7ae2055: 
1:7d1e6bc:     /**
1:174fe15:      * JSR-250 callback wrapper; converts checked exceptions to runtime exceptions
1:98497b1:      *
1:174fe15:      * delegates to stop, done to prevent backwards incompatible signature change
1:174fe15:      */
1:174fe15:     @PreDestroy
1:174fe15:     private void preDestroy () {
1:174fe15:         try {
1:174fe15:             stop();
1:174fe15:         } catch (Exception ex) {
1:174fe15:             throw new RuntimeException();
1:174fe15:         }
1:174fe15:     }
1:174fe15: 
1:174fe15:     /**
1:1ec71bd:      *
1:09fab74:      * @throws Exception
1:09fab74:      * @org.apache .xbean.DestroyMethod
1:d29ca2a:      */
1:7ae2055:     @Override
1:62e1abf:     public void stop() throws Exception {
1:155461a:         final ServiceStopper stopper = new ServiceStopper();
1:155461a: 
1:2311749:         //The preShutdownHooks need to run before stopping.compareAndSet()
1:2311749:         //so there is a separate AtomicBoolean so the hooks only run once
1:2311749:         //We want to make sure the hooks are run before stop is initialized
1:2311749:         //including setting the stopping variable - See AMQ-6706
1:2311749:         if (preShutdownHooksInvoked.compareAndSet(false, true)) {
1:2311749:             for (Runnable hook : preShutdownHooks) {
1:2311749:                 try {
1:2311749:                     hook.run();
1:2311749:                 } catch (Throwable e) {
1:2311749:                     stopper.onException(hook, e);
1:2311749:                 }
1:155461a:             }
1:155461a:         }
1:155461a: 
1:4260034:         if (!stopping.compareAndSet(false, true)) {
1:4260034:             LOG.trace("Broker already stopping/stopped");
1:ed58e9a:             return;
1:4098942:         }
1:4228281: 
1:35df815:         setStartException(new BrokerStoppedException("Stop invoked"));
1:3da9f1c:         MDC.put("activemq.broker", brokerName);
1:4228281: 
1:1ec71bd:         if (systemExitOnShutdown) {
1:f0d9f83:             new Thread() {
1:f0d9f83:                 @Override
1:7ae2055:                 public void run() {
1:f0d9f83:                     System.exit(systemExitOnShutdownExitCode);
1:f0d9f83:                 }
1:f0d9f83:             }.start();
1:4098942:         }
1:98497b1: 
1:e1bbde7:         LOG.info("Apache ActiveMQ {} ({}, {}) is shutting down", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId} );
1:c1051c8: 
1:d29ca2a:         removeShutdownHook();
1:dcf1f5e:         if (this.scheduler != null) {
1:dcf1f5e:             this.scheduler.stop();
1:dcf1f5e:             this.scheduler = null;
1:dcf1f5e:         }
1:230a86c:         if (services != null) {
1:98497b1:             for (Service service : services) {
1:ee2462d:                 stopper.stop(service);
1:4098942:             }
1:4098942:         }
1:319966c:         stopAllConnectors(stopper);
1:d75e418:         this.slave = true;
1:803abe4:         // remove any VMTransports connected
1:803abe4:         // this has to be done after services are stopped,
1:eea9fca:         // to avoid timing issue with discovery (spinning up a new instance)
1:803abe4:         BrokerRegistry.getInstance().unbind(getBrokerName());
1:1ec71bd:         VMTransportFactory.stopped(getBrokerName());
1:3a9299b:         if (broker != null) {
1:d29ca2a:             stopper.stop(broker);
1:3559363:             broker = null;
1:3a9299b:         }
1:3559363: 
1:f21992e:         if (jobSchedulerStore != null) {
1:f21992e:             jobSchedulerStore.stop();
1:f21992e:             jobSchedulerStore = null;
1:f21992e:         }
1:230a86c:         if (tempDataStore != null) {
1:ee55abb:             tempDataStore.stop();
1:3559363:             tempDataStore = null;
1:3a9299b:         }
1:155461a:         try {
1:da076f4:             stopper.stop(getPersistenceAdapter());
1:2030097:             persistenceAdapter = null;
1:2030097:             if (isUseJmx()) {
1:35df815:                 stopper.stop(managementContext);
1:2030097:                 managementContext = null;
1:2030097:             }
1:2030097:             // Clear SelectorParser cache to free memory
1:2030097:             SelectorParser.clearCache();
1:2030097:         } finally {
1:d21b32e:             started.set(false);
1:2030097:             stopped.set(true);
1:2030097:             stoppedLatch.countDown();
1:98497b1:         }
1:39ff4d9: 
1:1a5ad28:         if (this.taskRunnerFactory != null) {
1:1a5ad28:             this.taskRunnerFactory.shutdown();
1:3559363:             this.taskRunnerFactory = null;
1:1a5ad28:         }
1:1a5ad28:         if (this.executor != null) {
1:6c1676b:             ThreadPoolUtils.shutdownNow(executor);
1:3559363:             this.executor = null;
1:1a5ad28:         }
1:3559363: 
1:3559363:         this.destinationInterceptors = null;
1:3559363:         this.destinationFactory = null;
1:3559363: 
1:e1bbde7:         if (startDate != null) {
1:e1bbde7:             LOG.info("Apache ActiveMQ {} ({}, {}) uptime {}", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId, getUptime()});
1:f2225c2:         }
1:e1bbde7:         LOG.info("Apache ActiveMQ {} ({}, {}) is shutdown", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId});
1:2251ba0: 
1:1ec71bd:         synchronized (shutdownHooks) {
1:b4f65ba:             for (Runnable hook : shutdownHooks) {
1:1ec71bd:                 try {
1:155461a:                     hook.run();
1:155461a:                 } catch (Throwable e) {
1:155461a:                     stopper.onException(hook, e);
1:2251ba0:                 }
1:98497b1:             }
1:98497b1:         }
1:c1051c8: 
1:3da9f1c:         MDC.remove("activemq.broker");
1:c1051c8: 
1:f2225c2:         // and clear start date
1:f2225c2:         startDate = null;
1:f2225c2: 
1:d29ca2a:         stopper.throwFirstException();
1:98497b1:     }
1:f0d9f83: 
1:d3fb1aa:     public boolean checkQueueSize(String queueName) {
1:98497b1:         long count = 0;
1:98497b1:         long queueSize = 0;
1:98497b1:         Map<ActiveMQDestination, Destination> destinationMap = regionBroker.getDestinationMap();
1:98497b1:         for (Map.Entry<ActiveMQDestination, Destination> entry : destinationMap.entrySet()) {
1:98497b1:             if (entry.getKey().isQueue()) {
1:98497b1:                 if (entry.getValue().getName().matches(queueName)) {
1:98497b1:                     queueSize = entry.getValue().getDestinationStatistics().getMessages().getCount();
1:ea0ceac:                     count += queueSize;
1:98497b1:                     if (queueSize > 0) {
1:e1bbde7:                         LOG.info("Queue has pending message: {} queueSize is: {}", entry.getValue().getName(), queueSize);
1:98497b1:                     }
1:98497b1:                 }
1:98497b1:             }
1:98497b1:         }
1:98497b1:         return count == 0;
1:98497b1:     }
1:98497b1: 
1:98497b1:     /**
1:98497b1:      * This method (both connectorName and queueName are using regex to match)
1:98497b1:      * 1. stop the connector (supposed the user input the connector which the
1:98497b1:      * clients connect to) 2. to check whether there is any pending message on
1:98497b1:      * the queues defined by queueName 3. supposedly, after stop the connector,
1:98497b1:      * client should failover to other broker and pending messages should be
1:98497b1:      * forwarded. if no pending messages, the method finally call stop to stop
1:98497b1:      * the broker.
1:f0d9f83:      *
1:98497b1:      * @param connectorName
1:98497b1:      * @param queueName
1:98497b1:      * @param timeout
1:98497b1:      * @param pollInterval
1:98497b1:      * @throws Exception
1:98497b1:      */
1:3cd8da8:     public void stopGracefully(String connectorName, String queueName, long timeout, long pollInterval) throws Exception {
1:98497b1:         if (isUseJmx()) {
1:98497b1:             if (connectorName == null || queueName == null || timeout <= 0) {
1:98497b1:                 throw new Exception(
1:98497b1:                         "connectorName and queueName cannot be null and timeout should be >0 for stopGracefully.");
1:98497b1:             }
1:98497b1:             if (pollInterval <= 0) {
1:98497b1:                 pollInterval = 30;
1:98497b1:             }
1:e1bbde7:             LOG.info("Stop gracefully with connectorName: {} queueName: {} timeout: {} pollInterval: {}", new Object[]{
1:e1bbde7:                     connectorName, queueName, timeout, pollInterval
1:e1bbde7:             });
1:98497b1:             TransportConnector connector;
1:98497b1:             for (int i = 0; i < transportConnectors.size(); i++) {
1:98497b1:                 connector = transportConnectors.get(i);
1:98497b1:                 if (connector != null && connector.getName() != null && connector.getName().matches(connectorName)) {
1:98497b1:                     connector.stop();
1:98497b1:                 }
1:98497b1:             }
1:98497b1:             long start = System.currentTimeMillis();
1:98497b1:             while (System.currentTimeMillis() - start < timeout * 1000) {
1:98497b1:                 // check quesize until it gets zero
1:98497b1:                 if (checkQueueSize(queueName)) {
1:98497b1:                     stop();
1:f392884:                     break;
1:98497b1:                 } else {
1:98497b1:                     Thread.sleep(pollInterval * 1000);
1:98497b1:                 }
1:98497b1:             }
1:98497b1:             if (stopped.get()) {
1:98497b1:                 LOG.info("Successfully stop the broker.");
1:98497b1:             } else {
1:98497b1:                 LOG.info("There is still pending message on the queue. Please check and stop the broker manually.");
1:98497b1:             }
1:98497b1:         }
1:98497b1:     }
1:1ec71bd: 
1:4098942:     /**
1:31c7e62:      * A helper method to block the caller thread until the broker has been
1:230a86c:      * stopped
1:31c7e62:      */
1:44bafc3:     public void waitUntilStopped() {
1:31c7e62:         while (isStarted() && !stopped.get()) {
1:31c7e62:             try {
1:44bafc3:                 stoppedLatch.await();
1:1ec71bd:             } catch (InterruptedException e) {
1:44bafc3:                 // ignore
1:78035ea:             }
1:4098942:         }
1:6b1ffae:     }
1:1ec71bd: 
1:ed8e4ea:     public boolean isStopped() {
1:ed8e4ea:         return stopped.get();
1:ed8e4ea:     }
1:ed8e4ea: 
1:4098942:     /**
1:956c3e0:      * A helper method to block the caller thread until the broker has fully started
1:956c3e0:      * @return boolean true if wait succeeded false if broker was not started or was stopped
1:d29ca2a:      */
1:956c3e0:     public boolean waitUntilStarted() {
1:6521549:         return waitUntilStarted(DEFAULT_START_TIMEOUT);
1:5016c4d:     }
1:5016c4d: 
1:5016c4d:     /**
1:5016c4d:      * A helper method to block the caller thread until the broker has fully started
1:5016c4d:      *
1:5016c4d:      * @param timeout
1:5016c4d:      *        the amount of time to wait before giving up and returning false.
1:5016c4d:      *
1:5016c4d:      * @return boolean true if wait succeeded false if broker was not started or was stopped
1:5016c4d:      */
1:5016c4d:     public boolean waitUntilStarted(long timeout) {
1:d0fb549:         boolean waitSucceeded = isStarted();
1:5016c4d:         long expiration = Math.max(0, timeout + System.currentTimeMillis());
1:5016c4d:         while (!isStarted() && !stopped.get() && !waitSucceeded && expiration > System.currentTimeMillis()) {
1:4098942:             try {
1:da076f4:                 if (getStartException() != null) {
1:7f89b33:                     return waitSucceeded;
1:ed58e9a:                 }
1:31c7e62:                 waitSucceeded = startedLatch.await(100L, TimeUnit.MILLISECONDS);
1:31c7e62:             } catch (InterruptedException ignore) {
1:31c7e62:             }
1:31c7e62:         }
1:956c3e0:         return waitSucceeded;
1:31c7e62:     }
1:31c7e62: 
1:d29ca2a:     // Properties
1:d29ca2a:     // -------------------------------------------------------------------------
1:4098942:     /**
1:8ad6fd3:      * Returns the message broker
1:d29ca2a:      */
1:d29ca2a:     public Broker getBroker() throws Exception {
1:d29ca2a:         if (broker == null) {
1:da076f4:             checkStartException();
1:d29ca2a:             broker = createBroker();
1:2251ba0:         }
1:d29ca2a:         return broker;
1:ed58e9a:     }
1:1ec71bd: 
1:4098942:     /**
1:230a86c:      * Returns the administration view of the broker; used to create and destroy
1:230a86c:      * resources such as queues and topics. Note this method returns null if JMX
1:230a86c:      * is disabled.
1:d29ca2a:      */
1:8ad6fd3:     public BrokerView getAdminView() throws Exception {
1:8ad6fd3:         if (adminView == null) {
1:8ad6fd3:             // force lazy creation
1:8ad6fd3:             getBroker();
1:ed58e9a:         }
1:8ad6fd3:         return adminView;
1:ed58e9a:     }
1:d14e4ae: 
1:8ad6fd3:     public void setAdminView(BrokerView adminView) {
1:8ad6fd3:         this.adminView = adminView;
1:ed58e9a:     }
1:d14e4ae: 
1:d29ca2a:     public String getBrokerName() {
1:d29ca2a:         return brokerName;
1:ed58e9a:     }
1:d14e4ae: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the name of this broker; which must be unique in the network
1:f0d9f83:      *
1:64b8fb6:      * @param brokerName
1:d29ca2a:      */
1:b0c0441:     private static final String brokerNameReplacedCharsRegExp = "[^a-zA-Z0-9\\.\\_\\-\\:]";
1:d29ca2a:     public void setBrokerName(String brokerName) {
1:bc03f37:         if (brokerName == null) {
1:bc03f37:             throw new NullPointerException("The broker name cannot be null");
1:bc03f37:         }
1:b0c0441:         String str = brokerName.replaceAll(brokerNameReplacedCharsRegExp, "_");
1:64b8fb6:         if (!str.equals(brokerName)) {
1:b0c0441:             LOG.error("Broker Name: {} contained illegal characters matching regExp: {} - replaced with {}", brokerName, brokerNameReplacedCharsRegExp, str);
1:64b8fb6:         }
1:64b8fb6:         this.brokerName = str.trim();
1:ed58e9a:     }
1:620b657: 
1:609681a:     public PersistenceAdapterFactory getPersistenceFactory() {
1:d29ca2a:         return persistenceFactory;
1:ed58e9a:     }
1:16f2d75: 
1:9dccfa4:     public File getDataDirectoryFile() {
1:9dccfa4:         if (dataDirectoryFile == null) {
1:9dccfa4:             dataDirectoryFile = new File(IOHelper.getDefaultDataDirectory());
1:7f89b33:         }
1:9dccfa4:         return dataDirectoryFile;
1:7f89b33:     }
1:e4621e3: 
1:82201d2:     public File getBrokerDataDirectory() {
1:64b8fb6:         String brokerDir = getBrokerName();
1:9dccfa4:         return new File(getDataDirectoryFile(), brokerDir);
1:7f89b33:     }
1:88fbb05: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the directory in which the data files will be stored by default for
1:d29ca2a:      * the JDBC and Journal persistence adaptors.
1:f0d9f83:      *
1:1ec71bd:      * @param dataDirectory
1:1ec71bd:      *            the directory to store data files
1:d29ca2a:      */
1:9dccfa4:     public void setDataDirectory(String dataDirectory) {
1:9dccfa4:         setDataDirectoryFile(new File(dataDirectory));
1:7f89b33:     }
1:c427689: 
1:d29ca2a:     /**
1:9dccfa4:      * Sets the directory in which the data files will be stored by default for
1:9dccfa4:      * the JDBC and Journal persistence adaptors.
1:f0d9f83:      *
1:1ec71bd:      * @param dataDirectoryFile
1:1ec71bd:      *            the directory to store data files
1:d29ca2a:      */
1:9dccfa4:     public void setDataDirectoryFile(File dataDirectoryFile) {
1:9dccfa4:         this.dataDirectoryFile = dataDirectoryFile;
1:7f89b33:     }
1:5f4db41: 
1:d29ca2a:     /**
1:7d1e6bc:      * @return the tmpDataDirectory
1:7d1e6bc:      */
1:230a86c:     public File getTmpDataDirectory() {
1:7d1e6bc:         if (tmpDataDirectory == null) {
1:82201d2:             tmpDataDirectory = new File(getBrokerDataDirectory(), "tmp_storage");
1:7d1e6bc:         }
1:7d1e6bc:         return tmpDataDirectory;
1:7d1e6bc:     }
1:5f4db41: 
1:7d1e6bc:     /**
1:1ec71bd:      * @param tmpDataDirectory
1:1ec71bd:      *            the tmpDataDirectory to set
1:7d1e6bc:      */
1:230a86c:     public void setTmpDataDirectory(File tmpDataDirectory) {
1:230a86c:         this.tmpDataDirectory = tmpDataDirectory;
1:7d1e6bc:     }
1:5f4db41: 
1:609681a:     public void setPersistenceFactory(PersistenceAdapterFactory persistenceFactory) {
1:d29ca2a:         this.persistenceFactory = persistenceFactory;
1:7f89b33:     }
1:64b8fb6: 
1:9d4c74f:     public void setDestinationFactory(DestinationFactory destinationFactory) {
1:9d4c74f:         this.destinationFactory = destinationFactory;
1:9d4c74f:     }
1:83a6eff: 
1:d29ca2a:     public boolean isPersistent() {
1:d29ca2a:         return persistent;
1:6f70393:     }
1:83a6eff: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets whether or not persistence is enabled or disabled.
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:d29ca2a:      */
1:d29ca2a:     public void setPersistent(boolean persistent) {
1:d29ca2a:         this.persistent = persistent;
1:2a2dcd5:     }
1:25a252f: 
1:d29ca2a:     public boolean isPopulateJMSXUserID() {
1:d29ca2a:         return populateJMSXUserID;
1:996b7a5:     }
1:25a252f: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets whether or not the broker should populate the JMSXUserID header.
1:d29ca2a:      */
1:d29ca2a:     public void setPopulateJMSXUserID(boolean populateJMSXUserID) {
1:d29ca2a:         this.populateJMSXUserID = populateJMSXUserID;
1:6d8e2c5:     }
1:a3e3821: 
1:2b0024c:     public SystemUsage getSystemUsage() {
1:6d8e2c5:         try {
1:2b0024c:             if (systemUsage == null) {
1:f21992e: 
1:f21992e:                 systemUsage = new SystemUsage("Main", getPersistenceAdapter(), getTempDataStore(), getJobSchedulerStore());
1:1a5ad28:                 systemUsage.setExecutor(getExecutor());
1:5bdcc19:                 systemUsage.getMemoryUsage().setLimit(1024L * 1024 * 1024 * 1); // 1 GB
1:ca728c0:                 systemUsage.getTempUsage().setLimit(1024L * 1024 * 1024 * 50); // 50 GB
1:ca728c0:                 systemUsage.getStoreUsage().setLimit(1024L * 1024 * 1024 * 100); // 100 GB
1:5bdcc19:                 systemUsage.getJobSchedulerUsage().setLimit(1024L * 1024 * 1024 * 50); // 50 GB
1:2cb2119:                 addService(this.systemUsage);
1:996b7a5:             }
1:2b0024c:             return systemUsage;
1:61fd811:         } catch (IOException e) {
1:8bf987b:             LOG.error("Cannot create SystemUsage", e);
1:3630a41:             throw new RuntimeException("Fatally failed to create SystemUsage" + e.getMessage(), e);
1:20118f2:         }
1:20118f2:     }
1:0d9b413: 
1:2b0024c:     public void setSystemUsage(SystemUsage memoryManager) {
1:2cb2119:         if (this.systemUsage != null) {
1:2cb2119:             removeService(this.systemUsage);
1:2cb2119:         }
1:2b0024c:         this.systemUsage = memoryManager;
1:1a5ad28:         if (this.systemUsage.getExecutor()==null) {
1:1a5ad28:             this.systemUsage.setExecutor(getExecutor());
1:1a5ad28:         }
1:2cb2119:         addService(this.systemUsage);
1:20118f2:     }
1:14c605f: 
1:d29ca2a:     /**
1:14c605f:      * @return the consumerUsageManager
1:1ec71bd:      * @throws IOException
1:14c605f:      */
1:6d8e2c5:     public SystemUsage getConsumerSystemUsage() throws IOException {
1:f472000:         if (this.consumerSystemUsaage == null) {
1:1ec71bd:             if (splitSystemUsageForProducersConsumers) {
1:c427689:                 this.consumerSystemUsaage = new SystemUsage(getSystemUsage(), "Consumer");
1:1ec71bd:                 float portion = consumerSystemUsagePortion / 100f;
1:c427689:                 this.consumerSystemUsaage.getMemoryUsage().setUsagePortion(portion);
1:c427689:                 addService(this.consumerSystemUsaage);
1:98497b1:             } else {
1:1ec71bd:                 consumerSystemUsaage = getSystemUsage();
1:c427689:             }
1:14c605f:         }
1:f472000:         return this.consumerSystemUsaage;
1:14c605f:     }
1:14c605f: 
1:14c605f:     /**
1:1ec71bd:      * @param consumerSystemUsaage
1:1ec71bd:      *            the storeSystemUsage to set
1:14c605f:      */
1:f472000:     public void setConsumerSystemUsage(SystemUsage consumerSystemUsaage) {
1:f472000:         if (this.consumerSystemUsaage != null) {
1:f472000:             removeService(this.consumerSystemUsaage);
1:11705e7:         }
1:f472000:         this.consumerSystemUsaage = consumerSystemUsaage;
2:f472000:         addService(this.consumerSystemUsaage);
1:e8a641c:     }
1:14c605f: 
1:14c605f:     /**
1:14c605f:      * @return the producerUsageManager
1:1ec71bd:      * @throws IOException
1:14c605f:      */
1:6d8e2c5:     public SystemUsage getProducerSystemUsage() throws IOException {
1:1ec71bd:         if (producerSystemUsage == null) {
1:c427689:             if (splitSystemUsageForProducersConsumers) {
1:c427689:                 producerSystemUsage = new SystemUsage(getSystemUsage(), "Producer");
1:1ec71bd:                 float portion = producerSystemUsagePortion / 100f;
1:c427689:                 producerSystemUsage.getMemoryUsage().setUsagePortion(portion);
1:c427689:                 addService(producerSystemUsage);
1:1ec71bd:             } else {
1:1ec71bd:                 producerSystemUsage = getSystemUsage();
1:c427689:             }
1:14c605f:         }
1:6d8e2c5:         return producerSystemUsage;
1:14c605f:     }
1:14c605f: 
1:14c605f:     /**
1:1ec71bd:      * @param producerUsageManager
1:1ec71bd:      *            the producerUsageManager to set
1:14c605f:      */
1:6d8e2c5:     public void setProducerSystemUsage(SystemUsage producerUsageManager) {
1:2cb2119:         if (this.producerSystemUsage != null) {
1:2cb2119:             removeService(this.producerSystemUsage);
1:2cb2119:         }
1:6d8e2c5:         this.producerSystemUsage = producerUsageManager;
1:2cb2119:         addService(this.producerSystemUsage);
1:14c605f:     }
1:14c605f: 
1:da076f4:     public synchronized PersistenceAdapter getPersistenceAdapter() throws IOException {
1:35df815:         if (persistenceAdapter == null && !hasStartException()) {
1:d29ca2a:             persistenceAdapter = createPersistenceAdapter();
1:90d0c4b:             configureService(persistenceAdapter);
1:5f4db41:             this.persistenceAdapter = registerPersistenceAdapterMBean(persistenceAdapter);
1:e8a641c:         }
1:d29ca2a:         return persistenceAdapter;
1:e8a641c:     }
1:14c605f: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the persistence adaptor implementation to use for this broker
1:f0d9f83:      *
1:1ec71bd:      * @throws IOException
1:d29ca2a:      */
1:5f4db41:     public void setPersistenceAdapter(PersistenceAdapter persistenceAdapter) throws IOException {
1:ae816dc:         if (!isPersistent() && ! (persistenceAdapter instanceof MemoryPersistenceAdapter)) {
1:e1bbde7:             LOG.warn("persistent=\"false\", ignoring configured persistenceAdapter: {}", persistenceAdapter);
1:ae816dc:             return;
1:ae816dc:         }
1:d29ca2a:         this.persistenceAdapter = persistenceAdapter;
1:a3b4c5a:         configureService(this.persistenceAdapter);
1:5f4db41:         this.persistenceAdapter = registerPersistenceAdapterMBean(persistenceAdapter);
1:f528aa5:     }
1:5f4db41: 
1:d29ca2a:     public TaskRunnerFactory getTaskRunnerFactory() {
1:1a5ad28:         if (this.taskRunnerFactory == null) {
1:c659506:             this.taskRunnerFactory = new TaskRunnerFactory("ActiveMQ BrokerService["+getBrokerName()+"] Task", getTaskRunnerPriority(), true, 1000,
1:1ec71bd:                     isDedicatedTaskRunner());
1:dffccb1:             this.taskRunnerFactory.setThreadClassLoader(this.getClass().getClassLoader());
1:f528aa5:         }
1:1a5ad28:         return this.taskRunnerFactory;
1:f528aa5:     }
1:14c605f: 
1:d29ca2a:     public void setTaskRunnerFactory(TaskRunnerFactory taskRunnerFactory) {
1:d29ca2a:         this.taskRunnerFactory = taskRunnerFactory;
1:b3873fb:     }
1:14c605f: 
1:230a86c:     public TaskRunnerFactory getPersistenceTaskRunnerFactory() {
1:3fe77a2:         if (taskRunnerFactory == null) {
1:1ec71bd:             persistenceTaskRunnerFactory = new TaskRunnerFactory("Persistence Adaptor Task", persistenceThreadPriority,
1:c808beb:                     true, 1000, isDedicatedTaskRunner());
1:3fe77a2:         }
1:3fe77a2:         return persistenceTaskRunnerFactory;
1:3fe77a2:     }
1:14c605f: 
1:230a86c:     public void setPersistenceTaskRunnerFactory(TaskRunnerFactory persistenceTaskRunnerFactory) {
1:230a86c:         this.persistenceTaskRunnerFactory = persistenceTaskRunnerFactory;
1:3fe77a2:     }
1:14c605f: 
1:d29ca2a:     public boolean isUseJmx() {
1:d29ca2a:         return useJmx;
1:b3873fb:     }
1:14c605f: 
1:ccf3f3c:     public boolean isEnableStatistics() {
1:ccf3f3c:         return enableStatistics;
1:62e1abf:     }
1:0c0be94: 
1:d29ca2a:     /**
1:230a86c:      * Sets whether or not the Broker's services enable statistics or not.
1:d29ca2a:      */
1:ccf3f3c:     public void setEnableStatistics(boolean enableStatistics) {
1:ccf3f3c:         this.enableStatistics = enableStatistics;
1:ec9975c:     }
1:81c5b15: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets whether or not the Broker's services should be exposed into JMX or
1:d29ca2a:      * not.
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:d29ca2a:      */
1:d29ca2a:     public void setUseJmx(boolean useJmx) {
1:d29ca2a:         this.useJmx = useJmx;
1:ec9975c:     }
1:81c5b15: 
1:c37859a:     public ObjectName getBrokerObjectName() throws MalformedObjectNameException {
1:d29ca2a:         if (brokerObjectName == null) {
1:d29ca2a:             brokerObjectName = createBrokerObjectName();
1:4a16c1f:         }
1:d29ca2a:         return brokerObjectName;
1:4a16c1f:     }
1:bc03f37: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the JMX ObjectName for this broker
1:d29ca2a:      */
1:d29ca2a:     public void setBrokerObjectName(ObjectName brokerObjectName) {
1:d29ca2a:         this.brokerObjectName = brokerObjectName;
1:4a16c1f:     }
1:bc03f37: 
1:d29ca2a:     public ManagementContext getManagementContext() {
1:d29ca2a:         if (managementContext == null) {
1:da076f4:             checkStartException();
1:d29ca2a:             managementContext = new ManagementContext();
1:4a16c1f:         }
1:d29ca2a:         return managementContext;
1:139a220:     }
1:bc03f37: 
1:da076f4:     synchronized private void checkStartException() {
1:da076f4:         if (startException != null) {
1:da076f4:             throw new BrokerStoppedException(startException);
1:da076f4:         }
1:da076f4:     }
1:da076f4: 
1:35df815:     synchronized private boolean hasStartException() {
1:35df815:         return startException != null;
1:35df815:     }
1:35df815: 
1:da076f4:     synchronized private void setStartException(Throwable t) {
1:da076f4:         startException = t;
1:da076f4:     }
1:da076f4: 
1:d29ca2a:     public void setManagementContext(ManagementContext managementContext) {
1:d29ca2a:         this.managementContext = managementContext;
1:ed58e9a:     }
1:bc03f37: 
1:e2ef8b8:     public NetworkConnector getNetworkConnectorByName(String connectorName) {
1:1ec71bd:         for (NetworkConnector connector : networkConnectors) {
1:1ec71bd:             if (connector.getName().equals(connectorName)) {
1:e2ef8b8:                 return connector;
1:e2ef8b8:             }
1:e2ef8b8:         }
1:e2ef8b8:         return null;
1:e2ef8b8:     }
1:e2ef8b8: 
1:d29ca2a:     public String[] getNetworkConnectorURIs() {
1:d29ca2a:         return networkConnectorURIs;
1:ed58e9a:     }
1:bc03f37: 
1:d29ca2a:     public void setNetworkConnectorURIs(String[] networkConnectorURIs) {
1:d29ca2a:         this.networkConnectorURIs = networkConnectorURIs;
1:7f89b33:     }
1:3a9299b: 
1:e2ef8b8:     public TransportConnector getConnectorByName(String connectorName) {
1:1ec71bd:         for (TransportConnector connector : transportConnectors) {
1:1ec71bd:             if (connector.getName().equals(connectorName)) {
1:e2ef8b8:                 return connector;
1:e2ef8b8:             }
1:e2ef8b8:         }
1:e2ef8b8:         return null;
1:e2ef8b8:     }
1:e2ef8b8: 
1:c1051c8:     public Map<String, String> getTransportConnectorURIsAsMap() {
1:56917c0:         Map<String, String> answer = new HashMap<>();
1:c1051c8:         for (TransportConnector connector : transportConnectors) {
1:c1051c8:             try {
1:c1051c8:                 URI uri = connector.getConnectUri();
1:ddca4cf:                 if (uri != null) {
1:ddca4cf:                     String scheme = uri.getScheme();
1:ddca4cf:                     if (scheme != null) {
1:4b44d31:                         answer.put(scheme.toLowerCase(Locale.ENGLISH), uri.toString());
1:ddca4cf:                     }
1:c1051c8:                 }
1:ee55abb:             } catch (Exception e) {
1:c1051c8:                 LOG.debug("Failed to read URI to build transportURIsAsMap", e);
1:c1051c8:             }
1:c1051c8:         }
1:c1051c8:         return answer;
1:c1051c8:     }
1:3a9299b: 
1:0736953:     public ProducerBrokerExchange getProducerBrokerExchange(ProducerInfo producerInfo){
1:0736953:         ProducerBrokerExchange result = null;
1:0736953: 
1:0736953:         for (TransportConnector connector : transportConnectors) {
1:0736953:             for (TransportConnection tc: connector.getConnections()){
1:0736953:                 result = tc.getProducerBrokerExchangeIfExists(producerInfo);
1:0736953:                 if (result !=null){
1:0736953:                     return result;
1:0736953:                 }
1:0736953:             }
1:0736953:         }
1:0736953:         return result;
1:0736953:     }
1:0736953: 
1:d29ca2a:     public String[] getTransportConnectorURIs() {
1:d29ca2a:         return transportConnectorURIs;
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     public void setTransportConnectorURIs(String[] transportConnectorURIs) {
1:d29ca2a:         this.transportConnectorURIs = transportConnectorURIs;
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the jmsBridgeConnectors.
1:d29ca2a:      */
1:230a86c:     public JmsConnector[] getJmsBridgeConnectors() {
1:d29ca2a:         return jmsBridgeConnectors;
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     /**
1:1ec71bd:      * @param jmsConnectors
1:1ec71bd:      *            The jmsBridgeConnectors to set.
1:d29ca2a:      */
1:230a86c:     public void setJmsBridgeConnectors(JmsConnector[] jmsConnectors) {
1:230a86c:         this.jmsBridgeConnectors = jmsConnectors;
1:7f89b33:     }
1:3fe77a2: 
1:ee2462d:     public Service[] getServices() {
1:7ae2055:         return services.toArray(new Service[0]);
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     /**
1:30f531d:      * Sets the services associated with this broker.
1:d29ca2a:      */
1:ee2462d:     public void setServices(Service[] services) {
1:2cb2119:         this.services.clear();
1:2cb2119:         if (services != null) {
1:1ec71bd:             for (int i = 0; i < services.length; i++) {
1:2cb2119:                 this.services.add(services[i]);
1:2cb2119:             }
1:2cb2119:         }
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     /**
1:230a86c:      * Adds a new service so that it will be started as part of the broker
1:230a86c:      * lifecycle
1:d29ca2a:      */
1:ee2462d:     public void addService(Service service) {
1:2cb2119:         services.add(service);
1:2cb2119:     }
1:1ec71bd: 
1:2cb2119:     public void removeService(Service service) {
1:2cb2119:         services.remove(service);
1:7f89b33:     }
1:2cb2119: 
1:d29ca2a:     public boolean isUseLoggingForShutdownErrors() {
1:d29ca2a:         return useLoggingForShutdownErrors;
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets whether or not we should use commons-logging when reporting errors
1:d29ca2a:      * when shutting down the broker
1:d29ca2a:      */
1:d29ca2a:     public void setUseLoggingForShutdownErrors(boolean useLoggingForShutdownErrors) {
1:d29ca2a:         this.useLoggingForShutdownErrors = useLoggingForShutdownErrors;
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     public boolean isUseShutdownHook() {
1:d29ca2a:         return useShutdownHook;
1:7f89b33:     }
1:3fe77a2: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets whether or not we should use a shutdown handler to close down the
1:d29ca2a:      * broker cleanly if the JVM is terminated. It is recommended you leave this
1:d29ca2a:      * enabled.
1:d29ca2a:      */
1:d29ca2a:     public void setUseShutdownHook(boolean useShutdownHook) {
1:d29ca2a:         this.useShutdownHook = useShutdownHook;
1:139a220:     }
1:3fe77a2: 
1:466ccdd:     public boolean isAdvisorySupport() {
1:466ccdd:         return advisorySupport;
1:139a220:     }
1:3fe77a2: 
1:d29ca2a:     /**
1:230a86c:      * Allows the support of advisory messages to be disabled for performance
1:230a86c:      * reasons.
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:42b768a:      */
1:466ccdd:     public void setAdvisorySupport(boolean advisorySupport) {
1:466ccdd:         this.advisorySupport = advisorySupport;
1:139a220:     }
1:7d1e6bc: 
1:ecf89a6:     public List<TransportConnector> getTransportConnectors() {
1:56917c0:         return new ArrayList<>(transportConnectors);
1:b4f65ba:     }
1:7d1e6bc: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the transport connectors which this broker will listen on for new
1:d29ca2a:      * clients
1:f0d9f83:      *
1:f0d9f83:      * @org.apache.xbean.Property
1:1ec71bd:      *                            nestedType="org.apache.activemq.broker.TransportConnector"
1:d29ca2a:      */
1:ecf89a6:     public void setTransportConnectors(List<TransportConnector> transportConnectors) throws Exception {
1:3cd8da8:         for (TransportConnector connector : transportConnectors) {
1:d29ca2a:             addConnector(connector);
1:b4f65ba:         }
1:b4f65ba:     }
1:7d1e6bc: 
1:74bed6b:     public TransportConnector getTransportConnectorByName(String name){
1:3cd8da8:         for (TransportConnector transportConnector : transportConnectors){
1:74bed6b:            if (name.equals(transportConnector.getName())){
1:74bed6b:                return transportConnector;
1:74bed6b:            }
1:74bed6b:         }
1:74bed6b:         return null;
1:74bed6b:     }
1:74bed6b: 
1:74bed6b:     public TransportConnector getTransportConnectorByScheme(String scheme){
1:3cd8da8:         for (TransportConnector transportConnector : transportConnectors){
1:74bed6b:             if (scheme.equals(transportConnector.getUri().getScheme())){
1:74bed6b:                 return transportConnector;
1:74bed6b:             }
1:74bed6b:         }
1:74bed6b:         return null;
1:74bed6b:     }
1:74bed6b: 
1:ecf89a6:     public List<NetworkConnector> getNetworkConnectors() {
1:56917c0:         return new ArrayList<>(networkConnectors);
1:b4f65ba:     }
1:7d1e6bc: 
1:ecf89a6:     public List<ProxyConnector> getProxyConnectors() {
1:56917c0:         return new ArrayList<>(proxyConnectors);
1:b4f65ba:     }
1:7d1e6bc: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the network connectors which this broker will use to connect to
1:d29ca2a:      * other brokers in a federated network
1:f0d9f83:      *
1:f0d9f83:      * @org.apache.xbean.Property
1:1ec71bd:      *                            nestedType="org.apache.activemq.network.NetworkConnector"
1:d29ca2a:      */
1:3cd8da8:     public void setNetworkConnectors(List<?> networkConnectors) throws Exception {
1:3cd8da8:         for (Object connector : networkConnectors) {
1:3cd8da8:             addNetworkConnector((NetworkConnector) connector);
1:b4f65ba:         }
1:b4f65ba:     }
1:9d4c74f: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the network connectors which this broker will use to connect to
1:d29ca2a:      * other brokers in a federated network
1:d29ca2a:      */
1:3cd8da8:     public void setProxyConnectors(List<?> proxyConnectors) throws Exception {
1:3cd8da8:         for (Object connector : proxyConnectors) {
1:3cd8da8:             addProxyConnector((ProxyConnector) connector);
1:b4f65ba:         }
1:b4f65ba:     }
1:9d4c74f: 
1:d29ca2a:     public PolicyMap getDestinationPolicy() {
1:d29ca2a:         return destinationPolicy;
1:b4f65ba:     }
1:9d4c74f: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the destination specific policies available either for exact
1:d29ca2a:      * destinations or for wildcard areas of destinations.
1:d29ca2a:      */
1:d29ca2a:     public void setDestinationPolicy(PolicyMap policyMap) {
1:d29ca2a:         this.destinationPolicy = policyMap;
1:b4f65ba:     }
1:8610db3: 
1:4686ec5:     public BrokerPlugin[] getPlugins() {
1:4686ec5:         return plugins;
1:2b0024c:     }
1:8610db3: 
1:d29ca2a:     /**
1:230a86c:      * Sets a number of broker plugins to install such as for security
1:230a86c:      * authentication or authorization
1:d29ca2a:      */
1:4686ec5:     public void setPlugins(BrokerPlugin[] plugins) {
1:4686ec5:         this.plugins = plugins;
1:230a86c:     }
1:9c42236: 
1:a640ff5:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {
1:a640ff5:         return messageAuthorizationPolicy;
1:230a86c:     }
1:8610db3: 
1:9c42236:     /**
1:230a86c:      * Sets the policy used to decide if the current connection is authorized to
1:230a86c:      * consume a given message
1:9dccfa4:      */
1:a640ff5:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {
1:a640ff5:         this.messageAuthorizationPolicy = messageAuthorizationPolicy;
1:230a86c:     }
1:4098942: 
1:d29ca2a:     /**
1:9c42236:      * Delete all messages from the persistent store
1:f0d9f83:      *
1:5f4db41:      * @throws IOException
1:9c42236:      */
1:230a86c:     public void deleteAllMessages() throws IOException {
1:9fd9189:         getPersistenceAdapter().deleteAllMessages();
1:9fd9189:     }
1:4098942: 
1:d29ca2a:     public boolean isDeleteAllMessagesOnStartup() {
1:d29ca2a:         return deleteAllMessagesOnStartup;
1:9c42236:     }
1:4098942: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets whether or not all messages are deleted on startup - mostly only
1:d29ca2a:      * useful for testing.
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:44bafc3:      */
1:d29ca2a:     public void setDeleteAllMessagesOnStartup(boolean deletePersistentMessagesOnStartup) {
1:d29ca2a:         this.deleteAllMessagesOnStartup = deletePersistentMessagesOnStartup;
1:230a86c:     }
1:4098942: 
1:d29ca2a:     public URI getVmConnectorURI() {
1:d29ca2a:         if (vmConnectorURI == null) {
1:ed96e2e:             try {
1:b0c0441:                 vmConnectorURI = new URI("vm://" + getBrokerName());
1:230a86c:             } catch (URISyntaxException e) {
1:e1bbde7:                 LOG.error("Badly formed URI from {}", getBrokerName(), e);
1:230a86c:             }
1:230a86c:         }
1:d29ca2a:         return vmConnectorURI;
1:230a86c:     }
1:4098942: 
1:d29ca2a:     public void setVmConnectorURI(URI vmConnectorURI) {
1:d29ca2a:         this.vmConnectorURI = vmConnectorURI;
1:f392884:     }
1:f0d9f83: 
1:0ed0ba5:     public String getDefaultSocketURIString() {
1:da076f4:         if (started.get()) {
1:3cd8da8:             if (this.defaultSocketURIString == null) {
1:3cd8da8:                 for (TransportConnector tc:this.transportConnectors) {
1:0ed0ba5:                     String result = null;
1:3cd8da8:                     try {
1:0ed0ba5:                         result = tc.getPublishableConnectString();
1:3cd8da8:                     } catch (Exception e) {
1:e1bbde7:                       LOG.warn("Failed to get the ConnectURI for {}", tc, e);
1:3cd8da8:                     }
1:3cd8da8:                     if (result != null) {
1:3cd8da8:                         // find first publishable uri
1:3cd8da8:                         if (tc.isUpdateClusterClients() || tc.isRebalanceClusterClients()) {
1:3cd8da8:                             this.defaultSocketURIString = result;
1:3cd8da8:                             break;
1:3cd8da8:                         } else {
1:3cd8da8:                         // or use the first defined
1:3cd8da8:                             if (this.defaultSocketURIString == null) {
2:91059de:                                 this.defaultSocketURIString = result;
1:f392884:                             }
1:f392884:                         }
1:f392884:                     }
1:f392884:                 }
1:3cd8da8: 
1:f392884:             }
1:0ed0ba5:             return this.defaultSocketURIString;
1:3cd8da8:         }
1:f392884:        return null;
1:91059de:     }
1:f0d9f83: 
1:4098942:     /**
1:4098942:      * @return Returns the shutdownOnMasterFailure.
1:4098942:      */
1:230a86c:     public boolean isShutdownOnMasterFailure() {
1:4098942:         return shutdownOnMasterFailure;
1:4098942:     }
1:4098942: 
1:4098942:     /**
1:1ec71bd:      * @param shutdownOnMasterFailure
1:1ec71bd:      *            The shutdownOnMasterFailure to set.
1:4098942:      */
1:230a86c:     public void setShutdownOnMasterFailure(boolean shutdownOnMasterFailure) {
1:230a86c:         this.shutdownOnMasterFailure = shutdownOnMasterFailure;
1:4098942:     }
1:4098942: 
1:449981b:     public boolean isKeepDurableSubsActive() {
1:449981b:         return keepDurableSubsActive;
1:91059de:     }
1:4098942: 
1:449981b:     public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {
1:449981b:         this.keepDurableSubsActive = keepDurableSubsActive;
1:230a86c:     }
1:4098942: 
1:8f8fddc:     public boolean isUseVirtualTopics() {
1:8f8fddc:         return useVirtualTopics;
1:319966c:     }
1:4098942: 
1:42b768a:     /**
1:230a86c:      * Sets whether or not <a
1:230a86c:      * href="http://activemq.apache.org/virtual-destinations.html">Virtual
1:230a86c:      * Topics</a> should be supported by default if they have not been
1:230a86c:      * explicitly configured.
1:53082e6:      */
1:8f8fddc:     public void setUseVirtualTopics(boolean useVirtualTopics) {
1:8f8fddc:         this.useVirtualTopics = useVirtualTopics;
1:319966c:     }
1:4098942: 
1:370734c:     public DestinationInterceptor[] getDestinationInterceptors() {
1:370734c:         return destinationInterceptors;
1:ea1dad7:     }
1:4098942: 
1:42b768a:     public boolean isUseMirroredQueues() {
1:42b768a:         return useMirroredQueues;
1:449981b:     }
1:4098942: 
1:42b768a:     /**
1:42b768a:      * Sets whether or not <a
1:42b768a:      * href="http://activemq.apache.org/mirrored-queues.html">Mirrored
1:42b768a:      * Queues</a> should be supported by default if they have not been
1:42b768a:      * explicitly configured.
1:42b768a:      */
1:42b768a:     public void setUseMirroredQueues(boolean useMirroredQueues) {
1:42b768a:         this.useMirroredQueues = useMirroredQueues;
1:449981b:     }
1:ed96e2e: 
1:9dccfa4:     /**
1:370734c:      * Sets the destination interceptors to use
1:ee2462d:      */
1:370734c:     public void setDestinationInterceptors(DestinationInterceptor[] destinationInterceptors) {
1:370734c:         this.destinationInterceptors = destinationInterceptors;
1:47853d3:     }
1:ed58e9a: 
1:4bd8a8b:     public ActiveMQDestination[] getDestinations() {
1:4bd8a8b:         return destinations;
1:47853d3:     }
1:ed58e9a: 
1:44bafc3:     /**
1:4bd8a8b:      * Sets the destinations which should be loaded/created on startup
1:ee2462d:      */
1:4bd8a8b:     public void setDestinations(ActiveMQDestination[] destinations) {
1:4bd8a8b:         this.destinations = destinations;
1:47853d3:     }
1:7d1e6bc: 
1:7d1e6bc:     /**
1:7d1e6bc:      * @return the tempDataStore
1:7d1e6bc:      */
1:ee55abb:     public synchronized PListStore getTempDataStore() {
1:230a86c:         if (tempDataStore == null) {
1:222daf2:             if (!isPersistent()) {
1:01704ee:                 return null;
1:222daf2:             }
1:ed58e9a: 
1:f392884:             try {
1:32e63dc:                 PersistenceAdapter pa = getPersistenceAdapter();
1:32e63dc:                 if( pa!=null && pa instanceof PListStore) {
1:32e63dc:                     return (PListStore) pa;
1:32e63dc:                 }
1:61fd811:             } catch (IOException e) {
1:f21992e:                 throw new RuntimeException(e);
1:7d1e6bc:             }
1:ed58e9a: 
1:7d1e6bc:             try {
1:d5dd937:                 String clazz = "org.apache.activemq.store.kahadb.plist.PListStoreImpl";
1:d5dd937:                 this.tempDataStore = (PListStore) getClass().getClassLoader().loadClass(clazz).newInstance();
1:ee55abb:                 this.tempDataStore.setDirectory(getTmpDataDirectory());
1:0619a87:                 configureService(tempDataStore);
1:8646bb1:             } catch (ClassNotFoundException e) {
1:8646bb1:                 throw new RuntimeException("Kahadb class PListStoreImpl not found. Add activemq-kahadb jar or set persistent to false on BrokerService.", e);
1:f392884:             } catch (Exception e) {
1:7d1e6bc:                 throw new RuntimeException(e);
1:7d1e6bc:             }
1:32e63dc:         }
1:7d1e6bc:         return tempDataStore;
1:7d1e6bc:     }
1:7d1e6bc: 
1:7d1e6bc:     /**
1:1ec71bd:      * @param tempDataStore
1:1ec71bd:      *            the tempDataStore to set
1:7d1e6bc:      */
1:ee55abb:     public void setTempDataStore(PListStore tempDataStore) {
1:230a86c:         this.tempDataStore = tempDataStore;
1:b6759b3:         if (tempDataStore != null) {
1:b6759b3:             if (tmpDataDirectory == null) {
1:b6759b3:                 tmpDataDirectory = tempDataStore.getDirectory();
1:b6759b3:             } else if (tempDataStore.getDirectory() == null) {
1:b6759b3:                 tempDataStore.setDirectory(tmpDataDirectory);
1:b6759b3:             }
1:b6759b3:         }
1:0619a87:         configureService(tempDataStore);
1:c395917:     }
1:ed58e9a: 
1:230a86c:     public int getPersistenceThreadPriority() {
1:3fe77a2:         return persistenceThreadPriority;
1:3fe77a2:     }
1:3fe77a2: 
1:230a86c:     public void setPersistenceThreadPriority(int persistenceThreadPriority) {
1:230a86c:         this.persistenceThreadPriority = persistenceThreadPriority;
1:3fe77a2:     }
1:7f89b33: 
1:53082e6:     /**
1:bc03f37:      * @return the useLocalHostBrokerName
1:bc03f37:      */
1:230a86c:     public boolean isUseLocalHostBrokerName() {
1:bc03f37:         return this.useLocalHostBrokerName;
1:bc03f37:     }
1:bc03f37: 
1:bc03f37:     /**
1:1ec71bd:      * @param useLocalHostBrokerName
1:1ec71bd:      *            the useLocalHostBrokerName to set
1:bc03f37:      */
1:230a86c:     public void setUseLocalHostBrokerName(boolean useLocalHostBrokerName) {
1:230a86c:         this.useLocalHostBrokerName = useLocalHostBrokerName;
1:230a86c:         if (useLocalHostBrokerName && !started.get() && brokerName == null || brokerName == DEFAULT_BROKER_NAME) {
1:230a86c:             brokerName = LOCAL_HOST_NAME;
1:bc03f37:         }
1:bc03f37:     }
1:7f89b33: 
1:ee2462d:     /**
1:1ec71bd:      * Looks up and lazily creates if necessary the destination for the given
1:1ec71bd:      * JMS name
1:4bd8a8b:      */
1:42b768a:     public Destination getDestination(ActiveMQDestination destination) throws Exception {
1:204f91f:         return getBroker().addDestination(getAdminConnectionContext(), destination,false);
1:7d1e6bc:     }
1:1ec71bd: 
1:16f2d75:     public void removeDestination(ActiveMQDestination destination) throws Exception {
1:1ec71bd:         getBroker().removeDestination(getAdminConnectionContext(), destination, 0);
1:16f2d75:     }
1:1ec71bd: 
1:c427689:     public int getProducerSystemUsagePortion() {
1:c427689:         return producerSystemUsagePortion;
1:c427689:     }
1:c427689: 
1:c427689:     public void setProducerSystemUsagePortion(int producerSystemUsagePortion) {
1:c427689:         this.producerSystemUsagePortion = producerSystemUsagePortion;
1:c427689:     }
1:c427689: 
1:c427689:     public int getConsumerSystemUsagePortion() {
1:c427689:         return consumerSystemUsagePortion;
1:c427689:     }
1:c427689: 
1:c427689:     public void setConsumerSystemUsagePortion(int consumerSystemUsagePortion) {
1:c427689:         this.consumerSystemUsagePortion = consumerSystemUsagePortion;
1:c427689:     }
1:c427689: 
1:c427689:     public boolean isSplitSystemUsageForProducersConsumers() {
1:c427689:         return splitSystemUsageForProducersConsumers;
1:c427689:     }
1:c427689: 
1:1ec71bd:     public void setSplitSystemUsageForProducersConsumers(boolean splitSystemUsageForProducersConsumers) {
1:c427689:         this.splitSystemUsageForProducersConsumers = splitSystemUsageForProducersConsumers;
1:88fbb05:     }
1:1ec71bd: 
1:88fbb05:     public boolean isMonitorConnectionSplits() {
1:1ec71bd:         return monitorConnectionSplits;
1:1ec71bd:     }
1:91059de: 
1:1ec71bd:     public void setMonitorConnectionSplits(boolean monitorConnectionSplits) {
1:1ec71bd:         this.monitorConnectionSplits = monitorConnectionSplits;
1:1ec71bd:     }
1:6f70393: 
1:1ec71bd:     public int getTaskRunnerPriority() {
1:1ec71bd:         return taskRunnerPriority;
1:1ec71bd:     }
1:88fbb05: 
1:1ec71bd:     public void setTaskRunnerPriority(int taskRunnerPriority) {
1:1ec71bd:         this.taskRunnerPriority = taskRunnerPriority;
1:1ec71bd:     }
1:88fbb05: 
1:1ec71bd:     public boolean isDedicatedTaskRunner() {
1:1ec71bd:         return dedicatedTaskRunner;
1:1ec71bd:     }
1:1ec71bd: 
1:1ec71bd:     public void setDedicatedTaskRunner(boolean dedicatedTaskRunner) {
1:1ec71bd:         this.dedicatedTaskRunner = dedicatedTaskRunner;
1:1ec71bd:     }
1:1ec71bd: 
1:1ec71bd:     public boolean isCacheTempDestinations() {
1:e4621e3:         return cacheTempDestinations;
1:e4621e3:     }
1:e4621e3: 
1:e4621e3:     public void setCacheTempDestinations(boolean cacheTempDestinations) {
1:e4621e3:         this.cacheTempDestinations = cacheTempDestinations;
1:e4621e3:     }
1:e4621e3: 
1:e4621e3:     public int getTimeBeforePurgeTempDestinations() {
1:e4621e3:         return timeBeforePurgeTempDestinations;
1:e4621e3:     }
1:e4621e3: 
1:1ec71bd:     public void setTimeBeforePurgeTempDestinations(int timeBeforePurgeTempDestinations) {
1:e4621e3:         this.timeBeforePurgeTempDestinations = timeBeforePurgeTempDestinations;
1:e4621e3:     }
1:1ec71bd: 
1:620b657:     public boolean isUseTempMirroredQueues() {
1:620b657:         return useTempMirroredQueues;
1:620b657:     }
1:620b657: 
1:620b657:     public void setUseTempMirroredQueues(boolean useTempMirroredQueues) {
1:620b657:         this.useTempMirroredQueues = useTempMirroredQueues;
1:620b657:     }
1:1ec71bd: 
1:f21992e:     public synchronized JobSchedulerStore getJobSchedulerStore() {
1:01704ee: 
1:01704ee:         // If support is off don't allow any scheduler even is user configured their own.
1:01704ee:         if (!isSchedulerSupport()) {
1:01704ee:             return null;
1:01704ee:         }
1:01704ee: 
1:01704ee:         // If the user configured their own we use it even if persistence is disabled since
1:01704ee:         // we don't know anything about their implementation.
1:01704ee:         if (jobSchedulerStore == null) {
1:01704ee: 
1:01704ee:             if (!isPersistent()) {
1:433912f:                 this.jobSchedulerStore = new InMemoryJobSchedulerStore();
1:433912f:                 configureService(jobSchedulerStore);
1:433912f:                 return this.jobSchedulerStore;
1:433912f:             }
1:01704ee: 
1:433912f:             try {
1:01704ee:                 PersistenceAdapter pa = getPersistenceAdapter();
1:74846bb:                 if (pa != null) {
1:74846bb:                     this.jobSchedulerStore = pa.createJobSchedulerStore();
1:74846bb:                     jobSchedulerStore.setDirectory(getSchedulerDirectoryFile());
1:74846bb:                     configureService(jobSchedulerStore);
1:74846bb:                     return this.jobSchedulerStore;
1:74846bb:                 }
1:74846bb:             } catch (IOException e) {
1:433912f:                 throw new RuntimeException(e);
1:74846bb:             } catch (UnsupportedOperationException ex) {
1:74846bb:                 // It's ok if the store doesn't implement a scheduler.
1:433912f:             } catch (Exception e) {
1:74846bb:                 throw new RuntimeException(e);
1:74846bb:             }
1:74846bb: 
1:74846bb:             try {
1:74846bb:                 PersistenceAdapter pa = getPersistenceAdapter();
1:01704ee:                 if (pa != null && pa instanceof JobSchedulerStore) {
1:01704ee:                     this.jobSchedulerStore = (JobSchedulerStore) pa;
1:01704ee:                     configureService(jobSchedulerStore);
1:01704ee:                     return this.jobSchedulerStore;
1:01704ee:                 }
1:01704ee:             } catch (IOException e) {
1:74846bb:                 throw new RuntimeException(e);
1:01704ee:             }
1:01704ee: 
1:74846bb:             // Load the KahaDB store as a last resort, this only works if KahaDB is
1:74846bb:             // included at runtime, otherwise this will fail.  User should disable
1:74846bb:             // scheduler support if this fails.
1:01704ee:             try {
1:74846bb:                 String clazz = "org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter";
1:74846bb:                 PersistenceAdapter adaptor = (PersistenceAdapter)getClass().getClassLoader().loadClass(clazz).newInstance();
1:74846bb:                 jobSchedulerStore = adaptor.createJobSchedulerStore();
1:f21992e:                 jobSchedulerStore.setDirectory(getSchedulerDirectoryFile());
1:f21992e:                 configureService(jobSchedulerStore);
1:e1bbde7:                 LOG.info("JobScheduler using directory: {}", getSchedulerDirectoryFile());
1:74846bb:             } catch (Exception e) {
1:01704ee:                 throw new RuntimeException(e);
1:01704ee:             }
1:f21992e:         }
1:f21992e:         return jobSchedulerStore;
1:f21992e:     }
1:f21992e: 
1:f21992e:     public void setJobSchedulerStore(JobSchedulerStore jobSchedulerStore) {
1:f21992e:         this.jobSchedulerStore = jobSchedulerStore;
1:f21992e:         configureService(jobSchedulerStore);
1:f21992e:     }
1:f21992e: 
1:1ec71bd:     //
1:d29ca2a:     // Implementation methods
1:d29ca2a:     // -------------------------------------------------------------------------
1:ee2462d:     /**
1:d29ca2a:      * Handles any lazy-creation helper properties which are added to make
1:d29ca2a:      * things easier to configure inside environments such as Spring
1:f0d9f83:      *
1:d29ca2a:      * @throws Exception
1:370734c:      */
1:d29ca2a:     protected void processHelperProperties() throws Exception {
1:d29ca2a:         if (transportConnectorURIs != null) {
2:d29ca2a:             for (int i = 0; i < transportConnectorURIs.length; i++) {
2:d29ca2a:                 String uri = transportConnectorURIs[i];
1:d29ca2a:                 addConnector(uri);
1:88fbb05:             }
1:88fbb05:         }
1:d29ca2a:         if (networkConnectorURIs != null) {
1:4098942:             for (int i = 0; i < networkConnectorURIs.length; i++) {
1:4098942:                 String uri = networkConnectorURIs[i];
1:d29ca2a:                 addNetworkConnector(uri);
1:88fbb05:             }
1:c427689:         }
1:230a86c:         if (jmsBridgeConnectors != null) {
1:230a86c:             for (int i = 0; i < jmsBridgeConnectors.length; i++) {
1:d29ca2a:                 addJmsConnector(jmsBridgeConnectors[i]);
1:f1b6362:             }
1:f1b6362:         }
1:230a86c:     }
1:88fbb05: 
1:4bd8a8b:     /**
1:61fd811:      * Check that the store usage limit is not greater than max usable
1:61fd811:      * space and adjust if it is
1:61fd811:      */
1:d7febdd:     protected void checkStoreUsageLimits() throws Exception {
1:61fd811:         final SystemUsage usage = getSystemUsage();
1:4098942: 
1:7b90f41:         if (getPersistenceAdapter() != null) {
1:df19a38:             PersistenceAdapter adapter = getPersistenceAdapter();
1:4cddd2c:             checkUsageLimit(adapter.getDirectory(), usage.getStoreUsage(), usage.getStoreUsage().getPercentLimit());
1:3df43f5: 
1:df19a38:             long maxJournalFileSize = 0;
1:df19a38:             long storeLimit = usage.getStoreUsage().getLimit();
1:df19a38: 
1:d5dd937:             if (adapter instanceof JournaledStore) {
1:d5dd937:                 maxJournalFileSize = ((JournaledStore) adapter).getJournalMaxFileLength();
1:df19a38:             }
1:df19a38: 
1:dc19d28:             if (storeLimit > 0 && storeLimit < maxJournalFileSize) {
1:df19a38:                 LOG.error("Store limit is " + storeLimit / (1024 * 1024) +
1:df19a38:                           " mb, whilst the max journal file size for the store is: " +
1:df19a38:                           maxJournalFileSize / (1024 * 1024) + " mb, " +
1:df19a38:                           "the store will not accept any data when used.");
1:df19a38: 
1:df19a38:             }
1:dbc661f:         }
1:dbc661f:     }
1:cf9ccca: 
1:370734c:     /**
1:61fd811:      * Check that temporary usage limit is not greater than max usable
1:61fd811:      * space and adjust if it is
1:61fd811:      */
1:d7febdd:     protected void checkTmpStoreUsageLimits() throws Exception {
1:61fd811:         final SystemUsage usage = getSystemUsage();
1:f0429be: 
1:dbc661f:         File tmpDir = getTmpDataDirectory();
1:4cddd2c: 
1:7b90f41:         if (tmpDir != null) {
1:4cddd2c:             checkUsageLimit(tmpDir, usage.getTempUsage(), usage.getTempUsage().getPercentLimit());
1:f0429be: 
1:5b4fe6e:             if (isPersistent()) {
1:5b4fe6e:                 long maxJournalFileSize;
1:df19a38: 
1:d5dd937:                 PListStore store = usage.getTempUsage().getStore();
1:d5dd937:                 if (store != null && store instanceof JournaledStore) {
1:d5dd937:                     maxJournalFileSize = ((JournaledStore) store).getJournalMaxFileLength();
1:5b4fe6e:                 } else {
1:d5dd937:                     maxJournalFileSize = DEFAULT_MAX_FILE_LENGTH;
1:5b4fe6e:                 }
1:4cddd2c:                 long storeLimit = usage.getTempUsage().getLimit();
1:df19a38: 
1:dc19d28:                 if (storeLimit > 0 && storeLimit < maxJournalFileSize) {
1:5b4fe6e:                     LOG.error("Temporary Store limit is " + storeLimit / (1024 * 1024) +
1:5b4fe6e:                               " mb, whilst the max journal file size for the temporary store is: " +
1:5b4fe6e:                               maxJournalFileSize / (1024 * 1024) + " mb, " +
1:5b4fe6e:                               "the temp store will not accept any data when used.");
1:5b4fe6e:                 }
1:d403f10:             }
1:47853d3:         }
1:523ea5f:     }
1:f0429be: 
1:8a28c06:     protected void checkUsageLimit(File dir, PercentLimitUsage<?> storeUsage, int percentLimit) throws ConfigurationException {
1:4cddd2c:         if (dir != null) {
1:4cddd2c:             dir = StoreUtil.findParentDirectory(dir);
1:4cddd2c:             String storeName = storeUsage instanceof StoreUsage ? "Store" : "Temporary Store";
1:4cddd2c:             long storeLimit = storeUsage.getLimit();
1:4cddd2c:             long storeCurrent = storeUsage.getUsage();
1:8a28c06:             long totalSpace = storeUsage.getTotal() > 0 ? storeUsage.getTotal() : dir.getTotalSpace();
1:8a28c06:             long totalUsableSpace = (storeUsage.getTotal() > 0 ? storeUsage.getTotal() : dir.getUsableSpace()) + storeCurrent;
1:8a28c06:             if (totalUsableSpace < 0 || totalSpace < 0) {
1:8a28c06:                 final String message = "File system space reported by: " + dir + " was negative, possibly a huge file system, set a sane usage.total to provide some guidance";
1:8a28c06:                 LOG.error(message);
1:8a28c06:                 throw new ConfigurationException(message);
1:41bec0d:             }
1:4cddd2c:             //compute byte value of the percent limit
1:4cddd2c:             long bytePercentLimit = totalSpace * percentLimit / 100;
1:4cddd2c:             int oneMeg = 1024 * 1024;
1:4cddd2c: 
1:4cddd2c:             //Check if the store limit is less than the percent Limit that was set and also
1:4cddd2c:             //the usable space...this means we can grow the store larger
1:4cddd2c:             //Changes in partition size (total space) as well as changes in usable space should
1:4cddd2c:             //be detected here
1:4cddd2c:             if (diskUsageCheckRegrowThreshold > -1 && percentLimit > 0
1:8a28c06:                     && storeUsage.getTotal() == 0
1:4cddd2c:                     && storeLimit < bytePercentLimit && storeLimit < totalUsableSpace){
1:4cddd2c: 
1:4cddd2c:                 // set the limit to be bytePercentLimit or usableSpace if
1:4cddd2c:                 // usableSpace is less than the percentLimit
1:4cddd2c:                 long newLimit = bytePercentLimit > totalUsableSpace ? totalUsableSpace : bytePercentLimit;
1:4cddd2c: 
1:4cddd2c:                 //To prevent changing too often, check threshold
1:4cddd2c:                 if (newLimit - storeLimit >= diskUsageCheckRegrowThreshold) {
1:4cddd2c:                     LOG.info("Usable disk space has been increased, attempting to regrow " + storeName + " limit to "
1:4cddd2c:                             + percentLimit + "% of the partition size.");
1:4cddd2c:                     storeUsage.setLimit(newLimit);
1:4cddd2c:                     LOG.info(storeName + " limit has been increased to " + newLimit * 100 / totalSpace
1:4cddd2c:                             + "% (" + newLimit / oneMeg + " mb) of the partition size.");
1:4cddd2c:                 }
1:4cddd2c: 
1:4cddd2c:             //check if the limit is too large for the amount of usable space
1:4cddd2c:             } else if (storeLimit > totalUsableSpace) {
1:d7febdd:                 final String message = storeName + " limit is " +  storeLimit / oneMeg
1:d7febdd:                         + " mb (current store usage is " + storeCurrent / oneMeg
1:d7febdd:                         + " mb). The data directory: " + dir.getAbsolutePath()
1:d7febdd:                         + " only has " + totalUsableSpace / oneMeg
1:d7febdd:                         + " mb of usable space.";
1:d7febdd: 
1:d7febdd:                 if (!isAdjustUsageLimits()) {
1:d7febdd:                     LOG.error(message);
1:d7febdd:                     throw new ConfigurationException(message);
1:d7febdd:                 }
1:d7febdd: 
1:4cddd2c:                 if (percentLimit > 0) {
1:4cddd2c:                     LOG.warn(storeName + " limit has been set to "
1:af09b45:                             + percentLimit + "% (" + bytePercentLimit / oneMeg + " mb)"
1:4cddd2c:                             + " of the partition size but there is not enough usable space."
1:af09b45:                             + " The current store limit (which may have been adjusted by a"
1:af09b45:                             + " previous usage limit check) is set to (" + storeLimit / oneMeg + " mb)"
1:af09b45:                             + " but only " + totalUsableSpace * 100 / totalSpace + "% (" + totalUsableSpace / oneMeg + " mb)"
1:af09b45:                             + " is available - resetting limit");
1:d7febdd:                 } else {
1:d7febdd:                     LOG.warn(message + " - resetting to maximum available disk space: " +
1:d7febdd:                             totalUsableSpace / oneMeg + " mb");
1:4cddd2c:                 }
1:4cddd2c:                 storeUsage.setLimit(totalUsableSpace);
1:4cddd2c:             }
1:4cddd2c:         }
1:4cddd2c:     }
1:4cddd2c: 
1:8f8fddc:     /**
1:61fd811:      * Schedules a periodic task based on schedulePeriodForDiskLimitCheck to
1:61fd811:      * update store and temporary store limits if the amount of available space
1:61fd811:      * plus current store size is less than the existin configured limit
1:61fd811:      */
1:61fd811:     protected void scheduleDiskUsageLimitsCheck() throws IOException {
1:61fd811:         if (schedulePeriodForDiskUsageCheck > 0 &&
1:61fd811:                 (getPersistenceAdapter() != null || getTmpDataDirectory() != null)) {
1:61fd811:             Runnable diskLimitCheckTask = new Runnable() {
1:61fd811:                 @Override
1:61fd811:                 public void run() {
1:61fd811:                     try {
1:61fd811:                         checkStoreUsageLimits();
1:cdb38b3:                     } catch (Throwable e) {
1:61fd811:                         LOG.error("Failed to check persistent disk usage limits", e);
1:61fd811:                     }
1:4cddd2c: 
1:61fd811:                     try {
1:61fd811:                         checkTmpStoreUsageLimits();
1:cdb38b3:                     } catch (Throwable e) {
1:61fd811:                         LOG.error("Failed to check temporary store usage limits", e);
1:61fd811:                     }
1:61fd811:                 }
1:61fd811:             };
1:61fd811:             scheduler.executePeriodically(diskLimitCheckTask, schedulePeriodForDiskUsageCheck);
1:61fd811:         }
1:61fd811:     }
1:61fd811: 
1:d7febdd:     protected void checkMemorySystemUsageLimits() throws Exception {
1:61fd811:         final SystemUsage usage = getSystemUsage();
1:61fd811:         long memLimit = usage.getMemoryUsage().getLimit();
1:61fd811:         long jvmLimit = Runtime.getRuntime().maxMemory();
1:61fd811: 
1:61fd811:         if (memLimit > jvmLimit) {
1:d7febdd:             final String message = "Memory Usage for the Broker (" + memLimit / (1024 * 1024)
1:d7febdd:                     + "mb) is more than the maximum available for the JVM: " + jvmLimit / (1024 * 1024);
1:d7febdd: 
1:d7febdd:             if (adjustUsageLimits) {
1:d7febdd:                 usage.getMemoryUsage().setPercentOfJvmHeap(70);
1:d7febdd:                 LOG.warn(message + " mb - resetting to 70% of maximum available: " + (usage.getMemoryUsage().getLimit() / (1024 * 1024)) + " mb");
1:d7febdd:             } else {
1:d7febdd:                 LOG.error(message);
1:d7febdd:                 throw new ConfigurationException(message);
1:d7febdd:             }
1:d7febdd:         }
1:61fd811:     }
1:d7febdd: 
1:d7febdd:     protected void checkStoreSystemUsageLimits() throws Exception {
1:d7febdd:         final SystemUsage usage = getSystemUsage();
1:61fd811: 
1:61fd811:         //Check the persistent store and temp store limits if they exist
1:61fd811:         //and schedule a periodic check to update disk limits if
1:61fd811:         //schedulePeriodForDiskLimitCheck is set
1:61fd811:         checkStoreUsageLimits();
1:61fd811:         checkTmpStoreUsageLimits();
1:61fd811:         scheduleDiskUsageLimitsCheck();
1:61fd811: 
1:f21992e:         if (getJobSchedulerStore() != null) {
1:f21992e:             JobSchedulerStore scheduler = getJobSchedulerStore();
1:f21992e:             File schedulerDir = scheduler.getDirectory();
1:f21992e:             if (schedulerDir != null) {
1:f21992e: 
1:f21992e:                 String schedulerDirPath = schedulerDir.getAbsolutePath();
1:f21992e:                 if (!schedulerDir.isAbsolute()) {
1:f21992e:                     schedulerDir = new File(schedulerDirPath);
1:f21992e:                 }
1:f21992e: 
1:ea1d02d:                 while (schedulerDir != null && !schedulerDir.isDirectory()) {
1:f21992e:                     schedulerDir = schedulerDir.getParentFile();
1:f21992e:                 }
1:598f206:                 long schedulerLimit = usage.getJobSchedulerUsage().getLimit();
1:f21992e:                 long dirFreeSpace = schedulerDir.getUsableSpace();
1:598f206:                 if (schedulerLimit > dirFreeSpace) {
1:598f206:                     LOG.warn("Job Scheduler Store limit is " + schedulerLimit / (1024 * 1024) +
1:f21992e:                              " mb, whilst the data directory: " + schedulerDir.getAbsolutePath() +
1:0ba311f:                              " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space - resetting to " +
1:cf9ccca:                             dirFreeSpace / (1024 * 1024) + " mb.");
1:cf9ccca:                     usage.getJobSchedulerUsage().setLimit(dirFreeSpace);
1:f21992e:                 }
1:f21992e:             }
1:f21992e:         }
1:7b90f41:     }
1:7b90f41: 
1:4150650:     public void stopAllConnectors(ServiceStopper stopper) {
1:98497b1:         for (Iterator<NetworkConnector> iter = getNetworkConnectors().iterator(); iter.hasNext();) {
1:98497b1:             NetworkConnector connector = iter.next();
1:44bafc3:             unregisterNetworkConnectorMBean(connector);
2:319966c:             stopper.stop(connector);
1:61fdb18:         }
1:98497b1:         for (Iterator<ProxyConnector> iter = getProxyConnectors().iterator(); iter.hasNext();) {
1:98497b1:             ProxyConnector connector = iter.next();
1:8610db3:             stopper.stop(connector);
1:61fdb18:         }
1:30f531d:         for (Iterator<JmsConnector> iter = jmsConnectors.iterator(); iter.hasNext();) {
1:30f531d:             JmsConnector connector = iter.next();
1:319966c:             stopper.stop(connector);
1:dbc661f:         }
1:ecf89a6:         for (Iterator<TransportConnector> iter = getTransportConnectors().iterator(); iter.hasNext();) {
1:ecf89a6:             TransportConnector connector = iter.next();
1:539a5f1:             try {
1:539a5f1:                 unregisterConnectorMBean(connector);
1:539a5f1:             } catch (IOException e) {
1:539a5f1:             }
1:319966c:             stopper.stop(connector);
1:dbc661f:         }
1:dbc661f:     }
1:7b90f41: 
1:230a86c:     protected TransportConnector registerConnectorMBean(TransportConnector connector) throws IOException {
1:f21992e:         try {
1:1ec71bd:             ObjectName objectName = createConnectorObjectName(connector);
1:1ec71bd:             connector = connector.asManagedConnector(getManagementContext(), objectName);
1:1ec71bd:             ConnectorViewMBean view = new ConnectorView(connector);
1:ced6909:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
1:1ec71bd:             return connector;
1:1ec71bd:         } catch (Throwable e) {
1:cf62d58:             throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e, e);
1:dbc661f:         }
1:98497b1:     }
1:61fdb18: 
1:c9b8905:     protected void unregisterConnectorMBean(TransportConnector connector) throws IOException {
1:b3873fb:         if (isUseJmx()) {
1:1ec71bd:             try {
1:1ec71bd:                 ObjectName objectName = createConnectorObjectName(connector);
1:1ec71bd:                 getManagementContext().unregisterMBean(objectName);
1:1ec71bd:             } catch (Throwable e) {
1:1ec71bd:                 throw IOExceptionSupport.create(
1:4228281:                         "Transport Connector could not be unregistered in JMX: " + e.getMessage(), e);
1:98497b1:             }
1:30f531d:         }
1:30f531d:     }
1:1ec71bd: 
1:5f4db41:     protected PersistenceAdapter registerPersistenceAdapterMBean(PersistenceAdapter adaptor) throws IOException {
1:5f4db41:         return adaptor;
1:5f4db41:     }
1:5f4db41: 
1:5f4db41:     protected void unregisterPersistenceAdapterMBean(PersistenceAdapter adaptor) throws IOException {
1:3cd8da8:         if (isUseJmx()) {}
1:5f4db41:     }
1:5f4db41: 
1:230a86c:     private ObjectName createConnectorObjectName(TransportConnector connector) throws MalformedObjectNameException {
1:7d7d6fa:         return BrokerMBeanSupport.createConnectorName(getBrokerObjectName(), "clientConnectors", connector.getName());
1:5f4db41:     }
1:8610db3: 
1:c2eb486:     public void registerNetworkConnectorMBean(NetworkConnector connector) throws IOException {
1:1ec71bd:         NetworkConnectorViewMBean view = new NetworkConnectorView(connector);
1:1ec71bd:         try {
1:1ec71bd:             ObjectName objectName = createNetworkConnectorObjectName(connector);
1:1ec71bd:             connector.setObjectName(objectName);
1:ced6909:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
1:1ec71bd:         } catch (Throwable e) {
1:1ec71bd:             throw IOExceptionSupport.create("Network Connector could not be registered in JMX: " + e.getMessage(), e);
1:5f4db41:         }
1:30f531d:     }
1:8610db3: 
1:bab0887:     public ObjectName createNetworkConnectorObjectName(NetworkConnector connector) throws MalformedObjectNameException {
1:7d7d6fa:         return BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "networkConnectors", connector.getName());
1:30f531d:     }
1:8610db3: 
1:3cd8da8:     public ObjectName createDuplexNetworkConnectorObjectName(String transport) throws MalformedObjectNameException {
1:ea1d02d:         return BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "duplexNetworkConnectors", transport);
1:30f531d:     }
1:f0429be: 
1:53082e6:     protected void unregisterNetworkConnectorMBean(NetworkConnector connector) {
1:5f4db41:         if (isUseJmx()) {
1:1ec71bd:             try {
1:1ec71bd:                 ObjectName objectName = createNetworkConnectorObjectName(connector);
1:1ec71bd:                 getManagementContext().unregisterMBean(objectName);
1:d7febdd:             } catch (Exception e) {
1:ea1d02d:                 LOG.warn("Network Connector could not be unregistered from JMX due " + e.getMessage() + ". This exception is ignored.", e);
1:30f531d:             }
1:30f531d:         }
1:30f531d:     }
1:f0429be: 
1:d29ca2a:     protected void registerProxyConnectorMBean(ProxyConnector connector) throws IOException {
1:1ec71bd:         ProxyConnectorView view = new ProxyConnectorView(connector);
1:1ec71bd:         try {
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "proxyConnectors", connector.getName());
1:ced6909:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
1:1ec71bd:         } catch (Throwable e) {
2:1ec71bd:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:4098942:         }
1:4098942:     }
1:4098942: 
1:4098942:     protected void registerJmsConnectorMBean(JmsConnector connector) throws IOException {
1:1ec71bd:         JmsConnectorView view = new JmsConnectorView(connector);
1:1ec71bd:         try {
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "jmsConnectors", connector.getName());
1:ced6909:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
1:1ec71bd:         } catch (Throwable e) {
1:1ec71bd:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:4098942:         }
1:4098942:     }
1:4098942: 
1:d29ca2a:     /**
1:d29ca2a:      * Factory method to create a new broker
1:f0d9f83:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     protected Broker createBroker() throws Exception {
1:13829ef:         regionBroker = createRegionBroker();
1:d29ca2a:         Broker broker = addInterceptors(regionBroker);
1:d29ca2a:         // Add a filter that will stop access to the broker once stopped
1:d29ca2a:         broker = new MutableBrokerFilter(broker) {
1:1ec71bd:             Broker old;
1:1ec71bd: 
1:7ae2055:             @Override
1:1ec71bd:             public void stop() throws Exception {
1:62e1abf:                 old = this.next.getAndSet(new ErrorBroker("Broker has been stopped: " + this) {
1:d29ca2a:                     // Just ignore additional stop actions.
1:7ae2055:                     @Override
1:230a86c:                     public void stop() throws Exception {
1:30f531d:                     }
1:5cd9eba:                 });
1:1096564:                 old.stop();
1:230a86c:             }
1:1ec71bd: 
1:7ae2055:             @Override
1:1ec71bd:             public void start() throws Exception {
1:1ec71bd:                 if (forceStart && old != null) {
1:1ec71bd:                     this.next.set(old);
1:1ec71bd:                 }
1:1ec71bd:                 getNext().start();
1:1ec71bd:             }
1:d29ca2a:         };
1:d29ca2a:         return broker;
1:62e1abf:     }
1:f0429be: 
1:d29ca2a:     /**
1:d29ca2a:      * Factory method to create the core region broker onto which interceptors
1:d29ca2a:      * are added
1:f0d9f83:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     protected Broker createRegionBroker() throws Exception {
1:42b768a:         if (destinationInterceptors == null) {
1:42b768a:             destinationInterceptors = createDefaultDestinationInterceptor();
1:62e1abf:         }
1:42b768a:         configureServices(destinationInterceptors);
1:42b768a:         DestinationInterceptor destinationInterceptor = new CompositeDestinationInterceptor(destinationInterceptors);
1:9d4c74f:         if (destinationFactory == null) {
1:13829ef:             destinationFactory = new DestinationFactoryImpl(this, getTaskRunnerFactory(), getPersistenceAdapter());
1:9d4c74f:         }
1:1096564:         return createRegionBroker(destinationInterceptor);
1:1096564:     }
1:1ec71bd: 
1:1096564:     protected Broker createRegionBroker(DestinationInterceptor destinationInterceptor) throws IOException {
1:1ec71bd:         RegionBroker regionBroker;
1:62e1abf:         if (isUseJmx()) {
1:c37859a:             try {
1:3cd8da8:                 regionBroker = new ManagedRegionBroker(this, getManagementContext(), getBrokerObjectName(),
1:1a5ad28:                     getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory, destinationInterceptor,getScheduler(),getExecutor());
1:3cd8da8:             } catch(MalformedObjectNameException me){
1:ea1d02d:                 LOG.warn("Cannot create ManagedRegionBroker due " + me.getMessage(), me);
1:c37859a:                 throw new IOException(me);
1:c37859a:             }
1:1ec71bd:         } else {
1:1ec71bd:             regionBroker = new RegionBroker(this, getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory,
1:1a5ad28:                     destinationInterceptor,getScheduler(),getExecutor());
1:230a86c:         }
1:9d4c74f:         destinationFactory.setRegionBroker(regionBroker);
1:449981b:         regionBroker.setKeepDurableSubsActive(keepDurableSubsActive);
1:230a86c:         regionBroker.setBrokerName(getBrokerName());
1:1096564:         regionBroker.getDestinationStatistics().setEnabled(enableStatistics);
1:254d920:         regionBroker.setAllowTempAutoCreationOnSend(isAllowTempAutoCreationOnSend());
1:996b7a5:         if (brokerId != null) {
1:996b7a5:             regionBroker.setBrokerId(brokerId);
1:996b7a5:         }
1:1ec71bd:         return regionBroker;
1:1ec71bd:     }
1:f0429be: 
1:d29ca2a:     /**
1:da67a38:      * Create the default destination interceptor
1:da67a38:      */
1:42b768a:     protected DestinationInterceptor[] createDefaultDestinationInterceptor() {
1:56917c0:         List<DestinationInterceptor> answer = new ArrayList<>();
1:42b768a:         if (isUseVirtualTopics()) {
1:42b768a:             VirtualDestinationInterceptor interceptor = new VirtualDestinationInterceptor();
1:42b768a:             VirtualTopic virtualTopic = new VirtualTopic();
1:42b768a:             virtualTopic.setName("VirtualTopic.>");
1:1ec71bd:             VirtualDestination[] virtualDestinations = { virtualTopic };
1:42b768a:             interceptor.setVirtualDestinations(virtualDestinations);
1:42b768a:             answer.add(interceptor);
1:1096564:         }
1:42b768a:         if (isUseMirroredQueues()) {
1:1ec71bd:             MirroredQueue interceptor = new MirroredQueue();
1:42b768a:             answer.add(interceptor);
1:13829ef:         }
1:42b768a:         DestinationInterceptor[] array = new DestinationInterceptor[answer.size()];
1:42b768a:         answer.toArray(array);
1:42b768a:         return array;
1:13829ef:     }
1:f0429be: 
1:da67a38:     /**
1:d29ca2a:      * Strategy method to add interceptors to the broker
1:f0d9f83:      *
2:6d8e2c5:      * @throws IOException
1:d29ca2a:      */
1:d1a18f5:     protected Broker addInterceptors(Broker broker) throws Exception {
1:7ae2055:         if (isSchedulerSupport()) {
1:f21992e:             SchedulerBroker sb = new SchedulerBroker(this, broker, getJobSchedulerStore());
1:c7c8e53:             if (isUseJmx()) {
1:c7c8e53:                 JobSchedulerViewMBean view = new JobSchedulerView(sb.getJobScheduler());
1:c7c8e53:                 try {
1:7d7d6fa:                     ObjectName objectName = BrokerMBeanSupport.createJobSchedulerServiceName(getBrokerObjectName());
1:c7c8e53:                     AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
1:c7c8e53:                     this.adminView.setJMSJobScheduler(objectName);
1:c7c8e53:                 } catch (Throwable e) {
1:c7c8e53:                     throw IOExceptionSupport.create("JobScheduler could not be registered in JMX: "
1:c7c8e53:                             + e.getMessage(), e);
1:c7c8e53:                 }
1:c7c8e53:             }
1:c7c8e53:             broker = sb;
1:7ae2055:         }
1:ed96e2e:         if (isUseJmx()) {
1:973909a:             HealthViewMBean statusView = new HealthView((ManagedRegionBroker)getRegionBroker());
1:1ec71bd:             try {
1:7d7d6fa:                 ObjectName objectName = BrokerMBeanSupport.createHealthServiceName(getBrokerObjectName());
1:ed96e2e:                 AnnotatedMBean.registerMBean(getManagementContext(), statusView, objectName);
1:1ec71bd:             } catch (Throwable e) {
1:ed96e2e:                 throw IOExceptionSupport.create("Status MBean could not be registered in JMX: "
1:ed96e2e:                         + e.getMessage(), e);
1:ed96e2e:             }
1:ed96e2e:         }
1:466ccdd:         if (isAdvisorySupport()) {
1:d29ca2a:             broker = new AdvisoryBroker(broker);
1:230a86c:         }
1:d29ca2a:         broker = new CompositeDestinationBroker(broker);
1:475eedc:         broker = new TransactionBroker(broker, getPersistenceAdapter().createTransactionStore());
1:d29ca2a:         if (isPopulateJMSXUserID()) {
1:6f68a94:             UserIDBroker userIDBroker = new UserIDBroker(broker);
1:286c9d0:             userIDBroker.setUseAuthenticatePrincipal(isUseAuthenticatedPrincipalForJMSXUserID());
1:6f68a94:             broker = userIDBroker;
1:230a86c:         }
1:1ec71bd:         if (isMonitorConnectionSplits()) {
1:1ec71bd:             broker = new ConnectionSplitBroker(broker);
1:88fbb05:         }
1:4686ec5:         if (plugins != null) {
1:4686ec5:             for (int i = 0; i < plugins.length; i++) {
1:4686ec5:                 BrokerPlugin plugin = plugins[i];
1:4686ec5:                 broker = plugin.installPlugin(broker);
1:319966c:             }
1:319966c:         }
1:d29ca2a:         return broker;
1:319966c:     }
1:c7c8e53: 
1:d29ca2a:     protected PersistenceAdapter createPersistenceAdapter() throws IOException {
1:d29ca2a:         if (isPersistent()) {
1:1a5ad28:             PersistenceAdapterFactory fac = getPersistenceFactory();
1:1a5ad28:             if (fac != null) {
1:1a5ad28:                 return fac.createPersistenceAdapter();
1:91059de:             } else {
1:4098942:                 try {
1:d5dd937:                     String clazz = "org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter";
1:d5dd937:                     PersistenceAdapter adaptor = (PersistenceAdapter)getClass().getClassLoader().loadClass(clazz).newInstance();
1:1a5ad28:                     File dir = new File(getBrokerDataDirectory(),"KahaDB");
1:1a5ad28:                     adaptor.setDirectory(dir);
1:1a5ad28:                     return adaptor;
1:ed58e9a:                 } catch (Throwable e) {
1:d5dd937:                     throw IOExceptionSupport.create(e);
1:1a5ad28:                 }
1:d5dd937:             }
1:e8a641c:         } else {
1:d29ca2a:             return new MemoryPersistenceAdapter();
1:236a1ac:         }
132:d29ca2a:     }
1:f0429be: 
1:c37859a:     protected ObjectName createBrokerObjectName() throws MalformedObjectNameException  {
1:7d7d6fa:         return BrokerMBeanSupport.createBrokerObjectName(getManagementContext().getJmxDomainName(), getBrokerName());
1:d29ca2a:     }
1:f0429be: 
1:5d99c99:     protected TransportConnector createTransportConnector(URI brokerURI) throws Exception {
1:9a8f6e4:         TransportServer transport = TransportFactorySupport.bind(this, brokerURI);
1:5d99c99:         return new TransportConnector(transport);
1:d29ca2a:     }
1:f0429be: 
1:d29ca2a:     /**
1:d29ca2a:      * Extracts the port from the options
1:d29ca2a:      */
1:3cd8da8:     protected Object getPort(Map<?,?> options) {
1:d29ca2a:         Object port = options.get("port");
1:d29ca2a:         if (port == null) {
1:d29ca2a:             port = DEFAULT_PORT;
1:e1bbde7:             LOG.warn("No port specified so defaulting to: {}", port);
1:d29ca2a:         }
1:d29ca2a:         return port;
1:d29ca2a:     }
1:2a2dcd5: 
1:d29ca2a:     protected void addShutdownHook() {
1:d29ca2a:         if (useShutdownHook) {
1:d29ca2a:             shutdownHook = new Thread("ActiveMQ ShutdownHook") {
1:7ae2055:                 @Override
1:f38908e:                 public void run() {
1:d29ca2a:                     containerShutdown();
1:d29ca2a:                 }
1:d29ca2a:             };
1:d29ca2a:             Runtime.getRuntime().addShutdownHook(shutdownHook);
1:d29ca2a:         }
1:d29ca2a:     }
1:2a2dcd5: 
1:d29ca2a:     protected void removeShutdownHook() {
1:d29ca2a:         if (shutdownHook != null) {
1:ed58e9a:             try {
1:d29ca2a:                 Runtime.getRuntime().removeShutdownHook(shutdownHook);
1:f21992e:             } catch (Exception e) {
1:ea1d02d:                 LOG.debug("Caught exception, must be shutting down. This exception is ignored.", e);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:20118f2: 
1:d29ca2a:     /**
1:145c80a:      * Sets hooks to be executed when broker shut down
1:f0d9f83:      *
1:1ec71bd:      * @org.apache.xbean.Property
1:145c80a:      */
1:145c80a:     public void setShutdownHooks(List<Runnable> hooks) throws Exception {
1:145c80a:         for (Runnable hook : hooks) {
1:145c80a:             addShutdownHook(hook);
1:145c80a:         }
1:145c80a:     }
1:f0d9f83: 
1:145c80a:     /**
1:d29ca2a:      * Causes a clean shutdown of the container when the VM is being shut down
1:d29ca2a:      */
1:d29ca2a:     protected void containerShutdown() {
1:ed58e9a:         try {
1:55409bd:             stop();
1:32e63dc:         } catch (IOException e) {
1:d29ca2a:             Throwable linkedException = e.getCause();
1:d29ca2a:             if (linkedException != null) {
1:d29ca2a:                 logError("Failed to shut down: " + e + ". Reason: " + linkedException, linkedException);
1:30f531d:             } else {
1:d29ca2a:                 logError("Failed to shut down: " + e, e);
1:d29ca2a:             }
1:d29ca2a:             if (!useLoggingForShutdownErrors) {
1:d29ca2a:                 e.printStackTrace(System.err);
1:d29ca2a:             }
1:c1051c8:         } catch (Exception e) {
1:d29ca2a:             logError("Failed to shut down: " + e, e);
1:d29ca2a:         }
1:d29ca2a:     }
1:20118f2: 
1:d29ca2a:     protected void logError(String message, Throwable e) {
1:d29ca2a:         if (useLoggingForShutdownErrors) {
1:230a86c:             LOG.error("Failed to shut down: " + e);
1:d5dd937:         } else {
1:d29ca2a:             System.err.println("Failed to shut down: " + e);
1:d29ca2a:         }
1:d29ca2a:     }
1:4098942: 
1:370734c:     /**
1:370734c:      * Starts any configured destinations on startup
1:370734c:      */
1:370734c:     protected void startDestinations() throws Exception {
1:370734c:         if (destinations != null) {
1:8abb655:             ConnectionContext adminConnectionContext = getAdminConnectionContext();
1:370734c:             for (int i = 0; i < destinations.length; i++) {
1:370734c:                 ActiveMQDestination destination = destinations[i];
1:204f91f:                 getBroker().addDestination(adminConnectionContext, destination,true);
1:d29ca2a:             }
1:d29ca2a:         }
1:b6f63b0:         if (isUseVirtualTopics()) {
1:b6f63b0:             startVirtualConsumerDestinations();
1:b6f63b0:         }
1:d29ca2a:     }
1:11705e7: 
1:8abb655:     /**
1:230a86c:      * Returns the broker's administration connection context used for
1:230a86c:      * configuring the broker at startup
1:8abb655:      */
1:8abb655:     public ConnectionContext getAdminConnectionContext() throws Exception {
1:df7cb77:         return BrokerSupport.getConnectionContext(getBroker());
1:d29ca2a:     }
1:11705e7: 
1:b3873fb:     protected void startManagementContext() throws Exception {
1:eea9fca:         getManagementContext().setBrokerName(brokerName);
1:1ec71bd:         getManagementContext().start();
1:b3873fb:         adminView = new BrokerView(this, null);
1:1ec71bd:         ObjectName objectName = getBrokerObjectName();
1:b3873fb:         AnnotatedMBean.registerMBean(getManagementContext(), adminView, objectName);
1:b3873fb:     }
1:11705e7: 
1:8abb655:     /**
1:4098942:      * Start all transport and network connections, proxies and bridges
1:f0d9f83:      *
1:c9b8905:      * @throws Exception
1:8abb655:      */
1:4150650:     public void startAllConnectors() throws Exception {
1:ef84db5:         final Set<ActiveMQDestination> durableDestinations = getBroker().getDurableDestinations();
1:56917c0:         List<TransportConnector> al = new ArrayList<>();
1:30f531d:         for (Iterator<TransportConnector> iter = getTransportConnectors().iterator(); iter.hasNext();) {
1:30f531d:             TransportConnector connector = iter.next();
1:30f531d:             al.add(startTransportConnector(connector));
1:62e1abf:         }
1:30f531d:         if (al.size() > 0) {
1:30f531d:             // let's clear the transportConnectors list and replace it with
1:30f531d:             // the started transportConnector instances
1:30f531d:             this.transportConnectors.clear();
1:30f531d:             setTransportConnectors(al);
1:62e1abf:         }
1:d75e418:         this.slave = false;
1:98497b1:         if (!stopped.get()) {
1:f38908e:             ThreadPoolExecutor networkConnectorStartExecutor = null;
1:f38908e:             if (isNetworkConnectorStartAsync()) {
1:f38908e:                 // spin up as many threads as needed
1:f38908e:                 networkConnectorStartExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE,
1:f38908e:                     10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
1:f38908e:                     new ThreadFactory() {
1:f38908e:                         int count=0;
1:3cd8da8:                         @Override
1:f38908e:                         public Thread newThread(Runnable runnable) {
1:f38908e:                             Thread thread = new Thread(runnable, "NetworkConnector Start Thread-" +(count++));
1:f38908e:                             thread.setDaemon(true);
1:f38908e:                             return thread;
1:f38908e:                         }
1:f38908e:                     });
1:f38908e:             }
1:f38908e: 
1:30f531d:             for (Iterator<NetworkConnector> iter = getNetworkConnectors().iterator(); iter.hasNext();) {
1:f38908e:                 final NetworkConnector connector = iter.next();
1:d84a586:                 connector.setLocalUri(getVmConnectorURI());
1:ef84db5:                 startNetworkConnector(connector, durableDestinations, networkConnectorStartExecutor);
1:f38908e:             }
2:f38908e:             if (networkConnectorStartExecutor != null) {
1:f38908e:                 // executor done when enqueued tasks are complete
1:6c1676b:                 ThreadPoolUtils.shutdown(networkConnectorStartExecutor);
1:3cd8da8:             }
1:1a5ad28: 
1:30f531d:             for (Iterator<ProxyConnector> iter = getProxyConnectors().iterator(); iter.hasNext();) {
1:30f531d:                 ProxyConnector connector = iter.next();
1:f38908e:                 connector.start();
1:1a5ad28:             }
1:98497b1:             for (Iterator<JmsConnector> iter = jmsConnectors.iterator(); iter.hasNext();) {
1:98497b1:                 JmsConnector connector = iter.next();
3:98497b1:                 connector.start();
1:98497b1:             }
1:98497b1:             for (Service service : services) {
1:f1b6362:                 configureService(service);
1:98497b1:                 service.start();
1:1ec71bd:             }
1:f1b6362:         }
1:f1b6362:     }
1:4098942: 
1:bab0887:     public void startNetworkConnector(final NetworkConnector connector,
1:bab0887:             final ThreadPoolExecutor networkConnectorStartExecutor) throws Exception {
1:ef84db5:         startNetworkConnector(connector, getBroker().getDurableDestinations(), networkConnectorStartExecutor);
1:ef84db5:     }
1:ef84db5: 
1:ef84db5:     public void startNetworkConnector(final NetworkConnector connector,
1:ef84db5:             final Set<ActiveMQDestination> durableDestinations,
1:ef84db5:             final ThreadPoolExecutor networkConnectorStartExecutor) throws Exception {
1:bab0887:         connector.setBrokerName(getBrokerName());
1:bab0887:         //set the durable destinations to match the broker if not set on the connector
1:bab0887:         if (connector.getDurableDestinations() == null) {
1:ef84db5:             connector.setDurableDestinations(durableDestinations);
1:bab0887:         }
1:bab0887:         String defaultSocketURI = getDefaultSocketURIString();
1:bab0887:         if (defaultSocketURI != null) {
1:bab0887:             connector.setBrokerURL(defaultSocketURI);
1:bab0887:         }
1:bab0887:         //If using the runtime plugin to start a network connector then the mbean needs
1:bab0887:         //to be added, under normal start it will already exist so check for InstanceNotFoundException
1:bab0887:         if (isUseJmx()) {
1:bab0887:             ObjectName networkMbean = createNetworkConnectorObjectName(connector);
1:bab0887:             try {
1:bab0887:                 getManagementContext().getObjectInstance(networkMbean);
1:bab0887:             } catch (InstanceNotFoundException e) {
1:bab0887:                 LOG.debug("Network connector MBean {} not found, registering", networkMbean);
1:bab0887:                 registerNetworkConnectorMBean(connector);
1:bab0887:             }
1:bab0887:         }
1:bab0887:         if (networkConnectorStartExecutor != null) {
1:bab0887:             networkConnectorStartExecutor.execute(new Runnable() {
1:bab0887:                 @Override
1:bab0887:                 public void run() {
1:bab0887:                     try {
1:bab0887:                         LOG.info("Async start of {}", connector);
1:bab0887:                         connector.start();
1:bab0887:                     } catch(Exception e) {
1:bab0887:                         LOG.error("Async start of network connector: {} failed", connector, e);
1:bab0887:                     }
1:bab0887:                 }
1:bab0887:             });
1:bab0887:         } else {
1:bab0887:             connector.start();
1:bab0887:         }
1:bab0887:     }
1:bab0887: 
1:7c2735d:     public TransportConnector startTransportConnector(TransportConnector connector) throws Exception {
1:7c2735d:         connector.setBrokerService(this);
1:f8c268d:         connector.setTaskRunnerFactory(getTaskRunnerFactory());
1:a640ff5:         MessageAuthorizationPolicy policy = getMessageAuthorizationPolicy();
1:a640ff5:         if (policy != null) {
1:a640ff5:             connector.setMessageAuthorizationPolicy(policy);
1:f38908e:         }
1:230a86c:         if (isUseJmx()) {
1:c9b8905:             connector = registerConnectorMBean(connector);
1:f38908e:         }
1:d301b41:         connector.getStatistics().setEnabled(enableStatistics);
1:f38908e:         connector.start();
1:e34cbc1:         return connector;
1:f38908e:     }
1:f38908e: 
1:d29ca2a:     /**
1:90d0c4b:      * Perform any custom dependency injection
1:d29ca2a:      */
1:42b768a:     protected void configureServices(Object[] services) {
1:42b768a:         for (Object service : services) {
1:98497b1:             configureService(service);
1:2251ba0:         }
1:2251ba0:     }
1:4098942: 
1:42b768a:     /**
1:42b768a:      * Perform any custom dependency injection
1:42b768a:      */
1:90d0c4b:     protected void configureService(Object service) {
1:90d0c4b:         if (service instanceof BrokerServiceAware) {
1:f1b6362:             BrokerServiceAware serviceAware = (BrokerServiceAware) service;
1:90d0c4b:             serviceAware.setBrokerService(this);
1:98497b1:         }
1:f1b6362:     }
1:4098942: 
1:e8a641c:     public void handleIOException(IOException exception) {
1:e8a641c:         if (ioExceptionHandler != null) {
1:e8a641c:             ioExceptionHandler.handle(exception);
1:f38908e:          } else {
1:e1bbde7:             LOG.info("No IOExceptionHandler registered, ignoring IO exception", exception);
1:f1b6362:          }
1:4098942:     }
1:7f89b33: 
1:b6f63b0:     protected void startVirtualConsumerDestinations() throws Exception {
1:da076f4:         checkStartException();
1:b6f63b0:         ConnectionContext adminConnectionContext = getAdminConnectionContext();
1:b6f63b0:         Set<ActiveMQDestination> destinations = destinationFactory.getDestinations();
1:b6f63b0:         DestinationFilter filter = getVirtualTopicConsumerDestinationFilter();
1:b6f63b0:         if (!destinations.isEmpty()) {
1:b6f63b0:             for (ActiveMQDestination destination : destinations) {
1:b6f63b0:                 if (filter.matches(destination) == true) {
1:b6f63b0:                     broker.addDestination(adminConnectionContext, destination, false);
1:b6f63b0:                 }
1:4098942:             }
1:4098942:         }
1:4098942:     }
1:145c80a: 
1:b6f63b0:     private DestinationFilter getVirtualTopicConsumerDestinationFilter() {
1:b6f63b0:         // created at startup, so no sync needed
1:b6f63b0:         if (virtualConsumerDestinationFilter == null) {
1:56917c0:             Set <ActiveMQQueue> consumerDestinations = new HashSet<>();
1:5453b26:             if (destinationInterceptors != null) {
1:5453b26:                 for (DestinationInterceptor interceptor : destinationInterceptors) {
1:5453b26:                     if (interceptor instanceof VirtualDestinationInterceptor) {
1:5453b26:                         VirtualDestinationInterceptor virtualDestinationInterceptor = (VirtualDestinationInterceptor) interceptor;
1:5453b26:                         for (VirtualDestination virtualDestination: virtualDestinationInterceptor.getVirtualDestinations()) {
1:5453b26:                             if (virtualDestination instanceof VirtualTopic) {
1:5453b26:                                 consumerDestinations.add(new ActiveMQQueue(((VirtualTopic) virtualDestination).getPrefix() + DestinationFilter.ANY_DESCENDENT));
1:5453b26:                             }
1:cc81680:                             if (isUseVirtualDestSubs()) {
1:cc81680:                                 try {
1:cc81680:                                     broker.virtualDestinationAdded(getAdminConnectionContext(), virtualDestination);
1:cc81680:                                     LOG.debug("Adding virtual destination: {}", virtualDestination);
1:cc81680:                                 } catch (Exception e) {
1:cc81680:                                     LOG.warn("Could not fire virtual destination consumer advisory", e);
1:cc81680:                                 }
1:cc81680:                             }
1:b6f63b0:                         }
1:b6f63b0:                     }
1:b6f63b0:                 }
1:b6f63b0:             }
1:b6f63b0:             ActiveMQQueue filter = new ActiveMQQueue();
1:b6f63b0:             filter.setCompositeDestinations(consumerDestinations.toArray(new ActiveMQDestination[]{}));
1:b6f63b0:             virtualConsumerDestinationFilter = DestinationFilter.parseFilter(filter);
1:b6f63b0:         }
1:b6f63b0:         return virtualConsumerDestinationFilter;
1:b6f63b0:     }
1:b6f63b0: 
1:1a5ad28:     protected synchronized ThreadPoolExecutor getExecutor() {
1:1a5ad28:         if (this.executor == null) {
1:5cd9eba:             this.executor = new ThreadPoolExecutor(1, 10, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
1:5cd9eba: 
1:5cd9eba:                 private long i = 0;
1:5cd9eba: 
1:f21992e:                 @Override
1:3cd8da8:                 public Thread newThread(Runnable runnable) {
1:5cd9eba:                     this.i++;
1:c659506:                     Thread thread = new Thread(runnable, "ActiveMQ BrokerService.worker." + this.i);
1:3cd8da8:                     thread.setDaemon(true);
1:5cd9eba:                     thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
1:f21992e:                         @Override
1:5cd9eba:                         public void uncaughtException(final Thread t, final Throwable e) {
1:5cd9eba:                             LOG.error("Error in thread '{}'", t.getName(), e);
1:5cd9eba:                         }
1:f38908e:                     });
1:3cd8da8:                     return thread;
1:5cd9eba:                 }
1:5cd9eba:             }, new RejectedExecutionHandler() {
1:5cd9eba:                 @Override
1:5cd9eba:                 public void rejectedExecution(final Runnable r, final ThreadPoolExecutor executor) {
1:f38908e:                     try {
1:5cd9eba:                         executor.getQueue().offer(r, 60, TimeUnit.SECONDS);
1:5cd9eba:                     } catch (InterruptedException e) {
1:5cd9eba:                         throw new RejectedExecutionException("Interrupted waiting for BrokerService.worker");
1:5cd9eba:                     }
1:5cd9eba: 
1:5cd9eba:                     throw new RejectedExecutionException("Timed Out while attempting to enqueue Task.");
1:5cd9eba:                 }
1:3cd8da8:             });
1:1a5ad28:         }
1:1a5ad28:         return this.executor;
1:1a5ad28:     }
1:f0d9f83: 
1:c42d8de:     public synchronized Scheduler getScheduler() {
1:1a5ad28:         if (this.scheduler==null) {
1:1a5ad28:             this.scheduler = new Scheduler("ActiveMQ Broker["+getBrokerName()+"] Scheduler");
1:5cd9eba:             try {
1:1a5ad28:                 this.scheduler.start();
1:1a5ad28:             } catch (Exception e) {
1:ea1d02d:                LOG.error("Failed to start Scheduler", e);
1:1a5ad28:             }
1:1a5ad28:         }
1:1a5ad28:         return this.scheduler;
1:1a5ad28:     }
1:7333847: 
1:13829ef:     public Broker getRegionBroker() {
1:1096564:         return regionBroker;
1:ed58e9a:     }
1:e8a641c: 
1:13829ef:     public void setRegionBroker(Broker regionBroker) {
1:13829ef:         this.regionBroker = regionBroker;
1:88fbb05:     }
1:620b657: 
1:155461a:     public final void removePreShutdownHook(final Runnable hook) {
1:155461a:         preShutdownHooks.remove(hook);
1:155461a:     }
1:155461a: 
1:b4f65ba:     public void addShutdownHook(Runnable hook) {
1:1ec71bd:         synchronized (shutdownHooks) {
1:b4f65ba:             shutdownHooks.add(hook);
1:ed58e9a:         }
1:ed58e9a:     }
1:1ec71bd: 
1:b4f65ba:     public void removeShutdownHook(Runnable hook) {
1:1ec71bd:         synchronized (shutdownHooks) {
1:b4f65ba:             shutdownHooks.remove(hook);
1:ed58e9a:         }
1:ed58e9a:     }
1:e8a641c: 
1:b4f65ba:     public boolean isSystemExitOnShutdown() {
1:b4f65ba:         return systemExitOnShutdown;
1:ed58e9a:     }
1:f528aa5: 
1:1462fd2:     /**
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:1462fd2:      */
1:b4f65ba:     public void setSystemExitOnShutdown(boolean systemExitOnShutdown) {
1:b4f65ba:         this.systemExitOnShutdown = systemExitOnShutdown;
1:ed58e9a:     }
1:f528aa5: 
1:139a220:     public int getSystemExitOnShutdownExitCode() {
1:139a220:         return systemExitOnShutdownExitCode;
1:7f89b33:     }
1:f528aa5: 
1:139a220:     public void setSystemExitOnShutdownExitCode(int systemExitOnShutdownExitCode) {
1:139a220:         this.systemExitOnShutdownExitCode = systemExitOnShutdownExitCode;
1:7f89b33:     }
1:f528aa5: 
1:139a220:     public SslContext getSslContext() {
1:139a220:         return sslContext;
1:7f89b33:     }
1:f528aa5: 
1:139a220:     public void setSslContext(SslContext sslContext) {
1:139a220:         this.sslContext = sslContext;
1:d14e4ae:     }
1:b3873fb: 
1:1ec71bd:     public boolean isShutdownOnSlaveFailure() {
1:1ec71bd:         return shutdownOnSlaveFailure;
1:1ec71bd:     }
1:d14e4ae: 
1:1462fd2:     /**
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:1462fd2:      */
1:1ec71bd:     public void setShutdownOnSlaveFailure(boolean shutdownOnSlaveFailure) {
1:1ec71bd:         this.shutdownOnSlaveFailure = shutdownOnSlaveFailure;
1:1ec71bd:     }
1:d14e4ae: 
1:1ec71bd:     public boolean isWaitForSlave() {
1:1ec71bd:         return waitForSlave;
1:1ec71bd:     }
1:d14e4ae: 
1:1462fd2:     /**
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:1462fd2:      */
1:1ec71bd:     public void setWaitForSlave(boolean waitForSlave) {
1:1ec71bd:         this.waitForSlave = waitForSlave;
1:1ec71bd:     }
1:e80bf00: 
1:e80bf00:     public long getWaitForSlaveTimeout() {
1:e80bf00:         return this.waitForSlaveTimeout;
1:e80bf00:     }
1:e80bf00: 
1:e80bf00:     public void setWaitForSlaveTimeout(long waitForSlaveTimeout) {
1:e80bf00:         this.waitForSlaveTimeout = waitForSlaveTimeout;
1:e80bf00:     }
1:e80bf00: 
3:90d0c4b:     /**
1:4228281:      * Get the passiveSlave
1:4228281:      * @return the passiveSlave
1:4228281:      */
1:4228281:     public boolean isPassiveSlave() {
1:4228281:         return this.passiveSlave;
1:4228281:     }
1:f0d9f83: 
1:4228281:     /**
1:4228281:      * Set the passiveSlave
1:4228281:      * @param passiveSlave the passiveSlave to set
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:4228281:      */
1:4228281:     public void setPassiveSlave(boolean passiveSlave) {
1:4228281:         this.passiveSlave = passiveSlave;
1:4228281:     }
1:4150650: 
1:4150650:     /**
1:4150650:      * override the Default IOException handler, called when persistence adapter
1:4150650:      * has experiences File or JDBC I/O Exceptions
1:4150650:      *
1:4150650:      * @param ioExceptionHandler
1:4150650:      */
1:e8a641c:     public void setIoExceptionHandler(IOExceptionHandler ioExceptionHandler) {
1:4150650:         configureService(ioExceptionHandler);
1:e8a641c:         this.ioExceptionHandler = ioExceptionHandler;
1:1ec71bd:     }
1:f0d9f83: 
1:4150650:     public IOExceptionHandler getIoExceptionHandler() {
1:4150650:         return ioExceptionHandler;
1:4150650:     }
1:4150650: 
1:7ae2055:     /**
1:7ae2055:      * @return the schedulerSupport
1:7ae2055:      */
1:7ae2055:     public boolean isSchedulerSupport() {
1:433912f:         return this.schedulerSupport;
1:7ae2055:     }
1:7ae2055: 
1:7ae2055:     /**
1:7ae2055:      * @param schedulerSupport the schedulerSupport to set
1:1462fd2:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:7ae2055:      */
1:7ae2055:     public void setSchedulerSupport(boolean schedulerSupport) {
1:7ae2055:         this.schedulerSupport = schedulerSupport;
1:7ae2055:     }
1:7ae2055: 
1:7ae2055:     /**
1:7ae2055:      * @return the schedulerDirectory
1:7ae2055:      */
1:7ae2055:     public File getSchedulerDirectoryFile() {
1:7ae2055:         if (this.schedulerDirectoryFile == null) {
1:adb76e5:             this.schedulerDirectoryFile = new File(getBrokerDataDirectory(), "scheduler");
1:7ae2055:         }
1:7ae2055:         return schedulerDirectoryFile;
1:7ae2055:     }
1:7ae2055: 
1:7ae2055:     /**
1:7ae2055:      * @param schedulerDirectory the schedulerDirectory to set
1:7ae2055:      */
1:7ae2055:     public void setSchedulerDirectoryFile(File schedulerDirectory) {
1:7ae2055:         this.schedulerDirectoryFile = schedulerDirectory;
1:7ae2055:     }
1:f0d9f83: 
1:7ae2055:     public void setSchedulerDirectory(String schedulerDirectory) {
1:7ae2055:         setSchedulerDirectoryFile(new File(schedulerDirectory));
1:2705e36:     }
1:2705e36: 
1:2705e36:     public int getSchedulePeriodForDestinationPurge() {
1:2705e36:         return this.schedulePeriodForDestinationPurge;
1:2705e36:     }
1:2705e36: 
1:2705e36:     public void setSchedulePeriodForDestinationPurge(int schedulePeriodForDestinationPurge) {
1:2705e36:         this.schedulePeriodForDestinationPurge = schedulePeriodForDestinationPurge;
1:1a5ad28:     }
1:7ae2055: 
1:4cddd2c:     /**
1:4cddd2c:      * @param schedulePeriodForDiskUsageCheck
1:4cddd2c:      */
1:61fd811:     public void setSchedulePeriodForDiskUsageCheck(
1:61fd811:             int schedulePeriodForDiskUsageCheck) {
1:61fd811:         this.schedulePeriodForDiskUsageCheck = schedulePeriodForDiskUsageCheck;
1:61fd811:     }
1:61fd811: 
1:4cddd2c:     public int getDiskUsageCheckRegrowThreshold() {
1:4cddd2c:         return diskUsageCheckRegrowThreshold;
1:4cddd2c:     }
1:4cddd2c: 
1:4cddd2c:     /**
1:4cddd2c:      * @param diskUsageCheckRegrowThreshold
1:4cddd2c:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:4cddd2c:      */
1:4cddd2c:     public void setDiskUsageCheckRegrowThreshold(int diskUsageCheckRegrowThreshold) {
1:4cddd2c:         this.diskUsageCheckRegrowThreshold = diskUsageCheckRegrowThreshold;
1:4cddd2c:     }
1:4cddd2c: 
1:f0d9f83:     public int getMaxPurgedDestinationsPerSweep() {
1:f0d9f83:         return this.maxPurgedDestinationsPerSweep;
1:f0d9f83:     }
1:f0d9f83: 
1:f0d9f83:     public void setMaxPurgedDestinationsPerSweep(int maxPurgedDestinationsPerSweep) {
1:f0d9f83:         this.maxPurgedDestinationsPerSweep = maxPurgedDestinationsPerSweep;
1:f0d9f83:     }
1:f0d9f83: 
1:11705e7:     public BrokerContext getBrokerContext() {
1:11705e7:         return brokerContext;
1:7ae2055:     }
1:d14e4ae: 
1:11705e7:     public void setBrokerContext(BrokerContext brokerContext) {
1:11705e7:         this.brokerContext = brokerContext;
1:d14e4ae:     }
1:d14e4ae: 
1:996b7a5:     public void setBrokerId(String brokerId) {
1:996b7a5:         this.brokerId = new BrokerId(brokerId);
1:6f68a94:     }
1:6f68a94: 
1:286c9d0:     public boolean isUseAuthenticatedPrincipalForJMSXUserID() {
1:286c9d0:         return useAuthenticatedPrincipalForJMSXUserID;
1:6f68a94:     }
1:6f68a94: 
1:286c9d0:     public void setUseAuthenticatedPrincipalForJMSXUserID(boolean useAuthenticatedPrincipalForJMSXUserID) {
1:286c9d0:         this.useAuthenticatedPrincipalForJMSXUserID = useAuthenticatedPrincipalForJMSXUserID;
1:d14e4ae:     }
1:11705e7: 
1:f5dcc9d:     /**
1:f5dcc9d:      * Should MBeans that support showing the Authenticated User Name information have this
1:f5dcc9d:      * value filled in or not.
1:f5dcc9d:      *
1:f5dcc9d:      * @return true if user names should be exposed in MBeans
1:f5dcc9d:      */
1:f5dcc9d:     public boolean isPopulateUserNameInMBeans() {
1:f5dcc9d:         return this.populateUserNameInMBeans;
1:f5dcc9d:     }
1:f5dcc9d: 
1:f5dcc9d:     /**
1:f5dcc9d:      * Sets whether Authenticated User Name information is shown in MBeans that support this field.
1:6c1676b:      * @param value if MBeans should expose user name information.
1:f5dcc9d:      */
1:f5dcc9d:     public void setPopulateUserNameInMBeans(boolean value) {
1:f5dcc9d:         this.populateUserNameInMBeans = value;
1:f5dcc9d:     }
1:f5dcc9d: 
1:584c133:     /**
1:584c133:      * Gets the time in Milliseconds that an invocation of an MBean method will wait before
1:584c133:      * failing.  The default value is to wait forever (zero).
1:584c133:      *
1:584c133:      * @return timeout in milliseconds before MBean calls fail, (default is 0 or no timeout).
1:584c133:      */
1:584c133:     public long getMbeanInvocationTimeout() {
1:584c133:         return mbeanInvocationTimeout;
1:584c133:     }
1:584c133: 
1:584c133:     /**
1:584c133:      * Gets the time in Milliseconds that an invocation of an MBean method will wait before
1:584c133:      * failing. The default value is to wait forever (zero).
1:584c133:      *
1:584c133:      * @param mbeanInvocationTimeout
1:584c133:      *      timeout in milliseconds before MBean calls fail, (default is 0 or no timeout).
1:584c133:      */
1:584c133:     public void setMbeanInvocationTimeout(long mbeanInvocationTimeout) {
1:584c133:         this.mbeanInvocationTimeout = mbeanInvocationTimeout;
1:584c133:     }
1:584c133: 
1:f38908e:     public boolean isNetworkConnectorStartAsync() {
1:f38908e:         return networkConnectorStartAsync;
1:f38908e:     }
1:f38908e: 
1:f38908e:     public void setNetworkConnectorStartAsync(boolean networkConnectorStartAsync) {
1:f38908e:         this.networkConnectorStartAsync = networkConnectorStartAsync;
1:f38908e:     }
1:254d920: 
1:254d920:     public boolean isAllowTempAutoCreationOnSend() {
1:254d920:         return allowTempAutoCreationOnSend;
1:254d920:     }
1:254d920: 
1:254d920:     /**
1:254d920:      * enable if temp destinations need to be propagated through a network when
1:254d920:      * advisorySupport==false. This is used in conjunction with the policy
1:254d920:      * gcInactiveDestinations for matching temps so they can get removed
1:254d920:      * when inactive
1:254d920:      *
1:254d920:      * @param allowTempAutoCreationOnSend
1:254d920:      */
1:254d920:     public void setAllowTempAutoCreationOnSend(boolean allowTempAutoCreationOnSend) {
1:254d920:         this.allowTempAutoCreationOnSend = allowTempAutoCreationOnSend;
1:254d920:     }
1:6f70393: 
1:3cd8da8:     public long getOfflineDurableSubscriberTimeout() {
1:6f70393:         return offlineDurableSubscriberTimeout;
1:d14e4ae:     }
1:6f70393: 
1:3cd8da8:     public void setOfflineDurableSubscriberTimeout(long offlineDurableSubscriberTimeout) {
1:6f70393:         this.offlineDurableSubscriberTimeout = offlineDurableSubscriberTimeout;
1:d14e4ae:     }
1:6f70393: 
1:3cd8da8:     public long getOfflineDurableSubscriberTaskSchedule() {
1:6f70393:         return offlineDurableSubscriberTaskSchedule;
1:6f70393:     }
1:6f70393: 
1:3cd8da8:     public void setOfflineDurableSubscriberTaskSchedule(long offlineDurableSubscriberTaskSchedule) {
1:6f70393:         this.offlineDurableSubscriberTaskSchedule = offlineDurableSubscriberTaskSchedule;
1:6f70393:     }
1:b6f63b0: 
1:b6f63b0:     public boolean shouldRecordVirtualDestination(ActiveMQDestination destination) {
1:b6f63b0:         return isUseVirtualTopics() && destination.isQueue() &&
1:b6f63b0:                getVirtualTopicConsumerDestinationFilter().matches(destination);
1:b6f63b0:     }
1:7f89b33: 
1:da076f4:     synchronized public Throwable getStartException() {
1:7f89b33:         return startException;
1:7f89b33:     }
1:eebe135: 
1:eebe135:     public boolean isStartAsync() {
1:eebe135:         return startAsync;
1:eebe135:     }
1:eebe135: 
1:eebe135:     public void setStartAsync(boolean startAsync) {
1:eebe135:         this.startAsync = startAsync;
1:eebe135:     }
1:d75e418: 
1:d75e418:     public boolean isSlave() {
1:d75e418:         return this.slave;
1:d75e418:     }
1:d75e418: 
1:3a8eb74:     public boolean isStopping() {
1:3a8eb74:         return this.stopping.get();
1:3a8eb74:     }
1:11705e7: 
1:4a16c1f:     /**
1:4a16c1f:      * @return true if the broker allowed to restart on shutdown.
1:4a16c1f:      */
1:4a16c1f:     public boolean isRestartAllowed() {
1:4a16c1f:         return restartAllowed;
1:6f70393:     }
1:e8a641c: 
1:4a16c1f:     /**
1:4a16c1f:      * Sets if the broker allowed to restart on shutdown.
1:4a16c1f:      */
1:4a16c1f:     public void setRestartAllowed(boolean restartAllowed) {
1:4a16c1f:         this.restartAllowed = restartAllowed;
1:996b7a5:     }
1:62e1abf: 
1:4a16c1f:     /**
1:4a16c1f:      * A lifecycle manager of the BrokerService should
1:4a16c1f:      * inspect this property after a broker shutdown has occurred
1:4a16c1f:      * to find out if the broker needs to be re-created and started
1:4a16c1f:      * again.
1:4a16c1f:      *
1:4a16c1f:      * @return true if the broker wants to be restarted after it shuts down.
1:4a16c1f:      */
1:4a16c1f:     public boolean isRestartRequested() {
1:4a16c1f:         return restartRequested;
1:11705e7:     }
1:62e1abf: 
1:4a16c1f:     public void requestRestart() {
1:4a16c1f:         this.restartRequested = true;
1:11705e7:     }
1:62e1abf: 
1:ec9975c:     public int getStoreOpenWireVersion() {
1:ec9975c:         return storeOpenWireVersion;
1:e8a641c:     }
1:62e1abf: 
1:ec9975c:     public void setStoreOpenWireVersion(int storeOpenWireVersion) {
1:ec9975c:         this.storeOpenWireVersion = storeOpenWireVersion;
1:3630a41:     }
1:fde22a8: 
1:fde22a8:     /**
1:fde22a8:      * @return the current number of connections on this Broker.
1:fde22a8:      */
1:fde22a8:     public int getCurrentConnections() {
1:fde22a8:         return this.currentConnections.get();
1:fde22a8:     }
1:fde22a8: 
1:fde22a8:     /**
1:fde22a8:      * @return the total number of connections this broker has handled since startup.
1:fde22a8:      */
1:fde22a8:     public long getTotalConnections() {
1:fde22a8:         return this.totalConnections.get();
1:fde22a8:     }
1:fde22a8: 
1:fde22a8:     public void incrementCurrentConnections() {
1:fde22a8:         this.currentConnections.incrementAndGet();
1:fde22a8:     }
1:fde22a8: 
1:fde22a8:     public void decrementCurrentConnections() {
1:fde22a8:         this.currentConnections.decrementAndGet();
1:fde22a8:     }
1:fde22a8: 
1:fde22a8:     public void incrementTotalConnections() {
1:fde22a8:         this.totalConnections.incrementAndGet();
1:fde22a8:     }
1:741e3aa: 
1:741e3aa:     public boolean isRejectDurableConsumers() {
1:741e3aa:         return rejectDurableConsumers;
1:741e3aa:     }
1:741e3aa: 
1:741e3aa:     public void setRejectDurableConsumers(boolean rejectDurableConsumers) {
1:741e3aa:         this.rejectDurableConsumers = rejectDurableConsumers;
1:741e3aa:     }
1:cc81680: 
1:cc81680:     public boolean isUseVirtualDestSubs() {
1:cc81680:         return useVirtualDestSubs;
1:cc81680:     }
1:cc81680: 
1:cc81680:     public void setUseVirtualDestSubs(
1:cc81680:             boolean useVirtualDestSubs) {
1:cc81680:         this.useVirtualDestSubs = useVirtualDestSubs;
1:cc81680:     }
1:cc81680: 
1:cc81680:     public boolean isUseVirtualDestSubsOnCreation() {
1:cc81680:         return useVirtualDestSubsOnCreation;
1:cc81680:     }
1:cc81680: 
1:cc81680:     public void setUseVirtualDestSubsOnCreation(
1:cc81680:             boolean useVirtualDestSubsOnCreation) {
1:cc81680:         this.useVirtualDestSubsOnCreation = useVirtualDestSubsOnCreation;
1:cc81680:     }
1:d7febdd: 
1:d7febdd:     public boolean isAdjustUsageLimits() {
1:d7febdd:         return adjustUsageLimits;
1:d7febdd:     }
1:d7febdd: 
1:d7febdd:     public void setAdjustUsageLimits(boolean adjustUsageLimits) {
1:d7febdd:         this.adjustUsageLimits = adjustUsageLimits;
1:d7febdd:     }
1:fe9d99e: 
1:fe9d99e:     public void setRollbackOnlyOnAsyncException(boolean rollbackOnlyOnAsyncException) {
1:fe9d99e:         this.rollbackOnlyOnAsyncException = rollbackOnlyOnAsyncException;
1:fe9d99e:     }
1:fe9d99e: 
1:fe9d99e:     public boolean isRollbackOnlyOnAsyncException() {
1:fe9d99e:         return rollbackOnlyOnAsyncException;
1:fe9d99e:     }
1:3630a41: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:cdb38b3
/////////////////////////////////////////////////////////////////////////
1:                     } catch (Throwable e) {
1:                     } catch (Throwable e) {
commit:d84a586
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 connector.setLocalUri(getVmConnectorURI());
commit:8a28c06
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.PercentLimitUsage;
/////////////////////////////////////////////////////////////////////////
1:     protected void checkUsageLimit(File dir, PercentLimitUsage<?> storeUsage, int percentLimit) throws ConfigurationException {
1:             long totalSpace = storeUsage.getTotal() > 0 ? storeUsage.getTotal() : dir.getTotalSpace();
1:             long totalUsableSpace = (storeUsage.getTotal() > 0 ? storeUsage.getTotal() : dir.getUsableSpace()) + storeCurrent;
1:             if (totalUsableSpace < 0 || totalSpace < 0) {
1:                 final String message = "File system space reported by: " + dir + " was negative, possibly a huge file system, set a sane usage.total to provide some guidance";
1:                 LOG.error(message);
1:                 throw new ConfigurationException(message);
/////////////////////////////////////////////////////////////////////////
1:                     && storeUsage.getTotal() == 0
commit:b6759b3
/////////////////////////////////////////////////////////////////////////
1:         if (tempDataStore != null) {
1:             if (tmpDataDirectory == null) {
1:                 tmpDataDirectory = tempDataStore.getDirectory();
1:             } else if (tempDataStore.getDirectory() == null) {
1:                 tempDataStore.setDirectory(tmpDataDirectory);
1:             }
1:         }
commit:fe9d99e
/////////////////////////////////////////////////////////////////////////
1:     private boolean rollbackOnlyOnAsyncException = true;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setRollbackOnlyOnAsyncException(boolean rollbackOnlyOnAsyncException) {
1:         this.rollbackOnlyOnAsyncException = rollbackOnlyOnAsyncException;
1:     }
1: 
1:     public boolean isRollbackOnlyOnAsyncException() {
1:         return rollbackOnlyOnAsyncException;
1:     }
commit:b0c0441
/////////////////////////////////////////////////////////////////////////
1:     private static final String brokerNameReplacedCharsRegExp = "[^a-zA-Z0-9\\.\\_\\-\\:]";
1:         String str = brokerName.replaceAll(brokerNameReplacedCharsRegExp, "_");
1:             LOG.error("Broker Name: {} contained illegal characters matching regExp: {} - replaced with {}", brokerName, brokerNameReplacedCharsRegExp, str);
/////////////////////////////////////////////////////////////////////////
1:                 vmConnectorURI = new URI("vm://" + getBrokerName());
/////////////////////////////////////////////////////////////////////////
0:         map.put("create","false");
commit:455a628
/////////////////////////////////////////////////////////////////////////
1:         PersistenceAdapter persistenceAdapterToStart = getPersistenceAdapter();
1:         if (persistenceAdapterToStart == null) {
1:             checkStartException();
1:             throw new ConfigurationException("Cannot start null persistence adapter");
1:         }
1:         persistenceAdapterToStart.setUsageManager(getProducerSystemUsage());
1:         persistenceAdapterToStart.setBrokerName(getBrokerName());
1:         LOG.info("Using Persistence Adapter: {}", persistenceAdapterToStart);
1:         persistenceAdapterToStart.start();
commit:35df815
/////////////////////////////////////////////////////////////////////////
1:         setStartException(new BrokerStoppedException("Stop invoked"));
/////////////////////////////////////////////////////////////////////////
1:                 stopper.stop(managementContext);
/////////////////////////////////////////////////////////////////////////
1:         if (persistenceAdapter == null && !hasStartException()) {
/////////////////////////////////////////////////////////////////////////
1:     synchronized private boolean hasStartException() {
1:         return startException != null;
1:     }
1: 
commit:da076f4
/////////////////////////////////////////////////////////////////////////
1:         setStartException(null);
/////////////////////////////////////////////////////////////////////////
1:                         setStartException(e);
/////////////////////////////////////////////////////////////////////////
1:                         setStartException(t);
/////////////////////////////////////////////////////////////////////////
1:         checkStartException();
/////////////////////////////////////////////////////////////////////////
1:         if (started.get()) {
0:             setStartException(new BrokerStoppedException("Stop invoked"));
1:         }
/////////////////////////////////////////////////////////////////////////
1:             stopper.stop(getPersistenceAdapter());
/////////////////////////////////////////////////////////////////////////
1:                 if (getStartException() != null) {
/////////////////////////////////////////////////////////////////////////
1:             checkStartException();
/////////////////////////////////////////////////////////////////////////
1:     public synchronized PersistenceAdapter getPersistenceAdapter() throws IOException {
1:             checkStartException();
/////////////////////////////////////////////////////////////////////////
1:             checkStartException();
1:     synchronized private void checkStartException() {
1:         if (startException != null) {
1:             throw new BrokerStoppedException(startException);
1:         }
1:     }
1: 
1:     synchronized private void setStartException(Throwable t) {
1:         startException = t;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         checkStartException();
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Throwable getStartException() {
commit:768fa17
/////////////////////////////////////////////////////////////////////////
1:         getTempDataStore();
1:         if (tempDataStore != null) {
1:             try {
1:                 // start after we have the store lock
1:                 tempDataStore.start();
1:             } catch (Exception e) {
1:                 RuntimeException exception = new RuntimeException(
1:                         "Failed to start temp data store: " + tempDataStore, e);
1:                 LOG.error(exception.getLocalizedMessage(), e);
1:                 throw exception;
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d7febdd
/////////////////////////////////////////////////////////////////////////
1:     private boolean adjustUsageLimits = true;
/////////////////////////////////////////////////////////////////////////
1:             checkMemorySystemUsageLimits();
/////////////////////////////////////////////////////////////////////////
1:         checkStoreSystemUsageLimits();
/////////////////////////////////////////////////////////////////////////
1:     protected void checkStoreUsageLimits() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     protected void checkTmpStoreUsageLimits() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     protected void checkUsageLimit(File dir, Usage<?> storeUsage, int percentLimit) throws ConfigurationException {
/////////////////////////////////////////////////////////////////////////
1:                 final String message = storeName + " limit is " +  storeLimit / oneMeg
1:                         + " mb (current store usage is " + storeCurrent / oneMeg
1:                         + " mb). The data directory: " + dir.getAbsolutePath()
1:                         + " only has " + totalUsableSpace / oneMeg
1:                         + " mb of usable space.";
1: 
1:                 if (!isAdjustUsageLimits()) {
1:                     LOG.error(message);
1:                     throw new ConfigurationException(message);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 } else {
1:                     LOG.warn(message + " - resetting to maximum available disk space: " +
1:                             totalUsableSpace / oneMeg + " mb");
/////////////////////////////////////////////////////////////////////////
1:                     } catch (Exception e) {
1:                     } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1:     protected void checkMemorySystemUsageLimits() throws Exception {
1:             final String message = "Memory Usage for the Broker (" + memLimit / (1024 * 1024)
1:                     + "mb) is more than the maximum available for the JVM: " + jvmLimit / (1024 * 1024);
1: 
1:             if (adjustUsageLimits) {
1:                 usage.getMemoryUsage().setPercentOfJvmHeap(70);
1:                 LOG.warn(message + " mb - resetting to 70% of maximum available: " + (usage.getMemoryUsage().getLimit() / (1024 * 1024)) + " mb");
1:             } else {
1:                 LOG.error(message);
1:                 throw new ConfigurationException(message);
1:             }
1:     }
1: 
1:     protected void checkStoreSystemUsageLimits() throws Exception {
1:         final SystemUsage usage = getSystemUsage();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isAdjustUsageLimits() {
1:         return adjustUsageLimits;
1:     }
1: 
1:     public void setAdjustUsageLimits(boolean adjustUsageLimits) {
1:         this.adjustUsageLimits = adjustUsageLimits;
1:     }
commit:dc19d28
/////////////////////////////////////////////////////////////////////////
1:             if (storeLimit > 0 && storeLimit < maxJournalFileSize) {
/////////////////////////////////////////////////////////////////////////
1:                 if (storeLimit > 0 && storeLimit < maxJournalFileSize) {
commit:3100909
/////////////////////////////////////////////////////////////////////////
1:         connector.setLocalUri(getVmConnectorURI());
/////////////////////////////////////////////////////////////////////////
commit:c129051
/////////////////////////////////////////////////////////////////////////
1: 
1:         getJobSchedulerStore();
1:         if (jobSchedulerStore != null) {
1:             try {
1:                 jobSchedulerStore.start();
1:             } catch (Exception e) {
1:                 RuntimeException exception = new RuntimeException(
1:                         "Failed to start job scheduler store: " + jobSchedulerStore, e);
1:                 LOG.error(exception.getLocalizedMessage(), e);
1:                 throw exception;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:741e3aa
/////////////////////////////////////////////////////////////////////////
1:     private boolean rejectDurableConsumers = false;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isRejectDurableConsumers() {
1:         return rejectDurableConsumers;
1:     }
1: 
1:     public void setRejectDurableConsumers(boolean rejectDurableConsumers) {
1:         this.rejectDurableConsumers = rejectDurableConsumers;
1:     }
commit:189a75a
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Memory Usage for the Broker (" + memLimit / (1024 * 1024) +
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Temporary Store limit is " + storeLimit / (1024 * 1024) +
commit:cf62d58
/////////////////////////////////////////////////////////////////////////
1:             throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e, e);
commit:7c2735d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public TransportConnector startTransportConnector(TransportConnector connector) throws Exception {
1:         connector.setBrokerService(this);
commit:8554193
/////////////////////////////////////////////////////////////////////////
0:                 long storeCurrent = usage.getStoreUsage().getUsage();
0:                 if (storeLimit > (dirFreeSpace + storeCurrent)) {
0:                              " mb (current store usage is " + storeCurrent / (1024 * 1024) +
0:                              " mb). The data directory: " + dir.getAbsolutePath() +
0:                             (dirFreeSpace + storeCurrent) / (1024 * 1024) + " mb");
0:                     usage.getStoreUsage().setLimit(dirFreeSpace + storeCurrent);
commit:5bdcc19
/////////////////////////////////////////////////////////////////////////
1:                 systemUsage.getMemoryUsage().setLimit(1024L * 1024 * 1024 * 1); // 1 GB
1:                 systemUsage.getJobSchedulerUsage().setLimit(1024L * 1024 * 1024 * 50); // 50 GB
/////////////////////////////////////////////////////////////////////////
0:             usage.getMemoryUsage().setPercentOfJvmHeap(70);
0:                       jvmLimit / (1024 * 1024) + " mb - resetting to 70% of maximum available: " + (usage.getMemoryUsage().getLimit() / (1024 * 1024)) + " mb");
commit:634a818
/////////////////////////////////////////////////////////////////////////
author:Christian Schneider
-------------------------------------------------------------------------------
commit:8646bb1
/////////////////////////////////////////////////////////////////////////
1:             } catch (ClassNotFoundException e) {
1:                 throw new RuntimeException("Kahadb class PListStoreImpl not found. Add activemq-kahadb jar or set persistent to false on BrokerService.", e);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:2311749
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean preShutdownHooksInvoked = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:     private final List<Runnable> preShutdownHooks = new CopyOnWriteArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         preShutdownHooksInvoked.set(false);
/////////////////////////////////////////////////////////////////////////
1:         //The preShutdownHooks need to run before stopping.compareAndSet()
1:         //so there is a separate AtomicBoolean so the hooks only run once
1:         //We want to make sure the hooks are run before stop is initialized
1:         //including setting the stopping variable - See AMQ-6706
1:         if (preShutdownHooksInvoked.compareAndSet(false, true)) {
1:             for (Runnable hook : preShutdownHooks) {
1:                 try {
1:                     hook.run();
1:                 } catch (Throwable e) {
1:                     stopper.onException(hook, e);
1:                 }
commit:ef84db5
/////////////////////////////////////////////////////////////////////////
1:         final Set<ActiveMQDestination> durableDestinations = getBroker().getDurableDestinations();
/////////////////////////////////////////////////////////////////////////
1:                 startNetworkConnector(connector, durableDestinations, networkConnectorStartExecutor);
/////////////////////////////////////////////////////////////////////////
1:         startNetworkConnector(connector, getBroker().getDurableDestinations(), networkConnectorStartExecutor);
1:     }
1: 
1:     public void startNetworkConnector(final NetworkConnector connector,
1:             final Set<ActiveMQDestination> durableDestinations,
1:             final ThreadPoolExecutor networkConnectorStartExecutor) throws Exception {
1:             connector.setDurableDestinations(durableDestinations);
commit:bab0887
/////////////////////////////////////////////////////////////////////////
1: import javax.management.InstanceNotFoundException;
/////////////////////////////////////////////////////////////////////////
1:     public ObjectName createNetworkConnectorObjectName(NetworkConnector connector) throws MalformedObjectNameException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 startNetworkConnector(connector, networkConnectorStartExecutor);
/////////////////////////////////////////////////////////////////////////
1:     public void startNetworkConnector(final NetworkConnector connector,
1:             final ThreadPoolExecutor networkConnectorStartExecutor) throws Exception {
1:         connector.setBrokerName(getBrokerName());
1:         //set the durable destinations to match the broker if not set on the connector
1:         if (connector.getDurableDestinations() == null) {
0:             connector.setDurableDestinations(getBroker().getDurableDestinations());
1:         }
1:         String defaultSocketURI = getDefaultSocketURIString();
1:         if (defaultSocketURI != null) {
1:             connector.setBrokerURL(defaultSocketURI);
1:         }
1:         //If using the runtime plugin to start a network connector then the mbean needs
1:         //to be added, under normal start it will already exist so check for InstanceNotFoundException
1:         if (isUseJmx()) {
1:             ObjectName networkMbean = createNetworkConnectorObjectName(connector);
1:             try {
1:                 getManagementContext().getObjectInstance(networkMbean);
1:             } catch (InstanceNotFoundException e) {
1:                 LOG.debug("Network connector MBean {} not found, registering", networkMbean);
1:                 registerNetworkConnectorMBean(connector);
1:             }
1:         }
1:         if (networkConnectorStartExecutor != null) {
1:             networkConnectorStartExecutor.execute(new Runnable() {
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         LOG.info("Async start of {}", connector);
1:                         connector.start();
1:                     } catch(Exception e) {
1:                         LOG.error("Async start of network connector: {} failed", connector, e);
1:                     }
1:                 }
1:             });
1:         } else {
1:             connector.start();
1:         }
1:     }
1: 
commit:5772e7b
/////////////////////////////////////////////////////////////////////////
1:      * Whether or not the creation of destinations that match virtual destinations
commit:cc81680
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Whether or not virtual destination subscriptions should cause network demand
1:      */
1:     private boolean useVirtualDestSubs = false;
1:     /**
0:      * Whether or no the creation of destinations that match virtual destinations
1:      * should cause network demand
1:      */
1:     private boolean useVirtualDestSubsOnCreation = false;
/////////////////////////////////////////////////////////////////////////
1:                             if (isUseVirtualDestSubs()) {
1:                                 try {
1:                                     broker.virtualDestinationAdded(getAdminConnectionContext(), virtualDestination);
1:                                     LOG.debug("Adding virtual destination: {}", virtualDestination);
1:                                 } catch (Exception e) {
1:                                     LOG.warn("Could not fire virtual destination consumer advisory", e);
1:                                 }
1:                             }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isUseVirtualDestSubs() {
1:         return useVirtualDestSubs;
1:     }
1: 
1:     public void setUseVirtualDestSubs(
1:             boolean useVirtualDestSubs) {
1:         this.useVirtualDestSubs = useVirtualDestSubs;
1:     }
1: 
1:     public boolean isUseVirtualDestSubsOnCreation() {
1:         return useVirtualDestSubsOnCreation;
1:     }
1: 
1:     public void setUseVirtualDestSubsOnCreation(
1:             boolean useVirtualDestSubsOnCreation) {
1:         this.useVirtualDestSubsOnCreation = useVirtualDestSubsOnCreation;
1:     }
commit:af09b45
/////////////////////////////////////////////////////////////////////////
1:                             + percentLimit + "% (" + bytePercentLimit / oneMeg + " mb)"
1:                             + " The current store limit (which may have been adjusted by a"
1:                             + " previous usage limit check) is set to (" + storeLimit / oneMeg + " mb)"
1:                             + " but only " + totalUsableSpace * 100 / totalSpace + "% (" + totalUsableSpace / oneMeg + " mb)"
1:                             + " is available - resetting limit");
commit:6fef9ee
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                          " only has " + totalUsableSpace / oneMeg +
commit:4cddd2c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.StoreUsage;
0: import org.apache.activemq.usage.Usage;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.StoreUtil;
/////////////////////////////////////////////////////////////////////////
1:     private int diskUsageCheckRegrowThreshold = -1;
/////////////////////////////////////////////////////////////////////////
1:             checkUsageLimit(adapter.getDirectory(), usage.getStoreUsage(), usage.getStoreUsage().getPercentLimit());
/////////////////////////////////////////////////////////////////////////
1: 
1:             checkUsageLimit(tmpDir, usage.getTempUsage(), usage.getTempUsage().getPercentLimit());
/////////////////////////////////////////////////////////////////////////
1:                 long storeLimit = usage.getTempUsage().getLimit();
/////////////////////////////////////////////////////////////////////////
0:     protected void checkUsageLimit(File dir, Usage<?> storeUsage, int percentLimit) {
1:         if (dir != null) {
1:             dir = StoreUtil.findParentDirectory(dir);
1:             String storeName = storeUsage instanceof StoreUsage ? "Store" : "Temporary Store";
1:             long storeLimit = storeUsage.getLimit();
1:             long storeCurrent = storeUsage.getUsage();
0:             long usableSpace = dir.getUsableSpace();
0:             long totalSpace = dir.getTotalSpace();
0:             long totalUsableSpace = dir.getUsableSpace() + storeCurrent;
1:             //compute byte value of the percent limit
1:             long bytePercentLimit = totalSpace * percentLimit / 100;
1:             int oneMeg = 1024 * 1024;
1: 
1:             //Check if the store limit is less than the percent Limit that was set and also
1:             //the usable space...this means we can grow the store larger
1:             //Changes in partition size (total space) as well as changes in usable space should
1:             //be detected here
1:             if (diskUsageCheckRegrowThreshold > -1 && percentLimit > 0
1:                     && storeLimit < bytePercentLimit && storeLimit < totalUsableSpace){
1: 
1:                 // set the limit to be bytePercentLimit or usableSpace if
1:                 // usableSpace is less than the percentLimit
1:                 long newLimit = bytePercentLimit > totalUsableSpace ? totalUsableSpace : bytePercentLimit;
1: 
1:                 //To prevent changing too often, check threshold
1:                 if (newLimit - storeLimit >= diskUsageCheckRegrowThreshold) {
1:                     LOG.info("Usable disk space has been increased, attempting to regrow " + storeName + " limit to "
1:                             + percentLimit + "% of the partition size.");
1:                     storeUsage.setLimit(newLimit);
1:                     LOG.info(storeName + " limit has been increased to " + newLimit * 100 / totalSpace
1:                             + "% (" + newLimit / oneMeg + " mb) of the partition size.");
1:                 }
1: 
1:             //check if the limit is too large for the amount of usable space
1:             } else if (storeLimit > totalUsableSpace) {
1:                 if (percentLimit > 0) {
1:                     LOG.warn(storeName + " limit has been set to "
0:                             + percentLimit + "% (" + storeLimit / oneMeg + " mb)"
1:                             + " of the partition size but there is not enough usable space."
0:                             + " Only " + totalUsableSpace * 100 / totalSpace + "% (" + totalUsableSpace / oneMeg + " mb)"
0:                             + " is available");
1:                 }
1: 
0:                 LOG.warn(storeName + " limit is " +  storeLimit / oneMeg +
0:                          " mb (current store usage is " + storeCurrent / oneMeg +
0:                          " mb). The data directory: " + dir.getAbsolutePath() +
0:                          " only has " + usableSpace / oneMeg +
0:                          " mb of usable space - resetting to maximum available disk space: " +
0:                          totalUsableSpace / oneMeg + " mb");
1:                 storeUsage.setLimit(totalUsableSpace);
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @param schedulePeriodForDiskUsageCheck
1:      */
1:     public int getDiskUsageCheckRegrowThreshold() {
1:         return diskUsageCheckRegrowThreshold;
1:     }
1: 
1:     /**
1:      * @param diskUsageCheckRegrowThreshold
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryPropertyEditor"
1:      */
1:     public void setDiskUsageCheckRegrowThreshold(int diskUsageCheckRegrowThreshold) {
1:         this.diskUsageCheckRegrowThreshold = diskUsageCheckRegrowThreshold;
1:     }
1: 
commit:4f8d56a
/////////////////////////////////////////////////////////////////////////
0:             long storeCurrent = usage.getTempUsage().getUsage();
0:             if (storeLimit > (dirFreeSpace + storeCurrent)) {
0:                         " mb (current temporary store usage is " + storeCurrent / (1024 * 1024) +
0:                         " mb). The temporary data directory: " + tmpDir.getAbsolutePath() +
0:                         " only has " + dirFreeSpace / (1024 * 1024) +
0:                         " mb of usable space - resetting to maximum available disk space: " +
0:                        (dirFreeSpace + storeCurrent) / (1024 * 1024) + " mb");
0:                usage.getTempUsage().setLimit(dirFreeSpace + storeCurrent);
commit:12b26b6
/////////////////////////////////////////////////////////////////////////
1:         try(InputStream in = BrokerService.class.getResourceAsStream("/org/apache/activemq/version.txt")) {
1:             if (in != null) {
1:                 try(InputStreamReader isr = new InputStreamReader(in);
1:                     BufferedReader reader = new BufferedReader(isr)) {
1:                     version = reader.readLine();
1:                 }
1:         } catch (IOException ie) {
1:             LOG.warn("Error reading broker version ", ie);
commit:61fd811
/////////////////////////////////////////////////////////////////////////
1:     private int schedulePeriodForDiskUsageCheck = 0;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check that the store usage limit is not greater than max usable
1:      * space and adjust if it is
1:      */
0:     protected void checkStoreUsageLimits() throws IOException {
1:         final SystemUsage usage = getSystemUsage();
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Check that temporary usage limit is not greater than max usable
1:      * space and adjust if it is
1:      */
0:     protected void checkTmpStoreUsageLimits() throws IOException {
1:         final SystemUsage usage = getSystemUsage();
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Schedules a periodic task based on schedulePeriodForDiskLimitCheck to
1:      * update store and temporary store limits if the amount of available space
1:      * plus current store size is less than the existin configured limit
1:      */
1:     protected void scheduleDiskUsageLimitsCheck() throws IOException {
1:         if (schedulePeriodForDiskUsageCheck > 0 &&
1:                 (getPersistenceAdapter() != null || getTmpDataDirectory() != null)) {
1:             Runnable diskLimitCheckTask = new Runnable() {
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         checkStoreUsageLimits();
1:                     } catch (IOException e) {
1:                         LOG.error("Failed to check persistent disk usage limits", e);
1:                     }
1: 
1:                     try {
1:                         checkTmpStoreUsageLimits();
1:                     } catch (IOException e) {
1:                         LOG.error("Failed to check temporary store usage limits", e);
1:                     }
1:                 }
1:             };
1:             scheduler.executePeriodically(diskLimitCheckTask, schedulePeriodForDiskUsageCheck);
1:         }
1:     }
1: 
0:     protected void checkSystemUsageLimits() throws IOException {
1:         final SystemUsage usage = getSystemUsage();
1:         long memLimit = usage.getMemoryUsage().getLimit();
1:         long jvmLimit = Runtime.getRuntime().maxMemory();
1: 
1:         if (memLimit > jvmLimit) {
0:             usage.getMemoryUsage().setPercentOfJvmHeap(70);
0:             LOG.warn("Memory Usage for the Broker (" + memLimit / (1024 * 1024) +
0:                     " mb) is more than the maximum available for the JVM: " +
0:                     jvmLimit / (1024 * 1024) + " mb - resetting to 70% of maximum available: " + (usage.getMemoryUsage().getLimit() / (1024 * 1024)) + " mb");
1:         }
1: 
1:         //Check the persistent store and temp store limits if they exist
1:         //and schedule a periodic check to update disk limits if
1:         //schedulePeriodForDiskLimitCheck is set
1:         checkStoreUsageLimits();
1:         checkTmpStoreUsageLimits();
1:         scheduleDiskUsageLimitsCheck();
/////////////////////////////////////////////////////////////////////////
1:     public void setSchedulePeriodForDiskUsageCheck(
1:             int schedulePeriodForDiskUsageCheck) {
1:         this.schedulePeriodForDiskUsageCheck = schedulePeriodForDiskUsageCheck;
1:     }
1: 
author:Zoran Regvart
-------------------------------------------------------------------------------
commit:155461a
/////////////////////////////////////////////////////////////////////////
0:     private List<Runnable> preShutdownHooks = new CopyOnWriteArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Adds a {@link Runnable} hook that will be invoked before the
1:      * broker is stopped. This allows performing cleanup actions
1:      * before the broker is stopped. The hook should not throw
1:      * exceptions or block.
1:      */
1:     public final void addPreShutdownHook(final Runnable hook) {
1:         preShutdownHooks.add(hook);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         final ServiceStopper stopper = new ServiceStopper();
1: 
0:         for (Runnable hook : preShutdownHooks) {
1:             try {
1:                 hook.run();
1:             } catch (Throwable e) {
1:                 stopper.onException(hook, e);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public final void removePreShutdownHook(final Runnable hook) {
1:         preShutdownHooks.remove(hook);
1:     }
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:56917c0
/////////////////////////////////////////////////////////////////////////
1:     private final List<TransportConnector> transportConnectors = new CopyOnWriteArrayList<>();
1:     private final List<NetworkConnector> networkConnectors = new CopyOnWriteArrayList<>();
1:     private final List<ProxyConnector> proxyConnectors = new CopyOnWriteArrayList<>();
1:     private final List<JmsConnector> jmsConnectors = new CopyOnWriteArrayList<>();
1:     private final List<Service> services = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:     private final List<Runnable> shutdownHooks = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Failed to start Apache ActiveMQ ({}, {})", getBrokerName(), brokerId, e);
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> answer = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         return new ArrayList<>(transportConnectors);
/////////////////////////////////////////////////////////////////////////
1:         return new ArrayList<>(networkConnectors);
1:         return new ArrayList<>(proxyConnectors);
/////////////////////////////////////////////////////////////////////////
1:         List<DestinationInterceptor> answer = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         List<TransportConnector> al = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:         Map<String, String> map = new HashMap<>(URISupport.parseParameters(uri));
/////////////////////////////////////////////////////////////////////////
1:             Set <ActiveMQQueue> consumerDestinations = new HashSet<>();
commit:5009b0c
/////////////////////////////////////////////////////////////////////////
1:             Security.insertProviderAt(bouncycastle,
1:                 Integer.getInteger("org.apache.activemq.broker.BouncyCastlePosition", 2));
commit:5e05df1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:13044de
/////////////////////////////////////////////////////////////////////////
1:     private int storeOpenWireVersion = OpenWireFormat.DEFAULT_STORE_VERSION;
commit:35b82e5
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean persistenceAdapterStarted = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:                         synchronized (persistenceAdapterStarted) {
1:                             persistenceAdapterStarted.set(true);
1:                             persistenceAdapterStarted.notifyAll();
/////////////////////////////////////////////////////////////////////////
1:                         synchronized (persistenceAdapterStarted) {
1:                             if (!persistenceAdapterStarted.get()) {
1:                                 persistenceAdapterStarted.wait();
1:                             }
commit:433912f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.scheduler.memory.InMemoryJobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
1:                 this.jobSchedulerStore = new InMemoryJobSchedulerStore();
1:                 configureService(jobSchedulerStore);
1:                 try {
0:                     jobSchedulerStore.start();
1:                 } catch (Exception e) {
1:                     throw new RuntimeException(e);
1:                 }
1:                 return this.jobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
1:         return this.schedulerSupport;
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1:                 if (pa != null) {
1:                     this.jobSchedulerStore = pa.createJobSchedulerStore();
1:                     jobSchedulerStore.setDirectory(getSchedulerDirectoryFile());
1:                     configureService(jobSchedulerStore);
0:                     jobSchedulerStore.start();
1:                     return this.jobSchedulerStore;
1:                 }
1:             } catch (IOException e) {
1:                 throw new RuntimeException(e);
1:             } catch (UnsupportedOperationException ex) {
1:                 // It's ok if the store doesn't implement a scheduler.
1:             } catch (Exception e) {
1:                 throw new RuntimeException(e);
1:             }
1: 
1:             try {
1:                 PersistenceAdapter pa = getPersistenceAdapter();
/////////////////////////////////////////////////////////////////////////
1:             // Load the KahaDB store as a last resort, this only works if KahaDB is
1:             // included at runtime, otherwise this will fail.  User should disable
1:             // scheduler support if this fails.
1:                 String clazz = "org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter";
1:                 PersistenceAdapter adaptor = (PersistenceAdapter)getClass().getClassLoader().loadClass(clazz).newInstance();
1:                 jobSchedulerStore = adaptor.createJobSchedulerStore();
commit:5016c4d
/////////////////////////////////////////////////////////////////////////
0:         return waitUntilStarted(Long.MAX_VALUE);
1:     }
1: 
1:     /**
1:      * A helper method to block the caller thread until the broker has fully started
1:      *
1:      * @param timeout
1:      *        the amount of time to wait before giving up and returning false.
1:      *
1:      * @return boolean true if wait succeeded false if broker was not started or was stopped
1:      */
1:     public boolean waitUntilStarted(long timeout) {
1:         long expiration = Math.max(0, timeout + System.currentTimeMillis());
1:         while (!isStarted() && !stopped.get() && !waitSucceeded && expiration > System.currentTimeMillis()) {
commit:25f1fe8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.Log4JConfigView;
/////////////////////////////////////////////////////////////////////////
1:         if (isUseJmx() && Log4JConfigView.isLog4JAvailable()) {
1:             ObjectName objectName = BrokerMBeanSupport.createLog4JConfigViewName(getBrokerObjectName().toString());
1:             Log4JConfigView log4jConfigView = new Log4JConfigView();
1:             AnnotatedMBean.registerMBean(getManagementContext(), log4jConfigView, objectName);
1:         }
1: 
commit:fde22a8
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.AnnotatedMBean;
1: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1: import org.apache.activemq.broker.jmx.BrokerView;
1: import org.apache.activemq.broker.jmx.ConnectorView;
1: import org.apache.activemq.broker.jmx.ConnectorViewMBean;
1: import org.apache.activemq.broker.jmx.HealthView;
1: import org.apache.activemq.broker.jmx.HealthViewMBean;
1: import org.apache.activemq.broker.jmx.JmsConnectorView;
1: import org.apache.activemq.broker.jmx.JobSchedulerView;
1: import org.apache.activemq.broker.jmx.JobSchedulerViewMBean;
1: import org.apache.activemq.broker.jmx.ManagedRegionBroker;
1: import org.apache.activemq.broker.jmx.ManagementContext;
1: import org.apache.activemq.broker.jmx.NetworkConnectorView;
1: import org.apache.activemq.broker.jmx.NetworkConnectorViewMBean;
1: import org.apache.activemq.broker.jmx.ProxyConnectorView;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.BrokerSupport;
1: import org.apache.activemq.util.DefaultIOExceptionHandler;
1: import org.apache.activemq.util.IOExceptionHandler;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.IOHelper;
1: import org.apache.activemq.util.InetAddressUtil;
1: import org.apache.activemq.util.ServiceStopper;
1: import org.apache.activemq.util.ThreadPoolUtils;
1: import org.apache.activemq.util.TimeUtils;
0: import org.apache.activemq.util.URISupport;
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicLong totalConnections = new AtomicLong();
1:     private final AtomicInteger currentConnections = new AtomicInteger();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the current number of connections on this Broker.
1:      */
1:     public int getCurrentConnections() {
1:         return this.currentConnections.get();
1:     }
1: 
1:     /**
1:      * @return the total number of connections this broker has handled since startup.
1:      */
1:     public long getTotalConnections() {
1:         return this.totalConnections.get();
1:     }
1: 
1:     public void incrementCurrentConnections() {
1:         this.currentConnections.incrementAndGet();
1:     }
1: 
1:     public void decrementCurrentConnections() {
1:         this.currentConnections.decrementAndGet();
1:     }
1: 
1:     public void incrementTotalConnections() {
1:         this.totalConnections.incrementAndGet();
1:     }
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to start Apache ActiveMQ ({}, {})", new Object[]{ getBrokerName(), brokerId }, e);
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("Using Persistence Adapter: {}", getPersistenceAdapter());
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Apache ActiveMQ {} ({}, {}) is starting", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId });
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Apache ActiveMQ {} ({}, {}) started", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId});
1:         LOG.info("For help or more information please see: http://activemq.apache.org");
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Apache ActiveMQ {} ({}, {}) is shutting down", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId} );
/////////////////////////////////////////////////////////////////////////
1:         if (startDate != null) {
1:             LOG.info("Apache ActiveMQ {} ({}, {}) uptime {}", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId, getUptime()});
1:         LOG.info("Apache ActiveMQ {} ({}, {}) is shutdown", new Object[]{ getBrokerVersion(), getBrokerName(), brokerId});
/////////////////////////////////////////////////////////////////////////
1:                         LOG.info("Queue has pending message: {} queueSize is: {}", entry.getValue().getName(), queueSize);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Stop gracefully with connectorName: {} queueName: {} timeout: {} pollInterval: {}", new Object[]{
1:                     connectorName, queueName, timeout, pollInterval
1:             });
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Broker Name: {} contained illegal characters - replaced with {}", brokerName, str);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("persistent=\"false\", ignoring configured persistenceAdapter: {}", persistenceAdapter);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Badly formed URI from {}", getBrokerName(), e);
/////////////////////////////////////////////////////////////////////////
1:                       LOG.warn("Failed to get the ConnectURI for {}", tc, e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("{} temporary storage", str);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("JobScheduler using directory: {}", getSchedulerDirectoryFile());
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Network Connector could not be unregistered from JMX", e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Couldn't create ManagedRegionBroker", me);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("No port specified so defaulting to: {}", port);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Caught exception, must be shutting down", e);
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.info("Async start of {}", connector);
0:                                 LOG.error("Async start of network connector: {} failed", connector, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("No IOExceptionHandler registered, ignoring IO exception", exception);
commit:8320e66
/////////////////////////////////////////////////////////////////////////
0:         return this.schedulerSupport && (isPersistent() || jobSchedulerStore != null);
author:William Crowell
-------------------------------------------------------------------------------
commit:41bec0d
/////////////////////////////////////////////////////////////////////////
0:             if (totalSpace < 0) {
0:                 totalSpace = Long.MAX_VALUE;
0:                 LOG.info("Total space was negative.  Setting to " + totalSpace);
1:             }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:2852a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:dffccb1
/////////////////////////////////////////////////////////////////////////
1:             this.taskRunnerFactory.setThreadClassLoader(this.getClass().getClassLoader());
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:8e0865d
/////////////////////////////////////////////////////////////////////////
1:         long delta = getUptimeMillis();
1: 
1:         if (delta == 0) {
1: 
1:     public long getUptimeMillis() {
1:         if (startDate == null) {
1:             return 0;
1:         }
1: 
1:         return new Date().getTime() - startDate.getTime();
1:     }
1: 
commit:6521549
/////////////////////////////////////////////////////////////////////////
1:     public static final long DEFAULT_START_TIMEOUT = 600000L;
/////////////////////////////////////////////////////////////////////////
1:     private long waitForSlaveTimeout = DEFAULT_START_TIMEOUT;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return waitUntilStarted(DEFAULT_START_TIMEOUT);
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:ed8e4ea
/////////////////////////////////////////////////////////////////////////
1:     public boolean isStopped() {
1:         return stopped.get();
1:     }
1: 
author:Christian Posta
-------------------------------------------------------------------------------
commit:c2eb486
/////////////////////////////////////////////////////////////////////////
1:     public void registerNetworkConnectorMBean(NetworkConnector connector) throws IOException {
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:598f206
/////////////////////////////////////////////////////////////////////////
0:                     " mb) is more than the maximum available for the JVM: " +
0:                     jvmLimit / (1024 * 1024) + " mb - resetting to 70% of maximum available: " + (usage.getMemoryUsage().getLimit() / (1024 * 1024)) + " mb");
/////////////////////////////////////////////////////////////////////////
0:                         " mb, whilst the temporary data directory: " + tmpDirPath +
0:                         " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space - resetting to maximum available " +
/////////////////////////////////////////////////////////////////////////
1:                 long schedulerLimit = usage.getJobSchedulerUsage().getLimit();
1:                 if (schedulerLimit > dirFreeSpace) {
1:                     LOG.warn("Job Scheduler Store limit is " + schedulerLimit / (1024 * 1024) +
commit:ea1d02d
/////////////////////////////////////////////////////////////////////////
0:                 while (dir != null && !dir.isDirectory()) {
/////////////////////////////////////////////////////////////////////////
0:                              " mb of usable space - resetting to maximum available disk space: " +
/////////////////////////////////////////////////////////////////////////
0:             while (tmpDir != null && !tmpDir.isDirectory()) {
/////////////////////////////////////////////////////////////////////////
1:                 while (schedulerDir != null && !schedulerDir.isDirectory()) {
/////////////////////////////////////////////////////////////////////////
1:         return BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "duplexNetworkConnectors", transport);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Network Connector could not be unregistered from JMX due " + e.getMessage() + ". This exception is ignored.", e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Cannot create ManagedRegionBroker due " + me.getMessage(), me);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Caught exception, must be shutting down. This exception is ignored.", e);
/////////////////////////////////////////////////////////////////////////
1:                LOG.error("Failed to start Scheduler", e);
commit:c659506
/////////////////////////////////////////////////////////////////////////
1:             this.taskRunnerFactory = new TaskRunnerFactory("ActiveMQ BrokerService["+getBrokerName()+"] Task", getTaskRunnerPriority(), true, 1000,
/////////////////////////////////////////////////////////////////////////
1:                     Thread thread = new Thread(runnable, "ActiveMQ BrokerService.worker." + this.i);
commit:c9cc85b
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to start Apache ActiveMQ (" + getBrokerName() + ", " + brokerId + "). Reason: " + e, e);
1:                 LOG.warn("Failed to stop broker after failure in start. This exception will be ignored.", ex);
/////////////////////////////////////////////////////////////////////////
1: 
1:         broker = getBroker();
1:         brokerId = broker.getBrokerId();
1: 
1:         // need to log this after creating the broker so we have its id and name
0:         if (LOG.isInfoEnabled()) {
0:             LOG.info("Apache ActiveMQ " + getBrokerVersion() + " ("
0:                     + getBrokerName() + ", " + brokerId + ") is starting");
1:         }
1:         broker.start();
1: 
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Apache ActiveMQ " + getBrokerVersion() + " ("
0:             LOG.info("For help or more information please see: http://activemq.apache.org");
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Apache ActiveMQ " + getBrokerVersion() + " ("
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Apache ActiveMQ " + getBrokerVersion() + " ("
0:                         + getBrokerName() + ", " + brokerId + ") uptime " + getUptime());
0:             LOG.info("Apache ActiveMQ " + getBrokerVersion() + " ("
/////////////////////////////////////////////////////////////////////////
commit:4260034
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean stopping = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:         stopping.set(false);
/////////////////////////////////////////////////////////////////////////
1:         if (!stopping.compareAndSet(false, true)) {
1:             LOG.trace("Broker already stopping/stopped");
/////////////////////////////////////////////////////////////////////////
0:                     + getBrokerName() + ", " + brokerId + ") is shutdown");
commit:5453b26
/////////////////////////////////////////////////////////////////////////
1:             if (destinationInterceptors != null) {
1:                 for (DestinationInterceptor interceptor : destinationInterceptors) {
1:                     if (interceptor instanceof VirtualDestinationInterceptor) {
1:                         VirtualDestinationInterceptor virtualDestinationInterceptor = (VirtualDestinationInterceptor) interceptor;
1:                         for (VirtualDestination virtualDestination: virtualDestinationInterceptor.getVirtualDestinations()) {
1:                             if (virtualDestination instanceof VirtualTopic) {
1:                                 consumerDestinations.add(new ActiveMQQueue(((VirtualTopic) virtualDestination).getPrefix() + DestinationFilter.ANY_DESCENDENT));
1:                             }
commit:f2225c2
/////////////////////////////////////////////////////////////////////////
1: import java.util.Date;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.TimeUtils;
/////////////////////////////////////////////////////////////////////////
1:     private Date startDate;
/////////////////////////////////////////////////////////////////////////
1:     public String getUptime() {
0:         // compute and log uptime
0:         if (startDate == null) {
1:             return "not started";
1:         }
0:         long delta = new Date().getTime() - startDate.getTime();
1:         return TimeUtils.printDuration(delta);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         startDate = new Date();
/////////////////////////////////////////////////////////////////////////
0:             if (startDate != null) {
0:                 LOG.info("Uptime {}", getUptime());
1:             }
/////////////////////////////////////////////////////////////////////////
1:         // and clear start date
1:         startDate = null;
1: 
commit:5b4fe6e
/////////////////////////////////////////////////////////////////////////
1:             if (isPersistent()) {
1:                 long maxJournalFileSize;
0:                 if (usage.getTempUsage().getStore() != null) {
0:                     maxJournalFileSize = usage.getTempUsage().getStore().getJournalMaxFileLength();
1:                 } else {
0:                     maxJournalFileSize = org.apache.kahadb.journal.Journal.DEFAULT_MAX_FILE_LENGTH;
1:                 }
0:                 if (storeLimit < maxJournalFileSize) {
1:                     LOG.error("Temporary Store limit is " + storeLimit / (1024 * 1024) +
1:                               " mb, whilst the max journal file size for the temporary store is: " +
1:                               maxJournalFileSize / (1024 * 1024) + " mb, " +
1:                               "the temp store will not accept any data when used.");
1:                 }
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:             ThreadPoolUtils.shutdownNow(executor);
/////////////////////////////////////////////////////////////////////////
1:                     ThreadPoolUtils.shutdown(networkConnectorStartExecutor);
/////////////////////////////////////////////////////////////////////////
1:      * @param value if MBeans should expose user name information.
commit:ca728c0
/////////////////////////////////////////////////////////////////////////
0:                 systemUsage.getMemoryUsage().setLimit(1024 * 1024 * 64); // 64 MB
1:                 systemUsage.getTempUsage().setLimit(1024L * 1024 * 1024 * 50); // 50 GB
1:                 systemUsage.getStoreUsage().setLimit(1024L * 1024 * 1024 * 100); // 100 GB
commit:4b44d31
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:                         answer.put(scheme.toLowerCase(Locale.ENGLISH), uri.toString());
commit:eea9fca
/////////////////////////////////////////////////////////////////////////
1:             // throw new IllegalStateException("Already started.");
/////////////////////////////////////////////////////////////////////////
1:                 // need to remove MDC during starting JMX, as that would otherwise causes leaks, as spawned threads inheirt the MDC and
1:                 // we cannot cleanup clear that during shutdown of the broker.
1:                 MDC.remove("activemq.broker");
1:                 try {
1:                     startManagementContext();
1:                 } finally {
1:                     MDC.put("activemq.broker", brokerName);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         // to avoid timing issue with discovery (spinning up a new instance)
/////////////////////////////////////////////////////////////////////////
1:         getManagementContext().setBrokerName(brokerName);
author:Gary Tully
-------------------------------------------------------------------------------
commit:8d480b4
/////////////////////////////////////////////////////////////////////////
1:     private volatile DestinationInterceptor[] destinationInterceptors;
commit:3630a41
/////////////////////////////////////////////////////////////////////////
0:     private String configurationUrl;
/////////////////////////////////////////////////////////////////////////
1:             throw new RuntimeException("Fatally failed to create SystemUsage" + e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public String getConfigurationUrl() {
0:         return configurationUrl;
1:     }
1: 
0:     public void setConfigurationUrl(String configurationUrl) {
0:         this.configurationUrl = configurationUrl;
1:     }
commit:0ba311f
/////////////////////////////////////////////////////////////////////////
1:                              " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space - resetting to " +
commit:27c424c
/////////////////////////////////////////////////////////////////////////
1:         startAllConnectors();
1: 
commit:7d7d6fa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
/////////////////////////////////////////////////////////////////////////
1:         return BrokerMBeanSupport.createConnectorName(getBrokerObjectName(), "clientConnectors", connector.getName());
/////////////////////////////////////////////////////////////////////////
1:         return BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "networkConnectors", connector.getName());
0:         return BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "duplexNetworkConnectors", transport.toString());
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "proxyConnectors", connector.getName());
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createNetworkConnectorName(getBrokerObjectName(), "jmsConnectors", connector.getName());
/////////////////////////////////////////////////////////////////////////
1:                     ObjectName objectName = BrokerMBeanSupport.createJobSchedulerServiceName(getBrokerObjectName());
/////////////////////////////////////////////////////////////////////////
1:                 ObjectName objectName = BrokerMBeanSupport.createHealthServiceName(getBrokerObjectName());
/////////////////////////////////////////////////////////////////////////
1:         return BrokerMBeanSupport.createBrokerObjectName(getManagementContext().getJmxDomainName(), getBrokerName());
commit:69d8258
/////////////////////////////////////////////////////////////////////////
1:         getBroker().nowMasterBroker();
commit:0051c4e
/////////////////////////////////////////////////////////////////////////
1:             // in jvm master slave, lets not publish over existing broker till we get the lock
1:             final BrokerRegistry brokerRegistry = BrokerRegistry.getInstance();
1:             if (brokerRegistry.lookup(getBrokerName()) == null) {
1:                 brokerRegistry.bind(getBrokerName(), BrokerService.this);
1:             }
1:             brokerRegistry.bind(getBrokerName(), BrokerService.this);
commit:ae816dc
/////////////////////////////////////////////////////////////////////////
1:         if (!isPersistent() && ! (persistenceAdapter instanceof MemoryPersistenceAdapter)) {
0:             LOG.warn("persistent=\"false\", ignoring configured persistenceAdapter: " + persistenceAdapter);
1:             return;
1:         }
commit:b6f63b0
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.filter.DestinationFilter;
/////////////////////////////////////////////////////////////////////////
1:     private DestinationFilter virtualConsumerDestinationFilter;
/////////////////////////////////////////////////////////////////////////
1:         if (isUseVirtualTopics()) {
1:             startVirtualConsumerDestinations();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     protected void startVirtualConsumerDestinations() throws Exception {
1:         ConnectionContext adminConnectionContext = getAdminConnectionContext();
1:         Set<ActiveMQDestination> destinations = destinationFactory.getDestinations();
1:         DestinationFilter filter = getVirtualTopicConsumerDestinationFilter();
1:         if (!destinations.isEmpty()) {
1:             for (ActiveMQDestination destination : destinations) {
1:                 if (filter.matches(destination) == true) {
1:                     broker.addDestination(adminConnectionContext, destination, false);
1:                 }
1:     private DestinationFilter getVirtualTopicConsumerDestinationFilter() {
1:         // created at startup, so no sync needed
1:         if (virtualConsumerDestinationFilter == null) {
0:             Set <ActiveMQQueue> consumerDestinations = new HashSet<ActiveMQQueue>();
0:             for (DestinationInterceptor interceptor : destinationInterceptors) {
0:                 if (interceptor instanceof VirtualDestinationInterceptor) {
0:                     VirtualDestinationInterceptor virtualDestinationInterceptor = (VirtualDestinationInterceptor) interceptor;
0:                     for (VirtualDestination virtualDestination: virtualDestinationInterceptor.getVirtualDestinations()) {
0:                         if (virtualDestination instanceof VirtualTopic) {
0:                             consumerDestinations.add(new ActiveMQQueue(((VirtualTopic) virtualDestination).getPrefix() + DestinationFilter.ANY_DESCENDENT));
1:                         }
1:                     }
1:                 }
1:             }
1:             ActiveMQQueue filter = new ActiveMQQueue();
1:             filter.setCompositeDestinations(consumerDestinations.toArray(new ActiveMQDestination[]{}));
1:             virtualConsumerDestinationFilter = DestinationFilter.parseFilter(filter);
1:         }
1:         return virtualConsumerDestinationFilter;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean shouldRecordVirtualDestination(ActiveMQDestination destination) {
1:         return isUseVirtualTopics() && destination.isQueue() &&
1:                 getVirtualTopicConsumerDestinationFilter().matches(destination);
1:     }
commit:dcf1f5e
/////////////////////////////////////////////////////////////////////////
1:         if (this.scheduler != null) {
1:             this.scheduler.stop();
1:             this.scheduler = null;
1:         }
/////////////////////////////////////////////////////////////////////////
commit:41cdadb
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("No IOExceptionHandler registered, ignoring IO exception, " + exception, exception);
commit:6813691
/////////////////////////////////////////////////////////////////////////
1:     private int schedulePeriodForDestinationPurge= 0;
commit:174c405
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to start ActiveMQ JMS Message Broker (" + getBrokerName() + ", " + brokerId + "). Reason: " + e, e);
commit:2030097
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             stopper.stop(persistenceAdapter);
1:             persistenceAdapter = null;
0:             slave = true;
1:             if (isUseJmx()) {
0:                 stopper.stop(getManagementContext());
1:                 managementContext = null;
1:             }
1:             // Clear SelectorParser cache to free memory
1:             SelectorParser.clearCache();
1:         } finally {
1:             stopped.set(true);
1:             stoppedLatch.countDown();
commit:0619a87
/////////////////////////////////////////////////////////////////////////
1:                 configureService(tempDataStore);
/////////////////////////////////////////////////////////////////////////
1:         configureService(tempDataStore);
commit:ddca4cf
/////////////////////////////////////////////////////////////////////////
1:                 if (uri != null) {
1:                     String scheme = uri.getScheme();
1:                     if (scheme != null) {
0:                         answer.put(scheme.toLowerCase(), uri.toString());
1:                     }
commit:c395917
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             tempDataStore.start();
1:         } catch (Exception e) {
0:             RuntimeException exception = new RuntimeException("Failed to start provided temp data store: " + tempDataStore, e);
0:             LOG.error(exception.getLocalizedMessage(), e);
0:             throw exception;
1:         }
commit:8a2892b
/////////////////////////////////////////////////////////////////////////
commit:254d920
/////////////////////////////////////////////////////////////////////////
1:     private boolean allowTempAutoCreationOnSend;
/////////////////////////////////////////////////////////////////////////
1:         regionBroker.setAllowTempAutoCreationOnSend(isAllowTempAutoCreationOnSend());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isAllowTempAutoCreationOnSend() {
1:         return allowTempAutoCreationOnSend;
1:     }
1: 
1:     /**
1:      * enable if temp destinations need to be propagated through a network when
1:      * advisorySupport==false. This is used in conjunction with the policy
1:      * gcInactiveDestinations for matching temps so they can get removed
1:      * when inactive
1:      *
1:      * @param allowTempAutoCreationOnSend
1:      */
1:     public void setAllowTempAutoCreationOnSend(boolean allowTempAutoCreationOnSend) {
1:         this.allowTempAutoCreationOnSend = allowTempAutoCreationOnSend;
1:     }
commit:b9045db
/////////////////////////////////////////////////////////////////////////
commit:4150650
/////////////////////////////////////////////////////////////////////////
1:     public void stopAllConnectors(ServiceStopper stopper) {
/////////////////////////////////////////////////////////////////////////
1:     public void startAllConnectors() throws Exception {
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * override the Default IOException handler, called when persistence adapter
1:      * has experiences File or JDBC I/O Exceptions
1:      *
1:      * @param ioExceptionHandler
1:      */
1:         configureService(ioExceptionHandler);
1:     public IOExceptionHandler getIoExceptionHandler() {
1:         return ioExceptionHandler;
1:     }
1: 
commit:c42d8de
/////////////////////////////////////////////////////////////////////////
1:     public synchronized Scheduler getScheduler() {
commit:286c9d0
/////////////////////////////////////////////////////////////////////////
1:     private boolean useAuthenticatedPrincipalForJMSXUserID;
/////////////////////////////////////////////////////////////////////////
1:             userIDBroker.setUseAuthenticatePrincipal(isUseAuthenticatedPrincipalForJMSXUserID());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUseAuthenticatedPrincipalForJMSXUserID() {
1:         return useAuthenticatedPrincipalForJMSXUserID;
1:     public void setUseAuthenticatedPrincipalForJMSXUserID(boolean useAuthenticatedPrincipalForJMSXUserID) {
1:         this.useAuthenticatedPrincipalForJMSXUserID = useAuthenticatedPrincipalForJMSXUserID;
commit:f38908e
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.SynchronousQueue;
/////////////////////////////////////////////////////////////////////////
1:     private boolean networkConnectorStartAsync = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 ThreadPoolExecutor networkConnectorStartExecutor = null;
1:                 if (isNetworkConnectorStartAsync()) {
1:                     // spin up as many threads as needed
1:                     networkConnectorStartExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE,
1:                             10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
1:                             new ThreadFactory() {
1:                                 int count=0;
1:                                 public Thread newThread(Runnable runnable) {
1:                                     Thread thread = new Thread(runnable, "NetworkConnector Start Thread-" +(count++));
1:                                     thread.setDaemon(true);
1:                                     return thread;
1:                                 }
1:                             });
1:                 }
1: 
1:                     final NetworkConnector connector = iter.next();
1:                     if (networkConnectorStartExecutor != null) {
0:                         networkConnectorStartExecutor.execute(new Runnable() {
1:                             public void run() {
1:                                 try {
0:                                     LOG.info("Async start of " + connector);
1:                                     connector.start();
0:                                 } catch(Exception e) {
0:                                     LOG.error("Async start of network connector: " + connector + " failed", e);
1:                                 }
1:                             }
1:                         });
1:                     } else {
1:                         connector.start();
1:                     }
1:                 if (networkConnectorStartExecutor != null) {
1:                     // executor done when enqueued tasks are complete
0:                     networkConnectorStartExecutor.shutdown();
0:                     networkConnectorStartExecutor = null;
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isNetworkConnectorStartAsync() {
1:         return networkConnectorStartAsync;
1:     }
1: 
1:     public void setNetworkConnectorStartAsync(boolean networkConnectorStartAsync) {
1:         this.networkConnectorStartAsync = networkConnectorStartAsync;
1:     }
commit:6f68a94
/////////////////////////////////////////////////////////////////////////
0:     private boolean useAuthenticatedPrincipalForJMXUserID;
1: 
/////////////////////////////////////////////////////////////////////////
1:             UserIDBroker userIDBroker = new UserIDBroker(broker);
0:             userIDBroker.setUseAuthenticatePrincipal(isUseAuthenticatedPrincipalForJMXUserID());
1:             broker = userIDBroker;
/////////////////////////////////////////////////////////////////////////
1: 
0:     public boolean isUseAuthenticatedPrincipalForJMXUserID() {
0:         return useAuthenticatedPrincipalForJMXUserID;
1:     }
1: 
0:     public void setUseAuthenticatedPrincipalForJMXUserID(boolean useAuthenticatedPrincipalForJMXUserID) {
0:         this.useAuthenticatedPrincipalForJMXUserID = useAuthenticatedPrincipalForJMXUserID;
1:     }
commit:0ed0ba5
/////////////////////////////////////////////////////////////////////////
1:     private String defaultSocketURIString;
/////////////////////////////////////////////////////////////////////////
1:     public String getDefaultSocketURIString() {
0:                 if (this.defaultSocketURIString ==null) {
1:                         String result = null;
1:                             result = tc.getPublishableConnectString();
0:                             this.defaultSocketURIString =result;
1:                 return this.defaultSocketURIString;
/////////////////////////////////////////////////////////////////////////
0:                     if (getDefaultSocketURIString() != null) {
0:                         connector.setBrokerURL(getDefaultSocketURIString());
commit:92b3ae2
/////////////////////////////////////////////////////////////////////////
1:     private boolean schedulerSupport = false;
commit:adb76e5
/////////////////////////////////////////////////////////////////////////
1:             this.schedulerDirectoryFile = new File(getBrokerDataDirectory(), "scheduler");
commit:3559363
/////////////////////////////////////////////////////////////////////////
1:             broker = null;
1:         
1:             tempDataStore = null;
0:         persistenceAdapter = null;
0:             managementContext = null;
/////////////////////////////////////////////////////////////////////////
1:             this.taskRunnerFactory = null;
0:             this.scheduler = null;
1:             this.executor = null;
1:         
1:         this.destinationInterceptors = null;
1:         this.destinationFactory = null;
1:         
commit:956c3e0
/////////////////////////////////////////////////////////////////////////
1:      * A helper method to block the caller thread until the broker has fully started
1:      * @return boolean true if wait succeeded false if broker was not started or was stopped
1:     public boolean waitUntilStarted() {
/////////////////////////////////////////////////////////////////////////
1:         return waitSucceeded;
commit:d3fb1aa
/////////////////////////////////////////////////////////////////////////
1:     public boolean checkQueueSize(String queueName) {
commit:6efc268
/////////////////////////////////////////////////////////////////////////
0:         if (!started.get()) {
commit:e80bf00
/////////////////////////////////////////////////////////////////////////
0:     private long waitForSlaveTimeout = 600000L;
/////////////////////////////////////////////////////////////////////////
0:             if (!slaveStartSignal.await(waitForSlaveTimeout, TimeUnit.MILLISECONDS)) {
0:             	throw new IllegalStateException("Gave up waiting for slave to start after " + waitForSlaveTimeout + " milliseconds."); 
1:             }
/////////////////////////////////////////////////////////////////////////
1:   
1:     public long getWaitForSlaveTimeout() {
1:         return this.waitForSlaveTimeout;
1:     }
1:     
1:     public void setWaitForSlaveTimeout(long waitForSlaveTimeout) {
1:         this.waitForSlaveTimeout = waitForSlaveTimeout;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: }
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1:                     true, 1000, isDedicatedTaskRunner());
commit:72b9416
/////////////////////////////////////////////////////////////////////////
1:         stopped.set(false);
1:         started.set(false);
commit:a72f26f
/////////////////////////////////////////////////////////////////////////
0:         return (Service[]) services.toArray(new Service[0]);
commit:0782204
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Failed to startAllConnectors", e);
commit:31c7e62
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:     private CountDownLatch startedLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1:             startedLatch.countDown();
/////////////////////////////////////////////////////////////////////////
1:         while (isStarted() && !stopped.get()) {
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * A helper method to block the caller thread until the broker has been
0:      * started
1:      */
0:     public void waitUntilStarted() {
0:         boolean waitSucceeded = false;
0:         while (isStarted() && !stopped.get() && !waitSucceeded) {
1:             try {
1:                 waitSucceeded = startedLatch.await(100L, TimeUnit.MILLISECONDS);
1:             } catch (InterruptedException ignore) {
1:             }
1:         }
1:     }
1: 
commit:543bc84
/////////////////////////////////////////////////////////////////////////
commit:43880af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             BrokerRegistry.getInstance().bind(getBrokerName(), this);
1:             
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:01704ee
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If support is off don't allow any scheduler even is user configured their own.
1:         if (!isSchedulerSupport()) {
1:             return null;
1:         }
1: 
1:         // If the user configured their own we use it even if persistence is disabled since
1:         // we don't know anything about their implementation.
1:         if (jobSchedulerStore == null) {
1: 
1:             if (!isPersistent()) {
1:                 return null;
1:             }
1: 
1:             try {
1:                 PersistenceAdapter pa = getPersistenceAdapter();
1:                 if (pa != null && pa instanceof JobSchedulerStore) {
1:                     this.jobSchedulerStore = (JobSchedulerStore) pa;
1:                     configureService(jobSchedulerStore);
1:                     return this.jobSchedulerStore;
1:                 }
1:             } catch (IOException e) {
1:                 throw new RuntimeException(e);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
commit:174fe15
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:  * Manages the life-cycle of an ActiveMQ Broker. A BrokerService consists of a
/////////////////////////////////////////////////////////////////////////
1: 
1:     @SuppressWarnings("unused")
1: 
/////////////////////////////////////////////////////////////////////////
1:      * JSR-250 callback wrapper; converts checked exceptions to runtime exceptions
1:      *
1:      * delegates to autoStart, done to prevent backwards incompatible signature change
1:      */
1:     @PostConstruct
1:     private void postConstruct() {
1:         try {
1:             autoStart();
1:         } catch (Exception ex) {
1:             throw new RuntimeException(ex);
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * JSR-250 callback wrapper; converts checked exceptions to runtime exceptions
1:      *
1:      * delegates to stop, done to prevent backwards incompatible signature change
1:      */
1:     @PreDestroy
1:     private void preDestroy () {
1:         try {
1:             stop();
1:         } catch (Exception ex) {
1:             throw new RuntimeException();
1:         }
1:     }
1: 
1:     /**
commit:539a5f1
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 unregisterConnectorMBean(connector);
1:             } catch (IOException e) {
1:             }
commit:ff9b800
/////////////////////////////////////////////////////////////////////////
1: import java.security.Provider;
1: import java.security.Security;
/////////////////////////////////////////////////////////////////////////
1: 
1:         try {
1:             ClassLoader loader = BrokerService.class.getClassLoader();
1:             Class<?> clazz = loader.loadClass("org.bouncycastle.jce.provider.BouncyCastleProvider");
1:             Provider bouncycastle = (Provider) clazz.newInstance();
0:             Security.insertProviderAt(bouncycastle, 2);
1:             LOG.info("Loaded the Bouncy Castle security provider.");
1:         } catch(Throwable e) {
1:             // No BouncyCastle found so we use the default Java Security Provider
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:3a8eb74
/////////////////////////////////////////////////////////////////////////
1:     public boolean isStopping() {
1:         return this.stopping.get();
1:     }
commit:d75e418
/////////////////////////////////////////////////////////////////////////
1:     private boolean slave = true;
/////////////////////////////////////////////////////////////////////////
1:         this.slave = true;
/////////////////////////////////////////////////////////////////////////
1:         this.slave = false;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isSlave() {
1:         return this.slave;
1:     }
1: 
commit:63a660a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.BrokerMBeanSuppurt;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return BrokerMBeanSuppurt.createConnectorName(getBrokerObjectName(), "clientConnectors", connector.getName());
/////////////////////////////////////////////////////////////////////////
0:         return BrokerMBeanSuppurt.createNetworkConnectorName(getBrokerObjectName(), "networkConnectors", connector.getName());
0:         return BrokerMBeanSuppurt.createNetworkConnectorName(getBrokerObjectName(), "duplexNetworkConnectors", transport.toString());
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = BrokerMBeanSuppurt.createNetworkConnectorName(getBrokerObjectName(), "proxyConnectors", connector.getName());
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = BrokerMBeanSuppurt.createNetworkConnectorName(getBrokerObjectName(), "jmsConnectors", connector.getName());
/////////////////////////////////////////////////////////////////////////
0:                     ObjectName objectName = BrokerMBeanSuppurt.createJobSchedulerServiceName(getBrokerObjectName());
/////////////////////////////////////////////////////////////////////////
0:                 ObjectName objectName = BrokerMBeanSuppurt.createHealthServiceName(getBrokerObjectName());
/////////////////////////////////////////////////////////////////////////
0:         return BrokerMBeanSuppurt.createBrokerObjectName(getManagementContext().getJmxDomainName(), getBrokerName());
commit:3cd8da8
/////////////////////////////////////////////////////////////////////////
1:     private long offlineDurableSubscriberTimeout = -1;
1:     private long offlineDurableSubscriberTaskSchedule = 300000;
/////////////////////////////////////////////////////////////////////////
1:     public void stopGracefully(String connectorName, String queueName, long timeout, long pollInterval) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         for (TransportConnector connector : transportConnectors) {
1:         for (TransportConnector transportConnector : transportConnectors){
/////////////////////////////////////////////////////////////////////////
1:         for (TransportConnector transportConnector : transportConnectors){
/////////////////////////////////////////////////////////////////////////
1:     public void setNetworkConnectors(List<?> networkConnectors) throws Exception {
1:         for (Object connector : networkConnectors) {
1:             addNetworkConnector((NetworkConnector) connector);
/////////////////////////////////////////////////////////////////////////
1:     public void setProxyConnectors(List<?> proxyConnectors) throws Exception {
1:         for (Object connector : proxyConnectors) {
1:             addProxyConnector((ProxyConnector) connector);
/////////////////////////////////////////////////////////////////////////
0:         if (started.get()) {
1:             if (this.defaultSocketURIString == null) {
1:                 for (TransportConnector tc:this.transportConnectors) {
0:                     String result = null;
1:                     try {
0:                         result = tc.getPublishableConnectString();
1:                     } catch (Exception e) {
0:                       LOG.warn("Failed to get the ConnectURI for "+tc,e);
1:                     }
1:                     if (result != null) {
1:                         // find first publishable uri
1:                         if (tc.isUpdateClusterClients() || tc.isRebalanceClusterClients()) {
1:                             this.defaultSocketURIString = result;
1:                             break;
1:                         } else {
1:                         // or use the first defined
1:                             if (this.defaultSocketURIString == null) {
1: 
0:             return this.defaultSocketURIString;
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (isUseJmx()) {}
/////////////////////////////////////////////////////////////////////////
0:     protected ObjectName createNetworkConnectorObjectName(NetworkConnector connector) throws MalformedObjectNameException {
1:     public ObjectName createDuplexNetworkConnectorObjectName(String transport) throws MalformedObjectNameException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 regionBroker = new ManagedRegionBroker(this, getManagementContext(), getBrokerObjectName(),
1:             } catch(MalformedObjectNameException me){
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected Object getPort(Map<?,?> options) {
/////////////////////////////////////////////////////////////////////////
0:                     10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
0:                     new ThreadFactory() {
0:                         int count=0;
1:                         @Override
1:                         public Thread newThread(Runnable runnable) {
0:                             Thread thread = new Thread(runnable, "NetworkConnector Start Thread-" +(count++));
1:                             thread.setDaemon(true);
1:                             return thread;
1:                         }
1:                     });
/////////////////////////////////////////////////////////////////////////
1:     public long getOfflineDurableSubscriberTimeout() {
1:     public void setOfflineDurableSubscriberTimeout(long offlineDurableSubscriberTimeout) {
1:     public long getOfflineDurableSubscriberTaskSchedule() {
1:     public void setOfflineDurableSubscriberTaskSchedule(long offlineDurableSubscriberTaskSchedule) {
0:                getVirtualTopicConsumerDestinationFilter().matches(destination);
commit:d21b32e
/////////////////////////////////////////////////////////////////////////
1:             started.set(false);
commit:f21992e
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedReader;
1: import java.io.File;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.net.UnknownHostException;
1: import java.util.ArrayList;
0: import java.util.Date;
1: import java.util.HashMap;
0: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.List;
0: import java.util.Locale;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.RejectedExecutionException;
1: import java.util.concurrent.RejectedExecutionHandler;
0: import java.util.concurrent.SynchronousQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import javax.annotation.PostConstruct;
1: import javax.annotation.PreDestroy;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
1: 
0: import org.apache.activemq.broker.jmx.AnnotatedMBean;
0: import org.apache.activemq.broker.jmx.BrokerView;
0: import org.apache.activemq.broker.jmx.ConnectorView;
0: import org.apache.activemq.broker.jmx.ConnectorViewMBean;
0: import org.apache.activemq.broker.jmx.JmsConnectorView;
0: import org.apache.activemq.broker.jmx.JobSchedulerView;
0: import org.apache.activemq.broker.jmx.JobSchedulerViewMBean;
0: import org.apache.activemq.broker.jmx.ManagedRegionBroker;
0: import org.apache.activemq.broker.jmx.ManagementContext;
0: import org.apache.activemq.broker.jmx.NetworkConnectorView;
0: import org.apache.activemq.broker.jmx.NetworkConnectorViewMBean;
0: import org.apache.activemq.broker.jmx.ProxyConnectorView;
0: import org.apache.activemq.broker.jmx.StatusView;
0: import org.apache.activemq.broker.jmx.StatusViewMBean;
1: import org.apache.activemq.broker.region.CompositeDestinationInterceptor;
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.DestinationFactory;
1: import org.apache.activemq.broker.region.DestinationFactoryImpl;
1: import org.apache.activemq.broker.region.DestinationInterceptor;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.scheduler.JobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.BrokerSupport;
0: import org.apache.activemq.util.DefaultIOExceptionHandler;
0: import org.apache.activemq.util.IOExceptionHandler;
0: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.activemq.util.IOHelper;
0: import org.apache.activemq.util.InetAddressUtil;
0: import org.apache.activemq.util.JMXSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.util.ThreadPoolUtils;
0: import org.apache.activemq.util.TimeUtils;
0: import org.apache.activemq.util.URISupport;
/////////////////////////////////////////////////////////////////////////
1:     // to other jms messaging systems
/////////////////////////////////////////////////////////////////////////
1:     private JobSchedulerStore jobSchedulerStore;
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (jobSchedulerStore != null) {
1:             jobSchedulerStore.stop();
1:             jobSchedulerStore = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:                 systemUsage = new SystemUsage("Main", getPersistenceAdapter(), getTempDataStore(), getJobSchedulerStore());
0:                 systemUsage.getJobSchedulerUsage().setLimit(1024L * 1024 * 1000 * 50); // 50 // Gb
/////////////////////////////////////////////////////////////////////////
1:     public synchronized JobSchedulerStore getJobSchedulerStore() {
0:         if (jobSchedulerStore == null && isSchedulerSupport()) {
1:             try {
0:                 String clazz = "org.apache.activemq.store.kahadb.scheduler.JobSchedulerStoreImpl";
0:                 jobSchedulerStore = (JobSchedulerStore) getClass().getClassLoader().loadClass(clazz).newInstance();
1:                 jobSchedulerStore.setDirectory(getSchedulerDirectoryFile());
1:                 configureService(jobSchedulerStore);
0:                 jobSchedulerStore.start();
0:                 LOG.info("JobScheduler using directory: " + getSchedulerDirectoryFile());
1:             } catch (Exception e) {
1:                 throw new RuntimeException(e);
1:             }
1: 
1:         }
1:         return jobSchedulerStore;
1:     }
1: 
1:     public void setJobSchedulerStore(JobSchedulerStore jobSchedulerStore) {
1:         this.jobSchedulerStore = jobSchedulerStore;
1:         configureService(jobSchedulerStore);
1:         try {
0:             jobSchedulerStore.start();
1:         } catch (Exception e) {
0:             RuntimeException exception = new RuntimeException(
0:                     "Failed to start provided job scheduler store: " + jobSchedulerStore, e);
0:             LOG.error(exception.getLocalizedMessage(), e);
0:             throw exception;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (getJobSchedulerStore() != null) {
1:             JobSchedulerStore scheduler = getJobSchedulerStore();
1:             File schedulerDir = scheduler.getDirectory();
1:             if (schedulerDir != null) {
1: 
1:                 String schedulerDirPath = schedulerDir.getAbsolutePath();
1:                 if (!schedulerDir.isAbsolute()) {
1:                     schedulerDir = new File(schedulerDirPath);
1:                 }
1: 
0:                 while (schedulerDir != null && schedulerDir.isDirectory() == false) {
1:                     schedulerDir = schedulerDir.getParentFile();
1:                 }
0:                 long schedularLimit = usage.getJobSchedulerUsage().getLimit();
1:                 long dirFreeSpace = schedulerDir.getUsableSpace();
0:                 if (schedularLimit > dirFreeSpace) {
0:                     LOG.warn("Job Schedular Store limit is " + schedularLimit / (1024 * 1024) +
1:                              " mb, whilst the data directory: " + schedulerDir.getAbsolutePath() +
0:                              " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space");
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:             SchedulerBroker sb = new SchedulerBroker(this, broker, getJobSchedulerStore());
/////////////////////////////////////////////////////////////////////////
1:                             @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
commit:2251ba0
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedReader;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.stomp.ProtocolConverter;
/////////////////////////////////////////////////////////////////////////
1:     public static final String BROKER_VERSION;
/////////////////////////////////////////////////////////////////////////
1: 
0:         InputStream in = null;
1:         String version = null;
0:         if ((in = ProtocolConverter.class.getResourceAsStream("/org/apache/activemq/version.txt")) != null) {
0:             BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1:             try {
0:                 version = reader.readLine();
0:             } catch(Exception e) {
1:             }
1:         }
1:         BROKER_VERSION = version;
/////////////////////////////////////////////////////////////////////////
1:     private String getBrokerVersion() {
1:         String version = ActiveMQConnectionMetaData.PROVIDER_VERSION;
1:         if (version == null) {
1:             version = BROKER_VERSION;
1:         }
1: 
1:         return version;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (LOG.isInfoEnabled()) {
0:             LOG.info("ActiveMQ " + getBrokerVersion() + " JMS Message Broker ("
0:                     + getBrokerName() + ", " + brokerId + ") started");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isInfoEnabled()) {
0:             LOG.info("ActiveMQ " + getBrokerVersion() + " JMS Message Broker ("
0:                     + getBrokerName() + ", " + brokerId + ") is shutting down");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isInfoEnabled()) {
0:             LOG.info("ActiveMQ " + getBrokerVersion() + " JMS Message Broker ("
0:                     + getBrokerName() + ", " + brokerId + ") stopped");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isInfoEnabled()) {
0:                 LOG.info("ActiveMQ " + getBrokerVersion() + " JMS Message Broker ("
0:                         + getBrokerName() + ") is starting");
0:                 LOG.info("For help or more information please see: http://activemq.apache.org/");
1:             }
commit:584c133
/////////////////////////////////////////////////////////////////////////
1:     private long mbeanInvocationTimeout = 0;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Gets the time in Milliseconds that an invocation of an MBean method will wait before
1:      * failing.  The default value is to wait forever (zero).
1:      *
1:      * @return timeout in milliseconds before MBean calls fail, (default is 0 or no timeout).
1:      */
1:     public long getMbeanInvocationTimeout() {
1:         return mbeanInvocationTimeout;
1:     }
1: 
1:     /**
1:      * Gets the time in Milliseconds that an invocation of an MBean method will wait before
1:      * failing. The default value is to wait forever (zero).
1:      *
1:      * @param mbeanInvocationTimeout
1:      *      timeout in milliseconds before MBean calls fail, (default is 0 or no timeout).
1:      */
1:     public void setMbeanInvocationTimeout(long mbeanInvocationTimeout) {
1:         this.mbeanInvocationTimeout = mbeanInvocationTimeout;
1:     }
1: 
commit:5cd9eba
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.RejectedExecutionException;
0: import java.util.concurrent.RejectedExecutionHandler;
/////////////////////////////////////////////////////////////////////////
1:             this.executor = new ThreadPoolExecutor(1, 10, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
1: 
1:                 private long i = 0;
1: 
1:                 @Override
0:                 public Thread newThread(Runnable runnable) {
1:                     this.i++;
0:                     Thread thread = new Thread(runnable, "BrokerService.worker." + this.i);
0:                     thread.setDaemon(true);
1:                     thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
1:                         @Override
1:                         public void uncaughtException(final Thread t, final Throwable e) {
1:                             LOG.error("Error in thread '{}'", t.getName(), e);
1:                         }
1:                     });
0:                     return thread;
1:                 }
1:             }, new RejectedExecutionHandler() {
1:                 @Override
1:                 public void rejectedExecution(final Runnable r, final ThreadPoolExecutor executor) {
1:                     try {
1:                         executor.getQueue().offer(r, 60, TimeUnit.SECONDS);
1:                     } catch (InterruptedException e) {
1:                         throw new RejectedExecutionException("Interrupted waiting for BrokerService.worker");
1:                     }
1: 
1:                     throw new RejectedExecutionException("Timed Out while attempting to enqueue Task.");
1:                 }
1:             });
commit:f5dcc9d
/////////////////////////////////////////////////////////////////////////
1:     private boolean populateUserNameInMBeans;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Should MBeans that support showing the Authenticated User Name information have this
1:      * value filled in or not.
1:      *
1:      * @return true if user names should be exposed in MBeans
1:      */
1:     public boolean isPopulateUserNameInMBeans() {
1:         return this.populateUserNameInMBeans;
1:     }
1: 
1:     /**
1:      * Sets whether Authenticated User Name information is shown in MBeans that support this field.
0:      * @param true if MBeans should expose user name information.
1:      */
1:     public void setPopulateUserNameInMBeans(boolean value) {
1:         this.populateUserNameInMBeans = value;
1:     }
1: 
commit:df19a38
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.amq.AMQPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.BrokerSupport;
0: import org.apache.activemq.util.DefaultIOExceptionHandler;
0: import org.apache.activemq.util.IOExceptionHandler;
0: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.activemq.util.IOHelper;
0: import org.apache.activemq.util.InetAddressUtil;
0: import org.apache.activemq.util.JMXSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.util.URISupport;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             PersistenceAdapter adapter = getPersistenceAdapter();
0:             File dir = adapter.getDirectory();
/////////////////////////////////////////////////////////////////////////
1: 
1:             long maxJournalFileSize = 0;
1:             long storeLimit = usage.getStoreUsage().getLimit();
1: 
0:             if (adapter instanceof KahaDBPersistenceAdapter) {
0:                 KahaDBPersistenceAdapter kahaDB = (KahaDBPersistenceAdapter) adapter;
0:                 maxJournalFileSize = kahaDB.getJournalMaxFileLength();
0:             } else if (adapter instanceof AMQPersistenceAdapter) {
0:                 AMQPersistenceAdapter amqAdapter = (AMQPersistenceAdapter) adapter;
0:                 maxJournalFileSize = amqAdapter.getMaxFileLength();
1:             }
1: 
0:             if (storeLimit < maxJournalFileSize) {
1:                 LOG.error("Store limit is " + storeLimit / (1024 * 1024) +
1:                           " mb, whilst the max journal file size for the store is: " +
1:                           maxJournalFileSize / (1024 * 1024) + " mb, " +
1:                           "the store will not accept any data when used.");
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                 maxJournalFileSize = usage.getTempUsage().getStore().getJournalMaxFileLength();
0:                 maxJournalFileSize = org.apache.kahadb.journal.Journal.DEFAULT_MAX_FILE_LENGTH;
1: 
commit:f6caba7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.journal.Journal;
/////////////////////////////////////////////////////////////////////////
0:             long maxJournalFileSize;
1:             
0:             if (usage.getTempUsage().getStore() != null) {
0:             	maxJournalFileSize = usage.getTempUsage().getStore().getJournalMaxFileLength();
1:             } else {
0:             	maxJournalFileSize = org.apache.kahadb.journal.Journal.DEFAULT_MAX_FILE_LENGTH;
1:             }
1:             
commit:d403f10
/////////////////////////////////////////////////////////////////////////
1: 
0:             long maxJournalFileSize = usage.getTempUsage().getStore().getJournalMaxFileLength();
0:             if (storeLimit < maxJournalFileSize) {
0:                 LOG.error("Temporary Store limit is " + storeLimit / (1024 * 1024) +
0:                           " mb, whilst the max journal file size for the temporary store is: " +
0:                           maxJournalFileSize / (1024 * 1024) + " mb, " +
0:                           "the temp store will not accept any data when used.");
1:             }
commit:7b90f41
/////////////////////////////////////////////////////////////////////////
1:      * Forces a start of the broker.
1:      * By default a BrokerService instance that was
1:      * using BrokerService.start().
1:      * This method enforces a restart.
1:      * for most but some very trivial broker configurations.
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (memLimit > jvmLimit) {
0:             LOG.error("Memory Usage for the Broker (" + memLimit / (1024 * 1024) +
0:                       " mb) is more than the maximum available for the JVM: " +
0:                       jvmLimit / (1024 * 1024) + " mb");
1:         if (getPersistenceAdapter() != null) {
0:             if (dir != null) {
0:                 if (storeLimit > dirFreeSpace) {
0:                     LOG.warn("Store limit is " + storeLimit / (1024 * 1024) +
0:                              " mb, whilst the data directory: " + dir.getAbsolutePath() +
0:                              " only has " + dirFreeSpace / (1024 * 1024) + " mb of free space");
1:         if (tmpDir != null) {
1: 
0:             if (!tmpDir.isAbsolute()) {
0:                 tmpDir = new File(tmpDirPath);
1:             }
1: 
0:             while (tmpDir != null && tmpDir.isDirectory() == false) {
0:             if (storeLimit > dirFreeSpace) {
0:                 LOG.error("Temporary Store limit is " + storeLimit / (1024 * 1024) +
0:                           " mb, whilst the temporary data directory: " + tmpDirPath +
0:                           " only has " + dirFreeSpace / (1024 * 1024) + " mb of free space");
commit:f0d9f83
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
1:     private int maxPurgedDestinationsPerSweep = 0;
1:     static {
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:             if (systemExitOnShutdown && useShutdownHook) {
1:                 throw new ConfigurationException("'useShutdownHook' property cannot be be used with 'systemExitOnShutdown', please turn it off (useShutdownHook=false)");
1:             }
1:                 startManagementContext();
/////////////////////////////////////////////////////////////////////////
1:                 if (getManagementContext().isCreateConnector() && !getManagementContext().isConnectorStarted()) {
1:                     // try to restart management context
1:                     // typical for slaves that use the same ports as master
1:                     managementContext.stop();
0:                     startManagementContext();
1:                 }
1:                 adminView.setBroker(managedBroker);
/////////////////////////////////////////////////////////////////////////
1:                 setIoExceptionHandler(new DefaultIOExceptionHandler());
/////////////////////////////////////////////////////////////////////////
1:             new Thread() {
1:                 @Override
1:                     System.exit(systemExitOnShutdownExitCode);
1:                 }
1:             }.start();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @org.apache.xbean.Property
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @org.apache.xbean.Property
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                 throw new IllegalStateException("Gave up waiting for slave to start after " + waitForSlaveTimeout + " milliseconds.");
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int getMaxPurgedDestinationsPerSweep() {
1:         return this.maxPurgedDestinationsPerSweep;
1:     }
1: 
1:     public void setMaxPurgedDestinationsPerSweep(int maxPurgedDestinationsPerSweep) {
1:         this.maxPurgedDestinationsPerSweep = maxPurgedDestinationsPerSweep;
1:     }
1: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:cf9ccca
/////////////////////////////////////////////////////////////////////////
0:                       jvmLimit / (1024 * 1024) + " mb - resetting to maximum available: " + jvmLimit / (1024 * 1024) + " mb");
0:             usage.getMemoryUsage().setLimit(jvmLimit);
/////////////////////////////////////////////////////////////////////////
0:                              " only has " + dirFreeSpace / (1024 * 1024) +
0:                              " mb of usable space - resetting to maximum available disk space:  " +
0:                             dirFreeSpace / (1024 * 1024) + " mb");
0:                     usage.getStoreUsage().setLimit(dirFreeSpace);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                           " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space - resetting to maximum available " +
1:                         dirFreeSpace / (1024 * 1024) + " mb.");
0:                 usage.getTempUsage().setLimit(dirFreeSpace);
/////////////////////////////////////////////////////////////////////////
0:                              " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space - reseting to " +
0:                             dirFreeSpace / (1024 * 1024) + " mb.");
1:                     usage.getJobSchedulerUsage().setLimit(dirFreeSpace);
commit:0736953
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerInfo;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.*;
/////////////////////////////////////////////////////////////////////////
1:     public ProducerBrokerExchange getProducerBrokerExchange(ProducerInfo producerInfo){
1:         ProducerBrokerExchange result = null;
1: 
1:         for (TransportConnector connector : transportConnectors) {
1:             for (TransportConnection tc: connector.getConnections()){
1:                 result = tc.getProducerBrokerExchangeIfExists(producerInfo);
1:                 if (result !=null){
1:                     return result;
1:                 }
1:             }
1:         }
1:         return result;
1:     }
1: 
commit:c37859a
/////////////////////////////////////////////////////////////////////////
1:     public ObjectName getBrokerObjectName() throws MalformedObjectNameException {
/////////////////////////////////////////////////////////////////////////
0:         String objectNameStr = getBrokerObjectName().toString();
0:         objectNameStr += ",connector=clientConnectors,connectorName="+ JMXSupport.encodeObjectNamePart(connector.getName());
0:         return new ObjectName(objectNameStr);
/////////////////////////////////////////////////////////////////////////
0:         String objectNameStr = getBrokerObjectName().toString();
0:         objectNameStr += ",connector=networkConnectors,networkConnectorName="+ JMXSupport.encodeObjectNamePart(connector.getName());
0:         return new ObjectName(objectNameStr);
0:         String objectNameStr = getBrokerObjectName().toString();
0:         objectNameStr += ",connector=duplexNetworkConnectors,networkConnectorName="+ JMXSupport.encodeObjectNamePart(transport);
0:         return new ObjectName(objectNameStr);
/////////////////////////////////////////////////////////////////////////
0:             String objectNameStr = getBrokerObjectName().toString();
0:             objectNameStr += ",connector=proxyConnectors,proxyConnectorName="+ JMXSupport.encodeObjectNamePart(connector.getName());
0:             ObjectName objectName = new ObjectName(objectNameStr);
/////////////////////////////////////////////////////////////////////////
0:             String objectNameStr = getBrokerObjectName().toString();
0:             objectNameStr += ",connector=jmsConnectors,JmsConnectors="+ JMXSupport.encodeObjectNamePart(connector.getName());
0:             ObjectName objectName = new ObjectName(objectNameStr);
/////////////////////////////////////////////////////////////////////////
1:             try {
0:             }catch(MalformedObjectNameException me){
0:                 LOG.error("Couldn't create ManagedRegionBroker",me);
1:                 throw new IOException(me);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     String objectNameStr = getBrokerObjectName().toString();
0:                     objectNameStr += ",service=JobScheduler,name=JMS";
0:                     ObjectName objectName = new ObjectName(objectNameStr);
/////////////////////////////////////////////////////////////////////////
0:                 String objectNameStr = getBrokerObjectName().toString();
0:                 objectNameStr += ",service=Health";
0:                 ObjectName objectName = new ObjectName(objectNameStr);
/////////////////////////////////////////////////////////////////////////
1:     protected ObjectName createBrokerObjectName() throws MalformedObjectNameException  {
0:         String objectNameStr = getManagementContext().getJmxDomainName() + ":type=Broker,brokerName=";
0:         objectNameStr += JMXSupport.encodeObjectNamePart(getBrokerName());
0:         return new ObjectName(objectNameStr);
commit:39ff4d9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return slave;
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (!isSlave()) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:74bed6b
/////////////////////////////////////////////////////////////////////////
1:     public TransportConnector getTransportConnectorByName(String name){
0:         for (TransportConnector transportConnector:transportConnectors){
1:            if (name.equals(transportConnector.getName())){
1:                return transportConnector;
1:            }
1:         }
1:         return null;
1:     }
1: 
1:     public TransportConnector getTransportConnectorByScheme(String scheme){
0:         for (TransportConnector transportConnector:transportConnectors){
1:             if (scheme.equals(transportConnector.getUri().getScheme())){
1:                 return transportConnector;
1:             }
1:         }
1:         return null;
1:     }
1: 
commit:3df43f5
/////////////////////////////////////////////////////////////////////////
1: 
0:                 String dirPath = dir.getAbsolutePath();
commit:61fdb18
/////////////////////////////////////////////////////////////////////////
0:             String dirPath = dir.getAbsolutePath();
0:                 if (!dir.isAbsolute()) {
0:                     dir = new File(dirPath);
1:                 }
1: 
0:                 while (dir != null && dir.isDirectory() == false) {
0:                     dir = dir.getParentFile();
1:                 }
0:                 long dirFreeSpace = dir.getUsableSpace();
0:                              " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space");
/////////////////////////////////////////////////////////////////////////
0:                           " only has " + dirFreeSpace / (1024 * 1024) + " mb of usable space");
commit:dbc661f
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             checkSystemUsageLimits();
/////////////////////////////////////////////////////////////////////////
0:                 systemUsage.getTempUsage().setLimit(1024L * 1024 * 1000 * 50); // 50
0:                 systemUsage.getStoreUsage().setLimit(1024L * 1024 * 1000 * 100); // 100
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected void checkSystemUsageLimits() throws IOException {
0:         SystemUsage usage = getSystemUsage();
0:         long memLimit = usage.getMemoryUsage().getLimit();
0:         long jvmLimit = Runtime.getRuntime().maxMemory();
0:         if (memLimit > jvmLimit){
0:             LOG.error("Memory Usage for the Broker (" + memLimit/(1024*1024) + " mb) is more than the maximum available for the JVM: " + jvmLimit/(1024*1024) + " mb" );
1:         }
0:         if (getPersistenceAdapter() != null){
0:             File dir = getPersistenceAdapter().getDirectory();
0:             if (dir != null){
0:                 long storeLimit = usage.getStoreUsage().getLimit();
0:                 long dirFreeSpace = dir.getFreeSpace();
0:                 if (storeLimit > dirFreeSpace){
0:                     LOG.warn("Store limit is " + storeLimit/(1024*1024) + " mb, whilst the data directory: " + dir.getAbsolutePath() + " only has " + dirFreeSpace/(1024*1024) + " mb of free space");
1:                 }
1:             }
1:         }
1:         File tmpDir = getTmpDataDirectory();
0:         if (tmpDir != null){
0:             String tmpDirPath = tmpDir.getAbsolutePath();
0:             long storeLimit = usage.getTempUsage().getLimit();
0:             while (tmpDir != null && tmpDir.isDirectory()== false){
0:                 tmpDir = tmpDir.getParentFile();
1:             }
0:             long dirFreeSpace = tmpDir.getUsableSpace();
0:             if (storeLimit > dirFreeSpace){
0:                 LOG.error("Temporary Store limit is " + storeLimit/(1024*1024) + " mb, whilst the temporary data directory: " + tmpDirPath + " only has " + dirFreeSpace/(1024*1024) + " mb of free space");
1:             }
1:         }
1:     }
commit:ea0ceac
/////////////////////////////////////////////////////////////////////////
1:                     count += queueSize;
commit:2705e36
/////////////////////////////////////////////////////////////////////////
0:     private int schedulePeriodForDestinationPurge=5000;
1:     
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     public int getSchedulePeriodForDestinationPurge() {
1:         return this.schedulePeriodForDestinationPurge;
1:     }
1: 
1:     public void setSchedulePeriodForDestinationPurge(int schedulePeriodForDestinationPurge) {
1:         this.schedulePeriodForDestinationPurge = schedulePeriodForDestinationPurge;
commit:452ceae
/////////////////////////////////////////////////////////////////////////
0:             this.taskRunnerFactory = new TaskRunnerFactory("BrokerService["+getBrokerName()+"] Task", getTaskRunnerPriority(), true, 1000,
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
1:     private Scheduler scheduler;
1:     private ThreadPoolExecutor executor;
1:     
/////////////////////////////////////////////////////////////////////////
1:         if (this.taskRunnerFactory != null) {
1:             this.taskRunnerFactory.shutdown();
1:         }
0:         if (this.scheduler != null) {
0:             this.scheduler.stop();
1:         }
1:         if (this.executor != null) {
0:             this.executor.shutdownNow();
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 systemUsage.setExecutor(getExecutor());
/////////////////////////////////////////////////////////////////////////
1:         if (this.systemUsage.getExecutor()==null) {
1:             this.systemUsage.setExecutor(getExecutor());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (this.taskRunnerFactory == null) {
0:             this.taskRunnerFactory = new TaskRunnerFactory("BrokerService", getTaskRunnerPriority(), true, 1000,
1:         return this.taskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:                     getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory, destinationInterceptor,getScheduler(),getExecutor());
1:                     destinationInterceptor,getScheduler(),getExecutor());
/////////////////////////////////////////////////////////////////////////
1:             PersistenceAdapterFactory fac = getPersistenceFactory();
1:             if (fac != null) {
1:                 return fac.createPersistenceAdapter();
0:             }else {
0:                 KahaDBPersistenceAdapter adaptor = new KahaDBPersistenceAdapter();
1:                 File dir = new File(getBrokerDataDirectory(),"KahaDB");
1:                 adaptor.setDirectory(dir);
1:                 return adaptor;
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected synchronized ThreadPoolExecutor getExecutor() {
1:         if (this.executor == null) {
0:         this.executor = new ThreadPoolExecutor(1, 10, 30, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
0:             public Thread newThread(Runnable runnable) {
0:                 Thread thread = new Thread(runnable, "Usage Async Task");
0:                 thread.setDaemon(true);
0:                 return thread;
1:             }
0:         });
1:         }
1:         return this.executor;
1:     }
1:     
0:     protected synchronized Scheduler getScheduler() {
1:         if (this.scheduler==null) {
1:             this.scheduler = new Scheduler("ActiveMQ Broker["+getBrokerName()+"] Scheduler");
1:             try {
1:                 this.scheduler.start();
1:             } catch (Exception e) {
0:                LOG.error("Failed to start Scheduler ",e);
1:             }
1:         }
1:         return this.scheduler;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     }   
commit:475eedc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         broker = new TransactionBroker(broker, getPersistenceAdapter().createTransactionStore());
commit:f392884
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private URI defaultSocketURI;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public URI getDefaultSocketURI() {
1:        
0:             if (started.get()) {
0:                 if (this.defaultSocketURI==null) {
0:                     for (TransportConnector tc:this.transportConnectors) {
0:                         URI result = null;
1:                         try {
0:                             result = tc.getConnectUri();
1:                         } catch (Exception e) {
0:                           LOG.warn("Failed to get the ConnectURI for "+tc,e);
1:                         }
0:                         if (result != null) {
0:                             this.defaultSocketURI=result;
1:                             break;
1:                         }
1:                     }
1:                 }
0:                 return this.defaultSocketURI;
1:             }
1:        return null;
1:     }
/////////////////////////////////////////////////////////////////////////
0:                     if (getDefaultSocketURI() != null) {
0:                         connector.setBrokerURL(getDefaultSocketURI().toString());
1:                     }
commit:c7c8e53
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.JobSchedulerView;
0: import org.apache.activemq.broker.jmx.JobSchedulerViewMBean;
/////////////////////////////////////////////////////////////////////////
0:             SchedulerBroker sb = new SchedulerBroker(broker, getSchedulerDirectoryFile());
1:             if (isUseJmx()) {
1:                 JobSchedulerViewMBean view = new JobSchedulerView(sb.getJobScheduler());
1:                 try {
0:                     ObjectName objectName = new ObjectName(getManagementContext().getJmxDomainName() + ":"
0:                             + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + ","
0:                             + "Type=jobScheduler," + "jobSchedulerName=JMS");
1: 
1:                     AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
1:                     this.adminView.setJMSJobScheduler(objectName);
1:                 } catch (Throwable e) {
1:                     throw IOExceptionSupport.create("JobScheduler could not be registered in JMX: "
1:                             + e.getMessage(), e);
1:                 }
1: 
1:             }
1:             broker = sb;
commit:204f91f
/////////////////////////////////////////////////////////////////////////
1:         return getBroker().addDestination(getAdminConnectionContext(), destination,false);
/////////////////////////////////////////////////////////////////////////
1:                 getBroker().addDestination(adminConnectionContext, destination,true);
/////////////////////////////////////////////////////////////////////////
0:                 broker.addDestination(adminConnectionContext, destination,false);
commit:ee55abb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.plist.PListStore;
/////////////////////////////////////////////////////////////////////////
1:     private PListStore tempDataStore;
/////////////////////////////////////////////////////////////////////////
1:             tempDataStore.stop();
/////////////////////////////////////////////////////////////////////////
1:     public synchronized PListStore getTempDataStore() {
/////////////////////////////////////////////////////////////////////////
0:                 this.tempDataStore = new PListStore();
1:                 this.tempDataStore.setDirectory(getTmpDataDirectory());
0:                 this.tempDataStore.start();
1:             } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1:     public void setTempDataStore(PListStore tempDataStore) {
commit:7ae2055
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.scheduler.SchedulerBroker;
/////////////////////////////////////////////////////////////////////////
0:     private final List<TransportConnector> transportConnectors = new CopyOnWriteArrayList<TransportConnector>();
0:     private final List<NetworkConnector> networkConnectors = new CopyOnWriteArrayList<NetworkConnector>();
0:     private final List<ProxyConnector> proxyConnectors = new CopyOnWriteArrayList<ProxyConnector>();
0:     private final List<JmsConnector> jmsConnectors = new CopyOnWriteArrayList<JmsConnector>();
0:     private final List<Service> services = new ArrayList<Service>();
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean started = new AtomicBoolean(false);
1:     private final AtomicBoolean stopped = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:     private final CountDownLatch stoppedLatch = new CountDownLatch(1);
1:     private final CountDownLatch startedLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
0:     private final List<Runnable> shutdownHooks = new ArrayList<Runnable>();
0:     private boolean schedulerSupport = true;
1:     private File schedulerDirectoryFile;
/////////////////////////////////////////////////////////////////////////
1:         		@Override
1:                 public void run() {
/////////////////////////////////////////////////////////////////////////
1:         return services.toArray(new Service[0]);
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:                     @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         if (isSchedulerSupport()) {
0:             broker = new SchedulerBroker(broker,getSchedulerDirectoryFile());
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the schedulerSupport
1:      */
1:     public boolean isSchedulerSupport() {
0:         return this.schedulerSupport;
1:     }
1: 
1:     /**
1:      * @param schedulerSupport the schedulerSupport to set
1:      */
1:     public void setSchedulerSupport(boolean schedulerSupport) {
1:         this.schedulerSupport = schedulerSupport;
1:     }
1: 
1:     /**
1:      * @return the schedulerDirectory
1:      */
1:     public File getSchedulerDirectoryFile() {
1:         if (this.schedulerDirectoryFile == null) {
0:             this.schedulerDirectoryFile = new File(IOHelper.getDefaultDataDirectory(),"scheduler");
1:         }
1:         return schedulerDirectoryFile;
1:     }
1: 
1:     /**
1:      * @param schedulerDirectory the schedulerDirectory to set
1:      */
1:     public void setSchedulerDirectoryFile(File schedulerDirectory) {
1:         this.schedulerDirectoryFile = schedulerDirectory;
1:     }
1:     
1:     public void setSchedulerDirectory(String schedulerDirectory) {
1:         setSchedulerDirectoryFile(new File(schedulerDirectory));
1:     }
commit:7da608c
/////////////////////////////////////////////////////////////////////////
0:             if (!isSlave() && (this.masterConnector == null || isShutdownOnMasterFailure() == false)) {
commit:4228281
/////////////////////////////////////////////////////////////////////////
1:     private boolean passiveSlave;
/////////////////////////////////////////////////////////////////////////
1:                         "Transport Connector could not be unregistered in JMX: " + e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the passiveSlave
1:      * @return the passiveSlave
1:      */
1:     public boolean isPassiveSlave() {
1:         return this.passiveSlave;
1:     }
1: 
1:     /**
1:      * Set the passiveSlave
1:      * @param passiveSlave the passiveSlave to set
1:      */
1:     public void setPassiveSlave(boolean passiveSlave) {
1:         this.passiveSlave = passiveSlave;
1:     }
commit:98497b1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return (masterConnector != null && masterConnector.isSlave()) ||
0:             (masterConnector != null && masterConnector.isStoppedBeforeStart());
/////////////////////////////////////////////////////////////////////////
1:         if (stopped.get() || !started.compareAndSet(false, true)) {
/////////////////////////////////////////////////////////////////////////
1:             if (!stopped.get()) {
0:                 if (isUseJmx() && masterConnector != null) {
0:                     registerFTConnectorMBean(masterConnector);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (!stopped.get()) {
1:                     stop();
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         if (masterConnectorURI == null) {
0:             // master start has not finished yet
0:             if (slaveStartSignal.getCount() == 1) {
0:                 started.set(false);
0:                 slaveStartSignal.countDown();
1:             }
1:         } else {
1:             for (Service service : services) {
0:                 if (service instanceof MasterConnector) {
0:                     MasterConnector mConnector = (MasterConnector) service;
0:                     if (!mConnector.isSlave()) {
0:                         // means should be slave but not connected to master yet
0:                         started.set(false);
0:                         mConnector.stopBeforeConnected();
1:                     }
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
0:         public boolean checkQueueSize(String queueName) {
1:         long count = 0;
1:         long queueSize = 0;
1:         Map<ActiveMQDestination, Destination> destinationMap = regionBroker.getDestinationMap();
1:         for (Map.Entry<ActiveMQDestination, Destination> entry : destinationMap.entrySet()) {
1:             if (entry.getKey().isQueue()) {
1:                 if (entry.getValue().getName().matches(queueName)) {
1:                     queueSize = entry.getValue().getDestinationStatistics().getMessages().getCount();
0:                     count = queueSize;
1:                     if (queueSize > 0) {
0:                         LOG.info("Queue has pending message:" + entry.getValue().getName() + " queueSize is:"
0:                                 + queueSize);
1:                     }
1:                 }
1:             }
1:         }
1:         return count == 0;
1:     }
1: 
1:     /**
1:      * This method (both connectorName and queueName are using regex to match)
1:      * 1. stop the connector (supposed the user input the connector which the
1:      * clients connect to) 2. to check whether there is any pending message on
1:      * the queues defined by queueName 3. supposedly, after stop the connector,
1:      * client should failover to other broker and pending messages should be
1:      * forwarded. if no pending messages, the method finally call stop to stop
1:      * the broker.
1:      * 
1:      * @param connectorName
1:      * @param queueName
1:      * @param timeout
1:      * @param pollInterval
1:      * @throws Exception
1:      */
0:     public void stopGracefully(String connectorName, String queueName, long timeout, long pollInterval)
0:             throws Exception {
1:         if (isUseJmx()) {
1:             if (connectorName == null || queueName == null || timeout <= 0) {
1:                 throw new Exception(
1:                         "connectorName and queueName cannot be null and timeout should be >0 for stopGracefully.");
1:             }
1:             if (pollInterval <= 0) {
1:                 pollInterval = 30;
1:             }
0:             LOG.info("Stop gracefully with connectorName:" + connectorName + " queueName:" + queueName + " timeout:"
0:                     + timeout + " pollInterval:" + pollInterval);
1:             TransportConnector connector;
1:             for (int i = 0; i < transportConnectors.size(); i++) {
1:                 connector = transportConnectors.get(i);
1:                 if (connector != null && connector.getName() != null && connector.getName().matches(connectorName)) {
1:                     connector.stop();
1:                 }
1:             }
1:             long start = System.currentTimeMillis();
1:             while (System.currentTimeMillis() - start < timeout * 1000) {
1:                 // check quesize until it gets zero
1:                 if (checkQueueSize(queueName)) {
1:                     stop();
0:                     break;
1:                 } else {
1:                     Thread.sleep(pollInterval * 1000);
1:                 }
1:             }
1:             if (stopped.get()) {
1:                 LOG.info("Successfully stop the broker.");
1:             } else {
1:                 LOG.info("There is still pending message on the queue. Please check and stop the broker manually.");
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:             if (!stopped.get()) {
1:                 for (Iterator<NetworkConnector> iter = getNetworkConnectors().iterator(); iter.hasNext();) {
1:                     NetworkConnector connector = iter.next();
1:                     connector.setLocalUri(uri);
0:                     connector.setBrokerName(getBrokerName());
0:                     connector.setDurableDestinations(durableDestinations);
1:                     connector.start();
1:                 }
1:                 for (Iterator<ProxyConnector> iter = getProxyConnectors().iterator(); iter.hasNext();) {
1:                     ProxyConnector connector = iter.next();
1:                     connector.start();
1:                 }
1:                 for (Iterator<JmsConnector> iter = jmsConnectors.iterator(); iter.hasNext();) {
1:                     JmsConnector connector = iter.next();
1:                     connector.start();
1:                 }
1:                 for (Service service : services) {
1:                     configureService(service);
1:                     service.start();
1:                 }
commit:a33f73e
/////////////////////////////////////////////////////////////////////////
commit:c1051c8
/////////////////////////////////////////////////////////////////////////
1:     
1:     public Map<String, String> getTransportConnectorURIsAsMap() {
0:         Map<String, String> answer = new HashMap<String, String>();
1:         for (TransportConnector connector : transportConnectors) {
1:             try {
1:                 URI uri = connector.getConnectUri();
0:                 String scheme = uri.getScheme();
0:                 if (scheme != null) {
0:                     answer.put(scheme.toLowerCase(), uri.toString());
0:                     System.err.println(scheme + " = " + uri);
1:                 }
1:             } catch (Exception e) {
1:                 LOG.debug("Failed to read URI to build transportURIsAsMap", e);
1:             }
1:         }
1:         return answer;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:    
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected CountDownLatch slaveStartSignal = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean useTempMirroredQueues = true;
/////////////////////////////////////////////////////////////////////////
1:     private boolean monitorConnectionSplits = false;
1:     private boolean cacheTempDestinations = false;// useful for failover
0:     private List<Runnable> shutdownHooks = new ArrayList<Runnable>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             throw new javax.jms.IllegalStateException(
0:                     "Networks require advisory messages to function - advisories are currently disabled");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * @param masterConnectorURI
0:      *            The masterConnectorURI to set.
/////////////////////////////////////////////////////////////////////////
1:         forceStart = force;
1:         start();
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (systemExitOnShutdown) {
0:                 addShutdownHook(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:                 getManagementContext().start();
1:                 ManagedRegionBroker managedBroker = (ManagedRegionBroker) regionBroker;
1:                 ObjectName objectName = getBrokerObjectName();
0:                 getManagementContext().registerMBean(adminView, objectName);
0:             // see if there is a MasterBroker service and if so, configure
1:             }
1:             try {
1:             } catch (Exception ex) {
0:                 LOG.warn("Failed to stop broker after failure in start ", ex);
/////////////////////////////////////////////////////////////////////////
0:             for (Service service : services) {
/////////////////////////////////////////////////////////////////////////
1:         VMTransportFactory.stopped(getBrokerName());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         synchronized (shutdownHooks) {
1:                 } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("ActiveMQ " + ActiveMQConnectionMetaData.PROVIDER_VERSION + " JMS Message Broker ("
0:                     + getBrokerName() + ") is starting");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param dataDirectory
1:      *            the directory to store data files
/////////////////////////////////////////////////////////////////////////
1:      * @param dataDirectoryFile
1:      *            the directory to store data files
/////////////////////////////////////////////////////////////////////////
1:      * @param tmpDataDirectory
1:      *            the tmpDataDirectory to set
/////////////////////////////////////////////////////////////////////////
0:                 systemUsage.getMemoryUsage().setLimit(1024 * 1024 * 64); // Default
0:                                                                          // 64
0:                                                                          // Meg
0:                 systemUsage.getTempUsage().setLimit(1024L * 1024 * 1024 * 100); // 10
0:                                                                                 // Gb
0:                 systemUsage.getStoreUsage().setLimit(1024L * 1024 * 1024 * 100); // 100
0:                                                                                  // GB
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException
1:             if (splitSystemUsageForProducersConsumers) {
1:                 float portion = consumerSystemUsagePortion / 100f;
1:             } else {
1:                 consumerSystemUsaage = getSystemUsage();
1:      * @param consumerSystemUsaage
1:      *            the storeSystemUsage to set
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException
1:         if (producerSystemUsage == null) {
1:                 float portion = producerSystemUsagePortion / 100f;
1:             } else {
1:                 producerSystemUsage = getSystemUsage();
1:      * @param producerUsageManager
1:      *            the producerUsageManager to set
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws IOException
0:             taskRunnerFactory = new TaskRunnerFactory("BrokerService", getTaskRunnerPriority(), true, 1000,
1:                     isDedicatedTaskRunner());
/////////////////////////////////////////////////////////////////////////
1:             persistenceTaskRunnerFactory = new TaskRunnerFactory("Persistence Adaptor Task", persistenceThreadPriority,
0:                     true, 1000);
/////////////////////////////////////////////////////////////////////////
1:         for (NetworkConnector connector : networkConnectors) {
1:             if (connector.getName().equals(connectorName)) {
/////////////////////////////////////////////////////////////////////////
1:         for (TransportConnector connector : transportConnectors) {
1:             if (connector.getName().equals(connectorName)) {
/////////////////////////////////////////////////////////////////////////
1:      * @param jmsConnectors
1:      *            The jmsBridgeConnectors to set.
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < services.length; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property 
1:      *                            nestedType="org.apache.activemq.broker.TransportConnector"
/////////////////////////////////////////////////////////////////////////
0:      * @org.apache.xbean.Property 
1:      *                            nestedType="org.apache.activemq.network.NetworkConnector"
0:             NetworkConnector connector = (NetworkConnector) iter.next();
/////////////////////////////////////////////////////////////////////////
0:             ProxyConnector connector = (ProxyConnector) iter.next();
/////////////////////////////////////////////////////////////////////////
1:      * @param shutdownOnMasterFailure
1:      *            The shutdownOnMasterFailure to set.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param tempDataStore
1:      *            the tempDataStore to set
/////////////////////////////////////////////////////////////////////////
1:      * @param useLocalHostBrokerName
1:      *            the useLocalHostBrokerName to set
/////////////////////////////////////////////////////////////////////////
0:      * @param supportFailOver
0:      *            the supportFailOver to set
1:      * Looks up and lazily creates if necessary the destination for the given
1:      * JMS name
1: 
1:         getBroker().removeDestination(getAdminConnectionContext(), destination, 0);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setSplitSystemUsageForProducersConsumers(boolean splitSystemUsageForProducersConsumers) {
1: 
1:         return monitorConnectionSplits;
1:     }
1:     public void setMonitorConnectionSplits(boolean monitorConnectionSplits) {
1:         this.monitorConnectionSplits = monitorConnectionSplits;
1:     }
1:     public int getTaskRunnerPriority() {
1:         return taskRunnerPriority;
1:     }
1:     public void setTaskRunnerPriority(int taskRunnerPriority) {
1:         this.taskRunnerPriority = taskRunnerPriority;
1:     }
1:     public boolean isDedicatedTaskRunner() {
1:         return dedicatedTaskRunner;
1:     }
1: 
1:     public void setDedicatedTaskRunner(boolean dedicatedTaskRunner) {
1:         this.dedicatedTaskRunner = dedicatedTaskRunner;
1:     }
1: 
1:     public boolean isCacheTempDestinations() {
/////////////////////////////////////////////////////////////////////////
1:     public void setTimeBeforePurgeTempDestinations(int timeBeforePurgeTempDestinations) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     //
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 throw new IllegalStateException(
0:                         "Cannot specify masterConnectorURI when a masterConnector is already registered via the services property");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             ObjectName objectName = createConnectorObjectName(connector);
1:             connector = connector.asManagedConnector(getManagementContext(), objectName);
1:             ConnectorViewMBean view = new ConnectorView(connector);
0:             getManagementContext().registerMBean(view, objectName);
1:             return connector;
1:         } catch (Throwable e) {
0:             throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e.getMessage(), e);
1:             try {
1:                 ObjectName objectName = createConnectorObjectName(connector);
1:                 getManagementContext().unregisterMBean(objectName);
1:             } catch (Throwable e) {
1:                 throw IOExceptionSupport.create(
0:                         "Transport Connector could not be registered in JMX: " + e.getMessage(), e);
1: 
0:         return new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName="
0:                 + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=Connector," + "ConnectorName="
0:                 + JMXSupport.encodeObjectNamePart(connector.getName()));
1:         NetworkConnectorViewMBean view = new NetworkConnectorView(connector);
1:         try {
1:             ObjectName objectName = createNetworkConnectorObjectName(connector);
1:             connector.setObjectName(objectName);
0:             getManagementContext().registerMBean(view, objectName);
1:         } catch (Throwable e) {
1:             throw IOExceptionSupport.create("Network Connector could not be registered in JMX: " + e.getMessage(), e);
0:     protected ObjectName createNetworkConnectorObjectName(NetworkConnector connector)
0:             throws MalformedObjectNameException {
0:         return new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName="
0:                 + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=NetworkConnector,"
0:                 + "NetworkConnectorName=" + JMXSupport.encodeObjectNamePart(connector.getName()));
1:             try {
1:                 ObjectName objectName = createNetworkConnectorObjectName(connector);
1:                 getManagementContext().unregisterMBean(objectName);
0:             } catch (Exception e) {
0:                 LOG.error("Network Connector could not be unregistered from JMX: " + e, e);
1:         ProxyConnectorView view = new ProxyConnectorView(connector);
1:         try {
0:             ObjectName objectName = new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName="
0:                     + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=ProxyConnector,"
0:                     + "ProxyConnectorName=" + JMXSupport.encodeObjectNamePart(connector.getName()));
0:             getManagementContext().registerMBean(view, objectName);
1:         } catch (Throwable e) {
1:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
0:         FTConnectorView view = new FTConnectorView(connector);
1:         try {
0:             ObjectName objectName = new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName="
0:                     + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=MasterConnector");
0:             getManagementContext().registerMBean(view, objectName);
1:         } catch (Throwable e) {
1:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:         JmsConnectorView view = new JmsConnectorView(connector);
1:         try {
0:             ObjectName objectName = new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName="
0:                     + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=JmsConnector,"
0:                     + "JmsConnectorName=" + JMXSupport.encodeObjectNamePart(connector.getName()));
0:             getManagementContext().registerMBean(view, objectName);
1:         } catch (Throwable e) {
1:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:             Broker old;
1: 
1:             public void stop() throws Exception {
1: 
1:             public void start() throws Exception {
1:                 if (forceStart && old != null) {
1:                     this.next.set(old);
1:                 }
1:                 getNext().start();
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:         RegionBroker regionBroker;
0:             regionBroker = new ManagedRegionBroker(this, getManagementContext(), getBrokerObjectName(),
0:                     getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory, destinationInterceptor);
1:             regionBroker = new RegionBroker(this, getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory,
0:                     destinationInterceptor);
1:         return regionBroker;
1:     }
/////////////////////////////////////////////////////////////////////////
1:             VirtualDestination[] virtualDestinations = { virtualTopic };
1:             MirroredQueue interceptor = new MirroredQueue();
/////////////////////////////////////////////////////////////////////////
1:         if (isMonitorConnectionSplits()) {
1:             broker = new ConnectionSplitBroker(broker);
/////////////////////////////////////////////////////////////////////////
0:             return new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName="
0:                     + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=Broker");
0:         TransportServer transport = TransportFactory.bind(this, brokerURI);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected void waitForSlave() {
0:             slaveStartSignal.await();
1:         } catch (InterruptedException e) {
0:             LOG.error("Exception waiting for slave:" + e);
1: 
0:     protected void slaveConnectionEstablished() {
0:         slaveStartSignal.countDown();
1: 
/////////////////////////////////////////////////////////////////////////
0:             Set<ActiveMQDestination> durableDestinations = getBroker().getDurableDestinations();
/////////////////////////////////////////////////////////////////////////
0:             if (isWaitForSlave()) {
0:                 waitForSlave();
/////////////////////////////////////////////////////////////////////////
0:             for (Service service : services) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQDestination destination = (ActiveMQDestination) iter.next();
/////////////////////////////////////////////////////////////////////////
1:         synchronized (shutdownHooks) {
1: 
1:         synchronized (shutdownHooks) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isShutdownOnSlaveFailure() {
1:         return shutdownOnSlaveFailure;
1:     }
1:     public void setShutdownOnSlaveFailure(boolean shutdownOnSlaveFailure) {
1:         this.shutdownOnSlaveFailure = shutdownOnSlaveFailure;
1:     }
1:     public boolean isWaitForSlave() {
1:         return waitForSlave;
1:     }
1:     public void setWaitForSlave(boolean waitForSlave) {
1:         this.waitForSlave = waitForSlave;
1:     }
0:     public CountDownLatch getSlaveStartSignal() {
0:         return slaveStartSignal;
1:     }
commit:3b37436
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d14e4ae
/////////////////////////////////////////////////////////////////////////
0: 	protected CountDownLatch slaveStartSignal = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1:     private boolean shutdownOnSlaveFailure;
1:     private boolean waitForSlave;
/////////////////////////////////////////////////////////////////////////
0:     protected void waitForSlave(){
1:         try {
0:         	slaveStartSignal.await();
0:         }catch(InterruptedException e){
0:         	LOG.error("Exception waiting for slave:"+e);
1:         }
1:     }
1:     
0:     protected void slaveConnectionEstablished(){
0:     	slaveStartSignal.countDown();
1:     }
1:     
1:     
/////////////////////////////////////////////////////////////////////////
0:             if(isWaitForSlave()){
0:             	waitForSlave();
1:             }
/////////////////////////////////////////////////////////////////////////
0: 	public boolean isShutdownOnSlaveFailure() {
0: 		return shutdownOnSlaveFailure;
1: 	}
1: 
0: 	public void setShutdownOnSlaveFailure(boolean shutdownOnSlaveFailure) {
0: 		this.shutdownOnSlaveFailure = shutdownOnSlaveFailure;
1: 	}
1: 
0: 	public boolean isWaitForSlave() {
0: 		return waitForSlave;
1: 	}
1: 
0: 	public void setWaitForSlave(boolean waitForSlave) {
0: 		this.waitForSlave = waitForSlave;
1: 	}
1: 
0: 	public CountDownLatch getSlaveStartSignal() {
0: 		return slaveStartSignal;
1: 	}
1: 
commit:0cf3845
/////////////////////////////////////////////////////////////////////////
0:                 systemUsage.getTempUsage().setLimit(1024L * 1024 * 1024 * 100); // 10 Gb
0:                 systemUsage.getStoreUsage().setLimit(1024L * 1024 * 1024 * 100); // 100 GB
commit:55409bd
/////////////////////////////////////////////////////////////////////////
0:             try{
1:                 stop();
0:             }catch(Exception ex) {
0:                 LOG.warn("Failed to stop broker after failure in start ",ex);
1:             }
commit:4ee029e
/////////////////////////////////////////////////////////////////////////
1:                 broker.nowMasterBroker();
commit:2aa661d
/////////////////////////////////////////////////////////////////////////
0:         	Set<ActiveMQDestination> durableDestinations = getBroker().getDurableDestinations();
/////////////////////////////////////////////////////////////////////////
0:                 connector.setDurableDestinations(durableDestinations);
commit:803abe4
/////////////////////////////////////////////////////////////////////////
1:         // remove any VMTransports connected
1:         // this has to be done after services are stopped,
0:         // to avoid timimg issue with discovery (spinning up a new instance)
1:         BrokerRegistry.getInstance().unbind(getBrokerName());
0:         VMTransportFactory.stopped(getBrokerName());        
/////////////////////////////////////////////////////////////////////////
commit:620b657
/////////////////////////////////////////////////////////////////////////
0:     private boolean useTempMirroredQueues=true;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isUseTempMirroredQueues() {
1:         return useTempMirroredQueues;
1:     }
1: 
1:     public void setUseTempMirroredQueues(boolean useTempMirroredQueues) {
1:         this.useTempMirroredQueues = useTempMirroredQueues;
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
commit:16f2d75
/////////////////////////////////////////////////////////////////////////
1:     public void removeDestination(ActiveMQDestination destination) throws Exception {
0:         getBroker().removeDestination(getAdminConnectionContext(), destination,0);
1:     }
1:     
commit:8bf9c17
/////////////////////////////////////////////////////////////////////////
0:         if (!isAdvisorySupport()) {
0:             throw new javax.jms.IllegalStateException("Networks require advisory messages to function - advisories are currently disabled");
1:         }
commit:f1b6362
/////////////////////////////////////////////////////////////////////////
0:            // see if there is a MasterBroker service and if so, configure
0:             // it and start it.
0:             for (Service service : services) {
0:                 if (service instanceof MasterConnector) {
1:                     configureService(service);
0:                     service.start();
1:                 }
1:             } 
0:             if (!isSlave()) {
1:                 startAllConnectors();
1:             }
/////////////////////////////////////////////////////////////////////////
0:         boolean masterServiceExists = false;
/////////////////////////////////////////////////////////////////////////
0:         for (Service service : services) {
0:             if (service instanceof MasterConnector) {
0:                 masterServiceExists = true;
0:                 break;
1:             }
1:         }
0:             if (masterServiceExists) {
/////////////////////////////////////////////////////////////////////////
1:             BrokerServiceAware serviceAware = (BrokerServiceAware) service;
0:         if (masterConnector == null) {
0:             if (service instanceof MasterConnector) {
0:                 masterConnector = (MasterConnector) service;
0:                 supportFailOver = true;
1:             }
commit:2f9fdea
/////////////////////////////////////////////////////////////////////////
0:     private boolean monitorConnectionSplits=false;
0:     private boolean cacheTempDestinations=false;//useful for failover
commit:0ff0ee3
/////////////////////////////////////////////////////////////////////////
commit:5dc188e
/////////////////////////////////////////////////////////////////////////
0:     private boolean monitorConnectionSplits=true;
commit:5fd3229
/////////////////////////////////////////////////////////////////////////
0:         map.put("async", "false");
commit:e4621e3
/////////////////////////////////////////////////////////////////////////
0:     private boolean cacheTempDestinations=true;//useful for failover
1:     private int timeBeforePurgeTempDestinations = 5000;
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	public boolean isCacheTempDestinations() {
1:         return cacheTempDestinations;
1:     }
1: 
1:     public void setCacheTempDestinations(boolean cacheTempDestinations) {
1:         this.cacheTempDestinations = cacheTempDestinations;
1:     }
1: 
1:     public int getTimeBeforePurgeTempDestinations() {
1:         return timeBeforePurgeTempDestinations;
1:     }
1: 
0:     public void setTimeBeforePurgeTempDestinations(
0:             int timeBeforePurgeTempDestinations) {
1:         this.timeBeforePurgeTempDestinations = timeBeforePurgeTempDestinations;
1:     }
commit:290ce2a
/////////////////////////////////////////////////////////////////////////
0:         map.put("async", "true");
commit:88fbb05
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.cluster.ConnectionSplitBroker;
/////////////////////////////////////////////////////////////////////////
0:     private boolean monitorConnectionSplits;
1:     private int taskRunnerPriority = Thread.NORM_PRIORITY;
1:     private boolean dedicatedTaskRunner;
/////////////////////////////////////////////////////////////////////////
0:             taskRunnerFactory = new TaskRunnerFactory("BrokerService",getTaskRunnerPriority(),true,1000,isDedicatedTaskRunner());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isMonitorConnectionSplits() {
0: 		return monitorConnectionSplits;
1: 	}
0: 	public void setMonitorConnectionSplits(boolean monitorConnectionSplits) {
0: 		this.monitorConnectionSplits = monitorConnectionSplits;
1: 	}
0: 	public int getTaskRunnerPriority() {
0: 		return taskRunnerPriority;
1: 	}
1: 
0: 	public void setTaskRunnerPriority(int taskRunnerPriority) {
0: 		this.taskRunnerPriority = taskRunnerPriority;
1: 	}
1: 
0: 	public boolean isDedicatedTaskRunner() {
0: 		return dedicatedTaskRunner;
1: 	}
1: 
0: 	public void setDedicatedTaskRunner(boolean dedicatedTaskRunner) {
0: 		this.dedicatedTaskRunner = dedicatedTaskRunner;
1: 	}
0: 	//
/////////////////////////////////////////////////////////////////////////
0:         if (isMonitorConnectionSplits()){
0:         	broker = new ConnectionSplitBroker(broker);
1:         }
/////////////////////////////////////////////////////////////////////////
1: }
commit:c427689
/////////////////////////////////////////////////////////////////////////
1:     private int producerSystemUsagePortion = 60;
1:     private int consumerSystemUsagePortion = 40;
1:     private boolean splitSystemUsageForProducersConsumers;
/////////////////////////////////////////////////////////////////////////
0:             if(splitSystemUsageForProducersConsumers) {
1:                 this.consumerSystemUsaage = new SystemUsage(getSystemUsage(), "Consumer");
0:                 float portion = consumerSystemUsagePortion/100f;
1:                 this.consumerSystemUsaage.getMemoryUsage().setUsagePortion(portion);
1:                 addService(this.consumerSystemUsaage);
0:             }else {
0:                 consumerSystemUsaage=getSystemUsage();
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if (producerSystemUsage == null ) {
1:             if (splitSystemUsageForProducersConsumers) {
1:                 producerSystemUsage = new SystemUsage(getSystemUsage(), "Producer");
0:                 float portion = producerSystemUsagePortion/100f;
1:                 producerSystemUsage.getMemoryUsage().setUsagePortion(portion);
1:                 addService(producerSystemUsage);
0:             }else {
0:                 producerSystemUsage=getSystemUsage();
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
1:     public int getProducerSystemUsagePortion() {
1:         return producerSystemUsagePortion;
1:     }
1: 
1:     public void setProducerSystemUsagePortion(int producerSystemUsagePortion) {
1:         this.producerSystemUsagePortion = producerSystemUsagePortion;
1:     }
1: 
1:     public int getConsumerSystemUsagePortion() {
1:         return consumerSystemUsagePortion;
1:     }
1: 
1:     public void setConsumerSystemUsagePortion(int consumerSystemUsagePortion) {
1:         this.consumerSystemUsagePortion = consumerSystemUsagePortion;
1:     }
1: 
1:     public boolean isSplitSystemUsageForProducersConsumers() {
1:         return splitSystemUsageForProducersConsumers;
1:     }
1: 
0:     public void setSplitSystemUsageForProducersConsumers(
0:             boolean splitSystemUsageForProducersConsumers) {
1:         this.splitSystemUsageForProducersConsumers = splitSystemUsageForProducersConsumers;
1:     }
commit:5f4db41
/////////////////////////////////////////////////////////////////////////
1:             this.persistenceAdapter = registerPersistenceAdapterMBean(persistenceAdapter);
1:      * @throws IOException 
1:     public void setPersistenceAdapter(PersistenceAdapter persistenceAdapter) throws IOException {
1:         this.persistenceAdapter = registerPersistenceAdapterMBean(persistenceAdapter);
1:         
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected PersistenceAdapter registerPersistenceAdapterMBean(PersistenceAdapter adaptor) throws IOException {
0:         MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:         if (mbeanServer != null) {
1: 
1:           
1:         }
1:         return adaptor;
1:     }
1: 
1:     protected void unregisterPersistenceAdapterMBean(PersistenceAdapter adaptor) throws IOException {
1:         if (isUseJmx()) {
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             if (mbeanServer != null) {
1:                 
1:             }       
1:         }
1:     }
commit:2db7df7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.BrokerView;
0: import org.apache.activemq.broker.jmx.ConnectorView;
0: import org.apache.activemq.broker.jmx.ConnectorViewMBean;
0: import org.apache.activemq.broker.jmx.FTConnectorView;
0: import org.apache.activemq.broker.jmx.JmsConnectorView;
0: import org.apache.activemq.broker.jmx.ManagedRegionBroker;
0: import org.apache.activemq.broker.jmx.ManagementContext;
0: import org.apache.activemq.broker.jmx.NetworkConnectorView;
0: import org.apache.activemq.broker.jmx.NetworkConnectorViewMBean;
0: import org.apache.activemq.broker.jmx.ProxyConnectorView;
/////////////////////////////////////////////////////////////////////////
1:    
/////////////////////////////////////////////////////////////////////////
0:     public boolean isSlave() {
commit:a3b4c5a
/////////////////////////////////////////////////////////////////////////
1:         configureService(this.persistenceAdapter);
commit:f472000
/////////////////////////////////////////////////////////////////////////
1:     private SystemUsage consumerSystemUsaage;
/////////////////////////////////////////////////////////////////////////
1:         if (this.consumerSystemUsaage == null) {
0:             this.consumerSystemUsaage = new SystemUsage(getSystemUsage(), "Consumer");
0:             this.consumerSystemUsaage.getMemoryUsage().setUsagePortion(0.5f);
1:             addService(this.consumerSystemUsaage);
1:         return this.consumerSystemUsaage;
0:      * @param consumerSystemUsaage the storeSystemUsage to set
1:     public void setConsumerSystemUsage(SystemUsage consumerSystemUsaage) {
1:         if (this.consumerSystemUsaage != null) {
1:             removeService(this.consumerSystemUsaage);
1:         this.consumerSystemUsaage = consumerSystemUsaage;
1:         addService(this.consumerSystemUsaage);
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0:     private SystemUsage storeSystemUsage;
/////////////////////////////////////////////////////////////////////////
0:         if (this.storeSystemUsage == null) {
0:             this.storeSystemUsage = new SystemUsage(getSystemUsage(), "Store");
0:             this.storeSystemUsage.getMemoryUsage().setUsagePortion(0.5f);
0:             addService(this.storeSystemUsage);
0:         return this.storeSystemUsage;
0:      * @param storeSystemUsage the storeSystemUsage to set
0:     public void setConsumerSystemUsage(SystemUsage storeSystemUsage) {
0:         if (this.storeSystemUsage != null) {
0:             removeService(this.storeSystemUsage);
0:         this.storeSystemUsage = storeSystemUsage;
0:         addService(this.storeSystemUsage);
commit:2cb2119
/////////////////////////////////////////////////////////////////////////
0:     private List<Service> services = new ArrayList<Service>();
/////////////////////////////////////////////////////////////////////////
0:             for (Service service: services) {
/////////////////////////////////////////////////////////////////////////
1:                 addService(this.systemUsage);
/////////////////////////////////////////////////////////////////////////
1:         if (this.systemUsage != null) {
1:             removeService(this.systemUsage);
1:         }
1:         addService(this.systemUsage);
/////////////////////////////////////////////////////////////////////////
0:             addService(consumerSystemUsage);
/////////////////////////////////////////////////////////////////////////
0:         if (this.consumerSystemUsage != null) {
0:             removeService(this.consumerSystemUsage);
1:         }
1:         addService(this.producerSystemUsage);
/////////////////////////////////////////////////////////////////////////
0:             addService(producerSystemUsage);
/////////////////////////////////////////////////////////////////////////
1:         if (this.producerSystemUsage != null) {
1:             removeService(this.producerSystemUsage);
1:         }
0:         addService(this.producerSystemUsage);
/////////////////////////////////////////////////////////////////////////
0:         return (Service[]) services.toArray();
/////////////////////////////////////////////////////////////////////////
1:         this.services.clear();
1:         if (services != null) {
0:             for (int i=0; i < services.length;i++) {
1:                 this.services.add(services[i]);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         services.add(service);
1:     }
1:     
1:     public void removeService(Service service) {
1:         services.remove(service);
/////////////////////////////////////////////////////////////////////////
0:             for (Service service:services) {
0:                 configureService(service);
0:                 service.start();
commit:e2ef8b8
/////////////////////////////////////////////////////////////////////////
1:     public NetworkConnector getNetworkConnectorByName(String connectorName) {
0:         for(NetworkConnector connector : networkConnectors) {
0:             if(connector.getName().equals(connectorName)) {
1:                 return connector;
1:             }
1:         }
1:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public TransportConnector getConnectorByName(String connectorName) {
0:         for(TransportConnector connector : transportConnectors) {
0:             if(connector.getName().equals(connectorName)) {
1:                 return connector;
1:             }
1:         }
1:         return null;
1:     }
1: 
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     private SystemUsage usageManager;
1:     private SystemUsage producerSystemUsage;
0:     private SystemUsage consumerSystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     public SystemUsage getUsageManager() {
1:         try {
0:             usageManager = new SystemUsage("Main",getPersistenceAdapter(),getTempDataStore());
0:             usageManager.getMemoryUsage().setLimit(1024 * 1024 * 64); // Default to 64 Meg
0:             usageManager.getTempDiskUsage().setLimit(1024 * 1024 * 1024 * 100);//10 Gb
0:             usageManager.getStoreUsage().setLimit(1024 * 1024 * 1024 * 100); //100 GB
0:         }catch(IOException e) {
0:             LOG.fatal("Cannot create SystemUsage",e);
0:             throw new RuntimeException("Fatally failed to create SystemUsage" + e.getMessage());
1:         }
0:     public void setUsageManager(SystemUsage memoryManager) {
1:      * @throws IOException 
1:     public SystemUsage getConsumerSystemUsage() throws IOException {
0:         if (consumerSystemUsage == null) {
0:             consumerSystemUsage = new SystemUsage(getUsageManager(), "Consumer");
0:             consumerSystemUsage.getMemoryUsage().setUsagePortion(0.5f);
0:         return consumerSystemUsage;
0:     public void setConsumerSystemUsage(SystemUsage consumerUsageManager) {
0:         this.consumerSystemUsage = consumerUsageManager;
1:      * @throws IOException 
1:     public SystemUsage getProducerSystemUsage() throws IOException {
0:         if (producerSystemUsage == null) {
0:             producerSystemUsage = new SystemUsage(getUsageManager(), "Producer");
0:             producerSystemUsage.getMemoryUsage().setUsagePortion(0.45f);
1:         return producerSystemUsage;
1:     public void setProducerSystemUsage(SystemUsage producerUsageManager) {
1:         this.producerSystemUsage = producerUsageManager;
/////////////////////////////////////////////////////////////////////////
0:         getPersistenceAdapter().setUsageManager(getProducerSystemUsage());
/////////////////////////////////////////////////////////////////////////
0:             destinationFactory = new DestinationFactoryImpl(getProducerSystemUsage(), getTaskRunnerFactory(), getPersistenceAdapter());
0:             regionBroker = new ManagedRegionBroker(this, mbeanServer, getBrokerObjectName(), getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory,
0:             regionBroker = new RegionBroker(this, getTaskRunnerFactory(), getConsumerSystemUsage(), destinationFactory, destinationInterceptor);
commit:64b8fb6
/////////////////////////////////////////////////////////////////////////
1:      * @param brokerName 
0:         String str = brokerName.replaceAll("[^a-zA-Z0-9\\.\\_\\-\\:]", "_");
1:         if (!str.equals(brokerName)) {
0:             log.error("Broker Name: " + brokerName + " contained illegal characters - replaced with " + str);
1:         }
1:         this.brokerName = str.trim();
1:         
/////////////////////////////////////////////////////////////////////////
1:         String brokerDir = getBrokerName();
commit:1e3e5b7
/////////////////////////////////////////////////////////////////////////
0:             boolean result=true;
0:             boolean empty=true;
0:                 File directory=getTmpDataDirectory();
0:                 if(directory.exists()&&directory.isDirectory()){
0:                     File[] files=directory.listFiles();
0:                     if(files!=null&&files.length>0){
0:                         empty=false;
0:                         for(int i=0;i<files.length;i++){
0:                             File file=files[i];
0:                             if(!file.isDirectory()){
0:                                 result&=file.delete();
1:                             }
1:                         }
1:                     }
1:                 }
0:                 if(!empty){
0:                     String str=result?"Successfully deleted":"Failed to delete";
0:                     log.info(str+" temporary storage");
1:                 }
0:                 tempDataStore=StoreFactory.open(getTmpDataDirectory().getPath(),"rw");
commit:83a6eff
/////////////////////////////////////////////////////////////////////////
0:     private boolean clustered = false;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * @return the clustered
1:      */
0:     public boolean isClustered(){
0:         return this.clustered;
1:     }
1: 
1:     /**
0:      * @param clustered the clustered to set
1:      */
0:     public void setClustered(boolean clustered){
0:         this.clustered=clustered;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     }   
commit:4757541
/////////////////////////////////////////////////////////////////////////
0:         map.put("async","false");
/////////////////////////////////////////////////////////////////////////
1:             URI uri = getVmConnectorURI();
0:             HashMap map = new HashMap(URISupport.parseParamters(uri));
0:             map.put("network", "true");
0:             map.put("async","false");
0:             uri = URISupport.createURIWithQuery(uri, URISupport.createQueryString(map));
0:                 connector.setLocalUri(uri);
commit:25a252f
/////////////////////////////////////////////////////////////////////////
0:     private boolean supportFailOver = false;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isSlave(){
/////////////////////////////////////////////////////////////////////////
1:             getBroker().brokerServiceStarted();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * @return the supportFailOver
1:      */
0:     public boolean isSupportFailOver(){
0:         return this.supportFailOver;
1:     }
1: 
1:     /**
0:      * @param supportFailOver the supportFailOver to set
1:      */
0:     public void setSupportFailOver(boolean supportFailOver){
0:         this.supportFailOver=supportFailOver;
1:     }    
/////////////////////////////////////////////////////////////////////////
0:             supportFailOver=true;
/////////////////////////////////////////////////////////////////////////
1:     }
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                
commit:2bed73b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class BrokerService implements Service {
commit:a2aed3d
/////////////////////////////////////////////////////////////////////////
0:     static final String DEFAULT_BROKER_NAME = "localhost";
commit:47510d8
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Store getTempDataStore(){
0:         if(tempDataStore==null){
0:             String name=getTmpDataDirectory().getPath();
0:             try{
0:                 log.info("About to delete any non-persistent messages that may have overflowed to disk ...");
0:                 StoreFactory.delete(name);
0:                 log.info("Successfully deleted temporary storage");
0:                 tempDataStore=StoreFactory.open(name,"rw");
commit:0d9b413
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
commit:985b4ce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.amq.AMQPersistenceAdapterFactory;
0: import org.apache.activemq.store.journal.JournalPersistenceAdapterFactory;
/////////////////////////////////////////////////////////////////////////
0:         getPersistenceAdapter().setBrokerName(getBrokerName());
/////////////////////////////////////////////////////////////////////////
0:     protected AMQPersistenceAdapterFactory createPersistenceFactory() {
0:         AMQPersistenceAdapterFactory factory = new AMQPersistenceAdapterFactory();
0:         factory.setDataDirectory(getDataDirectory());
0:         factory.setBrokerName(getBrokerName());
commit:1dc9d9d
/////////////////////////////////////////////////////////////////////////
1:     private boolean enableStatistics = true;
commit:9fd9189
/////////////////////////////////////////////////////////////////////////
0:         if(this.deleteAllMessagesOnStartup){
1:             getPersistenceAdapter().deleteAllMessages();
1:         }
commit:14c605f
/////////////////////////////////////////////////////////////////////////
0:     private UsageManager usageManager;
0:     private UsageManager producerUsageManager;
0:     private UsageManager consumerUsageManager;
/////////////////////////////////////////////////////////////////////////
0:         if (usageManager == null) {
0:             usageManager = new UsageManager("Main");
0:             usageManager.setLimit(1024 * 1024 * 20); // Default to 20 Meg
0:         return usageManager;
1:        
0:         this.usageManager = memoryManager;
1:     }
1:     
1:     /**
1:      * @return the consumerUsageManager
1:      */
0:     public UsageManager getConsumerUsageManager(){
0:         if (consumerUsageManager==null) {
0:             consumerUsageManager = new UsageManager(getMemoryManager(),"Consumer",0.5f);
1:         }
0:         return consumerUsageManager;
1:     
1:     /**
0:      * @param consumerUsageManager the consumerUsageManager to set
1:      */
0:     public void setConsumerUsageManager(UsageManager consumerUsageManager){
0:         this.consumerUsageManager=consumerUsageManager;
1:     }
1: 
1:     
1:     /**
1:      * @return the producerUsageManager
1:      */
0:     public UsageManager getProducerUsageManager(){
0:         if (producerUsageManager==null) {
0:             producerUsageManager = new UsageManager(getMemoryManager(),"Producer",0.45f);
1:         }
0:         return producerUsageManager;
1:     }
1:     
1:     /**
0:      * @param producerUsageManager the producerUsageManager to set
1:      */
0:     public void setProducerUsageManager(UsageManager producerUsageManager){
0:         this.producerUsageManager=producerUsageManager;
1:     }    
1: 
1:    
/////////////////////////////////////////////////////////////////////////
0:         getPersistenceAdapter().setUsageManager(getProducerUsageManager());
/////////////////////////////////////////////////////////////////////////
0:             destinationFactory = new DestinationFactoryImpl(getProducerUsageManager(), getTaskRunnerFactory(), getPersistenceAdapter());
0:             regionBroker = new ManagedRegionBroker(this, mbeanServer, getBrokerObjectName(), getTaskRunnerFactory(), getConsumerUsageManager(),
0:             regionBroker = new RegionBroker(this,getTaskRunnerFactory(), getConsumerUsageManager(), destinationFactory, destinationInterceptor);
/////////////////////////////////////////////////////////////////////////
1: 
1:     
1:    
commit:f5b1b83
/////////////////////////////////////////////////////////////////////////
0:     private boolean enableStatistics = false;
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
commit:61d56b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws Exception{
0:         if(!started.compareAndSet(true,false)){
0:         log.info("ActiveMQ Message Broker ("+getBrokerName()+", "+brokerId+") is shutting down");
0:         ServiceStopper stopper=new ServiceStopper();
0:         if(services!=null){
0:             for(int i=0;i<services.length;i++){
0:                 Service service=services[i];
0:         if(broker!=null){
0:         if(isUseJmx()){
0:             MBeanServer mbeanServer=getManagementContext().getMBeanServer();
0:             if(mbeanServer!=null){
0:                 for(Iterator iter=registeredMBeanNames.iterator();iter.hasNext();){
0:                     ObjectName name=(ObjectName)iter.next();
0:                     try{
0:                     }catch(Exception e){
0:                         stopper.onException(mbeanServer,e);
0:         // remove any VMTransports connected
0:         // this has to be done after services are stopped,
0:         // to avoid timimg issue with discovery (spinning up a new instance)
0:         BrokerRegistry.getInstance().unbind(getBrokerName());
0:         log.info("ActiveMQ JMS Message Broker ("+getBrokerName()+", "+brokerId+") stopped");
commit:81c5b15
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:         //remove any VMTransports connected
0:         //this has to be done after services are stopped,
0:         //to avoid timimg issue with discovery (spinning up a new instance)
0:         VMTransportFactory.stopped(getBrokerName());
/////////////////////////////////////////////////////////////////////////
0:                 connector.setLocalUri(getVmConnectorURI());
commit:bc03f37
/////////////////////////////////////////////////////////////////////////
0: import java.net.UnknownHostException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    
1:     public static final String DEFAULT_PORT = "61616";
1:     public static final String DEFAULT_BROKER_NAME = "localhost";
1:     public static final String LOCAL_HOST_NAME;
/////////////////////////////////////////////////////////////////////////
1:     private String brokerName = DEFAULT_BROKER_NAME;
/////////////////////////////////////////////////////////////////////////
0:     private boolean useLocalHostBrokerName = false;
1:     
1:    
/////////////////////////////////////////////////////////////////////////
0:                 // yes - this is order dependent!
/////////////////////////////////////////////////////////////////////////
1:         if (brokerName == null) {
1:             throw new NullPointerException("The broker name cannot be null");
1:         }
0:         brokerName = brokerName.trim();
/////////////////////////////////////////////////////////////////////////
0:                 vmConnectorURI = new URI("vm://" + getBrokerName().replaceAll("[^a-zA-Z0-9\\.\\_\\-]", "_"));
0:                 log.error("Badly formed URI from " + getBrokerName(),e);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return the useLocalHostBrokerName
1:      */
0:     public boolean isUseLocalHostBrokerName(){
1:         return this.useLocalHostBrokerName;
1:     }
1: 
1:     /**
0:      * @param useLocalHostBrokerName the useLocalHostBrokerName to set
1:      */
0:     public void setUseLocalHostBrokerName(boolean useLocalHostBrokerName){
0:         this.useLocalHostBrokerName=useLocalHostBrokerName;
0:         if(useLocalHostBrokerName&&!started.get()&&brokerName==null||brokerName==DEFAULT_BROKER_NAME){
0:             brokerName=LOCAL_HOST_NAME;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
0:     static{
1:         String localHostName = "localhost";
0:         try{
0:             localHostName=java.net.InetAddress.getLocalHost().getHostName();
0:         }catch(UnknownHostException e){
0:             log.error("Failed to resolve localhost");
1:         }
1:         LOCAL_HOST_NAME = localHostName;
1:     }
commit:f1a989d
/////////////////////////////////////////////////////////////////////////
0:             log.info("Using Persistence Adapter: " + getPersistenceAdapter());
commit:415d46c
/////////////////////////////////////////////////////////////////////////
0:             log.info("Using Persistence Adaptor: " + getPersistenceAdapter());
commit:4597ddd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
0:     //private PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy = new VMPendingDurableSubscriberMessageStoragePolicy();
0:     private PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy = new StorePendingDurableSubscriberMessageStoragePolicy();
/////////////////////////////////////////////////////////////////////////
0:             log.info("Using Persistence Adaptor " + getPersistenceAdapter());
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy;
0: import org.apache.activemq.broker.region.policy.VMPendingDurableSubscriberMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
0:     private PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy = new VMPendingDurableSubscriberMessageStoragePolicy();
/////////////////////////////////////////////////////////////////////////
0:             /*
0:             if(isUseJmx()){
0:                 // yes - this is orer dependent!
0:                 // register all destination in persistence store including inactive destinations as mbeans
0:                 this.startDestinationsInPersistenceStore(broker);
1:             }
1:             */
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * @return the pendingDurableSubscriberPolicy
1:      */
0:     public PendingDurableSubscriberMessageStoragePolicy getPendingDurableSubscriberPolicy(){
0:         return this.pendingDurableSubscriberPolicy;
1:     }
1:   
1:     /**
0:      * @param pendingDurableSubscriberPolicy the pendingDurableSubscriberPolicy to set
1:      */
0:     public void setPendingDurableSubscriberPolicy(PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy){
0:         this.pendingDurableSubscriberPolicy=pendingDurableSubscriberPolicy;
1:         if (broker != null) {
0:             broker.setPendingDurableSubscriberPolicy(pendingDurableSubscriberPolicy);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         regionBroker.setPendingDurableSubscriberPolicy(getPendingDurableSubscriberPolicy());
/////////////////////////////////////////////////////////////////////////
1:     }    
commit:78035ea
/////////////////////////////////////////////////////////////////////////
0:         if(tempDataStore!=null){
0:             tempDataStore.close();
1:         }
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0:         tempDataStore.close();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Store getTempDataStore() {
commit:3fe77a2
/////////////////////////////////////////////////////////////////////////
1:     private TaskRunnerFactory persistenceTaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private int persistenceThreadPriority = Thread.MAX_PRIORITY;
1:    
/////////////////////////////////////////////////////////////////////////
1:     
1:     
0:     public TaskRunnerFactory getPersistenceTaskRunnerFactory(){
1:         if (taskRunnerFactory == null) {
0:             persistenceTaskRunnerFactory = new TaskRunnerFactory("Persistence Adaptor Task", persistenceThreadPriority, true, 1000);
1:         }
1:         return persistenceTaskRunnerFactory;
1:     }
1: 
1:    
0:     public void setPersistenceTaskRunnerFactory(TaskRunnerFactory persistenceTaskRunnerFactory){
0:         this.persistenceTaskRunnerFactory=persistenceTaskRunnerFactory;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
0:     public int getPersistenceThreadPriority(){
1:         return persistenceThreadPriority;
1:     }
1: 
0:     public void setPersistenceThreadPriority(int persistenceThreadPriority){
0:         this.persistenceThreadPriority=persistenceThreadPriority;
1:     }
/////////////////////////////////////////////////////////////////////////
0:         factory.setTaskRunnerFactory(getPersistenceTaskRunnerFactory());
/////////////////////////////////////////////////////////////////////////
1:    
1:     
1: 
1:     
1: 
commit:7d1e6bc
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.IOException;
0: import java.io.Serializable;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import javax.management.MBeanServer;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.CompositeDestinationInterceptor;
1: import org.apache.activemq.broker.region.virtual.VirtualDestination;
1: import org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor;
1: import org.apache.activemq.broker.region.virtual.VirtualTopic;
0: import org.apache.activemq.kaha.Store;
0: import org.apache.activemq.kaha.StoreFactory;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     private File tmpDataDirectory;
/////////////////////////////////////////////////////////////////////////
0:     private Store tempDataStore;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return the tmpDataDirectory
1:      */
0:     public File getTmpDataDirectory(){
1:         if (tmpDataDirectory == null) {
0:             tmpDataDirectory = new File(getDataDirectory(), "tmp_storage");
1:         }
1:         return tmpDataDirectory;
1:     }
1: 
1:     /**
0:      * @param tmpDataDirectory the tmpDataDirectory to set
1:      */
0:     public void setTmpDataDirectory(File tmpDataDirectory){
0:         this.tmpDataDirectory=tmpDataDirectory;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return the tempDataStore
1:      */
0:     public Store getTempDataStore() {
0:         if (tempDataStore == null){
0:             String name = getTmpDataDirectory().getPath();
1:             try {
0:             StoreFactory.delete(name);
0:             tempDataStore = StoreFactory.open(name,"rw");
0:             }catch(IOException e){
1:                 throw new RuntimeException(e);
1:             }
1:         }
1:         return tempDataStore;
1:     }
1: 
1:     /**
0:      * @param tempDataStore the tempDataStore to set
1:      */
0:     public void setTempDataStore(Store tempDataStore){
0:         this.tempDataStore=tempDataStore;
1:     }   
/////////////////////////////////////////////////////////////////////////
1: 
1:     
commit:9d4c74f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.DestinationFactory;
0: import org.apache.activemq.broker.region.DestinationFactoryImpl;
/////////////////////////////////////////////////////////////////////////
0:     private DestinationFactory destinationFactory;
/////////////////////////////////////////////////////////////////////////
1:     public void setDestinationFactory(DestinationFactory destinationFactory) {
1:         this.destinationFactory = destinationFactory;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0: 	RegionBroker regionBroker = null;
1: 	if (destinationFactory == null) {
0:             destinationFactory = new DestinationFactoryImpl(getMemoryManager(), getTaskRunnerFactory(), getPersistenceAdapter());
1:         }
0:                     destinationFactory, destinationInterceptor);
0:             regionBroker = new RegionBroker(this,getTaskRunnerFactory(), getMemoryManager(), destinationFactory, destinationInterceptor);
1:         destinationFactory.setRegionBroker(regionBroker);
1:         
/////////////////////////////////////////////////////////////////////////
1:    
commit:6cb66e4
/////////////////////////////////////////////////////////////////////////
0:                     getTaskRunnerFactory(), getMemoryManager(), getPersistenceAdapter());
0: 			regionBroker = new RegionBroker(this,getTaskRunnerFactory(), getMemoryManager(), getPersistenceAdapter());
commit:3601e81
/////////////////////////////////////////////////////////////////////////
0:             BrokerViewMBean view = new BrokerView(managedBroker, getMemoryManager());
commit:9c42236
/////////////////////////////////////////////////////////////////////////
1:             deleteAllMessages();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Delete all messages from the persistent store
0:      * @throws IOException
1:      */
0:     public void deleteAllMessages() throws IOException{
0:         getPersistenceAdapter().deleteAllMessages();
1:     }
commit:8610db3
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = getTransportConnectors().iterator(); iter.hasNext();) {
1:             
0:             TransportConnector connector = (TransportConnector) iter.next();
1:             stopper.stop(connector);
1:         }
1: 
1:         
0:         //remove any VMTransports connected
0:         VMTransportFactory.stopped(getBrokerName());
1: 
commit:e7106d3
/////////////////////////////////////////////////////////////////////////
0:                 connector.setDurableDestinations(getBroker().getDurableDestinations());
commit:d517eeb
/////////////////////////////////////////////////////////////////////////
0:         NetworkConnector connector=new NetworkConnector();
/////////////////////////////////////////////////////////////////////////
0:                 connector.setBrokerName(getBrokerName());
commit:5a429d9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.vm.VMTransportFactory;
/////////////////////////////////////////////////////////////////////////
0:         NetworkConnector connector=new NetworkConnector(this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         //remove any VMTransports connected
0:         VMTransportFactory.stopped(getBrokerName());
commit:4098942
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
0: import org.apache.activemq.broker.ft.MasterConnector;
0: import org.apache.activemq.broker.jmx.FTConnectorView;
0: import org.apache.activemq.broker.jmx.JmsConnectorView;
/////////////////////////////////////////////////////////////////////////
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
1: 
0: import java.io.File;
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:     private boolean shutdownOnMasterFailure = false;
/////////////////////////////////////////////////////////////////////////
0:     private MasterConnector masterConnector;
0:     private String masterConnectorURI;
/////////////////////////////////////////////////////////////////////////
0:         int what = System.identityHashCode(connector);
/////////////////////////////////////////////////////////////////////////
0:     public JmsConnector addJmsConnector(JmsConnector connector) throws Exception{
1:         if (isUseJmx()) {
1:             registerJmsConnectorMBean(connector);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     public void initializeMasterConnector(URI remoteURI) throws Exception {
0:         if (masterConnector != null){
0:             throw new IllegalStateException("Can only be the Slave to one Master");
1:         }
0:         URI localURI = getVmConnectorURI();
0:         TransportConnector connector = null;
0:         if (!transportConnectors.isEmpty()){
0:             connector = (TransportConnector)transportConnectors.get(0);
1:         }
0:         masterConnector = new MasterConnector(this,connector);
0:         masterConnector.setLocalURI(localURI);
0:         masterConnector.setRemoteURI(remoteURI);
1:         
1:         if (isUseJmx()) {
0:             registerFTConnectorMBean(masterConnector);
1:         }
1:     }
1:     
1:     /**
0:      * @return Returns the masterConnectorURI.
1:      */
0:     public String getMasterConnectorURI(){
0:         return masterConnectorURI;
1:     }
1: 
1:     /**
0:      * @param masterConnectorURI The masterConnectorURI to set.
1:      */
0:     public void setMasterConnectorURI(String masterConnectorURI){
0:         this.masterConnectorURI=masterConnectorURI;
1:     }
1: 
1:     /**
0:      * @return true if this Broker is a slave to a Master
1:      */
0:     public boolean isSlave(){
0:         return masterConnector != null && masterConnector.isSlave();
1:     }
1:     
0:     public void masterFailed(){
0:         if (shutdownOnMasterFailure){
0:             log.fatal("The Master has failed ... shutting down");
1:             try {
1:             stop();
0:             }catch(Exception e){
0:                 log.error("Failed to stop for master failure",e);
1:             }
0:         }else {
0:             log.warn("Master Failed - starting all connectors");
0:             try{
0:                 startAllConnectors();
0:             }catch(Exception e){
0:                log.error("Failed to startAllConnectors");
1:             }
1:         }
1:     }
1:     
1:     
/////////////////////////////////////////////////////////////////////////
0:         if (masterConnectorURI!=null){
0:             initializeMasterConnector(new URI(masterConnectorURI));
0:             if (masterConnector!=null){
0:                 masterConnector.start();
1:             }
0:         startAllConnectors();
/////////////////////////////////////////////////////////////////////////
0:         if (masterConnector != null){
0:             masterConnector.stop();
1:         }
1:             
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < networkConnectorURIs.length; i++) {
1:                 String uri = networkConnectorURIs[i];
/////////////////////////////////////////////////////////////////////////
1:         
1:         
/////////////////////////////////////////////////////////////////////////
0:     protected void registerFTConnectorMBean(MasterConnector connector) throws IOException {
0:         MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:         FTConnectorView view = new FTConnectorView(connector);
0:         Hashtable map = new Hashtable();
0:         map.put("Type", "MasterConnector");
0:         map.put("BrokerName", JMXSupport.encodeObjectNamePart(getBrokerName()));
0:         // map.put("ConnectorName",
0:         // JMXSupport.encodeObjectNamePart(connector.()));
1:         try {
0:             ObjectName objectName = new ObjectName("org.apache.activemq", map);
0:             mbeanServer.registerMBean(view, objectName);
0:             registeredMBeanNames.add(objectName);
1:         }
0:         catch (Throwable e) {
0:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:         }
1:     }
1:     
1:     protected void registerJmsConnectorMBean(JmsConnector connector) throws IOException {
0:         MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:         JmsConnectorView view = new JmsConnectorView(connector);
0:         Hashtable map = new Hashtable();
0:         map.put("Type", "JmsConnector");
0:         map.put("BrokerName", JMXSupport.encodeObjectNamePart(getBrokerName()));
0:         // map.put("ConnectorName",
0:         // JMXSupport.encodeObjectNamePart(connector.()));
1:         try {
0:             ObjectName objectName = new ObjectName("org.apache.activemq", map);
0:             mbeanServer.registerMBean(view, objectName);
0:             registeredMBeanNames.add(objectName);
1:         }
0:         catch (Throwable e) {
0:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:             regionBroker = new ManagedRegionBroker(this,mbeanServer, getBrokerObjectName(),
0: 			regionBroker = new RegionBroker(this,getTaskRunnerFactory(), getMemoryManager(), getPersistenceAdapter(),
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Start all transport and network connections, proxies and bridges
1:      * @throws Exception
1:      */
0:     protected void startAllConnectors() throws Exception{
0:         if (!isSlave()){
0:             for (Iterator iter = getTransportConnectors().iterator(); iter.hasNext();) {
0:                 TransportConnector connector = (TransportConnector) iter.next();
0:                 connector.start();
1:             }
1: 
0:             for (Iterator iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:                 NetworkConnector connector = (NetworkConnector) iter.next();
0:                 connector.start();
1:             }
1:             
0:             for (Iterator iter = getProxyConnectors().iterator(); iter.hasNext();) {
0:                 ProxyConnector connector = (ProxyConnector) iter.next();
0:                 connector.start();
1:             }
1:             
0:             for (Iterator iter = jmsConnectors.iterator(); iter.hasNext();) {
0:                 JmsConnector connector = (JmsConnector) iter.next();
0:                 connector.start();
1:             }
1:             }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return Returns the shutdownOnMasterFailure.
1:      */
0:     public boolean isShutdownOnMasterFailure(){
1:         return shutdownOnMasterFailure;
1:     }
1: 
1:     /**
0:      * @param shutdownOnMasterFailure The shutdownOnMasterFailure to set.
1:      */
0:     public void setShutdownOnMasterFailure(boolean shutdownOnMasterFailure){
0:         this.shutdownOnMasterFailure=shutdownOnMasterFailure;
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:6b1ffae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     for (NetworkConnector connector : getNetworkConnectors()) {
1:                         registerNetworkConnectorMBean(connector);
1:                     }
commit:d0fb549
/////////////////////////////////////////////////////////////////////////
1:         boolean waitSucceeded = isStarted();
commit:428a063
/////////////////////////////////////////////////////////////////////////
1:         return started.get() && startedLatch.getCount() == 0;
/////////////////////////////////////////////////////////////////////////
0:         while (!isStarted() && !stopped.get() && !waitSucceeded) {
commit:ed96e2e
/////////////////////////////////////////////////////////////////////////
1:         if (isUseJmx()) {
0:             StatusViewMBean statusView = new StatusView((ManagedRegionBroker)getRegionBroker());
1:             try {
0:                 ObjectName objectName = new ObjectName(getManagementContext().getJmxDomainName() + ":"
0:                         + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + ","
0:                         + "Type=Status");
1: 
1:                 AnnotatedMBean.registerMBean(getManagementContext(), statusView, objectName);
1:             } catch (Throwable e) {
1:                 throw IOExceptionSupport.create("Status MBean could not be registered in JMX: "
1:                         + e.getMessage(), e);
1:             }
1:         }
commit:d301b41
/////////////////////////////////////////////////////////////////////////
1:         connector.getStatistics().setEnabled(enableStatistics);
0:         connector.start();
commit:3c4848b
/////////////////////////////////////////////////////////////////////////
0:             BrokerRegistry.getInstance().bind(getBrokerName(), BrokerService.this);
/////////////////////////////////////////////////////////////////////////
commit:eebe135
/////////////////////////////////////////////////////////////////////////
1:     private boolean startAsync = false;
/////////////////////////////////////////////////////////////////////////
1:             start();
/////////////////////////////////////////////////////////////////////////
1:             startPersistenceAdapter(startAsync);
1:             startBroker(startAsync);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         startedLatch.countDown();
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isStartAsync() {
1:         return startAsync;
1:     }
1: 
1:     public void setStartAsync(boolean startAsync) {
1:         this.startAsync = startAsync;
1:     }
commit:ed58e9a
/////////////////////////////////////////////////////////////////////////
1:     private Throwable startException = null;
/////////////////////////////////////////////////////////////////////////
0:             startAsync();
0:         doStart(false);
1:     }
1: 
0:     public void startAsync() throws Exception {
0:         doStart(true);
1:     }
1: 
0:     public void doStart(boolean async) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             startPersistenceAdapter(async);
0:             startBroker(async);
/////////////////////////////////////////////////////////////////////////
1:     private void startPersistenceAdapter(boolean async) throws Exception {
1:         if (async) {
1:             new Thread("Persistence Adapter Starting Thread") {
0:                 @Override
1:                 public void run() {
1:                     try {
1:                         doStartPersistenceAdapter();
1:                     } catch (Throwable e) {
0:                         startException = e;
1:                     } finally {
0:                         synchronized (persistenceAdapterLock) {
0:                             persistenceAdapterLock.notifyAll();
1:                         }
1:             }.start();
1:         } else {
1:             doStartPersistenceAdapter();
1:         }
1:     private void doStartPersistenceAdapter() throws Exception {
0:         getPersistenceAdapter().setUsageManager(getProducerSystemUsage());
0:         getPersistenceAdapter().setBrokerName(getBrokerName());
0:         LOG.info("Using Persistence Adapter: " + getPersistenceAdapter());
1:         if (deleteAllMessagesOnStartup) {
0:             deleteAllMessages();
1:         }
0:         getPersistenceAdapter().start();
1:     }
1: 
1:     private void startBroker(boolean async) throws Exception {
1:         if (async) {
1:             new Thread("Broker Starting Thread") {
0:                 @Override
1:                 public void run() {
1:                     try {
0:                         synchronized (persistenceAdapterLock) {
0:                             persistenceAdapterLock.wait();
1:                         doStartBroker();
1:                     } catch (Throwable t) {
0:                         startException = t;
1:             }.start();
1:         } else {
1:             doStartBroker();
1:         }
1:     }
1: 
1:     private void doStartBroker() throws Exception {
1: 
0:         if (startException != null) {
1:             return;
1:         }
0:         slave = false;
1:         startDestinations();
1:         addShutdownHook();
0:         getBroker().start();
1:         if (isUseJmx()) {
0:             if (getManagementContext().isCreateConnector() && !getManagementContext().isConnectorStarted()) {
0:                 // try to restart management context
0:                 // typical for slaves that use the same ports as master
0:                 managementContext.stop();
0:                 startManagementContext();
0:             ManagedRegionBroker managedBroker = (ManagedRegionBroker) regionBroker;
1:             managedBroker.setContextBroker(broker);
0:             adminView.setBroker(managedBroker);
1:         }
0:         BrokerRegistry.getInstance().bind(getBrokerName(), BrokerService.this);
0:         // see if there is a MasterBroker service and if so, configure
0:         // it and start it.
0:         for (Service service : services) {
0:             if (service instanceof MasterConnector) {
0:                 configureService(service);
0:                 service.start();
1:             }
1:         }
0:         if (!isSlave() && (masterConnector == null || isShutdownOnMasterFailure() == false)) {
0:             startAllConnectors();
1:         }
0:         if (!stopped.get()) {
0:             if (isUseJmx() && masterConnector != null) {
0:                 registerFTConnectorMBean(masterConnector);
1:             }
1:         }
0:         if (brokerId == null) {
0:             brokerId = broker.getBrokerId();
1:         }
1:         if (ioExceptionHandler == null) {
0:             setIoExceptionHandler(new DefaultIOExceptionHandler());
1:         }
0:         LOG.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ", " + brokerId + ") started");
0:         getBroker().brokerServiceStarted();
0:         checkSystemUsageLimits();
/////////////////////////////////////////////////////////////////////////
0:     public Throwable getStartException() {
commit:7f89b33
/////////////////////////////////////////////////////////////////////////
0:     private final Object persistenceAdapterLock = new Object();
0:     private boolean persistenceAdapterStarted = false;
0:     private Exception startException = null;
1: 
/////////////////////////////////////////////////////////////////////////
0:             startPersistenceAdapter();
0:             startBroker();
/////////////////////////////////////////////////////////////////////////
0:     private void startPersistenceAdapter() throws Exception {
0:         new Thread() {
0:             @Override
0:             public void run() {
0:                 try {
0:                     getPersistenceAdapter().setUsageManager(getProducerSystemUsage());
0:                     getPersistenceAdapter().setBrokerName(getBrokerName());
0:                     LOG.info("Using Persistence Adapter: " + getPersistenceAdapter());
0:                     if (deleteAllMessagesOnStartup) {
0:                         deleteAllMessages();
1:                     }
0:                     getPersistenceAdapter().start();
0:                 } catch (Exception e) {
0:                     startException = e;
1:                 } finally {
0:                     synchronized (persistenceAdapterLock) {
0:                         persistenceAdapterLock.notifyAll();
1:                     }
1:                 }
1:             }
0:         }.start();
1:     }
1: 
0:     private void startBroker() throws Exception {
0:         new Thread() {
0:             @Override
0:             public void run() {
0:                 try {
0:                     synchronized (persistenceAdapterLock) {
0:                         persistenceAdapterLock.wait();
1:                     }
0:                     if (startException != null) {
1:                         return;
1:                     }
0:                     slave = false;
0:                     startDestinations();
0:                     addShutdownHook();
0:                     getBroker().start();
1:                     if (isUseJmx()) {
0:                         if (getManagementContext().isCreateConnector() && !getManagementContext().isConnectorStarted()) {
0:                             // try to restart management context
0:                             // typical for slaves that use the same ports as master
0:                             managementContext.stop();
0:                             startManagementContext();
1:                         }
0:                         ManagedRegionBroker managedBroker = (ManagedRegionBroker) regionBroker;
0:                         managedBroker.setContextBroker(broker);
0:                         adminView.setBroker(managedBroker);
1:                     }
0:                     BrokerRegistry.getInstance().bind(getBrokerName(), BrokerService.this);
0:                     // see if there is a MasterBroker service and if so, configure
0:                     // it and start it.
0:                     for (Service service : services) {
0:                         if (service instanceof MasterConnector) {
0:                             configureService(service);
0:                             service.start();
1:                         }
1:                     }
0:                     if (!isSlave() && (masterConnector == null || isShutdownOnMasterFailure() == false)) {
0:                         startAllConnectors();
1:                     }
0:                     if (!stopped.get()) {
0:                         if (isUseJmx() && masterConnector != null) {
0:                             registerFTConnectorMBean(masterConnector);
1:                         }
1:                     }
0:                     if (brokerId == null) {
0:                         brokerId = broker.getBrokerId();
1:                     }
0:                     if (ioExceptionHandler == null) {
0:                         setIoExceptionHandler(new DefaultIOExceptionHandler());
1:                     }
0:                     LOG.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ", " + brokerId + ") started");
0:                     getBroker().brokerServiceStarted();
0:                     checkSystemUsageLimits();
0:                 } catch (Exception e) {
0:                     startException = e;
1:                 }
1:             }
0:         }.start();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 if (startException != null) {
1:                     return waitSucceeded;
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
0:     public Exception getStartException() {
1:         return startException;
1:     }
commit:cb895f0
/////////////////////////////////////////////////////////////////////////
0:         connector.getStatistics().setEnabled(enableStatistics);
0:         connector.start();
commit:91059de
/////////////////////////////////////////////////////////////////////////
0:                 if (this.defaultSocketURIString == null) {
/////////////////////////////////////////////////////////////////////////
0:                             // find first publishable uri
0:                             if (tc.isUpdateClusterClients() || tc.isRebalanceClusterClients()) {
1:                                 this.defaultSocketURIString = result;
0:                                 break;
1:                             } else {
0:                             // or use the first defined
0:                                 if (this.defaultSocketURIString == null) {
1:                                     this.defaultSocketURIString = result;
1:                                 }
1:                             }
1: 
commit:1462fd2
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
/////////////////////////////////////////////////////////////////////////
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
commit:5f99d5c
/////////////////////////////////////////////////////////////////////////
0:     private int offlineDurableSubscriberTaskSchedule = 300000;
commit:6f70393
/////////////////////////////////////////////////////////////////////////
0:     private int offlineDurableSubscriberTimeout = -1;
0:     private int offlineDurableSubscriberTaskSchedule = 30000;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public int getOfflineDurableSubscriberTimeout() {
1:         return offlineDurableSubscriberTimeout;
1:     }
1: 
0:     public void setOfflineDurableSubscriberTimeout(int offlineDurableSubscriberTimeout) {
1:         this.offlineDurableSubscriberTimeout = offlineDurableSubscriberTimeout;
1:     }
1: 
0:     public int getOfflineDurableSubscriberTaskSchedule() {
1:         return offlineDurableSubscriberTaskSchedule;
1:     }
1: 
0:     public void setOfflineDurableSubscriberTaskSchedule(int offlineDurableSubscriberTaskSchedule) {
1:         this.offlineDurableSubscriberTaskSchedule = offlineDurableSubscriberTaskSchedule;
1:     }
commit:3da9f1c
/////////////////////////////////////////////////////////////////////////
1:         MDC.put("activemq.broker", brokerName);
/////////////////////////////////////////////////////////////////////////
1:             MDC.remove("activemq.broker");
/////////////////////////////////////////////////////////////////////////
1:         MDC.put("activemq.broker", brokerName);
/////////////////////////////////////////////////////////////////////////
1:         MDC.remove("activemq.broker");
commit:f0429be
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.MDC;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         MDC.put("broker", brokerName);
1: 
/////////////////////////////////////////////////////////////////////////
0:         } finally {
0:             MDC.remove("broker");
/////////////////////////////////////////////////////////////////////////
1: 
0:         MDC.put("broker", brokerName);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         MDC.remove("broker");
1: 
/////////////////////////////////////////////////////////////////////////
0:                         final Map context = MDCHelper.getCopyOfContextMap();
0:                                     MDCHelper.setContextMap(context);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(BrokerService.class);
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("The Master has failed ... shutting down");
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Cannot create SystemUsage", e);
commit:2a2dcd5
/////////////////////////////////////////////////////////////////////////
1: 
0:     public ObjectName createDuplexNetworkConnectorObjectName(String transport)
0:             throws MalformedObjectNameException {
0:         return new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName="
0:                 + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=NetworkConnector,"
0:                 + "NetworkConnectorName=duplex" + JMXSupport.encodeObjectNamePart(transport));
1:     }
1: 
commit:df7cb77
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.*;
/////////////////////////////////////////////////////////////////////////
1:         return BrokerSupport.getConnectionContext(getBroker());
commit:996b7a5
/////////////////////////////////////////////////////////////////////////
0:             if (brokerId == null) {
0:                 brokerId = broker.getBrokerId();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (brokerId != null) {
1:             regionBroker.setBrokerId(brokerId);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     }
1:     public void setBrokerId(String brokerId) {
1:         this.brokerId = new BrokerId(brokerId);
1:     }
commit:20118f2
/////////////////////////////////////////////////////////////////////////
1:     protected boolean shouldAutostart() {
1:         return true;
1:     }
1: 
1:     public void autoStart() throws Exception {
1:         if(shouldAutostart()) {
0:             start();
1:         }
1:     }
1: 
commit:784b93d
/////////////////////////////////////////////////////////////////////////
0:         Map<String, String> map = new HashMap<String, String>(URISupport.parseParameters(uri));
/////////////////////////////////////////////////////////////////////////
0:             Map<String, String> map = new HashMap<String, String>(URISupport.parseParameters(uri));
commit:11705e7
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     private BrokerContext brokerContext;
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     public BrokerContext getBrokerContext() {
1:         return brokerContext;
1:     }
1: 
1:     public void setBrokerContext(BrokerContext brokerContext) {
1:         this.brokerContext = brokerContext;
1:     }    
1: 
commit:145c80a
/////////////////////////////////////////////////////////////////////////
1:      * Sets hooks to be executed when broker shut down
1:      * 
0:      * @org.apache.xbean.Property
1:      */
1:     public void setShutdownHooks(List<Runnable> hooks) throws Exception {
1:         for (Runnable hook : hooks) {
1:             addShutdownHook(hook);
1:         }
1:     }
1:     
1:     /**
commit:5280808
/////////////////////////////////////////////////////////////////////////
0:         broker = new TransactionBroker(broker, getPersistenceAdapter().createTransactionStore());
commit:7333847
/////////////////////////////////////////////////////////////////////////
1:     
0:     private boolean slave = true;
/////////////////////////////////////////////////////////////////////////
0:             (masterConnector != null && masterConnector.isStoppedBeforeStart()) ||
0:             (masterConnector == null && slave);
/////////////////////////////////////////////////////////////////////////
0:             slave = false;
/////////////////////////////////////////////////////////////////////////
0:         slave = true;
commit:4969866
/////////////////////////////////////////////////////////////////////////
0:             	if (getManagementContext().isCreateConnector() && !getManagementContext().isConnectorStarted()) {
commit:e8a641c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.DefaultIOExceptionHandler;
0: import org.apache.activemq.util.IOExceptionHandler;
/////////////////////////////////////////////////////////////////////////
1:     private IOExceptionHandler ioExceptionHandler;
1: 
0: 	static {
/////////////////////////////////////////////////////////////////////////
0:             if (ioExceptionHandler == null) {
0:             	setIoExceptionHandler(new DefaultIOExceptionHandler());
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void handleIOException(IOException exception) {
1:         if (ioExceptionHandler != null) {
1:             ioExceptionHandler.handle(exception);
1:          } else {
0:             LOG.info("Ignoring IO exception, " + exception, exception);
1:          }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public void setIoExceptionHandler(IOExceptionHandler ioExceptionHandler) {
0:         ioExceptionHandler.setBrokerService(this);
1:         this.ioExceptionHandler = ioExceptionHandler;
1:     }
1:     
commit:f528aa5
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: import org.apache.activemq.ConfigurationException;
/////////////////////////////////////////////////////////////////////////
0:         	if (systemExitOnShutdown && useShutdownHook) {
0:         		throw new ConfigurationException("'useShutdownHook' property cannot be be used with 'systemExitOnShutdown', please turn it off (useShutdownHook=false)");
1:         	}
/////////////////////////////////////////////////////////////////////////
1:         
0:         if (systemExitOnShutdown) {
0:         	new Thread() {
0:         		public void run() {
0:         			System.exit(systemExitOnShutdownExitCode);
1:         		}
0:         	}.start();
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         
commit:db65c43
/////////////////////////////////////////////////////////////////////////
0:                     	Runtime.getRuntime().halt(systemExitOnShutdownExitCode);
commit:b3873fb
/////////////////////////////////////////////////////////////////////////
1:             if (isUseJmx()) {
0:             	startManagementContext();
1:             }
/////////////////////////////////////////////////////////////////////////
0:             	if (!getManagementContext().isConnectorStarted()) {
0:             		// try to restart management context
0:             		// typical for slaves that use the same ports as master
0:             		managementContext.stop();
0:             		startManagementContext();
1:             	}
0:             	adminView.setBroker(managedBroker);
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected void startManagementContext() throws Exception {
0:         getManagementContext().start();
1:         adminView = new BrokerView(this, null);
0:         ObjectName objectName = getBrokerObjectName();
1:         AnnotatedMBean.registerMBean(getManagementContext(), adminView, objectName);
1:     }
commit:ced6909
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.AnnotatedMBean;
/////////////////////////////////////////////////////////////////////////
0:                 AnnotatedMBean.registerMBean(getManagementContext(), adminView, objectName);
/////////////////////////////////////////////////////////////////////////
1:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
/////////////////////////////////////////////////////////////////////////
1:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
/////////////////////////////////////////////////////////////////////////
1:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
/////////////////////////////////////////////////////////////////////////
1:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
/////////////////////////////////////////////////////////////////////////
0:             AnnotatedMBean.registerMBean(getManagementContext(), view, objectName);
commit:62e1abf
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.selector.SelectorParser;
/////////////////////////////////////////////////////////////////////////
1:     private boolean forceStart = false;
1:     
/////////////////////////////////////////////////////////////////////////
1:     public void start(boolean force) throws Exception {
0:     	forceStart = force;
0:     	start();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:             
1:             if (isUseJmx()) {
0:             	getManagementContext().start();
0:                 ManagedRegionBroker managedBroker = (ManagedRegionBroker)regionBroker;
0:                 managedBroker.setContextBroker(broker);
0:                 adminView = new BrokerView(this, managedBroker);
0:                 MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:                 if (mbeanServer != null) {
0:                     ObjectName objectName = getBrokerObjectName();
0:                     mbeanServer.registerMBean(adminView, objectName);
0:                     registeredMBeanNames.add(objectName);
1:                 }
1:             }
0:             
/////////////////////////////////////////////////////////////////////////
0:             registeredMBeanNames.clear();
/////////////////////////////////////////////////////////////////////////
0:         	Broker old;
0:             
1:         	public void stop() throws Exception {
1:                 old = this.next.getAndSet(new ErrorBroker("Broker has been stopped: " + this) {
0:                     
0:         	
1:         	public void start() throws Exception {
0:         		if (forceStart && old != null) {
0:         			this.next.set(old);
1:         		}
0:         		getNext().start();
1:         	}
0:             
commit:2de531c
/////////////////////////////////////////////////////////////////////////
0:         stopper.stop(persistenceAdapter);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:ec9975c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.openwire.OpenWireFormat;
/////////////////////////////////////////////////////////////////////////
0:     private int storeOpenWireVersion = OpenWireFormat.DEFAULT_VERSION;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public int getStoreOpenWireVersion() {
1:         return storeOpenWireVersion;
1:     }
0: 
1:     public void setStoreOpenWireVersion(int storeOpenWireVersion) {
1:         this.storeOpenWireVersion = storeOpenWireVersion;
1:     }
commit:4a16c1f
/////////////////////////////////////////////////////////////////////////
1:     private boolean restartAllowed = true;
1:     private boolean restartRequested = false;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * @return true if the broker allowed to restart on shutdown.
1:      */
1:     public boolean isRestartAllowed() {
1:         return restartAllowed;
1:     }
0: 
1:     /**
1:      * Sets if the broker allowed to restart on shutdown.
0:      * @return
1:      */
1:     public void setRestartAllowed(boolean restartAllowed) {
1:         this.restartAllowed = restartAllowed;
1:     }
0: 
1:     /**
1:      * A lifecycle manager of the BrokerService should
1:      * inspect this property after a broker shutdown has occurred
1:      * to find out if the broker needs to be re-created and started
1:      * again.
1:      *
1:      * @return true if the broker wants to be restarted after it shuts down.
1:      */
1:     public boolean isRestartRequested() {
1:         return restartRequested;
1:     }
0: 
1:     public void requestRestart() {
1:         this.restartRequested = true;
1:     }
commit:32e63dc
/////////////////////////////////////////////////////////////////////////
0: 
0:             try {
1:                 PersistenceAdapter pa = getPersistenceAdapter();
1:                 if( pa!=null && pa instanceof PListStore) {
1:                     return (PListStore) pa;
1:                 }
1:             } catch (IOException e) {
0:                 throw new RuntimeException(e);
1:             }
0: 
commit:30f531d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         startAllConnectors();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Sets the services associated with this broker.
/////////////////////////////////////////////////////////////////////////
0:         Set<ActiveMQDestination> durableDestinations = getBroker().getDurableDestinations();
0:         List<TransportConnector> al = new ArrayList<TransportConnector>();
1:         for (Iterator<TransportConnector> iter = getTransportConnectors().iterator(); iter.hasNext();) {
1:             TransportConnector connector = iter.next();
1:             connector.setBrokerService(this);
1:             al.add(startTransportConnector(connector));
1:         }
1:         if (al.size() > 0) {
1:             // let's clear the transportConnectors list and replace it with
1:             // the started transportConnector instances
1:             this.transportConnectors.clear();
1:             setTransportConnectors(al);
1:         }
0:         URI uri = getVmConnectorURI();
0:         Map<String, String> map = new HashMap<String, String>(URISupport.parseParameters(uri));
0:         map.put("network", "true");
0:         map.put("async", "false");
0:         uri = URISupport.createURIWithQuery(uri, URISupport.createQueryString(map));
0:         if (!stopped.get()) {
0:             ThreadPoolExecutor networkConnectorStartExecutor = null;
0:             if (isNetworkConnectorStartAsync()) {
0:                 // spin up as many threads as needed
0:                 networkConnectorStartExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE,
0:                         10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
0:                         new ThreadFactory() {
0:                             int count=0;
0:                             public Thread newThread(Runnable runnable) {
0:                                 Thread thread = new Thread(runnable, "NetworkConnector Start Thread-" +(count++));
0:                                 thread.setDaemon(true);
0:                                 return thread;
1:             }
0: 
1:             for (Iterator<NetworkConnector> iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:                 final NetworkConnector connector = iter.next();
0:                 connector.setLocalUri(uri);
0:                 connector.setBrokerName(getBrokerName());
0:                 connector.setDurableDestinations(durableDestinations);
0:                 if (getDefaultSocketURIString() != null) {
0:                     connector.setBrokerURL(getDefaultSocketURIString());
0:                     networkConnectorStartExecutor.execute(new Runnable() {
0:                         public void run() {
0:                             try {
0:                                 LOG.info("Async start of " + connector);
0:                                 connector.start();
0:                             } catch(Exception e) {
0:                                 LOG.error("Async start of network connector: " + connector + " failed", e);
1:                             }
1:                         }
0:                     });
1:                 } else {
0:                     connector.start();
1:             }
0:             if (networkConnectorStartExecutor != null) {
0:                 // executor done when enqueued tasks are complete
0:                 ThreadPoolUtils.shutdown(networkConnectorStartExecutor);
1:             }
1:             for (Iterator<ProxyConnector> iter = getProxyConnectors().iterator(); iter.hasNext();) {
1:                 ProxyConnector connector = iter.next();
0:                 connector.start();
1:             }
1:             for (Iterator<JmsConnector> iter = jmsConnectors.iterator(); iter.hasNext();) {
1:                 JmsConnector connector = iter.next();
0:                 connector.start();
1:             }
0:             for (Service service : services) {
0:                 configureService(service);
0:                 service.start();
commit:58aca86
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if ((in = BrokerService.class.getResourceAsStream("/org/apache/activemq/version.txt")) != null) {
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransportFactorySupport;
/////////////////////////////////////////////////////////////////////////
1:         TransportServer transport = TransportFactorySupport.bind(this, brokerURI);
commit:d5dd937
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.*;
0: import org.apache.activemq.broker.region.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.JournaledStore;
1: import org.apache.activemq.store.PListStore;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.*;
0: import javax.annotation.PostConstruct;
0: import javax.annotation.PreDestroy;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
0: import java.io.*;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.net.UnknownHostException;
0: import java.util.*;
0: import java.util.concurrent.*;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public static final int DEFAULT_MAX_FILE_LENGTH = 1024 * 1024 * 32;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:                 String clazz = "org.apache.activemq.store.kahadb.plist.PListStoreImpl";
1:                 this.tempDataStore = (PListStore) getClass().getClassLoader().loadClass(clazz).newInstance();
/////////////////////////////////////////////////////////////////////////
1:             if (adapter instanceof JournaledStore) {
1:                 maxJournalFileSize = ((JournaledStore) adapter).getJournalMaxFileLength();
/////////////////////////////////////////////////////////////////////////
1:                 PListStore store = usage.getTempUsage().getStore();
1:                 if (store != null && store instanceof JournaledStore) {
1:                     maxJournalFileSize = ((JournaledStore) store).getJournalMaxFileLength();
1:                     maxJournalFileSize = DEFAULT_MAX_FILE_LENGTH;
/////////////////////////////////////////////////////////////////////////
1:             } else {
0:                 try {
1:                     String clazz = "org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter";
1:                     PersistenceAdapter adaptor = (PersistenceAdapter)getClass().getClassLoader().loadClass(clazz).newInstance();
0:                     File dir = new File(getBrokerDataDirectory(),"KahaDB");
0:                     adaptor.setDirectory(dir);
0:                     return adaptor;
0:                 } catch (Throwable e) {
1:                     throw IOExceptionSupport.create(e);
1:                 }
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
0:                     maxJournalFileSize = org.apache.activemq.store.kahadb.disk.journal.Journal.DEFAULT_MAX_FILE_LENGTH;
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:6453ebb
/////////////////////////////////////////////////////////////////////////
1:     private SslContext sslContext;
commit:fd184fb
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("Using Persistence Adapter: " + getPersistenceAdapter());
commit:8573072
/////////////////////////////////////////////////////////////////////////
0:             
0:             getPersistenceAdapter().setUsageManager(getProducerSystemUsage());
0:             getPersistenceAdapter().setBrokerName(getBrokerName());
0:             getPersistenceAdapter().start();
0: 
0:             startDestinations();
0: 
0:             addShutdownHook();
0:             
/////////////////////////////////////////////////////////////////////////
0: //        getPersistenceAdapter().start();
commit:139a220
/////////////////////////////////////////////////////////////////////////
0: import java.security.KeyManagementException;
0: import java.security.SecureRandom;
/////////////////////////////////////////////////////////////////////////
0: import javax.net.ssl.KeyManager;
0: import javax.net.ssl.TrustManager;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.tcp.SslTransportFactory;
/////////////////////////////////////////////////////////////////////////
1:     private int systemExitOnShutdownExitCode;
0:     private SslContext sslContext = new SslContext();
/////////////////////////////////////////////////////////////////////////
0: 
1:     public int getSystemExitOnShutdownExitCode() {
1:         return systemExitOnShutdownExitCode;
1:     }
0: 
1:     public void setSystemExitOnShutdownExitCode(int systemExitOnShutdownExitCode) {
1:         this.systemExitOnShutdownExitCode = systemExitOnShutdownExitCode;
1:     }
0: 
1:     public SslContext getSslContext() {
1:         return sslContext;
1:     }
0: 
1:     public void setSslContext(SslContext sslContext) {
1:         this.sslContext = sslContext;
1:     }
0: 
commit:b4f65ba
/////////////////////////////////////////////////////////////////////////
0:     private List<Runnable> shutdownHooks= new ArrayList<Runnable>();
1:     private boolean systemExitOnShutdown;
0:     private int systemExitOnShutdownExitCode;    
0:     
/////////////////////////////////////////////////////////////////////////
0:             
0:             if( systemExitOnShutdown ) {
0:                 addShutdownHook(new Runnable(){
0:                     public void run() {
0:                         System.exit(systemExitOnShutdownExitCode);
1:                     }
0:                 });
1:             }
0:             
/////////////////////////////////////////////////////////////////////////
0:         synchronized(shutdownHooks) {
1:             for (Runnable hook : shutdownHooks) {
0:                 try {
0:                     hook.run();
0:                 } catch ( Throwable e ) {
0:                     stopper.onException(hook, e);
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void addShutdownHook(Runnable hook) {
0:         synchronized(shutdownHooks) {
1:             shutdownHooks.add(hook);
1:         }
1:     }
0:     
1:     public void removeShutdownHook(Runnable hook) {
0:         synchronized(shutdownHooks) {
1:             shutdownHooks.remove(hook);
1:         }
1:     }
0: 
1:     public boolean isSystemExitOnShutdown() {
1:         return systemExitOnShutdown;
1:     }
0: 
1:     public void setSystemExitOnShutdown(boolean systemExitOnShutdown) {
1:         this.systemExitOnShutdown = systemExitOnShutdown;
1:     }
0:     
commit:5d99c99
/////////////////////////////////////////////////////////////////////////
1:         return addConnector(createTransportConnector(bindAddress));
/////////////////////////////////////////////////////////////////////////
1:         return addConnector(new TransportConnector(transport));
/////////////////////////////////////////////////////////////////////////
1:     protected TransportConnector createTransportConnector(URI brokerURI) throws Exception {
1:         return new TransportConnector(transport);
/////////////////////////////////////////////////////////////////////////
commit:3910056
/////////////////////////////////////////////////////////////////////////
0:     	TransportServer transport = TransportFactory.bind(this, brokerURI);
/////////////////////////////////////////////////////////////////////////
1:                 connector.setBrokerService(this);
commit:1096564
/////////////////////////////////////////////////////////////////////////
1:     protected DestinationFactory destinationFactory;
/////////////////////////////////////////////////////////////////////////
0: //        MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0: //        if (mbeanServer != null) {
0: //
0: //          
0: //        }
/////////////////////////////////////////////////////////////////////////
0:                 Broker old = this.next.getAndSet(new ErrorBroker("Broker has been stopped: " + this) {
1:                 old.stop();
0: //        RegionBroker rBroker = (RegionBroker)regionBroker;
/////////////////////////////////////////////////////////////////////////
1:         return createRegionBroker(destinationInterceptor);
1:     }
0:     
1:     protected Broker createRegionBroker(DestinationInterceptor destinationInterceptor) throws IOException {
0:  		    RegionBroker regionBroker;
/////////////////////////////////////////////////////////////////////////
1:         regionBroker.getDestinationStatistics().setEnabled(enableStatistics);
0: 
1: 		    return regionBroker;
1: 	}
commit:13829ef
/////////////////////////////////////////////////////////////////////////
1:     private Broker regionBroker;
/////////////////////////////////////////////////////////////////////////
1:         regionBroker = createRegionBroker();
/////////////////////////////////////////////////////////////////////////
1:             destinationFactory = new DestinationFactoryImpl(this, getTaskRunnerFactory(), getPersistenceAdapter());
/////////////////////////////////////////////////////////////////////////
0: 
1:     public Broker getRegionBroker() {
0:         return regionBroker;
1:     }
0: 
1:     public void setRegionBroker(Broker regionBroker) {
1:         this.regionBroker = regionBroker;
1:     }
commit:222daf2
/////////////////////////////////////////////////////////////////////////
0:             
1:             if (!isPersistent()) {
1:                 return null;
1:             }
0:             
commit:0a52fe7
/////////////////////////////////////////////////////////////////////////
0:                 tempDataStore = StoreFactory.open(getTmpDataDirectory(), "rw");
commit:2b0024c
/////////////////////////////////////////////////////////////////////////
1:     private SystemUsage systemUsage;
/////////////////////////////////////////////////////////////////////////
1:     public SystemUsage getSystemUsage() {
1:             if (systemUsage == null) {
0:                 systemUsage = new SystemUsage("Main", getPersistenceAdapter(), getTempDataStore());
0:                 systemUsage.getMemoryUsage().setLimit(1024 * 1024 * 64); // Default 64 Meg
0:                 systemUsage.getTempUsage().setLimit(1024 * 1024 * 1024 * 100); // 10 Gb
0:                 systemUsage.getStoreUsage().setLimit(1024 * 1024 * 1024 * 100); // 100 GB
1:             }
1:             return systemUsage;
0:         } catch (IOException e) {
0:             LOG.fatal("Cannot create SystemUsage", e);
1:     public void setSystemUsage(SystemUsage memoryManager) {
1:         this.systemUsage = memoryManager;
/////////////////////////////////////////////////////////////////////////
0:             consumerSystemUsage = new SystemUsage(getSystemUsage(), "Consumer");
/////////////////////////////////////////////////////////////////////////
0:             producerSystemUsage = new SystemUsage(getSystemUsage(), "Producer");
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     public static final String DEFAULT_PORT = "61616";
0:     public static final String LOCAL_HOST_NAME;
0:     public static final String DEFAULT_BROKER_NAME = "localhost";
0: 
/////////////////////////////////////////////////////////////////////////
0:     private List<TransportConnector> transportConnectors = new CopyOnWriteArrayList<TransportConnector>();
0:     private List<NetworkConnector> networkConnectors = new CopyOnWriteArrayList<NetworkConnector>();
0:     private List<ProxyConnector> proxyConnectors = new CopyOnWriteArrayList<ProxyConnector>();
0:     private List<ObjectName> registeredMBeanNames = new CopyOnWriteArrayList<ObjectName>();
0:     private List<JmsConnector> jmsConnectors = new CopyOnWriteArrayList<JmsConnector>();
/////////////////////////////////////////////////////////////////////////
0:         Map<String, String> map = new HashMap<String, String>(URISupport.parseParamters(uri));
/////////////////////////////////////////////////////////////////////////
1:                 List<TransportConnector> transportConnectors = getTransportConnectors();
1:                 for (Iterator<TransportConnector> iter = transportConnectors.iterator(); iter.hasNext();) {
1:                         TransportConnector tc = iter.next();
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator<ObjectName> iter = registeredMBeanNames.iterator(); iter.hasNext();) {
0:                     ObjectName name = iter.next();
/////////////////////////////////////////////////////////////////////////
1:     public List<TransportConnector> getTransportConnectors() {
0:         return new ArrayList<TransportConnector>(transportConnectors);
/////////////////////////////////////////////////////////////////////////
1:     public void setTransportConnectors(List<TransportConnector> transportConnectors) throws Exception {
0:         for (Iterator<TransportConnector> iter = transportConnectors.iterator(); iter.hasNext();) {
1:             TransportConnector connector = iter.next();
1:     public List<NetworkConnector> getNetworkConnectors() {
0:         return new ArrayList<NetworkConnector>(networkConnectors);
1:     public List<ProxyConnector> getProxyConnectors() {
0:         return new ArrayList<ProxyConnector>(proxyConnectors);
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<NetworkConnector> iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:             NetworkConnector connector = iter.next();
0:         for (Iterator<ProxyConnector> iter = getProxyConnectors().iterator(); iter.hasNext();) {
0:             ProxyConnector connector = iter.next();
0:         for (Iterator<JmsConnector> iter = jmsConnectors.iterator(); iter.hasNext();) {
0:             JmsConnector connector = iter.next();
1:         for (Iterator<TransportConnector> iter = getTransportConnectors().iterator(); iter.hasNext();) {
0:             TransportConnector connector = iter.next();
/////////////////////////////////////////////////////////////////////////
0:             List<TransportConnector> al = new ArrayList<TransportConnector>();
0:             for (Iterator<TransportConnector> iter = getTransportConnectors().iterator(); iter.hasNext();) {
0:                 TransportConnector connector = iter.next();
/////////////////////////////////////////////////////////////////////////
0:             Map<String, String> map = new HashMap<String, String>(URISupport.parseParamters(uri));
0:             for (Iterator<NetworkConnector> iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:                 NetworkConnector connector = iter.next();
0:             for (Iterator<ProxyConnector> iter = getProxyConnectors().iterator(); iter.hasNext();) {
0:                 ProxyConnector connector = iter.next();
0:             for (Iterator<JmsConnector> iter = jmsConnectors.iterator(); iter.hasNext();) {
0:                 JmsConnector connector = iter.next();
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IOHelper;
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:  * Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a
1:  * number of transport connectors, network connectors and a bunch of properties
1:  * which can be used to configure the broker as its lazily created.
0:  * 
0:     private static final Log LOG = LogFactory.getLog(BrokerService.class);
/////////////////////////////////////////////////////////////////////////
1:     private boolean populateJMSXUserID;
1:     private boolean useLoggingForShutdownErrors;
1:     private boolean shutdownOnMasterFailure;
/////////////////////////////////////////////////////////////////////////
1:     private JmsConnector[] jmsBridgeConnectors; // these are Jms to Jms bridges
0:     // to other jms messaging
0:     // systems
/////////////////////////////////////////////////////////////////////////
1:     private boolean keepDurableSubsActive = true;
1:     private boolean useVirtualTopics = true;
1:     private boolean useLocalHostBrokerName;
0:     private boolean supportFailOver;
0:     private boolean clustered;
0:     static {
0:         try {
0:             localHostName = java.net.InetAddress.getLocalHost().getHostName();
1:         } catch (UnknownHostException e) {
1:             LOG.error("Failed to resolve localhost");
/////////////////////////////////////////////////////////////////////////
0:      * 
/////////////////////////////////////////////////////////////////////////
0:      * 
/////////////////////////////////////////////////////////////////////////
0:      * 
/////////////////////////////////////////////////////////////////////////
0:      * 
0: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean removeConnector(TransportConnector connector) throws Exception {
1:         if (rc) {
1:             unregisterConnectorMBean(connector);
0: 
0:      * 
0: 
0:      * 
/////////////////////////////////////////////////////////////////////////
0:      * 
1:     public NetworkConnector addNetworkConnector(URI discoveryAddress) throws Exception {
1:         NetworkConnector connector = new DiscoveryNetworkConnector(discoveryAddress);
0:      * 
1:     public ProxyConnector addProxyConnector(URI bindAddress) throws Exception {
1:         ProxyConnector connector = new ProxyConnector();
/////////////////////////////////////////////////////////////////////////
0:         connector.setBrokerService(this);
0:         map.put("async", "false");
0: 
1:         // Set a connection filter so that the connector does not establish loop
1:         // back connections.
0:                         TransportConnector tc = (TransportConnector)iter.next();
1:                         if (location.equals(tc.getConnectUri())) {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1:      * Removes the given network connector without stopping it. The caller
1:      * should call {@link NetworkConnector#stop()} to close the connector
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public JmsConnector addJmsConnector(JmsConnector connector) throws Exception {
/////////////////////////////////////////////////////////////////////////
0: 
1:     public JmsConnector removeJmsConnector(JmsConnector connector) {
1:         if (jmsConnectors.remove(connector)) {
0: 
0:     public String getMasterConnectorURI() {
0:     public void setMasterConnectorURI(String masterConnectorURI) {
0:         this.masterConnectorURI = masterConnectorURI;
0:     public synchronized boolean isSlave() {
0: 
1:     public void masterFailed() {
1:         if (shutdownOnMasterFailure) {
0:             LOG.fatal("The Master has failed ... shutting down");
0:                 stop();
0:             } catch (Exception e) {
1:                 LOG.error("Failed to stop for master failure", e);
0:         } else {
1:             LOG.warn("Master Failed - starting all connectors");
0:             try {
0:             } catch (Exception e) {
0:                 LOG.error("Failed to startAllConnectors");
0: 
0: 
0:         if (!started.compareAndSet(false, true)) {
1:             // as its way too easy to not be completely sure if start() has been
1:             // called or not with the gazillion of different configuration
1:             // mechanisms
0: 
0:             // throw new IllegalStateException("Allready started.");
0: 
0: 
0:             LOG.info("Using Persistence Adapter: " + getPersistenceAdapter());
/////////////////////////////////////////////////////////////////////////
0:              * if(isUseJmx()){ // yes - this is order dependent! // register all
0:              * destination in persistence store including inactive destinations
0:              * as mbeans this.startDestinationsInPersistenceStore(broker); }
1:              */
0: 
0: 
0:             LOG.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ", " + brokerId + ") started");
0:         } catch (Exception e) {
0:             LOG.error("Failed to start ActiveMQ JMS Message Broker. Reason: " + e, e);
1:     public void stop() throws Exception {
0:         if (!started.compareAndSet(true, false)) {
0:         LOG.info("ActiveMQ Message Broker (" + getBrokerName() + ", " + brokerId + ") is shutting down");
0:         ServiceStopper stopper = new ServiceStopper();
1:         if (services != null) {
0:             for (int i = 0; i < services.length; i++) {
0:                 Service service = services[i];
0:         if (broker != null) {
1:         if (tempDataStore != null) {
1:         if (isUseJmx()) {
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             if (mbeanServer != null) {
0:                 for (Iterator iter = registeredMBeanNames.iterator(); iter.hasNext();) {
0:                     ObjectName name = (ObjectName)iter.next();
0:                     try {
0:                     } catch (Exception e) {
0:                         stopper.onException(mbeanServer, e);
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ", " + brokerId + ") stopped");
0:      * A helper method to block the caller thread until the broker has been
1:      * stopped
0:             } catch (InterruptedException e) {
0: 
0:             LOG.info("ActiveMQ " + ActiveMQConnectionMetaData.PROVIDER_VERSION + " JMS Message Broker (" + getBrokerName() + ") is starting");
0:             LOG.info("For help or more information please see: http://activemq.apache.org/");
1:      * Returns the administration view of the broker; used to create and destroy
1:      * resources such as queues and topics. Note this method returns null if JMX
1:      * is disabled.
/////////////////////////////////////////////////////////////////////////
0:      * 
0:      * @param brokerName
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Broker Name: " + brokerName + " contained illegal characters - replaced with " + str);
0: 
/////////////////////////////////////////////////////////////////////////
0:      * 
0:      * @param dataDirectory the directory to store data files
0: 
0:      * 
0:      * @param dataDirectoryFile the directory to store data files
/////////////////////////////////////////////////////////////////////////
1:     public File getTmpDataDirectory() {
/////////////////////////////////////////////////////////////////////////
1:     public void setTmpDataDirectory(File tmpDataDirectory) {
1:         this.tmpDataDirectory = tmpDataDirectory;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public UsageManager getConsumerUsageManager() {
0:         if (consumerUsageManager == null) {
0:             consumerUsageManager = new UsageManager(getMemoryManager(), "Consumer", 0.5f);
0:     public void setConsumerUsageManager(UsageManager consumerUsageManager) {
0:         this.consumerUsageManager = consumerUsageManager;
0:     public UsageManager getProducerUsageManager() {
0:         if (producerUsageManager == null) {
0:             producerUsageManager = new UsageManager(getMemoryManager(), "Producer", 0.45f);
0: 
0:     public void setProducerUsageManager(UsageManager producerUsageManager) {
0:         this.producerUsageManager = producerUsageManager;
1:     }
/////////////////////////////////////////////////////////////////////////
0: 
1:     public TaskRunnerFactory getPersistenceTaskRunnerFactory() {
1:     public void setPersistenceTaskRunnerFactory(TaskRunnerFactory persistenceTaskRunnerFactory) {
1:         this.persistenceTaskRunnerFactory = persistenceTaskRunnerFactory;
0: 
1:     }
1:      * Sets whether or not the Broker's services enable statistics or not.
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public JmsConnector[] getJmsBridgeConnectors() {
1:     public void setJmsBridgeConnectors(JmsConnector[] jmsConnectors) {
1:         this.jmsBridgeConnectors = jmsConnectors;
/////////////////////////////////////////////////////////////////////////
0:      * Sets the services associated with this broker such as a
0:      * {@link MasterConnector}
1:      * Adds a new service so that it will be started as part of the broker
1:      * lifecycle
0:             services = new Service[] {service};
0:         } else {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:      * Allows the support of advisory messages to be disabled for performance
1:      * reasons.
/////////////////////////////////////////////////////////////////////////
0:             TransportConnector connector = (TransportConnector)iter.next();
/////////////////////////////////////////////////////////////////////////
0:             NetworkConnector connector = (NetworkConnector)iter.next();
/////////////////////////////////////////////////////////////////////////
0:             ProxyConnector connector = (ProxyConnector)iter.next();
0: 
/////////////////////////////////////////////////////////////////////////
1:      * Sets a number of broker plugins to install such as for security
1:      * authentication or authorization
0: 
1:      * Sets the policy used to decide if the current connection is authorized to
1:      * consume a given message
/////////////////////////////////////////////////////////////////////////
0:      * 
1:     public void deleteAllMessages() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             } catch (URISyntaxException e) {
0:                 LOG.error("Badly formed URI from " + getBrokerName(), e);
/////////////////////////////////////////////////////////////////////////
1:     public boolean isShutdownOnMasterFailure() {
1:     public void setShutdownOnMasterFailure(boolean shutdownOnMasterFailure) {
1:         this.shutdownOnMasterFailure = shutdownOnMasterFailure;
/////////////////////////////////////////////////////////////////////////
0: 
1:      * Sets whether or not <a
1:      * href="http://activemq.apache.org/virtual-destinations.html">Virtual
1:      * Topics</a> should be supported by default if they have not been
1:      * explicitly configured.
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     public synchronized Store getTempDataStore() {
1:         if (tempDataStore == null) {
0:             boolean result = true;
0:             boolean empty = true;
0:             try {
0:                 File directory = getTmpDataDirectory();
0:                 if (directory.exists() && directory.isDirectory()) {
0:                     File[] files = directory.listFiles();
0:                     if (files != null && files.length > 0) {
0:                         empty = false;
0:                         for (int i = 0; i < files.length; i++) {
0:                             File file = files[i];
0:                             if (!file.isDirectory()) {
0:                                 result &= file.delete();
0:                 if (!empty) {
0:                     String str = result ? "Successfully deleted" : "Failed to delete";
0:                     LOG.info(str + " temporary storage");
0:                 tempDataStore = StoreFactory.open(getTmpDataDirectory().getPath(), "rw");
0:             } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
0:     public void setTempDataStore(Store tempDataStore) {
1:         this.tempDataStore = tempDataStore;
1:     }
0: 
1:     public int getPersistenceThreadPriority() {
1:     public void setPersistenceThreadPriority(int persistenceThreadPriority) {
1:         this.persistenceThreadPriority = persistenceThreadPriority;
0: 
1:     public boolean isUseLocalHostBrokerName() {
1:     public void setUseLocalHostBrokerName(boolean useLocalHostBrokerName) {
1:         this.useLocalHostBrokerName = useLocalHostBrokerName;
1:         if (useLocalHostBrokerName && !started.get() && brokerName == null || brokerName == DEFAULT_BROKER_NAME) {
1:             brokerName = LOCAL_HOST_NAME;
0: 
0:     public boolean isSupportFailOver() {
0:     public void setSupportFailOver(boolean supportFailOver) {
0:         this.supportFailOver = supportFailOver;
1:     }
0: 
0:     public boolean isClustered() {
0:     public void setClustered(boolean clustered) {
0:         this.clustered = clustered;
/////////////////////////////////////////////////////////////////////////
0:      * 
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (jmsBridgeConnectors != null) {
1:             for (int i = 0; i < jmsBridgeConnectors.length; i++) {
0:             } else {
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:             NetworkConnector connector = (NetworkConnector)iter.next();
0:             ProxyConnector connector = (ProxyConnector)iter.next();
0:             JmsConnector connector = (JmsConnector)iter.next();
0:             TransportConnector connector = (TransportConnector)iter.next();
1:     }
1:     protected TransportConnector registerConnectorMBean(TransportConnector connector) throws IOException {
0:                 ConnectorViewMBean view = new ConnectorView(connector);
0:             } catch (Throwable e) {
0: 
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             if (mbeanServer != null) {
0:                 try {
0:                     ObjectName objectName = createConnectorObjectName(connector);
0: 
0:                     if (registeredMBeanNames.remove(objectName)) {
0:                         mbeanServer.unregisterMBean(objectName);
1:                     }
0:                 } catch (Throwable e) {
0:                     throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e.getMessage(), e);
1:                 }
1:             }
1:     private ObjectName createConnectorObjectName(TransportConnector connector) throws MalformedObjectNameException {
0:         return new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=Connector,"
0:                               + "ConnectorName=" + JMXSupport.encodeObjectNamePart(connector.getName()));
1:     }
/////////////////////////////////////////////////////////////////////////
0:             } catch (Throwable e) {
0:         return new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=NetworkConnector,"
0:                               + "NetworkConnectorName=" + JMXSupport.encodeObjectNamePart(connector.getName()));
/////////////////////////////////////////////////////////////////////////
0:                 } catch (Exception e) {
0:                     LOG.error("Network Connector could not be unregistered from JMX: " + e, e);
0: 
0:                 ObjectName objectName = new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + ","
0:                                                        + "Type=ProxyConnector," + "ProxyConnectorName=" + JMXSupport.encodeObjectNamePart(connector.getName()));
0:             } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
0:                 ObjectName objectName = new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + ","
0:                                                        + "Type=MasterConnector");
0:             } catch (Throwable e) {
/////////////////////////////////////////////////////////////////////////
0:                 ObjectName objectName = new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + ","
0:                                                        + "Type=JmsConnector," + "JmsConnectorName=" + JMXSupport.encodeObjectNamePart(connector.getName()));
0:             } catch (Throwable e) {
0: 
0:      * 
/////////////////////////////////////////////////////////////////////////
0:                 setNext(new ErrorBroker("Broker has been stopped: " + this) {
/////////////////////////////////////////////////////////////////////////
0: 
0:         RegionBroker rBroker = (RegionBroker)regionBroker;
0:             ManagedRegionBroker managedBroker = (ManagedRegionBroker)regionBroker;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * 
/////////////////////////////////////////////////////////////////////////
0:         if (this.deleteAllMessagesOnStartup) {
0: 
0:         } else {
0:         RegionBroker regionBroker = null;
0:         if (destinationFactory == null) {
0:             regionBroker = new ManagedRegionBroker(this, mbeanServer, getBrokerObjectName(), getTaskRunnerFactory(), getConsumerUsageManager(), destinationFactory,
0:                                                    destinationInterceptor);
0:         } else {
0:             regionBroker = new RegionBroker(this, getTaskRunnerFactory(), getConsumerUsageManager(), destinationFactory, destinationInterceptor);
0: 
1:         regionBroker.setBrokerName(getBrokerName());
0:         return regionBroker;
1:     }
0:         if (!isUseVirtualTopics()) {
0:         VirtualDestination[] virtualDestinations = {virtualTopic};
0:      * 
/////////////////////////////////////////////////////////////////////////
0:         } else {
/////////////////////////////////////////////////////////////////////////
0:             return new ObjectName(getManagementContext().getJmxDomainName() + ":" + "BrokerName=" + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=Broker");
0:         } catch (Throwable e) {
0:         TransportServer transport = TransportFactory.bind(getBrokerName(), brokerURI);
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("No port specified so defaulting to: " + port);
/////////////////////////////////////////////////////////////////////////
0:             } catch (Exception e) {
0:                 LOG.debug("Caught exception, must be shutting down: " + e);
/////////////////////////////////////////////////////////////////////////
0:         } catch (IOException e) {
0:             } else {
0:         } catch (Exception e) {
1:             LOG.error("Failed to shut down: " + e);
0:         } else {
0: 
0: 
1:      * Returns the broker's administration connection context used for
1:      * configuring the broker at startup
/////////////////////////////////////////////////////////////////////////
0: 
0:      * Factory method to create the new administration connection context
0:      * object. Note this method is here rather than inside a default broker
0:      * implementation to ensure that the broker reference inside it is the outer
0:      * most interceptor
/////////////////////////////////////////////////////////////////////////
0:      * 
0:     protected void startAllConnectors() throws Exception {
0:         if (!isSlave()) {
0: 
0:             ArrayList al = new ArrayList();
0:                 TransportConnector connector = (TransportConnector)iter.next();
0: 
0:             if (al.size() > 0) {
0:                 // let's clear the transportConnectors list and replace it with
0:                 // the started transportConnector instances
0:                 this.transportConnectors.clear();
0:                 setTransportConnectors(al);
0:             map.put("async", "false");
0:                 NetworkConnector connector = (NetworkConnector)iter.next();
0: 
0:                 ProxyConnector connector = (ProxyConnector)iter.next();
0: 
0:                 JmsConnector connector = (JmsConnector)iter.next();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:         }
0: 
0:         connector.getStatistics().setEnabled(enableStatistics);
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:             BrokerServiceAware serviceAware = (BrokerServiceAware)service;
0:             masterConnector = (MasterConnector)service;
0:             supportFailOver = true;
0:      * Starts all destiantions in persistence store. This includes all inactive
0:      * destinations
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQDestination destination = (ActiveMQDestination)iter.next();
1:     }
commit:0945e32
/////////////////////////////////////////////////////////////////////////
0:                 super.stop();
commit:ec6e6a5
/////////////////////////////////////////////////////////////////////////
0:     	connector.setBrokerService(this);
/////////////////////////////////////////////////////////////////////////
0:                 connector.setObjectName(objectName);
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:319966c
/////////////////////////////////////////////////////////////////////////
1:         stopAllConnectors(stopper);
/////////////////////////////////////////////////////////////////////////
0: 	protected void stopAllConnectors(ServiceStopper stopper) {
0: 		
0: 		for (Iterator iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:             NetworkConnector connector = (NetworkConnector) iter.next();
1:             unregisterNetworkConnectorMBean(connector);
1:             stopper.stop(connector);
1:         }
0: 
0:         for (Iterator iter = getProxyConnectors().iterator(); iter.hasNext();) {
0:             ProxyConnector connector = (ProxyConnector) iter.next();
1:             stopper.stop(connector);
1:         }
0:         
0:         for (Iterator iter = jmsConnectors.iterator(); iter.hasNext();) {
0:             JmsConnector connector = (JmsConnector) iter.next();
1:             stopper.stop(connector);
1:         }
0:         
0:         for (Iterator iter = getTransportConnectors().iterator(); iter.hasNext();) {
0:             TransportConnector connector = (TransportConnector) iter.next();
1:             stopper.stop(connector);
1:         }
1: 	}
0: 
commit:bf4d753
/////////////////////////////////////////////////////////////////////////
0:  * Manages the lifecycle of an ActiveMQ Broker. A BrokerService consists of a number of transport
/////////////////////////////////////////////////////////////////////////
0:      * 
0:      * @org.apache.xbean.Property nestedType="org.apache.activemq.broker.TransportConnector"
/////////////////////////////////////////////////////////////////////////
0:      * 
0:      * @org.apache.xbean.Property nestedType="org.apache.activemq.network.NetworkConnector"
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:46d62df
/////////////////////////////////////////////////////////////////////////
0:     private boolean keepDurableSubsActive=true;
commit:d724f9e
/////////////////////////////////////////////////////////////////////////
0:     protected void registerConnectorMBean(TransportConnector connector, ObjectName objectName) throws IOException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0:             
0:             ObjectName objectName = new ObjectName(
0:                     managementContext.getJmxDomainName()+":"+
0:                     "BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0:                     "Type=Connector,"+
0:                     "ConnectorName="+JMXSupport.encodeObjectNamePart(connector.getName())
0:                     );
0:             
0:             connector = connector.asManagedConnector(getManagementContext().getMBeanServer(), objectName);
0:             registerConnectorMBean(connector, objectName);
commit:23d80b3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.BrokerId;
/////////////////////////////////////////////////////////////////////////
1:     private BrokerId brokerId;
0: 
/////////////////////////////////////////////////////////////////////////
0:             brokerId = broker.getBrokerId();
0:             log.info("ActiveMQ JMS Message Broker (" + getBrokerName()+", "+brokerId+") started");
/////////////////////////////////////////////////////////////////////////
0:         log.info("ActiveMQ Message Broker (" + getBrokerName()+", "+brokerId+") is shutting down");
/////////////////////////////////////////////////////////////////////////
0:         log.info("ActiveMQ JMS Message Broker (" + getBrokerName()+", "+brokerId+") stopped");
commit:ea1dad7
/////////////////////////////////////////////////////////////////////////
1:     public boolean isStarted() {
0:         return started.get();
1:     }
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0:         getPersistenceAdapter().setUsageManager(getMemoryManager());
/////////////////////////////////////////////////////////////////////////
commit:449981b
/////////////////////////////////////////////////////////////////////////
0:     private boolean keepDurableSubsActive;
0: 
/////////////////////////////////////////////////////////////////////////
1:         regionBroker.setKeepDurableSubsActive(keepDurableSubsActive);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public boolean isKeepDurableSubsActive() {
1:         return keepDurableSubsActive;
1:     }
0: 
1:     public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {
1:         this.keepDurableSubsActive = keepDurableSubsActive;
1:     }
commit:47f2bb7
/////////////////////////////////////////////////////////////////////////
0:         stopper.stop(persistenceAdapter);
commit:47853d3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.network.ConnectionFilter;
/////////////////////////////////////////////////////////////////////////
0:         
0:         // Set a connection filter so that the connector does not establish loop back connections.
1:         connector.setConnectionFilter(new ConnectionFilter() {
1:             public boolean connectTo(URI location) {
0:                 List transportConnectors = getTransportConnectors();
0:                 for (Iterator iter = transportConnectors.iterator(); iter.hasNext();) {
0:                     try {
0:                         TransportConnector tc = (TransportConnector) iter.next();
0:                         if( location.equals(tc.getConnectUri()) ) {
1:                             return false;
1:                         }
0:                     } catch (Throwable e) {
1:                     }
1:                 }
1:                 return true;
1:             }
0:         });
0:         
commit:b2ad8fa
/////////////////////////////////////////////////////////////////////////
0:             		"Type=NetworkConnector,"+
0:                     "NetworkConnectorName="+JMXSupport.encodeObjectNamePart(connector.getName())
/////////////////////////////////////////////////////////////////////////
0:             		"Type=ProxyConnector,"+
0:                     "ProxyConnectorName="+JMXSupport.encodeObjectNamePart(connector.getName())
/////////////////////////////////////////////////////////////////////////
0:             		"Type=JmsConnector,"+
0:                     "JmsConnectorName="+JMXSupport.encodeObjectNamePart(connector.getName())
commit:07d4e8c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         	ObjectName objectName = new ObjectName(
0:             		managementContext.getJmxDomainName()+":"+
0:             		"BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0:             		"Type=Connector,"+
0:             		"ConnectorName="+JMXSupport.encodeObjectNamePart(connector.getName())
0:             		);
/////////////////////////////////////////////////////////////////////////
0:         	ObjectName objectName = new ObjectName(
0:             		managementContext.getJmxDomainName()+":"+
0:             		"BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0:             		"Type=NetworkConnector"
0:             		);
/////////////////////////////////////////////////////////////////////////
0:         	ObjectName objectName = new ObjectName(
0:             		managementContext.getJmxDomainName()+":"+
0:             		"BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0:             		"Type=ProxyConnector"
0:             		);
/////////////////////////////////////////////////////////////////////////
0:         	ObjectName objectName = new ObjectName(
0:             		managementContext.getJmxDomainName()+":"+
0:             		"BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0:             		"Type=MasterConnector"
0:             		);
/////////////////////////////////////////////////////////////////////////
0:         	ObjectName objectName = new ObjectName(
0:             		managementContext.getJmxDomainName()+":"+
0:             		"BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0:             		"Type=JmsConnector"
0:             		);
/////////////////////////////////////////////////////////////////////////
0:             BrokerViewMBean view = new BrokerView(this, managedBroker);
/////////////////////////////////////////////////////////////////////////
0:             return new ObjectName(
0:             		getManagementContext().getJmxDomainName()+":"+
0:             		"BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0:             		"Type=Broker"
0:             		);
commit:ed5d43b
/////////////////////////////////////////////////////////////////////////
0:             managedBroker.setContextBroker(broker);
commit:523ea5f
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (isUseJmx()) {
0:             connector = connector.asManagedConnector(getManagementContext().getMBeanServer(), getBrokerObjectName());
0:             registerConnectorMBean(connector);
1:         }        
commit:236a1ac
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: 
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:         if (isUseJmx()) {
0:             connector = connector.asManagedConnector(getManagementContext().getMBeanServer(), getBrokerObjectName());
0:             registerConnectorMBean(connector);
1:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:         return new TransportConnector(broker, transport);
commit:6701997
/////////////////////////////////////////////////////////////////////////
0:         
0: 
0:             connector = connector.asManagedConnector(getManagementContext().getMBeanServer(), getBrokerObjectName());
commit:a33f399
/////////////////////////////////////////////////////////////////////////
0:             return new ObjectName(getManagementContext().getJmxDomainName(), map);
commit:f8c268d
/////////////////////////////////////////////////////////////////////////
0:         connector.setBrokerName(getBrokerName());
1:         connector.setTaskRunnerFactory(getTaskRunnerFactory());
/////////////////////////////////////////////////////////////////////////
commit:1a3021b
/////////////////////////////////////////////////////////////////////////
0:             //throw new IllegalStateException("Allready started.");
0:             return;
commit:43d4e98
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Allready started.");
0:             //return;
/////////////////////////////////////////////////////////////////////////
0:         log.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ") stopped: "+broker);
/////////////////////////////////////////////////////////////////////////
0:                 setNext(new ErrorBroker("Broker has been stopped: "+this) {
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker;
0: 
0: import java.io.File;
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: 
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
0: 
1: import org.apache.activemq.ActiveMQConnectionMetaData;
1: import org.apache.activemq.Service;
1: import org.apache.activemq.advisory.AdvisoryBroker;
0: import org.apache.activemq.broker.jmx.BrokerView;
0: import org.apache.activemq.broker.jmx.BrokerViewMBean;
0: import org.apache.activemq.broker.jmx.ConnectorView;
0: import org.apache.activemq.broker.jmx.ConnectorViewMBean;
0: import org.apache.activemq.broker.jmx.ManagedRegionBroker;
0: import org.apache.activemq.broker.jmx.ManagedTransportConnector;
0: import org.apache.activemq.broker.jmx.ManagementContext;
0: import org.apache.activemq.broker.jmx.NetworkConnectorView;
0: import org.apache.activemq.broker.jmx.NetworkConnectorViewMBean;
0: import org.apache.activemq.broker.jmx.ProxyConnectorView;
0: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.network.jms.JmsConnector;
1: import org.apache.activemq.proxy.ProxyConnector;
0: import org.apache.activemq.store.DefaultPersistenceAdapterFactory;
1: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
1: import org.apache.activemq.thread.TaskRunnerFactory;
0: import org.apache.activemq.transport.TransportFactory;
1: import org.apache.activemq.transport.TransportServer;
0: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.activemq.util.JMXSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.util.URISupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
0: 
1: /**
0:  * Represents a running broker service which consists of a number of transport
0:  * connectors, network connectors and a bunch of properties which can be used to
0:  * configure the broker as its lazily created.
0:  *
0:  * @version $Revision: 1.1 $
1:  */
0: public class BrokerService implements Service {
0:     public static final String DEFAULT_PORT = "61616";
0: 
0:     private static final Log log = LogFactory.getLog(BrokerService.class);
0: 
0:     private boolean useJmx = false;
1:     private boolean persistent = true;
0:     private boolean populateJMSXUserID = false;
1:     private boolean useShutdownHook = true;
0:     private boolean useLoggingForShutdownErrors = false;
0:     private String brokerName = "localhost";
0:     private File dataDirectory;
1:     private Broker broker;
1:     private ManagementContext managementContext;
1:     private ObjectName brokerObjectName;
1:     private TaskRunnerFactory taskRunnerFactory;
0:     private UsageManager memoryManager;
1:     private PersistenceAdapter persistenceAdapter;
0:     private DefaultPersistenceAdapterFactory persistenceFactory;
0:     private List transportConnectors = new CopyOnWriteArrayList();
0:     private List networkConnectors = new CopyOnWriteArrayList();
0:     private List proxyConnectors = new CopyOnWriteArrayList();
0:     private List registeredMBeanNames = new CopyOnWriteArrayList();
0:     private List jmsConnectors = new CopyOnWriteArrayList();
0:     private Thread shutdownHook;
1:     private String[] transportConnectorURIs;
1:     private String[] networkConnectorURIs;
0:     private String[] proxyConnectorURIs;
0:     private JmsConnector[] jmsBridgeConnectors; //these are Jms to Jms bridges to other jms messaging systems
1:     private boolean deleteAllMessagesOnStartup;
1:     private URI vmConnectorURI;
1:     private PolicyMap destinationPolicy;
0:     private AtomicBoolean started = new AtomicBoolean(false);
0: 
1:     /**
1:      * Adds a new transport connector for the given bind address
0:      *
1:      * @return the newly created and added transport connector
1:      * @throws Exception
1:      */
1:     public TransportConnector addConnector(String bindAddress) throws Exception {
1:         return addConnector(new URI(bindAddress));
1:     }
0: 
1:     /**
1:      * Adds a new transport connector for the given bind address
0:      *
1:      * @return the newly created and added transport connector
1:      * @throws Exception
1:      */
1:     public TransportConnector addConnector(URI bindAddress) throws Exception {
0:         return addConnector(createTransportConnector(getBroker(), bindAddress));
1:     }
0: 
1:     /**
1:      * Adds a new transport connector for the given TransportServer transport
0:      *
1:      * @return the newly created and added transport connector
1:      * @throws Exception
1:      */
1:     public TransportConnector addConnector(TransportServer transport) throws Exception {
0:         return addConnector(new TransportConnector(getBroker(), transport));
1:     }
0: 
1:     /**
1:      * Adds a new transport connector
0:      *
1:      * @return the transport connector
1:      * @throws Exception
1:      */
1:     public TransportConnector addConnector(TransportConnector connector) throws Exception {
0:         if (isUseJmx()) {
0:             connector = connector.asManagedConnector(getManagementContext().getMBeanServer(), getBrokerObjectName());
1:         }
0:         connector.setBroker(getBroker());
1:         transportConnectors.add(connector);
0:         if (isUseJmx()) {
0:             registerConnectorMBean(connector);
1:         }
1:         return connector;
1:     }
0: 
1:     /**
1:      * Adds a new network connector using the given discovery address
0:      *
1:      * @return the newly created and added network connector
1:      * @throws Exception
1:      */
1:     public NetworkConnector addNetworkConnector(String discoveryAddress) throws Exception {
1:         return addNetworkConnector(new URI(discoveryAddress));
1:     }
0:     
1:     /**
1:      * Adds a new proxy connector using the given bind address
0:      *
1:      * @return the newly created and added network connector
1:      * @throws Exception
1:      */
1:     public ProxyConnector addProxyConnector(String bindAddress) throws Exception {
1:         return addProxyConnector(new URI(bindAddress));
1:     }
0: 
1:     /**
1:      * Adds a new network connector using the given discovery address
0:      *
1:      * @return the newly created and added network connector
1:      * @throws Exception
1:      */
0:     public NetworkConnector addNetworkConnector(URI discoveryAddress) throws Exception{
0:         NetworkConnector connector=new NetworkConnector();
0:         // add the broker name to the parameters if not set
0:         connector.setUri(discoveryAddress);
1:         return addNetworkConnector(connector);
1:     }
0: 
1:     /**
1:      * Adds a new proxy connector using the given bind address
0:      *
1:      * @return the newly created and added network connector
1:      * @throws Exception
1:      */
0:     public ProxyConnector addProxyConnector(URI bindAddress) throws Exception{
0:         ProxyConnector connector=new ProxyConnector();
1:         connector.setBind(bindAddress);
1:         connector.setRemote(new URI("fanout:multicast://default"));
1:         return addProxyConnector(connector);
1:     }
0: 
1:     /**
1:      * Adds a new network connector to connect this broker to a federated
1:      * network
1:      */
1:     public NetworkConnector addNetworkConnector(NetworkConnector connector) throws Exception {
0:         URI uri = getVmConnectorURI();
0:         HashMap map = new HashMap(URISupport.parseParamters(uri));
0:         map.put("network", "true");
0:         uri = URISupport.createURIWithQuery(uri, URISupport.createQueryString(map));
0:         connector.setLocalUri(uri);
0:         connector.setBrokerName(getBrokerName());
1:         networkConnectors.add(connector);
0:         if (isUseJmx()) {
0:             registerNetworkConnectorMBean(connector);
1:         }
1:         return connector;
1:     }
0:     
1:     public ProxyConnector addProxyConnector(ProxyConnector connector) throws Exception {
0:         URI uri = getVmConnectorURI();
0:         connector.setLocalUri(uri);
1:         proxyConnectors.add(connector);
0:         if (isUseJmx()) {
1:             registerProxyConnectorMBean(connector);
1:         }
1:         return connector;
1:     }
0:     
0:     public JmsConnector addJmsConnector(JmsConnector connector){
0:         connector.setBrokerService(this);
1:         jmsConnectors.add(connector);
1:         return connector;
1:     }
0:     
0:     public JmsConnector removeJmsConnector(JmsConnector connector){
0:         if (jmsConnectors.remove(connector)){
1:             return connector;
1:         }
0:         return null;
1:     }
0:     
1:     // Service interface
1:     // -------------------------------------------------------------------------
0:     public void start() throws Exception {
0:         if (! started.compareAndSet(false, true)) {
1:             // lets just ignore redundant start() calls
0:             // as its way too easy to not be completely sure if start() has been 
0:             // called or not with the gazillion of different configuration mechanisms
0:             
0:             //throw new IllegalStateException("Allready started.");
0:             return;
1:         }
0:         
1:         processHelperProperties();
0: 
0:         BrokerRegistry.getInstance().bind(getBrokerName(), this);
0: 
0:         addShutdownHook();
0:         if (deleteAllMessagesOnStartup) {
0:             getPersistenceAdapter().deleteAllMessages();
1:         }
0: 
0:         if (isUseJmx()) {
0:             getManagementContext().start();
1:         }
0: 
0:         getBroker().start();
0: 
0:         for (Iterator iter = getTransportConnectors().iterator(); iter.hasNext();) {
0:             TransportConnector connector = (TransportConnector) iter.next();
0:             connector.start();
1:         }
0: 
0:         for (Iterator iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:             NetworkConnector connector = (NetworkConnector) iter.next();
0:             connector.start();
1:         }
0:         
0:         for (Iterator iter = getProxyConnectors().iterator(); iter.hasNext();) {
0:             ProxyConnector connector = (ProxyConnector) iter.next();
0:             connector.start();
1:         }
0:         
0:         for (Iterator iter = jmsConnectors.iterator(); iter.hasNext();) {
0:             JmsConnector connector = (JmsConnector) iter.next();
0:             connector.start();
1:         }
0: 
0:         log.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ") started");
1:     }
0: 
0:     public void stop() throws Exception {
0:         if (! started.compareAndSet(true, false)) {
0:             return;
1:         }
0:         log.info("ActiveMQ Message Broker (" + getBrokerName() + ") is shutting down");
0:         BrokerRegistry.getInstance().unbind(getBrokerName());
0: 
1:         removeShutdownHook();
0: 
0:         ServiceStopper stopper = new ServiceStopper();
0: 
0:         for (Iterator iter = getTransportConnectors().iterator(); iter.hasNext();) {
0:             TransportConnector connector = (TransportConnector) iter.next();
0:             stopper.stop(connector);
1:         }
0: 
0:         for (Iterator iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:             NetworkConnector connector = (NetworkConnector) iter.next();
0:             stopper.stop(connector);
1:         }
0: 
0:         for (Iterator iter = getProxyConnectors().iterator(); iter.hasNext();) {
0:             ProxyConnector connector = (ProxyConnector) iter.next();
0:             stopper.stop(connector);
1:         }
0:         
0:         for (Iterator iter = jmsConnectors.iterator(); iter.hasNext();) {
0:             JmsConnector connector = (JmsConnector) iter.next();
0:             stopper.stop(connector);
1:         }
0: 
0: 
0:         stopper.stop(getPersistenceAdapter());
0: 
0:         if (broker != null) {
1:             stopper.stop(broker);
1:         }
0: 
0:         if (isUseJmx()) {
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             for (Iterator iter = registeredMBeanNames.iterator(); iter.hasNext();) {
0:                 ObjectName name = (ObjectName) iter.next();
0:                 try {
0:                     mbeanServer.unregisterMBean(name);
1:                 }
0:                 catch (Exception e) {
0:                     stopper.onException(mbeanServer, e);
1:                 }
1:             }
0:             stopper.stop(getManagementContext());
1:         }
0: 
0:         log.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ") stopped");
0: 
1:         stopper.throwFirstException();
1:     }
0: 
1:     // Properties
1:     // -------------------------------------------------------------------------
1:     public Broker getBroker() throws Exception {
1:         if (broker == null) {
0:             log.info("ActiveMQ " + ActiveMQConnectionMetaData.PROVIDER_VERSION + " JMS Message Broker ("
0:                     + getBrokerName() + ") is starting");
0:             log.info("For help or more information please see: http://www.logicblaze.com");
1:             broker = createBroker();
1:         }
1:         return broker;
1:     }
0: 
1:     public String getBrokerName() {
1:         return brokerName;
1:     }
0: 
1:     /**
1:      * Sets the name of this broker; which must be unique in the network
1:      */
1:     public void setBrokerName(String brokerName) {
0:         this.brokerName = brokerName;
1:     }
0: 
0:     public DefaultPersistenceAdapterFactory getPersistenceFactory() {
0:         if (persistenceFactory == null) {
0:             persistenceFactory = createPersistenceFactory();
1:         }
1:         return persistenceFactory;
1:     }
0: 
0:     public File getDataDirectory() {
0:         if (dataDirectory == null) {
0:             dataDirectory = new File(new File("activemq-data"), getBrokerName()
0:                     .replaceAll("[^a-zA-Z0-9\\.\\_\\-]", "_"));
1:         }
0:         return dataDirectory;
1:     }
0: 
1:     /**
1:      * Sets the directory in which the data files will be stored by default for
1:      * the JDBC and Journal persistence adaptors.
0:      *
0:      * @param dataDirectory
0:      *            the directory to store data files
1:      */
0:     public void setDataDirectory(File dataDirectory) {
0:         this.dataDirectory = dataDirectory;
1:     }
0: 
0:     public void setPersistenceFactory(DefaultPersistenceAdapterFactory persistenceFactory) {
1:         this.persistenceFactory = persistenceFactory;
1:     }
0: 
1:     public boolean isPersistent() {
1:         return persistent;
1:     }
0: 
1:     /**
1:      * Sets whether or not persistence is enabled or disabled.
1:      */
1:     public void setPersistent(boolean persistent) {
1:         this.persistent = persistent;
1:     }
0: 
1:     public boolean isPopulateJMSXUserID() {
1:         return populateJMSXUserID;
1:     }
0: 
1:     /**
1:      * Sets whether or not the broker should populate the JMSXUserID header.
1:      */
1:     public void setPopulateJMSXUserID(boolean populateJMSXUserID) {
1:         this.populateJMSXUserID = populateJMSXUserID;
1:     }
0: 
0:     public UsageManager getMemoryManager() {
0:         if (memoryManager == null) {
0:             memoryManager = new UsageManager();
0:             memoryManager.setLimit(1024 * 1024 * 20); // Default to 20 Meg
0:             // limit
1:         }
0:         return memoryManager;
1:     }
0: 
0:     public void setMemoryManager(UsageManager memoryManager) {
0:         this.memoryManager = memoryManager;
1:     }
0: 
0:     public PersistenceAdapter getPersistenceAdapter() throws IOException {
0:         if (persistenceAdapter == null) {
1:             persistenceAdapter = createPersistenceAdapter();
1:         }
1:         return persistenceAdapter;
1:     }
0: 
1:     /**
1:      * Sets the persistence adaptor implementation to use for this broker
1:      */
0:     public void setPersistenceAdapter(PersistenceAdapter persistenceAdapter) {
1:         this.persistenceAdapter = persistenceAdapter;
1:     }
0: 
1:     public TaskRunnerFactory getTaskRunnerFactory() {
0:         if (taskRunnerFactory == null) {
0:             taskRunnerFactory = new TaskRunnerFactory();
1:         }
0:         return taskRunnerFactory;
1:     }
0: 
1:     public void setTaskRunnerFactory(TaskRunnerFactory taskRunnerFactory) {
1:         this.taskRunnerFactory = taskRunnerFactory;
1:     }
0: 
1:     public boolean isUseJmx() {
1:         return useJmx;
1:     }
0: 
1:     /**
1:      * Sets whether or not the Broker's services should be exposed into JMX or
1:      * not.
1:      */
1:     public void setUseJmx(boolean useJmx) {
1:         this.useJmx = useJmx;
1:     }
0: 
0:     public ObjectName getBrokerObjectName() throws IOException {
1:         if (brokerObjectName == null) {
1:             brokerObjectName = createBrokerObjectName();
1:         }
1:         return brokerObjectName;
1:     }
0: 
1:     /**
1:      * Sets the JMX ObjectName for this broker
1:      */
1:     public void setBrokerObjectName(ObjectName brokerObjectName) {
1:         this.brokerObjectName = brokerObjectName;
1:     }
0: 
1:     public ManagementContext getManagementContext() {
1:         if (managementContext == null) {
1:             managementContext = new ManagementContext();
1:         }
1:         return managementContext;
1:     }
0: 
1:     public void setManagementContext(ManagementContext managementContext) {
1:         this.managementContext = managementContext;
1:     }
0: 
1:     public String[] getNetworkConnectorURIs() {
1:         return networkConnectorURIs;
1:     }
0: 
1:     public void setNetworkConnectorURIs(String[] networkConnectorURIs) {
1:         this.networkConnectorURIs = networkConnectorURIs;
1:     }
0: 
1:     public String[] getTransportConnectorURIs() {
1:         return transportConnectorURIs;
1:     }
0: 
1:     public void setTransportConnectorURIs(String[] transportConnectorURIs) {
1:         this.transportConnectorURIs = transportConnectorURIs;
1:     }
0: 
1:     /**
1:      * @return Returns the jmsBridgeConnectors.
1:      */
0:     public JmsConnector[] getJmsBridgeConnectors(){
1:         return jmsBridgeConnectors;
1:     }
0: 
1:     /**
0:      * @param jmsBridgeConnectors The jmsBridgeConnectors to set.
1:      */
0:     public void setJmsBridgeConnectors(JmsConnector[] jmsConnectors){
0:         this.jmsBridgeConnectors=jmsConnectors;
1:     }
0: 
1:     public boolean isUseLoggingForShutdownErrors() {
1:         return useLoggingForShutdownErrors;
1:     }
0: 
1:     /**
1:      * Sets whether or not we should use commons-logging when reporting errors
1:      * when shutting down the broker
1:      */
1:     public void setUseLoggingForShutdownErrors(boolean useLoggingForShutdownErrors) {
1:         this.useLoggingForShutdownErrors = useLoggingForShutdownErrors;
1:     }
0: 
1:     public boolean isUseShutdownHook() {
1:         return useShutdownHook;
1:     }
0: 
1:     /**
1:      * Sets whether or not we should use a shutdown handler to close down the
1:      * broker cleanly if the JVM is terminated. It is recommended you leave this
1:      * enabled.
1:      */
1:     public void setUseShutdownHook(boolean useShutdownHook) {
1:         this.useShutdownHook = useShutdownHook;
1:     }
0: 
0:     public List getTransportConnectors() {
0:         return new ArrayList(transportConnectors);
1:     }
0: 
1:     /**
1:      * Sets the transport connectors which this broker will listen on for new
1:      * clients
1:      */
0:     public void setTransportConnectors(List transportConnectors) throws Exception {
0:         for (Iterator iter = transportConnectors.iterator(); iter.hasNext();) {
0:             TransportConnector connector = (TransportConnector) iter.next();
0:             connector.setBroker(getBroker());
0:             connector.setBrokerName(getBrokerName());
1:             addConnector(connector);
1:         }
1:     }
0: 
0:     public List getNetworkConnectors() {
0:         return new ArrayList(networkConnectors);
1:     }
0: 
0:     public List getProxyConnectors() {
0:         return new ArrayList(proxyConnectors);
1:     }
0: 
1:     /**
1:      * Sets the network connectors which this broker will use to connect to
1:      * other brokers in a federated network
1:      */
0:     public void setNetworkConnectors(List networkConnectors) throws Exception {
0:         for (Iterator iter = networkConnectors.iterator(); iter.hasNext();) {
0:             NetworkConnector connector = (NetworkConnector) iter.next();
0:             addNetworkConnector(connector);
1:         }
1:     }
0: 
1:     /**
1:      * Sets the network connectors which this broker will use to connect to
1:      * other brokers in a federated network
1:      */
0:     public void setProxyConnectors(List proxyConnectors) throws Exception {
0:         for (Iterator iter = proxyConnectors.iterator(); iter.hasNext();) {
0:             ProxyConnector connector = (ProxyConnector) iter.next();
0:             addProxyConnector(connector);
1:         }
1:     }
0:     
1:     public PolicyMap getDestinationPolicy() {
1:         return destinationPolicy;
1:     }
0: 
1:     /**
1:      * Sets the destination specific policies available either for exact
1:      * destinations or for wildcard areas of destinations.
1:      */
1:     public void setDestinationPolicy(PolicyMap policyMap) {
1:         this.destinationPolicy = policyMap;
1:     }
0: 
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
1:     /**
1:      * Handles any lazy-creation helper properties which are added to make
1:      * things easier to configure inside environments such as Spring
0:      *
1:      * @throws Exception
1:      */
1:     protected void processHelperProperties() throws Exception {
1:         if (transportConnectorURIs != null) {
1:             for (int i = 0; i < transportConnectorURIs.length; i++) {
1:                 String uri = transportConnectorURIs[i];
1:                 addConnector(uri);
1:             }
1:         }
1:         if (networkConnectorURIs != null) {
1:             for (int i = 0; i < transportConnectorURIs.length; i++) {
1:                 String uri = transportConnectorURIs[i];
1:                 addNetworkConnector(uri);
1:             }
1:         }
0:         if (proxyConnectorURIs != null) {
0:             for (int i = 0; i < proxyConnectorURIs.length; i++) {
0:                 String uri = proxyConnectorURIs[i];
0:                 addProxyConnector(uri);
1:             }
1:         }
0:         if (jmsBridgeConnectors != null){
0:             for (int i = 0; i < jmsBridgeConnectors.length; i++){
1:                 addJmsConnector(jmsBridgeConnectors[i]);
1:             }
1:         }
1:     }
0: 
0:     protected void registerConnectorMBean(TransportConnector connector) throws IOException, URISyntaxException {
0:         MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:         ConnectorViewMBean view = new ConnectorView(connector);
0:         Hashtable map = new Hashtable();
0:         map.put("Type", "Connector");
0:         map.put("BrokerName", JMXSupport.encodeObjectNamePart(getBrokerName()));
0:         map.put("ConnectorName", JMXSupport.encodeObjectNamePart(connector.getName()));
0:         try {
0:             ObjectName objectName = new ObjectName("org.apache.activemq", map);
0:             mbeanServer.registerMBean(view, objectName);
0:             registeredMBeanNames.add(objectName);
1:         }
0:         catch (Throwable e) {
0:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:         }
1:     }
0: 
0:     protected void registerNetworkConnectorMBean(NetworkConnector connector) throws IOException {
0:         MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:         NetworkConnectorViewMBean view = new NetworkConnectorView(connector);
0:         Hashtable map = new Hashtable();
0:         map.put("Type", "NetworkConnector");
0:         map.put("BrokerName", JMXSupport.encodeObjectNamePart(getBrokerName()));
0:         // map.put("ConnectorName",
0:         // JMXSupport.encodeObjectNamePart(connector.()));
0:         try {
0:             ObjectName objectName = new ObjectName("org.apache.activemq", map);
0:             mbeanServer.registerMBean(view, objectName);
0:             registeredMBeanNames.add(objectName);
1:         }
0:         catch (Throwable e) {
0:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:         }
1:     }
0: 
1:     protected void registerProxyConnectorMBean(ProxyConnector connector) throws IOException {
0:         MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:         ProxyConnectorView view = new ProxyConnectorView(connector);
0:         Hashtable map = new Hashtable();
0:         map.put("Type", "ProxyConnector");
0:         map.put("BrokerName", JMXSupport.encodeObjectNamePart(getBrokerName()));
0:         // map.put("ConnectorName",
0:         // JMXSupport.encodeObjectNamePart(connector.()));
0:         try {
0:             ObjectName objectName = new ObjectName("org.apache.activemq", map);
0:             mbeanServer.registerMBean(view, objectName);
0:             registeredMBeanNames.add(objectName);
1:         }
0:         catch (Throwable e) {
0:             throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
1:         }
1:     }
0:     
1:     /**
1:      * Factory method to create a new broker
0:      *
1:      * @throws Exception
0:      *
0:      * @throws
0:      * @throws
1:      */
1:     protected Broker createBroker() throws Exception {
0:         Broker regionBroker = createRegionBroker();
1:         Broker broker = addInterceptors(regionBroker);
0: 
1:         // Add a filter that will stop access to the broker once stopped
1:         broker = new MutableBrokerFilter(broker) {
0:             public void stop() throws Exception {
0:                 super.stop();
0:                 setNext(new ErrorBroker("Broker has been stopped.") {
1:                     // Just ignore additional stop actions.
0:                     public void stop() throws Exception {
1:                     }
0:                 });
1:             }
1:         };
0: 
0:         if (isUseJmx()) {
0:             ManagedRegionBroker managedBroker = (ManagedRegionBroker) regionBroker;
0:             BrokerViewMBean view = new BrokerView(broker, managedBroker.getDestinationStatistics(), getMemoryManager());
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             ObjectName objectName = getBrokerObjectName();
0:             mbeanServer.registerMBean(view, objectName);
0:             registeredMBeanNames.add(objectName);
1:         }
0: 
1:         return broker;
0: 
1:     }
0: 
1:     /**
1:      * Factory method to create the core region broker onto which interceptors
1:      * are added
0:      *
1:      * @throws Exception
1:      */
1:     protected Broker createRegionBroker() throws Exception {
0:         // we must start the persistence adaptor before we can create the region
0:         // broker
0:         getPersistenceAdapter().start();
0: 		RegionBroker regionBroker = null;
0:         if (isUseJmx()) {
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             regionBroker = new ManagedRegionBroker(mbeanServer, getBrokerObjectName(),
0:                     getTaskRunnerFactory(), getMemoryManager(), getPersistenceAdapter(), getDestinationPolicy());
1:         }
0:         else {
0: 			regionBroker = new RegionBroker(getTaskRunnerFactory(), getMemoryManager(), getPersistenceAdapter(),
0:                     getDestinationPolicy());
1:         }
0: 		regionBroker.setBrokerName(getBrokerName());
0: 		return regionBroker;
1: 	}
0: 
1:     /**
1:      * Strategy method to add interceptors to the broker
0:      *
0:      * @throws IOException
1:      */
0:     protected Broker addInterceptors(Broker broker) throws IOException {
0:         broker = new TransactionBroker(broker, getPersistenceAdapter().createTransactionStore());
1:         broker = new AdvisoryBroker(broker);
1:         broker = new CompositeDestinationBroker(broker);
1:         if (isPopulateJMSXUserID()) {
0:             broker = new UserIDBroker(broker);
1:         }
1:         return broker;
1:     }
0: 
1:     protected PersistenceAdapter createPersistenceAdapter() throws IOException {
1:         if (isPersistent()) {
0:             return getPersistenceFactory().createPersistenceAdapter();
1:         }
0:         else {
1:             return new MemoryPersistenceAdapter();
1:         }
1:     }
0: 
0:     protected DefaultPersistenceAdapterFactory createPersistenceFactory() {
0:         DefaultPersistenceAdapterFactory factory = new DefaultPersistenceAdapterFactory();
0:         factory.setMemManager(getMemoryManager());
0:         factory.setDataDirectory(getDataDirectory());
0:         factory.setTaskRunnerFactory(getTaskRunnerFactory());
0:         return factory;
1:     }
0: 
0:     protected ObjectName createBrokerObjectName() throws IOException {
0:         try {
0:             Hashtable map = new Hashtable();
0:             map.put("Type", "Broker");
0:             map.put("BrokerName", JMXSupport.encodeObjectNamePart(getBrokerName()));
0:             return new ObjectName("org.apache.activemq", map);
1:         }
0:         catch (Throwable e) {
0:             throw IOExceptionSupport.create("Invalid JMX broker name: " + brokerName, e);
1:         }
1:     }
0: 
0:     protected TransportConnector createTransportConnector(Broker broker, URI brokerURI) throws Exception {
0: 
0:         TransportServer transport = TransportFactory.bind(getBrokerName(),brokerURI);
0:         if (isUseJmx()) {
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             return new ManagedTransportConnector(mbeanServer, getBrokerObjectName(), broker, transport);
1:         }
0:         else {
0:             return new TransportConnector(broker, transport);
1:         }
1:     }
0: 
1:     /**
1:      * Extracts the port from the options
1:      */
0:     protected Object getPort(Map options) {
1:         Object port = options.get("port");
1:         if (port == null) {
1:             port = DEFAULT_PORT;
0:             log.warn("No port specified so defaulting to: " + port);
1:         }
1:         return port;
1:     }
0: 
1:     protected void addShutdownHook() {
1:         if (useShutdownHook) {
1:             shutdownHook = new Thread("ActiveMQ ShutdownHook") {
0:                 public void run() {
1:                     containerShutdown();
1:                 }
1:             };
1:             Runtime.getRuntime().addShutdownHook(shutdownHook);
1:         }
1:     }
0: 
1:     protected void removeShutdownHook() {
1:         if (shutdownHook != null) {
0:             try {
1:                 Runtime.getRuntime().removeShutdownHook(shutdownHook);
1:             }
0:             catch (Exception e) {
0:                 log.debug("Caught exception, must be shutting down: " + e);
1:             }
1:         }
1:     }
0: 
1:     /**
1:      * Causes a clean shutdown of the container when the VM is being shut down
1:      */
1:     protected void containerShutdown() {
0:         try {
0:             stop();
1:         }
0:         catch (IOException e) {
1:             Throwable linkedException = e.getCause();
1:             if (linkedException != null) {
1:                 logError("Failed to shut down: " + e + ". Reason: " + linkedException, linkedException);
1:             }
0:             else {
1:                 logError("Failed to shut down: " + e, e);
1:             }
1:             if (!useLoggingForShutdownErrors) {
1:                 e.printStackTrace(System.err);
1:             }
1:         }
0:         catch (Exception e) {
1:             logError("Failed to shut down: " + e, e);
1:         }
1:     }
0: 
1:     protected void logError(String message, Throwable e) {
1:         if (useLoggingForShutdownErrors) {
0:             log.error("Failed to shut down: " + e);
1:         }
0:         else {
1:             System.err.println("Failed to shut down: " + e);
1:         }
1:     }
0: 
1:     public boolean isDeleteAllMessagesOnStartup() {
1:         return deleteAllMessagesOnStartup;
1:     }
0: 
1:     /**
1:      * Sets whether or not all messages are deleted on startup - mostly only
1:      * useful for testing.
1:      */
1:     public void setDeleteAllMessagesOnStartup(boolean deletePersistentMessagesOnStartup) {
1:         this.deleteAllMessagesOnStartup = deletePersistentMessagesOnStartup;
1:     }
0: 
1:     public URI getVmConnectorURI() {
1:         if (vmConnectorURI == null) {
0:             try {
0:                 vmConnectorURI = new URI("vm://" + getBrokerName());
1:             }
0:             catch (URISyntaxException e) {
1:             }
1:         }
1:         return vmConnectorURI;
1:     }
0: 
1:     public void setVmConnectorURI(URI vmConnectorURI) {
1:         this.vmConnectorURI = vmConnectorURI;
1:     }
1: }
author:James Strachan
-------------------------------------------------------------------------------
commit:973909a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.HealthView;
0: import org.apache.activemq.broker.jmx.HealthViewMBean;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             HealthViewMBean statusView = new HealthView((ManagedRegionBroker)getRegionBroker());
commit:1797ce9
/////////////////////////////////////////////////////////////////////////
0:                         + "Type=Health");
commit:42b768a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.*;
0: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.virtual.MirroredQueue;
/////////////////////////////////////////////////////////////////////////
1:     private boolean useMirroredQueues = false;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUseMirroredQueues() {
1:         return useMirroredQueues;
0:     }
0: 
1:     /**
1:      * Sets whether or not <a
1:      * href="http://activemq.apache.org/mirrored-queues.html">Mirrored
1:      * Queues</a> should be supported by default if they have not been
1:      * explicitly configured.
1:      */
1:     public void setUseMirroredQueues(boolean useMirroredQueues) {
1:         this.useMirroredQueues = useMirroredQueues;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Looks up and lazily creates if necessary the destination for the given JMS name
1:      */
1:     public Destination getDestination(ActiveMQDestination destination) throws Exception {
0:         return getBroker().addDestination(getAdminConnectionContext(), destination);
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         if (destinationInterceptors == null) {
1:             destinationInterceptors = createDefaultDestinationInterceptor();
1:         configureServices(destinationInterceptors);
0: 
1:         DestinationInterceptor destinationInterceptor = new CompositeDestinationInterceptor(destinationInterceptors);
/////////////////////////////////////////////////////////////////////////
1:     protected DestinationInterceptor[] createDefaultDestinationInterceptor() {
0:         List<DestinationInterceptor> answer = new ArrayList<DestinationInterceptor>();
1:         if (isUseVirtualTopics()) {
1:             VirtualDestinationInterceptor interceptor = new VirtualDestinationInterceptor();
1:             VirtualTopic virtualTopic = new VirtualTopic();
1:             virtualTopic.setName("VirtualTopic.>");
0:             VirtualDestination[] virtualDestinations = {virtualTopic};
1:             interceptor.setVirtualDestinations(virtualDestinations);
1:             answer.add(interceptor);
1:         if (isUseMirroredQueues()) {
0:             MirroredQueue interceptor = new MirroredQueue();    
1:             answer.add(interceptor);
0:         }
1:         DestinationInterceptor[] array = new DestinationInterceptor[answer.size()];
1:         answer.toArray(array);
1:         return array;
/////////////////////////////////////////////////////////////////////////
1:     protected void configureServices(Object[] services) {
1:         for (Object service : services) {
0:             configureService(service);
0:         }
0:     }
0: 
1:     /**
1:      * Perform any custom dependency injection
1:      */
commit:9dccfa4
/////////////////////////////////////////////////////////////////////////
1:     private File dataDirectoryFile;
/////////////////////////////////////////////////////////////////////////
1:     public File getDataDirectoryFile() {
1:         if (dataDirectoryFile == null) {
1:             dataDirectoryFile = new File(IOHelper.getDefaultDataDirectory());
1:         return dataDirectoryFile;
1:         return new File(getDataDirectoryFile(), brokerDir);
/////////////////////////////////////////////////////////////////////////
1:     public void setDataDirectory(String dataDirectory) {
1:         setDataDirectoryFile(new File(dataDirectory));
1:      * Sets the directory in which the data files will be stored by default for
1:      * the JDBC and Journal persistence adaptors.
0:      *
0:      * @param dataDirectoryFile
0:      *            the directory to store data files
1:      */
1:     public void setDataDirectoryFile(File dataDirectoryFile) {
1:         this.dataDirectoryFile = dataDirectoryFile;
0:     }
0: 
1:     /**
commit:a640190
/////////////////////////////////////////////////////////////////////////
0: 
0:     static{
0:         String localHostName = "localhost";
0:         try{
0:             localHostName=java.net.InetAddress.getLocalHost().getHostName();
0:         }catch(UnknownHostException e){
0:             log.error("Failed to resolve localhost");
0:         }
0:         LOCAL_HOST_NAME = localHostName;
0:     }
0: 
0:     @Override
1:     public String toString() {
1:         return "BrokerService[" + getBrokerName() + "]";
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:7162f01
/////////////////////////////////////////////////////////////////////////
0:             usageManager.setLimit(1024 * 1024 * 64); // Default to 64 Meg
commit:82201d2
/////////////////////////////////////////////////////////////////////////
0:             dataDirectory = new File(IOHelper.getDefaultDataDirectory());
1:     public File getBrokerDataDirectory() {
0:         String brokerDir = getBrokerName().replaceAll("[^a-zA-Z0-9\\.\\_\\-]", "_");
0:         return new File(getDataDirectory(), brokerDir);
0:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:             tmpDataDirectory = new File(getBrokerDataDirectory(), "tmp_storage");
/////////////////////////////////////////////////////////////////////////
0:         factory.setDataDirectory(getBrokerDataDirectory());
commit:44bafc3
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean stopped = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:     private CountDownLatch stoppedLatch = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
0:         stopped.set(true);
0:         stoppedLatch.countDown();
0: 
1:     /**
0:      * A helper method to block the caller thread until the broker has been stopped
1:      */
1:     public void waitUntilStopped() {
0:         while (!stopped.get()) {
0:             try {
1:                 stoppedLatch.await();
0:             }
0:             catch (InterruptedException e) {
1:                 // ignore
0:             }
0:     }
/////////////////////////////////////////////////////////////////////////
0:     protected void stopAllConnectors(ServiceStopper stopper) {
0: 
0: 		for (Iterator iter = getNetworkConnectors().iterator(); iter.hasNext();) {
0:             NetworkConnector connector = (NetworkConnector) iter.next();
1:             unregisterNetworkConnectorMBean(connector);
0:             stopper.stop(connector);
0:         }
0: 
0:         for (Iterator iter = getProxyConnectors().iterator(); iter.hasNext();) {
0:             ProxyConnector connector = (ProxyConnector) iter.next();
0:             stopper.stop(connector);
0:         }
0: 
0:         for (Iterator iter = jmsConnectors.iterator(); iter.hasNext();) {
0:             JmsConnector connector = (JmsConnector) iter.next();
0:             stopper.stop(connector);
0:         }
0: 
0:         for (Iterator iter = getTransportConnectors().iterator(); iter.hasNext();) {
0:             TransportConnector connector = (TransportConnector) iter.next();
0:             stopper.stop(connector);
0:         }
0: 	}
0: 
commit:9583b5f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.jdbc.DataSourceSupport;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IOHelper;
/////////////////////////////////////////////////////////////////////////
0:             dataDirectory = new File(new File(IOHelper.getDefaultDataDirectory()), getBrokerName()
commit:3013c20
/////////////////////////////////////////////////////////////////////////
0:             log.info("For help or more information please see: http://activemq.apache.org/");
/////////////////////////////////////////////////////////////////////////
0:      * <a href="http://activemq.apache.org/virtual-destinations.html">Virtual Topics</a>
commit:1d882e9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.security.SecurityContext;
/////////////////////////////////////////////////////////////////////////
0:         context.setSecurityContext(SecurityContext.BROKER_SECURITY_CONTEXT);
commit:b3e315f
/////////////////////////////////////////////////////////////////////////
0:     private Service[] services;
commit:49e10d3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.util.CommandAgent;
/////////////////////////////////////////////////////////////////////////
0:     private Service[] services = new Service[] { new CommandAgent() };
commit:d96a43d
/////////////////////////////////////////////////////////////////////////
0:      * @param jmsConnectors The jmsBridgeConnectors to set.
commit:53082e6
/////////////////////////////////////////////////////////////////////////
0: import javax.management.InstanceNotFoundException;
0: import javax.management.JMException;
0: import javax.management.MBeanRegistrationException;
0: import javax.management.MalformedObjectNameException;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Removes the given network connector without stopping it.
0:      * The caller should call {@link NetworkConnector#stop()} to close the connector
1:      */
1:     public boolean removeNetworkConnector(NetworkConnector connector) {
1:         boolean answer = networkConnectors.remove(connector);
1:         if (answer) {
0:             unregisterNetworkConnectorMBean(connector);
0:         }
1:         return answer;
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:             unregisterNetworkConnectorMBean(connector);
/////////////////////////////////////////////////////////////////////////
0:                 ObjectName objectName = createNetworkConnectorObjectName(connector);
/////////////////////////////////////////////////////////////////////////
0:     protected ObjectName createNetworkConnectorObjectName(NetworkConnector connector) throws MalformedObjectNameException {
0:         return new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName="
0:                 + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=NetworkConnector," + "NetworkConnectorName="
0:                 + JMXSupport.encodeObjectNamePart(connector.getName()));
0:     }
0: 
1:     protected void unregisterNetworkConnectorMBean(NetworkConnector connector) {
0:         if (isUseJmx()) {
0:             MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0:             if (mbeanServer != null) {
0:                 try {
0:                     ObjectName objectName = createNetworkConnectorObjectName(connector);
0:                     if (registeredMBeanNames.contains(objectName)) {
0:                         registeredMBeanNames.remove(objectName);
0:                         mbeanServer.unregisterMBean(objectName);
0:                     }
0:                 }
0:                 catch (Exception e) {
0:                     log.error("Failed to unregister MBean: " + e, e);
0:                 }
0:             }
0:         }
0:     }
0:     
commit:ee2462d
/////////////////////////////////////////////////////////////////////////
0:     private Service[] services;
0:     private String masterConnectorURI;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (isUseJmx() && masterConnector != null) {
0:                 registerFTConnectorMBean(masterConnector);
0:             }
0:      
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (services != null) {
0:             for (int i = 0; i < services.length; i++) {
0:                 Service service = services[i];
1:                 stopper.stop(service);
0:             }
/////////////////////////////////////////////////////////////////////////
0:         
/////////////////////////////////////////////////////////////////////////
1:     public Service[] getServices() {
0:         return services;
0:     }
0: 
1:     /**
0:      * Sets the services associated with this broker such as a {@link MasterConnector}
1:      */
1:     public void setServices(Service[] services) {
0:         this.services = services;
0:     }
0: 
1:     /**
0:      * Adds a new service so that it will be started as part of the broker lifecycle
1:      */
1:     public void addService(Service service) {
0:         if (services == null) {
0:             services = new Service[] { service };
0:         }
0:         else {
0:             int length = services.length;
0:             Service[] temp = new Service[length + 1];
0:             System.arraycopy(services, 1, temp, 1, length);
0:             temp[length] = service;
0:             services = temp;
0:         }
0:     }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (masterConnectorURI != null) {
0:             if (masterConnector != null) {
0:                 throw new IllegalStateException("Cannot specify masterConnectorURI when a masterConnector is already registered via the services property");
0:             }
0:             else {
0:                 addService(new MasterConnector(masterConnectorURI));
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:             
0:             if (services != null) {
0:                 for (int i = 0; i < services.length; i++) {
0:                     Service service = services[i];
0:                     configureService(service);
0:                     service.start();
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (service instanceof MasterConnector) {
0:             masterConnector = (MasterConnector) service;
0:         }
commit:8abb655
/////////////////////////////////////////////////////////////////////////
1:             ConnectionContext adminConnectionContext = getAdminConnectionContext();
0:             
0:                 getBroker().addDestination(adminConnectionContext, destination);
0:     
1:     /**
0:      * Returns the broker's administration connection context used for configuring the broker
0:      * at startup
1:      */
1:     public ConnectionContext getAdminConnectionContext() throws Exception {
0:         ConnectionContext adminConnectionContext = getBroker().getAdminConnectionContext();
0:         if (adminConnectionContext == null) {
0:             adminConnectionContext = createAdminConnectionContext();
0:             getBroker().setAdminConnectionContext(adminConnectionContext);
0:         }
0:         return adminConnectionContext;
0:     }
0:     
1:     /**
0:      * Factory method to create the new administration connection context object.
0:      * Note this method is here rather than inside a default broker implementation to
0:      * ensure that the broker reference inside it is the outer most interceptor
1:      */
0:     protected ConnectionContext createAdminConnectionContext() throws Exception {
0:         ConnectionContext context = new ConnectionContext();
0:         context.setBroker(getBroker());
0:         return context;
0:     }
0: 
0:     
commit:4bd8a8b
/////////////////////////////////////////////////////////////////////////
0:      * should be supported by default if they have not been explicitly configured.
/////////////////////////////////////////////////////////////////////////
0:     
1:     public ActiveMQDestination[] getDestinations() {
1:         return destinations;
0:     }
0: 
1:     /**
1:      * Sets the destinations which should be loaded/created on startup
1:      */
1:     public void setDestinations(ActiveMQDestination[] destinations) {
1:         this.destinations = destinations;
0:     }
commit:370734c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     private ActiveMQDestination[] destinations;
/////////////////////////////////////////////////////////////////////////
0:             startDestinations();
0:             
/////////////////////////////////////////////////////////////////////////
0:      * should be supported by defaut if they have not been explicitly configured.
0:     
1:     public DestinationInterceptor[] getDestinationInterceptors() {
1:         return destinationInterceptors;
0:     }
0: 
1:     /**
1:      * Sets the destination interceptors to use
1:      */
1:     public void setDestinationInterceptors(DestinationInterceptor[] destinationInterceptors) {
1:         this.destinationInterceptors = destinationInterceptors;
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Starts any configured destinations on startup
0:      *
1:      */
1:     protected void startDestinations() throws Exception {
1:         if (destinations != null) {
0:             ConnectionContext context = new ConnectionContext();
0:             context.setBroker(getBroker());
0: 
1:             for (int i = 0; i < destinations.length; i++) {
1:                 ActiveMQDestination destination = destinations[i];
0:                 getBroker().addDestination(context, destination);
0:             }
0:         }
0:     }
0: 
commit:da67a38
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.CompositeDestinationInterceptor;
0: import org.apache.activemq.broker.region.DestinationInterceptor;
0: import org.apache.activemq.broker.region.virtual.*;
/////////////////////////////////////////////////////////////////////////
0:     private DestinationInterceptor[] destinationInterceptors;
/////////////////////////////////////////////////////////////////////////
0:         
0:         DestinationInterceptor destinationInterceptor = null;
0:         if (destinationInterceptors != null) {
0:             destinationInterceptor = new CompositeDestinationInterceptor(destinationInterceptors);
0:         }
0:         else {
0:             destinationInterceptor = createDefaultDestinationInterceptor();
0:         }
0:         
0:                     getPersistenceAdapter(), destinationInterceptor);
0: 			regionBroker = new RegionBroker(this,getTaskRunnerFactory(), getMemoryManager(), getPersistenceAdapter(), destinationInterceptor);
/////////////////////////////////////////////////////////////////////////
1:      * Create the default destination interceptor
1:      */
0:     protected DestinationInterceptor createDefaultDestinationInterceptor() {
0:         if (! isUseVirtualTopics()) {
0:             return null;
0:         }
0:         VirtualDestinationInterceptor answer = new VirtualDestinationInterceptor();
0:         VirtualTopic virtualTopic = new VirtualTopic();
0:         virtualTopic.setName("VirtualTopic.>");
0:         VirtualDestination[] virtualDestinations = { virtualTopic };
0:         answer.setVirtualDestinations(virtualDestinations);
0:         return answer;
0:     }
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
commit:29081a8
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
0: 
0: import java.io.File;
0: import java.io.IOException;
0: import java.io.Serializable;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
commit:8f8fddc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.usecases.VirtualTopicPubSubTest;
/////////////////////////////////////////////////////////////////////////
0:     private boolean useVirtualTopics=true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isUseVirtualTopics() {
1:         return useVirtualTopics;
0:     }
0: 
1:     /**
0:      * Sets whether or not
0:      * <a href="http://incubator.apache.org/activemq/virtual-destinations.html">Virtual Topics</a>
0:      * should be supported.
0:      */
1:     public void setUseVirtualTopics(boolean useVirtualTopics) {
1:         this.useVirtualTopics = useVirtualTopics;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (isUseVirtualTopics()) {
0:             broker = new VirtualTopicBroker(broker);
0:         }
commit:90d0c4b
/////////////////////////////////////////////////////////////////////////
1:             configureService(persistenceAdapter);
/////////////////////////////////////////////////////////////////////////
0:     public boolean isDeleteAllMessagesOnStartup() {
0:         return deleteAllMessagesOnStartup;
0:     }
0: 
1:     /**
0:      * Sets whether or not all messages are deleted on startup - mostly only
0:      * useful for testing.
0:      */
0:     public void setDeleteAllMessagesOnStartup(boolean deletePersistentMessagesOnStartup) {
0:         this.deleteAllMessagesOnStartup = deletePersistentMessagesOnStartup;
0:     }
0: 
0:     public URI getVmConnectorURI() {
0:         if (vmConnectorURI == null) {
0:             try {
0:                 vmConnectorURI = new URI("vm://" + getBrokerName());
0:             }
0:             catch (URISyntaxException e) {
0:             }
0:         }
0:         return vmConnectorURI;
0:     }
0: 
0:     public void setVmConnectorURI(URI vmConnectorURI) {
0:         this.vmConnectorURI = vmConnectorURI;
0:     }
0: 
1:     /**
0:      * @return Returns the shutdownOnMasterFailure.
0:      */
0:     public boolean isShutdownOnMasterFailure(){
0:         return shutdownOnMasterFailure;
0:     }
0: 
1:     /**
0:      * @param shutdownOnMasterFailure The shutdownOnMasterFailure to set.
0:      */
0:     public void setShutdownOnMasterFailure(boolean shutdownOnMasterFailure){
0:         this.shutdownOnMasterFailure=shutdownOnMasterFailure;
0:     }
0: 
0:     public boolean isKeepDurableSubsActive() {
0:         return keepDurableSubsActive;
0:     }
0: 
0:     public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {
0:         this.keepDurableSubsActive = keepDurableSubsActive;
0:     }
/////////////////////////////////////////////////////////////////////////
1:      * Perform any custom dependency injection
1:     protected void configureService(Object service) {
1:         if (service instanceof BrokerServiceAware) {
0:             BrokerServiceAware serviceAware = (BrokerServiceAware) service;
1:             serviceAware.setBrokerService(this);
commit:fd3c510
/////////////////////////////////////////////////////////////////////////
0:         factory.setDataDirectoryFile(getDataDirectory());
commit:466ccdd
/////////////////////////////////////////////////////////////////////////
1:     private boolean advisorySupport = true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isAdvisorySupport() {
1:         return advisorySupport;
0:     }
0: 
0:     /**
0:      * Allows the support of advisory messages to be disabled for performance reasons.
0:      */
1:     public void setAdvisorySupport(boolean advisorySupport) {
1:         this.advisorySupport = advisorySupport;
0:     }
/////////////////////////////////////////////////////////////////////////
1:         if (isAdvisorySupport()) {
0:             broker = new AdvisoryBroker(broker);
0:         }
commit:8ad6fd3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private BrokerView adminView;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (mbeanServer != null) {
0:                 for (Iterator iter = registeredMBeanNames.iterator(); iter.hasNext();) {
0:                     ObjectName name = (ObjectName) iter.next();
0:                     try {
0:                         mbeanServer.unregisterMBean(name);
0:                     }
0:                     catch (Exception e) {
0:                         stopper.onException(mbeanServer, e);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
1:      * Returns the message broker
0:      */
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
0:      * Returns the administration view of the broker; used to create and destroy resources such as queues and topics.
0:      * 
0:      * Note this method returns null if JMX is disabled.
0:      */
1:     public BrokerView getAdminView() throws Exception {
1:         if (adminView == null) {
1:             // force lazy creation
1:             getBroker();
0:         }
1:         return adminView;
0:     }
0: 
1:     public void setAdminView(BrokerView adminView) {
1:         this.adminView = adminView;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (mbeanServer != null) {
0:             ConnectorViewMBean view = new ConnectorView(connector);
0:             try {
0:                 mbeanServer.registerMBean(view, objectName);
0:                 registeredMBeanNames.add(objectName);
0:             }
0:             catch (Throwable e) {
0:                 throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
0:             }
0:         if (mbeanServer != null) {
0:             NetworkConnectorViewMBean view = new NetworkConnectorView(connector);
0:             try {
0:                 ObjectName objectName = new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName="
0:                         + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=NetworkConnector," + "NetworkConnectorName="
0:                         + JMXSupport.encodeObjectNamePart(connector.getName()));
0:                 mbeanServer.registerMBean(view, objectName);
0:                 registeredMBeanNames.add(objectName);
0:             }
0:             catch (Throwable e) {
0:                 throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
0:             }
0:         if (mbeanServer != null) {
0:             ProxyConnectorView view = new ProxyConnectorView(connector);
0:             try {
0:                 ObjectName objectName = new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName="
0:                         + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=ProxyConnector," + "ProxyConnectorName="
0:                         + JMXSupport.encodeObjectNamePart(connector.getName()));
0:                 mbeanServer.registerMBean(view, objectName);
0:                 registeredMBeanNames.add(objectName);
0:             }
0:             catch (Throwable e) {
0:                 throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
0:             }
0: 
0:         if (mbeanServer != null) {
0:             FTConnectorView view = new FTConnectorView(connector);
0:             try {
0:                 ObjectName objectName = new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName="
0:                         + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=MasterConnector");
0:                 mbeanServer.registerMBean(view, objectName);
0:                 registeredMBeanNames.add(objectName);
0:             }
0:             catch (Throwable e) {
0:                 throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
0:             }
0: 
0:         if (mbeanServer != null) {
0:             JmsConnectorView view = new JmsConnectorView(connector);
0:             try {
0:                 ObjectName objectName = new ObjectName(managementContext.getJmxDomainName() + ":" + "BrokerName="
0:                         + JMXSupport.encodeObjectNamePart(getBrokerName()) + "," + "Type=JmsConnector," + "JmsConnectorName="
0:                         + JMXSupport.encodeObjectNamePart(connector.getName()));
0:                 mbeanServer.registerMBean(view, objectName);
0:                 registeredMBeanNames.add(objectName);
0:             }
0:             catch (Throwable e) {
0:                 throw IOExceptionSupport.create("Broker could not be registered in JMX: " + e.getMessage(), e);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             adminView = new BrokerView(this, managedBroker);
0:             if (mbeanServer != null) {
0:                 ObjectName objectName = getBrokerObjectName();
0:                 mbeanServer.registerMBean(adminView, objectName);
0:                 registeredMBeanNames.add(objectName);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             regionBroker = new ManagedRegionBroker(this, mbeanServer, getBrokerObjectName(), getTaskRunnerFactory(), getMemoryManager(),
0:                     getPersistenceAdapter());
/////////////////////////////////////////////////////////////////////////
0:         }
commit:b765307
/////////////////////////////////////////////////////////////////////////
0: import java.io.Serializable;
/////////////////////////////////////////////////////////////////////////
0: public class BrokerService implements Service, Serializable {
0: 
1:     private static final long serialVersionUID = 7353129142305630237L;
/////////////////////////////////////////////////////////////////////////
1:     private transient Thread shutdownHook;
commit:609681a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PersistenceAdapterFactory;
/////////////////////////////////////////////////////////////////////////
1:     private PersistenceAdapterFactory persistenceFactory;
/////////////////////////////////////////////////////////////////////////
1:     public PersistenceAdapterFactory getPersistenceFactory() {
/////////////////////////////////////////////////////////////////////////
1:     public void setPersistenceFactory(PersistenceAdapterFactory persistenceFactory) {
commit:d9729e8
/////////////////////////////////////////////////////////////////////////
0:             log.info("For help or more information please see: http://incubator.apache.org/activemq/");
commit:d1a18f5
/////////////////////////////////////////////////////////////////////////
1:     protected Broker addInterceptors(Broker broker) throws Exception {
commit:400b1fc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
/////////////////////////////////////////////////////////////////////////
0:         NetworkConnector connector=new DiscoveryNetworkConnector(discoveryAddress);
commit:364337b
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             processHelperProperties();
0:             BrokerRegistry.getInstance().bind(getBrokerName(), this);
0:             addShutdownHook();
0:             if (deleteAllMessagesOnStartup) {
0:                 deleteAllMessages();
0:             if (isUseJmx()) {
0:                 getManagementContext().start();
0:             }
0: 
0:             getBroker().start();
0:             if (masterConnectorURI!=null){
0:                 initializeMasterConnector(new URI(masterConnectorURI));
0:                 if (masterConnector!=null){
0:                     masterConnector.start();
0:                 }
0:             }
0:             
0:             startAllConnectors();
0:             
0: 
0:             log.info("ActiveMQ JMS Message Broker (" + getBrokerName() + ") started");
0:         }
0:         catch (Exception e) {
0:             log.error("Failed to start ActiveMQ JMS Message Broker. Reason: " + e, e);
1:             throw e;
0:         }
commit:dba3ea8
/////////////////////////////////////////////////////////////////////////
1:     private boolean useJmx = true;
commit:a640ff5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.security.MessageAuthorizationPolicy;
/////////////////////////////////////////////////////////////////////////
1:     private MessageAuthorizationPolicy messageAuthorizationPolicy;
/////////////////////////////////////////////////////////////////////////
1:         MessageAuthorizationPolicy policy = getMessageAuthorizationPolicy();
1:         if (policy != null) {
1:             connector.setMessageAuthorizationPolicy(policy);
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
1:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {
1:         return messageAuthorizationPolicy;
0:     }
0: 
0:     /**
0:      * Sets the policy used to decide if the current connection is authorized to consume
0:      * a given message
0:      */
1:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {
1:         this.messageAuthorizationPolicy = messageAuthorizationPolicy;
0:     }
0: 
commit:4686ec5
/////////////////////////////////////////////////////////////////////////
1:     private BrokerPlugin[] plugins;
/////////////////////////////////////////////////////////////////////////
1:     public BrokerPlugin[] getPlugins() {
1:         return plugins;
0:     }
0: 
0:     /**
0:      * Sets a number of broker plugins to install such as for security authentication or authorization
0:      */
1:     public void setPlugins(BrokerPlugin[] plugins) {
1:         this.plugins = plugins;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         if (plugins != null) {
1:             for (int i = 0; i < plugins.length; i++) {
1:                 BrokerPlugin plugin = plugins[i];
1:                 broker = plugin.installPlugin(broker);
0:             }
0:         }
author:Torsten Mielke
-------------------------------------------------------------------------------
commit:2f72b71
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Forces a start of the broker. 
0:      * By default a BrokerService instance that was 
1:      * previously stopped using BrokerService.stop() cannot be restarted
0:      * using BrokerService.start(). 
0:      * This method enforces a restart. 
1:      * It is not recommended to force a restart of the broker and will not work
0:      * for most but some very trivial broker configurations. 
1:      * For restarting a broker instance we recommend to first call stop() on
1:      * the old instance and then recreate a new BrokerService instance.
0:      * 
1:      * @param force - if true enforces a restart.
1:      * @throws Exception
0:      */
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:8a1f994
/////////////////////////////////////////////////////////////////////////
1:             localHostName =  InetAddressUtil.getLocalHostName();
author:David Jencks
-------------------------------------------------------------------------------
commit:09fab74
/////////////////////////////////////////////////////////////////////////
0: 
0: import javax.annotation.PostConstruct;
0: import javax.annotation.PreDestroy;
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      *
1:      * @throws Exception
1:      * @org. apache.xbean.InitMethod
0:      */
0:     @PostConstruct
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      *
1:      * @throws Exception
1:      * @org.apache .xbean.DestroyMethod
0:      */
0:     @PreDestroy
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:1ab76f7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.selector.SelectorParser;
/////////////////////////////////////////////////////////////////////////
0:         // Clear SelectorParser cache to free memory
0:         SelectorParser.clearCache();
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:ccf3f3c
/////////////////////////////////////////////////////////////////////////
0:     private boolean enableStatistics = true;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isEnableStatistics() {
1:         return enableStatistics;
0:     }    
0:      * Sets whether or not the Broker's services enable statistics or
0:      * not.
0:      */
1:     public void setEnableStatistics(boolean enableStatistics) {
1:         this.enableStatistics = enableStatistics;
0:     }    
0:     
0:     /**
/////////////////////////////////////////////////////////////////////////
0:         
0:         RegionBroker rBroker = (RegionBroker) regionBroker;
0:         rBroker.getDestinationStatistics().setEnabled(enableStatistics);
0:         
0:         
/////////////////////////////////////////////////////////////////////////
0:         
0:        	connector.getStatistics().setEnabled(enableStatistics);
0:         
commit:e34cbc1
/////////////////////////////////////////////////////////////////////////
0:         	
0:         	ArrayList al = new ArrayList();
0: 
0:                 al.add(startTransportConnector(connector));
0:             }
0:  
0:             if (al.size()>0) {
0:             	//let's clear the transportConnectors list and replace it with the started transportConnector instances 
0:             	this.transportConnectors.clear();
0:             	setTransportConnectors(al);
/////////////////////////////////////////////////////////////////////////
0:     protected TransportConnector startTransportConnector(TransportConnector connector) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         
1:         return connector;
commit:0552c2b
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:             //register all destination in persistence store including inactive destinations as mbeans 
0:             this.startDestinationsInPersistenceStore(broker);
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Starts all destiantions in persistence store. This includes all inactive destinations
0:      */
0:     protected void startDestinationsInPersistenceStore(Broker broker) throws Exception {
0:         Set destinations = destinationFactory.getDestinations();
0:         if (destinations != null) {
0:             Iterator iter = destinations.iterator();
0:             ConnectionContext adminConnectionContext = broker.getAdminConnectionContext();
0:             if (adminConnectionContext == null) {
0:                 ConnectionContext context = new ConnectionContext();
0:                 context.setBroker(broker);
0:                 adminConnectionContext = context;
0:                 broker.setAdminConnectionContext(adminConnectionContext);
0:             }
0: 
0: 
0:             while (iter.hasNext()) {
0:                 ActiveMQDestination destination = (ActiveMQDestination) iter.next();
0:                 broker.addDestination(adminConnectionContext, destination);
0:             }
0:         }
0:     }
commit:c9b8905
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Stops and removes a transport connector from the broker.
0:      * 
1:      * @param connector
1:      * @return true if the connector has been previously added to the broker
1:      * @throws Exception
0:      */
0:     public boolean removeConnector(TransportConnector connector) throws Exception {        
1:         boolean rc = transportConnectors.remove(connector);
0:         if( rc ) {
0:            unregisterConnectorMBean(connector);
0:         }
1:         return rc;
0:         
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected TransportConnector registerConnectorMBean(TransportConnector connector) throws IOException  {
0: 
0:                 ObjectName objectName = createConnectorObjectName(connector);
0:                 connector = connector.asManagedConnector(getManagementContext().getMBeanServer(), objectName);
0:                 ConnectorViewMBean view = new ConnectorView(connector);            
0:                 return connector;
0:                 throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e.getMessage(), e);
0:         return connector;
0:     
1:     protected void unregisterConnectorMBean(TransportConnector connector) throws IOException {
0:         if (isUseJmx()) {
0: 	        MBeanServer mbeanServer = getManagementContext().getMBeanServer();
0: 	        if (mbeanServer != null) {
0: 	            try {
0: 	                ObjectName objectName = createConnectorObjectName(connector);
0: 	
0: 	                if( registeredMBeanNames.remove(objectName) ) {
0: 	                       mbeanServer.unregisterMBean(objectName);
0: 	                }
0: 	            }
0: 	            catch (Throwable e) {
0: 	                throw IOExceptionSupport.create("Transport Connector could not be registered in JMX: " + e.getMessage(), e);
0: 	            }
0: 	        }
0:         }
0:     }
0: 
0: 	private ObjectName createConnectorObjectName(TransportConnector connector) throws MalformedObjectNameException {
0: 		return new ObjectName(
0: 		        managementContext.getJmxDomainName()+":"+
0: 		        "BrokerName="+JMXSupport.encodeObjectNamePart(getBrokerName())+","+
0: 		        "Type=Connector,"+
0: 		        "ConnectorName="+JMXSupport.encodeObjectNamePart(connector.getName())
0: 		        );
0: 	}    
/////////////////////////////////////////////////////////////////////////
0:                 throw IOExceptionSupport.create("Network Connector could not be registered in JMX: " + e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
0:                     if (registeredMBeanNames.remove(objectName)) {
0:                     log.error("Network Connector could not be unregistered from JMX: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:             connector = registerConnectorMBean(connector);
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:635e6e7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 startTransportConnector(connector);
/////////////////////////////////////////////////////////////////////////
0:     protected void startTransportConnector(TransportConnector connector) throws Exception {
0:         connector.setBroker(getBroker());
0:         connector.setBrokerName(getBrokerName());
0:         connector.setTaskRunnerFactory(getTaskRunnerFactory());
0:         MessageAuthorizationPolicy policy = getMessageAuthorizationPolicy();
0:         if (policy != null) {
0:             connector.setMessageAuthorizationPolicy(policy);
0:         }
0:         
0:         if (isUseJmx()) {
0:             connector = connector.asManagedConnector(getManagementContext().getMBeanServer(), getBrokerObjectName());
0:             registerConnectorMBean(connector);
0:         }        
0:         connector.start();
0:     }
0: 
author:Dennis Cook
-------------------------------------------------------------------------------
commit:eef9202
/////////////////////////////////////////////////////////////////////////
0:             URI discoveryUri = connector.getDiscoveryUri();
0:             connector.setDiscoveryUri(discoveryUri);
============================================================================