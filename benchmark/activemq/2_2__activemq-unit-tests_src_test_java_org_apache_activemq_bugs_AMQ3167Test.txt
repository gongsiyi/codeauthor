1:cfdd68c: /**
1:cfdd68c:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:cfdd68c:  * contributor license agreements.  See the NOTICE file distributed with
1:cfdd68c:  * this work for additional information regarding copyright ownership.
1:cfdd68c:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:cfdd68c:  * (the "License"); you may not use this file except in compliance with
1:cfdd68c:  * the License.  You may obtain a copy of the License at
1:cfdd68c:  *
1:cfdd68c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:cfdd68c:  *
1:cfdd68c:  * Unless required by applicable law or agreed to in writing, software
1:cfdd68c:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cfdd68c:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cfdd68c:  * See the License for the specific language governing permissions and
1:cfdd68c:  * limitations under the License.
1:cfdd68c:  */
25:cfdd68c: 
1:cfdd68c: package org.apache.activemq.bugs;
1:cfdd68c: 
1:5219fa1: import static org.junit.Assert.assertTrue;
1:5219fa1: import static org.junit.Assert.fail;
1:5219fa1: 
1:cfdd68c: import java.util.ArrayList;
1:5219fa1: 
1:cfdd68c: import javax.jms.Connection;
1:cfdd68c: import javax.jms.Destination;
1:cfdd68c: import javax.jms.Message;
1:cfdd68c: import javax.jms.MessageConsumer;
1:cfdd68c: import javax.jms.MessageProducer;
1:cfdd68c: import javax.jms.Session;
1:5219fa1: 
1:cfdd68c: import org.apache.activemq.ActiveMQConnectionFactory;
1:cfdd68c: import org.apache.activemq.broker.BrokerService;
1:cfdd68c: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:cfdd68c: import org.apache.activemq.broker.region.policy.PolicyMap;
1:cfdd68c: import org.apache.activemq.command.ActiveMQDestination;
1:cfdd68c: import org.apache.activemq.command.ActiveMQMessage;
1:cfdd68c: import org.junit.After;
1:cfdd68c: import org.junit.Before;
1:cfdd68c: import org.junit.Test;
1:cfdd68c: 
1:cfdd68c: /**
1:cfdd68c:  * Test the loss of messages detected during testing with ActiveMQ 5.4.1 and 5.4.2.
1:cfdd68c:  * <p/>
1:5219fa1:  * Symptoms: - 1 record is lost "early" in the stream. - no more records lost.
1:cfdd68c:  * <p/>
1:5219fa1:  * Test Configuration: - Broker Settings: - Destination Policy - Occurs with "Destination Policy" using Store Cursor and
1:5219fa1:  * a memory limit - Not reproduced without "Destination Policy" defined - Persistence Adapter - Memory: Does not occur.
1:5219fa1:  * - KahaDB: Occurs. - Messages - Occurs with TextMessage and BinaryMessage - Persistent messages.
1:cfdd68c:  * <p/>
1:5219fa1:  * Notes: - Lower memory limits increase the rate of occurrence. - Higher memory limits may prevent the problem
1:5219fa1:  * (probably because memory limits not reached). - Producers sending a number of messages before consumers come online
1:5219fa1:  * increases rate of occurrence.
1:cfdd68c:  */
1:cfdd68c: 
1:cfdd68c: public class AMQ3167Test {
1:cfdd68c:     protected BrokerService embeddedBroker;
1:cfdd68c: 
1:cfdd68c:     protected static final int MEMORY_LIMIT = 16 * 1024;
1:cfdd68c: 
1:cfdd68c:     protected static boolean Debug_f = false;
1:cfdd68c: 
1:cfdd68c:     protected long Producer_stop_time = 0;
1:cfdd68c:     protected long Consumer_stop_time = 0;
1:cfdd68c:     protected long Consumer_startup_delay_ms = 2000;
1:cfdd68c:     protected boolean Stop_after_error = true;
1:cfdd68c: 
1:cfdd68c:     protected Connection JMS_conn;
1:cfdd68c:     protected long Num_error = 0;
1:cfdd68c: 
1:5219fa1:     // // ////
1:5219fa1:     // // UTILITIES ////
1:5219fa1:     // // ////
1:cfdd68c: 
1:cfdd68c:     /**
1:5219fa1:      * Create a new, unsecured, client connection to the test broker using the given username and password. This
1:cfdd68c:      * connection bypasses all security.
1:cfdd68c:      * <p/>
1:5219fa1:      * Don't forget to start the connection or no messages will be received by consumers even though producers will work
1:5219fa1:      * fine.
1:cfdd68c:      *
1:cfdd68c:      * @username name of the JMS user for the connection; may be null.
1:cfdd68c:      * @password Password for the JMS user; may be null.
1:cfdd68c:      */
1:cfdd68c: 
1:5219fa1:     protected Connection createUnsecuredConnection(String username, String password) throws javax.jms.JMSException {
1:cfdd68c:         ActiveMQConnectionFactory conn_fact;
1:cfdd68c: 
1:cfdd68c:         conn_fact = new ActiveMQConnectionFactory(embeddedBroker.getVmConnectorURI());
1:cfdd68c: 
1:cfdd68c:         return conn_fact.createConnection(username, password);
1:cfdd68c:     }
1:cfdd68c: 
1:5219fa1:     // // ////
1:5219fa1:     // // TEST FUNCTIONALITY ////
1:5219fa1:     // // ////
1:cfdd68c: 
1:cfdd68c:     @Before
1:5219fa1:     public void testPrep() throws Exception {
1:cfdd68c:         embeddedBroker = new BrokerService();
1:cfdd68c:         configureBroker(embeddedBroker);
1:cfdd68c:         embeddedBroker.start();
1:cfdd68c:         embeddedBroker.waitUntilStarted();
1:cfdd68c: 
1:cfdd68c:         // Prepare the connection
1:cfdd68c:         JMS_conn = createUnsecuredConnection(null, null);
1:cfdd68c:         JMS_conn.start();
1:cfdd68c:     }
1:cfdd68c: 
1:cfdd68c:     @After
1:5219fa1:     public void testCleanup() throws java.lang.Exception {
1:cfdd68c:         JMS_conn.stop();
1:cfdd68c:         embeddedBroker.stop();
1:cfdd68c:     }
1:cfdd68c: 
1:5219fa1:     protected void configureBroker(BrokerService broker_svc) throws Exception {
1:cfdd68c: 
1:cfdd68c:         broker_svc.setBrokerName("testbroker1");
1:cfdd68c: 
1:cfdd68c:         broker_svc.setUseJmx(false);
1:cfdd68c:         broker_svc.setPersistent(true);
1:cfdd68c:         broker_svc.setDataDirectory("target/AMQ3167Test");
1:cfdd68c:         configureDestinationPolicy(broker_svc);
1:cfdd68c:     }
1:cfdd68c: 
1:cfdd68c:     /**
1:cfdd68c:      * NOTE: overrides any prior policy map defined for the broker service.
1:cfdd68c:      */
1:cfdd68c: 
1:cfdd68c:     protected void configureDestinationPolicy(BrokerService broker_svc) {
1:cfdd68c:         PolicyMap pol_map;
1:cfdd68c:         PolicyEntry pol_ent;
1:cfdd68c:         ArrayList<PolicyEntry> ent_list;
1:cfdd68c: 
1:cfdd68c:         ent_list = new ArrayList<PolicyEntry>();
1:cfdd68c: 
1:cfdd68c:         //
1:cfdd68c:         // QUEUES
1:cfdd68c:         //
1:cfdd68c: 
1:cfdd68c:         pol_ent = new PolicyEntry();
1:cfdd68c:         pol_ent.setQueue(">");
1:cfdd68c:         pol_ent.setMemoryLimit(MEMORY_LIMIT);
1:cfdd68c:         pol_ent.setProducerFlowControl(false);
1:cfdd68c:         ent_list.add(pol_ent);
1:cfdd68c: 
1:cfdd68c:         //
1:cfdd68c:         // COMPLETE POLICY MAP
1:cfdd68c:         //
1:cfdd68c: 
1:cfdd68c:         pol_map = new PolicyMap();
1:cfdd68c:         pol_map.setPolicyEntries(ent_list);
1:cfdd68c: 
1:cfdd68c:         broker_svc.setDestinationPolicy(pol_map);
1:cfdd68c:     }
1:cfdd68c: 
1:5219fa1:     // // ////
1:5219fa1:     // // TEST ////
1:5219fa1:     // // ////
1:cfdd68c: 
1:cfdd68c:     @Test
1:5219fa1:     public void testQueueLostMessage() throws Exception {
1:cfdd68c:         Destination dest;
1:cfdd68c: 
1:cfdd68c:         dest = ActiveMQDestination.createDestination("lostmsgtest.queue", ActiveMQDestination.QUEUE_TYPE);
1:cfdd68c: 
1:cfdd68c:         // 10 seconds from now
1:cfdd68c:         Producer_stop_time = java.lang.System.nanoTime() + (10L * 1000000000L);
1:cfdd68c: 
1:cfdd68c:         // 15 seconds from now
1:cfdd68c:         Consumer_stop_time = Producer_stop_time + (5L * 1000000000L);
1:cfdd68c: 
1:cfdd68c:         runLostMsgTest(dest, 1000000, 1, 1, false);
1:cfdd68c: 
1:cfdd68c:         // Make sure failures in the threads are thoroughly reported in the JUnit framework.
1:cfdd68c:         assertTrue(Num_error == 0);
1:cfdd68c:     }
1:cfdd68c: 
1:cfdd68c:     /**
1:cfdd68c:      *
1:cfdd68c:      */
1:cfdd68c: 
1:cfdd68c:     protected static void log(String msg) {
1:cfdd68c:         if (Debug_f)
1:cfdd68c:             java.lang.System.err.println(msg);
1:cfdd68c:     }
1:cfdd68c: 
1:cfdd68c:     /**
1:cfdd68c:      * Main body of the lost-message test.
1:cfdd68c:      */
1:cfdd68c: 
1:5219fa1:     protected void runLostMsgTest(Destination dest, int num_msg, int num_send_per_sess, int num_recv_per_sess, boolean topic_f) throws Exception {
1:cfdd68c:         Thread prod_thread;
1:cfdd68c:         Thread cons_thread;
1:cfdd68c:         String tag;
1:cfdd68c:         Session sess;
1:cfdd68c:         MessageProducer prod;
1:cfdd68c:         MessageConsumer cons;
1:cfdd68c:         int ack_mode;
1:cfdd68c: 
1:cfdd68c:         //
1:cfdd68c:         // Start the producer
1:cfdd68c:         //
1:cfdd68c: 
1:cfdd68c:         tag = "prod";
1:cfdd68c:         log(">> Starting producer " + tag);
1:cfdd68c: 
1:cfdd68c:         sess = JMS_conn.createSession((num_send_per_sess > 1), Session.AUTO_ACKNOWLEDGE);
1:cfdd68c:         prod = sess.createProducer(dest);
1:cfdd68c: 
1:cfdd68c:         prod_thread = new producerThread(sess, prod, tag, num_msg, num_send_per_sess);
1:cfdd68c:         prod_thread.start();
1:cfdd68c:         log("Started producer " + tag);
1:cfdd68c: 
1:cfdd68c:         //
1:cfdd68c:         // Delay before starting consumers
1:cfdd68c:         //
1:cfdd68c: 
1:cfdd68c:         log("Waiting before starting consumers");
1:cfdd68c:         java.lang.Thread.sleep(Consumer_startup_delay_ms);
1:cfdd68c: 
1:cfdd68c:         //
1:cfdd68c:         // Now create and start the consumer
1:cfdd68c:         //
1:cfdd68c: 
1:cfdd68c:         tag = "cons";
1:cfdd68c:         log(">> Starting consumer");
1:cfdd68c: 
1:cfdd68c:         if (num_recv_per_sess > 1)
1:cfdd68c:             ack_mode = Session.CLIENT_ACKNOWLEDGE;
1:cfdd68c:         else
1:cfdd68c:             ack_mode = Session.AUTO_ACKNOWLEDGE;
1:cfdd68c: 
1:cfdd68c:         sess = JMS_conn.createSession(false, ack_mode);
1:cfdd68c:         cons = sess.createConsumer(dest);
1:cfdd68c: 
1:cfdd68c:         cons_thread = new consumerThread(sess, cons, tag, num_msg, num_recv_per_sess);
1:cfdd68c:         cons_thread.start();
1:cfdd68c:         log("Started consumer " + tag);
1:cfdd68c: 
1:cfdd68c:         //
1:cfdd68c:         // Wait for the producer and consumer to finish.
1:cfdd68c:         //
1:cfdd68c: 
1:cfdd68c:         log("< waiting for producer.");
1:cfdd68c:         prod_thread.join();
1:cfdd68c: 
1:cfdd68c:         log("< waiting for consumer.");
1:cfdd68c:         cons_thread.join();
1:cfdd68c: 
1:cfdd68c:         log("Shutting down");
1:cfdd68c:     }
1:cfdd68c: 
1:5219fa1:     // // ////
1:5219fa1:     // // INTERNAL CLASSES ////
1:5219fa1:     // // ////
1:cfdd68c: 
1:cfdd68c:     /**
1:5219fa1:      * Producer thread - runs a single producer until the maximum number of messages is sent, the producer stop time is
1:5219fa1:      * reached, or a test error is detected.
1:cfdd68c:      */
1:cfdd68c: 
1:cfdd68c:     protected class producerThread extends Thread {
1:cfdd68c:         protected Session msgSess;
1:cfdd68c:         protected MessageProducer msgProd;
1:cfdd68c:         protected String producerTag;
1:cfdd68c:         protected int numMsg;
1:cfdd68c:         protected int numPerSess;
1:cfdd68c:         protected long producer_stop_time;
1:cfdd68c: 
1:cfdd68c:         producerThread(Session sess, MessageProducer prod, String tag, int num_msg, int sess_size) {
1:cfdd68c:             super();
1:cfdd68c: 
1:cfdd68c:             producer_stop_time = 0;
1:cfdd68c:             msgSess = sess;
1:cfdd68c:             msgProd = prod;
1:cfdd68c:             producerTag = tag;
1:cfdd68c:             numMsg = num_msg;
1:cfdd68c:             numPerSess = sess_size;
1:cfdd68c:         }
1:cfdd68c: 
1:5219fa1:         public void execTest() throws Exception {
1:cfdd68c:             Message msg;
1:cfdd68c:             int sess_start;
1:cfdd68c:             int cur;
1:cfdd68c: 
1:cfdd68c:             sess_start = 0;
1:cfdd68c:             cur = 0;
1:5219fa1:             while ((cur < numMsg) && (!didTimeOut()) && ((!Stop_after_error) || (Num_error == 0))) {
1:cfdd68c:                 msg = msgSess.createTextMessage("test message from " + producerTag);
1:cfdd68c:                 msg.setStringProperty("testprodtag", producerTag);
1:cfdd68c:                 msg.setIntProperty("seq", cur);
1:cfdd68c: 
1:cfdd68c:                 if (msg instanceof ActiveMQMessage) {
1:cfdd68c:                     ((ActiveMQMessage) msg).setResponseRequired(true);
1:cfdd68c:                 }
1:cfdd68c: 
1:cfdd68c:                 //
1:cfdd68c:                 // Send the message.
1:cfdd68c:                 //
1:cfdd68c: 
1:cfdd68c:                 msgProd.send(msg);
1:cfdd68c:                 cur++;
1:cfdd68c: 
1:cfdd68c:                 //
1:cfdd68c:                 // Commit if the number of messages per session has been reached, and
1:5219fa1:                 // transactions are being used (only when > 1 msg per sess).
1:cfdd68c:                 //
1:cfdd68c: 
1:cfdd68c:                 if ((numPerSess > 1) && ((cur - sess_start) >= numPerSess)) {
1:cfdd68c:                     msgSess.commit();
1:cfdd68c:                     sess_start = cur;
1:cfdd68c:                 }
1:cfdd68c:             }
1:cfdd68c: 
1:cfdd68c:             // Make sure to send the final commit, if there were sends since the last commit.
1:cfdd68c:             if ((numPerSess > 1) && ((cur - sess_start) > 0))
1:cfdd68c:                 msgSess.commit();
1:cfdd68c: 
1:cfdd68c:             if (cur < numMsg)
1:5219fa1:                 log("* Producer " + producerTag + " timed out at " + java.lang.System.nanoTime() + " (stop time " + producer_stop_time + ")");
1:cfdd68c:         }
1:cfdd68c: 
1:cfdd68c:         /**
1:cfdd68c:          * Check whether it is time for the producer to terminate.
1:cfdd68c:          */
1:cfdd68c: 
1:cfdd68c:         protected boolean didTimeOut() {
1:cfdd68c:             if ((Producer_stop_time > 0) && (java.lang.System.nanoTime() >= Producer_stop_time))
1:cfdd68c:                 return true;
1:cfdd68c: 
1:cfdd68c:             return false;
1:cfdd68c:         }
1:cfdd68c: 
1:cfdd68c:         /**
1:cfdd68c:          * Run the producer.
1:cfdd68c:          */
1:cfdd68c: 
1:cfdd68c:         @Override
1:cfdd68c:         public void run() {
1:cfdd68c:             try {
1:cfdd68c:                 log("- running producer " + producerTag);
1:cfdd68c:                 execTest();
1:cfdd68c:                 log("- finished running producer " + producerTag);
1:cfdd68c:             } catch (Throwable thrown) {
1:cfdd68c:                 Num_error++;
1:cfdd68c:                 fail("producer " + producerTag + " failed: " + thrown.getMessage());
1:cfdd68c:                 throw new Error("producer " + producerTag + " failed", thrown);
1:cfdd68c:             }
1:cfdd68c:         }
1:cfdd68c: 
1:cfdd68c:         @Override
1:cfdd68c:         public String toString() {
1:cfdd68c:             return producerTag;
1:cfdd68c:         }
1:cfdd68c:     }
1:cfdd68c: 
1:cfdd68c:     /**
1:5219fa1:      * Producer thread - runs a single consumer until the maximum number of messages is received, the consumer stop time
1:5219fa1:      * is reached, or a test error is detected.
1:cfdd68c:      */
1:cfdd68c: 
1:cfdd68c:     protected class consumerThread extends Thread {
1:cfdd68c:         protected Session msgSess;
1:cfdd68c:         protected MessageConsumer msgCons;
1:cfdd68c:         protected String consumerTag;
1:cfdd68c:         protected int numMsg;
1:cfdd68c:         protected int numPerSess;
1:cfdd68c: 
1:cfdd68c:         consumerThread(Session sess, MessageConsumer cons, String tag, int num_msg, int sess_size) {
1:cfdd68c:             super();
1:cfdd68c: 
1:cfdd68c:             msgSess = sess;
1:cfdd68c:             msgCons = cons;
1:cfdd68c:             consumerTag = tag;
1:cfdd68c:             numMsg = num_msg;
1:cfdd68c:             numPerSess = sess_size;
1:cfdd68c:         }
1:cfdd68c: 
1:5219fa1:         public void execTest() throws Exception {
1:cfdd68c:             Message msg;
1:cfdd68c:             int sess_start;
1:cfdd68c:             int cur;
1:cfdd68c: 
1:cfdd68c:             msg = null;
1:cfdd68c:             sess_start = 0;
1:cfdd68c:             cur = 0;
1:cfdd68c: 
1:5219fa1:             while ((cur < numMsg) && (!didTimeOut()) && ((!Stop_after_error) || (Num_error == 0))) {
1:cfdd68c:                 //
1:cfdd68c:                 // Use a timeout of 1 second to periodically check the consumer timeout.
1:cfdd68c:                 //
1:cfdd68c:                 msg = msgCons.receive(1000);
1:cfdd68c:                 if (msg != null) {
1:cfdd68c:                     checkMessage(msg, cur);
1:cfdd68c:                     cur++;
1:cfdd68c: 
1:cfdd68c:                     if ((numPerSess > 1) && ((cur - sess_start) >= numPerSess)) {
1:cfdd68c:                         msg.acknowledge();
1:cfdd68c:                         sess_start = cur;
1:cfdd68c:                     }
1:cfdd68c:                 }
1:cfdd68c:             }
1:cfdd68c: 
1:cfdd68c:             // Acknowledge the last messages, if they were not yet acknowledged.
1:cfdd68c:             if ((numPerSess > 1) && ((cur - sess_start) > 0))
1:cfdd68c:                 msg.acknowledge();
1:cfdd68c: 
1:cfdd68c:             if (cur < numMsg)
1:cfdd68c:                 log("* Consumer " + consumerTag + " timed out");
1:cfdd68c:         }
1:cfdd68c: 
1:cfdd68c:         /**
1:cfdd68c:          * Check whether it is time for the consumer to terminate.
1:cfdd68c:          */
1:cfdd68c: 
1:cfdd68c:         protected boolean didTimeOut() {
1:cfdd68c:             if ((Consumer_stop_time > 0) && (java.lang.System.nanoTime() >= Consumer_stop_time))
1:cfdd68c:                 return true;
1:cfdd68c: 
1:cfdd68c:             return false;
1:cfdd68c:         }
1:cfdd68c: 
1:cfdd68c:         /**
1:5219fa1:          * Verify the message received. Sequence numbers are checked and are expected to exactly match the message
1:5219fa1:          * number (starting at 0).
1:cfdd68c:          */
1:cfdd68c: 
1:5219fa1:         protected void checkMessage(Message msg, int exp_seq) throws javax.jms.JMSException {
1:cfdd68c:             int seq;
1:cfdd68c: 
1:cfdd68c:             seq = msg.getIntProperty("seq");
1:cfdd68c: 
1:cfdd68c:             if (exp_seq != seq) {
1:cfdd68c:                 Num_error++;
1:cfdd68c:                 fail("*** Consumer " + consumerTag + " expected seq " + exp_seq + "; received " + seq);
1:cfdd68c:             }
1:cfdd68c:         }
1:cfdd68c: 
1:cfdd68c:         /**
1:cfdd68c:          * Run the consumer.
1:cfdd68c:          */
1:cfdd68c: 
1:cfdd68c:         @Override
1:cfdd68c:         public void run() {
1:cfdd68c:             try {
1:cfdd68c:                 log("- running consumer " + consumerTag);
1:cfdd68c:                 execTest();
1:cfdd68c:                 log("- running consumer " + consumerTag);
1:cfdd68c:             } catch (Throwable thrown) {
1:cfdd68c:                 Num_error++;
1:cfdd68c:                 fail("consumer " + consumerTag + " failed: " + thrown.getMessage());
1:cfdd68c:                 throw new Error("consumer " + consumerTag + " failed", thrown);
1:cfdd68c:             }
1:cfdd68c:         }
1:cfdd68c: 
1:cfdd68c:         @Override
1:cfdd68c:         public String toString() {
1:cfdd68c:             return consumerTag;
1:cfdd68c:         }
1:cfdd68c:     }
1:cfdd68c: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:5219fa1
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:  * Symptoms: - 1 record is lost "early" in the stream. - no more records lost.
1:  * Test Configuration: - Broker Settings: - Destination Policy - Occurs with "Destination Policy" using Store Cursor and
1:  * a memory limit - Not reproduced without "Destination Policy" defined - Persistence Adapter - Memory: Does not occur.
1:  * - KahaDB: Occurs. - Messages - Occurs with TextMessage and BinaryMessage - Persistent messages.
1:  * Notes: - Lower memory limits increase the rate of occurrence. - Higher memory limits may prevent the problem
1:  * (probably because memory limits not reached). - Producers sending a number of messages before consumers come online
1:  * increases rate of occurrence.
/////////////////////////////////////////////////////////////////////////
1:     // // ////
1:     // // UTILITIES ////
1:     // // ////
1:      * Create a new, unsecured, client connection to the test broker using the given username and password. This
1:      * Don't forget to start the connection or no messages will be received by consumers even though producers will work
1:      * fine.
1:     protected Connection createUnsecuredConnection(String username, String password) throws javax.jms.JMSException {
/////////////////////////////////////////////////////////////////////////
1:     // // ////
1:     // // TEST FUNCTIONALITY ////
1:     // // ////
1:     public void testPrep() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testCleanup() throws java.lang.Exception {
1:     protected void configureBroker(BrokerService broker_svc) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // // ////
1:     // // TEST ////
1:     // // ////
1:     public void testQueueLostMessage() throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected void runLostMsgTest(Destination dest, int num_msg, int num_send_per_sess, int num_recv_per_sess, boolean topic_f) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // // ////
1:     // // INTERNAL CLASSES ////
1:     // // ////
1:      * Producer thread - runs a single producer until the maximum number of messages is sent, the producer stop time is
1:      * reached, or a test error is detected.
/////////////////////////////////////////////////////////////////////////
1:         public void execTest() throws Exception {
1:             while ((cur < numMsg) && (!didTimeOut()) && ((!Stop_after_error) || (Num_error == 0))) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 // transactions are being used (only when > 1 msg per sess).
/////////////////////////////////////////////////////////////////////////
1:                 log("* Producer " + producerTag + " timed out at " + java.lang.System.nanoTime() + " (stop time " + producer_stop_time + ")");
/////////////////////////////////////////////////////////////////////////
1:      * Producer thread - runs a single consumer until the maximum number of messages is received, the consumer stop time
1:      * is reached, or a test error is detected.
/////////////////////////////////////////////////////////////////////////
1:         public void execTest() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             while ((cur < numMsg) && (!didTimeOut()) && ((!Stop_after_error) || (Num_error == 0))) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          * Verify the message received. Sequence numbers are checked and are expected to exactly match the message
1:          * number (starting at 0).
1:         protected void checkMessage(Message msg, int exp_seq) throws javax.jms.JMSException {
/////////////////////////////////////////////////////////////////////////
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:cfdd68c
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.bugs;
1: 
1: import java.util.ArrayList;
1: import javax.jms.Connection;
1: import javax.jms.Destination;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: 
1: 
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
1: 
1: /**
1:  * Test the loss of messages detected during testing with ActiveMQ 5.4.1 and 5.4.2.
1:  * <p/>
0:  * Symptoms:
0:  * - 1 record is lost "early" in the stream.
0:  * - no more records lost.
1:  * <p/>
0:  * Test Configuration:
0:  * - Broker Settings:
0:  * - Destination Policy
0:  * - Occurs with "Destination Policy" using Store Cursor and a memory limit
0:  * - Not reproduced without "Destination Policy" defined
0:  * - Persistence Adapter
0:  * - Memory: Does not occur.
0:  * - KahaDB: Occurs.
0:  * - Messages
0:  * - Occurs with TextMessage and BinaryMessage
0:  * - Persistent messages.
1:  * <p/>
0:  * Notes:
0:  * - Lower memory limits increase the rate of occurrence.
0:  * - Higher memory limits may prevent the problem (probably because memory limits not reached).
0:  * - Producers sending a number of messages before consumers come online increases rate of occurrence.
1:  */
1: 
1: public class AMQ3167Test {
1:     protected BrokerService embeddedBroker;
1: 
1:     protected static final int MEMORY_LIMIT = 16 * 1024;
1: 
1:     protected static boolean Debug_f = false;
1: 
1:     protected long Producer_stop_time = 0;
1:     protected long Consumer_stop_time = 0;
1:     protected long Consumer_startup_delay_ms = 2000;
1:     protected boolean Stop_after_error = true;
1: 
1:     protected Connection JMS_conn;
1:     protected long Num_error = 0;
1: 
1: 
0:     ////             ////
0:     ////  UTILITIES  ////
0:     ////             ////
1: 
1: 
1:     /**
0:      * Create a new, unsecured, client connection to the test broker using the given username and password.  This
1:      * connection bypasses all security.
1:      * <p/>
0:      * Don't forget to start the connection or no messages will be received by consumers even though producers
0:      * will work fine.
1:      *
1:      * @username name of the JMS user for the connection; may be null.
1:      * @password Password for the JMS user; may be null.
1:      */
1: 
0:     protected Connection createUnsecuredConnection(String username, String password)
0:             throws javax.jms.JMSException {
1:         ActiveMQConnectionFactory conn_fact;
1: 
1:         conn_fact = new ActiveMQConnectionFactory(embeddedBroker.getVmConnectorURI());
1: 
1:         return conn_fact.createConnection(username, password);
1:     }
1: 
1: 
0:     ////                      ////
0:     ////  TEST FUNCTIONALITY  ////
0:     ////                      ////
1: 
1: 
1:     @Before
0:     public void testPrep()
0:             throws Exception {
1:         embeddedBroker = new BrokerService();
1:         configureBroker(embeddedBroker);
1:         embeddedBroker.start();
1:         embeddedBroker.waitUntilStarted();
1: 
1:         // Prepare the connection
1:         JMS_conn = createUnsecuredConnection(null, null);
1:         JMS_conn.start();
1:     }
1: 
1:     @After
0:     public void testCleanup()
0:             throws java.lang.Exception {
1:         JMS_conn.stop();
1:         embeddedBroker.stop();
1:     }
1: 
1: 
0:     protected void configureBroker(BrokerService broker_svc)
0:             throws Exception {
0:         TransportConnector conn;
1: 
1:         broker_svc.setBrokerName("testbroker1");
1: 
1:         broker_svc.setUseJmx(false);
1:         broker_svc.setPersistent(true);
1:         broker_svc.setDataDirectory("target/AMQ3167Test");
1:         configureDestinationPolicy(broker_svc);
1:     }
1: 
1: 
1:     /**
1:      * NOTE: overrides any prior policy map defined for the broker service.
1:      */
1: 
1:     protected void configureDestinationPolicy(BrokerService broker_svc) {
1:         PolicyMap pol_map;
1:         PolicyEntry pol_ent;
1:         ArrayList<PolicyEntry> ent_list;
1: 
1:         ent_list = new ArrayList<PolicyEntry>();
1: 
1:         //
1:         // QUEUES
1:         //
1: 
1:         pol_ent = new PolicyEntry();
1:         pol_ent.setQueue(">");
1:         pol_ent.setMemoryLimit(MEMORY_LIMIT);
1:         pol_ent.setProducerFlowControl(false);
1:         ent_list.add(pol_ent);
1: 
1: 
1:         //
1:         // COMPLETE POLICY MAP
1:         //
1: 
1:         pol_map = new PolicyMap();
1:         pol_map.setPolicyEntries(ent_list);
1: 
1:         broker_svc.setDestinationPolicy(pol_map);
1:     }
1: 
1: 
0:     ////        ////
0:     ////  TEST  ////
0:     ////        ////
1: 
1:     @Test
0:     public void testQueueLostMessage()
0:             throws Exception {
1:         Destination dest;
1: 
1:         dest = ActiveMQDestination.createDestination("lostmsgtest.queue", ActiveMQDestination.QUEUE_TYPE);
1: 
1:         // 10 seconds from now
1:         Producer_stop_time = java.lang.System.nanoTime() + (10L * 1000000000L);
1: 
1:         // 15 seconds from now
1:         Consumer_stop_time = Producer_stop_time + (5L * 1000000000L);
1: 
1:         runLostMsgTest(dest, 1000000, 1, 1, false);
1: 
1:         // Make sure failures in the threads are thoroughly reported in the JUnit framework.
1:         assertTrue(Num_error == 0);
1:     }
1: 
1: 
1:     /**
1:      *
1:      */
1: 
1:     protected static void log(String msg) {
1:         if (Debug_f)
1:             java.lang.System.err.println(msg);
1:     }
1: 
1: 
1:     /**
1:      * Main body of the lost-message test.
1:      */
1: 
0:     protected void runLostMsgTest(Destination dest, int num_msg, int num_send_per_sess, int num_recv_per_sess,
0:                                   boolean topic_f)
0:             throws Exception {
1:         Thread prod_thread;
1:         Thread cons_thread;
1:         String tag;
1:         Session sess;
1:         MessageProducer prod;
1:         MessageConsumer cons;
1:         int ack_mode;
1: 
1: 
1:         //
1:         // Start the producer
1:         //
1: 
1:         tag = "prod";
1:         log(">> Starting producer " + tag);
1: 
1:         sess = JMS_conn.createSession((num_send_per_sess > 1), Session.AUTO_ACKNOWLEDGE);
1:         prod = sess.createProducer(dest);
1: 
1:         prod_thread = new producerThread(sess, prod, tag, num_msg, num_send_per_sess);
1:         prod_thread.start();
1:         log("Started producer " + tag);
1: 
1: 
1:         //
1:         // Delay before starting consumers
1:         //
1: 
1:         log("Waiting before starting consumers");
1:         java.lang.Thread.sleep(Consumer_startup_delay_ms);
1: 
1: 
1:         //
1:         // Now create and start the consumer
1:         //
1: 
1:         tag = "cons";
1:         log(">> Starting consumer");
1: 
1:         if (num_recv_per_sess > 1)
1:             ack_mode = Session.CLIENT_ACKNOWLEDGE;
1:         else
1:             ack_mode = Session.AUTO_ACKNOWLEDGE;
1: 
1:         sess = JMS_conn.createSession(false, ack_mode);
1:         cons = sess.createConsumer(dest);
1: 
1:         cons_thread = new consumerThread(sess, cons, tag, num_msg, num_recv_per_sess);
1:         cons_thread.start();
1:         log("Started consumer " + tag);
1: 
1: 
1:         //
1:         // Wait for the producer and consumer to finish.
1:         //
1: 
1:         log("< waiting for producer.");
1:         prod_thread.join();
1: 
1:         log("< waiting for consumer.");
1:         cons_thread.join();
1: 
1:         log("Shutting down");
1:     }
1: 
1: 
0:     ////                    ////
0:     ////  INTERNAL CLASSES  ////
0:     ////                    ////
1: 
1:     /**
0:      * Producer thread - runs a single producer until the maximum number of messages is sent, the producer stop
0:      * time is reached, or a test error is detected.
1:      */
1: 
1:     protected class producerThread extends Thread {
1:         protected Session msgSess;
1:         protected MessageProducer msgProd;
1:         protected String producerTag;
1:         protected int numMsg;
1:         protected int numPerSess;
1:         protected long producer_stop_time;
1: 
1:         producerThread(Session sess, MessageProducer prod, String tag, int num_msg, int sess_size) {
1:             super();
1: 
1:             producer_stop_time = 0;
1:             msgSess = sess;
1:             msgProd = prod;
1:             producerTag = tag;
1:             numMsg = num_msg;
1:             numPerSess = sess_size;
1:         }
1: 
0:         public void execTest()
0:                 throws Exception {
1:             Message msg;
1:             int sess_start;
1:             int cur;
1: 
1:             sess_start = 0;
1:             cur = 0;
0:             while ((cur < numMsg) && (!didTimeOut()) &&
0:                     ((!Stop_after_error) || (Num_error == 0))) {
1:                 msg = msgSess.createTextMessage("test message from " + producerTag);
1:                 msg.setStringProperty("testprodtag", producerTag);
1:                 msg.setIntProperty("seq", cur);
1: 
1:                 if (msg instanceof ActiveMQMessage) {
1:                     ((ActiveMQMessage) msg).setResponseRequired(true);
1:                 }
1: 
1: 
1:                 //
1:                 // Send the message.
1:                 //
1: 
1:                 msgProd.send(msg);
1:                 cur++;
1: 
1: 
1:                 //
1:                 // Commit if the number of messages per session has been reached, and
0:                 //  transactions are being used (only when > 1 msg per sess).
1:                 //
1: 
1:                 if ((numPerSess > 1) && ((cur - sess_start) >= numPerSess)) {
1:                     msgSess.commit();
1:                     sess_start = cur;
1:                 }
1:             }
1: 
1:             // Make sure to send the final commit, if there were sends since the last commit.
1:             if ((numPerSess > 1) && ((cur - sess_start) > 0))
1:                 msgSess.commit();
1: 
1:             if (cur < numMsg)
0:                 log("* Producer " + producerTag + " timed out at " + java.lang.System.nanoTime() +
0:                         " (stop time " + producer_stop_time + ")");
1:         }
1: 
1: 
1:         /**
1:          * Check whether it is time for the producer to terminate.
1:          */
1: 
1:         protected boolean didTimeOut() {
1:             if ((Producer_stop_time > 0) && (java.lang.System.nanoTime() >= Producer_stop_time))
1:                 return true;
1: 
1:             return false;
1:         }
1: 
1:         /**
1:          * Run the producer.
1:          */
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 log("- running producer " + producerTag);
1:                 execTest();
1:                 log("- finished running producer " + producerTag);
1:             } catch (Throwable thrown) {
1:                 Num_error++;
1:                 fail("producer " + producerTag + " failed: " + thrown.getMessage());
1:                 throw new Error("producer " + producerTag + " failed", thrown);
1:             }
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             return producerTag;
1:         }
1:     }
1: 
1: 
1:     /**
0:      * Producer thread - runs a single consumer until the maximum number of messages is received, the consumer stop
0:      * time is reached, or a test error is detected.
1:      */
1: 
1:     protected class consumerThread extends Thread {
1:         protected Session msgSess;
1:         protected MessageConsumer msgCons;
1:         protected String consumerTag;
1:         protected int numMsg;
1:         protected int numPerSess;
1: 
1:         consumerThread(Session sess, MessageConsumer cons, String tag, int num_msg, int sess_size) {
1:             super();
1: 
1:             msgSess = sess;
1:             msgCons = cons;
1:             consumerTag = tag;
1:             numMsg = num_msg;
1:             numPerSess = sess_size;
1:         }
1: 
0:         public void execTest()
0:                 throws Exception {
1:             Message msg;
1:             int sess_start;
1:             int cur;
1: 
1:             msg = null;
1:             sess_start = 0;
1:             cur = 0;
1: 
0:             while ((cur < numMsg) && (!didTimeOut()) &&
0:                     ((!Stop_after_error) || (Num_error == 0))) {
1:                 //
1:                 // Use a timeout of 1 second to periodically check the consumer timeout.
1:                 //
1:                 msg = msgCons.receive(1000);
1:                 if (msg != null) {
1:                     checkMessage(msg, cur);
1:                     cur++;
1: 
1:                     if ((numPerSess > 1) && ((cur - sess_start) >= numPerSess)) {
1:                         msg.acknowledge();
1:                         sess_start = cur;
1:                     }
1:                 }
1:             }
1: 
1:             // Acknowledge the last messages, if they were not yet acknowledged.
1:             if ((numPerSess > 1) && ((cur - sess_start) > 0))
1:                 msg.acknowledge();
1: 
1:             if (cur < numMsg)
1:                 log("* Consumer " + consumerTag + " timed out");
1:         }
1: 
1: 
1:         /**
1:          * Check whether it is time for the consumer to terminate.
1:          */
1: 
1:         protected boolean didTimeOut() {
1:             if ((Consumer_stop_time > 0) && (java.lang.System.nanoTime() >= Consumer_stop_time))
1:                 return true;
1: 
1:             return false;
1:         }
1: 
1: 
1:         /**
0:          * Verify the message received.  Sequence numbers are checked and are expected to exactly match the
0:          * message number (starting at 0).
1:          */
1: 
0:         protected void checkMessage(Message msg, int exp_seq)
0:                 throws javax.jms.JMSException {
1:             int seq;
1: 
1:             seq = msg.getIntProperty("seq");
1: 
1:             if (exp_seq != seq) {
1:                 Num_error++;
1:                 fail("*** Consumer " + consumerTag + " expected seq " + exp_seq + "; received " + seq);
1:             }
1:         }
1: 
1: 
1:         /**
1:          * Run the consumer.
1:          */
1: 
1:         @Override
1:         public void run() {
1:             try {
1:                 log("- running consumer " + consumerTag);
1:                 execTest();
1:                 log("- running consumer " + consumerTag);
1:             } catch (Throwable thrown) {
1:                 Num_error++;
1:                 fail("consumer " + consumerTag + " failed: " + thrown.getMessage());
1:                 throw new Error("consumer " + consumerTag + " failed", thrown);
1:             }
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             return consumerTag;
1:         }
1:     }
1: }
============================================================================