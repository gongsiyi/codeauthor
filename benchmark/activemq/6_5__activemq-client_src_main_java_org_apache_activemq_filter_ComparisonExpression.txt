5:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
5:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
5:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.filter;
14:d29ca2a: 
1:d29ca2a: import java.util.HashSet;
1:d29ca2a: import java.util.List;
1:ecf89a6: import java.util.Set;
1:d29ca2a: import java.util.regex.Pattern;
1:d29ca2a: 
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  * A filter performing a comparison of two objects
1:b0c2a40:  *
1:d29ca2a:  *
1:d29ca2a:  */
1:d29ca2a: public abstract class ComparisonExpression extends BinaryExpression implements BooleanExpression {
1:d29ca2a: 
1:2f25870:     public static final ThreadLocal<Boolean> CONVERT_STRING_EXPRESSIONS = new ThreadLocal<Boolean>();
1:2f25870: 
1:2f25870:     boolean convertStringExpressions = false;
1:ecf89a6:     private static final Set<Character> REGEXP_CONTROL_CHARS = new HashSet<Character>();
1:ecf89a6: 
1:ecf89a6:     /**
1:ecf89a6:      * @param left
1:ecf89a6:      * @param right
1:ecf89a6:      */
1:ecf89a6:     public ComparisonExpression(Expression left, Expression right) {
1:ecf89a6:         super(left, right);
1:2f25870:         convertStringExpressions = CONVERT_STRING_EXPRESSIONS.get()!=null;
1:ecf89a6:     }
1:ecf89a6: 
1:d29ca2a:     public static BooleanExpression createBetween(Expression value, Expression left, Expression right) {
1:ecf89a6:         return LogicExpression.createAND(createGreaterThanEqual(value, left), createLessThanEqual(value, right));
1:0fd46ce:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createNotBetween(Expression value, Expression left, Expression right) {
1:d29ca2a:         return LogicExpression.createOR(createLessThan(value, left), createGreaterThan(value, right));
1:0fd46ce:     }
1:d29ca2a: 
1:d29ca2a:     static {
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('.'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('\\'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('['));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf(']'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('^'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('$'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('?'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('*'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('+'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('{'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('}'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('|'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('('));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf(')'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf(':'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('&'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('<'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('>'));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('='));
1:d36c0d4:         REGEXP_CONTROL_CHARS.add(Character.valueOf('!'));
38:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     static class LikeExpression extends UnaryExpression implements BooleanExpression {
1:d29ca2a: 
1:d29ca2a:         Pattern likePattern;
1:d29ca2a: 
1:d29ca2a:         /**
1:d29ca2a:          */
1:d29ca2a:         public LikeExpression(Expression right, String like, int escape) {
1:d29ca2a:             super(right);
1:d29ca2a: 
1:d29ca2a:             StringBuffer regexp = new StringBuffer(like.length() * 2);
1:d29ca2a:             regexp.append("\\A"); // The beginning of the input
1:d29ca2a:             for (int i = 0; i < like.length(); i++) {
1:d29ca2a:                 char c = like.charAt(i);
1:acbe31f:                 if (escape == (0xFFFF & c) && shouldEscapeNext(like, i, c)) {
1:d29ca2a:                     i++;
1:d29ca2a:                     char t = like.charAt(i);
2:d29ca2a:                     regexp.append("\\x");
1:d29ca2a:                     regexp.append(Integer.toHexString(0xFFFF & t));
7:a6f1d75:                 } else {
1:acbe31f:                     append(regexp, c);
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:             regexp.append("\\z"); // The end of the input
1:d29ca2a: 
1:d29ca2a:             likePattern = Pattern.compile(regexp.toString(), Pattern.DOTALL);
1:d29ca2a:         }
1:d29ca2a: 
1:acbe31f:         private boolean shouldEscapeNext(String selector, int i, char escape) {
1:acbe31f:             int next = i+1;
1:acbe31f:             if (next < selector.length()) {
1:acbe31f:                 final char c = selector.charAt(next);
1:acbe31f:                 return  (c == '_' || c == '%' || c == escape);
1:acbe31f:             }
1:acbe31f:             return false;
1:acbe31f:         }
1:acbe31f: 
1:acbe31f:         private void append(StringBuffer regexp, char c) {
1:acbe31f:             if (c == '%') {
1:acbe31f:                 regexp.append(".*?"); // Do a non-greedy match
1:acbe31f:             } else if (c == '_') {
1:acbe31f:                 regexp.append("."); // match one
1:acbe31f:             } else if (REGEXP_CONTROL_CHARS.contains(new Character(c))) {
1:acbe31f:                 regexp.append("\\x");
1:acbe31f:                 regexp.append(Integer.toHexString(0xFFFF & c));
1:acbe31f:             } else {
1:acbe31f:                 regexp.append(c);
1:acbe31f:             }
1:acbe31f:         }
1:acbe31f: 
1:d29ca2a:         /**
1:d29ca2a:          * @see org.apache.activemq.filter.UnaryExpression#getExpressionSymbol()
1:d29ca2a:          */
1:d29ca2a:         public String getExpressionSymbol() {
1:d29ca2a:             return "LIKE";
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         /**
1:d29ca2a:          * @see org.apache.activemq.filter.Expression#evaluate(MessageEvaluationContext)
1:d29ca2a:          */
1:d29ca2a:         public Object evaluate(MessageEvaluationContext message) throws JMSException {
1:d29ca2a: 
1:d29ca2a:             Object rv = this.getRight().evaluate(message);
1:d29ca2a: 
1:d29ca2a:             if (rv == null) {
1:d29ca2a:                 return null;
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             if (!(rv instanceof String)) {
1:f812e34:                 return Boolean.FALSE;
1:f812e34:                 // throw new RuntimeException("LIKE can only operate on String
1:f812e34:                 // identifiers. LIKE attemped on: '" + rv.getClass());
1:fc00993:             }
1:d29ca2a: 
1:f812e34:             return likePattern.matcher((String)rv).matches() ? Boolean.TRUE : Boolean.FALSE;
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public boolean matches(MessageEvaluationContext message) throws JMSException {
1:d29ca2a:             Object object = evaluate(message);
1:f812e34:             return object != null && object == Boolean.TRUE;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createLike(Expression left, String right, String escape) {
1:d29ca2a:         if (escape != null && escape.length() != 1) {
1:ecf89a6:             throw new RuntimeException("The ESCAPE string litteral is invalid.  It can only be one character.  Litteral used: " + escape);
1:d29ca2a:         }
1:d29ca2a:         int c = -1;
1:d29ca2a:         if (escape != null) {
1:d29ca2a:             c = 0xFFFF & escape.charAt(0);
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         return new LikeExpression(left, right, c);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createNotLike(Expression left, String right, String escape) {
1:d29ca2a:         return UnaryExpression.createNOT(createLike(left, right, escape));
1:f812e34:     }
1:d29ca2a: 
1:a6f1d75:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:d29ca2a:     public static BooleanExpression createInFilter(Expression left, List elements) {
1:f812e34: 
1:ecf89a6:         if (!(left instanceof PropertyExpression)) {
1:f812e34:             throw new RuntimeException("Expected a property for In expression, got: " + left);
1:ecf89a6:         }
1:f812e34:         return UnaryExpression.createInExpression((PropertyExpression)left, elements, false);
1:f812e34: 
1:d29ca2a:     }
1:d29ca2a: 
1:a6f1d75:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:d29ca2a:     public static BooleanExpression createNotInFilter(Expression left, List elements) {
1:f812e34: 
1:ecf89a6:         if (!(left instanceof PropertyExpression)) {
1:f812e34:             throw new RuntimeException("Expected a property for In expression, got: " + left);
1:ecf89a6:         }
1:f812e34:         return UnaryExpression.createInExpression((PropertyExpression)left, elements, true);
1:d29ca2a: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createIsNull(Expression left) {
1:d29ca2a:         return doCreateEqual(left, ConstantExpression.NULL);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createIsNotNull(Expression left) {
1:d29ca2a:         return UnaryExpression.createNOT(doCreateEqual(left, ConstantExpression.NULL));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createNotEqual(Expression left, Expression right) {
1:d29ca2a:         return UnaryExpression.createNOT(createEqual(left, right));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createEqual(Expression left, Expression right) {
1:f812e34:         checkEqualOperand(left);
1:f812e34:         checkEqualOperand(right);
1:f812e34:         checkEqualOperandCompatability(left, right);
1:f812e34:         return doCreateEqual(left, right);
1:d29ca2a:     }
1:f812e34: 
1:a6f1d75:     @SuppressWarnings({ "rawtypes" })
1:f812e34:     private static BooleanExpression doCreateEqual(Expression left, Expression right) {
1:d29ca2a:         return new ComparisonExpression(left, right) {
1:d29ca2a: 
1:d29ca2a:             public Object evaluate(MessageEvaluationContext message) throws JMSException {
1:d29ca2a:                 Object lv = left.evaluate(message);
1:d29ca2a:                 Object rv = right.evaluate(message);
1:f812e34: 
1:a6f1d75:                 // If one of the values is null
1:d29ca2a:                 if (lv == null ^ rv == null) {
1:6e9ecdf:                     if (lv == null) {
1:6e9ecdf:                         return null;
1:6e9ecdf:                     }
1:d29ca2a:                     return Boolean.FALSE;
1:d29ca2a:                 }
1:d29ca2a:                 if (lv == rv || lv.equals(rv)) {
1:d29ca2a:                     return Boolean.TRUE;
1:f812e34:                 }
1:f812e34:                 if (lv instanceof Comparable && rv instanceof Comparable) {
1:d29ca2a:                     return compare((Comparable)lv, (Comparable)rv);
1:d29ca2a:                 }
1:d29ca2a:                 return Boolean.FALSE;
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             protected boolean asBoolean(int answer) {
1:d29ca2a:                 return answer == 0;
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             public String getExpressionSymbol() {
1:d29ca2a:                 return "=";
1:d29ca2a:             }
1:d29ca2a:         };
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createGreaterThan(final Expression left, final Expression right) {
1:f812e34:         checkLessThanOperand(left);
1:f812e34:         checkLessThanOperand(right);
1:d29ca2a:         return new ComparisonExpression(left, right) {
1:d29ca2a:             protected boolean asBoolean(int answer) {
1:d29ca2a:                 return answer > 0;
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             public String getExpressionSymbol() {
1:d29ca2a:                 return ">";
1:d29ca2a:             }
1:d29ca2a:         };
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createGreaterThanEqual(final Expression left, final Expression right) {
1:f812e34:         checkLessThanOperand(left);
1:f812e34:         checkLessThanOperand(right);
1:d29ca2a:         return new ComparisonExpression(left, right) {
1:d29ca2a:             protected boolean asBoolean(int answer) {
1:d29ca2a:                 return answer >= 0;
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             public String getExpressionSymbol() {
1:d29ca2a:                 return ">=";
1:d29ca2a:             }
1:d29ca2a:         };
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public static BooleanExpression createLessThan(final Expression left, final Expression right) {
1:f812e34:         checkLessThanOperand(left);
1:f812e34:         checkLessThanOperand(right);
1:d29ca2a:         return new ComparisonExpression(left, right) {
1:d29ca2a: 
1:d29ca2a:             protected boolean asBoolean(int answer) {
1:d29ca2a:                 return answer < 0;
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             public String getExpressionSymbol() {
1:d29ca2a:                 return "<";
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:         };
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     public static BooleanExpression createLessThanEqual(final Expression left, final Expression right) {
1:f812e34:         checkLessThanOperand(left);
1:f812e34:         checkLessThanOperand(right);
1:d29ca2a:         return new ComparisonExpression(left, right) {
1:d29ca2a: 
1:d29ca2a:             protected boolean asBoolean(int answer) {
1:d29ca2a:                 return answer <= 0;
1:d29ca2a:             }
1:d29ca2a: 
1:d29ca2a:             public String getExpressionSymbol() {
1:d29ca2a:                 return "<=";
1:d29ca2a:             }
1:d29ca2a:         };
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     /**
1:f812e34:      * Only Numeric expressions can be used in >, >=, < or <= expressions.s
1:d29ca2a:      *
1:f812e34:      * @param expr
1:f812e34:      */
1:f812e34:     public static void checkLessThanOperand(Expression expr) {
1:f812e34:         if (expr instanceof ConstantExpression) {
1:f812e34:             Object value = ((ConstantExpression)expr).getValue();
1:ecf89a6:             if (value instanceof Number) {
1:f812e34:                 return;
1:ecf89a6:             }
1:d29ca2a: 
1:f812e34:             // Else it's boolean or a String..
1:f812e34:             throw new RuntimeException("Value '" + expr + "' cannot be compared.");
1:f812e34:         }
1:f812e34:         if (expr instanceof BooleanExpression) {
1:f812e34:             throw new RuntimeException("Value '" + expr + "' cannot be compared.");
1:f812e34:         }
1:f812e34:     }
1:f812e34: 
1:f812e34:     /**
1:f812e34:      * Validates that the expression can be used in == or <> expression. Cannot
1:f812e34:      * not be NULL TRUE or FALSE litterals.
1:f812e34:      *
1:f812e34:      * @param expr
1:f812e34:      */
1:f812e34:     public static void checkEqualOperand(Expression expr) {
1:f812e34:         if (expr instanceof ConstantExpression) {
1:f812e34:             Object value = ((ConstantExpression)expr).getValue();
1:ecf89a6:             if (value == null) {
1:f812e34:                 throw new RuntimeException("'" + expr + "' cannot be compared.");
1:ecf89a6:             }
1:f812e34:         }
1:f812e34:     }
1:d29ca2a: 
1:f812e34:     /**
1:f812e34:      * @param left
1:f812e34:      * @param right
1:f812e34:      */
1:f812e34:     private static void checkEqualOperandCompatability(Expression left, Expression right) {
1:f812e34:         if (left instanceof ConstantExpression && right instanceof ConstantExpression) {
1:ecf89a6:             if (left instanceof BooleanExpression && !(right instanceof BooleanExpression)) {
1:f812e34:                 throw new RuntimeException("'" + left + "' cannot be compared with '" + right + "'");
1:ecf89a6:             }
1:f812e34:         }
1:f812e34:     }
1:d29ca2a: 
1:a6f1d75:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:d29ca2a:     public Object evaluate(MessageEvaluationContext message) throws JMSException {
1:ecf89a6:         Comparable<Comparable> lv = (Comparable)left.evaluate(message);
1:d29ca2a:         if (lv == null) {
1:d29ca2a:             return null;
1:d29ca2a:         }
1:f812e34:         Comparable rv = (Comparable)right.evaluate(message);
1:d29ca2a:         if (rv == null) {
1:d29ca2a:             return null;
1:d29ca2a:         }
1:d29ca2a:         return compare(lv, rv);
1:d29ca2a:     }
1:d29ca2a: 
1:a6f1d75:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:d29ca2a:     protected Boolean compare(Comparable lv, Comparable rv) {
1:ecf89a6:         Class<? extends Comparable> lc = lv.getClass();
1:ecf89a6:         Class<? extends Comparable> rc = rv.getClass();
1:d29ca2a:         // If the the objects are not of the same type,
1:d29ca2a:         // try to convert up to allow the comparison.
1:d29ca2a:         if (lc != rc) {
1:a6f1d75:             try {
1:a6f1d75:                 if (lc == Boolean.class) {
1:2f25870:                     if (convertStringExpressions && rc == String.class) {
1:a6f1d75:                         lv = Boolean.valueOf((String)lv).booleanValue();
1:fc00993:                     } else {
1:d29ca2a:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:a6f1d75:                 } else if (lc == Byte.class) {
1:0fd46ce:                     if (rc == Short.class) {
1:f812e34:                         lv = Short.valueOf(((Number)lv).shortValue());
1:f812e34:                     } else if (rc == Integer.class) {
1:f812e34:                         lv = Integer.valueOf(((Number)lv).intValue());
1:f812e34:                     } else if (rc == Long.class) {
1:f812e34:                         lv = Long.valueOf(((Number)lv).longValue());
1:f812e34:                     } else if (rc == Float.class) {
1:f812e34:                         lv = new Float(((Number)lv).floatValue());
1:f812e34:                     } else if (rc == Double.class) {
1:f812e34:                         lv = new Double(((Number)lv).doubleValue());
1:2f25870:                     } else if (convertStringExpressions && rc == String.class) {
1:a6f1d75:                         rv = Byte.valueOf((String)rv);
1:f812e34:                     } else {
1:0fd46ce:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:f812e34:                 } else if (lc == Short.class) {
1:0fd46ce:                     if (rc == Integer.class) {
1:f812e34:                         lv = Integer.valueOf(((Number)lv).intValue());
1:f812e34:                     } else if (rc == Long.class) {
1:f812e34:                         lv = Long.valueOf(((Number)lv).longValue());
1:f812e34:                     } else if (rc == Float.class) {
1:f812e34:                         lv = new Float(((Number)lv).floatValue());
1:f812e34:                     } else if (rc == Double.class) {
1:f812e34:                         lv = new Double(((Number)lv).doubleValue());
1:2f25870:                     } else if (convertStringExpressions && rc == String.class) {
1:a6f1d75:                         rv = Short.valueOf((String)rv);
1:f812e34:                     } else {
1:0fd46ce:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:0fd46ce:                 } else if (lc == Integer.class) {
1:d29ca2a:                     if (rc == Long.class) {
1:f812e34:                         lv = Long.valueOf(((Number)lv).longValue());
1:f812e34:                     } else if (rc == Float.class) {
1:f812e34:                         lv = new Float(((Number)lv).floatValue());
1:f812e34:                     } else if (rc == Double.class) {
1:f812e34:                         lv = new Double(((Number)lv).doubleValue());
1:2f25870:                     } else if (convertStringExpressions && rc == String.class) {
1:a6f1d75:                         rv = Integer.valueOf((String)rv);
1:f812e34:                     } else {
1:d29ca2a:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:f812e34:                 } else if (lc == Long.class) {
1:d29ca2a:                     if (rc == Integer.class) {
1:f812e34:                         rv = Long.valueOf(((Number)rv).longValue());
1:f812e34:                     } else if (rc == Float.class) {
1:f812e34:                         lv = new Float(((Number)lv).floatValue());
1:f812e34:                     } else if (rc == Double.class) {
1:f812e34:                         lv = new Double(((Number)lv).doubleValue());
1:2f25870:                     } else if (convertStringExpressions && rc == String.class) {
1:a6f1d75:                         rv = Long.valueOf((String)rv);
1:f812e34:                     } else {
1:d29ca2a:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:f812e34:                 } else if (lc == Float.class) {
1:d29ca2a:                     if (rc == Integer.class) {
1:f812e34:                         rv = new Float(((Number)rv).floatValue());
1:f812e34:                     } else if (rc == Long.class) {
1:f812e34:                         rv = new Float(((Number)rv).floatValue());
1:f812e34:                     } else if (rc == Double.class) {
1:f812e34:                         lv = new Double(((Number)lv).doubleValue());
1:2f25870:                     } else if (convertStringExpressions && rc == String.class) {
1:a6f1d75:                         rv = Float.valueOf((String)rv);
1:f812e34:                     } else {
1:d29ca2a:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:f812e34:                 } else if (lc == Double.class) {
1:d29ca2a:                     if (rc == Integer.class) {
1:f812e34:                         rv = new Double(((Number)rv).doubleValue());
1:f812e34:                     } else if (rc == Long.class) {
1:f812e34:                         rv = new Double(((Number)rv).doubleValue());
1:f812e34:                     } else if (rc == Float.class) {
1:f812e34:                         rv = new Float(((Number)rv).doubleValue());
1:2f25870:                     } else if (convertStringExpressions && rc == String.class) {
1:a6f1d75:                         rv = Double.valueOf((String)rv);
1:f812e34:                     } else {
1:d29ca2a:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:2f25870:                 } else if (convertStringExpressions && lc == String.class) {
1:a6f1d75:                     if (rc == Boolean.class) {
1:a6f1d75:                         lv = Boolean.valueOf((String)lv);
1:a6f1d75:                     } else if (rc == Byte.class) {
1:a6f1d75:                         lv = Byte.valueOf((String)lv);
1:a6f1d75:                     } else if (rc == Short.class) {
1:a6f1d75:                         lv = Short.valueOf((String)lv);
2:a6f1d75:                     } else if (rc == Integer.class) {
1:a6f1d75:                         lv = Integer.valueOf((String)lv);
5:a6f1d75:                     } else if (rc == Long.class) {
1:a6f1d75:                         lv = Long.valueOf((String)lv);
6:a6f1d75:                     } else if (rc == Float.class) {
1:a6f1d75:                         lv = Float.valueOf((String)lv);
6:a6f1d75:                     } else if (rc == Double.class) {
1:a6f1d75:                         lv = Double.valueOf((String)lv);
1:f812e34:                     } else {
1:d29ca2a:                         return Boolean.FALSE;
1:0fd46ce:                     }
1:a6f1d75:                 } else {
7:a6f1d75:                     return Boolean.FALSE;
1:0fd46ce:                 }
1:a6f1d75:             } catch(NumberFormatException e) {
1:a6f1d75:                 return Boolean.FALSE;
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return asBoolean(lv.compareTo(rv)) ? Boolean.TRUE : Boolean.FALSE;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected abstract boolean asBoolean(int answer);
1:f812e34: 
1:d29ca2a:     public boolean matches(MessageEvaluationContext message) throws JMSException {
1:d29ca2a:         Object object = evaluate(message);
1:f812e34:         return object != null && object == Boolean.TRUE;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:gtully
-------------------------------------------------------------------------------
commit:acbe31f
/////////////////////////////////////////////////////////////////////////
1:                 if (escape == (0xFFFF & c) && shouldEscapeNext(like, i, c)) {
1:                     append(regexp, c);
/////////////////////////////////////////////////////////////////////////
1:         private boolean shouldEscapeNext(String selector, int i, char escape) {
1:             int next = i+1;
1:             if (next < selector.length()) {
1:                 final char c = selector.charAt(next);
1:                 return  (c == '_' || c == '%' || c == escape);
1:             }
1:             return false;
1:         }
1: 
1:         private void append(StringBuffer regexp, char c) {
1:             if (c == '%') {
1:                 regexp.append(".*?"); // Do a non-greedy match
1:             } else if (c == '_') {
1:                 regexp.append("."); // match one
1:             } else if (REGEXP_CONTROL_CHARS.contains(new Character(c))) {
1:                 regexp.append("\\x");
1:                 regexp.append(Integer.toHexString(0xFFFF & c));
1:             } else {
1:                 regexp.append(c);
1:             }
1:         }
1: 
author:Timothy Bish
-------------------------------------------------------------------------------
commit:6e9ecdf
/////////////////////////////////////////////////////////////////////////
1:                     if (lv == null) {
1:                         return null;
1:                     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:2f25870
/////////////////////////////////////////////////////////////////////////
1:     public static final ThreadLocal<Boolean> CONVERT_STRING_EXPRESSIONS = new ThreadLocal<Boolean>();
1: 
1:     boolean convertStringExpressions = false;
/////////////////////////////////////////////////////////////////////////
1:         convertStringExpressions = CONVERT_STRING_EXPRESSIONS.get()!=null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     if (convertStringExpressions && rc == String.class) {
/////////////////////////////////////////////////////////////////////////
1:                     } else if (convertStringExpressions && rc == String.class) {
/////////////////////////////////////////////////////////////////////////
1:                     } else if (convertStringExpressions && rc == String.class) {
/////////////////////////////////////////////////////////////////////////
1:                     } else if (convertStringExpressions && rc == String.class) {
/////////////////////////////////////////////////////////////////////////
1:                     } else if (convertStringExpressions && rc == String.class) {
/////////////////////////////////////////////////////////////////////////
1:                     } else if (convertStringExpressions && rc == String.class) {
/////////////////////////////////////////////////////////////////////////
1:                     } else if (convertStringExpressions && rc == String.class) {
1:                 } else if (convertStringExpressions && lc == String.class) {
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     private static final Set<Character> REGEXP_CONTROL_CHARS = new HashSet<Character>();
1: 
1:     /**
1:      * @param left
1:      * @param right
1:      */
1:     public ComparisonExpression(Expression left, Expression right) {
1:         super(left, right);
1:     }
1: 
1:         return LogicExpression.createAND(createGreaterThanEqual(value, left), createLessThanEqual(value, right));
/////////////////////////////////////////////////////////////////////////
1:             throw new RuntimeException("The ESCAPE string litteral is invalid.  It can only be one character.  Litteral used: " + escape);
/////////////////////////////////////////////////////////////////////////
1:         if (!(left instanceof PropertyExpression)) {
1:         }
1:         if (!(left instanceof PropertyExpression)) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (value instanceof Number) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (value == null) {
1:             }
1:             if (left instanceof BooleanExpression && !(right instanceof BooleanExpression)) {
1:             }
1:         Comparable<Comparable> lv = (Comparable)left.evaluate(message);
/////////////////////////////////////////////////////////////////////////
1:         Class<? extends Comparable> lc = lv.getClass();
1:         Class<? extends Comparable> rc = rv.getClass();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final HashSet REGEXP_CONTROL_CHARS = new HashSet();
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:             }
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0:         return LogicExpression.createAND(createGreaterThanEqual(value, left), createLessThanEqual(value,
0:                                                                                                   right));
/////////////////////////////////////////////////////////////////////////
0:                 } else if (c == '%') {
0:                     regexp.append(".*?"); // Do a non-greedy match
0:                 } else if (c == '_') {
0:                     regexp.append("."); // match one
0:                 } else if (REGEXP_CONTROL_CHARS.contains(new Character(c))) {
1:                 } else {
/////////////////////////////////////////////////////////////////////////
1:                 return Boolean.FALSE;
1:                 // throw new RuntimeException("LIKE can only operate on String
1:                 // identifiers. LIKE attemped on: '" + rv.getClass());
1:             return likePattern.matcher((String)rv).matches() ? Boolean.TRUE : Boolean.FALSE;
1: 
1:             return object != null && object == Boolean.TRUE;
0:             throw new RuntimeException(
0:                                        "The ESCAPE string litteral is invalid.  It can only be one character.  Litteral used: "
0:                                            + escape);
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
0:         if (!(left instanceof PropertyExpression))
1:             throw new RuntimeException("Expected a property for In expression, got: " + left);
1:         return UnaryExpression.createInExpression((PropertyExpression)left, elements, false);
1: 
1: 
0:         if (!(left instanceof PropertyExpression))
1:             throw new RuntimeException("Expected a property for In expression, got: " + left);
1:         return UnaryExpression.createInExpression((PropertyExpression)left, elements, true);
/////////////////////////////////////////////////////////////////////////
1:         checkEqualOperand(left);
1:         checkEqualOperand(right);
1:         checkEqualOperandCompatability(left, right);
1:         return doCreateEqual(left, right);
1: 
1:     private static BooleanExpression doCreateEqual(Expression left, Expression right) {
1: 
1:                 }
1:                 if (lv instanceof Comparable && rv instanceof Comparable) {
/////////////////////////////////////////////////////////////////////////
1:         checkLessThanOperand(left);
1:         checkLessThanOperand(right);
/////////////////////////////////////////////////////////////////////////
1:         checkLessThanOperand(left);
1:         checkLessThanOperand(right);
/////////////////////////////////////////////////////////////////////////
1:         checkLessThanOperand(left);
1:         checkLessThanOperand(right);
/////////////////////////////////////////////////////////////////////////
1:     public static BooleanExpression createLessThanEqual(final Expression left, final Expression right) {
1:         checkLessThanOperand(left);
1:         checkLessThanOperand(right);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Only Numeric expressions can be used in >, >=, < or <= expressions.s
1:      * @param expr
1:      */
1:     public static void checkLessThanOperand(Expression expr) {
1:         if (expr instanceof ConstantExpression) {
1:             Object value = ((ConstantExpression)expr).getValue();
0:             if (value instanceof Number)
1:                 return;
1:             // Else it's boolean or a String..
1:             throw new RuntimeException("Value '" + expr + "' cannot be compared.");
1:         }
1:         if (expr instanceof BooleanExpression) {
1:             throw new RuntimeException("Value '" + expr + "' cannot be compared.");
1:         }
1:     }
1: 
1:     /**
1:      * Validates that the expression can be used in == or <> expression. Cannot
1:      * not be NULL TRUE or FALSE litterals.
1:      * @param expr
1:      */
1:     public static void checkEqualOperand(Expression expr) {
1:         if (expr instanceof ConstantExpression) {
1:             Object value = ((ConstantExpression)expr).getValue();
0:             if (value == null)
1:                 throw new RuntimeException("'" + expr + "' cannot be compared.");
1:         }
1:     }
1:     /**
1:      * 
1:      * @param left
1:      * @param right
1:      */
1:     private static void checkEqualOperandCompatability(Expression left, Expression right) {
1:         if (left instanceof ConstantExpression && right instanceof ConstantExpression) {
0:             if (left instanceof BooleanExpression && !(right instanceof BooleanExpression))
1:                 throw new RuntimeException("'" + left + "' cannot be compared with '" + right + "'");
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:         Comparable lv = (Comparable)left.evaluate(message);
1:         Comparable rv = (Comparable)right.evaluate(message);
/////////////////////////////////////////////////////////////////////////
1:                     lv = Short.valueOf(((Number)lv).shortValue());
1:                 } else if (rc == Integer.class) {
1:                     lv = Integer.valueOf(((Number)lv).intValue());
1:                 } else if (rc == Long.class) {
1:                     lv = Long.valueOf(((Number)lv).longValue());
1:                 } else if (rc == Float.class) {
1:                     lv = new Float(((Number)lv).floatValue());
1:                 } else if (rc == Double.class) {
1:                     lv = new Double(((Number)lv).doubleValue());
1:                 } else {
1:             } else if (lc == Short.class) {
1:                     lv = Integer.valueOf(((Number)lv).intValue());
1:                 } else if (rc == Long.class) {
1:                     lv = Long.valueOf(((Number)lv).longValue());
1:                 } else if (rc == Float.class) {
1:                     lv = new Float(((Number)lv).floatValue());
1:                 } else if (rc == Double.class) {
1:                     lv = new Double(((Number)lv).doubleValue());
1:                 } else {
1:                     lv = Long.valueOf(((Number)lv).longValue());
1:                 } else if (rc == Float.class) {
1:                     lv = new Float(((Number)lv).floatValue());
1:                 } else if (rc == Double.class) {
1:                     lv = new Double(((Number)lv).doubleValue());
1:                 } else {
1:             } else if (lc == Long.class) {
1:                     rv = Long.valueOf(((Number)rv).longValue());
1:                 } else if (rc == Float.class) {
1:                     lv = new Float(((Number)lv).floatValue());
1:                 } else if (rc == Double.class) {
1:                     lv = new Double(((Number)lv).doubleValue());
1:                 } else {
1:             } else if (lc == Float.class) {
1:                     rv = new Float(((Number)rv).floatValue());
1:                 } else if (rc == Long.class) {
1:                     rv = new Float(((Number)rv).floatValue());
1:                 } else if (rc == Double.class) {
1:                     lv = new Double(((Number)lv).doubleValue());
1:                 } else {
1:             } else if (lc == Double.class) {
1:                     rv = new Double(((Number)rv).doubleValue());
1:                 } else if (rc == Long.class) {
1:                     rv = new Double(((Number)rv).doubleValue());
1:                 } else if (rc == Float.class) {
1:                     rv = new Float(((Number)rv).doubleValue());
1:                 } else {
0:             } else
1: 
1:         return object != null && object == Boolean.TRUE;
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:0fd46ce
/////////////////////////////////////////////////////////////////////////
0:             if (lc == Byte.class) {
1:                 if (rc == Short.class) {
0:                     lv = new Short(((Number) lv).shortValue());
1:                 }
0:                 else if (rc == Integer.class) {
0:                     lv = new Integer(((Number) lv).intValue());
1:                 }
0:                 else if (rc == Long.class) {
0:                     lv = new Long(((Number) lv).longValue());
1:                 }
0:                 else if (rc == Float.class) {
0:                     lv = new Float(((Number) lv).floatValue());
1:                 }
0:                 else if (rc == Double.class) {
0:                     lv = new Double(((Number) lv).doubleValue());
1:                 }
0:                 else {
1:                     return Boolean.FALSE;
1:                 }
0:              } else if (lc == Short.class) {
1:                 if (rc == Integer.class) {
0:                     lv = new Integer(((Number) lv).intValue());
1:                 }
0:                 else if (rc == Long.class) {
0:                     lv = new Long(((Number) lv).longValue());
1:                 }
0:                 else if (rc == Float.class) {
0:                     lv = new Float(((Number) lv).floatValue());
1:                 }
0:                 else if (rc == Double.class) {
0:                     lv = new Double(((Number) lv).doubleValue());
1:                 }
0:                 else {
1:                     return Boolean.FALSE;
1:                 }
1:             } else if (lc == Integer.class) {
commit:93dc39b
/////////////////////////////////////////////////////////////////////////
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.filter;
1: 
1: import java.util.HashSet;
1: import java.util.List;
1: import java.util.regex.Pattern;
1: 
1: import javax.jms.JMSException;
1: 
1: /**
1:  * A filter performing a comparison of two objects
1:  * 
0:  * @version $Revision: 1.2 $
1:  */
1: public abstract class ComparisonExpression extends BinaryExpression implements BooleanExpression {
1: 
1:     public static BooleanExpression createBetween(Expression value, Expression left, Expression right) {
0:         return LogicExpression.createAND(createGreaterThanEqual(value, left), createLessThanEqual(value, right));
1:     }
1: 
1:     public static BooleanExpression createNotBetween(Expression value, Expression left, Expression right) {
1:         return LogicExpression.createOR(createLessThan(value, left), createGreaterThan(value, right));
1:     }
1: 
0:     static final private HashSet REGEXP_CONTROL_CHARS = new HashSet();
1: 
1:     static {
0:         REGEXP_CONTROL_CHARS.add(new Character('.'));
0:         REGEXP_CONTROL_CHARS.add(new Character('\\'));
0:         REGEXP_CONTROL_CHARS.add(new Character('['));
0:         REGEXP_CONTROL_CHARS.add(new Character(']'));
0:         REGEXP_CONTROL_CHARS.add(new Character('^'));
0:         REGEXP_CONTROL_CHARS.add(new Character('$'));
0:         REGEXP_CONTROL_CHARS.add(new Character('?'));
0:         REGEXP_CONTROL_CHARS.add(new Character('*'));
0:         REGEXP_CONTROL_CHARS.add(new Character('+'));
0:         REGEXP_CONTROL_CHARS.add(new Character('{'));
0:         REGEXP_CONTROL_CHARS.add(new Character('}'));
0:         REGEXP_CONTROL_CHARS.add(new Character('|'));
0:         REGEXP_CONTROL_CHARS.add(new Character('('));
0:         REGEXP_CONTROL_CHARS.add(new Character(')'));
0:         REGEXP_CONTROL_CHARS.add(new Character(':'));
0:         REGEXP_CONTROL_CHARS.add(new Character('&'));
0:         REGEXP_CONTROL_CHARS.add(new Character('<'));
0:         REGEXP_CONTROL_CHARS.add(new Character('>'));
0:         REGEXP_CONTROL_CHARS.add(new Character('='));
0:         REGEXP_CONTROL_CHARS.add(new Character('!'));
1:     }
1: 
1:     static class LikeExpression extends UnaryExpression implements BooleanExpression {
1: 
1:         Pattern likePattern;
1: 
1:         /**
0:          * @param left
1:          */
1:         public LikeExpression(Expression right, String like, int escape) {
1:             super(right);
1: 
1:             StringBuffer regexp = new StringBuffer(like.length() * 2);
1:             regexp.append("\\A"); // The beginning of the input
1:             for (int i = 0; i < like.length(); i++) {
1:                 char c = like.charAt(i);
0:                 if (escape == (0xFFFF & c)) {
1:                     i++;
0:                     if (i >= like.length()) {
0:                         // nothing left to escape...
0:                         break;
1:                     }
1: 
1:                     char t = like.charAt(i);
1:                     regexp.append("\\x");
1:                     regexp.append(Integer.toHexString(0xFFFF & t));
1:                 }
0:                 else if (c == '%') {
0:                     regexp.append(".*?"); // Do a non-greedy match 
1:                 }
0:                 else if (c == '_') {
0:                     regexp.append("."); // match one 
1:                 }
0:                 else if (REGEXP_CONTROL_CHARS.contains(new Character(c))) {
1:                     regexp.append("\\x");
0:                     regexp.append(Integer.toHexString(0xFFFF & c));
1:                 }
0:                 else {
0:                     regexp.append(c);
1:                 }
1:             }
1:             regexp.append("\\z"); // The end of the input
1: 
0:             System.out.println("regexp: " + like + ": " + regexp);
1:             likePattern = Pattern.compile(regexp.toString(), Pattern.DOTALL);
1:         }
1: 
1:         /**
1:          * @see org.apache.activemq.filter.UnaryExpression#getExpressionSymbol()
1:          */
1:         public String getExpressionSymbol() {
1:             return "LIKE";
1:         }
1: 
1:         /**
1:          * @see org.apache.activemq.filter.Expression#evaluate(MessageEvaluationContext)
1:          */
1:         public Object evaluate(MessageEvaluationContext message) throws JMSException {
1: 
1:             Object rv = this.getRight().evaluate(message);
1: 
1:             if (rv == null) {
1:                 return null;
1:             }
1: 
1:             if (!(rv instanceof String)) {
1:             	return Boolean.FALSE;
0:                 //throw new RuntimeException("LIKE can only operate on String identifiers.  LIKE attemped on: '" + rv.getClass());
1:             }
1: 
0:             return likePattern.matcher((String) rv).matches() ? Boolean.TRUE : Boolean.FALSE;
1:         }
1:         
1:         public boolean matches(MessageEvaluationContext message) throws JMSException {
1:             Object object = evaluate(message);
0:             return object!=null && object==Boolean.TRUE;            
1:         }
1:     }
1: 
1:     public static BooleanExpression createLike(Expression left, String right, String escape) {
1:         if (escape != null && escape.length() != 1) {
0:             throw new RuntimeException("The ESCAPE string litteral is invalid.  It can only be one character.  Litteral used: " + escape);
1:         }
1:         int c = -1;
1:         if (escape != null) {
1:             c = 0xFFFF & escape.charAt(0);
1:         }
1: 
1:         return new LikeExpression(left, right, c);
1:     }
1: 
1:     public static BooleanExpression createNotLike(Expression left, String right, String escape) {
1:         return UnaryExpression.createNOT(createLike(left, right, escape));
1:     }    
1: 
1:     public static BooleanExpression createInFilter(Expression left, List elements) {
1:     	
0:     	if( !(left instanceof PropertyExpression) )
0:     		throw new RuntimeException("Expected a property for In expression, got: "+left);    	
0:     	return UnaryExpression.createInExpression((PropertyExpression)left, elements, false);
1:     	
1:     }
1: 
1:     public static BooleanExpression createNotInFilter(Expression left, List elements) {
1:     	
0:     	if( !(left instanceof PropertyExpression) )
0:     		throw new RuntimeException("Expected a property for In expression, got: "+left);    	
0:     	return UnaryExpression.createInExpression((PropertyExpression)left, elements, true);
1: 
1:     }
1: 
1:     public static BooleanExpression createIsNull(Expression left) {
1:         return doCreateEqual(left, ConstantExpression.NULL);
1:     }
1: 
1:     public static BooleanExpression createIsNotNull(Expression left) {
1:         return UnaryExpression.createNOT(doCreateEqual(left, ConstantExpression.NULL));
1:     }
1: 
1:     public static BooleanExpression createNotEqual(Expression left, Expression right) {
1:         return UnaryExpression.createNOT(createEqual(left, right));
1:     }
1: 
1:     public static BooleanExpression createEqual(Expression left, Expression right) {
0:     	checkEqualOperand(left);
0:     	checkEqualOperand(right);
0:     	checkEqualOperandCompatability(left, right);
0:     	return doCreateEqual(left, right);
1:     }
1:     
0: 	private static BooleanExpression doCreateEqual(Expression left, Expression right) {
1:         return new ComparisonExpression(left, right) {
1: 
1:             public Object evaluate(MessageEvaluationContext message) throws JMSException {
1:                 Object lv = left.evaluate(message);
1:                 Object rv = right.evaluate(message);
1:                 
0:                 // Iff one of the values is null
1:                 if (lv == null ^ rv == null) {
1:                     return Boolean.FALSE;
1:                 }
1:                 if (lv == rv || lv.equals(rv)) {
1:                     return Boolean.TRUE;
1:                 }                
0:                 if( lv instanceof Comparable && rv instanceof Comparable ) {
1:                     return compare((Comparable)lv, (Comparable)rv);
1:                 }
1:                 return Boolean.FALSE;
1:             }
1: 
1:             protected boolean asBoolean(int answer) {
1:                 return answer == 0;
1:             }
1: 
1:             public String getExpressionSymbol() {
1:                 return "=";
1:             }
1:         };
1:     }
1: 
1:     public static BooleanExpression createGreaterThan(final Expression left, final Expression right) {
0:     	checkLessThanOperand(left);
0:     	checkLessThanOperand(right);
1:         return new ComparisonExpression(left, right) {
1:             protected boolean asBoolean(int answer) {
1:                 return answer > 0;
1:             }
1: 
1:             public String getExpressionSymbol() {
1:                 return ">";
1:             }
1:         };
1:     }
1: 
1:     public static BooleanExpression createGreaterThanEqual(final Expression left, final Expression right) {
0:     	checkLessThanOperand(left);
0:     	checkLessThanOperand(right);
1:         return new ComparisonExpression(left, right) {
1:             protected boolean asBoolean(int answer) {
1:                 return answer >= 0;
1:             }
1: 
1:             public String getExpressionSymbol() {
1:                 return ">=";
1:             }
1:         };
1:     }
1: 
1:     public static BooleanExpression createLessThan(final Expression left, final Expression right) {
0:     	checkLessThanOperand(left);
0:     	checkLessThanOperand(right);
1:         return new ComparisonExpression(left, right) {
1: 
1:             protected boolean asBoolean(int answer) {
1:                 return answer < 0;
1:             }
1: 
1:             public String getExpressionSymbol() {
1:                 return "<";
1:             }
1: 
1:         };
1:     }
1: 
0: 	public static BooleanExpression createLessThanEqual(final Expression left, final Expression right) {
0:     	checkLessThanOperand(left);
0:     	checkLessThanOperand(right);
1:         return new ComparisonExpression(left, right) {
1: 
1:             protected boolean asBoolean(int answer) {
1:                 return answer <= 0;
1:             }
1: 
1:             public String getExpressionSymbol() {
1:                 return "<=";
1:             }
1:         };
1:     }
1: 
1: 	/**
0:      * Only Numeric expressions can be used in >, >=, < or <= expressions.s 
1:      * 
0: 	 * @param expr
1: 	 */
0: 	public static void checkLessThanOperand(Expression expr ) {
0: 		if( expr instanceof ConstantExpression ) {
0: 			Object value = ((ConstantExpression)expr).getValue();
0: 			if( value instanceof Number )
0: 				return;
1: 			
0: 			// Else it's boolean or a String..  
0: 			throw new RuntimeException("Value '"+expr+"' cannot be compared.");
1: 		}
0: 		if( expr instanceof BooleanExpression ) {
0: 			throw new RuntimeException("Value '"+expr+"' cannot be compared.");
1: 		}		
1: 	}
1: 
1: 	/**
0:      * Validates that the expression can be used in == or <> expression.  
0:      * Cannot not be NULL TRUE or FALSE litterals.
1:      * 
0: 	 * @param expr
1: 	 */
0: 	public static void checkEqualOperand(Expression expr ) {
0: 		if( expr instanceof ConstantExpression ) {
0: 			Object value = ((ConstantExpression)expr).getValue();
0: 			if( value == null )
0: 				throw new RuntimeException("'"+expr+"' cannot be compared.");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * 
0: 	 * @param left
0: 	 * @param right
1: 	 */
0: 	private static void checkEqualOperandCompatability(Expression left, Expression right) {
0: 		if( left instanceof ConstantExpression && right instanceof ConstantExpression ) {
0: 			if( left instanceof BooleanExpression && !(right instanceof BooleanExpression) )
0: 				throw new RuntimeException("'"+left+"' cannot be compared with '"+right+"'");
1: 		}
1: 	}
1: 
1: 	
1: 	
1:     /**
0:      * @param left
0:      * @param right
1:      */
0:     public ComparisonExpression(Expression left, Expression right) {
0:         super(left, right);
1:     }
1: 
1:     public Object evaluate(MessageEvaluationContext message) throws JMSException {
0:         Comparable lv = (Comparable) left.evaluate(message);
1:         if (lv == null) {
1:             return null;
1:         }
0:         Comparable rv = (Comparable) right.evaluate(message);
1:         if (rv == null) {
1:             return null;
1:         }
1:         return compare(lv, rv);
1:     }
1: 
1:     protected Boolean compare(Comparable lv, Comparable rv) {
0:         Class lc = lv.getClass();
0:         Class rc = rv.getClass();
1:         // If the the objects are not of the same type,
1:         // try to convert up to allow the comparison.
1:         if (lc != rc) {
0:             if (lc == Integer.class) {
1:                 if (rc == Long.class) {
0:                     lv = new Long(((Number) lv).longValue());
1:                 }
0:                 else if (rc == Float.class) {
0:                     lv = new Float(((Number) lv).floatValue());
1:                 }
0:                 else if (rc == Double.class) {
0:                     lv = new Double(((Number) lv).doubleValue());
1:                 }
0:                 else {
1:                     return Boolean.FALSE;
1:                 }
1:             }
0:             else if (lc == Long.class) {
1:                 if (rc == Integer.class) {
0:                     rv = new Long(((Number) rv).longValue());
1:                 }
0:                 else if (rc == Float.class) {
0:                     lv = new Float(((Number) lv).floatValue());
1:                 }
0:                 else if (rc == Double.class) {
0:                     lv = new Double(((Number) lv).doubleValue());
1:                 }
0:                 else {
1:                     return Boolean.FALSE;
1:                 }
1:             }
0:             else if (lc == Float.class) {
1:                 if (rc == Integer.class) {
0:                     rv = new Float(((Number) rv).floatValue());
1:                 }
0:                 else if (rc == Long.class) {
0:                     rv = new Float(((Number) rv).floatValue());
1:                 }
0:                 else if (rc == Double.class) {
0:                     lv = new Double(((Number) lv).doubleValue());
1:                 }
0:                 else {
1:                     return Boolean.FALSE;
1:                 }
1:             } 
0:             else if (lc == Double.class) {
1:                 if (rc == Integer.class) {
0:                     rv = new Double(((Number) rv).doubleValue());
1:                 }
0:                 else if (rc == Long.class) {
0:                     rv = new Double(((Number) rv).doubleValue());
1:                 }
0:                 else if (rc == Float.class) {
0:                 	rv = new Float(((Number) rv).doubleValue());
1:                 }
0:                 else {
1:                     return Boolean.FALSE;
1:                 }
1:             } 
0:             else 
1:                 return Boolean.FALSE;
1:         }
1:         return asBoolean(lv.compareTo(rv)) ? Boolean.TRUE : Boolean.FALSE;
1:     }
1: 
1:     protected abstract boolean asBoolean(int answer);
1:     
1:     public boolean matches(MessageEvaluationContext message) throws JMSException {
1:         Object object = evaluate(message);
0:         return object!=null && object==Boolean.TRUE;            
1:     }
1: 
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:a6f1d75
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "rawtypes", "unchecked" })
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "rawtypes", "unchecked" })
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "rawtypes" })
/////////////////////////////////////////////////////////////////////////
1:                 // If one of the values is null
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "rawtypes", "unchecked" })
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({ "rawtypes", "unchecked" })
1:             try {
1:                 if (lc == Boolean.class) {
0:                     if (rc == String.class) {
1:                         lv = Boolean.valueOf((String)lv).booleanValue();
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
1:                 } else if (lc == Byte.class) {
0:                     if (rc == Short.class) {
0:                         lv = Short.valueOf(((Number)lv).shortValue());
1:                     } else if (rc == Integer.class) {
0:                         lv = Integer.valueOf(((Number)lv).intValue());
1:                     } else if (rc == Long.class) {
0:                         lv = Long.valueOf(((Number)lv).longValue());
1:                     } else if (rc == Float.class) {
0:                         lv = new Float(((Number)lv).floatValue());
1:                     } else if (rc == Double.class) {
0:                         lv = new Double(((Number)lv).doubleValue());
0:                     } else if (rc == String.class) {
1:                         rv = Byte.valueOf((String)rv);
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
0:                 } else if (lc == Short.class) {
0:                     if (rc == Integer.class) {
0:                         lv = Integer.valueOf(((Number)lv).intValue());
1:                     } else if (rc == Long.class) {
0:                         lv = Long.valueOf(((Number)lv).longValue());
1:                     } else if (rc == Float.class) {
0:                         lv = new Float(((Number)lv).floatValue());
1:                     } else if (rc == Double.class) {
0:                         lv = new Double(((Number)lv).doubleValue());
0:                     } else if (rc == String.class) {
1:                         rv = Short.valueOf((String)rv);
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
0:                 } else if (lc == Integer.class) {
0:                     if (rc == Long.class) {
0:                         lv = Long.valueOf(((Number)lv).longValue());
1:                     } else if (rc == Float.class) {
0:                         lv = new Float(((Number)lv).floatValue());
1:                     } else if (rc == Double.class) {
0:                         lv = new Double(((Number)lv).doubleValue());
0:                     } else if (rc == String.class) {
1:                         rv = Integer.valueOf((String)rv);
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
0:                 } else if (lc == Long.class) {
0:                     if (rc == Integer.class) {
0:                         rv = Long.valueOf(((Number)rv).longValue());
1:                     } else if (rc == Float.class) {
0:                         lv = new Float(((Number)lv).floatValue());
1:                     } else if (rc == Double.class) {
0:                         lv = new Double(((Number)lv).doubleValue());
0:                     } else if (rc == String.class) {
1:                         rv = Long.valueOf((String)rv);
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
0:                 } else if (lc == Float.class) {
0:                     if (rc == Integer.class) {
0:                         rv = new Float(((Number)rv).floatValue());
1:                     } else if (rc == Long.class) {
0:                         rv = new Float(((Number)rv).floatValue());
1:                     } else if (rc == Double.class) {
0:                         lv = new Double(((Number)lv).doubleValue());
0:                     } else if (rc == String.class) {
1:                         rv = Float.valueOf((String)rv);
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
0:                 } else if (lc == Double.class) {
0:                     if (rc == Integer.class) {
0:                         rv = new Double(((Number)rv).doubleValue());
1:                     } else if (rc == Long.class) {
0:                         rv = new Double(((Number)rv).doubleValue());
1:                     } else if (rc == Float.class) {
0:                         rv = new Float(((Number)rv).doubleValue());
0:                     } else if (rc == String.class) {
1:                         rv = Double.valueOf((String)rv);
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
0:                 } else if (lc == String.class) {
1:                     if (rc == Boolean.class) {
1:                         lv = Boolean.valueOf((String)lv);
1:                     } else if (rc == Byte.class) {
1:                         lv = Byte.valueOf((String)lv);
1:                     } else if (rc == Short.class) {
1:                         lv = Short.valueOf((String)lv);
1:                     } else if (rc == Integer.class) {
1:                         lv = Integer.valueOf((String)lv);
1:                     } else if (rc == Long.class) {
1:                         lv = Long.valueOf((String)lv);
1:                     } else if (rc == Float.class) {
1:                         lv = Float.valueOf((String)lv);
1:                     } else if (rc == Double.class) {
1:                         lv = Double.valueOf((String)lv);
1:                     } else {
1:                         return Boolean.FALSE;
0:                     }
1:             } catch(NumberFormatException e) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('.'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('\\'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('['));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf(']'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('^'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('$'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('?'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('*'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('+'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('{'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('}'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('|'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('('));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf(')'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf(':'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('&'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('<'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('>'));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('='));
1:         REGEXP_CONTROL_CHARS.add(Character.valueOf('!'));
/////////////////////////////////////////////////////////////////////////
0:                     lv = Short.valueOf(((Number) lv).shortValue());
0:                     lv = Integer.valueOf(((Number) lv).intValue());
0:                     lv = Long.valueOf(((Number) lv).longValue());
/////////////////////////////////////////////////////////////////////////
0:                     lv = Integer.valueOf(((Number) lv).intValue());
0:                     lv = Long.valueOf(((Number) lv).longValue());
/////////////////////////////////////////////////////////////////////////
0:                     lv = Long.valueOf(((Number) lv).longValue());
/////////////////////////////////////////////////////////////////////////
0:                     rv = Long.valueOf(((Number) rv).longValue());
============================================================================