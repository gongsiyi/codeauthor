1:6579d9e: /**
1:6579d9e:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6579d9e:  * contributor license agreements.  See the NOTICE file distributed with
1:6579d9e:  * this work for additional information regarding copyright ownership.
1:6579d9e:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:6579d9e:  * (the "License"); you may not use this file except in compliance with
1:6579d9e:  * the License.  You may obtain a copy of the License at
1:6579d9e:  *
1:6579d9e:  *      http://www.apache.org/licenses/LICENSE-2.0
1:6579d9e:  *
1:6579d9e:  * Unless required by applicable law or agreed to in writing, software
1:6579d9e:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6579d9e:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6579d9e:  * See the License for the specific language governing permissions and
1:6579d9e:  * limitations under the License.
1:6579d9e:  */
1:6579d9e: package org.apache.activemq.broker.virtual;
5:6579d9e: 
1:6579d9e: import java.util.concurrent.CountDownLatch;
1:6579d9e: import java.util.concurrent.TimeUnit;
1:6579d9e: 
1:6579d9e: import javax.jms.DeliveryMode;
1:6579d9e: import javax.jms.Destination;
1:6579d9e: import javax.jms.ExceptionListener;
1:6579d9e: import javax.jms.JMSException;
1:6579d9e: import javax.jms.Message;
1:6579d9e: import javax.jms.MessageConsumer;
1:6579d9e: import javax.jms.MessageListener;
1:6579d9e: import javax.jms.Session;
1:6579d9e: import javax.jms.TextMessage;
1:6579d9e: 
1:6579d9e: import org.apache.activemq.ActiveMQConnection;
1:6579d9e: import org.apache.activemq.ActiveMQConnectionFactory;
1:6579d9e: import org.apache.activemq.ActiveMQMessageProducer;
1:6579d9e: import org.apache.activemq.ActiveMQSession;
1:6579d9e: import org.apache.activemq.RedeliveryPolicy;
1:6579d9e: import org.apache.activemq.broker.BrokerFactory;
1:6579d9e: import org.apache.activemq.broker.BrokerService;
1:6579d9e: import org.apache.activemq.broker.region.Queue;
1:6579d9e: import org.apache.activemq.broker.region.RegionBroker;
1:6579d9e: import org.apache.activemq.command.ActiveMQQueue;
1:6579d9e: import org.junit.After;
1:6579d9e: import org.junit.Before;
1:6579d9e: import org.junit.Test;
1:6579d9e: import org.slf4j.Logger;
1:6579d9e: import org.slf4j.LoggerFactory;
1:6579d9e: 
1:9f5fff7: import junit.framework.TestCase;
1:9f5fff7: 
1:6579d9e: /**
1:6579d9e:  * Unit test for virtual topics and DLQ messaging. See individual test for more
1:6579d9e:  * detail
1:6579d9e:  *
1:6579d9e:  */
1:6579d9e: public class VirtualTopicDLQTest extends TestCase {
1:6579d9e:     private static BrokerService broker;
1:6579d9e: 
1:6579d9e:     private static final Logger LOG = LoggerFactory.getLogger(VirtualTopicDLQTest.class);
1:6579d9e: 
1:6579d9e:     static final String jmsConnectionURI = "failover:(vm://localhost)";
1:6579d9e: 
1:6579d9e:     // Virtual Topic that the test publishes 10 messages to
1:6579d9e:     private static final String virtualTopicName = "VirtualTopic.Test";
1:6579d9e: 
1:6579d9e:     // Queues that receive all the messages send to the virtual topic
1:6579d9e:     private static final String consumer1Prefix = "Consumer.A.";
1:6579d9e:     private static final String consumer2Prefix = "Consumer.B.";
1:6579d9e:     private static final String consumer3Prefix = "Consumer.C.";
1:6579d9e: 
1:6579d9e:     // Expected Individual Dead Letter Queue names that are tied to the
1:6579d9e:     // Subscriber Queues
1:4e63ee7:     private static final String dlqPrefix = "ActiveMQ.DLQ.Queue.";
1:6579d9e: 
1:6579d9e:     // Number of messages
1:6579d9e:     private static final int numberMessages = 6;
1:6579d9e: 
1:9f5fff7:     @Override
1:6579d9e:     @Before
1:6579d9e:     public void setUp() throws Exception {
1:6579d9e:         try {
1:6579d9e:             broker = BrokerFactory.createBroker("xbean:org/apache/activemq/broker/virtual/virtual-individual-dlq.xml", true);
1:6579d9e:             broker.start();
1:6579d9e:             broker.waitUntilStarted();
1:6579d9e:         } catch (Exception e) {
5:6579d9e:             e.printStackTrace();
1:6579d9e:             throw e;
1:6579d9e:         }
1:6579d9e:     }
1:6579d9e: 
1:9f5fff7:     @Override
1:6579d9e:     @After
1:6579d9e:     public void tearDown() throws Exception {
1:6579d9e:         try {
1:6579d9e:             // Purge the DLQ's so counts are correct for next run
1:6579d9e:             purgeDestination(dlqPrefix + consumer1Prefix + virtualTopicName);
1:6579d9e:             purgeDestination(dlqPrefix + consumer2Prefix + virtualTopicName);
1:6579d9e:             purgeDestination(dlqPrefix + consumer3Prefix + virtualTopicName);
1:6579d9e:         } catch (Exception e) {
1:6579d9e:             e.printStackTrace();
1:6579d9e:         }
1:6579d9e: 
1:6579d9e:         if (broker != null) {
1:6579d9e:             broker.stop();
1:6579d9e:             broker.waitUntilStopped();
1:6579d9e:             broker = null;
1:6579d9e:         }
1:6579d9e:     }
1:6579d9e: 
1:6579d9e:     /*
1:6579d9e:      * This test verifies that all undelivered messages sent to a consumers
1:6579d9e:      * listening on a queue associated with a virtual topic with be forwarded to
1:6579d9e:      * separate DLQ's.
1:6579d9e:      *
1:6579d9e:      * Note that the broker config, deadLetterStrategy need to have the enable
1:6579d9e:      * audit set to false so that duplicate message sent from a topic to
1:6579d9e:      * individual consumers are forwarded to the DLQ
1:6579d9e:      *
1:6579d9e:      * <deadLetterStrategy> <bean
1:6579d9e:      * xmlns="http://www.springframework.org/schema/beans"
1:6579d9e:      * class="org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy"
1:6579d9e:      * > <property name="useQueueForQueueMessages" value="true"></property>
1:6579d9e:      * <property name="processNonPersistent" value="true"></property> <property
1:6579d9e:      * name="processExpired" value="false"></property> <property
1:6579d9e:      * name="enableAudit" value="false"></property>
1:6579d9e:      *
1:6579d9e:      * </bean> </deadLetterStrategy>
1:6579d9e:      */
1:6579d9e:     @Test
1:6579d9e:     public void testVirtualTopicSubscriberDeadLetterQueue() throws Exception {
1:6579d9e: 
1:6579d9e:         TestConsumer consumer1 = null;
1:6579d9e:         TestConsumer consumer2 = null;
1:6579d9e:         TestConsumer consumer3 = null;
1:6579d9e:         TestConsumer dlqConsumer1 = null;
1:6579d9e:         TestConsumer dlqConsumer2 = null;
1:6579d9e:         TestConsumer dlqConsumer3 = null;
1:6579d9e: 
1:6579d9e:         try {
1:6579d9e: 
1:6579d9e:             // The first 2 consumers will rollback, ultimately causing messages
1:6579d9e:             // to land on the DLQ
1:6579d9e:             consumer1 = new TestConsumer(consumer1Prefix + virtualTopicName, false, numberMessages, true);
1:6579d9e:             thread(consumer1, false);
1:6579d9e: 
1:6579d9e:             consumer2 = new TestConsumer(consumer2Prefix + virtualTopicName, false, numberMessages, true);
1:6579d9e:             thread(consumer2, false);
1:6579d9e: 
1:6579d9e:             // TestConsumer that does not throw exceptions, messages should not
1:6579d9e:             // land on DLQ
1:6579d9e:             consumer3 = new TestConsumer(consumer3Prefix + virtualTopicName, false, numberMessages, false);
1:6579d9e:             thread(consumer3, false);
1:6579d9e: 
1:6579d9e:             // TestConsumer to read the expected Dead Letter Queue
1:6579d9e:             dlqConsumer1 = new TestConsumer(dlqPrefix + consumer1Prefix + virtualTopicName, false, numberMessages, false);
1:6579d9e:             thread(dlqConsumer1, false);
1:6579d9e: 
1:6579d9e:             dlqConsumer2 = new TestConsumer(dlqPrefix + consumer2Prefix + virtualTopicName, false, numberMessages, false);
1:6579d9e:             thread(dlqConsumer2, false);
1:6579d9e: 
1:6579d9e:             dlqConsumer3 = new TestConsumer(dlqPrefix + consumer3Prefix + virtualTopicName, false, numberMessages, false);
1:6579d9e:             thread(dlqConsumer3, false);
1:6579d9e: 
1:6579d9e:             // Give the consumers a second to start
1:6579d9e:             Thread.sleep(1000);
1:6579d9e: 
1:6579d9e:             // Start the producer
1:6579d9e:             TestProducer producer = new TestProducer(virtualTopicName, true, numberMessages);
1:6579d9e:             thread(producer, false);
1:6579d9e: 
1:6579d9e:             assertTrue("sent all producer messages in time, count is: " + producer.getLatch().getCount(), producer.getLatch().await(10, TimeUnit.SECONDS));
1:6579d9e:             LOG.info("producer successful, count = " + producer.getLatch().getCount());
1:6579d9e: 
1:6579d9e:             assertTrue("remaining consumer1 count should be zero, is: " + consumer1.getLatch().getCount(), consumer1.getLatch().await(10, TimeUnit.SECONDS));
1:6579d9e:             LOG.info("consumer1 successful, count = " + consumer1.getLatch().getCount());
1:6579d9e: 
1:6579d9e:             assertTrue("remaining consumer2 count should be zero, is: " + consumer2.getLatch().getCount(), consumer2.getLatch().await(10, TimeUnit.SECONDS));
1:6579d9e:             LOG.info("consumer2 successful, count = " + consumer2.getLatch().getCount());
1:6579d9e: 
1:6579d9e:             assertTrue("remaining consumer3 count should be zero, is: " + consumer3.getLatch().getCount(), consumer3.getLatch().await(10, TimeUnit.SECONDS));
1:6579d9e:             LOG.info("consumer3 successful, count = " + consumer3.getLatch().getCount());
1:6579d9e: 
1:6579d9e:             assertTrue("remaining dlqConsumer1 count should be zero, is: " + dlqConsumer1.getLatch().getCount(),
1:6579d9e:                 dlqConsumer1.getLatch().await(10, TimeUnit.SECONDS));
1:6579d9e:             LOG.info("dlqConsumer1 successful, count = " + dlqConsumer1.getLatch().getCount());
1:6579d9e: 
1:6579d9e:             assertTrue("remaining dlqConsumer2 count should be zero, is: " + dlqConsumer2.getLatch().getCount(),
1:6579d9e:                 dlqConsumer2.getLatch().await(10, TimeUnit.SECONDS));
1:6579d9e:             LOG.info("dlqConsumer2 successful, count = " + dlqConsumer2.getLatch().getCount());
1:6579d9e: 
1:6579d9e:             assertTrue("remaining dlqConsumer3 count should be " + numberMessages + ", is: " + dlqConsumer3.getLatch().getCount(), dlqConsumer3.getLatch()
1:6579d9e:                 .getCount() == numberMessages);
1:6579d9e:             LOG.info("dlqConsumer2 successful, count = " + dlqConsumer2.getLatch().getCount());
1:6579d9e: 
1:6579d9e:         } catch (Exception e) {
1:6579d9e:             e.printStackTrace();
1:6579d9e:             throw e;
1:6579d9e:         } finally {
1:6579d9e:             // Tell consumers to stop (don't read any more messages after this)
1:6579d9e:             if (consumer1 != null)
1:6579d9e:                 consumer1.setStop(true);
1:6579d9e:             if (consumer2 != null)
1:6579d9e:                 consumer2.setStop(true);
1:6579d9e:             if (consumer3 != null)
1:6579d9e:                 consumer3.setStop(true);
1:6579d9e:             if (dlqConsumer1 != null)
1:6579d9e:                 dlqConsumer1.setStop(true);
1:6579d9e:             if (dlqConsumer2 != null)
1:6579d9e:                 dlqConsumer2.setStop(true);
1:6579d9e:             if (dlqConsumer3 != null)
1:6579d9e:                 dlqConsumer3.setStop(true);
1:6579d9e:         }
1:6579d9e:     }
1:6579d9e: 
1:6579d9e:     private static Thread thread(Runnable runnable, boolean daemon) {
1:6579d9e:         Thread brokerThread = new Thread(runnable);
1:6579d9e:         brokerThread.setDaemon(daemon);
1:6579d9e:         brokerThread.start();
1:6579d9e:         return brokerThread;
1:6579d9e:     }
1:6579d9e: 
1:6579d9e:     private class TestProducer implements Runnable {
1:6579d9e:         private String destinationName = null;
1:6579d9e:         private boolean isTopic = true;
1:6579d9e:         private int numberMessages = 0;
1:6579d9e:         private CountDownLatch latch = null;
1:6579d9e: 
1:6579d9e:         public TestProducer(String destinationName, boolean isTopic, int numberMessages) {
1:6579d9e:             this.destinationName = destinationName;
1:6579d9e:             this.isTopic = isTopic;
1:6579d9e:             this.numberMessages = numberMessages;
1:6579d9e:             latch = new CountDownLatch(numberMessages);
1:6579d9e:         }
1:6579d9e: 
1:6579d9e:         public CountDownLatch getLatch() {
1:6579d9e:             return latch;
1:6579d9e:         }
1:6579d9e: 
1:9f5fff7:         @Override
1:6579d9e:         public void run() {
1:6579d9e:             ActiveMQConnectionFactory connectionFactory = null;
1:6579d9e:             ActiveMQConnection connection = null;
1:6579d9e:             ActiveMQSession session = null;
1:6579d9e:             Destination destination = null;
1:6579d9e: 
1:6579d9e:             try {
1:6579d9e:                 LOG.info("Started TestProducer for destination (" + destinationName + ")");
1:6579d9e: 
1:6579d9e:                 connectionFactory = new ActiveMQConnectionFactory(jmsConnectionURI);
1:6579d9e:                 connection = (ActiveMQConnection) connectionFactory.createConnection();
1:6579d9e:                 connection.start();
1:6579d9e:                 session = (ActiveMQSession) connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:6579d9e: 
1:6579d9e:                 if (isTopic) {
1:6579d9e:                     destination = session.createTopic(this.destinationName);
1:6579d9e:                 } else {
1:6579d9e:                     destination = session.createQueue(this.destinationName);
1:6579d9e:                 }
1:6579d9e: 
1:6579d9e:                 // Create a MessageProducer from the Session to the Topic or
1:6579d9e:                 // Queue
1:6579d9e:                 ActiveMQMessageProducer producer = (ActiveMQMessageProducer) session.createProducer(destination);
1:6579d9e:                 producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:6579d9e: 
1:6579d9e:                 for (int i = 0; i < numberMessages; i++) {
1:9f5fff7:                     TextMessage message = session.createTextMessage("I am a message :: " + String.valueOf(i));
1:6579d9e:                     try {
1:6579d9e:                         producer.send(message);
1:6579d9e: 
1:6579d9e:                     } catch (Exception deeperException) {
1:6579d9e:                         LOG.info("Producer for destination (" + destinationName + ") Caught: " + deeperException);
1:6579d9e:                     }
1:6579d9e: 
1:6579d9e:                     latch.countDown();
1:6579d9e:                     Thread.sleep(1000);
1:6579d9e:                 }
1:6579d9e: 
1:6579d9e:                 LOG.info("Finished TestProducer for destination (" + destinationName + ")");
1:6579d9e: 
1:6579d9e:             } catch (Exception e) {
1:6579d9e:                 LOG.error("Terminating TestProducer(" + destinationName + ")Caught: " + e);
1:6579d9e:             } finally {
1:6579d9e:                 try {
2:6579d9e:                     // Clean up
1:9f5fff7:                     if (connection != null) {
1:6579d9e:                         connection.close();
1:9f5fff7:                     }
1:6579d9e:                 } catch (Exception e) {
1:6579d9e:                     LOG.error("Closing connection/session (" + destinationName + ")Caught: " + e);
1:6579d9e:                 }
1:6579d9e:             }
1:6579d9e:         }
1:6579d9e:     }
1:6579d9e: 
1:6579d9e:     private class TestConsumer implements Runnable, ExceptionListener, MessageListener {
1:6579d9e:         private String destinationName = null;
1:6579d9e:         private boolean isTopic = true;
1:6579d9e:         private CountDownLatch latch = null;
1:6579d9e:         private int maxRedeliveries = 0;
1:6579d9e:         private int receivedMessageCounter = 0;
1:6579d9e:         private boolean bFakeFail = false;
1:6579d9e:         private boolean bStop = false;
1:6579d9e: 
1:6579d9e:         private ActiveMQConnectionFactory connectionFactory = null;
1:6579d9e:         private ActiveMQConnection connection = null;
1:6579d9e:         private Session session = null;
1:6579d9e:         private MessageConsumer consumer = null;
1:6579d9e: 
1:6579d9e:         public TestConsumer(String destinationName, boolean isTopic, int expectedNumberMessages, boolean bFakeFail) {
1:6579d9e:             this.destinationName = destinationName;
1:6579d9e:             this.isTopic = isTopic;
1:6579d9e:             latch = new CountDownLatch(expectedNumberMessages * (this.bFakeFail ? (maxRedeliveries + 1) : 1));
1:6579d9e:             this.bFakeFail = bFakeFail;
1:6579d9e:         }
1:6579d9e: 
1:6579d9e:         public CountDownLatch getLatch() {
1:6579d9e:             return latch;
1:6579d9e:         }
1:6579d9e: 
1:9f5fff7:         @Override
1:6579d9e:         public void run() {
1:6579d9e: 
1:6579d9e:             try {
1:6579d9e:                 LOG.info("Started TestConsumer for destination (" + destinationName + ")");
1:6579d9e: 
1:6579d9e:                 connectionFactory = new ActiveMQConnectionFactory(jmsConnectionURI);
1:6579d9e:                 connection = (ActiveMQConnection) connectionFactory.createConnection();
1:6579d9e:                 connection.start();
1:6579d9e:                 session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:6579d9e: 
1:6579d9e:                 RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:6579d9e:                 policy.setInitialRedeliveryDelay(1);
1:6579d9e:                 policy.setUseExponentialBackOff(false);
1:6579d9e:                 policy.setMaximumRedeliveries(maxRedeliveries);
1:6579d9e: 
1:6579d9e:                 connection.setExceptionListener(this);
1:6579d9e: 
1:6579d9e:                 Destination destination = null;
1:6579d9e:                 if (isTopic) {
1:6579d9e:                     destination = session.createTopic(destinationName);
1:6579d9e:                 } else {
1:6579d9e:                     destination = session.createQueue(destinationName);
1:6579d9e:                 }
1:6579d9e: 
1:6579d9e:                 consumer = session.createConsumer(destination);
1:6579d9e:                 consumer.setMessageListener(this);
1:6579d9e: 
1:6579d9e:                 while (!bStop) {
1:6579d9e:                     Thread.sleep(100);
1:6579d9e:                 }
1:6579d9e: 
1:6579d9e:                 LOG.info("Finished TestConsumer for destination name (" + destinationName + ") remaining " + this.latch.getCount() + " messages "
1:6579d9e:                     + this.toString());
1:6579d9e: 
1:6579d9e:             } catch (Exception e) {
1:6579d9e:                 LOG.error("Consumer (" + destinationName + ") Caught: " + e);
1:6579d9e:             } finally {
1:6579d9e:                 try {
1:9f5fff7:                     if (connection != null) {
1:6579d9e:                         connection.close();
1:9f5fff7:                     }
1:6579d9e:                 } catch (Exception e) {
1:6579d9e:                     LOG.error("Closing connection/session (" + destinationName + ")Caught: " + e);
1:6579d9e:                 }
1:6579d9e:             }
1:6579d9e:         }
1:6579d9e: 
1:9f5fff7:         @Override
1:6579d9e:         public synchronized void onException(JMSException ex) {
2:6579d9e:             ex.printStackTrace();
1:6579d9e:             LOG.error("Consumer for destination, (" + destinationName + "), JMS Exception occured.  Shutting down client.");
1:6579d9e:         }
1:6579d9e: 
1:6579d9e:         public synchronized void setStop(boolean bStop) {
1:6579d9e:             this.bStop = bStop;
1:6579d9e:         }
1:6579d9e: 
1:9f5fff7:         @Override
1:6579d9e:         public synchronized void onMessage(Message message) {
1:6579d9e:             receivedMessageCounter++;
1:6579d9e:             latch.countDown();
1:6579d9e: 
1:6579d9e:             LOG.info("Consumer for destination (" + destinationName + ") latch countdown: " + latch.getCount() + " :: Number messages received "
1:6579d9e:                 + this.receivedMessageCounter);
1:6579d9e: 
1:6579d9e:             try {
1:6579d9e:                 LOG.info("Consumer for destination (" + destinationName + ") Received message id :: " + message.getJMSMessageID());
1:6579d9e: 
1:6579d9e:                 if (!bFakeFail) {
1:6579d9e:                     LOG.info("Consumer on destination " + destinationName + " committing JMS Session for message: " + message.toString());
1:6579d9e:                     session.commit();
1:6579d9e:                 } else {
1:6579d9e:                     LOG.info("Consumer on destination " + destinationName + " rolling back JMS Session for message: " + message.toString());
1:6579d9e:                     session.rollback(); // rolls back all the consumed messages
1:6579d9e:                                         // on the session to
1:6579d9e:                 }
1:6579d9e: 
1:6579d9e:             } catch (JMSException ex) {
1:6579d9e:                 LOG.error("Error reading JMS Message from destination " + destinationName + ".");
1:6579d9e:             }
1:6579d9e:         }
1:6579d9e:     }
1:6579d9e: 
1:6579d9e:     private static void purgeDestination(String destination) throws Exception {
1:6579d9e:         final Queue dest = (Queue) ((RegionBroker) broker.getRegionBroker()).getQueueRegion().getDestinationMap().get(new ActiveMQQueue(destination));
1:6579d9e:         dest.purge();
1:6579d9e:         assertEquals(0, dest.getDestinationStatistics().getMessages().getCount());
1:6579d9e:     }
1:6579d9e: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9f5fff7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.TestCase;
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                     TextMessage message = session.createTextMessage("I am a message :: " + String.valueOf(i));
/////////////////////////////////////////////////////////////////////////
1:                     if (connection != null) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                     if (connection != null) {
1:                     }
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:4e63ee7
/////////////////////////////////////////////////////////////////////////
1:     private static final String dlqPrefix = "ActiveMQ.DLQ.Queue.";
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:6579d9e
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.virtual;
1: 
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.ExceptionListener;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
0: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQMessageProducer;
1: import org.apache.activemq.ActiveMQSession;
1: import org.apache.activemq.RedeliveryPolicy;
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Unit test for virtual topics and DLQ messaging. See individual test for more
1:  * detail
1:  *
1:  */
1: public class VirtualTopicDLQTest extends TestCase {
1:     private static BrokerService broker;
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(VirtualTopicDLQTest.class);
1: 
1:     static final String jmsConnectionURI = "failover:(vm://localhost)";
1: 
1:     // Virtual Topic that the test publishes 10 messages to
1:     private static final String virtualTopicName = "VirtualTopic.Test";
1: 
1:     // Queues that receive all the messages send to the virtual topic
1:     private static final String consumer1Prefix = "Consumer.A.";
1:     private static final String consumer2Prefix = "Consumer.B.";
1:     private static final String consumer3Prefix = "Consumer.C.";
1: 
1:     // Expected Individual Dead Letter Queue names that are tied to the
1:     // Subscriber Queues
0:     private static final String dlqPrefix = "ActiveMQ.DLQ.Topic.";
1: 
1:     // Number of messages
1:     private static final int numberMessages = 6;
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:         try {
1:             broker = BrokerFactory.createBroker("xbean:org/apache/activemq/broker/virtual/virtual-individual-dlq.xml", true);
1:             broker.start();
1:             broker.waitUntilStarted();
1:         } catch (Exception e) {
1:             e.printStackTrace();
1:             throw e;
1:         }
1:     }
1: 
1:     @After
1:     public void tearDown() throws Exception {
1:         try {
1:             // Purge the DLQ's so counts are correct for next run
1:             purgeDestination(dlqPrefix + consumer1Prefix + virtualTopicName);
1:             purgeDestination(dlqPrefix + consumer2Prefix + virtualTopicName);
1:             purgeDestination(dlqPrefix + consumer3Prefix + virtualTopicName);
1:         } catch (Exception e) {
1:             e.printStackTrace();
1:         }
1: 
1:         if (broker != null) {
1:             broker.stop();
1:             broker.waitUntilStopped();
1:             broker = null;
1:         }
1:     }
1: 
1:     /*
1:      * This test verifies that all undelivered messages sent to a consumers
1:      * listening on a queue associated with a virtual topic with be forwarded to
1:      * separate DLQ's.
1:      *
1:      * Note that the broker config, deadLetterStrategy need to have the enable
1:      * audit set to false so that duplicate message sent from a topic to
1:      * individual consumers are forwarded to the DLQ
1:      *
1:      * <deadLetterStrategy> <bean
1:      * xmlns="http://www.springframework.org/schema/beans"
1:      * class="org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy"
1:      * > <property name="useQueueForQueueMessages" value="true"></property>
1:      * <property name="processNonPersistent" value="true"></property> <property
1:      * name="processExpired" value="false"></property> <property
1:      * name="enableAudit" value="false"></property>
1:      *
1:      * </bean> </deadLetterStrategy>
1:      */
1:     @Test
1:     public void testVirtualTopicSubscriberDeadLetterQueue() throws Exception {
1: 
1:         TestConsumer consumer1 = null;
1:         TestConsumer consumer2 = null;
1:         TestConsumer consumer3 = null;
1:         TestConsumer dlqConsumer1 = null;
1:         TestConsumer dlqConsumer2 = null;
1:         TestConsumer dlqConsumer3 = null;
1: 
1:         try {
1: 
1:             // The first 2 consumers will rollback, ultimately causing messages
1:             // to land on the DLQ
1:             consumer1 = new TestConsumer(consumer1Prefix + virtualTopicName, false, numberMessages, true);
1:             thread(consumer1, false);
1: 
1:             consumer2 = new TestConsumer(consumer2Prefix + virtualTopicName, false, numberMessages, true);
1:             thread(consumer2, false);
1: 
1:             // TestConsumer that does not throw exceptions, messages should not
1:             // land on DLQ
1:             consumer3 = new TestConsumer(consumer3Prefix + virtualTopicName, false, numberMessages, false);
1:             thread(consumer3, false);
1: 
1:             // TestConsumer to read the expected Dead Letter Queue
1:             dlqConsumer1 = new TestConsumer(dlqPrefix + consumer1Prefix + virtualTopicName, false, numberMessages, false);
1:             thread(dlqConsumer1, false);
1: 
1:             dlqConsumer2 = new TestConsumer(dlqPrefix + consumer2Prefix + virtualTopicName, false, numberMessages, false);
1:             thread(dlqConsumer2, false);
1: 
1:             dlqConsumer3 = new TestConsumer(dlqPrefix + consumer3Prefix + virtualTopicName, false, numberMessages, false);
1:             thread(dlqConsumer3, false);
1: 
1:             // Give the consumers a second to start
1:             Thread.sleep(1000);
1: 
1:             // Start the producer
1:             TestProducer producer = new TestProducer(virtualTopicName, true, numberMessages);
1:             thread(producer, false);
1: 
1:             assertTrue("sent all producer messages in time, count is: " + producer.getLatch().getCount(), producer.getLatch().await(10, TimeUnit.SECONDS));
1:             LOG.info("producer successful, count = " + producer.getLatch().getCount());
1: 
1:             assertTrue("remaining consumer1 count should be zero, is: " + consumer1.getLatch().getCount(), consumer1.getLatch().await(10, TimeUnit.SECONDS));
1:             LOG.info("consumer1 successful, count = " + consumer1.getLatch().getCount());
1: 
1:             assertTrue("remaining consumer2 count should be zero, is: " + consumer2.getLatch().getCount(), consumer2.getLatch().await(10, TimeUnit.SECONDS));
1:             LOG.info("consumer2 successful, count = " + consumer2.getLatch().getCount());
1: 
1:             assertTrue("remaining consumer3 count should be zero, is: " + consumer3.getLatch().getCount(), consumer3.getLatch().await(10, TimeUnit.SECONDS));
1:             LOG.info("consumer3 successful, count = " + consumer3.getLatch().getCount());
1: 
1:             assertTrue("remaining dlqConsumer1 count should be zero, is: " + dlqConsumer1.getLatch().getCount(),
1:                 dlqConsumer1.getLatch().await(10, TimeUnit.SECONDS));
1:             LOG.info("dlqConsumer1 successful, count = " + dlqConsumer1.getLatch().getCount());
1: 
1:             assertTrue("remaining dlqConsumer2 count should be zero, is: " + dlqConsumer2.getLatch().getCount(),
1:                 dlqConsumer2.getLatch().await(10, TimeUnit.SECONDS));
1:             LOG.info("dlqConsumer2 successful, count = " + dlqConsumer2.getLatch().getCount());
1: 
1:             assertTrue("remaining dlqConsumer3 count should be " + numberMessages + ", is: " + dlqConsumer3.getLatch().getCount(), dlqConsumer3.getLatch()
1:                 .getCount() == numberMessages);
1:             LOG.info("dlqConsumer2 successful, count = " + dlqConsumer2.getLatch().getCount());
1: 
1:         } catch (Exception e) {
1:             e.printStackTrace();
1:             throw e;
1:         } finally {
1:             // Tell consumers to stop (don't read any more messages after this)
1:             if (consumer1 != null)
1:                 consumer1.setStop(true);
1:             if (consumer2 != null)
1:                 consumer2.setStop(true);
1:             if (consumer3 != null)
1:                 consumer3.setStop(true);
1:             if (dlqConsumer1 != null)
1:                 dlqConsumer1.setStop(true);
1:             if (dlqConsumer2 != null)
1:                 dlqConsumer2.setStop(true);
1:             if (dlqConsumer3 != null)
1:                 dlqConsumer3.setStop(true);
1:         }
1:     }
1: 
1:     private static Thread thread(Runnable runnable, boolean daemon) {
1:         Thread brokerThread = new Thread(runnable);
1:         brokerThread.setDaemon(daemon);
1:         brokerThread.start();
1:         return brokerThread;
1:     }
1: 
1:     private class TestProducer implements Runnable {
1:         private String destinationName = null;
1:         private boolean isTopic = true;
1:         private int numberMessages = 0;
1:         private CountDownLatch latch = null;
1: 
1:         public TestProducer(String destinationName, boolean isTopic, int numberMessages) {
1:             this.destinationName = destinationName;
1:             this.isTopic = isTopic;
1:             this.numberMessages = numberMessages;
1:             latch = new CountDownLatch(numberMessages);
1:         }
1: 
1:         public CountDownLatch getLatch() {
1:             return latch;
1:         }
1: 
1:         public void run() {
1:             ActiveMQConnectionFactory connectionFactory = null;
1:             ActiveMQConnection connection = null;
1:             ActiveMQSession session = null;
1:             Destination destination = null;
1: 
1:             try {
1:                 LOG.info("Started TestProducer for destination (" + destinationName + ")");
1: 
1:                 connectionFactory = new ActiveMQConnectionFactory(jmsConnectionURI);
1:                 connection = (ActiveMQConnection) connectionFactory.createConnection();
1:                 connection.start();
1:                 session = (ActiveMQSession) connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:                 if (isTopic) {
1:                     destination = session.createTopic(this.destinationName);
1:                 } else {
1:                     destination = session.createQueue(this.destinationName);
1:                 }
1: 
1:                 // Create a MessageProducer from the Session to the Topic or
1:                 // Queue
1:                 ActiveMQMessageProducer producer = (ActiveMQMessageProducer) session.createProducer(destination);
1:                 producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1: 
1:                 for (int i = 0; i < numberMessages; i++) {
0:                     TextMessage message = (TextMessage) session.createTextMessage("I am a message :: " + String.valueOf(i));
1:                     try {
1:                         producer.send(message);
1: 
1:                     } catch (Exception deeperException) {
1:                         LOG.info("Producer for destination (" + destinationName + ") Caught: " + deeperException);
1:                     }
1: 
1:                     latch.countDown();
1:                     Thread.sleep(1000);
1:                 }
1: 
1:                 LOG.info("Finished TestProducer for destination (" + destinationName + ")");
1: 
1:             } catch (Exception e) {
1:                 LOG.error("Terminating TestProducer(" + destinationName + ")Caught: " + e);
1:                 e.printStackTrace();
1: 
1:             } finally {
1:                 try {
1:                     // Clean up
0:                     if (session != null)
0:                         session.close();
0:                     if (connection != null)
1:                         connection.close();
1: 
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                     LOG.error("Closing connection/session (" + destinationName + ")Caught: " + e);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private class TestConsumer implements Runnable, ExceptionListener, MessageListener {
1:         private String destinationName = null;
1:         private boolean isTopic = true;
1:         private CountDownLatch latch = null;
1:         private int maxRedeliveries = 0;
1:         private int receivedMessageCounter = 0;
1:         private boolean bFakeFail = false;
1:         private boolean bStop = false;
1: 
1:         private ActiveMQConnectionFactory connectionFactory = null;
1:         private ActiveMQConnection connection = null;
1:         private Session session = null;
1:         private MessageConsumer consumer = null;
1: 
1:         public TestConsumer(String destinationName, boolean isTopic, int expectedNumberMessages, boolean bFakeFail) {
1:             this.destinationName = destinationName;
1:             this.isTopic = isTopic;
1:             latch = new CountDownLatch(expectedNumberMessages * (this.bFakeFail ? (maxRedeliveries + 1) : 1));
1:             this.bFakeFail = bFakeFail;
1:         }
1: 
1:         public CountDownLatch getLatch() {
1:             return latch;
1:         }
1: 
1:         public void run() {
1: 
1:             try {
1:                 LOG.info("Started TestConsumer for destination (" + destinationName + ")");
1: 
1:                 connectionFactory = new ActiveMQConnectionFactory(jmsConnectionURI);
1:                 connection = (ActiveMQConnection) connectionFactory.createConnection();
1:                 connection.start();
1:                 session = connection.createSession(true, Session.SESSION_TRANSACTED);
1: 
1:                 RedeliveryPolicy policy = connection.getRedeliveryPolicy();
1:                 policy.setInitialRedeliveryDelay(1);
1:                 policy.setUseExponentialBackOff(false);
1:                 policy.setMaximumRedeliveries(maxRedeliveries);
1: 
1:                 connection.setExceptionListener(this);
1: 
1:                 Destination destination = null;
1:                 if (isTopic) {
1:                     destination = session.createTopic(destinationName);
1:                 } else {
1:                     destination = session.createQueue(destinationName);
1:                 }
1: 
1:                 consumer = session.createConsumer(destination);
1:                 consumer.setMessageListener(this);
1: 
1:                 while (!bStop) {
1:                     Thread.sleep(100);
1:                 }
1: 
1:                 LOG.info("Finished TestConsumer for destination name (" + destinationName + ") remaining " + this.latch.getCount() + " messages "
1:                     + this.toString());
1: 
1:             } catch (Exception e) {
1:                 LOG.error("Consumer (" + destinationName + ") Caught: " + e);
1:                 e.printStackTrace();
1:             } finally {
1:                 try {
1:                     // Clean up
0:                     if (consumer != null)
0:                         consumer.close();
0:                     if (session != null)
0:                         session.close();
0:                     if (connection != null)
1:                         connection.close();
1: 
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                     LOG.error("Closing connection/session (" + destinationName + ")Caught: " + e);
1:                 }
1:             }
1:         }
1: 
1:         public synchronized void onException(JMSException ex) {
1:             ex.printStackTrace();
1:             LOG.error("Consumer for destination, (" + destinationName + "), JMS Exception occured.  Shutting down client.");
1:         }
1: 
1:         public synchronized void setStop(boolean bStop) {
1:             this.bStop = bStop;
1:         }
1: 
1:         public synchronized void onMessage(Message message) {
1:             receivedMessageCounter++;
1:             latch.countDown();
1: 
1:             LOG.info("Consumer for destination (" + destinationName + ") latch countdown: " + latch.getCount() + " :: Number messages received "
1:                 + this.receivedMessageCounter);
1: 
1:             try {
1:                 LOG.info("Consumer for destination (" + destinationName + ") Received message id :: " + message.getJMSMessageID());
1: 
1:                 if (!bFakeFail) {
1:                     LOG.info("Consumer on destination " + destinationName + " committing JMS Session for message: " + message.toString());
1:                     session.commit();
1:                 } else {
1:                     LOG.info("Consumer on destination " + destinationName + " rolling back JMS Session for message: " + message.toString());
1:                     session.rollback(); // rolls back all the consumed messages
1:                                         // on the session to
1:                 }
1: 
1:             } catch (JMSException ex) {
1:                 ex.printStackTrace();
1:                 LOG.error("Error reading JMS Message from destination " + destinationName + ".");
1:             }
1:         }
1:     }
1: 
1:     private static void purgeDestination(String destination) throws Exception {
1:         final Queue dest = (Queue) ((RegionBroker) broker.getRegionBroker()).getQueueRegion().getDestinationMap().get(new ActiveMQQueue(destination));
1:         dest.purge();
1:         assertEquals(0, dest.getDestinationStatistics().getMessages().getCount());
1:     }
1: }
============================================================================