1:d29ca2a: /**
1:7f883f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7f883f6:  * contributor license agreements.  See the NOTICE file distributed with
1:7f883f6:  * this work for additional information regarding copyright ownership.
1:7f883f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7f883f6:  * (the "License"); you may not use this file except in compliance with
1:7f883f6:  * the License.  You may obtain a copy of the License at
1:d226f50:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:230a86c:  *
1:7f883f6:  * Unless required by applicable law or agreed to in writing, software
1:7f883f6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7f883f6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7f883f6:  * See the License for the specific language governing permissions and
1:7f883f6:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
1:83fde0b: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.net.URI;
1:d29ca2a: import java.net.URISyntaxException;
1:08d7977: import java.util.ArrayList;
1:08d7977: import java.util.HashMap;
1:08d7977: import java.util.Iterator;
1:08d7977: import java.util.List;
1:08d7977: import java.util.Map;
1:59b38fc: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:59b38fc: import java.util.concurrent.CopyOnWriteArrayList;
1:59b38fc: import java.util.concurrent.CountDownLatch;
1:59b38fc: import java.util.concurrent.LinkedBlockingQueue;
1:e3fcf71: import java.util.concurrent.RejectedExecutionHandler;
1:59b38fc: import java.util.concurrent.ThreadFactory;
1:59b38fc: import java.util.concurrent.ThreadPoolExecutor;
1:59b38fc: import java.util.concurrent.TimeUnit;
1:1a3f54c: import java.util.concurrent.atomic.AtomicBoolean;
1:1a3f54c: import java.util.concurrent.atomic.AtomicInteger;
1:97ae323: 
1:d29ca2a: import javax.jms.Connection;
1:d29ca2a: import javax.jms.ConnectionConsumer;
1:d29ca2a: import javax.jms.ConnectionMetaData;
1:d29ca2a: import javax.jms.Destination;
1:d29ca2a: import javax.jms.ExceptionListener;
1:d29ca2a: import javax.jms.IllegalStateException;
1:d29ca2a: import javax.jms.InvalidDestinationException;
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.Queue;
1:d29ca2a: import javax.jms.QueueConnection;
1:d29ca2a: import javax.jms.QueueSession;
1:d29ca2a: import javax.jms.ServerSessionPool;
1:d29ca2a: import javax.jms.Session;
1:d29ca2a: import javax.jms.Topic;
1:d29ca2a: import javax.jms.TopicConnection;
1:d29ca2a: import javax.jms.TopicSession;
1:d29ca2a: import javax.jms.XAConnection;
1:97ae323: 
1:204f91f: import org.apache.activemq.advisory.DestinationSource;
1:1a3f54c: import org.apache.activemq.blob.BlobTransferPolicy;
1:a3836b5: import org.apache.activemq.broker.region.policy.RedeliveryPolicyMap;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQMessage;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTempDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTempQueue;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTempTopic;
1:d29ca2a: import org.apache.activemq.command.BrokerInfo;
1:d29ca2a: import org.apache.activemq.command.Command;
1:1a3f54c: import org.apache.activemq.command.CommandTypes;
1:ef0734b: import org.apache.activemq.command.ConnectionControl;
1:6397d05: import org.apache.activemq.command.ConnectionError;
1:d29ca2a: import org.apache.activemq.command.ConnectionId;
1:d29ca2a: import org.apache.activemq.command.ConnectionInfo;
1:ef0734b: import org.apache.activemq.command.ConsumerControl;
1:d29ca2a: import org.apache.activemq.command.ConsumerId;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.ControlCommand;
1:d29ca2a: import org.apache.activemq.command.DestinationInfo;
1:d29ca2a: import org.apache.activemq.command.ExceptionResponse;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageDispatch;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:c9bb1c9: import org.apache.activemq.command.ProducerAck;
1:d29ca2a: import org.apache.activemq.command.ProducerId;
1:3b08860: import org.apache.activemq.command.RemoveInfo;
1:d29ca2a: import org.apache.activemq.command.RemoveSubscriptionInfo;
1:d29ca2a: import org.apache.activemq.command.Response;
1:d29ca2a: import org.apache.activemq.command.SessionId;
1:d29ca2a: import org.apache.activemq.command.ShutdownInfo;
1:1a3f54c: import org.apache.activemq.command.WireFormatInfo;
1:d29ca2a: import org.apache.activemq.management.JMSConnectionStatsImpl;
1:d29ca2a: import org.apache.activemq.management.JMSStatsImpl;
1:d29ca2a: import org.apache.activemq.management.StatsCapable;
1:d29ca2a: import org.apache.activemq.management.StatsImpl;
1:fb3b6db: import org.apache.activemq.state.CommandVisitorAdapter;
1:1a5ad28: import org.apache.activemq.thread.Scheduler;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:d4cd7f9: import org.apache.activemq.transport.FutureResponse;
1:ad1f751: import org.apache.activemq.transport.RequestTimedOutIOException;
1:d4cd7f9: import org.apache.activemq.transport.ResponseCallback;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:d29ca2a: import org.apache.activemq.transport.TransportListener;
1:8d3ca90: import org.apache.activemq.transport.failover.FailoverTransport;
1:d29ca2a: import org.apache.activemq.util.IdGenerator;
1:d29ca2a: import org.apache.activemq.util.IntrospectionSupport;
1:d29ca2a: import org.apache.activemq.util.JMSExceptionSupport;
1:d29ca2a: import org.apache.activemq.util.LongSequenceGenerator;
1:d29ca2a: import org.apache.activemq.util.ServiceSupport;
1:6c1676b: import org.apache.activemq.util.ThreadPoolUtils;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:230a86c: 
1:8858dc2: public class ActiveMQConnection implements Connection, TopicConnection, QueueConnection, StatsCapable, Closeable, TransportListener, EnhancedConnection {
1:d71bc42: 
1:d29ca2a:     public static final String DEFAULT_USER = ActiveMQConnectionFactory.DEFAULT_USER;
1:d29ca2a:     public static final String DEFAULT_PASSWORD = ActiveMQConnectionFactory.DEFAULT_PASSWORD;
1:d29ca2a:     public static final String DEFAULT_BROKER_URL = ActiveMQConnectionFactory.DEFAULT_BROKER_URL;
1:c33231b:     public static int DEFAULT_THREAD_POOL_SIZE = 1000;
1:fc00993: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQConnection.class);
1:fc00993: 
1:db8c771:     public final ConcurrentMap<ActiveMQTempDestination, ActiveMQTempDestination> activeTempDestinations = new ConcurrentHashMap<>();
1:230a86c: 
1:62fb85e:     protected boolean dispatchAsync=true;
1:fc00993:     protected boolean alwaysSessionAsync = true;
1:fc00993: 
1:c808beb:     private TaskRunnerFactory sessionTaskRunner;
1:1a5ad28:     private final ThreadPoolExecutor executor;
1:fc00993: 
1:d29ca2a:     // Connection state variables
1:d29ca2a:     private final ConnectionInfo info;
1:d29ca2a:     private ExceptionListener exceptionListener;
1:0acf545:     private ClientInternalExceptionListener clientInternalExceptionListener;
1:d29ca2a:     private boolean clientIDSet;
1:d29ca2a:     private boolean isConnectionInfoSentToBroker;
1:d29ca2a:     private boolean userSpecifiedClientID;
1:230a86c: 
1:d29ca2a:     // Configuration options variables
1:d29ca2a:     private ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
1:05a8cba:     private BlobTransferPolicy blobTransferPolicy;
1:a3836b5:     private RedeliveryPolicyMap redeliveryPolicyMap;
1:86faaef:     private MessageTransformer transformer;
1:dcf7dea: 
1:230a86c:     private boolean disableTimeStampsByDefault;
1:d29ca2a:     private boolean optimizedMessageDispatch = true;
1:d29ca2a:     private boolean copyMessageOnSend = true;
1:230a86c:     private boolean useCompression;
1:230a86c:     private boolean objectMessageSerializationDefered;
1:230a86c:     private boolean useAsyncSend;
1:230a86c:     private boolean optimizeAcknowledge;
1:975fc55:     private long optimizeAcknowledgeTimeOut = 0;
1:3d5a758:     private long optimizedAckScheduledAckInterval = 0;
1:ca067a6:     private boolean nestedMapAndListEnabled = true;
1:d29ca2a:     private boolean useRetroactiveConsumer;
1:3d862f0:     private boolean exclusiveConsumer;
1:4e2acd4:     private boolean alwaysSyncSend;
1:5fe0a4c:     private int closeTimeout = 15000;
1:230a86c:     private boolean watchTopicAdvisories = true;
1:78cf4b1:     private long warnAboutUnstartedConnectionTimeout = 500L;
1:114a923:     private int sendTimeout =0;
1:d8b5d5c:     private boolean sendAcksAsync=true;
1:794e62f:     private boolean checkForDuplicates = true;
1:6da702b:     private boolean queueOnlyConnection = false;
1:642cc43:     private boolean consumerExpiryCheckEnabled = true;
1:dcf7dea: 
1:d29ca2a:     private final Transport transport;
1:7339c6e:     private final IdGenerator clientIdGenerator;
1:d29ca2a:     private final JMSStatsImpl factoryStats;
1:d29ca2a:     private final JMSConnectionStatsImpl stats;
1:230a86c: 
1:d29ca2a:     private final AtomicBoolean started = new AtomicBoolean(false);
1:d29ca2a:     private final AtomicBoolean closing = new AtomicBoolean(false);
1:d29ca2a:     private final AtomicBoolean closed = new AtomicBoolean(false);
1:36a2bdc:     private final AtomicBoolean transportFailed = new AtomicBoolean(false);
1:db8c771:     private final CopyOnWriteArrayList<ActiveMQSession> sessions = new CopyOnWriteArrayList<>();
1:db8c771:     private final CopyOnWriteArrayList<ActiveMQConnectionConsumer> connectionConsumers = new CopyOnWriteArrayList<>();
1:db8c771:     private final CopyOnWriteArrayList<TransportListener> transportListeners = new CopyOnWriteArrayList<>();
1:dcf7dea: 
1:d29ca2a:     // Maps ConsumerIds to ActiveMQConsumer objects
1:db8c771:     private final ConcurrentMap<ConsumerId, ActiveMQDispatcher> dispatchers = new ConcurrentHashMap<>();
1:db8c771:     private final ConcurrentMap<ProducerId, ActiveMQMessageProducer> producers = new ConcurrentHashMap<>();
1:d29ca2a:     private final LongSequenceGenerator sessionIdGenerator = new LongSequenceGenerator();
1:d29ca2a:     private final SessionId connectionSessionId;
1:d29ca2a:     private final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
1:d29ca2a:     private final LongSequenceGenerator tempDestinationIdGenerator = new LongSequenceGenerator();
1:d29ca2a:     private final LongSequenceGenerator localTransactionIdGenerator = new LongSequenceGenerator();
1:dcf7dea: 
1:d29ca2a:     private AdvisoryConsumer advisoryConsumer;
1:d29ca2a:     private final CountDownLatch brokerInfoReceived = new CountDownLatch(1);
1:90e21b4:     private BrokerInfo brokerInfo;
1:daf48bb:     private IOException firstFailureError;
1:230a86c:     private int producerWindowSize = ActiveMQConnectionFactory.DEFAULT_PRODUCER_WINDOW_SIZE;
1:230a86c: 
1:230a86c:     // Assume that protocol is the latest. Change to the actual protocol
1:1a3f54c:     // version when a WireFormatInfo is received.
1:204f91f:     private final AtomicInteger protocolVersion = new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
1:204f91f:     private final long timeCreated;
1:204f91f:     private final ConnectionAudit connectionAudit = new ConnectionAudit();
1:f6efc56:     private DestinationSource destinationSource;
1:1555260:     private final Object ensureConnectionInfoSentMutex = new Object();
1:c808beb:     private boolean useDedicatedTaskRunner;
1:dc0291b:     protected AtomicInteger transportInterruptionProcessingComplete = new AtomicInteger(0);
1:b836af8:     private long consumerFailoverRedeliveryWaitPeriod;
1:97ae323:     private Scheduler scheduler;
1:bbb2acc:     private boolean messagePrioritySupported = false;
1:2030097:     private boolean transactedIndividualAck = false;
1:0b6bf7e:     private boolean nonBlockingRedelivery = false;
1:221a751:     private boolean rmIdFromConnectionId = false;
1:1a3f54c: 
1:c33231b:     private int maxThreadPoolSize = DEFAULT_THREAD_POOL_SIZE;
1:e3fcf71:     private RejectedExecutionHandler rejectedTaskHandler = null;
1:b1cd2b9: 
1:db8c771:     private List<String> trustedPackages = new ArrayList<>();
1:94446e5:     private boolean trustAllPackages = false;
1:db8c771:     private int connectResponseTimeout;
1:94446e5: 
1:d29ca2a:     /**
1:d29ca2a:      * Construct an <code>ActiveMQConnection</code>
1:d226f50:      *
1:230a86c:      * @param transport
1:d29ca2a:      * @param factoryStats
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:b9045db:     protected ActiveMQConnection(final Transport transport, IdGenerator clientIdGenerator, IdGenerator connectionIdGenerator, JMSStatsImpl factoryStats) throws Exception {
1:230a86c: 
1:90e21b4:         this.transport = transport;
1:7339c6e:         this.clientIdGenerator = clientIdGenerator;
1:90e21b4:         this.factoryStats = factoryStats;
1:230a86c: 
1:230a86c:         // Configure a single threaded executor who's core thread can timeout if
1:230a86c:         // idle
1:1a5ad28:         executor = new ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
1:849baa6:             @Override
1:dcf7dea:             public Thread newThread(Runnable r) {
1:1a5ad28:                 Thread thread = new Thread(r, "ActiveMQ Connection Executor: " + transport);
1:9287816:                 //Don't make these daemon threads - see https://issues.apache.org/jira/browse/AMQ-796
1:9287816:                 //thread.setDaemon(true);
1:e2aad41:                 return thread;
1:230a86c:             }
1:230a86c:         });
1:230a86c:         // asyncConnectionThread.allowCoreThreadTimeOut(true);
1:b9045db:         String uniqueId = connectionIdGenerator.generateId();
1:1a5ad28:         this.info = new ConnectionInfo(new ConnectionId(uniqueId));
1:ef0734b:         this.info.setManageable(true);
1:f392884:         this.info.setFaultTolerant(transport.isFaultTolerant());
1:d29ca2a:         this.connectionSessionId = new SessionId(info.getConnectionId(), -1);
1:3d5a758: 
1:d29ca2a:         this.transport.setTransportListener(this);
1:3d5a758: 
1:90e21b4:         this.stats = new JMSConnectionStatsImpl(sessions, this instanceof XAConnection);
1:90e21b4:         this.factoryStats.addConnection(this);
1:78cf4b1:         this.timeCreated = System.currentTimeMillis();
1:cbaa58b:         this.connectionAudit.setCheckForDuplicates(transport.isFaultTolerant());
1:9df9d3e:     }
1:a3836b5: 
1:90e21b4:     protected void setUserName(String userName) {
1:90e21b4:         this.info.setUserName(userName);
1:1a3f54c:     }
1:d226f50: 
1:90e21b4:     protected void setPassword(String password) {
2:d29ca2a:         this.info.setPassword(password);
1:dcf7dea:     }
1:d226f50: 
1:a3836b5:     /**
1:d29ca2a:      * A static helper method to create a new connection
1:d226f50:      *
1:d29ca2a:      * @return an ActiveMQConnection
17:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public static ActiveMQConnection makeConnection() throws JMSException {
1:d29ca2a:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory();
1:230a86c:         return (ActiveMQConnection)factory.createConnection();
1:6397d05:     }
1:d226f50: 
1:d29ca2a:     /**
1:d29ca2a:      * A static helper method to create a new connection
1:d226f50:      *
1:d29ca2a:      * @param uri
1:d29ca2a:      * @return and ActiveMQConnection
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public static ActiveMQConnection makeConnection(String uri) throws JMSException, URISyntaxException {
1:d29ca2a:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(uri);
1:230a86c:         return (ActiveMQConnection)factory.createConnection();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * A static helper method to create a new connection
1:d226f50:      *
1:d29ca2a:      * @param user
2:d29ca2a:      * @param password
1:d29ca2a:      * @param uri
1:d29ca2a:      * @return an ActiveMQConnection
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:230a86c:     public static ActiveMQConnection makeConnection(String user, String password, String uri) throws JMSException, URISyntaxException {
1:d29ca2a:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(user, password, new URI(uri));
1:230a86c:         return (ActiveMQConnection)factory.createConnection();
1:90e21b4:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * @return a number unique for this connection
1:d29ca2a:      */
1:d29ca2a:     public JMSConnectionStatsImpl getConnectionStats() {
1:d29ca2a:         return stats;
1:90e21b4:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>Session</CODE> object.
1:d226f50:      *
1:230a86c:      * @param transacted indicates whether the session is transacted
1:230a86c:      * @param acknowledgeMode indicates whether the consumer or the client will
1:230a86c:      *                acknowledge any messages it receives; ignored if the
1:230a86c:      *                session is transacted. Legal values are
1:230a86c:      *                <code>Session.AUTO_ACKNOWLEDGE</code>,
1:230a86c:      *                <code>Session.CLIENT_ACKNOWLEDGE</code>, and
1:230a86c:      *                <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:d29ca2a:      * @return a newly created session
1:230a86c:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:230a86c:      *                 create a session due to some internal error or lack of
1:230a86c:      *                 support for the specific transaction and acknowledgement
1:230a86c:      *                 mode.
1:d29ca2a:      * @see Session#AUTO_ACKNOWLEDGE
1:d29ca2a:      * @see Session#CLIENT_ACKNOWLEDGE
1:d29ca2a:      * @see Session#DUPS_OK_ACKNOWLEDGE
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:849baa6:     @Override
1:230a86c:     public Session createSession(boolean transacted, int acknowledgeMode) throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
3:d29ca2a:         ensureConnectionInfoSent();
1:08d7977:         if (!transacted) {
1:08d7977:             if (acknowledgeMode == Session.SESSION_TRANSACTED) {
1:f570349:                 throw new JMSException("acknowledgeMode SESSION_TRANSACTED cannot be used for an non-transacted Session");
1:ab438f6:             } else if (acknowledgeMode < Session.SESSION_TRANSACTED || acknowledgeMode > ActiveMQSession.MAX_ACK_CONSTANT) {
1:ab438f6:                 throw new JMSException("invalid acknowledgeMode: " + acknowledgeMode + ". Valid values are Session.AUTO_ACKNOWLEDGE (1), " +
1:ab438f6:                         "Session.CLIENT_ACKNOWLEDGE (2), Session.DUPS_OK_ACKNOWLEDGE (3), ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE (4) or for transacted sessions Session.SESSION_TRANSACTED (0)");
1:d29ca2a:             }
1:d29ca2a:         }
1:08d7977:         return new ActiveMQSession(this, getNextSessionId(), transacted ? Session.SESSION_TRANSACTED : acknowledgeMode, isDispatchAsync(), isAlwaysSessionAsync());
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d964145:      * @return sessionId
1:d29ca2a:      */
1:d29ca2a:     protected SessionId getNextSessionId() {
1:d29ca2a:         return new SessionId(info.getConnectionId(), sessionIdGenerator.getNextSequenceId());
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Gets the client identifier for this connection.
1:d29ca2a:      * <P>
1:d29ca2a:      * This value is specific to the JMS provider. It is either preconfigured by
1:d29ca2a:      * an administrator in a <CODE> ConnectionFactory</CODE> object or assigned
1:d29ca2a:      * dynamically by the application by calling the <code>setClientID</code>
1:d29ca2a:      * method.
1:d226f50:      *
1:d29ca2a:      * @return the unique client identifier
1:230a86c:      * @throws JMSException if the JMS provider fails to return the client ID
1:230a86c:      *                 for this connection due to some internal error.
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public String getClientID() throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         return this.info.getClientId();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the client identifier for this connection.
1:d29ca2a:      * <P>
1:d29ca2a:      * The preferred way to assign a JMS client's client identifier is for it to
1:d29ca2a:      * be configured in a client-specific <CODE>ConnectionFactory</CODE>
1:d29ca2a:      * object and transparently assigned to the <CODE>Connection</CODE> object
1:d29ca2a:      * it creates.
1:d29ca2a:      * <P>
1:d29ca2a:      * Alternatively, a client can set a connection's client identifier using a
1:d29ca2a:      * provider-specific value. The facility to set a connection's client
1:d29ca2a:      * identifier explicitly is not a mechanism for overriding the identifier
1:d29ca2a:      * that has been administratively configured. It is provided for the case
1:d29ca2a:      * where no administratively specified identifier exists. If one does exist,
1:230a86c:      * an attempt to change it by setting it must throw an
1:230a86c:      * <CODE>IllegalStateException</CODE>. If a client sets the client
1:230a86c:      * identifier explicitly, it must do so immediately after it creates the
1:230a86c:      * connection and before any other action on the connection is taken. After
1:230a86c:      * this point, setting the client identifier is a programming error that
1:230a86c:      * should throw an <CODE>IllegalStateException</CODE>.
1:d29ca2a:      * <P>
1:d29ca2a:      * The purpose of the client identifier is to associate a connection and its
1:d29ca2a:      * objects with a state maintained on behalf of the client by a provider.
1:d29ca2a:      * The only such state identified by the JMS API is that required to support
1:d29ca2a:      * durable subscriptions.
1:d29ca2a:      * <P>
1:d29ca2a:      * If another connection with the same <code>clientID</code> is already
1:d29ca2a:      * running when this method is called, the JMS provider should detect the
1:d29ca2a:      * duplicate ID and throw an <CODE>InvalidClientIDException</CODE>.
1:d226f50:      *
1:230a86c:      * @param newClientID the unique client identifier
1:230a86c:      * @throws JMSException if the JMS provider fails to set the client ID for
1:230a86c:      *                 this connection due to some internal error.
1:230a86c:      * @throws javax.jms.InvalidClientIDException if the JMS client specifies an
1:230a86c:      *                 invalid or duplicate client ID.
1:230a86c:      * @throws javax.jms.IllegalStateException if the JMS client attempts to set
1:230a86c:      *                 a connection's client ID at the wrong time or when it has
1:230a86c:      *                 been administratively configured.
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public void setClientID(String newClientID) throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:230a86c: 
1:d29ca2a:         if (this.clientIDSet) {
1:d29ca2a:             throw new IllegalStateException("The clientID has already been set");
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         if (this.isConnectionInfoSentToBroker) {
1:d29ca2a:             throw new IllegalStateException("Setting clientID on a used Connection is not allowed");
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         this.info.setClientId(newClientID);
1:d29ca2a:         this.userSpecifiedClientID = true;
1:d29ca2a:         ensureConnectionInfoSent();
1:d29ca2a:     }
1:230a86c: 
1:d71bc42:     /**
1:230a86c:      * Sets the default client id that the connection will use if explicitly not
1:230a86c:      * set with the setClientId() call.
1:d71bc42:      */
1:d71bc42:     public void setDefaultClientID(String clientID) throws JMSException {
1:d71bc42:         this.info.setClientId(clientID);
1:d71bc42:         this.userSpecifiedClientID = true;
1:d71bc42:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Gets the metadata for this connection.
1:d226f50:      *
1:d29ca2a:      * @return the connection metadata
1:230a86c:      * @throws JMSException if the JMS provider fails to get the connection
1:230a86c:      *                 metadata for this connection.
1:d29ca2a:      * @see javax.jms.ConnectionMetaData
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public ConnectionMetaData getMetaData() throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         return ActiveMQConnectionMetaData.INSTANCE;
1:d29ca2a:     }
1:c9bb1c9: 
1:d29ca2a:     /**
1:d29ca2a:      * Gets the <CODE>ExceptionListener</CODE> object for this connection. Not
1:d29ca2a:      * every <CODE>Connection</CODE> has an <CODE>ExceptionListener</CODE>
1:d29ca2a:      * associated with it.
1:d226f50:      *
1:d29ca2a:      * @return the <CODE>ExceptionListener</CODE> for this connection, or
1:0acf545:      *         null, if no <CODE>ExceptionListener</CODE> is associated with
1:d29ca2a:      *         this connection.
1:230a86c:      * @throws JMSException if the JMS provider fails to get the
1:230a86c:      *                 <CODE>ExceptionListener</CODE> for this connection.
1:d29ca2a:      * @see javax.jms.Connection#setExceptionListener(ExceptionListener)
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public ExceptionListener getExceptionListener() throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         return this.exceptionListener;
1:d29ca2a:     }
1:1a3f54c: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets an exception listener for this connection.
1:d29ca2a:      * <P>
1:d29ca2a:      * If a JMS provider detects a serious problem with a connection, it informs
1:d29ca2a:      * the connection's <CODE> ExceptionListener</CODE>, if one has been
1:d29ca2a:      * registered. It does this by calling the listener's <CODE>onException
1:230a86c:      * </CODE>
1:230a86c:      * method, passing it a <CODE>JMSException</CODE> object describing the
1:230a86c:      * problem.
1:d29ca2a:      * <P>
1:d29ca2a:      * An exception listener allows a client to be notified of a problem
1:d29ca2a:      * asynchronously. Some connections only consume messages, so they would
1:d29ca2a:      * have no other way to learn their connection has failed.
1:d29ca2a:      * <P>
1:d29ca2a:      * A connection serializes execution of its <CODE>ExceptionListener</CODE>.
1:d29ca2a:      * <P>
1:d29ca2a:      * A JMS provider should attempt to resolve connection problems itself
1:d29ca2a:      * before it notifies the client of them.
1:d226f50:      *
1:230a86c:      * @param listener the exception listener
1:230a86c:      * @throws JMSException if the JMS provider fails to set the exception
1:230a86c:      *                 listener for this connection.
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public void setExceptionListener(ExceptionListener listener) throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         this.exceptionListener = listener;
1:d29ca2a:     }
1:1a3f54c: 
1:d29ca2a:     /**
1:0acf545:      * Gets the <code>ClientInternalExceptionListener</code> object for this connection.
1:0acf545:      * Not every <CODE>ActiveMQConnectionn</CODE> has a <CODE>ClientInternalExceptionListener</CODE>
1:0acf545:      * associated with it.
1:d226f50:      *
1:0acf545:      * @return the listener or <code>null</code> if no listener is registered with the connection.
1:0acf545:      */
1:3d5a758:     public ClientInternalExceptionListener getClientInternalExceptionListener() {
1:0acf545:         return clientInternalExceptionListener;
1:d29ca2a:     }
1:1a3f54c: 
1:d29ca2a:     /**
1:0acf545:      * Sets a client internal exception listener for this connection.
1:0acf545:      * The connection will notify the listener, if one has been registered, of exceptions thrown by container components
1:0acf545:      * (e.g. an EJB container in case of Message Driven Beans) during asynchronous processing of a message.
1:0acf545:      * It does this by calling the listener's <code>onException()</code> method passing it a <code>Throwable</code>
1:d29ca2a:      * describing the problem.
1:d226f50:      *
1:0acf545:      * @param listener the exception listener
1:d29ca2a:      */
1:3d5a758:     public void setClientInternalExceptionListener(ClientInternalExceptionListener listener) {
1:0acf545:         this.clientInternalExceptionListener = listener;
1:d29ca2a:     }
1:d226f50: 
1:d29ca2a:     /**
1:d29ca2a:      * Starts (or restarts) a connection's delivery of incoming messages. A call
1:d29ca2a:      * to <CODE>start</CODE> on a connection that has already been started is
1:d29ca2a:      * ignored.
1:d226f50:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to start message delivery
1:230a86c:      *                 due to some internal error.
1:d29ca2a:      * @see javax.jms.Connection#stop()
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public void start() throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         ensureConnectionInfoSent();
1:d29ca2a:         if (started.compareAndSet(false, true)) {
1:933eb2f:             for (Iterator<ActiveMQSession> i = sessions.iterator(); i.hasNext();) {
1:933eb2f:                 ActiveMQSession session = i.next();
1:d29ca2a:                 session.start();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d71bc42: 
1:d29ca2a:     /**
1:d29ca2a:      * Temporarily stops a connection's delivery of incoming messages. Delivery
1:d29ca2a:      * can be restarted using the connection's <CODE>start</CODE> method. When
1:d29ca2a:      * the connection is stopped, delivery to all the connection's message
1:d29ca2a:      * consumers is inhibited: synchronous receives block, and messages are not
1:d29ca2a:      * delivered to message listeners.
1:d29ca2a:      * <P>
1:d29ca2a:      * This call blocks until receives and/or message listeners in progress have
1:d29ca2a:      * completed.
1:d29ca2a:      * <P>
1:d29ca2a:      * Stopping a connection has no effect on its ability to send messages. A
1:d29ca2a:      * call to <CODE>stop</CODE> on a connection that has already been stopped
1:d29ca2a:      * is ignored.
1:d29ca2a:      * <P>
1:d29ca2a:      * A call to <CODE>stop</CODE> must not return until delivery of messages
1:d29ca2a:      * has paused. This means that a client can rely on the fact that none of
1:d29ca2a:      * its message listeners will be called and that all threads of control
1:d29ca2a:      * waiting for <CODE>receive</CODE> calls to return will not return with a
1:d29ca2a:      * message until the connection is restarted. The receive timers for a
1:d29ca2a:      * stopped connection continue to advance, so receives may time out while
1:d29ca2a:      * the connection is stopped.
1:d29ca2a:      * <P>
1:d29ca2a:      * If message listeners are running when <CODE>stop</CODE> is invoked, the
1:d29ca2a:      * <CODE>stop</CODE> call must wait until all of them have returned before
1:d29ca2a:      * it may return. While these message listeners are completing, they must
1:d29ca2a:      * have the full services of the connection available to them.
1:d226f50:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to stop message delivery
1:230a86c:      *                 due to some internal error.
1:d29ca2a:      * @see javax.jms.Connection#start()
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public void stop() throws JMSException {
1:887ac0b:         doStop(true);
1:887ac0b:     }
1:887ac0b: 
1:887ac0b:     /**
1:887ac0b:      * @see #stop()
1:887ac0b:      * @param checkClosed <tt>true</tt> to check for already closed and throw {@link java.lang.IllegalStateException} if already closed,
1:887ac0b:      *                    <tt>false</tt> to skip this check
1:887ac0b:      * @throws JMSException if the JMS provider fails to stop message delivery due to some internal error.
1:887ac0b:      */
1:887ac0b:     void doStop(boolean checkClosed) throws JMSException {
1:887ac0b:         if (checkClosed) {
1:887ac0b:             checkClosedOrFailed();
1:887ac0b:         }
1:d29ca2a:         if (started.compareAndSet(true, false)) {
1:1555260:             synchronized(sessions) {
1:933eb2f:                 for (Iterator<ActiveMQSession> i = sessions.iterator(); i.hasNext();) {
1:933eb2f:                     ActiveMQSession s = i.next();
1:d29ca2a:                     s.stop();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d226f50: 
1:d29ca2a:     /**
1:d29ca2a:      * Closes the connection.
1:d29ca2a:      * <P>
1:d29ca2a:      * Since a provider typically allocates significant resources outside the
1:d29ca2a:      * JVM on behalf of a connection, clients should close these resources when
1:d29ca2a:      * they are not needed. Relying on garbage collection to eventually reclaim
1:d29ca2a:      * these resources may not be timely enough.
1:d29ca2a:      * <P>
1:d29ca2a:      * There is no need to close the sessions, producers, and consumers of a
1:d29ca2a:      * closed connection.
1:d29ca2a:      * <P>
1:d29ca2a:      * Closing a connection causes all temporary destinations to be deleted.
1:d29ca2a:      * <P>
1:d29ca2a:      * When this method is invoked, it should not return until message
1:d29ca2a:      * processing has been shut down in an orderly fashion. This means that all
1:d29ca2a:      * message listeners that may have been running have returned, and that all
1:d29ca2a:      * pending receives have returned. A close terminates all pending message
1:d29ca2a:      * receives on the connection's sessions' consumers. The receives may return
1:d29ca2a:      * with a message or with null, depending on whether there was a message
1:d29ca2a:      * available at the time of the close. If one or more of the connection's
1:d29ca2a:      * sessions' message listeners is processing a message at the time when
1:d29ca2a:      * connection <CODE>close</CODE> is invoked, all the facilities of the
1:d29ca2a:      * connection and its sessions must remain available to those listeners
1:d29ca2a:      * until they return control to the JMS provider.
1:d29ca2a:      * <P>
1:d29ca2a:      * Closing a connection causes any of its sessions' transactions in progress
1:d29ca2a:      * to be rolled back. In the case where a session's work is coordinated by
1:d29ca2a:      * an external transaction manager, a session's <CODE>commit</CODE> and
1:d29ca2a:      * <CODE> rollback</CODE> methods are not used and the result of a closed
1:d29ca2a:      * session's work is determined later by the transaction manager. Closing a
1:d29ca2a:      * connection does NOT force an acknowledgment of client-acknowledged
1:d29ca2a:      * sessions.
1:d29ca2a:      * <P>
1:d29ca2a:      * Invoking the <CODE>acknowledge</CODE> method of a received message from
1:230a86c:      * a closed connection's session must throw an
1:230a86c:      * <CODE>IllegalStateException</CODE>. Closing a closed connection must
1:230a86c:      * NOT throw an exception.
1:d226f50:      *
1:230a86c:      * @throws JMSException if the JMS provider fails to close the connection
1:230a86c:      *                 due to some internal error. For example, a failure to
1:230a86c:      *                 release resources or to close a socket connection can
1:230a86c:      *                 cause this exception to be thrown.
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public void close() throws JMSException {
1:934f3ce:         try {
1:d29ca2a:             // If we were running, lets stop first.
1:1555260:             if (!closed.get() && !transportFailed.get()) {
1:887ac0b:                 // do not fail if already closed as according to JMS spec we must not
1:887ac0b:                 // throw exception if already closed
1:887ac0b:                 doStop(false);
1:e3fcf71:             }
1:83fde0b: 
1:8d3ca90:             synchronized (this) {
1:d29ca2a:                 if (!closed.get()) {
1:d29ca2a:                     closing.set(true);
1:ad06a5f: 
1:f6efc56:                     if (destinationSource != null) {
1:f6efc56:                         destinationSource.stop();
1:f6efc56:                         destinationSource = null;
1:d29ca2a:                     }
1:230a86c:                     if (advisoryConsumer != null) {
1:230a86c:                         advisoryConsumer.dispose();
1:230a86c:                         advisoryConsumer = null;
1:230a86c:                     }
1:97ae323: 
1:97ae323:                     Scheduler scheduler = this.scheduler;
1:97ae323:                     if (scheduler != null) {
1:8d3ca90:                         try {
1:97ae323:                             scheduler.stop();
1:fb3b6db:                         } catch (Exception e) {
1:1a5ad28:                             JMSException ex =  JMSExceptionSupport.create(e);
1:1a5ad28:                             throw ex;
1:acd5996:                         }
1:d29ca2a:                     }
1:ad06a5f: 
1:eb6c082:                     long lastDeliveredSequenceId = -1;
1:933eb2f:                     for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:933eb2f:                         ActiveMQSession s = i.next();
1:d29ca2a:                         s.dispose();
1:3b08860:                         lastDeliveredSequenceId = Math.max(lastDeliveredSequenceId, s.getLastDeliveredSequenceId());
1:d29ca2a:                     }
1:933eb2f:                     for (Iterator<ActiveMQConnectionConsumer> i = this.connectionConsumers.iterator(); i.hasNext();) {
1:933eb2f:                         ActiveMQConnectionConsumer c = i.next();
5:d29ca2a:                         c.dispose();
1:d29ca2a:                     }
1:9010494: 
1:27440ae:                     this.activeTempDestinations.clear();
1:acd5996: 
1:934f3ce:                     try {
1:934f3ce:                         if (isConnectionInfoSentToBroker) {
1:934f3ce:                             // If we announced ourselves to the broker.. Try to let the broker
1:934f3ce:                             // know that the connection is being shutdown.
1:934f3ce:                             RemoveInfo removeCommand = info.createRemoveCommand();
1:934f3ce:                             removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:ad1f751:                             try {
1:a65f5e7:                                 syncSendPacket(removeCommand, closeTimeout);
1:ad1f751:                             } catch (JMSException e) {
1:ad1f751:                                 if (e.getCause() instanceof RequestTimedOutIOException) {
1:ad1f751:                                     // expected
1:ad1f751:                                 } else {
1:ad1f751:                                     throw e;
1:ad1f751:                                 }
1:ad1f751:                             }
1:934f3ce:                             doAsyncSendPacket(new ShutdownInfo());
1:934f3ce:                         }
1:934f3ce:                     } finally { // release anyway even if previous communication fails
1:934f3ce:                         started.set(false);
1:dcf7dea: 
1:934f3ce:                         // TODO if we move the TaskRunnerFactory to the connection
1:934f3ce:                         // factory
1:934f3ce:                         // then we may need to call
1:934f3ce:                         // factory.onConnectionClose(this);
1:934f3ce:                         if (sessionTaskRunner != null) {
1:934f3ce:                             sessionTaskRunner.shutdown();
1:934f3ce:                         }
1:934f3ce:                         closed.set(true);
1:934f3ce:                         closing.set(false);
1:c808beb:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:230a86c:         } finally {
1:d4cd7f9:             try {
1:83fde0b:                 if (executor != null) {
1:6c1676b:                     ThreadPoolUtils.shutdown(executor);
1:d29ca2a:                 }
1:83fde0b:             } catch (Throwable e) {
1:6c1676b:                 LOG.warn("Error shutting down thread pool: " + executor + ". This exception will be ignored.", e);
1:d29ca2a:             }
1:83fde0b: 
1:83fde0b:             ServiceSupport.dispose(this.transport);
1:83fde0b: 
1:ea35563:             factoryStats.removeConnection(this);
1:d29ca2a:         }
1:e3fcf71:     }
1:b1cd2b9: 
1:d29ca2a:     /**
1:d29ca2a:      * Tells the broker to terminate its VM. This can be used to cleanly
1:d29ca2a:      * terminate a broker running in a standalone java process. Server must have
1:d29ca2a:      * property enable.vm.shutdown=true defined to allow this to work.
1:d29ca2a:      */
1:230a86c:     // TODO : org.apache.activemq.message.BrokerAdminCommand not yet
1:230a86c:     // implemented.
1:d29ca2a:     /*
1:d29ca2a:      * public void terminateBrokerVM() throws JMSException { BrokerAdminCommand
1:d29ca2a:      * command = new BrokerAdminCommand();
1:d29ca2a:      * command.setCommand(BrokerAdminCommand.SHUTDOWN_SERVER_VM);
1:d29ca2a:      * asyncSendPacket(command); }
1:d29ca2a:      */
1:b1cd2b9: 
1:d29ca2a:     /**
1:d29ca2a:      * Create a durable connection consumer for this connection (optional
1:d29ca2a:      * operation). This is an expert facility not used by regular JMS clients.
1:d226f50:      *
1:230a86c:      * @param topic topic to access
1:230a86c:      * @param subscriptionName durable subscription name
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param sessionPool the server session pool to associate with this durable
1:230a86c:      *                connection consumer
1:230a86c:      * @param maxMessages the maximum number of messages that can be assigned to
1:230a86c:      *                a server session at one time
1:d29ca2a:      * @return the durable connection consumer
1:230a86c:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:230a86c:      *                 create a connection consumer due to some internal error
1:230a86c:      *                 or invalid arguments for <CODE>sessionPool</CODE> and
1:230a86c:      *                 <CODE>messageSelector</CODE>.
1:230a86c:      * @throws javax.jms.InvalidDestinationException if an invalid destination
1:230a86c:      *                 is specified.
1:230a86c:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:230a86c:      *                 invalid.
1:d29ca2a:      * @see javax.jms.ConnectionConsumer
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:849baa6:     @Override
1:230a86c:     public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName, String messageSelector, ServerSessionPool sessionPool, int maxMessages)
1:d226f50:         throws JMSException {
1:d29ca2a:         return this.createDurableConnectionConsumer(topic, subscriptionName, messageSelector, sessionPool, maxMessages, false);
1:d29ca2a:     }
1:baab4b2: 
1:d29ca2a:     /**
1:d29ca2a:      * Create a durable connection consumer for this connection (optional
1:d29ca2a:      * operation). This is an expert facility not used by regular JMS clients.
1:d226f50:      *
1:230a86c:      * @param topic topic to access
1:230a86c:      * @param subscriptionName durable subscription name
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param sessionPool the server session pool to associate with this durable
1:230a86c:      *                connection consumer
1:230a86c:      * @param maxMessages the maximum number of messages that can be assigned to
1:230a86c:      *                a server session at one time
1:230a86c:      * @param noLocal set true if you want to filter out messages published
1:230a86c:      *                locally
1:d29ca2a:      * @return the durable connection consumer
1:230a86c:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:230a86c:      *                 create a connection consumer due to some internal error
1:230a86c:      *                 or invalid arguments for <CODE>sessionPool</CODE> and
1:230a86c:      *                 <CODE>messageSelector</CODE>.
1:230a86c:      * @throws javax.jms.InvalidDestinationException if an invalid destination
1:230a86c:      *                 is specified.
1:230a86c:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:230a86c:      *                 invalid.
1:d29ca2a:      * @see javax.jms.ConnectionConsumer
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:230a86c:     public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName, String messageSelector, ServerSessionPool sessionPool, int maxMessages,
1:230a86c:                                                               boolean noLocal) throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:6da702b: 
1:6da702b:         if (queueOnlyConnection) {
1:6da702b:             throw new IllegalStateException("QueueConnection cannot be used to create Pub/Sub based resources.");
1:6da702b:         }
1:6da702b: 
1:d29ca2a:         ensureConnectionInfoSent();
1:d29ca2a:         SessionId sessionId = new SessionId(info.getConnectionId(), -1);
1:230a86c:         ConsumerInfo info = new ConsumerInfo(new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId()));
1:d29ca2a:         info.setDestination(ActiveMQMessageTransformation.transformDestination(topic));
1:333158a:         info.setSubscriptionName(subscriptionName);
2:d29ca2a:         info.setSelector(messageSelector);
2:d29ca2a:         info.setPrefetchSize(maxMessages);
1:62fb85e:         info.setDispatchAsync(isDispatchAsync());
1:230a86c: 
1:d29ca2a:         // Allows the options on the destination to configure the consumerInfo
1:230a86c:         if (info.getDestination().getOptions() != null) {
1:db8c771:             Map<String, String> options = new HashMap<>(info.getDestination().getOptions());
2:d29ca2a:             IntrospectionSupport.setProperties(this.info, options, "consumer.");
1:d29ca2a:         }
1:230a86c: 
2:d29ca2a:         return new ActiveMQConnectionConsumer(this, sessionPool, info);
1:c33231b:     }
1:90e21b4: 
1:d29ca2a:     // Properties
1:d29ca2a:     // -------------------------------------------------------------------------
1:90e21b4: 
1:0acf545:     /**
1:0cc5d24:      * Returns true if this connection has been started
1:d226f50:      *
1:d29ca2a:      * @return true if this Connection is started
1:0acf545:      */
1:0cc5d24:     public boolean isStarted() {
1:d29ca2a:         return started.get();
1:d29ca2a:     }
1:90e21b4: 
1:d29ca2a:     /**
1:0cc5d24:      * Returns true if the connection is closed
1:d29ca2a:      */
1:d29ca2a:     public boolean isClosed() {
1:d29ca2a:         return closed.get();
1:d29ca2a:     }
1:90e21b4: 
1:0acf545:     /**
1:0cc5d24:      * Returns true if the connection is in the process of being closed
1:f95552b:      */
1:0cc5d24:     public boolean isClosing() {
1:0cc5d24:         return closing.get();
1:d29ca2a:     }
1:230a86c: 
1:f95552b:     /**
1:0cc5d24:      * Returns true if the underlying transport has failed
1:4e2acd4:      */
1:0cc5d24:     public boolean isTransportFailed() {
1:0cc5d24:         return transportFailed.get();
1:c33231b:     }
1:230a86c: 
1:4e2acd4:     /**
1:d29ca2a:      * @return Returns the prefetchPolicy.
1:5fe0a4c:      */
1:d29ca2a:     public ActiveMQPrefetchPolicy getPrefetchPolicy() {
1:d29ca2a:         return prefetchPolicy;
1:d29ca2a:     }
78:d29ca2a: 
1:d29ca2a:     /**
1:480433b:      * Sets the <a
1:3013c20:      * href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
1:480433b:      * policy</a> for consumers created by this connection.
1:d29ca2a:      */
1:d29ca2a:     public void setPrefetchPolicy(ActiveMQPrefetchPolicy prefetchPolicy) {
1:d29ca2a:         this.prefetchPolicy = prefetchPolicy;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      */
1:d29ca2a:     public Transport getTransportChannel() {
1:d29ca2a:         return transport;
1:c9bb1c9:     }
1:c9bb1c9: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the clientID of the connection, forcing one to be
1:d29ca2a:      *         generated if one has not yet been configured.
1:d29ca2a:      */
1:d29ca2a:     public String getInitializedClientID() throws JMSException {
1:d29ca2a:         ensureConnectionInfoSent();
1:d29ca2a:         return info.getClientId();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the timeStampsDisableByDefault.
1:d29ca2a:      */
1:d29ca2a:     public boolean isDisableTimeStampsByDefault() {
1:d29ca2a:         return disableTimeStampsByDefault;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:4b08ea5:      * Sets whether or not timestamps on messages should be disabled or not. If
1:4b08ea5:      * you disable them it adds a small performance boost.
1:d29ca2a:      */
1:d29ca2a:     public void setDisableTimeStampsByDefault(boolean timeStampsDisableByDefault) {
1:d29ca2a:         this.disableTimeStampsByDefault = timeStampsDisableByDefault;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the dispatchOptimizedMessage.
1:d29ca2a:      */
1:d29ca2a:     public boolean isOptimizedMessageDispatch() {
1:d29ca2a:         return optimizedMessageDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:4b08ea5:      * If this flag is set then an larger prefetch limit is used - only
1:4b08ea5:      * applicable for durable topic subscribers.
1:d29ca2a:      */
1:d29ca2a:     public void setOptimizedMessageDispatch(boolean dispatchOptimizedMessage) {
1:d29ca2a:         this.optimizedMessageDispatch = dispatchOptimizedMessage;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5fe0a4c:      * @return Returns the closeTimeout.
1:d29ca2a:      */
1:230a86c:     public int getCloseTimeout() {
1:5fe0a4c:         return closeTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:c085df4:      * Sets the timeout before a close is considered complete. Normally a
1:c085df4:      * close() on a connection waits for confirmation from the broker; this
1:c085df4:      * allows that operation to timeout to save the client hanging if there is
1:c085df4:      * no broker
1:d29ca2a:      */
1:230a86c:     public void setCloseTimeout(int closeTimeout) {
1:230a86c:         this.closeTimeout = closeTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return ConnectionInfo
1:d29ca2a:      */
1:d29ca2a:     public ConnectionInfo getConnectionInfo() {
1:d29ca2a:         return this.info;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isUseRetroactiveConsumer() {
1:d29ca2a:         return useRetroactiveConsumer;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sets whether or not retroactive consumers are enabled. Retroactive
1:230a86c:      * consumers allow non-durable topic subscribers to receive old messages
1:230a86c:      * that were published before the non-durable subscriber started.
1:d29ca2a:      */
1:d29ca2a:     public void setUseRetroactiveConsumer(boolean useRetroactiveConsumer) {
1:d29ca2a:         this.useRetroactiveConsumer = useRetroactiveConsumer;
1:d29ca2a:     }
1:d29ca2a: 
1:ca067a6:     public boolean isNestedMapAndListEnabled() {
1:ca067a6:         return nestedMapAndListEnabled;
1:d29ca2a:     }
1:d29ca2a: 
1:5fe0a4c:     /**
1:4b08ea5:      * Enables/disables whether or not Message properties and MapMessage entries
1:4b08ea5:      * support <a
1:3013c20:      * href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
1:4b08ea5:      * Structures</a> of Map and List objects
1:d29ca2a:      */
1:ca067a6:     public void setNestedMapAndListEnabled(boolean structuredMapsEnabled) {
1:ca067a6:         this.nestedMapAndListEnabled = structuredMapsEnabled;
1:d29ca2a:     }
1:d29ca2a: 
1:3d862f0:     public boolean isExclusiveConsumer() {
1:3d862f0:         return exclusiveConsumer;
1:d29ca2a:     }
1:d29ca2a: 
1:5fe0a4c:     /**
1:230a86c:      * Enables or disables whether or not queue consumers should be exclusive or
1:230a86c:      * not for example to preserve ordering when not using <a
1:230a86c:      * href="http://activemq.apache.org/message-groups.html">Message Groups</a>
1:d226f50:      *
1:3d862f0:      * @param exclusiveConsumer
1:5fe0a4c:      */
1:3d862f0:     public void setExclusiveConsumer(boolean exclusiveConsumer) {
1:3d862f0:         this.exclusiveConsumer = exclusiveConsumer;
1:d29ca2a:     }
1:d29ca2a: 
1:5fe0a4c:     /**
1:230a86c:      * Adds a transport listener so that a client can be notified of events in
1:230a86c:      * the underlying transport
1:5fe0a4c:      */
1:2bc9a83:     public void addTransportListener(TransportListener transportListener) {
1:2bc9a83:         transportListeners.add(transportListener);
1:d29ca2a:     }
1:230a86c: 
1:2bc9a83:     public void removeTransportListener(TransportListener transportListener) {
1:2bc9a83:         transportListeners.remove(transportListener);
1:d29ca2a:     }
1:c808beb: 
1:c808beb:     public boolean isUseDedicatedTaskRunner() {
1:c808beb:         return useDedicatedTaskRunner;
1:c808beb:     }
1:d226f50: 
1:c808beb:     public void setUseDedicatedTaskRunner(boolean useDedicatedTaskRunner) {
1:c808beb:         this.useDedicatedTaskRunner = useDedicatedTaskRunner;
1:c808beb:     }
1:c808beb: 
1:6cf2169:     public TaskRunnerFactory getSessionTaskRunner() {
1:862cd71:         synchronized (this) {
1:c808beb:             if (sessionTaskRunner == null) {
1:c33231b:                 sessionTaskRunner = new TaskRunnerFactory("ActiveMQ Session Task", ThreadPriorities.INBOUND_CLIENT_SESSION, false, 1000, isUseDedicatedTaskRunner(), maxThreadPoolSize);
1:e3fcf71:                 sessionTaskRunner.setRejectedTaskHandler(rejectedTaskHandler);
1:c808beb:             }
1:c808beb:         }
1:6cf2169:         return sessionTaskRunner;
1:d29ca2a:     }
1:d29ca2a: 
1:6cf2169:     public void setSessionTaskRunner(TaskRunnerFactory sessionTaskRunner) {
1:6cf2169:         this.sessionTaskRunner = sessionTaskRunner;
1:d29ca2a:     }
1:d29ca2a: 
1:86faaef:     public MessageTransformer getTransformer() {
1:86faaef:         return transformer;
1:d29ca2a:     }
1:d29ca2a: 
1:526cb5b:     /**
1:230a86c:      * Sets the transformer used to transform messages before they are sent on
1:230a86c:      * to the JMS bus or when they are received from the bus but before they are
1:230a86c:      * delivered to the JMS client
1:36a2bdc:      */
1:86faaef:     public void setTransformer(MessageTransformer transformer) {
1:86faaef:         this.transformer = transformer;
1:d29ca2a:     }
1:d29ca2a: 
1:3d862f0:     /**
1:526cb5b:      * @return the statsEnabled
1:526cb5b:      */
1:230a86c:     public boolean isStatsEnabled() {
1:526cb5b:         return this.stats.isEnabled();
1:d29ca2a:     }
1:d29ca2a: 
1:526cb5b:     /**
1:526cb5b:      * @param statsEnabled the statsEnabled to set
1:526cb5b:      */
1:230a86c:     public void setStatsEnabled(boolean statsEnabled) {
1:526cb5b:         this.stats.setEnabled(statsEnabled);
1:d29ca2a:     }
1:d29ca2a: 
1:f6efc56:     /**
1:f6efc56:      * Returns the {@link DestinationSource} object which can be used to listen to destinations
1:f6efc56:      * being created or destroyed or to enquire about the current destinations available on the broker
1:d226f50:      *
1:f6efc56:      * @return a lazily created destination source
1:d29ca2a:      * @throws JMSException
1:f6efc56:      */
1:849baa6:     @Override
1:f6efc56:     public DestinationSource getDestinationSource() throws JMSException {
1:f6efc56:         if (destinationSource == null) {
1:f6efc56:             destinationSource = new DestinationSource(this);
1:f6efc56:             destinationSource.start();
1:d29ca2a:         }
1:f6efc56:         return destinationSource;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // Implementation methods
1:d29ca2a:     // -------------------------------------------------------------------------
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Used internally for adding Sessions to the Connection
1:d226f50:      *
1:d29ca2a:      * @param session
1:230a86c:      * @throws JMSException
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void addSession(ActiveMQSession session) throws JMSException {
1:d29ca2a:         this.sessions.add(session);
1:230a86c:         if (sessions.size() > 1 || session.isTransacted()) {
1:d29ca2a:             optimizedMessageDispatch = false;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Used interanlly for removing Sessions from a Connection
1:d226f50:      *
1:d29ca2a:      * @param session
1:d29ca2a:      */
1:d29ca2a:     protected void removeSession(ActiveMQSession session) {
1:d29ca2a:         this.sessions.remove(session);
1:cbaa58b:         this.removeDispatcher(session);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Add a ConnectionConsumer
1:d226f50:      *
1:d29ca2a:      * @param connectionConsumer
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void addConnectionConsumer(ActiveMQConnectionConsumer connectionConsumer) throws JMSException {
1:d29ca2a:         this.connectionConsumers.add(connectionConsumer);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Remove a ConnectionConsumer
1:d226f50:      *
1:d29ca2a:      * @param connectionConsumer
1:d29ca2a:      */
1:d29ca2a:     protected void removeConnectionConsumer(ActiveMQConnectionConsumer connectionConsumer) {
1:d29ca2a:         this.connectionConsumers.remove(connectionConsumer);
1:cbaa58b:         this.removeDispatcher(connectionConsumer);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>TopicSession</CODE> object.
1:d226f50:      *
1:230a86c:      * @param transacted indicates whether the session is transacted
1:230a86c:      * @param acknowledgeMode indicates whether the consumer or the client will
1:230a86c:      *                acknowledge any messages it receives; ignored if the
1:230a86c:      *                session is transacted. Legal values are
1:230a86c:      *                <code>Session.AUTO_ACKNOWLEDGE</code>,
1:230a86c:      *                <code>Session.CLIENT_ACKNOWLEDGE</code>, and
1:230a86c:      *                <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:d29ca2a:      * @return a newly created topic session
1:230a86c:      * @throws JMSException if the <CODE>TopicConnection</CODE> object fails
1:230a86c:      *                 to create a session due to some internal error or lack of
1:230a86c:      *                 support for the specific transaction and acknowledgement
1:230a86c:      *                 mode.
1:d29ca2a:      * @see Session#AUTO_ACKNOWLEDGE
1:d29ca2a:      * @see Session#CLIENT_ACKNOWLEDGE
1:d29ca2a:      * @see Session#DUPS_OK_ACKNOWLEDGE
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public TopicSession createTopicSession(boolean transacted, int acknowledgeMode) throws JMSException {
1:230a86c:         return new ActiveMQTopicSession((ActiveMQSession)createSession(transacted, acknowledgeMode));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a connection consumer for this connection (optional operation).
1:d29ca2a:      * This is an expert facility not used by regular JMS clients.
1:d226f50:      *
1:230a86c:      * @param topic the topic to access
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param sessionPool the server session pool to associate with this
1:230a86c:      *                connection consumer
1:230a86c:      * @param maxMessages the maximum number of messages that can be assigned to
1:230a86c:      *                a server session at one time
1:d29ca2a:      * @return the connection consumer
1:230a86c:      * @throws JMSException if the <CODE>TopicConnection</CODE> object fails
1:230a86c:      *                 to create a connection consumer due to some internal
1:230a86c:      *                 error or invalid arguments for <CODE>sessionPool</CODE>
1:230a86c:      *                 and <CODE>messageSelector</CODE>.
1:230a86c:      * @throws javax.jms.InvalidDestinationException if an invalid topic is
1:230a86c:      *                 specified.
1:230a86c:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:230a86c:      *                 invalid.
1:d29ca2a:      * @see javax.jms.ConnectionConsumer
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public ConnectionConsumer createConnectionConsumer(Topic topic, String messageSelector, ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:d29ca2a:         return createConnectionConsumer(topic, messageSelector, sessionPool, maxMessages, false);
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a connection consumer for this connection (optional operation).
1:d29ca2a:      * This is an expert facility not used by regular JMS clients.
1:d226f50:      *
1:230a86c:      * @param queue the queue to access
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param sessionPool the server session pool to associate with this
1:230a86c:      *                connection consumer
1:230a86c:      * @param maxMessages the maximum number of messages that can be assigned to
1:230a86c:      *                a server session at one time
1:d29ca2a:      * @return the connection consumer
1:230a86c:      * @throws JMSException if the <CODE>QueueConnection</CODE> object fails
1:230a86c:      *                 to create a connection consumer due to some internal
1:230a86c:      *                 error or invalid arguments for <CODE>sessionPool</CODE>
1:230a86c:      *                 and <CODE>messageSelector</CODE>.
1:230a86c:      * @throws javax.jms.InvalidDestinationException if an invalid queue is
1:230a86c:      *                 specified.
1:230a86c:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:230a86c:      *                 invalid.
1:d29ca2a:      * @see javax.jms.ConnectionConsumer
1:d29ca2a:      */
1:849baa6:     @Override
1:230a86c:     public ConnectionConsumer createConnectionConsumer(Queue queue, String messageSelector, ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:d29ca2a:         return createConnectionConsumer(queue, messageSelector, sessionPool, maxMessages, false);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a connection consumer for this connection (optional operation).
1:d29ca2a:      * This is an expert facility not used by regular JMS clients.
1:d226f50:      *
1:230a86c:      * @param destination the destination to access
1:230a86c:      * @param messageSelector only messages with properties matching the message
1:230a86c:      *                selector expression are delivered. A value of null or an
1:230a86c:      *                empty string indicates that there is no message selector
1:230a86c:      *                for the message consumer.
1:230a86c:      * @param sessionPool the server session pool to associate with this
1:230a86c:      *                connection consumer
1:230a86c:      * @param maxMessages the maximum number of messages that can be assigned to
1:230a86c:      *                a server session at one time
1:d29ca2a:      * @return the connection consumer
1:230a86c:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:230a86c:      *                 create a connection consumer due to some internal error
1:230a86c:      *                 or invalid arguments for <CODE>sessionPool</CODE> and
1:230a86c:      *                 <CODE>messageSelector</CODE>.
1:230a86c:      * @throws javax.jms.InvalidDestinationException if an invalid destination
1:230a86c:      *                 is specified.
1:230a86c:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:230a86c:      *                 invalid.
1:d29ca2a:      * @see javax.jms.ConnectionConsumer
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:849baa6:     @Override
1:230a86c:     public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector, ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:d29ca2a:         return createConnectionConsumer(destination, messageSelector, sessionPool, maxMessages, false);
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector, ServerSessionPool sessionPool, int maxMessages, boolean noLocal)
1:2984963:         throws JMSException {
1:230a86c: 
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         ensureConnectionInfoSent();
1:230a86c: 
1:d29ca2a:         ConsumerId consumerId = createConsumerId();
1:4ecc89e:         ConsumerInfo consumerInfo = new ConsumerInfo(consumerId);
1:4ecc89e:         consumerInfo.setDestination(ActiveMQMessageTransformation.transformDestination(destination));
1:4ecc89e:         consumerInfo.setSelector(messageSelector);
1:4ecc89e:         consumerInfo.setPrefetchSize(maxMessages);
1:4ecc89e:         consumerInfo.setNoLocal(noLocal);
1:4ecc89e:         consumerInfo.setDispatchAsync(isDispatchAsync());
1:d29ca2a: 
1:d29ca2a:         // Allows the options on the destination to configure the consumerInfo
1:4ecc89e:         if (consumerInfo.getDestination().getOptions() != null) {
1:db8c771:             Map<String, String> options = new HashMap<>(consumerInfo.getDestination().getOptions());
1:4ecc89e:             IntrospectionSupport.setProperties(consumerInfo, options, "consumer.");
1:d29ca2a:         }
1:d29ca2a: 
1:4ecc89e:         return new ActiveMQConnectionConsumer(this, sessionPool, consumerInfo);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:61b2f6b:      * @return a newly created ConsumedId unique to this connection session instance.
1:d29ca2a:      */
1:d29ca2a:     private ConsumerId createConsumerId() {
1:d29ca2a:         return new ConsumerId(connectionSessionId, consumerIdGenerator.getNextSequenceId());
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a <CODE>QueueSession</CODE> object.
1:d226f50:      *
1:230a86c:      * @param transacted indicates whether the session is transacted
1:230a86c:      * @param acknowledgeMode indicates whether the consumer or the client will
1:230a86c:      *                acknowledge any messages it receives; ignored if the
1:230a86c:      *                session is transacted. Legal values are
1:230a86c:      *                <code>Session.AUTO_ACKNOWLEDGE</code>,
1:230a86c:      *                <code>Session.CLIENT_ACKNOWLEDGE</code>, and
1:230a86c:      *                <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:d29ca2a:      * @return a newly created queue session
1:230a86c:      * @throws JMSException if the <CODE>QueueConnection</CODE> object fails
1:230a86c:      *                 to create a session due to some internal error or lack of
1:230a86c:      *                 support for the specific transaction and acknowledgement
1:230a86c:      *                 mode.
1:d29ca2a:      * @see Session#AUTO_ACKNOWLEDGE
1:d29ca2a:      * @see Session#CLIENT_ACKNOWLEDGE
1:d29ca2a:      * @see Session#DUPS_OK_ACKNOWLEDGE
1:d29ca2a:      */
1:849baa6:     @Override
1:d29ca2a:     public QueueSession createQueueSession(boolean transacted, int acknowledgeMode) throws JMSException {
1:230a86c:         return new ActiveMQQueueSession((ActiveMQSession)createSession(transacted, acknowledgeMode));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Ensures that the clientID was manually specified and not auto-generated.
1:d29ca2a:      * If the clientID was not specified this method will throw an exception.
1:d29ca2a:      * This method is used to ensure that the clientID + durableSubscriber name
1:d29ca2a:      * are used correctly.
1:d226f50:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void checkClientIDWasManuallySpecified() throws JMSException {
1:d29ca2a:         if (!userSpecifiedClientID) {
1:230a86c:             throw new JMSException("You cannot create a durable subscriber without specifying a unique clientID on a Connection");
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * send a Packet through the Connection - for internal use only
1:d226f50:      *
1:d29ca2a:      * @param command
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void asyncSendPacket(Command command) throws JMSException {
1:d29ca2a:         if (isClosed()) {
1:d29ca2a:             throw new ConnectionClosedException();
1:934f3ce:         } else {
1:2984963:             doAsyncSendPacket(command);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d226f50:     private void doAsyncSendPacket(Command command) throws JMSException {
1:d226f50:         try {
1:d226f50:             this.transport.oneway(command);
1:d226f50:         } catch (IOException e) {
1:d226f50:             throw JMSExceptionSupport.create(e);
1:d226f50:         }
1:d226f50:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Send a packet through a Connection - for internal use only
1:61b2f6b:      *
1:d29ca2a:      * @param command
1:61b2f6b:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:c9b49d8:     public void syncSendPacket(final Command command, final AsyncCallback onComplete) throws JMSException {
1:d4cd7f9:         if(onComplete==null) {
1:d4cd7f9:             syncSendPacket(command);
1:d4cd7f9:         } else {
1:d4cd7f9:             if (isClosed()) {
1:d4cd7f9:                 throw new ConnectionClosedException();
1:d4cd7f9:             }
1:d226f50:             try {
1:d4cd7f9:                 this.transport.asyncRequest(command, new ResponseCallback() {
1:849baa6:                     @Override
1:d4cd7f9:                     public void onCompletion(FutureResponse resp) {
1:d4cd7f9:                         Response response;
1:d4cd7f9:                         Throwable exception = null;
1:d4cd7f9:                         try {
1:d4cd7f9:                             response = resp.getResult();
1:d4cd7f9:                             if (response.isException()) {
1:d4cd7f9:                                 ExceptionResponse er = (ExceptionResponse)response;
1:d4cd7f9:                                 exception = er.getException();
1:d4cd7f9:                             }
1:d4cd7f9:                         } catch (Exception e) {
1:d4cd7f9:                             exception = e;
1:d4cd7f9:                         }
1:db8c771:                         if (exception != null) {
1:d4cd7f9:                             if ( exception instanceof JMSException) {
1:d4cd7f9:                                 onComplete.onException((JMSException) exception);
1:d4cd7f9:                             } else {
1:db8c771:                                 if (isClosed() || closing.get()) {
1:d4cd7f9:                                     LOG.debug("Received an exception but connection is closing");
1:d4cd7f9:                                 }
1:d4cd7f9:                                 JMSException jmsEx = null;
1:d4cd7f9:                                 try {
1:d4cd7f9:                                     jmsEx = JMSExceptionSupport.create(exception);
1:d4cd7f9:                                 } catch(Throwable e) {
1:d4cd7f9:                                     LOG.error("Caught an exception trying to create a JMSException for " +exception,e);
1:d4cd7f9:                                 }
1:c9b49d8:                                 // dispose of transport for security exceptions on connection initiation
1:c9b49d8:                                 if (exception instanceof SecurityException && command instanceof ConnectionInfo){
1:db8c771:                                     try {
1:db8c771:                                         forceCloseOnSecurityException(exception);
1:db8c771:                                     } catch (Throwable t) {
1:db8c771:                                         // We throw the original error from the ExceptionResponse instead.
1:db8c771:                                     }
1:d4cd7f9:                                 }
1:db8c771:                                 if (jmsEx != null) {
1:d4cd7f9:                                     onComplete.onException(jmsEx);
1:d4cd7f9:                                 }
1:d4cd7f9:                             }
1:d4cd7f9:                         } else {
1:d4cd7f9:                             onComplete.onSuccess();
1:d4cd7f9:                         }
1:d4cd7f9:                     }
1:d4cd7f9:                 });
1:d4cd7f9:             } catch (IOException e) {
1:d4cd7f9:                 throw JMSExceptionSupport.create(e);
1:d4cd7f9:             }
1:d4cd7f9:         }
1:d4cd7f9:     }
1:d4cd7f9: 
1:a58b008:     private void forceCloseOnSecurityException(Throwable exception) {
1:a58b008:         LOG.trace("force close on security exception:" + this + ", transport=" + transport, exception);
1:a58b008:         onException(new IOException("Force close due to SecurityException on connect", exception));
1:a58b008:     }
1:a58b008: 
1:a65f5e7:     public Response syncSendPacket(Command command, int timeout) throws JMSException {
1:d29ca2a:         if (isClosed()) {
1:d29ca2a:             throw new ConnectionClosedException();
1:2984963:         } else {
1:2984963: 
1:2984963:             try {
1:a65f5e7:                 Response response = (Response)(timeout > 0
1:a65f5e7:                         ? this.transport.request(command, timeout)
1:a65f5e7:                         : this.transport.request(command));
1:d29ca2a:                 if (response.isException()) {
1:d226f50:                     ExceptionResponse er = (ExceptionResponse)response;
1:d226f50:                     if (er.getException() instanceof JMSException) {
1:d226f50:                         throw (JMSException)er.getException();
1:d226f50:                     } else {
1:db8c771:                         if (isClosed() || closing.get()) {
1:1555260:                             LOG.debug("Received an exception but connection is closing");
1:d226f50:                         }
1:73edcbc:                         JMSException jmsEx = null;
1:2984963:                         try {
1:9df9d3e:                             jmsEx = JMSExceptionSupport.create(er.getException());
1:9df9d3e:                         } catch(Throwable e) {
1:b52624e:                             LOG.error("Caught an exception trying to create a JMSException for " +er.getException(),e);
1:d226f50:                         }
1:c9b49d8:                         if (er.getException() instanceof SecurityException && command instanceof ConnectionInfo){
1:db8c771:                             try {
1:db8c771:                                 forceCloseOnSecurityException(er.getException());
1:db8c771:                             } catch (Throwable t) {
1:db8c771:                                 // We throw the original error from the ExceptionResponse instead.
1:db8c771:                             }
1:d4cd7f9:                         }
1:db8c771:                         if (jmsEx != null) {
1:9df9d3e:                             throw jmsEx;
1:2984963:                         }
1:2984963:                     }
1:2984963:                 }
1:d226f50:                 return response;
1:d226f50:             } catch (IOException e) {
1:d226f50:                 throw JMSExceptionSupport.create(e);
1:d226f50:             }
1:d226f50:         }
1:2984963:     }
1:2984963: 
1:86faaef:     /**
1:5fe0a4c:      * Send a packet through a Connection - for internal use only
1:61b2f6b:      *
1:5fe0a4c:      * @param command
1:d226f50:      *
1:61b2f6b:      * @return the broker Response for the given Command.
1:230a86c:      *
1:d29ca2a:      * @throws JMSException
1:3d862f0:      */
1:a65f5e7:     public Response syncSendPacket(Command command) throws JMSException {
1:a65f5e7:         return syncSendPacket(command, 0);
1:2984963:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return statistics for this Connection
1:86faaef:      */
1:849baa6:     @Override
1:d29ca2a:     public StatsImpl getStats() {
1:d29ca2a:         return stats;
1:2984963:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * simply throws an exception if the Connection is already closed or the
1:230a86c:      * Transport has failed
1:d226f50:      *
1:d29ca2a:      * @throws JMSException
1:ca067a6:      */
1:36a2bdc:     protected synchronized void checkClosedOrFailed() throws JMSException {
17:d29ca2a:         checkClosed();
1:230a86c:         if (transportFailed.get()) {
1:daf48bb:             throw new ConnectionFailedException(firstFailureError);
1:74a7a8b:         }
1:74a7a8b:     }
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * simply throws an exception if the Connection is already closed
1:d226f50:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected synchronized void checkClosed() throws JMSException {
1:d29ca2a:         if (closed.get()) {
1:d29ca2a:             throw new ConnectionClosedException();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Send the ConnectionInfo to the Broker
1:d226f50:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected void ensureConnectionInfoSent() throws JMSException {
1:1555260:         synchronized(this.ensureConnectionInfoSentMutex) {
1:d29ca2a:             // Can we skip sending the ConnectionInfo packet??
1:1555260:             if (isConnectionInfoSentToBroker || closed.get()) {
1:d29ca2a:                 return;
1:d29ca2a:             }
1:e08cc35:             //TODO shouldn't this check be on userSpecifiedClientID rather than the value of clientID?
1:d29ca2a:             if (info.getClientId() == null || info.getClientId().trim().length() == 0) {
1:d29ca2a:                 info.setClientId(clientIdGenerator.generateId());
1:d29ca2a:             }
1:f43c090:             syncSendPacket(info.copy(), getConnectResponseTimeout());
1:d226f50: 
1:d29ca2a:             this.isConnectionInfoSentToBroker = true;
1:230a86c:             // Add a temp destination advisory consumer so that
1:230a86c:             // We know what the valid temporary destinations are on the
1:d29ca2a:             // broker without having to do an RPC to the broker.
1:d226f50: 
1:230a86c:             ConsumerId consumerId = new ConsumerId(new SessionId(info.getConnectionId(), -1), consumerIdGenerator.getNextSequenceId());
1:230a86c:             if (watchTopicAdvisories) {
1:230a86c:                 advisoryConsumer = new AdvisoryConsumer(this, consumerId);
1:230a86c:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public synchronized boolean isWatchTopicAdvisories() {
1:230a86c:         return watchTopicAdvisories;
1:230a86c:     }
1:d29ca2a: 
1:230a86c:     public synchronized void setWatchTopicAdvisories(boolean watchTopicAdvisories) {
1:230a86c:         this.watchTopicAdvisories = watchTopicAdvisories;
1:230a86c:     }
1:d29ca2a: 
1:230a86c:     /**
1:d29ca2a:      * @return Returns the useAsyncSend.
1:d29ca2a:      */
1:d29ca2a:     public boolean isUseAsyncSend() {
1:d29ca2a:         return useAsyncSend;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:4b08ea5:      * Forces the use of <a
1:230a86c:      * href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
1:230a86c:      * adds a massive performance boost; but means that the send() method will
1:230a86c:      * return immediately whether the message has been sent or not which could
1:230a86c:      * lead to message loss.
1:d29ca2a:      */
1:d29ca2a:     public void setUseAsyncSend(boolean useAsyncSend) {
1:d29ca2a:         this.useAsyncSend = useAsyncSend;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:4e2acd4:      * @return true if always sync send messages
1:d29ca2a:      */
1:230a86c:     public boolean isAlwaysSyncSend() {
1:4e2acd4:         return this.alwaysSyncSend;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:4e2acd4:      * Set true if always require messages to be sync sent
1:d226f50:      *
1:4e2acd4:      * @param alwaysSyncSend
1:4e2acd4:      */
1:230a86c:     public void setAlwaysSyncSend(boolean alwaysSyncSend) {
1:230a86c:         this.alwaysSyncSend = alwaysSyncSend;
1:d29ca2a:     }
1:d226f50: 
1:c14dc3a:     /**
1:c14dc3a:      * @return the messagePrioritySupported
1:c14dc3a:      */
1:c14dc3a:     public boolean isMessagePrioritySupported() {
1:c14dc3a:         return this.messagePrioritySupported;
1:d29ca2a:     }
1:d29ca2a: 
1:c14dc3a:     /**
1:c14dc3a:      * @param messagePrioritySupported the messagePrioritySupported to set
1:c14dc3a:      */
1:c14dc3a:     public void setMessagePrioritySupported(boolean messagePrioritySupported) {
1:c14dc3a:         this.messagePrioritySupported = messagePrioritySupported;
1:d29ca2a:     }
1:d29ca2a: 
1:4e2acd4:     /**
1:d29ca2a:      * Cleans up this connection so that it's state is as if the connection was
1:d29ca2a:      * just created. This allows the Resource Adapter to clean up a connection
1:d29ca2a:      * so that it can be reused without having to close and recreate the
1:d29ca2a:      * connection.
1:d29ca2a:      */
1:d29ca2a:     public void cleanup() throws JMSException {
1:b29eb38:         doCleanup(false);
1:b29eb38:     }
1:230a86c: 
1:2bd3379:     public boolean isUserSpecifiedClientID() {
1:2bd3379:         return userSpecifiedClientID;
1:2bd3379:     }
1:2bd3379: 
1:b29eb38:     public void doCleanup(boolean removeConnection) throws JMSException {
1:f8ef7ff:         if (advisoryConsumer != null && !isTransportFailed()) {
1:acd5996:             advisoryConsumer.dispose();
1:230a86c:             advisoryConsumer = null;
1:230a86c:         }
1:230a86c: 
1:933eb2f:         for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:933eb2f:             ActiveMQSession s = i.next();
1:d29ca2a:             s.dispose();
1:d29ca2a:         }
1:933eb2f:         for (Iterator<ActiveMQConnectionConsumer> i = this.connectionConsumers.iterator(); i.hasNext();) {
1:933eb2f:             ActiveMQConnectionConsumer c = i.next();
1:d29ca2a:             c.dispose();
1:d29ca2a:         }
1:d29ca2a: 
1:b29eb38:         if (removeConnection) {
1:b29eb38:             if (isConnectionInfoSentToBroker) {
1:b29eb38:                 if (!transportFailed.get() && !closing.get()) {
1:b29eb38:                     syncSendPacket(info.createRemoveCommand());
1:b29eb38:                 }
1:b29eb38:                 isConnectionInfoSentToBroker = false;
1:b29eb38:             }
1:b29eb38:             if (userSpecifiedClientID) {
1:b29eb38:                 info.setClientId(null);
1:b29eb38:                 userSpecifiedClientID = false;
1:b29eb38:             }
1:b29eb38:             clientIDSet = false;
1:d29ca2a:         }
1:d29ca2a: 
1:b29eb38:         started.set(false);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Changes the associated username/password that is associated with this
1:d29ca2a:      * connection. If the connection has been used, you must called cleanup()
1:d29ca2a:      * before calling this method.
1:d226f50:      *
1:230a86c:      * @throws IllegalStateException if the connection is in used.
1:d29ca2a:      */
1:d29ca2a:     public void changeUserInfo(String userName, String password) throws JMSException {
1:74a7a8b:         if (isConnectionInfoSentToBroker) {
1:d29ca2a:             throw new IllegalStateException("changeUserInfo used Connection is not allowed");
1:74a7a8b:         }
2:d29ca2a:         this.info.setUserName(userName);
1:90e21b4:         this.info.setPassword(password);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the resourceManagerId.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public String getResourceManagerId() throws JMSException {
1:221a751:         if (isRmIdFromConnectionId()) {
1:221a751:             return info.getConnectionId().getValue();
1:221a751:         }
2:d29ca2a:         waitForBrokerInfo();
1:74a7a8b:         if (brokerInfo == null) {
1:230a86c:             throw new JMSException("Connection failed before Broker info was received.");
1:74a7a8b:         }
1:c59246d:         return brokerInfo.getBrokerId().getValue();
1:d29ca2a:     }
1:d29ca2a: 
1:36a2bdc:     /**
1:230a86c:      * Returns the broker name if one is available or null if one is not
1:230a86c:      * available yet.
2:0cc5d24:      */
1:e6747ea:     public String getBrokerName() {
1:d226f50:         try {
1:230a86c:             brokerInfoReceived.await(5, TimeUnit.SECONDS);
1:230a86c:             if (brokerInfo == null) {
1:230a86c:                 return null;
1:230a86c:             }
1:230a86c:             return brokerInfo.getBrokerName();
1:230a86c:         } catch (InterruptedException e) {
1:83fde0b:             Thread.currentThread().interrupt();
1:230a86c:             return null;
1:83fde0b:         }
1:230a86c:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Returns the broker information if it is available or null if it is not
1:230a86c:      * available yet.
1:0cc5d24:      */
1:e6747ea:     public BrokerInfo getBrokerInfo() {
1:e6747ea:         return brokerInfo;
1:3a7c673:     }
1:fb3b6db: 
1:480433b:     /**
1:d29ca2a:      * @return Returns the RedeliveryPolicy.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public RedeliveryPolicy getRedeliveryPolicy() throws JMSException {
1:a3836b5:         return redeliveryPolicyMap.getDefaultEntry();
1:3a7c673:     }
1:fb3b6db: 
1:ca067a6:     /**
1:ffb9d2a:      * Sets the redelivery policy to be used when messages are rolled back
1:0cc5d24:      */
1:ffb9d2a:     public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
1:a3836b5:         this.redeliveryPolicyMap.setDefaultEntry(redeliveryPolicy);
1:fb3b6db:     }
1:d29ca2a: 
1:05a8cba:     public BlobTransferPolicy getBlobTransferPolicy() {
1:1807dbb:         if (blobTransferPolicy == null) {
1:1807dbb:             blobTransferPolicy = createBlobTransferPolicy();
1:fb3b6db:         }
1:05a8cba:         return blobTransferPolicy;
1:fb3b6db:     }
1:d29ca2a: 
1:d964145:     /**
1:230a86c:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large
1:230a86c:      * OBjects) are transferred from producers to brokers to consumers
1:05a8cba:      */
1:05a8cba:     public void setBlobTransferPolicy(BlobTransferPolicy blobTransferPolicy) {
1:05a8cba:         this.blobTransferPolicy = blobTransferPolicy;
1:d29ca2a:     }
1:d29ca2a: 
1:05a8cba:     /**
1:d964145:      * @return Returns the alwaysSessionAsync.
1:d964145:      */
1:230a86c:     public boolean isAlwaysSessionAsync() {
1:d964145:         return alwaysSessionAsync;
1:d29ca2a:     }
1:d29ca2a: 
1:d964145:     /**
1:de7617e:      * If this flag is not set then a separate thread is not used for dispatching messages for each Session in
1:de7617e:      * the Connection. However, a separate thread is always used if there is more than one session, or the session
1:de7617e:      * isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
1:de7617e:      * happens asynchronously.
1:d964145:      */
1:480433b:     public void setAlwaysSessionAsync(boolean alwaysSessionAsync) {
1:480433b:         this.alwaysSessionAsync = alwaysSessionAsync;
1:d29ca2a:     }
1:d29ca2a: 
1:d964145:     /**
1:d964145:      * @return Returns the optimizeAcknowledge.
1:d964145:      */
1:230a86c:     public boolean isOptimizeAcknowledge() {
1:d964145:         return optimizeAcknowledge;
1:d29ca2a:     }
1:d29ca2a: 
1:d964145:     /**
1:230a86c:      * Enables an optimised acknowledgement mode where messages are acknowledged
1:230a86c:      * in batches rather than individually
1:d226f50:      *
1:d964145:      * @param optimizeAcknowledge The optimizeAcknowledge to set.
1:d964145:      */
1:230a86c:     public void setOptimizeAcknowledge(boolean optimizeAcknowledge) {
1:230a86c:         this.optimizeAcknowledge = optimizeAcknowledge;
1:d29ca2a:     }
1:d29ca2a: 
1:975fc55:     /**
1:975fc55:      * The max time in milliseconds between optimized ack batches
1:975fc55:      * @param optimizeAcknowledgeTimeOut
1:975fc55:      */
1:44488a5:     public void setOptimizeAcknowledgeTimeOut(long optimizeAcknowledgeTimeOut) {
1:975fc55:         this.optimizeAcknowledgeTimeOut =  optimizeAcknowledgeTimeOut;
1:975fc55:     }
1:975fc55: 
1:975fc55:     public long getOptimizeAcknowledgeTimeOut() {
1:975fc55:         return optimizeAcknowledgeTimeOut;
1:975fc55:     }
1:975fc55: 
1:78cf4b1:     public long getWarnAboutUnstartedConnectionTimeout() {
1:78cf4b1:         return warnAboutUnstartedConnectionTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:78cf4b1:     /**
1:230a86c:      * Enables the timeout from a connection creation to when a warning is
1:230a86c:      * generated if the connection is not properly started via {@link #start()}
1:230a86c:      * and a message is received by a consumer. It is a very common gotcha to
1:230a86c:      * forget to <a
1:230a86c:      * href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
1:230a86c:      * the connection</a> so this option makes the default case to create a
1:230a86c:      * warning if the user forgets. To disable the warning just set the value to <
1:230a86c:      * 0 (say -1).
1:78cf4b1:      */
1:78cf4b1:     public void setWarnAboutUnstartedConnectionTimeout(long warnAboutUnstartedConnectionTimeout) {
1:78cf4b1:         this.warnAboutUnstartedConnectionTimeout = warnAboutUnstartedConnectionTimeout;
1:d29ca2a:     }
1:d226f50: 
1:114a923:     /**
1:b21dc69:      * @return the sendTimeout (in milliseconds)
1:114a923:      */
1:114a923:     public int getSendTimeout() {
1:114a923:         return sendTimeout;
1:d29ca2a:     }
1:d29ca2a: 
1:114a923:     /**
1:b21dc69:      * @param sendTimeout the sendTimeout to set (in milliseconds)
1:114a923:      */
1:114a923:     public void setSendTimeout(int sendTimeout) {
1:114a923:         this.sendTimeout = sendTimeout;
1:d29ca2a:     }
1:d226f50: 
1:d8b5d5c:     /**
1:d8b5d5c:      * @return the sendAcksAsync
1:d8b5d5c:      */
1:d8b5d5c:     public boolean isSendAcksAsync() {
1:d8b5d5c:         return sendAcksAsync;
1:d29ca2a:     }
1:d29ca2a: 
1:d8b5d5c:     /**
1:d8b5d5c:      * @param sendAcksAsync the sendAcksAsync to set
1:d8b5d5c:      */
1:d8b5d5c:     public void setSendAcksAsync(boolean sendAcksAsync) {
1:d8b5d5c:         this.sendAcksAsync = sendAcksAsync;
1:d29ca2a:     }
1:d29ca2a: 
1:78cf4b1:     /**
1:78cf4b1:      * Returns the time this connection was created
1:78cf4b1:      */
1:78cf4b1:     public long getTimeCreated() {
1:78cf4b1:         return timeCreated;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private void waitForBrokerInfo() throws JMSException {
1:230a86c:         try {
1:d29ca2a:             brokerInfoReceived.await();
1:3a7c673:         } catch (InterruptedException e) {
1:230a86c:             Thread.currentThread().interrupt();
1:2984963:             throw JMSExceptionSupport.create(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // Package protected so that it can be used in unit tests
1:b34f730:     public Transport getTransport() {
1:d29ca2a:         return transport;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void addProducer(ProducerId producerId, ActiveMQMessageProducer producer) {
1:230a86c:         producers.put(producerId, producer);
1:230a86c:     }
1:230a86c: 
1:230a86c:     public void removeProducer(ProducerId producerId) {
1:230a86c:         producers.remove(producerId);
1:230a86c:     }
1:c9bb1c9: 
1:d29ca2a:     public void addDispatcher(ConsumerId consumerId, ActiveMQDispatcher dispatcher) {
1:230a86c:         dispatchers.put(consumerId, dispatcher);
1:c9bb1c9:     }
1:230a86c: 
1:d29ca2a:     public void removeDispatcher(ConsumerId consumerId) {
1:230a86c:         dispatchers.remove(consumerId);
1:d29ca2a:     }
1:230a86c: 
1:e8818fa:     public boolean hasDispatcher(ConsumerId consumerId) {
1:e8818fa:         return dispatchers.containsKey(consumerId);
1:e8818fa:     }
1:e8818fa: 
1:d29ca2a:     /**
1:86faaef:      * @param o - the command to consume
1:d29ca2a:      */
1:849baa6:     @Override
1:9ca56a0:     public void onCommand(final Object o) {
1:230a86c:         final Command command = (Command)o;
1:d29ca2a:         if (!closed.get() && command != null) {
1:230a86c:             try {
1:230a86c:                 command.visit(new CommandVisitorAdapter() {
1:849baa6:                     @Override
1:230a86c:                     public Response processMessageDispatch(MessageDispatch md) throws Exception {
1:8d3ca90:                         waitForTransportInterruptionProcessingToComplete();
1:933eb2f:                         ActiveMQDispatcher dispatcher = dispatchers.get(md.getConsumerId());
1:230a86c:                         if (dispatcher != null) {
1:230a86c:                             // Copy in case a embedded broker is dispatching via
1:230a86c:                             // vm://
1:230a86c:                             // md.getMessage() == null to signal end of queue
1:230a86c:                             // browse.
1:230a86c:                             Message msg = md.getMessage();
1:230a86c:                             if (msg != null) {
1:230a86c:                                 msg = msg.copy();
1:230a86c:                                 msg.setReadOnlyBody(true);
1:230a86c:                                 msg.setReadOnlyProperties(true);
1:230a86c:                                 msg.setRedeliveryCounter(md.getRedeliveryCounter());
1:230a86c:                                 msg.setConnection(ActiveMQConnection.this);
1:849baa6:                                 msg.setMemoryUsage(null);
1:230a86c:                                 md.setMessage(msg);
1:230a86c:                             }
1:230a86c:                             dispatcher.dispatch(md);
1:e8818fa:                         } else {
1:e8818fa:                             LOG.debug("{} no dispatcher for {} in {}", this, md, dispatchers);
1:230a86c:                         }
1:230a86c:                         return null;
1:230a86c:                     }
1:230a86c: 
1:849baa6:                     @Override
1:230a86c:                     public Response processProducerAck(ProducerAck pa) throws Exception {
1:230a86c:                         if (pa != null && pa.getProducerId() != null) {
1:230a86c:                             ActiveMQMessageProducer producer = producers.get(pa.getProducerId());
1:230a86c:                             if (producer != null) {
1:fb3b6db:                                 producer.onProducerAck(pa);
1:fb3b6db:                             }
1:fb3b6db:                         }
2:3a7c673:                         return null;
1:fb3b6db:                     }
1:230a86c: 
1:849baa6:                     @Override
1:230a86c:                     public Response processBrokerInfo(BrokerInfo info) throws Exception {
1:230a86c:                         brokerInfo = info;
1:230a86c:                         brokerInfoReceived.countDown();
1:230a86c:                         optimizeAcknowledge &= !brokerInfo.isFaultTolerantConfiguration();
1:230a86c:                         getBlobTransferPolicy().setBrokerUploadUrl(info.getBrokerUploadUrl());
1:230a86c:                         return null;
1:230a86c:                     }
1:230a86c: 
1:849baa6:                     @Override
1:230a86c:                     public Response processConnectionError(final ConnectionError error) throws Exception {
1:1a5ad28:                         executor.execute(new Runnable() {
1:849baa6:                             @Override
1:230a86c:                             public void run() {
1:230a86c:                                 onAsyncException(error.getException());
1:230a86c:                             }
1:230a86c:                         });
1:230a86c:                         return null;
1:230a86c:                     }
1:230a86c: 
1:849baa6:                     @Override
1:230a86c:                     public Response processControlCommand(ControlCommand command) throws Exception {
1:230a86c:                         return null;
1:230a86c:                     }
1:230a86c: 
1:849baa6:                     @Override
1:230a86c:                     public Response processConnectionControl(ConnectionControl control) throws Exception {
1:230a86c:                         onConnectionControl((ConnectionControl)command);
1:230a86c:                         return null;
1:230a86c:                     }
1:230a86c: 
1:849baa6:                     @Override
1:230a86c:                     public Response processConsumerControl(ConsumerControl control) throws Exception {
1:230a86c:                         onConsumerControl((ConsumerControl)command);
1:230a86c:                         return null;
1:230a86c:                     }
1:230a86c: 
1:849baa6:                     @Override
1:230a86c:                     public Response processWireFormat(WireFormatInfo info) throws Exception {
1:230a86c:                         onWireFormatInfo((WireFormatInfo)command);
1:230a86c:                         return null;
1:230a86c:                     }
1:230a86c:                 });
1:230a86c:             } catch (Exception e) {
1:0acf545:                 onClientInternalException(e);
1:230a86c:             }
1:fb3b6db:         }
1:3d5a758: 
1:933eb2f:         for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
1:933eb2f:             TransportListener listener = iter.next();
1:2bc9a83:             listener.onCommand(command);
1:fb3b6db:         }
1:fb3b6db:     }
1:230a86c: 
1:1a3f54c:     protected void onWireFormatInfo(WireFormatInfo info) {
1:230a86c:         protocolVersion.set(info.getVersion());
1:230a86c:     }
1:fb3b6db: 
1:230a86c:     /**
1:0acf545:      * Handles async client internal exceptions.
1:0acf545:      * A client internal exception is usually one that has been thrown
1:6d1f57b:      * by a container runtime component during asynchronous processing of a
1:0acf545:      * message that does not affect the connection itself.
1:0acf545:      * This method notifies the <code>ClientInternalExceptionListener</code> by invoking
1:0acf545:      * its <code>onException</code> method, if one has been registered with this connection.
1:d226f50:      *
1:0acf545:      * @param error the exception that the problem
1:0acf545:      */
1:0acf545:     public void onClientInternalException(final Throwable error) {
1:0acf545:         if ( !closed.get() && !closing.get() ) {
1:0acf545:             if ( this.clientInternalExceptionListener != null ) {
1:1a5ad28:                 executor.execute(new Runnable() {
1:849baa6:                     @Override
1:fb3b6db:                     public void run() {
1:0acf545:                         ActiveMQConnection.this.clientInternalExceptionListener.onException(error);
1:fb3b6db:                     }
1:fb3b6db:                 });
1:74a7a8b:             } else {
1:d226f50:                 LOG.debug("Async client internal exception occurred with no exception listener registered: "
1:0acf545:                         + error, error);
1:fb3b6db:             }
1:fb3b6db:         }
1:fb3b6db:     }
1:fb3b6db: 
1:1a3f54c:     /**
1:d29ca2a:      * Used for handling async exceptions
1:d226f50:      *
1:d29ca2a:      * @param error
1:d29ca2a:      */
1:d29ca2a:     public void onAsyncException(Throwable error) {
1:7f9f040:         if (!closed.get() && !closing.get()) {
1:d29ca2a:             if (this.exceptionListener != null) {
1:230a86c: 
1:74a7a8b:                 if (!(error instanceof JMSException)) {
1:d29ca2a:                     error = JMSExceptionSupport.create(error);
1:74a7a8b:                 }
1:230a86c:                 final JMSException e = (JMSException)error;
1:230a86c: 
1:1a5ad28:                 executor.execute(new Runnable() {
1:849baa6:                     @Override
1:dcf7dea:                     public void run() {
1:dcf7dea:                         ActiveMQConnection.this.exceptionListener.onException(e);
1:c9bb1c9:                     }
1:fb3b6db:                 });
1:230a86c: 
1:74a7a8b:             } else {
1:ce7495e:                 LOG.debug("Async exception with no exception listener: " + error, error);
1:dcf7dea:             }
1:dcf7dea:         }
1:d29ca2a:     }
1:230a86c: 
1:849baa6:     @Override
1:dcf7dea:     public void onException(final IOException error) {
1:d226f50:         onAsyncException(error);
1:63b2e5c:         if (!closed.get() && !closing.get()) {
1:d226f50:             executor.execute(new Runnable() {
1:849baa6:                 @Override
1:d226f50:                 public void run() {
1:d226f50:                     transportFailed(error);
1:d226f50:                     ServiceSupport.dispose(ActiveMQConnection.this.transport);
1:d226f50:                     brokerInfoReceived.countDown();
1:d226f50:                     try {
1:b29eb38:                         doCleanup(true);
1:934f3ce:                     } catch (JMSException e) {
1:d226f50:                         LOG.warn("Exception during connection cleanup, " + e, e);
1:d226f50:                     }
1:3d5a758:                     for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
1:d226f50:                         TransportListener listener = iter.next();
1:d226f50:                         listener.onException(error);
1:d226f50:                     }
1:d226f50:                 }
1:d226f50:             });
1:d226f50:         }
1:d226f50:     }
1:230a86c: 
1:849baa6:     @Override
1:2bc9a83:     public void transportInterupted() {
1:dc0291b:         transportInterruptionProcessingComplete.set(1);
1:933eb2f:         for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:933eb2f:             ActiveMQSession s = i.next();
1:dc0291b:             s.clearMessagesInProgress(transportInterruptionProcessingComplete);
1:dcf7dea:         }
1:230a86c: 
1:ad06a5f:         for (ActiveMQConnectionConsumer connectionConsumer : this.connectionConsumers) {
1:dc0291b:             connectionConsumer.clearMessagesInProgress(transportInterruptionProcessingComplete);
1:dc0291b:         }
1:dc0291b: 
1:dc0291b:         if (transportInterruptionProcessingComplete.decrementAndGet() > 0) {
1:dc0291b:             if (LOG.isDebugEnabled()) {
1:dc0291b:                 LOG.debug("transport interrupted - processing required, dispatchers: " + transportInterruptionProcessingComplete.get());
1:dc0291b:             }
1:dc0291b:             signalInterruptionProcessingNeeded();
1:ad06a5f:         }
1:d226f50: 
1:933eb2f:         for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
1:933eb2f:             TransportListener listener = iter.next();
1:2bc9a83:             listener.transportInterupted();
1:b836af8:         }
1:862cd71:     }
1:4c4f0d1: 
1:849baa6:     @Override
1:2bc9a83:     public void transportResumed() {
2:933eb2f:         for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
2:933eb2f:             TransportListener listener = iter.next();
1:2bc9a83:             listener.transportResumed();
1:dcf7dea:         }
1:d29ca2a:     }
1:dcf7dea: 
1:d29ca2a:     /**
1:d29ca2a:      * Create the DestinationInfo object for the temporary destination.
1:d226f50:      *
1:d29ca2a:      * @param topic - if its true topic, else queue.
1:d29ca2a:      * @return DestinationInfo
1:230a86c:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     protected ActiveMQTempDestination createTempDestination(boolean topic) throws JMSException {
1:230a86c: 
1:d29ca2a:         // Check if Destination info is of temporary type.
1:d29ca2a:         ActiveMQTempDestination dest;
1:230a86c:         if (topic) {
1:d29ca2a:             dest = new ActiveMQTempTopic(info.getConnectionId(), tempDestinationIdGenerator.getNextSequenceId());
5:d29ca2a:         } else {
1:d29ca2a:             dest = new ActiveMQTempQueue(info.getConnectionId(), tempDestinationIdGenerator.getNextSequenceId());
1:d29ca2a:         }
1:230a86c: 
2:d29ca2a:         DestinationInfo info = new DestinationInfo();
2:d29ca2a:         info.setConnectionId(this.info.getConnectionId());
1:d29ca2a:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
1:d29ca2a:         info.setDestination(dest);
3:d29ca2a:         syncSendPacket(info);
1:230a86c: 
1:d29ca2a:         dest.setConnection(this);
1:230a86c:         activeTempDestinations.put(dest, dest);
1:d29ca2a:         return dest;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
2:d29ca2a:      * @param destination
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void deleteTempDestination(ActiveMQTempDestination destination) throws JMSException {
1:230a86c: 
1:230a86c:         checkClosedOrFailed();
1:d29ca2a: 
1:3d5a758:         for (ActiveMQSession session : this.sessions) {
1:3d5a758:             if (session.isInUse(destination)) {
1:230a86c:                 throw new JMSException("A consumer is consuming from the temporary destination");
1:230a86c:             }
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         activeTempDestinations.remove(destination);
1:d29ca2a: 
1:204f91f:         DestinationInfo destInfo = new DestinationInfo();
1:204f91f:         destInfo.setConnectionId(this.info.getConnectionId());
1:204f91f:         destInfo.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:204f91f:         destInfo.setDestination(destination);
1:204f91f:         destInfo.setTimeout(0);
1:204f91f:         syncSendPacket(destInfo);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isDeleted(ActiveMQDestination dest) {
1:230a86c: 
1:230a86c:         // If we are not watching the advisories.. then
1:230a86c:         // we will assume that the temp destination does exist.
1:74a7a8b:         if (advisoryConsumer == null) {
1:230a86c:             return false;
1:74a7a8b:         }
1:230a86c: 
1:9ef4259:         return !activeTempDestinations.containsValue(dest);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isCopyMessageOnSend() {
1:d29ca2a:         return copyMessageOnSend;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public LongSequenceGenerator getLocalTransactionIdGenerator() {
1:d29ca2a:         return localTransactionIdGenerator;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isUseCompression() {
1:d29ca2a:         return useCompression;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:c085df4:      * Enables the use of compression of the message bodies
1:c085df4:      */
1:d29ca2a:     public void setUseCompression(boolean useCompression) {
1:d29ca2a:         this.useCompression = useCompression;
1:230a86c:     }
1:d29ca2a: 
1:d29ca2a:     public void destroyDestination(ActiveMQDestination destination) throws JMSException {
1:230a86c: 
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         ensureConnectionInfoSent();
1:d29ca2a: 
1:d29ca2a:         DestinationInfo info = new DestinationInfo();
1:d29ca2a:         info.setConnectionId(this.info.getConnectionId());
2:d29ca2a:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
2:d29ca2a:         info.setDestination(destination);
1:cb1d21f:         info.setTimeout(0);
1:d29ca2a:         syncSendPacket(info);
1:d29ca2a:     }
1:d29ca2a: 
1:480433b:     public boolean isDispatchAsync() {
1:480433b:         return dispatchAsync;
1:d29ca2a:     }
1:d29ca2a: 
1:0acf545:     /**
1:480433b:      * Enables or disables the default setting of whether or not consumers have
1:480433b:      * their messages <a
1:3013c20:      * href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
1:230a86c:      * synchronously or asynchronously by the broker</a>. For non-durable
1:230a86c:      * topics for example we typically dispatch synchronously by default to
1:230a86c:      * minimize context switches which boost performance. However sometimes its
1:230a86c:      * better to go slower to ensure that a single blocked consumer socket does
1:230a86c:      * not block delivery to other consumers.
1:d226f50:      *
1:230a86c:      * @param asyncDispatch If true then consumers created on this connection
1:230a86c:      *                will default to having their messages dispatched
1:09ff99f:      *                asynchronously. The default value is true.
1:480433b:      */
1:480433b:     public void setDispatchAsync(boolean asyncDispatch) {
1:480433b:         this.dispatchAsync = asyncDispatch;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public boolean isObjectMessageSerializationDefered() {
1:d29ca2a:         return objectMessageSerializationDefered;
1:d29ca2a:     }
1:d29ca2a: 
1:4b08ea5:     /**
1:4b08ea5:      * When an object is set on an ObjectMessage, the JMS spec requires the
1:4b08ea5:      * object to be serialized by that set method. Enabling this flag causes the
1:4b08ea5:      * object to not get serialized. The object may subsequently get serialized
1:4b08ea5:      * if the message needs to be sent over a socket or stored to disk.
1:4b08ea5:      */
1:d29ca2a:     public void setObjectMessageSerializationDefered(boolean objectMessageSerializationDefered) {
1:d29ca2a:         this.objectMessageSerializationDefered = objectMessageSerializationDefered;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Unsubscribes a durable subscription that has been created by a client.
1:d29ca2a:      * <P>
1:d29ca2a:      * This method deletes the state being maintained on behalf of the
1:d29ca2a:      * subscriber by its provider.
1:d29ca2a:      * <P>
1:d29ca2a:      * It is erroneous for a client to delete a durable subscription while there
1:230a86c:      * is an active <CODE>MessageConsumer </CODE> or
1:230a86c:      * <CODE>TopicSubscriber</CODE> for the subscription, or while a consumed
1:230a86c:      * message is part of a pending transaction or has not been acknowledged in
1:230a86c:      * the session.
1:d226f50:      *
1:230a86c:      * @param name the name used to identify this subscription
1:230a86c:      * @throws JMSException if the session fails to unsubscribe to the durable
1:230a86c:      *                 subscription due to some internal error.
1:230a86c:      * @throws InvalidDestinationException if an invalid subscription name is
1:230a86c:      *                 specified.
1:d29ca2a:      * @since 1.1
1:d29ca2a:      */
1:e08cc35:     public void unsubscribe(String name) throws InvalidDestinationException, JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a:         RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
1:d29ca2a:         rsi.setConnectionId(getConnectionInfo().getConnectionId());
1:933eb2f:         rsi.setSubscriptionName(name);
1:d29ca2a:         rsi.setClientId(getConnectionInfo().getClientId());
1:d29ca2a:         syncSendPacket(rsi);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Internal send method optimized: - It does not copy the message - It can
1:230a86c:      * only handle ActiveMQ messages. - You can specify if the send is async or
1:230a86c:      * sync - Does not allow you to send /w a transaction.
1:d29ca2a:      */
1:d29ca2a:     void send(ActiveMQDestination destination, ActiveMQMessage msg, MessageId messageId, int deliveryMode, int priority, long timeToLive, boolean async) throws JMSException {
1:36a2bdc:         checkClosedOrFailed();
1:d29ca2a: 
1:230a86c:         if (destination.isTemporary() && isDeleted(destination)) {
1:230a86c:             throw new JMSException("Cannot publish to a deleted Destination: " + destination);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         msg.setJMSDestination(destination);
1:230a86c:         msg.setJMSDeliveryMode(deliveryMode);
1:d29ca2a:         long expiration = 0L;
1:d29ca2a: 
1:d29ca2a:         if (!isDisableTimeStampsByDefault()) {
1:d29ca2a:             long timeStamp = System.currentTimeMillis();
1:d29ca2a:             msg.setJMSTimestamp(timeStamp);
1:d29ca2a:             if (timeToLive > 0) {
1:d29ca2a:                 expiration = timeToLive + timeStamp;
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         msg.setJMSExpiration(expiration);
1:d29ca2a:         msg.setJMSPriority(priority);
1:230a86c:         msg.setJMSRedelivered(false);
1:230a86c:         msg.setMessageId(messageId);
1:d29ca2a:         msg.onSend();
1:d29ca2a:         msg.setProducerId(msg.getMessageId().getProducerId());
1:230a86c: 
1:b836af8:         if (LOG.isDebugEnabled()) {
1:230a86c:             LOG.debug("Sending message: " + msg);
1:d29ca2a:         }
1:230a86c: 
1:230a86c:         if (async) {
1:d29ca2a:             asyncSendPacket(msg);
1:d29ca2a:         } else {
1:d29ca2a:             syncSendPacket(msg);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     protected void onConnectionControl(ConnectionControl command) {
1:230a86c:         if (command.isFaultTolerant()) {
1:ef0734b:             this.optimizeAcknowledge = false;
1:933eb2f:             for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:933eb2f:                 ActiveMQSession s = i.next();
1:ef0734b:                 s.setOptimizeAcknowledge(false);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     protected void onConsumerControl(ConsumerControl command) {
1:230a86c:         if (command.isClose()) {
1:3d5a758:             for (ActiveMQSession session : this.sessions) {
1:3d5a758:                 session.close(command.getConsumerId());
1:d29ca2a:             }
1:230a86c:         } else {
1:3d5a758:             for (ActiveMQSession session : this.sessions) {
1:3d5a758:                 session.setPrefetchSize(command.getConsumerId(), command.getPrefetch());
1:d29ca2a:             }
1:757a2f1:             for (ActiveMQConnectionConsumer connectionConsumer: connectionConsumers) {
1:757a2f1:                 ConsumerInfo consumerInfo = connectionConsumer.getConsumerInfo();
1:757a2f1:                 if (consumerInfo.getConsumerId().equals(command.getConsumerId())) {
1:757a2f1:                     consumerInfo.setPrefetchSize(command.getPrefetch());
1:757a2f1:                 }
1:757a2f1:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     protected void transportFailed(IOException error) {
1:36a2bdc:         transportFailed.set(true);
1:daf48bb:         if (firstFailureError == null) {
1:daf48bb:             firstFailureError = error;
1:7f9f040:         }
1:d29ca2a:     }
1:d29ca2a: 
1:c085df4:     /**
1:c085df4:      * Should a JMS message be copied to a new JMS Message object as part of the
1:c085df4:      * send() method in JMS. This is enabled by default to be compliant with the
1:c085df4:      * JMS specification. You can disable it if you do not mutate JMS messages
1:c085df4:      * after they are sent for a performance boost
1:c085df4:      */
1:d29ca2a:     public void setCopyMessageOnSend(boolean copyMessageOnSend) {
1:d29ca2a:         this.copyMessageOnSend = copyMessageOnSend;
1:d29ca2a:     }
1:230a86c: 
1:849baa6:     @Override
1:d29ca2a:     public String toString() {
1:230a86c:         return "ActiveMQConnection {id=" + info.getConnectionId() + ",clientId=" + info.getClientId() + ",started=" + started.get() + "}";
1:d29ca2a:     }
1:d29ca2a: 
1:1807dbb:     protected BlobTransferPolicy createBlobTransferPolicy() {
1:1807dbb:         return new BlobTransferPolicy();
1:d29ca2a:     }
1:1a3f54c: 
1:230a86c:     public int getProtocolVersion() {
1:230a86c:         return protocolVersion.get();
1:1a3f54c:     }
1:c9bb1c9: 
1:230a86c:     public int getProducerWindowSize() {
1:230a86c:         return producerWindowSize;
1:c9bb1c9:     }
1:c9bb1c9: 
1:230a86c:     public void setProducerWindowSize(int producerWindowSize) {
1:230a86c:         this.producerWindowSize = producerWindowSize;
1:230a86c:     }
1:230a86c: 
1:2a58f4c:     public void setAuditDepth(int auditDepth) {
1:2a58f4c:         connectionAudit.setAuditDepth(auditDepth);
1:d226f50:     }
1:c9bb1c9: 
1:2a58f4c:     public void setAuditMaximumProducerNumber(int auditMaximumProducerNumber) {
1:2a58f4c:         connectionAudit.setAuditMaximumProducerNumber(auditMaximumProducerNumber);
1:d226f50:     }
1:c9bb1c9: 
1:230a86c:     protected void removeDispatcher(ActiveMQDispatcher dispatcher) {
1:230a86c:         connectionAudit.removeDispatcher(dispatcher);
1:230a86c:     }
1:230a86c: 
1:230a86c:     protected boolean isDuplicate(ActiveMQDispatcher dispatcher, Message message) {
1:794e62f:         return checkForDuplicates && connectionAudit.isDuplicate(dispatcher, message);
1:230a86c:     }
1:230a86c: 
1:230a86c:     protected void rollbackDuplicate(ActiveMQDispatcher dispatcher, Message message) {
1:230a86c:         connectionAudit.rollbackDuplicate(dispatcher, message);
1:c9bb1c9:     }
1:c9bb1c9: 
1:d226f50:     public IOException getFirstFailureError() {
1:d226f50:         return firstFailureError;
1:d226f50:     }
1:d226f50: 
1:d226f50:     protected void waitForTransportInterruptionProcessingToComplete() throws InterruptedException {
1:dc0291b:         if (!closed.get() && !transportFailed.get() && transportInterruptionProcessingComplete.get()>0) {
1:dc0291b:             LOG.warn("dispatch with outstanding dispatch interruption processing count " + transportInterruptionProcessingComplete.get());
1:d226f50:             signalInterruptionProcessingComplete();
1:862cd71:         }
1:862cd71:     }
1:d226f50: 
1:d226f50:     protected void transportInterruptionProcessingComplete() {
1:dc0291b:         if (transportInterruptionProcessingComplete.decrementAndGet() == 0) {
1:dc0291b:             signalInterruptionProcessingComplete();
1:d226f50:         }
1:d226f50:     }
1:8d3ca90: 
1:dc0291b:     private void signalInterruptionProcessingComplete() {
1:862cd71:             if (LOG.isDebugEnabled()) {
1:dc0291b:                 LOG.debug("transportInterruptionProcessingComplete: " + transportInterruptionProcessingComplete.get()
1:dc0291b:                         + " for:" + this.getConnectionInfo().getConnectionId());
1:862cd71:             }
1:862cd71: 
1:8d3ca90:             FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);
1:8d3ca90:             if (failoverTransport != null) {
1:8d3ca90:                 failoverTransport.connectionInterruptProcessingComplete(this.getConnectionInfo().getConnectionId());
1:8d3ca90:                 if (LOG.isDebugEnabled()) {
1:de04214:                     LOG.debug("notified failover transport (" + failoverTransport
1:de04214:                             + ") of interruption completion for: " + this.getConnectionInfo().getConnectionId());
1:8d3ca90:                 }
1:8d3ca90:             }
1:dc0291b:             transportInterruptionProcessingComplete.set(0);
1:8d3ca90:     }
1:b836af8: 
1:4c4f0d1:     private void signalInterruptionProcessingNeeded() {
1:4c4f0d1:         FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);
1:4c4f0d1:         if (failoverTransport != null) {
1:4c4f0d1:             failoverTransport.getStateTracker().transportInterrupted(this.getConnectionInfo().getConnectionId());
1:4c4f0d1:             if (LOG.isDebugEnabled()) {
1:4c4f0d1:                 LOG.debug("notified failover transport (" + failoverTransport
1:4c4f0d1:                         + ") of pending interruption processing for: " + this.getConnectionInfo().getConnectionId());
1:4c4f0d1:             }
1:4c4f0d1:         }
1:4c4f0d1:     }
1:4c4f0d1: 
1:b836af8:     /*
1:b836af8:      * specify the amount of time in milliseconds that a consumer with a transaction pending recovery
1:b836af8:      * will wait to receive re dispatched messages.
1:b836af8:      * default value is 0 so there is no wait by default.
1:b836af8:      */
1:b836af8:     public void setConsumerFailoverRedeliveryWaitPeriod(long consumerFailoverRedeliveryWaitPeriod) {
1:b836af8:         this.consumerFailoverRedeliveryWaitPeriod = consumerFailoverRedeliveryWaitPeriod;
1:b836af8:     }
1:d226f50: 
1:b836af8:     public long getConsumerFailoverRedeliveryWaitPeriod() {
1:b836af8:         return consumerFailoverRedeliveryWaitPeriod;
1:b836af8:     }
1:d226f50: 
1:97ae323:     protected Scheduler getScheduler() throws JMSException {
1:97ae323:         Scheduler result = scheduler;
1:97ae323:         if (result == null) {
1:de549f8:             if (isClosing() || isClosed()) {
1:de549f8:                 // without lock contention report the closing state
1:de549f8:                 throw new ConnectionClosedException();
1:de549f8:             }
1:97ae323:             synchronized (this) {
1:97ae323:                 result = scheduler;
1:97ae323:                 if (result == null) {
1:97ae323:                     checkClosed();
1:97ae323:                     try {
1:d54e0d6:                         result = new Scheduler("ActiveMQConnection["+info.getConnectionId().getValue()+"] Scheduler");
1:d54e0d6:                         result.start();
1:d54e0d6:                         scheduler = result;
1:97ae323:                     } catch(Exception e) {
1:97ae323:                         throw JMSExceptionSupport.create(e);
1:97ae323:                     }
1:97ae323:                 }
1:97ae323:             }
1:97ae323:         }
1:97ae323:         return result;
1:8d3ca90:     }
1:d226f50: 
1:1a5ad28:     protected ThreadPoolExecutor getExecutor() {
1:1a5ad28:         return this.executor;
1:8d3ca90:     }
1:b836af8: 
1:c34851f:     protected CopyOnWriteArrayList<ActiveMQSession> getSessions() {
1:c34851f:         return sessions;
1:c34851f:     }
1:c34851f: 
1:794e62f:     /**
1:794e62f:      * @return the checkForDuplicates
1:794e62f:      */
1:794e62f:     public boolean isCheckForDuplicates() {
1:794e62f:         return this.checkForDuplicates;
1:862cd71:     }
1:862cd71: 
1:794e62f:     /**
1:794e62f:      * @param checkForDuplicates the checkForDuplicates to set
1:794e62f:      */
1:794e62f:     public void setCheckForDuplicates(boolean checkForDuplicates) {
1:794e62f:         this.checkForDuplicates = checkForDuplicates;
1:862cd71:     }
1:2030097: 
1:2030097:     public boolean isTransactedIndividualAck() {
1:2030097:         return transactedIndividualAck;
1:2030097:     }
1:2030097: 
1:2030097:     public void setTransactedIndividualAck(boolean transactedIndividualAck) {
1:2030097:         this.transactedIndividualAck = transactedIndividualAck;
1:2030097:     }
1:2030097: 
1:0b6bf7e:     public boolean isNonBlockingRedelivery() {
1:0b6bf7e:         return nonBlockingRedelivery;
1:0b6bf7e:     }
1:0b6bf7e: 
1:0b6bf7e:     public void setNonBlockingRedelivery(boolean nonBlockingRedelivery) {
1:0b6bf7e:         this.nonBlockingRedelivery = nonBlockingRedelivery;
1:0b6bf7e:     }
1:0b6bf7e: 
1:221a751:     public boolean isRmIdFromConnectionId() {
1:221a751:         return rmIdFromConnectionId;
1:221a751:     }
1:221a751: 
1:221a751:     public void setRmIdFromConnectionId(boolean rmIdFromConnectionId) {
1:221a751:         this.rmIdFromConnectionId = rmIdFromConnectionId;
1:221a751:     }
1:221a751: 
1:d226f50:     /**
1:d226f50:      * Removes any TempDestinations that this connection has cached, ignoring
1:d226f50:      * any exceptions generated because the destination is in use as they should
1:d226f50:      * not be removed.
1:27440ae:      * Used from a pooled connection, b/c it will not be explicitly closed.
1:d226f50:      */
1:d226f50:     public void cleanUpTempDestinations() {
1:d226f50: 
1:d226f50:         if (this.activeTempDestinations == null || this.activeTempDestinations.isEmpty()) {
1:d226f50:             return;
1:d226f50:         }
1:d226f50: 
1:9ef4259:         Iterator<ConcurrentMap.Entry<ActiveMQTempDestination, ActiveMQTempDestination>> entries
1:d226f50:             = this.activeTempDestinations.entrySet().iterator();
1:d226f50:         while(entries.hasNext()) {
1:9ef4259:             ConcurrentMap.Entry<ActiveMQTempDestination, ActiveMQTempDestination> entry = entries.next();
1:d226f50:             try {
1:2f4d11f:                 // Only delete this temp destination if it was created from this connection. The connection used
1:83fde0b:                 // for the advisory consumer may also have a reference to this temp destination.
1:83fde0b:                 ActiveMQTempDestination dest = entry.getValue();
1:2f4d11f:                 String thisConnectionId = (info.getConnectionId() == null) ? "" : info.getConnectionId().toString();
1:2f4d11f:                 if (dest.getConnectionId() != null && dest.getConnectionId().equals(thisConnectionId)) {
1:d226f50:                     this.deleteTempDestination(entry.getValue());
1:862cd71:                 }
1:d226f50:             } catch (Exception ex) {
1:d226f50:                 // the temp dest is in use so it can not be deleted.
1:d226f50:                 // it is ok to leave it to connection tear down phase
1:d226f50:             }
1:d226f50:         }
1:d226f50:     }
1:d226f50: 
1:c085df4:     /**
1:a3836b5:      * Sets the Connection wide RedeliveryPolicyMap for handling messages that are being rolled back.
1:a3836b5:      * @param redeliveryPolicyMap the redeliveryPolicyMap to set
1:a3836b5:      */
1:a3836b5:     public void setRedeliveryPolicyMap(RedeliveryPolicyMap redeliveryPolicyMap) {
1:a3836b5:         this.redeliveryPolicyMap = redeliveryPolicyMap;
1:a3836b5:     }
1:a3836b5: 
1:a3836b5:     /**
1:a3836b5:      * Gets the Connection's configured RedeliveryPolicyMap which will be used by all the
1:a3836b5:      * Consumers when dealing with transaction messages that have been rolled back.
1:a3836b5:      *
1:a3836b5:      * @return the redeliveryPolicyMap
1:a3836b5:      */
1:a3836b5:     public RedeliveryPolicyMap getRedeliveryPolicyMap() {
1:a3836b5:         return redeliveryPolicyMap;
1:a3836b5:     }
1:d29ca2a: 
1:c33231b:     public int getMaxThreadPoolSize() {
1:c33231b:         return maxThreadPoolSize;
1:d29ca2a:     }
1:d29ca2a: 
1:c33231b:     public void setMaxThreadPoolSize(int maxThreadPoolSize) {
1:c33231b:         this.maxThreadPoolSize = maxThreadPoolSize;
1:d29ca2a:     }
1:6da702b: 
1:6da702b:     /**
1:6da702b:      * Enable enforcement of QueueConnection semantics.
1:6da702b:      *
1:6da702b:      * @return this object, useful for chaining
1:6da702b:      */
1:6da702b:     ActiveMQConnection enforceQueueOnlyConnection() {
1:6da702b:         this.queueOnlyConnection = true;
1:6da702b:         return this;
1:6da702b:     }
1:d29ca2a: 
1:e3fcf71:     public RejectedExecutionHandler getRejectedTaskHandler() {
1:e3fcf71:         return rejectedTaskHandler;
1:d29ca2a:     }
1:d29ca2a: 
1:e3fcf71:     public void setRejectedTaskHandler(RejectedExecutionHandler rejectedTaskHandler) {
1:e3fcf71:         this.rejectedTaskHandler = rejectedTaskHandler;
1:d29ca2a:     }
1:3d5a758: 
1:3d5a758:     /**
1:3d5a758:      * Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
1:3d5a758:      * to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
1:3d5a758:      * will not do any background Message acknowledgment.
1:3d5a758:      *
1:3d5a758:      * @return the scheduledOptimizedAckInterval
1:3d5a758:      */
1:3d5a758:     public long getOptimizedAckScheduledAckInterval() {
1:3d5a758:         return optimizedAckScheduledAckInterval;
1:3d5a758:     }
1:3d5a758: 
1:3d5a758:     /**
1:3d5a758:      * Sets the amount of time between scheduled sends of any outstanding Message Acks for consumers that
1:3d5a758:      * have been configured with optimizeAcknowledge enabled.
1:3d5a758:      *
1:27440ae:      * @param optimizedAckScheduledAckInterval the scheduledOptimizedAckInterval to set
1:3d5a758:      */
1:3d5a758:     public void setOptimizedAckScheduledAckInterval(long optimizedAckScheduledAckInterval) {
1:3d5a758:         this.optimizedAckScheduledAckInterval = optimizedAckScheduledAckInterval;
1:3d5a758:     }
1:642cc43: 
1:642cc43:     /**
1:642cc43:      * @return true if MessageConsumer instance will check for expired messages before dispatch.
1:642cc43:      */
1:642cc43:     public boolean isConsumerExpiryCheckEnabled() {
1:642cc43:         return consumerExpiryCheckEnabled;
1:642cc43:     }
1:642cc43: 
1:642cc43:     /**
1:642cc43:      * Controls whether message expiration checking is done in each MessageConsumer
1:642cc43:      * prior to dispatching a message.  Disabling this check can lead to consumption
1:642cc43:      * of expired messages.
1:642cc43:      *
1:642cc43:      * @param consumerExpiryCheckEnabled
1:642cc43:      *        controls whether expiration checking is done prior to dispatch.
1:642cc43:      */
1:642cc43:     public void setConsumerExpiryCheckEnabled(boolean consumerExpiryCheckEnabled) {
1:642cc43:         this.consumerExpiryCheckEnabled = consumerExpiryCheckEnabled;
1:642cc43:     }
1:94446e5: 
1:94446e5:     public List<String> getTrustedPackages() {
1:94446e5:         return trustedPackages;
1:94446e5:     }
1:94446e5: 
1:94446e5:     public void setTrustedPackages(List<String> trustedPackages) {
1:94446e5:         this.trustedPackages = trustedPackages;
1:94446e5:     }
1:94446e5: 
1:94446e5:     public boolean isTrustAllPackages() {
1:94446e5:         return trustAllPackages;
1:94446e5:     }
1:94446e5: 
1:94446e5:     public void setTrustAllPackages(boolean trustAllPackages) {
1:94446e5:         this.trustAllPackages = trustAllPackages;
1:94446e5:     }
1:f43c090: 
1:f43c090:     public int getConnectResponseTimeout() {
1:db8c771:         return connectResponseTimeout;
1:f43c090:     }
1:f43c090: 
1:db8c771:     public void setConnectResponseTimeout(int connectResponseTimeout) {
1:db8c771:         this.connectResponseTimeout = connectResponseTimeout;
1:db8c771:     }
1:f43c090: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:db8c771
/////////////////////////////////////////////////////////////////////////
1:     public final ConcurrentMap<ActiveMQTempDestination, ActiveMQTempDestination> activeTempDestinations = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:     private final CopyOnWriteArrayList<ActiveMQSession> sessions = new CopyOnWriteArrayList<>();
1:     private final CopyOnWriteArrayList<ActiveMQConnectionConsumer> connectionConsumers = new CopyOnWriteArrayList<>();
1:     private final CopyOnWriteArrayList<TransportListener> transportListeners = new CopyOnWriteArrayList<>();
1:     private final ConcurrentMap<ConsumerId, ActiveMQDispatcher> dispatchers = new ConcurrentHashMap<>();
1:     private final ConcurrentMap<ProducerId, ActiveMQMessageProducer> producers = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:     private List<String> trustedPackages = new ArrayList<>();
1:     private int connectResponseTimeout;
/////////////////////////////////////////////////////////////////////////
1:             Map<String, String> options = new HashMap<>(info.getDestination().getOptions());
/////////////////////////////////////////////////////////////////////////
1:             Map<String, String> options = new HashMap<>(consumerInfo.getDestination().getOptions());
/////////////////////////////////////////////////////////////////////////
1:                         if (exception != null) {
1:                                 if (isClosed() || closing.get()) {
/////////////////////////////////////////////////////////////////////////
1:                                     try {
1:                                         forceCloseOnSecurityException(exception);
1:                                     } catch (Throwable t) {
1:                                         // We throw the original error from the ExceptionResponse instead.
1:                                     }
1:                                 if (jmsEx != null) {
/////////////////////////////////////////////////////////////////////////
1:                         if (isClosed() || closing.get()) {
/////////////////////////////////////////////////////////////////////////
1:                             try {
1:                                 forceCloseOnSecurityException(er.getException());
1:                             } catch (Throwable t) {
1:                                 // We throw the original error from the ExceptionResponse instead.
1:                             }
1:                         if (jmsEx != null) {
/////////////////////////////////////////////////////////////////////////
1:         return connectResponseTimeout;
1:     public void setConnectResponseTimeout(int connectResponseTimeout) {
1:         this.connectResponseTimeout = connectResponseTimeout;
1:     }
commit:f43c090
/////////////////////////////////////////////////////////////////////////
0: 	private int connectResponseTimeout;
/////////////////////////////////////////////////////////////////////////
1:             syncSendPacket(info.copy(), getConnectResponseTimeout());
/////////////////////////////////////////////////////////////////////////
1: 
1:     public int getConnectResponseTimeout() {
0:     	return connectResponseTimeout;
1:     }
1: 
0: 	public void setConnectResponseTimeout(int connectResponseTimeout) {
0: 		this.connectResponseTimeout = connectResponseTimeout;
1: 	}
commit:08d7977
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:         if (!transacted) {
1:             if (acknowledgeMode == Session.SESSION_TRANSACTED) {
1:         return new ActiveMQSession(this, getNextSessionId(), transacted ? Session.SESSION_TRANSACTED : acknowledgeMode, isDispatchAsync(), isAlwaysSessionAsync());
commit:61b2f6b
/////////////////////////////////////////////////////////////////////////
1:      * @return a newly created ConsumedId unique to this connection session instance.
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @return the broker Response for the given Command.
1:      *
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
0:     public final ConcurrentMap<ActiveMQTempDestination, ActiveMQTempDestination> activeTempDestinations = new ConcurrentHashMap<ActiveMQTempDestination, ActiveMQTempDestination>();
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentMap<ConsumerId, ActiveMQDispatcher> dispatchers = new ConcurrentHashMap<ConsumerId, ActiveMQDispatcher>();
0:     private final ConcurrentMap<ProducerId, ActiveMQMessageProducer> producers = new ConcurrentHashMap<ProducerId, ActiveMQMessageProducer>();
/////////////////////////////////////////////////////////////////////////
1:         return !activeTempDestinations.containsValue(dest);
/////////////////////////////////////////////////////////////////////////
1:         Iterator<ConcurrentMap.Entry<ActiveMQTempDestination, ActiveMQTempDestination>> entries
1:             ConcurrentMap.Entry<ActiveMQTempDestination, ActiveMQTempDestination> entry = entries.next();
commit:8858dc2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class ActiveMQConnection implements Connection, TopicConnection, QueueConnection, StatsCapable, Closeable, TransportListener, EnhancedConnection {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:642cc43
/////////////////////////////////////////////////////////////////////////
1:     private boolean consumerExpiryCheckEnabled = true;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return true if MessageConsumer instance will check for expired messages before dispatch.
1:      */
1:     public boolean isConsumerExpiryCheckEnabled() {
1:         return consumerExpiryCheckEnabled;
1:     }
1: 
1:     /**
1:      * Controls whether message expiration checking is done in each MessageConsumer
1:      * prior to dispatching a message.  Disabling this check can lead to consumption
1:      * of expired messages.
1:      *
1:      * @param consumerExpiryCheckEnabled
1:      *        controls whether expiration checking is done prior to dispatch.
1:      */
1:     public void setConsumerExpiryCheckEnabled(boolean consumerExpiryCheckEnabled) {
1:         this.consumerExpiryCheckEnabled = consumerExpiryCheckEnabled;
1:     }
commit:d54e0d6
/////////////////////////////////////////////////////////////////////////
1:                         result = new Scheduler("ActiveMQConnection["+info.getConnectionId().getValue()+"] Scheduler");
1:                         result.start();
1:                         scheduler = result;
commit:9010494
/////////////////////////////////////////////////////////////////////////
0:     private final CopyOnWriteArrayList<TransportListener> transportListeners = new CopyOnWriteArrayList<TransportListener>();
0:     // Stream are deprecated and will be removed in a later release.
/////////////////////////////////////////////////////////////////////////
0:                     // Stream are deprecated and will be removed in a later release.
/////////////////////////////////////////////////////////////////////////
1: 
0:         // Stream are deprecated and will be removed in a later release.
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
0:     @Deprecated
author:gtully
-------------------------------------------------------------------------------
commit:2bd3379
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUserSpecifiedClientID() {
1:         return userSpecifiedClientID;
1:     }
1: 
commit:63b2e5c
/////////////////////////////////////////////////////////////////////////
1:         if (!closed.get() && !closing.get()) {
commit:a65f5e7
/////////////////////////////////////////////////////////////////////////
1:                                 syncSendPacket(removeCommand, closeTimeout);
/////////////////////////////////////////////////////////////////////////
1:     public Response syncSendPacket(Command command, int timeout) throws JMSException {
1:                 Response response = (Response)(timeout > 0
1:                         ? this.transport.request(command, timeout)
1:                         : this.transport.request(command));
/////////////////////////////////////////////////////////////////////////
1:     public Response syncSendPacket(Command command) throws JMSException {
1:         return syncSendPacket(command, 0);
commit:77d46dc
/////////////////////////////////////////////////////////////////////////
0:     protected Response doSyncSendPacket(Command command, int timeout)
commit:0a12bcb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1:                     long lastDeliveredSequenceId = -1;
/////////////////////////////////////////////////////////////////////////
0:                             doSyncSendPacket(removeCommand, closeTimeout);
commit:b29eb38
/////////////////////////////////////////////////////////////////////////
1:         doCleanup(false);
1:     }
1:     public void doCleanup(boolean removeConnection) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:         if (removeConnection) {
1:             if (isConnectionInfoSentToBroker) {
1:                 if (!transportFailed.get() && !closing.get()) {
1:                     syncSendPacket(info.createRemoveCommand());
1:                 }
1:                 isConnectionInfoSentToBroker = false;
1:             }
1:             if (userSpecifiedClientID) {
1:                 info.setClientId(null);
1:                 userSpecifiedClientID = false;
1:             }
1:             clientIDSet = false;
1:         started.set(false);
/////////////////////////////////////////////////////////////////////////
1:                         doCleanup(true);
commit:de549f8
/////////////////////////////////////////////////////////////////////////
1:             if (isClosing() || isClosed()) {
1:                 // without lock contention report the closing state
1:                 throw new ConnectionClosedException();
1:             }
commit:bbb2acc
/////////////////////////////////////////////////////////////////////////
1:     private boolean messagePrioritySupported = false;
commit:a58b008
/////////////////////////////////////////////////////////////////////////
0:                                     forceCloseOnSecurityException(exception);
/////////////////////////////////////////////////////////////////////////
1:     private void forceCloseOnSecurityException(Throwable exception) {
1:         LOG.trace("force close on security exception:" + this + ", transport=" + transport, exception);
1:         onException(new IOException("Force close due to SecurityException on connect", exception));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                             forceCloseOnSecurityException(er.getException());
commit:c34851f
/////////////////////////////////////////////////////////////////////////
0:         return createInputStream(dest, messageSelector, noLocal, -1);
/////////////////////////////////////////////////////////////////////////
1:     protected CopyOnWriteArrayList<ActiveMQSession> getSessions() {
1:         return sessions;
1:     }
1: 
commit:ad1f751
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.RequestTimedOutIOException;
/////////////////////////////////////////////////////////////////////////
1:                         try {
0:                             doSyncSendPacket(info.createRemoveCommand(), closeTimeout);
1:                         } catch (JMSException e) {
1:                             if (e.getCause() instanceof RequestTimedOutIOException) {
1:                                 // expected
1:                             } else {
1:                                 throw e;
1:                             }
1:                         }
commit:e8818fa
/////////////////////////////////////////////////////////////////////////
1:     public boolean hasDispatcher(ConsumerId consumerId) {
1:         return dispatchers.containsKey(consumerId);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         } else {
1:                             LOG.debug("{} no dispatcher for {} in {}", this, md, dispatchers);
commit:221a751
/////////////////////////////////////////////////////////////////////////
1:     private boolean rmIdFromConnectionId = false;
/////////////////////////////////////////////////////////////////////////
1:         if (isRmIdFromConnectionId()) {
1:             return info.getConnectionId().getValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isRmIdFromConnectionId() {
1:         return rmIdFromConnectionId;
1:     }
1: 
1:     public void setRmIdFromConnectionId(boolean rmIdFromConnectionId) {
1:         this.rmIdFromConnectionId = rmIdFromConnectionId;
1:     }
1: 
commit:dc0291b
/////////////////////////////////////////////////////////////////////////
1:     protected AtomicInteger transportInterruptionProcessingComplete = new AtomicInteger(0);
/////////////////////////////////////////////////////////////////////////
1:         transportInterruptionProcessingComplete.set(1);
1:             s.clearMessagesInProgress(transportInterruptionProcessingComplete);
1:             connectionConsumer.clearMessagesInProgress(transportInterruptionProcessingComplete);
1:         }
1: 
1:         if (transportInterruptionProcessingComplete.decrementAndGet() > 0) {
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("transport interrupted - processing required, dispatchers: " + transportInterruptionProcessingComplete.get());
1:             }
1:             signalInterruptionProcessingNeeded();
/////////////////////////////////////////////////////////////////////////
1:         if (!closed.get() && !transportFailed.get() && transportInterruptionProcessingComplete.get()>0) {
1:             LOG.warn("dispatch with outstanding dispatch interruption processing count " + transportInterruptionProcessingComplete.get());
1:         if (transportInterruptionProcessingComplete.decrementAndGet() == 0) {
1:             signalInterruptionProcessingComplete();
1:     private void signalInterruptionProcessingComplete() {
1:                 LOG.debug("transportInterruptionProcessingComplete: " + transportInterruptionProcessingComplete.get()
1:                         + " for:" + this.getConnectionInfo().getConnectionId());
/////////////////////////////////////////////////////////////////////////
1:             transportInterruptionProcessingComplete.set(0);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:338a74d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:94446e5
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:     private List<String> trustedPackages = new ArrayList<String>();
1:     private boolean trustAllPackages = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public List<String> getTrustedPackages() {
1:         return trustedPackages;
1:     }
1: 
1:     public void setTrustedPackages(List<String> trustedPackages) {
1:         this.trustedPackages = trustedPackages;
1:     }
1: 
1:     public boolean isTrustAllPackages() {
1:         return trustAllPackages;
1:     }
1: 
1:     public void setTrustAllPackages(boolean trustAllPackages) {
1:         this.trustAllPackages = trustAllPackages;
1:     }
commit:c705523
/////////////////////////////////////////////////////////////////////////
0:         stop();
commit:ec35588
/////////////////////////////////////////////////////////////////////////
author:Romain Manni-Bucau
-------------------------------------------------------------------------------
commit:934f3ce
/////////////////////////////////////////////////////////////////////////
1:                     try {
1:                         if (isConnectionInfoSentToBroker) {
1:                             // If we announced ourselves to the broker.. Try to let the broker
1:                             // know that the connection is being shutdown.
1:                             RemoveInfo removeCommand = info.createRemoveCommand();
1:                             removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:                             try {
0:                                 doSyncSendPacket(removeCommand, closeTimeout);
1:                             } catch (JMSException e) {
0:                                 if (e.getCause() instanceof RequestTimedOutIOException) {
0:                                     // expected
1:                                 } else {
0:                                     throw e;
1:                                 }
1:                             doAsyncSendPacket(new ShutdownInfo());
1:                     } finally { // release anyway even if previous communication fails
1:                         started.set(false);
1:                         // TODO if we move the TaskRunnerFactory to the connection
1:                         // factory
1:                         // then we may need to call
1:                         // factory.onConnectionClose(this);
1:                         if (sessionTaskRunner != null) {
1:                             sessionTaskRunner.shutdown();
1:                         }
1:                         closed.set(true);
1:                         closing.set(false);
author:Christian Posta
-------------------------------------------------------------------------------
commit:b21dc69
/////////////////////////////////////////////////////////////////////////
1:      * @return the sendTimeout (in milliseconds)
1:      * @param sendTimeout the sendTimeout to set (in milliseconds)
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:887ac0b
/////////////////////////////////////////////////////////////////////////
1:         doStop(true);
1:     }
1: 
1:     /**
1:      * @see #stop()
1:      * @param checkClosed <tt>true</tt> to check for already closed and throw {@link java.lang.IllegalStateException} if already closed,
1:      *                    <tt>false</tt> to skip this check
1:      * @throws JMSException if the JMS provider fails to stop message delivery due to some internal error.
1:      */
1:     void doStop(boolean checkClosed) throws JMSException {
1:         if (checkClosed) {
1:             checkClosedOrFailed();
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 // do not fail if already closed as according to JMS spec we must not
1:                 // throw exception if already closed
1:                 doStop(false);
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:                     ThreadPoolUtils.shutdown(executor);
1:                 LOG.warn("Error shutting down thread pool: " + executor + ". This exception will be ignored.", e);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:849baa6
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                                 msg.setMemoryUsage(null);
/////////////////////////////////////////////////////////////////////////
1:                             @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:de7617e
/////////////////////////////////////////////////////////////////////////
1:      * If this flag is not set then a separate thread is not used for dispatching messages for each Session in
1:      * the Connection. However, a separate thread is always used if there is more than one session, or the session
1:      * isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch
1:      * happens asynchronously.
commit:3d5a758
/////////////////////////////////////////////////////////////////////////
1:     private long optimizedAckScheduledAckInterval = 0;
/////////////////////////////////////////////////////////////////////////
1:     public ClientInternalExceptionListener getClientInternalExceptionListener() {
/////////////////////////////////////////////////////////////////////////
1:     public void setClientInternalExceptionListener(ClientInternalExceptionListener listener) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                     for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:         for (ActiveMQSession session : this.sessions) {
1:             if (session.isInUse(destination)) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:             // TODO Should we handle the "close" case?
0:             // if (false && "close".equals(text)){
0:             //     LOG.error("Broker " + getBrokerInfo() + "shutdown connection");
0:             //     try {
0:             //         close();
0:             //     } catch (JMSException e) {
0:             //     }
0:             // }
/////////////////////////////////////////////////////////////////////////
1:             for (ActiveMQSession session : this.sessions) {
1:                 session.close(command.getConsumerId());
1:             for (ActiveMQSession session : this.sessions) {
1:                 session.setPrefetchSize(command.getConsumerId(), command.getPrefetch());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled
1:      * to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers
1:      * will not do any background Message acknowledgment.
1:      *
1:      * @return the scheduledOptimizedAckInterval
1:      */
1:     public long getOptimizedAckScheduledAckInterval() {
1:         return optimizedAckScheduledAckInterval;
1:     }
1: 
1:     /**
1:      * Sets the amount of time between scheduled sends of any outstanding Message Acks for consumers that
1:      * have been configured with optimizeAcknowledge enabled.
1:      *
0:      * @param scheduledOptimizedAckInterval the scheduledOptimizedAckInterval to set
1:      */
1:     public void setOptimizedAckScheduledAckInterval(long optimizedAckScheduledAckInterval) {
1:         this.optimizedAckScheduledAckInterval = optimizedAckScheduledAckInterval;
1:     }
commit:6da702b
/////////////////////////////////////////////////////////////////////////
1:     private boolean queueOnlyConnection = false;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (queueOnlyConnection) {
1:             throw new IllegalStateException("QueueConnection cannot be used to create Pub/Sub based resources.");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Enable enforcement of QueueConnection semantics.
1:      *
1:      * @return this object, useful for chaining
1:      */
1:     ActiveMQConnection enforceQueueOnlyConnection() {
1:         this.queueOnlyConnection = true;
1:         return this;
1:     }
commit:a3836b5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.RedeliveryPolicyMap;
/////////////////////////////////////////////////////////////////////////
1:     private RedeliveryPolicyMap redeliveryPolicyMap;
/////////////////////////////////////////////////////////////////////////
1:         return redeliveryPolicyMap.getDefaultEntry();
1:         this.redeliveryPolicyMap.setDefaultEntry(redeliveryPolicy);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Sets the Connection wide RedeliveryPolicyMap for handling messages that are being rolled back.
1:      * @param redeliveryPolicyMap the redeliveryPolicyMap to set
1:      */
1:     public void setRedeliveryPolicyMap(RedeliveryPolicyMap redeliveryPolicyMap) {
1:         this.redeliveryPolicyMap = redeliveryPolicyMap;
1:     }
1: 
1:     /**
1:      * Gets the Connection's configured RedeliveryPolicyMap which will be used by all the
1:      * Consumers when dealing with transaction messages that have been rolled back.
1:      *
1:      * @return the redeliveryPolicyMap
1:      */
1:     public RedeliveryPolicyMap getRedeliveryPolicyMap() {
1:         return redeliveryPolicyMap;
1:     }
commit:59b38fc
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:                     cleanUpTempDestinations();
0:                         // If we announced ourselves to the broker.. Try to let the broker
commit:97ae323
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     private Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:                     Scheduler scheduler = this.scheduler;
1:                     if (scheduler != null) {
1:                             scheduler.stop();
/////////////////////////////////////////////////////////////////////////
1:     protected Scheduler getScheduler() throws JMSException {
1:         Scheduler result = scheduler;
1:         if (result == null) {
1:             synchronized (this) {
1:                 result = scheduler;
1:                 if (result == null) {
1:                     checkClosed();
1:                     try {
0:                         result = scheduler = new Scheduler("ActiveMQConnection["+info.getConnectionId().getValue()+"] Scheduler");
0:                         scheduler.start();
1:                     } catch(Exception e) {
1:                         throw JMSExceptionSupport.create(e);
1:                     }
1:                 }
1:             }
1:         }
1:         return result;
commit:0b6bf7e
/////////////////////////////////////////////////////////////////////////
0:     private boolean messagePrioritySupported = true;
1:     private boolean nonBlockingRedelivery = false;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isNonBlockingRedelivery() {
1:         return nonBlockingRedelivery;
1:     }
1: 
1:     public void setNonBlockingRedelivery(boolean nonBlockingRedelivery) {
1:         this.nonBlockingRedelivery = nonBlockingRedelivery;
1:     }
1: 
commit:83fde0b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Store the interrupted state and clear so that cleanup happens without
0:         // leaking connection resources.  Reset in finally to preserve state.
0:         boolean interrupted = Thread.interrupted();
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (executor != null) {
1:             } catch (Throwable e) {
0:                 LOG.error("Error shutting down thread pool " + e, e);
1: 
1:             ServiceSupport.dispose(this.transport);
1: 
0:             if (interrupted) {
1:                 Thread.currentThread().interrupt();
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 // for the advisory consumer may also have a reference to this temp destination.
1:                 ActiveMQTempDestination dest = entry.getValue();
commit:d226f50
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:     private void doAsyncSendPacket(Command command) throws JMSException {
1:         try {
1:             this.transport.oneway(command);
1:         } catch (IOException e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
0:     private Response doSyncSendPacket(Command command, int timeout)
1:             throws JMSException {
1:         try {
0:             Response response = (Response) (timeout > 0
0:                     ? this.transport.request(command, timeout)
0:             if (response != null && response.isException()) {
1:                 ExceptionResponse er = (ExceptionResponse)response;
1:                 if (er.getException() instanceof JMSException) {
1:                     throw (JMSException)er.getException();
1:                 } else {
0:                     throw JMSExceptionSupport.create(er.getException());
1:                 }
1:             }
1:             return response;
1:         } catch (IOException e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Async client internal exception occurred with no exception listener registered: "
1:      *
/////////////////////////////////////////////////////////////////////////
1:         onAsyncException(error);
0:         if (!closing.get() && !closed.get()) {
1:             executor.execute(new Runnable() {
1:                 public void run() {
1:                     transportFailed(error);
1:                     ServiceSupport.dispose(ActiveMQConnection.this.transport);
1:                     brokerInfoReceived.countDown();
1:                     try {
0:                         cleanup();
0:                     } catch (JMSException e) {
1:                         LOG.warn("Exception during connection cleanup, " + e, e);
1:                     }
0:                     for (Iterator<TransportListener> iter = transportListeners
0:                             .iterator(); iter.hasNext();) {
1:                         TransportListener listener = iter.next();
1:                         listener.onException(error);
1:                     }
1:                 }
1:             });
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
0:             connectionConsumer.clearMessagesInProgress();
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:     }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public IOException getFirstFailureError() {
1:         return firstFailureError;
1:     }
1: 
1:     protected void waitForTransportInterruptionProcessingToComplete() throws InterruptedException {
0:         CountDownLatch cdl = this.transportInterruptionProcessingComplete;
0:         if (cdl != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void transportInterruptionProcessingComplete() {
0:         CountDownLatch cdl = this.transportInterruptionProcessingComplete;
0:         if (cdl != null) {
0:             cdl.countDown();
1:             try {
1:                 signalInterruptionProcessingComplete();
0:             } catch (InterruptedException ignored) {}
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Removes any TempDestinations that this connection has cached, ignoring
1:      * any exceptions generated because the destination is in use as they should
1:      * not be removed.
1:      */
1:     public void cleanUpTempDestinations() {
1: 
1:         if (this.activeTempDestinations == null || this.activeTempDestinations.isEmpty()) {
1:             return;
1:         }
1: 
0:         Iterator<ConcurrentHashMap.Entry<ActiveMQTempDestination, ActiveMQTempDestination>> entries
1:             = this.activeTempDestinations.entrySet().iterator();
1:         while(entries.hasNext()) {
0:             ConcurrentHashMap.Entry<ActiveMQTempDestination, ActiveMQTempDestination> entry = entries.next();
1:             try {
1:                 this.deleteTempDestination(entry.getValue());
1:             } catch (Exception ex) {
1:                 // the temp dest is in use so it can not be deleted.
1:                 // it is ok to leave it to connection tear down phase
1:             }
1:         }
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:757a2f1
/////////////////////////////////////////////////////////////////////////
1:             for (ActiveMQConnectionConsumer connectionConsumer: connectionConsumers) {
1:                 ConsumerInfo consumerInfo = connectionConsumer.getConsumerInfo();
1:                 if (consumerInfo.getConsumerId().equals(command.getConsumerId())) {
1:                     consumerInfo.setPrefetchSize(command.getPrefetch());
1:                 }
1:             }
commit:27440ae
/////////////////////////////////////////////////////////////////////////
1:                     this.activeTempDestinations.clear();
/////////////////////////////////////////////////////////////////////////
1:      * Used from a pooled connection, b/c it will not be explicitly closed.
/////////////////////////////////////////////////////////////////////////
1:      * @param optimizedAckScheduledAckInterval the scheduledOptimizedAckInterval to set
commit:c9b49d8
/////////////////////////////////////////////////////////////////////////
1:     public void syncSendPacket(final Command command, final AsyncCallback onComplete) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:                                 // dispose of transport for security exceptions on connection initiation
1:                                 if (exception instanceof SecurityException && command instanceof ConnectionInfo){
/////////////////////////////////////////////////////////////////////////
1:                         if (er.getException() instanceof SecurityException && command instanceof ConnectionInfo){
commit:09ff99f
/////////////////////////////////////////////////////////////////////////
1:      *                asynchronously. The default value is true.
commit:9df9d3e
/////////////////////////////////////////////////////////////////////////
1:                             jmsEx = JMSExceptionSupport.create(er.getException());
1:                         } catch(Throwable e) {
/////////////////////////////////////////////////////////////////////////
1:                         }
0:                         if (jmsEx !=null) {
1:                             throw jmsEx;
commit:44488a5
/////////////////////////////////////////////////////////////////////////
1:     public void setOptimizeAcknowledgeTimeOut(long optimizeAcknowledgeTimeOut) {
commit:2030097
/////////////////////////////////////////////////////////////////////////
1:     private boolean transactedIndividualAck = false;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isTransactedIndividualAck() {
1:         return transactedIndividualAck;
1:     }
1: 
1:     public void setTransactedIndividualAck(boolean transactedIndividualAck) {
1:         this.transactedIndividualAck = transactedIndividualAck;
1:     }
1: 
commit:975fc55
/////////////////////////////////////////////////////////////////////////
1:     private long optimizeAcknowledgeTimeOut = 0;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The max time in milliseconds between optimized ack batches
1:      * @param optimizeAcknowledgeTimeOut
1:      */
0:     public void setOptimizeAcknowledgeTimeOut(int optimizeAcknowledgeTimeOut) {
1:         this.optimizeAcknowledgeTimeOut =  optimizeAcknowledgeTimeOut;
1:     }
1: 
1:     public long getOptimizeAcknowledgeTimeOut() {
1:         return optimizeAcknowledgeTimeOut;
1:     }
1: 
commit:b9045db
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQConnection(final Transport transport, IdGenerator clientIdGenerator, IdGenerator connectionIdGenerator, JMSStatsImpl factoryStats) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         String uniqueId = connectionIdGenerator.generateId();
commit:b6a9c70
/////////////////////////////////////////////////////////////////////////
0: 		    Response response = (Response) (timeout > 0
0:                     ? this.transport.request(command, timeout) 
0:                     : this.transport.request(command));
commit:4c4f0d1
/////////////////////////////////////////////////////////////////////////
0:         signalInterruptionProcessingNeeded();
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void signalInterruptionProcessingNeeded() {
1:         FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);
1:         if (failoverTransport != null) {
1:             failoverTransport.getStateTracker().transportInterrupted(this.getConnectionInfo().getConnectionId());
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("notified failover transport (" + failoverTransport
1:                         + ") of pending interruption processing for: " + this.getConnectionInfo().getConnectionId());
1:             }
1:         }
1:     }
1: 
commit:ad06a5f
/////////////////////////////////////////////////////////////////////////
0:         this.transportInterruptionProcessingComplete = new CountDownLatch(dispatchers.size() - (advisoryConsumer != null ? 1:0));
/////////////////////////////////////////////////////////////////////////
1:         
1:         for (ActiveMQConnectionConsumer connectionConsumer : this.connectionConsumers) {
0:             connectionConsumer.clearMessagesInProgress();    
1:         }
1:         
commit:e771b88
/////////////////////////////////////////////////////////////////////////
0:         this.transportInterruptionProcessingComplete = new CountDownLatch(dispatchers.size() - (advisoryConsumer != null ? 1:0) - connectionConsumers.size());
commit:b836af8
/////////////////////////////////////////////////////////////////////////
1:     private long consumerFailoverRedeliveryWaitPeriod;
/////////////////////////////////////////////////////////////////////////
0:             while (!closed.get() && !transportFailed.get() && !transportInterruptionProcessingComplete.await(10, TimeUnit.SECONDS)) {
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("transportInterruptionProcessingComplete for: " + this.getConnectionInfo().getConnectionId());
1:             }
0:                         LOG.debug("notified failover transport (" + failoverTransport +") of interruption completion for: " + this.getConnectionInfo().getConnectionId());
1: 
1:     /*
1:      * specify the amount of time in milliseconds that a consumer with a transaction pending recovery
1:      * will wait to receive re dispatched messages.
1:      * default value is 0 so there is no wait by default.
1:      */
1:     public void setConsumerFailoverRedeliveryWaitPeriod(long consumerFailoverRedeliveryWaitPeriod) {
1:         this.consumerFailoverRedeliveryWaitPeriod = consumerFailoverRedeliveryWaitPeriod;
1:     }
1:     
1:     public long getConsumerFailoverRedeliveryWaitPeriod() {
1:         return consumerFailoverRedeliveryWaitPeriod;
1:     }
commit:8d3ca90
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.failover.FailoverTransport;
/////////////////////////////////////////////////////////////////////////
1:                         waitForTransportInterruptionProcessingToComplete();
/////////////////////////////////////////////////////////////////////////
0: 	protected void waitForTransportInterruptionProcessingToComplete() throws InterruptedException {
0:             signalInterruptionProcessingComplete();
1: 	        try {
0: 	            signalInterruptionProcessingComplete();
0: 	        } catch (InterruptedException ignored) {}
1: 
0:     private void signalInterruptionProcessingComplete() throws InterruptedException {
0:         if (transportInterruptionProcessingComplete.await(0, TimeUnit.SECONDS)) {
1:             synchronized (this) {
0:                 transportInterruptionProcessingComplete = null;
1:                 FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);
1:                 if (failoverTransport != null) {
1:                     failoverTransport.connectionInterruptProcessingComplete(this.getConnectionInfo().getConnectionId());
1:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("transportInterruptionProcessingComplete for: " + this.getConnectionInfo().getConnectionId());
1:                     }
1:                 } 
1:             }
1:         }
1:     }
commit:862cd71
/////////////////////////////////////////////////////////////////////////
0:     protected CountDownLatch transportInterruptionProcessingComplete;
/////////////////////////////////////////////////////////////////////////
0:                         waitForTransportInterruptionProcessing();
/////////////////////////////////////////////////////////////////////////
0:         transportInterruptionProcessingComplete = new CountDownLatch(dispatchers.size() - (advisoryConsumer != null ? 1:0));
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("transport interrupted, dispatchers: " + transportInterruptionProcessingComplete.getCount());
1:         }
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	protected void waitForTransportInterruptionProcessing() throws InterruptedException {
0:         if (transportInterruptionProcessingComplete != null) {
0:             while (!closed.get() && !transportFailed.get() && !transportInterruptionProcessingComplete.await(15, TimeUnit.SECONDS)) {
0:                 LOG.warn("dispatch paused, waiting for outstanding dispatch interruption processing (" + transportInterruptionProcessingComplete.getCount() + ") to complete..");
1:             }
1:             synchronized (this) {
0:                 transportInterruptionProcessingComplete = null;
1:             }
1:         }
1:     }
1: 	
0: 	protected synchronized void transportInterruptionProcessingComplete() {
0: 	    if (transportInterruptionProcessingComplete != null) {
0: 	        transportInterruptionProcessingComplete.countDown();
1: 	    }
1: 	}
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1:     private TaskRunnerFactory sessionTaskRunner;
/////////////////////////////////////////////////////////////////////////
1:     private boolean useDedicatedTaskRunner;
/////////////////////////////////////////////////////////////////////////
0:                     if (sessionTaskRunner != null) {
0:                         sessionTaskRunner.shutdown();
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUseDedicatedTaskRunner() {
1:         return useDedicatedTaskRunner;
1:     }
1:     
1:     public void setUseDedicatedTaskRunner(boolean useDedicatedTaskRunner) {
1:         this.useDedicatedTaskRunner = useDedicatedTaskRunner;
1:     }
1: 
0:         synchronized (this) {
1:             if (sessionTaskRunner == null) {
0:                 sessionTaskRunner = new TaskRunnerFactory("ActiveMQ Session Task", ThreadPriorities.INBOUND_CLIENT_SESSION, false, 1000, isUseDedicatedTaskRunner());
1:             }
1:         }
commit:d88004f
/////////////////////////////////////////////////////////////////////////
0:                 syncSendPacket(info.createRemoveCommand());
commit:9f548bb
/////////////////////////////////////////////////////////////////////////
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
0:             // deliverAcks at this point is too early as acks can arrive at the broker
0:             // before redispatch of messages and hence be out or order
0:             s.transportResumed();
commit:3b08860
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.RemoveInfo;
/////////////////////////////////////////////////////////////////////////
0:                     long lastDeliveredSequenceId = 0;
1:                         lastDeliveredSequenceId = Math.max(lastDeliveredSequenceId, s.getLastDeliveredSequenceId());
/////////////////////////////////////////////////////////////////////////
0:                         RemoveInfo removeCommand = info.createRemoveCommand();
0:                         removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
commit:6d1f57b
/////////////////////////////////////////////////////////////////////////
1:      * by a container runtime component during asynchronous processing of a
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:d4cd7f9
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.*;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.FutureResponse;
1: import org.apache.activemq.transport.ResponseCallback;
/////////////////////////////////////////////////////////////////////////
0:     public void syncSendPacket(Command command, final AsyncCallback onComplete) throws JMSException {
1:         if(onComplete==null) {
1:             syncSendPacket(command);
1:         } else {
1:             if (isClosed()) {
1:                 throw new ConnectionClosedException();
1:             }
1:             try {
1:                 this.transport.asyncRequest(command, new ResponseCallback() {
0:                     @Override
1:                     public void onCompletion(FutureResponse resp) {
1:                         Response response;
1:                         Throwable exception = null;
1:                         try {
1:                             response = resp.getResult();
1:                             if (response.isException()) {
1:                                 ExceptionResponse er = (ExceptionResponse)response;
1:                                 exception = er.getException();
1:                             }
1:                         } catch (Exception e) {
1:                             exception = e;
1:                         }
0:                         if(exception!=null) {
1:                             if ( exception instanceof JMSException) {
1:                                 onComplete.onException((JMSException) exception);
1:                             } else {
0:                                 if (isClosed()||closing.get()) {
1:                                     LOG.debug("Received an exception but connection is closing");
1:                                 }
1:                                 JMSException jmsEx = null;
1:                                 try {
1:                                     jmsEx = JMSExceptionSupport.create(exception);
1:                                 } catch(Throwable e) {
1:                                     LOG.error("Caught an exception trying to create a JMSException for " +exception,e);
1:                                 }
0:                                 //dispose of transport for security exceptions
0:                                 if (exception instanceof SecurityException){
0:                                     Transport t = transport;
0:                                     if (null != t){
0:                                         ServiceSupport.dispose(t);
1:                                     }
1:                                 }
0:                                 if (jmsEx !=null) {
1:                                     onComplete.onException(jmsEx);
1:                                 }
1:                             }
1:                         } else {
1:                             onComplete.onSuccess();
1:                         }
1:                     }
1:                 });
1:             } catch (IOException e) {
1:                 throw JMSExceptionSupport.create(e);
1:             }
1:         }
1:     }
1: 
commit:ce7495e
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Async exception with no exception listener: " + error, error);
commit:836ca81
/////////////////////////////////////////////////////////////////////////
commit:3eb6aed
/////////////////////////////////////////////////////////////////////////
commit:2984963
/////////////////////////////////////////////////////////////////////////
0:                         doSyncSendPacket(info.createRemoveCommand(), closeTimeout);
0:                         doAsyncSendPacket(new ShutdownInfo());
/////////////////////////////////////////////////////////////////////////
0:         if (isClosed() || closing.get()) {
1:             doAsyncSendPacket(command);
0: 	private void doAsyncSendPacket(Command command) throws JMSException {
1: 		try {
0: 		    this.transport.oneway(command);
0: 		} catch (IOException e) {
1: 		    throw JMSExceptionSupport.create(e);
1: 		}
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (isClosed() || closing.get()) {
0:             return doSyncSendPacket(command, timeout);
0: 	private Response doSyncSendPacket(Command command, int timeout)
1: 			throws JMSException {
1: 		try {
0: 		    Response response = (Response)this.transport.request(command, timeout);
0: 		    if (response != null && response.isException()) {
0: 		        ExceptionResponse er = (ExceptionResponse)response;
0: 		        if (er.getException() instanceof JMSException) {
0: 		            throw (JMSException)er.getException();
1: 		        } else {
0: 		            throw JMSExceptionSupport.create(er.getException());
1: 		        }
1: 		    }
0: 		    return response;
0: 		} catch (IOException e) {
0: 		    throw JMSExceptionSupport.create(e);
1: 		}
1: 	}
1: 
commit:82d1c91
/////////////////////////////////////////////////////////////////////////
0:     private TaskRunnerFactory sessionTaskRunner = new TaskRunnerFactory("ActiveMQ Session Task", ThreadPriorities.INBOUND_CLIENT_SESSION, false, 1000);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     public final ConcurrentHashMap<ActiveMQTempDestination, ActiveMQTempDestination> activeTempDestinations = new ConcurrentHashMap<ActiveMQTempDestination, ActiveMQTempDestination>();
/////////////////////////////////////////////////////////////////////////
0:     private final CopyOnWriteArrayList<ActiveMQSession> sessions = new CopyOnWriteArrayList<ActiveMQSession>();
0:     private final CopyOnWriteArrayList<ActiveMQConnectionConsumer> connectionConsumers = new CopyOnWriteArrayList<ActiveMQConnectionConsumer>();
0:     private final CopyOnWriteArrayList<ActiveMQInputStream> inputStreams = new CopyOnWriteArrayList<ActiveMQInputStream>();
0:     private final CopyOnWriteArrayList<ActiveMQOutputStream> outputStreams = new CopyOnWriteArrayList<ActiveMQOutputStream>();
0:     private final CopyOnWriteArrayList<TransportListener> transportListeners = new CopyOnWriteArrayList<TransportListener>();
0:     private final ConcurrentHashMap<ConsumerId, ActiveMQDispatcher> dispatchers = new ConcurrentHashMap<ConsumerId, ActiveMQDispatcher>();
/////////////////////////////////////////////////////////////////////////
0:         asyncConnectionThread = new ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<ActiveMQSession> i = sessions.iterator(); i.hasNext();) {
1:                 ActiveMQSession session = i.next();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<ActiveMQSession> i = sessions.iterator(); i.hasNext();) {
1:                 ActiveMQSession s = i.next();
/////////////////////////////////////////////////////////////////////////
1:                     for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:                         ActiveMQSession s = i.next();
1:                     for (Iterator<ActiveMQConnectionConsumer> i = this.connectionConsumers.iterator(); i.hasNext();) {
1:                         ActiveMQConnectionConsumer c = i.next();
0:                     for (Iterator<ActiveMQInputStream> i = this.inputStreams.iterator(); i.hasNext();) {
0:                         ActiveMQInputStream c = i.next();
0:                     for (Iterator<ActiveMQOutputStream> i = this.outputStreams.iterator(); i.hasNext();) {
0:                         ActiveMQOutputStream c = i.next();
/////////////////////////////////////////////////////////////////////////
0:             Map<String, String> options = new HashMap<String, String>(info.getDestination().getOptions());
/////////////////////////////////////////////////////////////////////////
0:             Map<String, String> options = new HashMap<String, String>(info.getDestination().getOptions());
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:             ActiveMQSession s = i.next();
1:         for (Iterator<ActiveMQConnectionConsumer> i = this.connectionConsumers.iterator(); i.hasNext();) {
1:             ActiveMQConnectionConsumer c = i.next();
0:         for (Iterator<ActiveMQInputStream> i = this.inputStreams.iterator(); i.hasNext();) {
0:             ActiveMQInputStream c = i.next();
0:         for (Iterator<ActiveMQOutputStream> i = this.outputStreams.iterator(); i.hasNext();) {
0:             ActiveMQOutputStream c = i.next();
/////////////////////////////////////////////////////////////////////////
1:                         ActiveMQDispatcher dispatcher = dispatchers.get(md.getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
1:             TransportListener listener = iter.next();
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
1:                     TransportListener listener = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:             ActiveMQSession s = i.next();
1:         for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
1:             TransportListener listener = iter.next();
1:         for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {
1:             TransportListener listener = iter.next();
1:         for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
1:             ActiveMQSession s = i.next();
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
0:             ActiveMQSession s = i.next();
/////////////////////////////////////////////////////////////////////////
0:     public OutputStream createOutputStream(Destination dest, Map<String, Object> streamProperties, int deliveryMode, int priority, long timeToLive) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:         rsi.setSubscriptionName(name);
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession s = i.next();
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession s = i.next();
0:             for (Iterator<ActiveMQSession> i = this.sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession s = i.next();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(ActiveMQConnection.class);
0:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1: 
0:     public final ConcurrentHashMap activeTempDestinations = new ConcurrentHashMap();
1: 
0:     protected boolean dispatchAsync;
1:     protected boolean alwaysSessionAsync = true;
1: 
0:     private TaskRunnerFactory sessionTaskRunner = new TaskRunnerFactory("ActiveMQ Session Task", ThreadPriorities.INBOUND_CLIENT_SESSION, true, 1000);
0:     private final ThreadPoolExecutor asyncConnectionThread;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.info = new ConnectionInfo(new ConnectionId(CONNECTION_ID_GENERATOR.generateId()));
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return new ActiveMQSession(this, getNextSessionId(), transacted ? Session.SESSION_TRANSACTED : (acknowledgeMode == Session.SESSION_TRANSACTED
0:             ? Session.AUTO_ACKNOWLEDGE : acknowledgeMode), dispatchAsync, alwaysSessionAsync);
/////////////////////////////////////////////////////////////////////////
0:                     if (er.getException() instanceof JMSException) {
1:                     } else {
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                     if (er.getException() instanceof JMSException) {
1:                     } else {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:         if (isConnectionInfoSentToBroker) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (brokerInfo == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (!(error instanceof JMSException)) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (advisoryConsumer == null) {
1:         }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0: public class ActiveMQConnection implements Connection, TopicConnection, QueueConnection, StatsCapable, Closeable, StreamConnection, TransportListener {
0:     private TaskRunnerFactory sessionTaskRunner = new TaskRunnerFactory("ActiveMQ Session Task", ThreadPriorities.INBOUND_CLIENT_SESSION, true, 1000);
0:     private static final Log LOG = LogFactory.getLog(ActiveMQConnection.class);
1: 
1: 
1:     private boolean disableTimeStampsByDefault;
1:     private boolean useCompression;
1:     private boolean objectMessageSerializationDefered;
0:     protected boolean dispatchAsync;
0:     protected boolean alwaysSessionAsync = true;
1:     private boolean useAsyncSend;
1:     private boolean optimizeAcknowledge;
1:     private boolean watchTopicAdvisories = true;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private int producerWindowSize = ActiveMQConnectionFactory.DEFAULT_PRODUCER_WINDOW_SIZE;
1: 
1:     // Assume that protocol is the latest. Change to the actual protocol
0:     private AtomicInteger protocolVersion = new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
1:      * 
1:      * @param transport
0:     protected ActiveMQConnection(final Transport transport, IdGenerator clientIdGenerator, JMSStatsImpl factoryStats) throws Exception {
1: 
1: 
1:         // Configure a single threaded executor who's core thread can timeout if
1:         // idle
0:         asyncConnectionThread = new ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, new LinkedBlockingQueue(), new ThreadFactory() {
0:                 Thread thread = new Thread(r, "AcitveMQ Connection Worker: " + transport);
1:             }
1:         });
1:         // asyncConnectionThread.allowCoreThreadTimeOut(true);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return (ActiveMQConnection)factory.createConnection();
/////////////////////////////////////////////////////////////////////////
1:         return (ActiveMQConnection)factory.createConnection();
/////////////////////////////////////////////////////////////////////////
1:     public static ActiveMQConnection makeConnection(String user, String password, String uri) throws JMSException, URISyntaxException {
1:         return (ActiveMQConnection)factory.createConnection();
/////////////////////////////////////////////////////////////////////////
1:      * @param transacted indicates whether the session is transacted
1:      * @param acknowledgeMode indicates whether the consumer or the client will
1:      *                acknowledge any messages it receives; ignored if the
1:      *                session is transacted. Legal values are
1:      *                <code>Session.AUTO_ACKNOWLEDGE</code>,
1:      *                <code>Session.CLIENT_ACKNOWLEDGE</code>, and
1:      *                <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:      *                 create a session due to some internal error or lack of
1:      *                 support for the specific transaction and acknowledgement
1:      *                 mode.
1:     public Session createSession(boolean transacted, int acknowledgeMode) throws JMSException {
0:         boolean doSessionAsync = alwaysSessionAsync || sessions.size() > 0 || transacted || acknowledgeMode == Session.CLIENT_ACKNOWLEDGE;
0:         return new ActiveMQSession(this, getNextSessionId(), (transacted ? Session.SESSION_TRANSACTED : (acknowledgeMode == Session.SESSION_TRANSACTED
0:             ? Session.AUTO_ACKNOWLEDGE : acknowledgeMode)), dispatchAsync, alwaysSessionAsync);
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to return the client ID
1:      *                 for this connection due to some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * an attempt to change it by setting it must throw an
1:      * <CODE>IllegalStateException</CODE>. If a client sets the client
1:      * identifier explicitly, it must do so immediately after it creates the
1:      * connection and before any other action on the connection is taken. After
1:      * this point, setting the client identifier is a programming error that
1:      * should throw an <CODE>IllegalStateException</CODE>.
/////////////////////////////////////////////////////////////////////////
1:      * @param newClientID the unique client identifier
1:      * @throws JMSException if the JMS provider fails to set the client ID for
1:      *                 this connection due to some internal error.
1:      * @throws javax.jms.InvalidClientIDException if the JMS client specifies an
1:      *                 invalid or duplicate client ID.
1:      * @throws javax.jms.IllegalStateException if the JMS client attempts to set
1:      *                 a connection's client ID at the wrong time or when it has
1:      *                 been administratively configured.
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Sets the default client id that the connection will use if explicitly not
1:      * set with the setClientId() call.
1:      * @throws JMSException if the JMS provider fails to get the connection
1:      *                 metadata for this connection.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to get the
1:      *                 <CODE>ExceptionListener</CODE> for this connection.
/////////////////////////////////////////////////////////////////////////
1:      * </CODE>
1:      * method, passing it a <CODE>JMSException</CODE> object describing the
1:      * problem.
/////////////////////////////////////////////////////////////////////////
1:      * @param listener the exception listener
1:      * @throws JMSException if the JMS provider fails to set the exception
1:      *                 listener for this connection.
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to start message delivery
1:      *                 due to some internal error.
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQSession session = (ActiveMQSession)i.next();
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException if the JMS provider fails to stop message delivery
1:      *                 due to some internal error.
0:                 ActiveMQSession s = (ActiveMQSession)i.next();
/////////////////////////////////////////////////////////////////////////
1:      * a closed connection's session must throw an
1:      * <CODE>IllegalStateException</CODE>. Closing a closed connection must
1:      * NOT throw an exception.
1:      * @throws JMSException if the JMS provider fails to close the connection
1:      *                 due to some internal error. For example, a failure to
1:      *                 release resources or to close a socket connection can
1:      *                 cause this exception to be thrown.
/////////////////////////////////////////////////////////////////////////
1:                     if (advisoryConsumer != null) {
1:                         advisoryConsumer.dispose();
1:                         advisoryConsumer = null;
1:                     }
0:                         ActiveMQSession s = (ActiveMQSession)i.next();
0:                         ActiveMQConnectionConsumer c = (ActiveMQConnectionConsumer)i.next();
0:                         ActiveMQInputStream c = (ActiveMQInputStream)i.next();
0:                         ActiveMQOutputStream c = (ActiveMQOutputStream)i.next();
0:                         // If we announced ourselfs to the broker.. Try to let
0:                         // the broker
/////////////////////////////////////////////////////////////////////////
0:                     // TODO if we move the TaskRunnerFactory to the connection
0:                     // factory
/////////////////////////////////////////////////////////////////////////
1:         } finally {
/////////////////////////////////////////////////////////////////////////
1:     // TODO : org.apache.activemq.message.BrokerAdminCommand not yet
1:     // implemented.
/////////////////////////////////////////////////////////////////////////
1:      * @param topic topic to access
1:      * @param subscriptionName durable subscription name
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param sessionPool the server session pool to associate with this durable
1:      *                connection consumer
1:      * @param maxMessages the maximum number of messages that can be assigned to
1:      *                a server session at one time
1:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:      *                 create a connection consumer due to some internal error
1:      *                 or invalid arguments for <CODE>sessionPool</CODE> and
1:      *                 <CODE>messageSelector</CODE>.
1:      * @throws javax.jms.InvalidDestinationException if an invalid destination
1:      *                 is specified.
1:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:      *                 invalid.
1:     public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName, String messageSelector, ServerSessionPool sessionPool, int maxMessages)
0:         throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:      * @param topic topic to access
1:      * @param subscriptionName durable subscription name
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param sessionPool the server session pool to associate with this durable
1:      *                connection consumer
1:      * @param maxMessages the maximum number of messages that can be assigned to
1:      *                a server session at one time
1:      * @param noLocal set true if you want to filter out messages published
1:      *                locally
1:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:      *                 create a connection consumer due to some internal error
1:      *                 or invalid arguments for <CODE>sessionPool</CODE> and
1:      *                 <CODE>messageSelector</CODE>.
1:      * @throws javax.jms.InvalidDestinationException if an invalid destination
1:      *                 is specified.
1:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:      *                 invalid.
1:     public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName, String messageSelector, ServerSessionPool sessionPool, int maxMessages,
1:                                                               boolean noLocal) throws JMSException {
1:         ConsumerInfo info = new ConsumerInfo(new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId()));
/////////////////////////////////////////////////////////////////////////
1:         if (info.getDestination().getOptions() != null) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public int getCloseTimeout() {
1:     public void setCloseTimeout(int closeTimeout) {
1:         this.closeTimeout = closeTimeout;
/////////////////////////////////////////////////////////////////////////
1:      * Sets whether or not retroactive consumers are enabled. Retroactive
1:      * consumers allow non-durable topic subscribers to receive old messages
1:      * that were published before the non-durable subscriber started.
/////////////////////////////////////////////////////////////////////////
1:      * Enables or disables whether or not queue consumers should be exclusive or
1:      * not for example to preserve ordering when not using <a
1:      * href="http://activemq.apache.org/message-groups.html">Message Groups</a>
1:      * 
/////////////////////////////////////////////////////////////////////////
1:      * Adds a transport listener so that a client can be notified of events in
1:      * the underlying transport
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Sets the transformer used to transform messages before they are sent on
1:      * to the JMS bus or when they are received from the bus but before they are
1:      * delivered to the JMS client
/////////////////////////////////////////////////////////////////////////
1:     public boolean isStatsEnabled() {
1:     public void setStatsEnabled(boolean statsEnabled) {
/////////////////////////////////////////////////////////////////////////
1:      * @throws JMSException
1:         if (sessions.size() > 1 || session.isTransacted()) {
/////////////////////////////////////////////////////////////////////////
1:      * @param transacted indicates whether the session is transacted
1:      * @param acknowledgeMode indicates whether the consumer or the client will
1:      *                acknowledge any messages it receives; ignored if the
1:      *                session is transacted. Legal values are
1:      *                <code>Session.AUTO_ACKNOWLEDGE</code>,
1:      *                <code>Session.CLIENT_ACKNOWLEDGE</code>, and
1:      *                <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:      * @throws JMSException if the <CODE>TopicConnection</CODE> object fails
1:      *                 to create a session due to some internal error or lack of
1:      *                 support for the specific transaction and acknowledgement
1:      *                 mode.
1:         return new ActiveMQTopicSession((ActiveMQSession)createSession(transacted, acknowledgeMode));
1:      * @param topic the topic to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param sessionPool the server session pool to associate with this
1:      *                connection consumer
1:      * @param maxMessages the maximum number of messages that can be assigned to
1:      *                a server session at one time
1:      * @throws JMSException if the <CODE>TopicConnection</CODE> object fails
1:      *                 to create a connection consumer due to some internal
1:      *                 error or invalid arguments for <CODE>sessionPool</CODE>
1:      *                 and <CODE>messageSelector</CODE>.
1:      * @throws javax.jms.InvalidDestinationException if an invalid topic is
1:      *                 specified.
1:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:      *                 invalid.
1: 
1:      * @param queue the queue to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param sessionPool the server session pool to associate with this
1:      *                connection consumer
1:      * @param maxMessages the maximum number of messages that can be assigned to
1:      *                a server session at one time
1:      * @throws JMSException if the <CODE>QueueConnection</CODE> object fails
1:      *                 to create a connection consumer due to some internal
1:      *                 error or invalid arguments for <CODE>sessionPool</CODE>
1:      *                 and <CODE>messageSelector</CODE>.
1:      * @throws javax.jms.InvalidDestinationException if an invalid queue is
1:      *                 specified.
1:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:      *                 invalid.
1:     public ConnectionConsumer createConnectionConsumer(Queue queue, String messageSelector, ServerSessionPool sessionPool, int maxMessages) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:      * @param destination the destination to access
1:      * @param messageSelector only messages with properties matching the message
1:      *                selector expression are delivered. A value of null or an
1:      *                empty string indicates that there is no message selector
1:      *                for the message consumer.
1:      * @param sessionPool the server session pool to associate with this
1:      *                connection consumer
1:      * @param maxMessages the maximum number of messages that can be assigned to
1:      *                a server session at one time
1:      * @throws JMSException if the <CODE>Connection</CODE> object fails to
1:      *                 create a connection consumer due to some internal error
1:      *                 or invalid arguments for <CODE>sessionPool</CODE> and
1:      *                 <CODE>messageSelector</CODE>.
1:      * @throws javax.jms.InvalidDestinationException if an invalid destination
1:      *                 is specified.
1:      * @throws javax.jms.InvalidSelectorException if the message selector is
1:      *                 invalid.
1:     public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector, ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:     public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector, ServerSessionPool sessionPool, int maxMessages, boolean noLocal)
0:         throws JMSException {
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (info.getDestination().getOptions() != null) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param transacted indicates whether the session is transacted
1:      * @param acknowledgeMode indicates whether the consumer or the client will
1:      *                acknowledge any messages it receives; ignored if the
1:      *                session is transacted. Legal values are
1:      *                <code>Session.AUTO_ACKNOWLEDGE</code>,
1:      *                <code>Session.CLIENT_ACKNOWLEDGE</code>, and
1:      *                <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:      * @throws JMSException if the <CODE>QueueConnection</CODE> object fails
1:      *                 to create a session due to some internal error or lack of
1:      *                 support for the specific transaction and acknowledgement
1:      *                 mode.
1:         return new ActiveMQQueueSession((ActiveMQSession)createSession(transacted, acknowledgeMode));
/////////////////////////////////////////////////////////////////////////
1:             throw new JMSException("You cannot create a durable subscriber without specifying a unique clientID on a Connection");
/////////////////////////////////////////////////////////////////////////
0:                 Response response = (Response)this.transport.request(command);
0:                     ExceptionResponse er = (ExceptionResponse)response;
0:                         throw (JMSException)er.getException();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                 Response response = (Response)this.transport.request(command, timeout);
0:                 if (response != null && response.isException()) {
0:                     ExceptionResponse er = (ExceptionResponse)response;
0:                         throw (JMSException)er.getException();
/////////////////////////////////////////////////////////////////////////
1:      * simply throws an exception if the Connection is already closed or the
1:      * Transport has failed
1:         if (transportFailed.get()) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Add a temp destination advisory consumer so that
1:         // We know what the valid temporary destinations are on the
1: 
1:         ConsumerId consumerId = new ConsumerId(new SessionId(info.getConnectionId(), -1), consumerIdGenerator.getNextSequenceId());
1:         if (watchTopicAdvisories) {
1:             advisoryConsumer = new AdvisoryConsumer(this, consumerId);
1:         }
1:     public synchronized boolean isWatchTopicAdvisories() {
1:         return watchTopicAdvisories;
1:     }
1:     public synchronized void setWatchTopicAdvisories(boolean watchTopicAdvisories) {
1:         this.watchTopicAdvisories = watchTopicAdvisories;
1:     }
1:     /**
1: 
1:      * href="http://activemq.apache.org/async-sends.html">Async Sends</a> which
1:      * adds a massive performance boost; but means that the send() method will
1:      * return immediately whether the message has been sent or not which could
1:      * lead to message loss.
1: 
1:     public boolean isAlwaysSyncSend() {
0:      * 
1:     public void setAlwaysSyncSend(boolean alwaysSyncSend) {
1:         this.alwaysSyncSend = alwaysSyncSend;
1: 
0:         if (advisoryConsumer != null) {
1:             advisoryConsumer = null;
1: 
0:             ActiveMQSession s = (ActiveMQSession)i.next();
0:             ActiveMQConnectionConsumer c = (ActiveMQConnectionConsumer)i.next();
0:             ActiveMQInputStream c = (ActiveMQInputStream)i.next();
0:             ActiveMQOutputStream c = (ActiveMQOutputStream)i.next();
0:         if (isConnectionInfoSentToBroker) {
0:             if (!transportFailed.get() && !closing.get()) {
0:             isConnectionInfoSentToBroker = false;
1:         }
0:         if (userSpecifiedClientID) {
0:             userSpecifiedClientID = false;
/////////////////////////////////////////////////////////////////////////
1:      * @throws IllegalStateException if the connection is in used.
/////////////////////////////////////////////////////////////////////////
0:         if (brokerInfo == null)
1:             throw new JMSException("Connection failed before Broker info was received.");
1:      * Returns the broker name if one is available or null if one is not
1:      * available yet.
1:             brokerInfoReceived.await(5, TimeUnit.SECONDS);
1:             if (brokerInfo == null) {
1:                 return null;
1:             }
1:             return brokerInfo.getBrokerName();
1:         } catch (InterruptedException e) {
1:             Thread.currentThread().interrupt();
1:             return null;
1:         }
1: 
1:      * Returns the broker information if it is available or null if it is not
1:      * available yet.
/////////////////////////////////////////////////////////////////////////
1:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large
1:      * OBjects) are transferred from producers to brokers to consumers
/////////////////////////////////////////////////////////////////////////
1:     public boolean isAlwaysSessionAsync() {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isOptimizeAcknowledge() {
1:      * Enables an optimised acknowledgement mode where messages are acknowledged
1:      * in batches rather than individually
1:     public void setOptimizeAcknowledge(boolean optimizeAcknowledge) {
1:         this.optimizeAcknowledge = optimizeAcknowledge;
/////////////////////////////////////////////////////////////////////////
1:      * Enables the timeout from a connection creation to when a warning is
1:      * generated if the connection is not properly started via {@link #start()}
1:      * and a message is received by a consumer. It is a very common gotcha to
1:      * forget to <a
1:      * href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start
1:      * the connection</a> so this option makes the default case to create a
1:      * warning if the user forgets. To disable the warning just set the value to <
1:      * 0 (say -1).
/////////////////////////////////////////////////////////////////////////
1:     public void addProducer(ProducerId producerId, ActiveMQMessageProducer producer) {
1:         producers.put(producerId, producer);
1:     }
1: 
1:     public void removeProducer(ProducerId producerId) {
1:         producers.remove(producerId);
1:     }
1:         dispatchers.put(consumerId, dispatcher);
1: 
1:         dispatchers.remove(consumerId);
1: 
1:         final Command command = (Command)o;
1:             try {
1:                 command.visit(new CommandVisitorAdapter() {
0:                     @Override
1:                     public Response processMessageDispatch(MessageDispatch md) throws Exception {
0:                         ActiveMQDispatcher dispatcher = (ActiveMQDispatcher)dispatchers.get(md.getConsumerId());
1:                         if (dispatcher != null) {
1:                             // Copy in case a embedded broker is dispatching via
1:                             // vm://
1:                             // md.getMessage() == null to signal end of queue
1:                             // browse.
1:                             Message msg = md.getMessage();
1:                             if (msg != null) {
1:                                 msg = msg.copy();
1:                                 msg.setReadOnlyBody(true);
1:                                 msg.setReadOnlyProperties(true);
1:                                 msg.setRedeliveryCounter(md.getRedeliveryCounter());
1:                                 msg.setConnection(ActiveMQConnection.this);
1:                                 md.setMessage(msg);
1:                             }
1:                             dispatcher.dispatch(md);
1:                         }
1:                         return null;
1:                     }
1: 
0:                     @Override
1:                     public Response processProducerAck(ProducerAck pa) throws Exception {
1:                         if (pa != null && pa.getProducerId() != null) {
1:                             ActiveMQMessageProducer producer = producers.get(pa.getProducerId());
1:                             if (producer != null) {
1: 
0:                     @Override
1:                     public Response processBrokerInfo(BrokerInfo info) throws Exception {
1:                         brokerInfo = info;
1:                         brokerInfoReceived.countDown();
1:                         optimizeAcknowledge &= !brokerInfo.isFaultTolerantConfiguration();
1:                         getBlobTransferPolicy().setBrokerUploadUrl(info.getBrokerUploadUrl());
1:                         return null;
1:                     }
1: 
0:                     @Override
1:                     public Response processConnectionError(final ConnectionError error) throws Exception {
0:                         asyncConnectionThread.execute(new Runnable() {
1:                             public void run() {
1:                                 onAsyncException(error.getException());
1:                             }
1:                         });
0:                         new Thread("Async error worker") {
0:                         }.start();
1:                         return null;
1:                     }
1: 
0:                     @Override
1:                     public Response processControlCommand(ControlCommand command) throws Exception {
0:                         onControlCommand(command);
1:                         return null;
1:                     }
1: 
0:                     @Override
1:                     public Response processConnectionControl(ConnectionControl control) throws Exception {
1:                         onConnectionControl((ConnectionControl)command);
1:                         return null;
1:                     }
1: 
0:                     @Override
1:                     public Response processConsumerControl(ConsumerControl control) throws Exception {
1:                         onConsumerControl((ConsumerControl)command);
1:                         return null;
1:                     }
1: 
0:                     @Override
1:                     public Response processWireFormat(WireFormatInfo info) throws Exception {
1:                         onWireFormatInfo((WireFormatInfo)command);
1:                         return null;
1:                     }
1:                 });
1:             } catch (Exception e) {
0:                 onAsyncException(e);
1:             }
1: 
0:             TransportListener listener = (TransportListener)iter.next();
1:         protocolVersion.set(info.getVersion());
1:     }
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:                 final JMSException e = (JMSException)error;
1: 
0:                 asyncConnectionThread.execute(new Runnable() {
1: 
0:                 LOG.warn("Async exception with no exception listener: " + error, error);
1: 
0:         asyncConnectionThread.execute(new Runnable() {
1: 
0:                     TransportListener listener = (TransportListener)iter.next();
1: 
0:             ActiveMQSession s = (ActiveMQSession)i.next();
0:             TransportListener listener = (TransportListener)iter.next();
0:             TransportListener listener = (TransportListener)iter.next();
0:             ActiveMQSession s = (ActiveMQSession)i.next();
1:      * @throws JMSException
1: 
1:         if (topic) {
1: 
1: 
1:         activeTempDestinations.put(dest, dest);
1: 
1:         checkClosedOrFailed();
1: 
0:         for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:             ActiveMQSession s = (ActiveMQSession)i.next();
0:             if (s.isInUse(destination)) {
1:                 throw new JMSException("A consumer is consuming from the temporary destination");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If we are not watching the advisories.. then
1:         // we will assume that the temp destination does exist.
0:         if (advisoryConsumer == null)
1:             return false;
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * synchronously or asynchronously by the broker</a>. For non-durable
1:      * topics for example we typically dispatch synchronously by default to
1:      * minimize context switches which boost performance. However sometimes its
1:      * better to go slower to ensure that a single blocked consumer socket does
1:      * not block delivery to other consumers.
1:      * @param asyncDispatch If true then consumers created on this connection
1:      *                will default to having their messages dispatched
0:      *                asynchronously. The default value is false.
/////////////////////////////////////////////////////////////////////////
1: 
0:      * Creates a persistent output stream; individual messages will be written
0:      * to disk/database by the broker
0:      * Creates a non persistent output stream; messages will not be written to
0:      * disk
/////////////////////////////////////////////////////////////////////////
0:      * @param streamProperties defines a map of key-value pairs where the keys
0:      *                are strings and the values are primitive values (numbers
0:      *                and strings) which are appended to the messages similarly
0:      *                to using the
0:      *                {@link javax.jms.Message#setObjectProperty(String, Object)}
0:      *                method
/////////////////////////////////////////////////////////////////////////
1:      * is an active <CODE>MessageConsumer </CODE> or
1:      * <CODE>TopicSubscriber</CODE> for the subscription, or while a consumed
1:      * message is part of a pending transaction or has not been acknowledged in
1:      * the session.
1:      * @param name the name used to identify this subscription
1:      * @throws JMSException if the session fails to unsubscribe to the durable
1:      *                 subscription due to some internal error.
1:      * @throws InvalidDestinationException if an invalid subscription name is
1:      *                 specified.
/////////////////////////////////////////////////////////////////////////
1:      * Internal send method optimized: - It does not copy the message - It can
1:      * only handle ActiveMQ messages. - You can specify if the send is async or
1:      * sync - Does not allow you to send /w a transaction.
1:         if (destination.isTemporary() && isDeleted(destination)) {
1:             throw new JMSException("Cannot publish to a deleted Destination: " + destination);
1: 
1:         msg.setJMSDeliveryMode(deliveryMode);
/////////////////////////////////////////////////////////////////////////
1: 
1:         msg.setJMSRedelivered(false);
1:         msg.setMessageId(messageId);
1: 
1: 
0:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("Sending message: " + msg);
1:         if (async) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("JVM told to shutdown");
1: 
1:     protected void onConnectionControl(ConnectionControl command) {
1:         if (command.isFaultTolerant()) {
0:             for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession s = (ActiveMQSession)i.next();
1: 
1:     protected void onConsumerControl(ConsumerControl command) {
1:         if (command.isClose()) {
0:             for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession s = (ActiveMQSession)i.next();
1:         } else {
0:             for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession s = (ActiveMQSession)i.next();
0:                 s.setPrefetchSize(command.getConsumerId(), command.getPrefetch());
1: 
1:     protected void transportFailed(IOException error) {
1:             try {
0:             } catch (JMSException e) {
0:                 LOG.warn("Cleanup failed", e);
/////////////////////////////////////////////////////////////////////////
1: 
1:         return "ActiveMQConnection {id=" + info.getConnectionId() + ",clientId=" + info.getClientId() + ",started=" + started.get() + "}";
1:     public int getProtocolVersion() {
1:         return protocolVersion.get();
1:     public int getProducerWindowSize() {
1:         return producerWindowSize;
1:     public void setProducerWindowSize(int producerWindowSize) {
1:         this.producerWindowSize = producerWindowSize;
1:     }
1: 
1:     protected void removeDispatcher(ActiveMQDispatcher dispatcher) {
1:         connectionAudit.removeDispatcher(dispatcher);
1:     }
1: 
1:     protected boolean isDuplicate(ActiveMQDispatcher dispatcher, Message message) {
0:         return connectionAudit.isDuplicate(dispatcher, message);
1:     }
1: 
1:     protected void rollbackDuplicate(ActiveMQDispatcher dispatcher, Message message) {
1:         connectionAudit.rollbackDuplicate(dispatcher, message);
commit:3a7c673
/////////////////////////////////////////////////////////////////////////
0:         try {
0: 			brokerInfoReceived.await(5,TimeUnit.SECONDS);
0: 	        if (brokerInfo == null) {
1: 	            return null;
1: 	        }
0: 	        return brokerInfo.getBrokerName();
1: 		} catch (InterruptedException e) {
0: 			Thread.currentThread().interrupt();
1: 			return null;
1: 		}
commit:fb3b6db
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.state.CommandVisitorAdapter;
/////////////////////////////////////////////////////////////////////////
0:         	try {
0: 				command.visit(new CommandVisitorAdapter(){
0: 					@Override
0: 					public Response processMessageDispatch(MessageDispatch md) throws Exception {
0: 		                ActiveMQDispatcher dispatcher = (ActiveMQDispatcher) dispatchers.get(md.getConsumerId());
0: 		                if (dispatcher != null) {
0: 		                    // Copy in case a embedded broker is dispatching via vm://
0: 		                    // md.getMessage() == null to signal end of queue browse.
0: 		                    Message msg = md.getMessage();
0: 		                    if( msg!=null ) {
0: 		                        msg = msg.copy();
0: 		                        msg.setReadOnlyBody(true);
0: 		                        msg.setReadOnlyProperties(true);
0: 		                        msg.setRedeliveryCounter(md.getRedeliveryCounter());
0: 		                        msg.setConnection(ActiveMQConnection.this);
0: 		                        md.setMessage( msg );
1: 		                    }
0: 		                    dispatcher.dispatch(md);
1: 		                }
0: 		                return null;
1: 					}
1: 					
0: 					@Override
0: 					public Response processProducerAck(ProducerAck pa) throws Exception {
0: 		            	ActiveMQMessageProducer producer = producers.get(pa.getProducerId());
0: 		            	if( producer!=null ) {
1: 		            		producer.onProducerAck(pa);
1: 		            	}
0: 		            	return null;
1: 					}
1: 					
0: 					@Override
0: 					public Response processBrokerInfo(BrokerInfo info) throws Exception {
0: 		                brokerInfoReceived.countDown();
0: 		                optimizeAcknowledge &= !brokerInfo.isFaultTolerantConfiguration();
0: 		                getBlobTransferPolicy().setBrokerUploadUrl(info.getBrokerUploadUrl());
0: 		                return null;
1: 					}
1: 					
0: 					@Override
0: 					public Response processConnectionError(final ConnectionError error) throws Exception {
0: 		                asyncConnectionThread.execute(new Runnable(){
1: 		                    public void run() {
0: 		                        onAsyncException(error.getException());
1: 		                    }
1: 		                });
0: 		                new Thread("Async error worker") {
0: 		                }.start();
0: 		                return null;
1: 					}
0: 					@Override
0: 					public Response processControlCommand(ControlCommand command) throws Exception {
0: 		                onControlCommand(command);
0: 		                return null;
1: 					}
0: 					@Override
0: 					public Response processConnectionControl(ConnectionControl control) throws Exception {
0: 		                onConnectionControl((ConnectionControl) command);
0: 		                return null;
1: 					}
0: 					@Override
0: 					public Response processConsumerControl(ConsumerControl control) throws Exception {
0: 		                onConsumerControl((ConsumerControl) command);
0: 		                return null;
1: 					}
0: 					@Override
0: 					public Response processWireFormat(WireFormatInfo info) throws Exception {
0: 		                onConsumerControl((ConsumerControl) command);
0: 		                return null;
1: 					}
1: 				});
1: 			} catch (Exception e) {
0: 				onAsyncException(e);
1: 			}
1: 			
commit:c9bb1c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerAck;
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<ProducerId, ActiveMQMessageProducer> producers = new ConcurrentHashMap<ProducerId, ActiveMQMessageProducer>();
/////////////////////////////////////////////////////////////////////////
0:     private int producerWindowSize=ActiveMQConnectionFactory.DEFAULT_PRODUCER_WINDOW_SIZE;
/////////////////////////////////////////////////////////////////////////
1:     
0: 	public void addProducer(ProducerId producerId, ActiveMQMessageProducer producer) {
0: 		producers.put(producerId, producer);		
1: 	}
0: 	public void removeProducer(ProducerId producerId) {
0: 		producers.remove(producerId);		
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
0:             } else if (command.getDataStructureType() == ProducerAck.DATA_STRUCTURE_TYPE ) {
0:             	ProducerAck pa = (ProducerAck) command;
0:             	ActiveMQMessageProducer producer = producers.get(pa.getProducerId());
0:             	if( producer!=null ) {
0:             		producer.onProducerAck(pa);
1:             	}
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0: 	public int getProducerWindowSize() {
0: 		return producerWindowSize;
1: 	}
1: 
1: 
0: 	public void setProducerWindowSize(int producerWindowSize) {
0: 		this.producerWindowSize = producerWindowSize;
1: 	}
1: 
1: 
commit:1a3f54c
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.blob.BlobTransferPolicy;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.CommandTypes;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
0:     // Assume that protocol is the latest.  Change to the actual protocol
1:     // version when a WireFormatInfo is received.
0:     private AtomicInteger protocolVersion=new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
/////////////////////////////////////////////////////////////////////////
0:             }else if ( command.isWireFormatInfo() ) {
0:             	onWireFormatInfo((WireFormatInfo)command);
/////////////////////////////////////////////////////////////////////////
1:     protected void onWireFormatInfo(WireFormatInfo info) {
0:     	protocolVersion.set(info.getVersion());
1: 	}
1: 
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0: 	public int getProtocolVersion() {
0: 		return protocolVersion.get();
1: 	}
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.LinkedBlockingQueue;
0: import java.util.concurrent.ThreadFactory;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:         //asyncConnectionThread.allowCoreThreadTimeOut(true);
commit:d71bc42
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Sets the default client id that the connection will use if explicitly not set with
0:      * the setClientId() call.
1:      */
1:     public void setDefaultClientID(String clientID) throws JMSException {
1:         this.info.setClientId(clientID);
1:         this.userSpecifiedClientID = true;
1:     }
1: 
commit:333158a
/////////////////////////////////////////////////////////////////////////
1:         info.setSubscriptionName(subscriptionName);
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
0:                 Response response = (Response) this.transport.request(command);
/////////////////////////////////////////////////////////////////////////
0:                 Response response = (Response) this.transport.request(command,timeout);
/////////////////////////////////////////////////////////////////////////
1:     public void onCommand(final Object o) {
0:     	final Command command = (Command) o;
commit:b75a6da
/////////////////////////////////////////////////////////////////////////
0:             Thread.currentThread().interrupt();
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:1bd8c0b
/////////////////////////////////////////////////////////////////////////
commit:acd5996
/////////////////////////////////////////////////////////////////////////
0:                 this.factoryStats.removeConnection(this);
1:                 
0:                 if( advisoryConsumer!=null ) {
1:                     advisoryConsumer.dispose();
0:                     advisoryConsumer=null;
1:                 }
commit:1b4eb12
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e2aad41
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public static final TaskRunnerFactory SESSION_TASK_RUNNER = new TaskRunnerFactory("ActiveMQ Session Task",ThreadPriorities.INBOUND_CLIENT_SESSION,true,1000);
0:     private final ThreadPoolExecutor asyncConnectionThread;
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQConnection(final Transport transport, JMSStatsImpl factoryStats)
0:         // Configure a single threaded executor who's core thread can timeout if idle
0:                 Thread thread = new Thread(r, "AcitveMQ Connection Worker: "+transport);
0:                 thread.setDaemon(true);
1:                 return thread;
0:         asyncConnectionThread.allowCoreThreadTimeOut(true);
commit:cb1d21f
/////////////////////////////////////////////////////////////////////////
1:         info.setTimeout(0);
/////////////////////////////////////////////////////////////////////////
0:         info.setTimeout(0);
commit:535c30c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Todo: see if we can allow the core threads to timeout.
0:         // asyncConnectionThread.allowCoreThreadTimeOut(true);
/////////////////////////////////////////////////////////////////////////
0:                 if (response!=null && response.isException()) {
commit:dcf7dea
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.Executor;
0: import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingDeque;
0: import edu.emory.mathcs.backport.java.util.concurrent.LinkedBlockingQueue;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
0:     private final Executor asyncConnectionThread;
/////////////////////////////////////////////////////////////////////////
1:        
0: 	// Configure a single threaded executor who's core thread can timeout if idle
0:         asyncConnectionThread = new ThreadPoolExecutor(1,1,5,TimeUnit.SECONDS, new LinkedBlockingQueue(), new ThreadFactory() {
1:             public Thread newThread(Runnable r) {
0:                 return new Thread(r, "Connection task");
0:             }});
0:         asyncConnectionThread.allowCoreThreadTimeOut(true);
1:         
/////////////////////////////////////////////////////////////////////////
0:     public void onCommand(final Command command) {
/////////////////////////////////////////////////////////////////////////
0:                 asyncConnectionThread.execute(new Runnable(){
1:                     public void run() {
0:                         onAsyncException(((ConnectionError)command).getException());
1:                     }
0:                 });
0:                 new Thread("Async error worker") {
0:                 }.start();
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final JMSException e = (JMSException) error;
1:                 
0:                 asyncConnectionThread.execute(new Runnable(){
0:                     public void run() {
1:                         ActiveMQConnection.this.exceptionListener.onException(e);
1:                     }
0:                 });
1:                 
1:     public void onException(final IOException error) {
0:         asyncConnectionThread.execute(new Runnable(){
0:             public void run() {
0:                 transportFailed(error);
0:                 ServiceSupport.dispose(ActiveMQConnection.this.transport);
0:                 brokerInfoReceived.countDown();
1:         
0:                 for (Iterator iter = transportListeners.iterator(); iter.hasNext();) {
0:                     TransportListener listener = (TransportListener) iter.next();
0:                     listener.onException(error);
1:                 }
1:             }
0:         });
/////////////////////////////////////////////////////////////////////////
1: }
commit:b1cd2b9
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:baab4b2
/////////////////////////////////////////////////////////////////////////
0:         info.setDispatchAsync(asyncDispatch);
/////////////////////////////////////////////////////////////////////////
1:         
0:         info.setDispatchAsync(asyncDispatch);
commit:7f9f040
/////////////////////////////////////////////////////////////////////////
1:         if (!closed.get() && !closing.get()) {
0:             try{
0:                 cleanup();
0:             }catch(JMSException e){
0:                log.warn("Cleanup failed",e);
1:             }
commit:4092658
/////////////////////////////////////////////////////////////////////////
0:         transportFailed(error);
commit:6397d05
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConnectionError;
/////////////////////////////////////////////////////////////////////////
0:             else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
0:                 onAsyncException(((ConnectionError)command).getException());
1:             }
commit:c59246d
/////////////////////////////////////////////////////////////////////////
1:         return brokerInfo.getBrokerId().getValue();
commit:90e21b4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private BrokerInfo brokerInfo;
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQConnection(Transport transport, JMSStatsImpl factoryStats)
1:         this.transport = transport;
1:         this.stats = new JMSConnectionStatsImpl(sessions, this instanceof XAConnection);
1:         this.factoryStats = factoryStats;
1:         this.factoryStats.addConnection(this);
1:     }
1: 
1: 
1:     protected void setUserName(String userName) {
1:         this.info.setUserName(userName);
1:     }
1: 
1:     protected void setPassword(String password) {
1:         this.info.setPassword(password);
/////////////////////////////////////////////////////////////////////////
0:         if( brokerInfo==null )
0:             throw new JMSException("Connection failed before Broker info was received.");            
0:         return brokerInfo.getBrokerId().getBrokerId();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 this.brokerInfo = (BrokerInfo)command;
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  *  Licensed under the Apache License, Version 2.0 (the "License");
0:  *  you may not use this file except in compliance with the License.
0:  *  You may obtain a copy of the License at
0:  *
0:  *     http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  *  Unless required by applicable law or agreed to in writing, software
0:  *  distributed under the License is distributed on an "AS IS" BASIS,
0:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  *  See the License for the specific language governing permissions and
0:  *  limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.OutputStream;
1: import java.net.URI;
1: import java.net.URISyntaxException;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Map;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionConsumer;
1: import javax.jms.ConnectionMetaData;
1: import javax.jms.Destination;
1: import javax.jms.ExceptionListener;
1: import javax.jms.IllegalStateException;
1: import javax.jms.InvalidDestinationException;
1: import javax.jms.JMSException;
1: import javax.jms.Queue;
1: import javax.jms.QueueConnection;
1: import javax.jms.QueueSession;
1: import javax.jms.ServerSessionPool;
1: import javax.jms.Session;
1: import javax.jms.Topic;
1: import javax.jms.TopicConnection;
1: import javax.jms.TopicSession;
1: import javax.jms.XAConnection;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQTempDestination;
1: import org.apache.activemq.command.ActiveMQTempQueue;
1: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.BrokerInfo;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.ControlCommand;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.RedeliveryPolicy;
1: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.ShutdownInfo;
1: import org.apache.activemq.management.JMSConnectionStatsImpl;
1: import org.apache.activemq.management.JMSStatsImpl;
1: import org.apache.activemq.management.StatsCapable;
1: import org.apache.activemq.management.StatsImpl;
1: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportListener;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.JMSExceptionSupport;
1: import org.apache.activemq.util.LongSequenceGenerator;
1: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1: 
1: 
0: public class ActiveMQConnection implements Connection, TopicConnection, QueueConnection, StatsCapable, Closeable, TransportListener, StreamConnection {
1: 
0:     public static final TaskRunnerFactory SESSION_TASK_RUNNER = new TaskRunnerFactory("session Task",ThreadPriorities.INBOUND_CLIENT_SESSION,true,1000);
1: 
0:     private static final Log log = LogFactory.getLog(ActiveMQConnection.class);
0:     private static final IdGenerator connectionIdGenerator = new IdGenerator();
0:     private static final IdGenerator clientIdGenerator = new IdGenerator();
1: 
1:     public static final String DEFAULT_USER = ActiveMQConnectionFactory.DEFAULT_USER;
1:     public static final String DEFAULT_PASSWORD = ActiveMQConnectionFactory.DEFAULT_PASSWORD;
1:     public static final String DEFAULT_BROKER_URL = ActiveMQConnectionFactory.DEFAULT_BROKER_URL;
1:      
1:     // Connection state variables
1:     private final ConnectionInfo info;
1:     private ExceptionListener exceptionListener;
0:     private String resourceManagerId;
1:     private boolean clientIDSet;
1:     private boolean isConnectionInfoSentToBroker;
1:     private boolean userSpecifiedClientID;
1:     
1:     // Configuration options variables
1:     private ActiveMQPrefetchPolicy prefetchPolicy = new ActiveMQPrefetchPolicy();
0:     private RedeliveryPolicy redeliveryPolicy;
0:     private boolean disableTimeStampsByDefault = false;
0:     private boolean onSendPrepareMessageBody = true;
1:     private boolean optimizedMessageDispatch = true;
1:     private boolean copyMessageOnSend = true;
0:     private boolean useCompression = false;
0:     private boolean objectMessageSerializationDefered = false;
0:     protected boolean asyncDispatch = true;
0:     private boolean useAsyncSend = false;
1:     private boolean useRetroactiveConsumer;
1:     
0:     private long flowControlSleepTime = 0;
1:     private final JMSConnectionStatsImpl stats;
1:     private final JMSStatsImpl factoryStats;
1:     private final Transport transport;
1:     private final AtomicBoolean started = new AtomicBoolean(false);
1:     private final AtomicBoolean closing = new AtomicBoolean(false);
1:     private final AtomicBoolean closed = new AtomicBoolean(false);
0:     private final CopyOnWriteArrayList sessions = new CopyOnWriteArrayList();
0:     private final CopyOnWriteArrayList connectionConsumers = new CopyOnWriteArrayList();
0:     private final CopyOnWriteArrayList inputStreams = new CopyOnWriteArrayList();
0:     private final CopyOnWriteArrayList outputStreams = new CopyOnWriteArrayList();
1: 
1:     // Maps ConsumerIds to ActiveMQConsumer objects
0:     private final ConcurrentHashMap dispatchers = new ConcurrentHashMap();
1:     private final LongSequenceGenerator sessionIdGenerator = new LongSequenceGenerator();
1:     private final SessionId connectionSessionId;
1:     private final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
0:     private final LongSequenceGenerator producerIdGenerator = new LongSequenceGenerator();
1:     private final LongSequenceGenerator tempDestinationIdGenerator = new LongSequenceGenerator();
1:     private final LongSequenceGenerator localTransactionIdGenerator = new LongSequenceGenerator();
0:     final ConcurrentHashMap activeTempDestinations = new ConcurrentHashMap();
1: 
1:     private AdvisoryConsumer advisoryConsumer;
1:     private final CountDownLatch brokerInfoReceived = new CountDownLatch(1);
1: 
1: 
1: 
1:     /**
1:      * Construct an <code>ActiveMQConnection</code>
0:      * @param transport 
1:      * @param factoryStats
0:      * @param userName
1:      * @param password
1:      * @throws Exception 
1:      */
0:     protected ActiveMQConnection(Transport transport, String userName, String password, JMSStatsImpl factoryStats)
0:             throws Exception {
0:         this.transport = transport;
0:         this.info = new ConnectionInfo(new ConnectionId(connectionIdGenerator.generateId()));
1:         this.info.setUserName(userName);
1:         this.info.setPassword(password);
1: 
1:         this.connectionSessionId = new SessionId(info.getConnectionId(), -1);
1:         
0:         this.factoryStats = factoryStats;
0:         this.factoryStats.addConnection(this);
0:         this.stats = new JMSConnectionStatsImpl(sessions, this instanceof XAConnection);
1:         this.transport.setTransportListener(this);
1: 
0:         transport.start();
1:     }
1: 
1:     /**
1:      * A static helper method to create a new connection
0:      * 
1:      * @return an ActiveMQConnection
1:      * @throws JMSException
1:      */
1:     public static ActiveMQConnection makeConnection() throws JMSException {
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory();
0:         return (ActiveMQConnection) factory.createConnection();
1:     }
1: 
1:     /**
1:      * A static helper method to create a new connection
0:      * 
1:      * @param uri
1:      * @return and ActiveMQConnection
1:      * @throws JMSException
1:      */
1:     public static ActiveMQConnection makeConnection(String uri) throws JMSException, URISyntaxException {
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(uri);
0:         return (ActiveMQConnection) factory.createConnection();
1:     }
1: 
1:     /**
1:      * A static helper method to create a new connection
0:      * 
1:      * @param user
1:      * @param password
1:      * @param uri
1:      * @return an ActiveMQConnection
1:      * @throws JMSException
1:      */
0:     public static ActiveMQConnection makeConnection(String user, String password, String uri)
0:             throws JMSException, URISyntaxException {
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(user, password, new URI(uri));
0:         return (ActiveMQConnection) factory.createConnection();
1:     }
1: 
1:     /**
1:      * @return a number unique for this connection
1:      */
1:     public JMSConnectionStatsImpl getConnectionStats() {
1:         return stats;
1:     }
1: 
1:     /**
1:      * Creates a <CODE>Session</CODE> object.
0:      * 
0:      * @param transacted
0:      *            indicates whether the session is transacted
0:      * @param acknowledgeMode
0:      *            indicates whether the consumer or the client will acknowledge
0:      *            any messages it receives; ignored if the session is
0:      *            transacted. Legal values are
0:      *            <code>Session.AUTO_ACKNOWLEDGE</code>,
0:      *            <code>Session.CLIENT_ACKNOWLEDGE</code>, and
0:      *            <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:      * @return a newly created session
1:      * @throws JMSException
0:      *             if the <CODE>Connection</CODE> object fails to create a
0:      *             session due to some internal error or lack of support for the
0:      *             specific transaction and acknowledgement mode.
1:      * @see Session#AUTO_ACKNOWLEDGE
1:      * @see Session#CLIENT_ACKNOWLEDGE
1:      * @see Session#DUPS_OK_ACKNOWLEDGE
1:      * @since 1.1
1:      */
0:     public Session createSession(boolean transacted, int acknowledgeMode) throws JMSException {
1:         checkClosed();
1:         ensureConnectionInfoSent();
0:         return new ActiveMQSession(this, getNextSessionId(), (transacted ? Session.SESSION_TRANSACTED
0:                 : (acknowledgeMode == Session.SESSION_TRANSACTED ? Session.AUTO_ACKNOWLEDGE : acknowledgeMode)), asyncDispatch);
1:     }
1: 
1:     /**
0:      * @return
1:      */
1:     protected SessionId getNextSessionId() {
1:         return new SessionId(info.getConnectionId(), sessionIdGenerator.getNextSequenceId());
1:     }
1: 
1:     /**
1:      * Gets the client identifier for this connection.
1:      * <P>
1:      * This value is specific to the JMS provider. It is either preconfigured by
1:      * an administrator in a <CODE> ConnectionFactory</CODE> object or assigned
1:      * dynamically by the application by calling the <code>setClientID</code>
1:      * method.
0:      * 
1:      * @return the unique client identifier
1:      * @throws JMSException
0:      *             if the JMS provider fails to return the client ID for this
0:      *             connection due to some internal error.
1:      */
1:     public String getClientID() throws JMSException {
1:         checkClosed();
1:         return this.info.getClientId();
1:     }
1: 
1:     /**
1:      * Sets the client identifier for this connection.
1:      * <P>
1:      * The preferred way to assign a JMS client's client identifier is for it to
1:      * be configured in a client-specific <CODE>ConnectionFactory</CODE>
1:      * object and transparently assigned to the <CODE>Connection</CODE> object
1:      * it creates.
1:      * <P>
1:      * Alternatively, a client can set a connection's client identifier using a
1:      * provider-specific value. The facility to set a connection's client
1:      * identifier explicitly is not a mechanism for overriding the identifier
1:      * that has been administratively configured. It is provided for the case
1:      * where no administratively specified identifier exists. If one does exist,
0:      * an attempt to change it by setting it must throw an <CODE>IllegalStateException</CODE>.
0:      * If a client sets the client identifier explicitly, it must do so
0:      * immediately after it creates the connection and before any other action
0:      * on the connection is taken. After this point, setting the client
0:      * identifier is a programming error that should throw an <CODE>IllegalStateException</CODE>.
1:      * <P>
1:      * The purpose of the client identifier is to associate a connection and its
1:      * objects with a state maintained on behalf of the client by a provider.
1:      * The only such state identified by the JMS API is that required to support
1:      * durable subscriptions.
1:      * <P>
1:      * If another connection with the same <code>clientID</code> is already
1:      * running when this method is called, the JMS provider should detect the
1:      * duplicate ID and throw an <CODE>InvalidClientIDException</CODE>.
0:      * 
0:      * @param newClientID
0:      *            the unique client identifier
1:      * @throws JMSException
0:      *             if the JMS provider fails to set the client ID for this
0:      *             connection due to some internal error.
0:      * @throws javax.jms.InvalidClientIDException
0:      *             if the JMS client specifies an invalid or duplicate client
0:      *             ID.
0:      * @throws javax.jms.IllegalStateException
0:      *             if the JMS client attempts to set a connection's client ID at
0:      *             the wrong time or when it has been administratively
0:      *             configured.
1:      */
1:     public void setClientID(String newClientID) throws JMSException {
1:         checkClosed();
1: 
1:         if (this.clientIDSet) {
1:             throw new IllegalStateException("The clientID has already been set");
1:         }
1: 
1:         if (this.isConnectionInfoSentToBroker) {
1:             throw new IllegalStateException("Setting clientID on a used Connection is not allowed");
1:         }
1: 
1:         this.info.setClientId(newClientID);
1:         this.userSpecifiedClientID = true;
1:         ensureConnectionInfoSent();
1:     }
1: 
1:     /**
1:      * Gets the metadata for this connection.
0:      * 
1:      * @return the connection metadata
1:      * @throws JMSException
0:      *             if the JMS provider fails to get the connection metadata for
0:      *             this connection.
1:      * @see javax.jms.ConnectionMetaData
1:      */
1:     public ConnectionMetaData getMetaData() throws JMSException {
1:         checkClosed();
1:         return ActiveMQConnectionMetaData.INSTANCE;
1:     }
1: 
1:     /**
1:      * Gets the <CODE>ExceptionListener</CODE> object for this connection. Not
1:      * every <CODE>Connection</CODE> has an <CODE>ExceptionListener</CODE>
1:      * associated with it.
0:      * 
1:      * @return the <CODE>ExceptionListener</CODE> for this connection, or
0:      *         null. if no <CODE>ExceptionListener</CODE> is associated with
1:      *         this connection.
1:      * @throws JMSException
0:      *             if the JMS provider fails to get the <CODE>ExceptionListener</CODE>
0:      *             for this connection.
1:      * @see javax.jms.Connection#setExceptionListener(ExceptionListener)
1:      */
1:     public ExceptionListener getExceptionListener() throws JMSException {
1:         checkClosed();
1:         return this.exceptionListener;
1:     }
1: 
1:     /**
1:      * Sets an exception listener for this connection.
1:      * <P>
1:      * If a JMS provider detects a serious problem with a connection, it informs
1:      * the connection's <CODE> ExceptionListener</CODE>, if one has been
1:      * registered. It does this by calling the listener's <CODE>onException
0:      * </CODE> method, passing it a <CODE>JMSException</CODE> object
1:      * describing the problem.
1:      * <P>
1:      * An exception listener allows a client to be notified of a problem
1:      * asynchronously. Some connections only consume messages, so they would
1:      * have no other way to learn their connection has failed.
1:      * <P>
1:      * A connection serializes execution of its <CODE>ExceptionListener</CODE>.
1:      * <P>
1:      * A JMS provider should attempt to resolve connection problems itself
1:      * before it notifies the client of them.
0:      * 
0:      * @param listener
0:      *            the exception listener
1:      * @throws JMSException
0:      *             if the JMS provider fails to set the exception listener for
0:      *             this connection.
1:      */
1:     public void setExceptionListener(ExceptionListener listener) throws JMSException {
1:         checkClosed();
1:         this.exceptionListener = listener;
1:     }
1: 
1:     /**
1:      * Starts (or restarts) a connection's delivery of incoming messages. A call
1:      * to <CODE>start</CODE> on a connection that has already been started is
1:      * ignored.
0:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to start message delivery due to
0:      *             some internal error.
1:      * @see javax.jms.Connection#stop()
1:      */
1:     public void start() throws JMSException {
1:         checkClosed();
1:         ensureConnectionInfoSent();
1:         if (started.compareAndSet(false, true)) {
0:             for (Iterator i = sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession session = (ActiveMQSession) i.next();
1:                 session.start();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * @return true if this Connection is started
1:      */
0:     protected boolean isStarted() {
1:         return started.get();
1:     }
1: 
1:     /**
1:      * Temporarily stops a connection's delivery of incoming messages. Delivery
1:      * can be restarted using the connection's <CODE>start</CODE> method. When
1:      * the connection is stopped, delivery to all the connection's message
1:      * consumers is inhibited: synchronous receives block, and messages are not
1:      * delivered to message listeners.
1:      * <P>
1:      * This call blocks until receives and/or message listeners in progress have
1:      * completed.
1:      * <P>
1:      * Stopping a connection has no effect on its ability to send messages. A
1:      * call to <CODE>stop</CODE> on a connection that has already been stopped
1:      * is ignored.
1:      * <P>
1:      * A call to <CODE>stop</CODE> must not return until delivery of messages
1:      * has paused. This means that a client can rely on the fact that none of
1:      * its message listeners will be called and that all threads of control
1:      * waiting for <CODE>receive</CODE> calls to return will not return with a
1:      * message until the connection is restarted. The receive timers for a
1:      * stopped connection continue to advance, so receives may time out while
1:      * the connection is stopped.
1:      * <P>
1:      * If message listeners are running when <CODE>stop</CODE> is invoked, the
1:      * <CODE>stop</CODE> call must wait until all of them have returned before
1:      * it may return. While these message listeners are completing, they must
1:      * have the full services of the connection available to them.
0:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to stop message delivery due to
0:      *             some internal error.
1:      * @see javax.jms.Connection#start()
1:      */
1:     public void stop() throws JMSException {
1:         checkClosed();
1:         if (started.compareAndSet(true, false)) {
0:             for (Iterator i = sessions.iterator(); i.hasNext();) {
0:                 ActiveMQSession s = (ActiveMQSession) i.next();
1:                 s.stop();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Closes the connection.
1:      * <P>
1:      * Since a provider typically allocates significant resources outside the
1:      * JVM on behalf of a connection, clients should close these resources when
1:      * they are not needed. Relying on garbage collection to eventually reclaim
1:      * these resources may not be timely enough.
1:      * <P>
1:      * There is no need to close the sessions, producers, and consumers of a
1:      * closed connection.
1:      * <P>
1:      * Closing a connection causes all temporary destinations to be deleted.
1:      * <P>
1:      * When this method is invoked, it should not return until message
1:      * processing has been shut down in an orderly fashion. This means that all
1:      * message listeners that may have been running have returned, and that all
1:      * pending receives have returned. A close terminates all pending message
1:      * receives on the connection's sessions' consumers. The receives may return
1:      * with a message or with null, depending on whether there was a message
1:      * available at the time of the close. If one or more of the connection's
1:      * sessions' message listeners is processing a message at the time when
1:      * connection <CODE>close</CODE> is invoked, all the facilities of the
1:      * connection and its sessions must remain available to those listeners
1:      * until they return control to the JMS provider.
1:      * <P>
1:      * Closing a connection causes any of its sessions' transactions in progress
1:      * to be rolled back. In the case where a session's work is coordinated by
1:      * an external transaction manager, a session's <CODE>commit</CODE> and
1:      * <CODE> rollback</CODE> methods are not used and the result of a closed
1:      * session's work is determined later by the transaction manager. Closing a
1:      * connection does NOT force an acknowledgment of client-acknowledged
1:      * sessions.
1:      * <P>
1:      * Invoking the <CODE>acknowledge</CODE> method of a received message from
0:      * a closed connection's session must throw an <CODE>IllegalStateException</CODE>.
0:      * Closing a closed connection must NOT throw an exception.
0:      * 
1:      * @throws JMSException
0:      *             if the JMS provider fails to close the connection due to some
0:      *             internal error. For example, a failure to release resources
0:      *             or to close a socket connection can cause this exception to
0:      *             be thrown.
1:      */
1:     public void close() throws JMSException {
1:         checkClosed();
1: 
1:         // If we were running, lets stop first.
0:         stop();
1: 
0:         synchronized (this) {
1:             if (!closed.get()) {
1:                 closing.set(true);
1: 
0:                 if( advisoryConsumer!=null ) {
0:                     advisoryConsumer.dispose();
0:                     advisoryConsumer=null;
1:                 }
1: 
0:                 for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:                     ActiveMQSession s = (ActiveMQSession) i.next();
1:                     s.dispose();
1:                 }
0:                 for (Iterator i = this.connectionConsumers.iterator(); i.hasNext();) {
0:                     ActiveMQConnectionConsumer c = (ActiveMQConnectionConsumer) i.next();
1:                     c.dispose();
1:                 }
0:                 for (Iterator i = this.inputStreams.iterator(); i.hasNext();) {
0:                     ActiveMQInputStream c = (ActiveMQInputStream) i.next();
1:                     c.dispose();
1:                 }
0:                 for (Iterator i = this.outputStreams.iterator(); i.hasNext();) {
0:                     ActiveMQOutputStream c = (ActiveMQOutputStream) i.next();
1:                     c.dispose();
1:                 }
1:                 
1:                 
0:                 if (isConnectionInfoSentToBroker) {
0:                     syncSendPacket(info.createRemoveCommand());
1:                 }
1: 
0:                 asyncSendPacket(new ShutdownInfo());
0:                 ServiceSupport.dispose(this.transport);
1: 
0:                 started.set(false);
1: 
0:                 // TODO : ActiveMQConnectionFactory.onConnectionClose() not
0:                 // yet implemented.
0:                 // factory.onConnectionClose(this);
1:                 
0:                 closed.set(true);
0:                 closing.set(false);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Tells the broker to terminate its VM. This can be used to cleanly
1:      * terminate a broker running in a standalone java process. Server must have
1:      * property enable.vm.shutdown=true defined to allow this to work.
1:      */
0:     // TODO : org.apache.activemq.message.BrokerAdminCommand not yet implemented.
1:     /*
1:      * public void terminateBrokerVM() throws JMSException { BrokerAdminCommand
1:      * command = new BrokerAdminCommand();
1:      * command.setCommand(BrokerAdminCommand.SHUTDOWN_SERVER_VM);
1:      * asyncSendPacket(command); }
1:      */
1: 
1: 
1:     /**
1:      * Create a durable connection consumer for this connection (optional
1:      * operation). This is an expert facility not used by regular JMS clients.
0:      * 
0:      * @param topic
0:      *            topic to access
0:      * @param subscriptionName
0:      *            durable subscription name
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param sessionPool
0:      *            the server session pool to associate with this durable
0:      *            connection consumer
0:      * @param maxMessages
0:      *            the maximum number of messages that can be assigned to a
0:      *            server session at one time
1:      * @return the durable connection consumer
1:      * @throws JMSException
0:      *             if the <CODE>Connection</CODE> object fails to create a
0:      *             connection consumer due to some internal error or invalid
0:      *             arguments for <CODE>sessionPool</CODE> and <CODE>messageSelector</CODE>.
0:      * @throws javax.jms.InvalidDestinationException
0:      *             if an invalid destination is specified.
0:      * @throws javax.jms.InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @see javax.jms.ConnectionConsumer
1:      * @since 1.1
1:      */
0:     public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName,
0:             String messageSelector, ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:         return this.createDurableConnectionConsumer(topic, subscriptionName, messageSelector, sessionPool, maxMessages, false);
1:     }
1: 
1:     /**
1:      * Create a durable connection consumer for this connection (optional
1:      * operation). This is an expert facility not used by regular JMS clients.
0:      * 
0:      * @param topic
0:      *            topic to access
0:      * @param subscriptionName
0:      *            durable subscription name
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param sessionPool
0:      *            the server session pool to associate with this durable
0:      *            connection consumer
0:      * @param maxMessages
0:      *            the maximum number of messages that can be assigned to a
0:      *            server session at one time
0:      * @param noLocal
0:      *            set true if you want to filter out messages published locally
0:      * 
1:      * @return the durable connection consumer
1:      * @throws JMSException
0:      *             if the <CODE>Connection</CODE> object fails to create a
0:      *             connection consumer due to some internal error or invalid
0:      *             arguments for <CODE>sessionPool</CODE> and <CODE>messageSelector</CODE>.
0:      * @throws javax.jms.InvalidDestinationException
0:      *             if an invalid destination is specified.
0:      * @throws javax.jms.InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @see javax.jms.ConnectionConsumer
1:      * @since 1.1
1:      */
0:     public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subscriptionName,
0:             String messageSelector, ServerSessionPool sessionPool, int maxMessages, boolean noLocal)
0:             throws JMSException {
1:         checkClosed();
1:         ensureConnectionInfoSent();
1:         SessionId sessionId = new SessionId(info.getConnectionId(), -1);
0:         ConsumerInfo info = new ConsumerInfo(new ConsumerId(sessionId, consumerIdGenerator
0:                 .getNextSequenceId()));
1:         info.setDestination(ActiveMQMessageTransformation.transformDestination(topic));
0:         info.setSubcriptionName(subscriptionName);
1:         info.setSelector(messageSelector);
1:         info.setPrefetchSize(maxMessages);
1: 
1:         // Allows the options on the destination to configure the consumerInfo
0:         if( info.getDestination().getOptions()!=null ) {
0:             HashMap options = new HashMap(info.getDestination().getOptions());
1:             IntrospectionSupport.setProperties(this.info, options, "consumer.");
1:         }
1: 
1:         return new ActiveMQConnectionConsumer(this, sessionPool, info);
1:     }
1: 
1: 
1:     // Properties
1:     // -------------------------------------------------------------------------
1: 
1:     /**
1:      * @return Returns the prefetchPolicy.
1:      */
1:     public ActiveMQPrefetchPolicy getPrefetchPolicy() {
1:         return prefetchPolicy;
1:     }
1: 
1:     /**
0:      * @param prefetchPolicy
0:      *            The prefetchPolicy to set.
1:      */
1:     public void setPrefetchPolicy(ActiveMQPrefetchPolicy prefetchPolicy) {
1:         this.prefetchPolicy = prefetchPolicy;
1:     }
1: 
1:     /**
1:      */
1:     public Transport getTransportChannel() {
1:         return transport;
1:     }
1: 
1:     /**
0:      * 
1:      * @return Returns the clientID of the connection, forcing one to be
1:      *         generated if one has not yet been configured.
1:      */
1:     public String getInitializedClientID() throws JMSException {
1:         ensureConnectionInfoSent();
1:         return info.getClientId();
1:     }
1: 
1:     /**
0:      * 
1:      * @return Returns the timeStampsDisableByDefault.
1:      */
1:     public boolean isDisableTimeStampsByDefault() {
1:         return disableTimeStampsByDefault;
1:     }
1: 
1:     /**
0:      * 
0:      * @param timeStampsDisableByDefault
0:      *            The timeStampsDisableByDefault to set.
1:      */
1:     public void setDisableTimeStampsByDefault(boolean timeStampsDisableByDefault) {
1:         this.disableTimeStampsByDefault = timeStampsDisableByDefault;
1:     }
1: 
1:     /**
0:      * 
1:      * @return Returns the dispatchOptimizedMessage.
1:      */
1:     public boolean isOptimizedMessageDispatch() {
1:         return optimizedMessageDispatch;
1:     }
1: 
1:     /**
0:      * 
0:      * @param dispatchOptimizedMessage
0:      *            The dispatchOptimizedMessage to set.
1:      */
1:     public void setOptimizedMessageDispatch(boolean dispatchOptimizedMessage) {
1:         this.optimizedMessageDispatch = dispatchOptimizedMessage;
1:     }
1: 
1:     /**
0:      * 
0:      * @return Returns the onSendPrepareMessageBody.
1:      */
0:     public boolean isOnSendPrepareMessageBody() {
0:         return onSendPrepareMessageBody;
1:     }
1: 
1:     /**
0:      * 
0:      * @param onSendPrepareMessageBody
0:      *            The onSendPrepareMessageBody to set.
1:      */
0:     public void setOnSendPrepareMessageBody(boolean onSendPrepareMessageBody) {
0:         this.onSendPrepareMessageBody = onSendPrepareMessageBody;
1:     }
1: 
1:     /**
0:      * 
1:      * @return ConnectionInfo
1:      */
1:     public ConnectionInfo getConnectionInfo() {
1:         return this.info;
1:     }
1: 
1:     public boolean isUseRetroactiveConsumer() {
1:         return useRetroactiveConsumer;
1:     }
1: 
1:     /**
0:      * Sets whether or not retroactive consumers are enabled. Retroactive consumers allow
0:      * non-durable topic subscribers to receive old messages that were published before the
0:      * non-durable subscriber started.
1:      */
1:     public void setUseRetroactiveConsumer(boolean useRetroactiveConsumer) {
1:         this.useRetroactiveConsumer = useRetroactiveConsumer;
1:     }
1: 
1:     
1:     // Implementation methods
1:     // -------------------------------------------------------------------------
1: 
1:     /**
1:      * Used internally for adding Sessions to the Connection
0:      * 
1:      * @param session
1:      * @throws JMSException 
1:      * @throws JMSException
1:      */
1:     protected void addSession(ActiveMQSession session) throws JMSException {
1:         this.sessions.add(session);
0:         if (sessions.size()>1 || session.isTransacted()){
1:             optimizedMessageDispatch = false;
1:         }
1:     }
1: 
1:     /**
1:      * Used interanlly for removing Sessions from a Connection
0:      * 
1:      * @param session
1:      */
1:     protected void removeSession(ActiveMQSession session) {
1:         this.sessions.remove(session);
1:     }
1: 
1:     /**
1:      * Add a ConnectionConsumer
0:      * 
1:      * @param connectionConsumer
1:      * @throws JMSException
1:      */
1:     protected void addConnectionConsumer(ActiveMQConnectionConsumer connectionConsumer) throws JMSException {
1:         this.connectionConsumers.add(connectionConsumer);
1:     }
1: 
1:     /**
1:      * Remove a ConnectionConsumer
0:      * 
1:      * @param connectionConsumer
1:      */
1:     protected void removeConnectionConsumer(ActiveMQConnectionConsumer connectionConsumer) {
1:         this.connectionConsumers.remove(connectionConsumer);
1:     }
1: 
1:     /**
1:      * Creates a <CODE>TopicSession</CODE> object.
0:      * 
0:      * @param transacted
0:      *            indicates whether the session is transacted
0:      * @param acknowledgeMode
0:      *            indicates whether the consumer or the client will acknowledge
0:      *            any messages it receives; ignored if the session is
0:      *            transacted. Legal values are
0:      *            <code>Session.AUTO_ACKNOWLEDGE</code>,
0:      *            <code>Session.CLIENT_ACKNOWLEDGE</code>, and
0:      *            <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:      * @return a newly created topic session
1:      * @throws JMSException
0:      *             if the <CODE>TopicConnection</CODE> object fails to create
0:      *             a session due to some internal error or lack of support for
0:      *             the specific transaction and acknowledgement mode.
1:      * @see Session#AUTO_ACKNOWLEDGE
1:      * @see Session#CLIENT_ACKNOWLEDGE
1:      * @see Session#DUPS_OK_ACKNOWLEDGE
1:      */
1:     public TopicSession createTopicSession(boolean transacted, int acknowledgeMode) throws JMSException {
0:         return new ActiveMQTopicSession((ActiveMQSession) createSession(transacted, acknowledgeMode));
1:     }
1: 
1:     /**
1:      * Creates a connection consumer for this connection (optional operation).
1:      * This is an expert facility not used by regular JMS clients.
0:      * 
0:      * @param topic
0:      *            the topic to access
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param sessionPool
0:      *            the server session pool to associate with this connection
0:      *            consumer
0:      * @param maxMessages
0:      *            the maximum number of messages that can be assigned to a
0:      *            server session at one time
1:      * @return the connection consumer
1:      * @throws JMSException
0:      *             if the <CODE>TopicConnection</CODE> object fails to create
0:      *             a connection consumer due to some internal error or invalid
0:      *             arguments for <CODE>sessionPool</CODE> and <CODE>messageSelector</CODE>.
0:      * @throws javax.jms.InvalidDestinationException
0:      *             if an invalid topic is specified.
0:      * @throws javax.jms.InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @see javax.jms.ConnectionConsumer
1:      */
1:     public ConnectionConsumer createConnectionConsumer(Topic topic, String messageSelector, ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:         return createConnectionConsumer(topic, messageSelector, sessionPool, maxMessages, false);
1:     }
1:     
1:     /**
1:      * Creates a connection consumer for this connection (optional operation).
1:      * This is an expert facility not used by regular JMS clients.
0:      * 
0:      * @param queue
0:      *            the queue to access
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param sessionPool
0:      *            the server session pool to associate with this connection
0:      *            consumer
0:      * @param maxMessages
0:      *            the maximum number of messages that can be assigned to a
0:      *            server session at one time
1:      * @return the connection consumer
1:      * @throws JMSException
0:      *             if the <CODE>QueueConnection</CODE> object fails to create
0:      *             a connection consumer due to some internal error or invalid
0:      *             arguments for <CODE>sessionPool</CODE> and <CODE>messageSelector</CODE>.
0:      * @throws javax.jms.InvalidDestinationException
0:      *             if an invalid queue is specified.
0:      * @throws javax.jms.InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @see javax.jms.ConnectionConsumer
1:      */
0:     public ConnectionConsumer createConnectionConsumer(Queue queue, String messageSelector,
0:             ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:         return createConnectionConsumer(queue, messageSelector, sessionPool, maxMessages, false);
1:     }
1: 
1:     /**
1:      * Creates a connection consumer for this connection (optional operation).
1:      * This is an expert facility not used by regular JMS clients.
0:      * 
1:      * @param destination
0:      *            the destination to access
0:      * @param messageSelector
0:      *            only messages with properties matching the message selector
0:      *            expression are delivered. A value of null or an empty string
0:      *            indicates that there is no message selector for the message
0:      *            consumer.
0:      * @param sessionPool
0:      *            the server session pool to associate with this connection
0:      *            consumer
0:      * @param maxMessages
0:      *            the maximum number of messages that can be assigned to a
0:      *            server session at one time
1:      * @return the connection consumer
1:      * @throws JMSException
0:      *             if the <CODE>Connection</CODE> object fails to create a
0:      *             connection consumer due to some internal error or invalid
0:      *             arguments for <CODE>sessionPool</CODE> and <CODE>messageSelector</CODE>.
0:      * @throws javax.jms.InvalidDestinationException
0:      *             if an invalid destination is specified.
0:      * @throws javax.jms.InvalidSelectorException
0:      *             if the message selector is invalid.
1:      * @see javax.jms.ConnectionConsumer
1:      * @since 1.1
1:      */
0:     public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector,
0:             ServerSessionPool sessionPool, int maxMessages) throws JMSException {
1:         return createConnectionConsumer(destination, messageSelector, sessionPool, maxMessages, false);
1:     }
1: 
0:     public ConnectionConsumer createConnectionConsumer(Destination destination, String messageSelector, ServerSessionPool sessionPool, int maxMessages, boolean noLocal) throws JMSException {
1:         
1:         checkClosed();
1:         ensureConnectionInfoSent();
1:         ConsumerId consumerId = createConsumerId();
0:         ConsumerInfo info = new ConsumerInfo(consumerId);
0:         info.setDestination(ActiveMQMessageTransformation.transformDestination(destination));
1:         info.setSelector(messageSelector);
1:         info.setPrefetchSize(maxMessages);
0:         info.setNoLocal(noLocal);
1:         
1:         // Allows the options on the destination to configure the consumerInfo
0:         if( info.getDestination().getOptions()!=null ) {
0:             HashMap options = new HashMap(info.getDestination().getOptions());
1:             IntrospectionSupport.setProperties(this.info, options, "consumer.");
1:         }
1:         
1:         return new ActiveMQConnectionConsumer(this, sessionPool, info);
1:     }
1: 
1:     /**
0:      * @return
1:      */
1:     private ConsumerId createConsumerId() {
1:         return new ConsumerId(connectionSessionId, consumerIdGenerator.getNextSequenceId());
1:     }
1:     
1:     /**
0:      * @return
1:      */
0:     private ProducerId createProducerId() {
0:         return new ProducerId(connectionSessionId, producerIdGenerator.getNextSequenceId());
1:     }
1: 
1: 
1:     /**
1:      * Creates a <CODE>QueueSession</CODE> object.
0:      * 
0:      * @param transacted
0:      *            indicates whether the session is transacted
0:      * @param acknowledgeMode
0:      *            indicates whether the consumer or the client will acknowledge
0:      *            any messages it receives; ignored if the session is
0:      *            transacted. Legal values are
0:      *            <code>Session.AUTO_ACKNOWLEDGE</code>,
0:      *            <code>Session.CLIENT_ACKNOWLEDGE</code>, and
0:      *            <code>Session.DUPS_OK_ACKNOWLEDGE</code>.
1:      * @return a newly created queue session
1:      * @throws JMSException
0:      *             if the <CODE>QueueConnection</CODE> object fails to create
0:      *             a session due to some internal error or lack of support for
0:      *             the specific transaction and acknowledgement mode.
1:      * @see Session#AUTO_ACKNOWLEDGE
1:      * @see Session#CLIENT_ACKNOWLEDGE
1:      * @see Session#DUPS_OK_ACKNOWLEDGE
1:      */
1:     public QueueSession createQueueSession(boolean transacted, int acknowledgeMode) throws JMSException {
0:         return new ActiveMQQueueSession((ActiveMQSession) createSession(transacted, acknowledgeMode));
1:     }
1: 
1:     /**
1:      * Ensures that the clientID was manually specified and not auto-generated.
1:      * If the clientID was not specified this method will throw an exception.
1:      * This method is used to ensure that the clientID + durableSubscriber name
1:      * are used correctly.
0:      * 
1:      * @throws JMSException
1:      */
1:     public void checkClientIDWasManuallySpecified() throws JMSException {
1:         if (!userSpecifiedClientID) {
0:             throw new JMSException(
0:                     "You cannot create a durable subscriber without specifying a unique clientID on a Connection");
1:         }
1:     }
1: 
1:     /**
1:      * send a Packet through the Connection - for internal use only
0:      * 
1:      * @param command
1:      * @throws JMSException
1:      */
1:     public void asyncSendPacket(Command command) throws JMSException {
1:         if (isClosed()) {
1:             throw new ConnectionClosedException();
1:         } else {
1: 
0:             if (command.isMessage() && flowControlSleepTime > 0) {
0:                 try {
0:                     Thread.sleep(flowControlSleepTime);
0:                 } catch (InterruptedException e) {
1:                 }
1:             }
1: 
0:             try {
0:                 this.transport.oneway(command);
0:             } catch (IOException e) {
0:                 throw JMSExceptionSupport.create(e);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Send a packet through a Connection - for internal use only
0:      * 
1:      * @param command
0:      * @return
1:      * @throws JMSException
1:      */
0:     public Response syncSendPacket(Command command) throws JMSException {
1:         if (isClosed()) {
1:             throw new ConnectionClosedException();
1:         } else {
1: 
0:             if (command.isMessage() && flowControlSleepTime > 0) {
0:                 try {
0:                     Thread.sleep(flowControlSleepTime);
0:                 } catch (InterruptedException e) {
1:                 }
1:             }
1: 
0:             try {
0:                 Response response = this.transport.request(command);
1:                 if (response.isException()) {
0:                     ExceptionResponse er = (ExceptionResponse) response;
0:                     if (er.getException() instanceof JMSException)
0:                         throw (JMSException) er.getException();
0:                     else
0:                         throw JMSExceptionSupport.create(er.getException());
1:                 }
0:                 return response;
0:             } catch (IOException e) {
0:                 throw JMSExceptionSupport.create(e);
1:             }
1:         }
1:     }
1: 
1:     public boolean isClosed() {
1:         return closed.get();
1:     }
1: 
1:     /**
1:      * @return statistics for this Connection
1:      */
1:     public StatsImpl getStats() {
1:         return stats;
1:     }
1: 
1:     /**
1:      * simply throws an exception if the Connection is already closed
0:      * 
1:      * @throws JMSException
1:      */
1:     protected synchronized void checkClosed() throws JMSException {
1:         if (closed.get()) {
1:             throw new ConnectionClosedException();
1:         }
1:     }
1: 
1:     /**
1:      * Send the ConnectionInfo to the Broker
0:      * 
1:      * @throws JMSException
1:      */
1:     protected void ensureConnectionInfoSent() throws JMSException {
1:         // Can we skip sending the ConnectionInfo packet??
0:         if (isConnectionInfoSentToBroker) {
1:             return;
1:         }
1: 
1:         if (info.getClientId() == null || info.getClientId().trim().length() == 0) {
1:             info.setClientId(clientIdGenerator.generateId());
1:         }
1:         syncSendPacket(info);
1:         
1:         this.isConnectionInfoSentToBroker = true;
0:         // Add a temp destination advisory consumer so that 
0:         // We know what the valid temporary destinations are on the 
1:         // broker without having to do an RPC to the broker.
1:         
0:         ConsumerId consumerId = new ConsumerId(new SessionId(info.getConnectionId(), -1),consumerIdGenerator.getNextSequenceId());
0:         advisoryConsumer = new AdvisoryConsumer(this, consumerId);
1:         
1:     }
1: 
1:     /**
1:      * @return Returns the useAsyncSend.
1:      */
1:     public boolean isUseAsyncSend() {
1:         return useAsyncSend;
1:     }
1: 
1:     /**
0:      * @param useAsyncSend
0:      *            The useAsyncSend to set.
1:      */
1:     public void setUseAsyncSend(boolean useAsyncSend) {
1:         this.useAsyncSend = useAsyncSend;
1:     }
1: 
1:     /**
1:      * Cleans up this connection so that it's state is as if the connection was
1:      * just created. This allows the Resource Adapter to clean up a connection
1:      * so that it can be reused without having to close and recreate the
1:      * connection.
0:      * 
1:      */
1:     public void cleanup() throws JMSException {
1:         
0:         if( advisoryConsumer!=null ) {
0:             advisoryConsumer.dispose();
0:             advisoryConsumer=null;
1:         }
1:         
0:         for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:             ActiveMQSession s = (ActiveMQSession) i.next();
1:             s.dispose();
1:         }
0:         for (Iterator i = this.connectionConsumers.iterator(); i.hasNext();) {
0:             ActiveMQConnectionConsumer c = (ActiveMQConnectionConsumer) i.next();
1:             c.dispose();
1:         }
0:         for (Iterator i = this.inputStreams.iterator(); i.hasNext();) {
0:             ActiveMQInputStream c = (ActiveMQInputStream) i.next();
1:             c.dispose();
1:         }
0:         for (Iterator i = this.outputStreams.iterator(); i.hasNext();) {
0:             ActiveMQOutputStream c = (ActiveMQOutputStream) i.next();
1:             c.dispose();
1:         }
1: 
0:         if( isConnectionInfoSentToBroker ) {
0:             asyncSendPacket(info.createRemoveCommand());
0:             isConnectionInfoSentToBroker = false;
1:         }        
0:         if( userSpecifiedClientID ) {
0:             info.setClientId(null);
0:             userSpecifiedClientID=false;
1:         }
0:         clientIDSet = false;
1: 
0:         started.set(false);
1:     }
1: 
1:     /**
1:      * Changes the associated username/password that is associated with this
1:      * connection. If the connection has been used, you must called cleanup()
1:      * before calling this method.
0:      * 
0:      * @throws IllegalStateException
0:      *             if the connection is in used.
0:      * 
1:      */
1:     public void changeUserInfo(String userName, String password) throws JMSException {
0:         if (isConnectionInfoSentToBroker)
1:             throw new IllegalStateException("changeUserInfo used Connection is not allowed");
1: 
1:         this.info.setUserName(userName);
1:         this.info.setPassword(password);
1:     }
1: 
1:     /**
1:      * @return Returns the resourceManagerId.
1:      * @throws JMSException
1:      */
1:     public String getResourceManagerId() throws JMSException {
1:         waitForBrokerInfo();
0:         if( resourceManagerId==null )
0:             throw new JMSException("Resource manager id could not be determined.");            
0:         return resourceManagerId;
1:     }
1: 
1:     /**
1:      * @return Returns the RedeliveryPolicy.
1:      * @throws JMSException
1:      */
1:     public RedeliveryPolicy getRedeliveryPolicy() throws JMSException {
1:         waitForBrokerInfo();
0:         return redeliveryPolicy;
1:     }
1: 
1:     private void waitForBrokerInfo() throws JMSException {
0:         try {
1:             brokerInfoReceived.await();
0:         } catch (InterruptedException e) {
0:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     // Package protected so that it can be used in unit tests
0:     Transport getTransport() {
1:         return transport;
1:     }
1: 
1:     public void addDispatcher(ConsumerId consumerId, ActiveMQDispatcher dispatcher) {
0:         dispatchers.put(consumerId, dispatcher); 
1:     }
1:     public void removeDispatcher(ConsumerId consumerId) {
0:         dispatchers.remove(consumerId);   
1:     }
1:     
1:     /**
0:      * @param command - the command to consume
1:      */
0:     public void onCommand(Command command) {
1:         if (!closed.get() && command != null) {
0:             if (command.isMessageDispatch()) {
0:                 MessageDispatch md = (MessageDispatch) command;
0:                 ActiveMQDispatcher dispatcher = (ActiveMQDispatcher) dispatchers.get(md.getConsumerId());
0:                 if (dispatcher != null) {
0:                     // Copy in case a embedded broker is dispatching via vm://
0:                     // md.getMessage() == null to signal end of queue browse.
0:                     Message msg = md.getMessage();
0:                     if( msg!=null ) {
0:                         msg = msg.copy();
0:                         msg.setReadOnlyBody(true);
0:                         msg.setReadOnlyProperties(true);
0:                         msg.setRedeliveryCounter(md.getRedeliveryCounter());
0:                         msg.setConnection(this);
0:                         md.setMessage( msg );
1:                     }
0:                     dispatcher.dispatch(md);
1:                 }
0:             } else if ( command.isBrokerInfo() ) {
0:                 BrokerInfo brokerInfo = (BrokerInfo)command;
0:                 resourceManagerId = brokerInfo.getBrokerId().getBrokerId();
0:                 if( redeliveryPolicy == null ) {
0:                     if( brokerInfo.getRedeliveryPolicy()!=null ) {
0:                         redeliveryPolicy = brokerInfo.getRedeliveryPolicy();
1:                     } else {
0:                         redeliveryPolicy = new RedeliveryPolicy();
1:                     }
1:                 }
0:                 brokerInfoReceived.countDown();
1:             }
0:             else if (command instanceof ControlCommand) {
0:                 onControlCommand((ControlCommand) command);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Used for handling async exceptions
0:      * 
1:      * @param error
1:      */
1:     public void onAsyncException(Throwable error) {
0:         if (!closed.get() && !closing.get()) {
1:             if (this.exceptionListener != null) {
0:                 if (!(error instanceof JMSException))
1:                     error = JMSExceptionSupport.create(error);
0:                 this.exceptionListener.onException((JMSException) error);
1:             } else {
0:                 log.warn("Async exception with no exception listener: " + error, error);
1:             }
1:         }
1:     }
1: 
0:     public void onException(IOException error) {
0:         onAsyncException(error);
0:         ServiceSupport.dispose(this.transport);
0:         brokerInfoReceived.countDown();
1:     }
1: 
1:     /**
1:      * Create the DestinationInfo object for the temporary destination.
0:      * 
1:      * @param topic - if its true topic, else queue.
1:      * @return DestinationInfo
1:      * @throws JMSException 
1:      */
1:     protected ActiveMQTempDestination createTempDestination(boolean topic) throws JMSException {
1:         
1:         // Check if Destination info is of temporary type.
1:         ActiveMQTempDestination dest;
0:         if( topic ) {
1:             dest = new ActiveMQTempTopic(info.getConnectionId(), tempDestinationIdGenerator.getNextSequenceId());
1:         } else {
1:             dest = new ActiveMQTempQueue(info.getConnectionId(), tempDestinationIdGenerator.getNextSequenceId());
1:         }
1:         
1:         DestinationInfo info = new DestinationInfo();
1:         info.setConnectionId(this.info.getConnectionId());
1:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
1:         info.setDestination(dest);
1:         syncSendPacket(info);
1:         
1:         dest.setConnection(this);
0:         activeTempDestinations.put(dest,dest);
1:         return dest;
1:     }
1:     
1:     /**
0:      * 
1:      * @param destination
1:      * @throws JMSException
1:      */
1:     public void deleteTempDestination(ActiveMQTempDestination destination) throws JMSException {
1:         
1:         checkClosed();        
1:         activeTempDestinations.remove(destination);
1: 
1:         DestinationInfo info = new DestinationInfo();
1:         info.setConnectionId(this.info.getConnectionId());
1:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:         info.setDestination(destination);
0:         info.setTimeout(1000*5);
1:         syncSendPacket(info);
1:     }
1: 
1: 
1: 
1:     public boolean isDeleted(ActiveMQDestination dest) {
0:         return !activeTempDestinations.contains(dest);
1:     }
1: 
1:     public boolean isCopyMessageOnSend() {
1:         return copyMessageOnSend;
1:     }
1: 
1:     public LongSequenceGenerator getLocalTransactionIdGenerator() {
1:         return localTransactionIdGenerator;
1:     }
1: 
1:     public boolean isUseCompression() {
1:         return useCompression;
1:     }
1: 
1:     public void setUseCompression(boolean useCompression) {
1:         this.useCompression = useCompression;
1:     }    
1: 
1:     public void destroyDestination(ActiveMQDestination destination) throws JMSException {
1:         
1:         checkClosed();
1:         ensureConnectionInfoSent();
1: 
1:         DestinationInfo info = new DestinationInfo();
1:         info.setConnectionId(this.info.getConnectionId());
1:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:         info.setDestination(destination);
0:         info.setTimeout(1000*5);
1:         syncSendPacket(info);
1: 
1:     }
1: 
0:     public boolean isAsyncDispatch() {
0:         return asyncDispatch;
1:     }
1: 
0:     public void setAsyncDispatch(boolean asyncDispatch) {
0:         this.asyncDispatch = asyncDispatch;
1:     }
1: 
1:     public boolean isObjectMessageSerializationDefered() {
1:         return objectMessageSerializationDefered;
1:     }
1: 
1:     public void setObjectMessageSerializationDefered(boolean objectMessageSerializationDefered) {
1:         this.objectMessageSerializationDefered = objectMessageSerializationDefered;
1:     }
1: 
0:     public InputStream createInputStream(Destination dest) throws JMSException {
0:         return createInputStream(dest, null);
1:     }
1: 
0:     public InputStream createInputStream(Destination dest, String messageSelector) throws JMSException {
0:         return createInputStream(dest, messageSelector, false);
1:     }
1: 
0:     public InputStream createInputStream(Destination dest, String messageSelector, boolean noLocal) throws JMSException {
0:         return doCreateInputStream(dest, messageSelector, noLocal, null);
1:     }
1: 
0:     public InputStream createDurableInputStream(Topic dest, String name) throws JMSException {
0:         return createInputStream(dest, null, false);
1:     }
1: 
0:     public InputStream createDurableInputStream(Topic dest, String name, String messageSelector) throws JMSException {
0:         return createDurableInputStream(dest, name, messageSelector, false);
1:     }
1: 
0:     public InputStream createDurableInputStream(Topic dest, String name, String messageSelector, boolean noLocal) throws JMSException {
0:         return doCreateInputStream(dest, messageSelector, noLocal, name);
1:     }
1:     
0:     private InputStream doCreateInputStream(Destination dest, String messageSelector, boolean noLocal, String subName) throws JMSException {
1:         checkClosed();
1:         ensureConnectionInfoSent();
0:         return new ActiveMQInputStream(this, createConsumerId(), ActiveMQDestination.transform(dest), messageSelector, noLocal, subName, prefetchPolicy.getInputStreamPrefetch());
1:     }
1: 
1: 
0:     public OutputStream createOutputStream(Destination dest) throws JMSException {
0:         return createOutputStream(dest, null, ActiveMQMessage.DEFAULT_DELIVERY_MODE, ActiveMQMessage.DEFAULT_PRIORITY, ActiveMQMessage.DEFAULT_TIME_TO_LIVE);
1:     }
1: 
0:     public OutputStream createOutputStream(Destination dest, Map streamProperties, int deliveryMode, int priority, long timeToLive) throws JMSException {
1:         checkClosed();
1:         ensureConnectionInfoSent();
0:         return new ActiveMQOutputStream(this, createProducerId(), ActiveMQDestination.transform(dest), streamProperties, deliveryMode, priority, timeToLive);
1:     }
1: 
1:     /**
1:      * Unsubscribes a durable subscription that has been created by a client.
1:      * <P>
1:      * This method deletes the state being maintained on behalf of the
1:      * subscriber by its provider.
1:      * <P>
1:      * It is erroneous for a client to delete a durable subscription while there
0:      * is an active <CODE>MessageConsumer </CODE> or <CODE>TopicSubscriber</CODE>
0:      * for the subscription, or while a consumed message is part of a pending
0:      * transaction or has not been acknowledged in the session.
0:      * 
0:      * @param name
0:      *            the name used to identify this subscription
1:      * @throws JMSException
0:      *             if the session fails to unsubscribe to the durable
0:      *             subscription due to some internal error.
0:      * @throws InvalidDestinationException
0:      *             if an invalid subscription name is specified.
1:      * @since 1.1
1:      */
0:     public void unsubscribe(String name) throws JMSException {
1:         checkClosed();
1:         RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
1:         rsi.setConnectionId(getConnectionInfo().getConnectionId());
0:         rsi.setSubcriptionName(name);
1:         rsi.setClientId(getConnectionInfo().getClientId());
1:         syncSendPacket(rsi);
1:     }
1: 
1:     /**
0:      * Internal send method optimized:
0:      *  - It does not copy the message
0:      *  - It can only handle ActiveMQ messages.
0:      *  - You can specify if the send is async or sync 
0:      *  - Does not allow you to send /w a transaction.
1:      */
1:     void send(ActiveMQDestination destination, ActiveMQMessage msg, MessageId messageId, int deliveryMode, int priority, long timeToLive, boolean async) throws JMSException {
1:         checkClosed();
1: 
0:         if( destination.isTemporary() && isDeleted(destination) ) {
0:             throw new JMSException("Cannot publish to a deleted Destination: "+destination);
1:         }
1:         
1:         msg.setJMSDestination(destination);
0:         msg.setJMSDeliveryMode(deliveryMode);        
1:         long expiration = 0L;
1: 
1:         if (!isDisableTimeStampsByDefault()) {
1:             long timeStamp = System.currentTimeMillis();
1:             msg.setJMSTimestamp(timeStamp);
1:             if (timeToLive > 0) {
1:                 expiration = timeToLive + timeStamp;
1:             }
1:         }
1: 
1:         msg.setJMSExpiration(expiration);
1:         msg.setJMSPriority(priority);
1:         
0:         msg.setJMSRedelivered(false);        
0:         msg.setMessageId( messageId );
1:         
1:         msg.onSend();
1:         
1:         msg.setProducerId(msg.getMessageId().getProducerId());
1: 
0:         if (log.isDebugEnabled()) {
0:             log.debug("Sending message: " + msg);
1:         }
1: 
0:         if( async) {
1:             asyncSendPacket(msg);
1:         } else {
1:             syncSendPacket(msg);
1:         }
1: 
1:     }
1: 
0:     public void addOutputStream(ActiveMQOutputStream stream) {
0:         outputStreams.add(stream);
1:     }
0:     public void removeOutputStream(ActiveMQOutputStream stream) {
0:         outputStreams.remove(stream);
1:     }
0:     public void addInputStream(ActiveMQInputStream stream) {
0:         inputStreams.add(stream);
1:     }
0:     public void removeInputStream(ActiveMQInputStream stream) {
0:         inputStreams.remove(stream);
1:     }
1: 
0:     protected void onControlCommand(ControlCommand command) {
0:         String text = command.getCommand();
0:         if (text != null) {
0:             if (text.equals("shutdown")) {
0:                 log.info("JVM told to shutdown");
0:                 System.exit(0);
1:             }
1:         }
1:     }
1: 
1:     public void setCopyMessageOnSend(boolean copyMessageOnSend) {
1:         this.copyMessageOnSend = copyMessageOnSend;
1:     }
1:     
1:     public String toString() {
0:         return "ActiveMQConnection {id="+info.getConnectionId()+",clientId"+info.getClientId()+",started="+started.get()+"}";
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:38e5c08
/////////////////////////////////////////////////////////////////////////
commit:e3fcf71
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.RejectedExecutionHandler;
/////////////////////////////////////////////////////////////////////////
1:     private RejectedExecutionHandler rejectedTaskHandler = null;
/////////////////////////////////////////////////////////////////////////
0:         System.out.println(maxThreadPoolSize);
1:                 sessionTaskRunner.setRejectedTaskHandler(rejectedTaskHandler);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public RejectedExecutionHandler getRejectedTaskHandler() {
1:         return rejectedTaskHandler;
1:     }
0: 
1:     public void setRejectedTaskHandler(RejectedExecutionHandler rejectedTaskHandler) {
1:         this.rejectedTaskHandler = rejectedTaskHandler;
1:     }
commit:c33231b
/////////////////////////////////////////////////////////////////////////
1:     public static int DEFAULT_THREAD_POOL_SIZE = 1000;
/////////////////////////////////////////////////////////////////////////
1:     private int maxThreadPoolSize = DEFAULT_THREAD_POOL_SIZE;
0: 
/////////////////////////////////////////////////////////////////////////
1:                 sessionTaskRunner = new TaskRunnerFactory("ActiveMQ Session Task", ThreadPriorities.INBOUND_CLIENT_SESSION, false, 1000, isUseDedicatedTaskRunner(), maxThreadPoolSize);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public int getMaxThreadPoolSize() {
1:         return maxThreadPoolSize;
1:     }
0: 
1:     public void setMaxThreadPoolSize(int maxThreadPoolSize) {
1:         this.maxThreadPoolSize = maxThreadPoolSize;
1:     }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQConnection.class);
commit:4e33fb1
/////////////////////////////////////////////////////////////////////////
0:                     // As TemporaryQueue and TemporaryTopic instances are bound
0:                     // to a connection we should just delete them after the connection
0:                     // is closed to free up memory
0:                     for (Iterator<ActiveMQTempDestination> i = this.activeTempDestinations.values().iterator(); i.hasNext();) {
0:                         ActiveMQTempDestination c = i.next();
0:                         c.delete();
0:                     }
0:                     
commit:9c78797
/////////////////////////////////////////////////////////////////////////
0:         return createInputStream(dest, messageSelector, noLocal,  -1);
0: 
0: 
0:     public InputStream createInputStream(Destination dest, String messageSelector, boolean noLocal, long timeout) throws JMSException {
0:         return doCreateInputStream(dest, messageSelector, noLocal, null, timeout);
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:         return createDurableInputStream(dest, name, messageSelector, noLocal, -1);
0:     public InputStream createDurableInputStream(Topic dest, String name, String messageSelector, boolean noLocal, long timeout) throws JMSException {
0:         return doCreateInputStream(dest, messageSelector, noLocal, name, timeout);
0:     }
0:     
0:     private InputStream doCreateInputStream(Destination dest, String messageSelector, boolean noLocal, String subName, long timeout) throws JMSException {
0:         return new ActiveMQInputStream(this, createConsumerId(), ActiveMQDestination.transform(dest), messageSelector, noLocal, subName, prefetchPolicy.getInputStreamPrefetch(), timeout);
/////////////////////////////////////////////////////////////////////////
0: 
commit:f8ef7ff
/////////////////////////////////////////////////////////////////////////
1:         if (advisoryConsumer != null && !isTransportFailed()) {
/////////////////////////////////////////////////////////////////////////
0: 					try {
0: 						cleanup();
0: 					} catch (JMSException e) {
0: 						LOG.warn("Exception during connection cleanup, " + e, e);
0: 					}
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public IOException getFirstFailureError() {
0: 		return firstFailureError;
0: 	}
commit:2a58f4c
/////////////////////////////////////////////////////////////////////////
1:     public void setAuditDepth(int auditDepth) {
1:         connectionAudit.setAuditDepth(auditDepth);
0: 	}
0: 
1:     public void setAuditMaximumProducerNumber(int auditMaximumProducerNumber) {
1:         connectionAudit.setAuditMaximumProducerNumber(auditMaximumProducerNumber);
0: 	}
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:9287816
/////////////////////////////////////////////////////////////////////////
1:                 //Don't make these daemon threads - see https://issues.apache.org/jira/browse/AMQ-796
1:                 //thread.setDaemon(true);
commit:da7f996
/////////////////////////////////////////////////////////////////////////
0:                         //dispose of transport for security exceptions
0:                         if (er.getException() instanceof SecurityException){
0:                             Transport t = this.transport;
0:                             if (null != t){
0:                                 ServiceSupport.dispose(t);
0:                             }
0:                             if(jmsEx !=null) {
0:                                 throw jmsEx;
0:                             }
/////////////////////////////////////////////////////////////////////////
0:         Scheduler s = this.scheduler;
0:         if (s != null){
0:             s.stop();
/////////////////////////////////////////////////////////////////////////
commit:3a71f8e
/////////////////////////////////////////////////////////////////////////
0:                         //dispose of transport
0:                         Transport t = this.transport;
0:                         if (null != t){
0:                             ServiceSupport.dispose(t);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:     public void finalize() throws Throwable{
0:         if (scheduler != null){
0:             scheduler.stop();
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             if ("shutdown".equals(text)) {
0:             if (false && "close".equals(text)){
0:                 LOG.error("Broker " + getBrokerInfo() + "shutdown connection");
0:                 try {
0:                     close();
0:                 } catch (JMSException e) {
0:                 }
0:             }
commit:c14dc3a
/////////////////////////////////////////////////////////////////////////
0:     private boolean messagePrioritySupported=true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the messagePrioritySupported
1:      */
1:     public boolean isMessagePrioritySupported() {
1:         return this.messagePrioritySupported;
0:     }
0: 
1:     /**
1:      * @param messagePrioritySupported the messagePrioritySupported to set
1:      */
1:     public void setMessagePrioritySupported(boolean messagePrioritySupported) {
1:         this.messagePrioritySupported = messagePrioritySupported;
0:     }
commit:794e62f
/////////////////////////////////////////////////////////////////////////
1:     private boolean checkForDuplicates = true;
/////////////////////////////////////////////////////////////////////////
1:         return checkForDuplicates && connectionAudit.isDuplicate(dispatcher, message);
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * @return the checkForDuplicates
1:      */
1:     public boolean isCheckForDuplicates() {
1:         return this.checkForDuplicates;
0:     }
0: 
1:     /**
1:      * @param checkForDuplicates the checkForDuplicates to set
1:      */
1:     public void setCheckForDuplicates(boolean checkForDuplicates) {
1:         this.checkForDuplicates = checkForDuplicates;
0:     }
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
1:     private final ThreadPoolExecutor executor;
/////////////////////////////////////////////////////////////////////////
0:     private final Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
1:         executor = new ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new ThreadFactory() {
1:                 Thread thread = new Thread(r, "ActiveMQ Connection Executor: " + transport);
0:         String uniqueId = CONNECTION_ID_GENERATOR.generateId();
1:         this.info = new ConnectionInfo(new ConnectionId(uniqueId));
/////////////////////////////////////////////////////////////////////////
0:         this.scheduler = new Scheduler("ActiveMQConnection["+uniqueId+"] Scheduler");
0:         this.scheduler.start();
/////////////////////////////////////////////////////////////////////////
0:                     if (this.scheduler != null) {
0:                         try {
0:                             this.scheduler.stop();
0:                         } catch (Exception e) {
1:                             JMSException ex =  JMSExceptionSupport.create(e);
1:                             throw ex;
0:                         }
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                 if (executor != null){
0:                     executor.shutdown();
/////////////////////////////////////////////////////////////////////////
1:                         executor.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:                 executor.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:                 executor.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0: 			executor.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected Scheduler getScheduler() {
0:         return this.scheduler;
0:     }
0:     
1:     protected ThreadPoolExecutor getExecutor() {
1:         return this.executor;
0:     }
commit:de04214
/////////////////////////////////////////////////////////////////////////
0:     protected volatile CountDownLatch transportInterruptionProcessingComplete;
/////////////////////////////////////////////////////////////////////////
0:         this.transportInterruptionProcessingComplete = new CountDownLatch(dispatchers.size() - (advisoryConsumer != null ? 1:0));
/////////////////////////////////////////////////////////////////////////
0: 	    CountDownLatch cdl = this.transportInterruptionProcessingComplete;
0: 	    if (cdl != null) {
0:             if (!closed.get() && !transportFailed.get() && cdl.getCount()>0) {
0:                 LOG.warn("dispatch paused, waiting for outstanding dispatch interruption processing (" + cdl.getCount() + ") to complete..");
0:                 cdl.await(10, TimeUnit.SECONDS);
0: 	protected void transportInterruptionProcessingComplete() {
0: 	    CountDownLatch cdl = this.transportInterruptionProcessingComplete;
0: 	    if (cdl != null) {
0: 	        cdl.countDown();
/////////////////////////////////////////////////////////////////////////
0:         CountDownLatch cdl = this.transportInterruptionProcessingComplete;
0:         if (cdl.getCount()==0) {
0:             this.transportInterruptionProcessingComplete = null;
0: 
0:             FailoverTransport failoverTransport = transport.narrow(FailoverTransport.class);
0:             if (failoverTransport != null) {
0:                 failoverTransport.connectionInterruptProcessingComplete(this.getConnectionInfo().getConnectionId());
0:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("notified failover transport (" + failoverTransport
1:                             + ") of interruption completion for: " + this.getConnectionInfo().getConnectionId());
0:                 }
0: 
commit:f392884
/////////////////////////////////////////////////////////////////////////
1:         this.info.setFaultTolerant(transport.isFaultTolerant());
commit:204f91f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidDestinationException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.DestinationSource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicInteger protocolVersion = new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
1:     private final long timeCreated;
1:     private final ConnectionAudit connectionAudit = new ConnectionAudit();
/////////////////////////////////////////////////////////////////////////
1:         DestinationInfo destInfo = new DestinationInfo();
1:         destInfo.setConnectionId(this.info.getConnectionId());
1:         destInfo.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
1:         destInfo.setDestination(destination);
1:         destInfo.setTimeout(0);
1:         syncSendPacket(destInfo);
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:f570349
/////////////////////////////////////////////////////////////////////////
0:         if(!transacted && acknowledgeMode==Session.SESSION_TRANSACTED) {
1:            throw new JMSException("acknowledgeMode SESSION_TRANSACTED cannot be used for an non-transacted Session");
0:         }
commit:1555260
/////////////////////////////////////////////////////////////////////////
1:     private final Object ensureConnectionInfoSentMutex = new Object();
/////////////////////////////////////////////////////////////////////////
1:             synchronized(sessions) {
0:                 for (Iterator<ActiveMQSession> i = sessions.iterator(); i.hasNext();) {
0:                     ActiveMQSession s = i.next();
0:                     s.stop();
0:                 }
/////////////////////////////////////////////////////////////////////////
1:             if (!closed.get() && !transportFailed.get()) {
0:                 stop();
0:             }
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 if (asyncConnectionThread != null){
0:                     asyncConnectionThread.shutdown();
0:                 }
0:             }catch(Throwable e) {
0:                 LOG.error("Error shutting down thread pool " + e,e);
0:             }
/////////////////////////////////////////////////////////////////////////
0:                         if (isClosed()||closing.get()) {
1:                             LOG.debug("Received an exception but connection is closing");
0:                         }
/////////////////////////////////////////////////////////////////////////
0:     protected void ensureConnectionInfoSent() throws JMSException {
1:         synchronized(this.ensureConnectionInfoSentMutex) {
0:             // Can we skip sending the ConnectionInfo packet??
1:             if (isConnectionInfoSentToBroker || closed.get()) {
0:                 return;
0:             }
0:     
0:             if (info.getClientId() == null || info.getClientId().trim().length() == 0) {
0:                 info.setClientId(clientIdGenerator.generateId());
0:             }
0:             syncSendPacket(info);
0:     
0:             this.isConnectionInfoSentToBroker = true;
0:             // Add a temp destination advisory consumer so that
0:             // We know what the valid temporary destinations are on the
0:             // broker without having to do an RPC to the broker.
0:     
0:             ConsumerId consumerId = new ConsumerId(new SessionId(info.getConnectionId(), -1), consumerIdGenerator.getNextSequenceId());
0:             if (watchTopicAdvisories) {
0:                 advisoryConsumer = new AdvisoryConsumer(this, consumerId);
0:             }
commit:73edcbc
/////////////////////////////////////////////////////////////////////////
1:                         JMSException jmsEx = null;
0:                          jmsEx = JMSExceptionSupport.create(er.getException());
0:                         if(jmsEx !=null) {
0:                             throw jmsEx;
0:                         }
commit:b52624e
/////////////////////////////////////////////////////////////////////////
0:                             System.err.println(er.getException());
1:                             LOG.error("Caught an exception trying to create a JMSException for " +er.getException(),e);
commit:6f69f19
/////////////////////////////////////////////////////////////////////////
0:                         try {
0:                         }catch(Throwable e) {
0:                             LOG.error("Caught an exception trying to create a JMSException",e);
0:                         }
commit:0acf545
/////////////////////////////////////////////////////////////////////////
1:     private ClientInternalExceptionListener clientInternalExceptionListener;
/////////////////////////////////////////////////////////////////////////
1:      *         null, if no <CODE>ExceptionListener</CODE> is associated with
/////////////////////////////////////////////////////////////////////////
1:      * Gets the <code>ClientInternalExceptionListener</code> object for this connection.
1:      * Not every <CODE>ActiveMQConnectionn</CODE> has a <CODE>ClientInternalExceptionListener</CODE>
1:      * associated with it.
0:      * 
1:      * @return the listener or <code>null</code> if no listener is registered with the connection.
1:      */
0:     public ClientInternalExceptionListener getClientInternalExceptionListener()
0:     {
1:         return clientInternalExceptionListener;
0:     }
0: 
1:     /**
1:      * Sets a client internal exception listener for this connection.
1:      * The connection will notify the listener, if one has been registered, of exceptions thrown by container components
1:      * (e.g. an EJB container in case of Message Driven Beans) during asynchronous processing of a message.
1:      * It does this by calling the listener's <code>onException()</code> method passing it a <code>Throwable</code>
0:      * describing the problem.
0:      * 
1:      * @param listener the exception listener
1:      */
0:     public void setClientInternalExceptionListener(ClientInternalExceptionListener listener)
0:     {
1:         this.clientInternalExceptionListener = listener;
0:     }
0:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:                 onClientInternalException(e);
/////////////////////////////////////////////////////////////////////////
1:      * Handles async client internal exceptions.
1:      * A client internal exception is usually one that has been thrown
0:      * by a container runtie component during asynchronous processing of a
1:      * message that does not affect the connection itself.
1:      * This method notifies the <code>ClientInternalExceptionListener</code> by invoking
1:      * its <code>onException</code> method, if one has been registered with this connection.
0:      * 
1:      * @param error the exception that the problem
1:      */
1:     public void onClientInternalException(final Throwable error) {
1:         if ( !closed.get() && !closing.get() ) {
1:             if ( this.clientInternalExceptionListener != null ) {
0:                 asyncConnectionThread.execute(new Runnable() {
0:                     public void run() {
1:                         ActiveMQConnection.this.clientInternalExceptionListener.onException(error);
0:                     }
0:                 });
0:             } else {
0:                 LOG.debug("Async client internal exception occurred with no exception listener registered: " 
1:                         + error, error);
0:             }
0:         }
0:     }
1:     /**
commit:4ecc89e
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo consumerInfo = new ConsumerInfo(consumerId);
1:         consumerInfo.setDestination(ActiveMQMessageTransformation.transformDestination(destination));
1:         consumerInfo.setSelector(messageSelector);
1:         consumerInfo.setPrefetchSize(maxMessages);
1:         consumerInfo.setNoLocal(noLocal);
1:         consumerInfo.setDispatchAsync(isDispatchAsync());
1:         if (consumerInfo.getDestination().getOptions() != null) {
0:             Map<String, String> options = new HashMap<String, String>(consumerInfo.getDestination().getOptions());
1:             IntrospectionSupport.setProperties(consumerInfo, options, "consumer.");
1:         return new ActiveMQConnectionConsumer(this, sessionPool, consumerInfo);
commit:d8b5d5c
/////////////////////////////////////////////////////////////////////////
1:     private boolean sendAcksAsync=true;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the sendAcksAsync
1:      */
1:     public boolean isSendAcksAsync() {
1:         return sendAcksAsync;
0:     }
0: 
1:     /**
1:      * @param sendAcksAsync the sendAcksAsync to set
1:      */
1:     public void setSendAcksAsync(boolean sendAcksAsync) {
1:         this.sendAcksAsync = sendAcksAsync;
0:     }
commit:114a923
/////////////////////////////////////////////////////////////////////////
1:     private int sendTimeout =0;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
0:      * @return the sendTimeout
1:      */
1:     public int getSendTimeout() {
1:         return sendTimeout;
0:     }
0: 
1:     /**
0:      * @param sendTimeout the sendTimeout to set
1:      */
1:     public void setSendTimeout(int sendTimeout) {
1:         this.sendTimeout = sendTimeout;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:62fb85e
/////////////////////////////////////////////////////////////////////////
1:     protected boolean dispatchAsync=true;
/////////////////////////////////////////////////////////////////////////
0:             ? Session.AUTO_ACKNOWLEDGE : acknowledgeMode), isDispatchAsync(), isAlwaysSessionAsync());
/////////////////////////////////////////////////////////////////////////
1:         info.setDispatchAsync(isDispatchAsync());
/////////////////////////////////////////////////////////////////////////
0:         info.setDispatchAsync(isDispatchAsync());
commit:b34f730
/////////////////////////////////////////////////////////////////////////
1:     public Transport getTransport() {
commit:462921a
/////////////////////////////////////////////////////////////////////////
0:                 Thread thread = new Thread(r, "ActiveMQ Connection Worker: " + transport);
commit:3318a9f
/////////////////////////////////////////////////////////////////////////
0:         if (isClosed()) {
commit:08841bb
/////////////////////////////////////////////////////////////////////////
0:                     
0:                     if (asyncConnectionThread != null){
0:                     	asyncConnectionThread.shutdown();
0:                     }
/////////////////////////////////////////////////////////////////////////
0: 		onAsyncException(error);
0: 		if (!closing.get() && !closed.get()) {
0: 			asyncConnectionThread.execute(new Runnable() {
0: 				public void run() {
0: 					transportFailed(error);
0: 					ServiceSupport.dispose(ActiveMQConnection.this.transport);
0: 					brokerInfoReceived.countDown();
0: 					for (Iterator<TransportListener> iter = transportListeners
0: 							.iterator(); iter.hasNext();) {
0: 						TransportListener listener = iter.next();
0: 						listener.onException(error);
0: 					}
0: 				}
0: 			});
0: 		}
0: 	}
commit:cfdc5e3
/////////////////////////////////////////////////////////////////////////
0: 					public Response processProducerAck(ProducerAck pa) throws Exception{
0:                         if(pa!=null&&pa.getProducerId()!=null){
0:                             ActiveMQMessageProducer producer=producers.get(pa.getProducerId());
0:                             if(producer!=null){
0:                                 producer.onProducerAck(pa);
0:                             }
0:                         }
0:                         return null;
0:                     }
commit:cbaa58b
/////////////////////////////////////////////////////////////////////////
0:     private ConnectionAudit connectionAudit = new ConnectionAudit();
/////////////////////////////////////////////////////////////////////////
1:         this.connectionAudit.setCheckForDuplicates(transport.isFaultTolerant());
/////////////////////////////////////////////////////////////////////////
1:         this.removeDispatcher(session);
/////////////////////////////////////////////////////////////////////////
1:         this.removeDispatcher(connectionConsumer);
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void removeDispatcher(ActiveMQDispatcher dispatcher){
0:        connectionAudit.removeDispatcher(dispatcher);
0:     }
0: 
0:     protected boolean isDuplicate(ActiveMQDispatcher dispatcher,Message message){
0:        return connectionAudit.isDuplicate(dispatcher,message);
0:     }
0: 
0:     protected void rollbackDuplicate(ActiveMQDispatcher dispatcher,Message message){
0:        connectionAudit.rollbackDuplicate(dispatcher,message);
0:     }
commit:f95552b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      /**
0:      * @return Returns the useAsyncSend.
1:      */
0:     public boolean isUseAsyncSend() {
0:         return useAsyncSend;
0:     }
0:   
commit:c0af1f5
/////////////////////////////////////////////////////////////////////////
0: 		                onWireFormatInfo((WireFormatInfo) command);
commit:e8b12e4
/////////////////////////////////////////////////////////////////////////
0:                         brokerInfo=info;
commit:4e2acd4
/////////////////////////////////////////////////////////////////////////
1:     private boolean alwaysSyncSend;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return true if always sync send messages
1:      */
0:     public boolean isAlwaysSyncSend(){
1:         return this.alwaysSyncSend;
0:     }
0: 
1:     /**
1:      * Set true if always require messages to be sync sent
1:      * @param alwaysSyncSend
1:      */
0:     public void setAlwaysSyncSend(boolean alwaysSyncSend){
0:         this.alwaysSyncSend=alwaysSyncSend;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     }    
commit:2e0f676
/////////////////////////////////////////////////////////////////////////
0:             IntrospectionSupport.setProperties(info, options, "consumer.");
commit:526cb5b
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the statsEnabled
1:      */
0:     public boolean isStatsEnabled(){
1:         return this.stats.isEnabled();
0:     }
0: 
0:     
1:     /**
1:      * @param statsEnabled the statsEnabled to set
1:      */
0:     public void setStatsEnabled(boolean statsEnabled){
1:         this.stats.setEnabled(statsEnabled);
0:     }
commit:c250fa5
/////////////////////////////////////////////////////////////////////////
0:         this.asyncDispatch = asyncDispatch;
commit:7a386be
/////////////////////////////////////////////////////////////////////////
0:     private boolean optimizeAcknowledge = false;
commit:ef0734b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConnectionControl;
1: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.failover.FailoverTransport;
/////////////////////////////////////////////////////////////////////////
1:         this.info.setManageable(true);
/////////////////////////////////////////////////////////////////////////
0:         advisoryConsumer = new AdvisoryConsumer(this, consumerId);        
/////////////////////////////////////////////////////////////////////////
0:                 this.optimizeAcknowledge &= !this.brokerInfo.isFaultTolerantConfiguration();
0:             }else if (command instanceof ConnectionControl){
0:                 onConnectionControl((ConnectionControl) command);
0:             }else if (command instanceof ConsumerControl){
0:                 onConsumerControl((ConsumerControl) command);
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:             ActiveMQSession s = (ActiveMQSession) i.next();
0:             s.clearMessagesInProgress();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:             ActiveMQSession s = (ActiveMQSession) i.next();
0:             s.deliverAcks();
0:         }
/////////////////////////////////////////////////////////////////////////
0:     protected void onConnectionControl(ConnectionControl command){
0:         if (command.isFaultTolerant()){
1:             this.optimizeAcknowledge = false;
0:             for(Iterator i=this.sessions.iterator();i.hasNext();){
0:                 ActiveMQSession s=(ActiveMQSession) i.next();
1:                 s.setOptimizeAcknowledge(false);
0:             }
0:         }
0:     }
0:     
0:     protected void onConsumerControl(ConsumerControl command){
0:         if(command.isClose()){
0:             for(Iterator i=this.sessions.iterator();i.hasNext();){
0:                 ActiveMQSession s=(ActiveMQSession) i.next();
0:                 s.close(command.getConsumerId());
0:             }
0:         }else{
0:             for(Iterator i=this.sessions.iterator();i.hasNext();){
0:                 ActiveMQSession s=(ActiveMQSession) i.next();
0:                 s.setPrefetchSize(command.getConsumerId(),command.getPrefetch());
0:             }
0:         }
0:     }
0:     
commit:d964145
/////////////////////////////////////////////////////////////////////////
0:     protected boolean asyncDispatch = false;
0:     protected boolean alwaysSessionAsync=true;
0:     private boolean optimizeAcknowledge = true;
/////////////////////////////////////////////////////////////////////////
0:     public Session createSession(boolean transacted,int acknowledgeMode) throws JMSException{
0:         boolean doSessionAsync=alwaysSessionAsync||sessions.size()>0||transacted
0:                         ||acknowledgeMode==Session.CLIENT_ACKNOWLEDGE;
0:         return new ActiveMQSession(this,getNextSessionId(),(transacted?Session.SESSION_TRANSACTED
0:                         :(acknowledgeMode==Session.SESSION_TRANSACTED?Session.AUTO_ACKNOWLEDGE:acknowledgeMode)),
0:                         asyncDispatch,alwaysSessionAsync);
1:      * @return sessionId
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return Returns the alwaysSessionAsync.
1:      */
0:     public boolean isAlwaysSessionAsync(){
1:         return alwaysSessionAsync;
0:     }
0: 
0: 
1:     /**
0:      * @param alwaysSessionAsync The alwaysSessionAsync to set.
1:      */
0:     public void setAlwaysSessionAsync(boolean alwaysSessionAsync){
0:         this.alwaysSessionAsync=alwaysSessionAsync;
0:     }
0: 
1:     /**
1:      * @return Returns the optimizeAcknowledge.
1:      */
0:     public boolean isOptimizeAcknowledge(){
1:         return optimizeAcknowledge;
0:     }
0: 
0: 
1:     /**
1:      * @param optimizeAcknowledge The optimizeAcknowledge to set.
1:      */
0:     public void setOptimizeAcknowledge(boolean optimizeAcknowledge){
0:         this.optimizeAcknowledge=optimizeAcknowledge;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         //this.asyncDispatch = asyncDispatch;
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     
commit:5fe0a4c
/////////////////////////////////////////////////////////////////////////
1:     private int closeTimeout = 15000;
/////////////////////////////////////////////////////////////////////////
0:                     syncSendPacket(info.createRemoveCommand(),closeTimeout);
/////////////////////////////////////////////////////////////////////////
1:      * @return Returns the closeTimeout.
1:      */
0:     public int getCloseTimeout(){
1:         return closeTimeout;
0:     }
0: 
0: 
1:     /**
0:      * @param closeTimeout The closeTimeout to set.
1:      */
0:     public void setCloseTimeout(int closeTimeout){
0:         this.closeTimeout=closeTimeout;
0:     }
0: 
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Send a packet through a Connection - for internal use only
0:      * 
1:      * @param command
0:      * @return
0:      * @throws JMSException
1:      */
0:     public Response syncSendPacket(Command command, int timeout) throws JMSException {
0:         if (isClosed()) {
0:             throw new ConnectionClosedException();
0:         } else {
0: 
0:             if (command.isMessage() && flowControlSleepTime > 0) {
0:                 try {
0:                     Thread.sleep(flowControlSleepTime);
0:                 } catch (InterruptedException e) {
0:                 }
0:             }
0: 
0:             try {
0:                 Response response = this.transport.request(command,timeout);
0:                 if (response.isException()) {
0:                     ExceptionResponse er = (ExceptionResponse) response;
0:                     if (er.getException() instanceof JMSException)
0:                         throw (JMSException) er.getException();
0:                     else
0:                         throw JMSExceptionSupport.create(er.getException());
0:                 }
0:                 return response;
0:             } catch (IOException e) {
0:                 throw JMSExceptionSupport.create(e);
0:             }
0:         }
0:     }
commit:9c5680c
/////////////////////////////////////////////////////////////////////////
0:         if(isConnectionInfoSentToBroker){
0:             if(!transportFailed.get()){
0:                 asyncSendPacket(info.createRemoveCommand());
0:             }
0:             isConnectionInfoSentToBroker=false;
commit:f915da5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.DefaultTransportListener;
/////////////////////////////////////////////////////////////////////////
0: public class ActiveMQConnection extends DefaultTransportListener implements Connection, TopicConnection, QueueConnection, StatsCapable, Closeable,  StreamConnection {
commit:36a2bdc
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean transportFailed = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
0:      * or the Transport has failed
0:      * 
0:      * @throws JMSException
1:      */
1:     protected synchronized void checkClosedOrFailed() throws JMSException {
0:         checkClosed();
0:         if (transportFailed.get()){
0:             throw new ConnectionFailedException();
0:         }
0:     }
0:     
1:     /**
0:      * simply throws an exception if the Connection is already closed
/////////////////////////////////////////////////////////////////////////
0:             transportFailed(error);
0:     
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();        
/////////////////////////////////////////////////////////////////////////
1:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
0:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
0:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
0:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
0:         checkClosedOrFailed();
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void transportFailed(Throwable error){
1:         transportFailed.set(true);
0:         try{
0:             cleanup();
0:         }catch(JMSException e){
0:            log.warn("Cleanup failed",e);
0:         }
0:         
0:     }
author:Jonathan Anstey
-------------------------------------------------------------------------------
commit:2f4d11f
/////////////////////////////////////////////////////////////////////////
1:                 // Only delete this temp destination if it was created from this connection. The connection used
0:                 // for the advisory consumer may also have a reference to this temp destination. 
0:                 ActiveMQTempDestination dest = entry.getValue();                             
1:                 String thisConnectionId = (info.getConnectionId() == null) ? "" : info.getConnectionId().toString();
1:                 if (dest.getConnectionId() != null && dest.getConnectionId().equals(thisConnectionId)) {
0:                     this.deleteTempDestination(entry.getValue());
0:                 }
author:David Jencks
-------------------------------------------------------------------------------
commit:ab438f6
/////////////////////////////////////////////////////////////////////////
0:         if(!transacted) {
0:             if (acknowledgeMode==Session.SESSION_TRANSACTED) {
0:                 throw new JMSException("acknowledgeMode SESSION_TRANSACTED cannot be used for an non-transacted Session");
1:             } else if (acknowledgeMode < Session.SESSION_TRANSACTED || acknowledgeMode > ActiveMQSession.MAX_ACK_CONSTANT) {
1:                 throw new JMSException("invalid acknowledgeMode: " + acknowledgeMode + ". Valid values are Session.AUTO_ACKNOWLEDGE (1), " +
1:                         "Session.CLIENT_ACKNOWLEDGE (2), Session.DUPS_OK_ACKNOWLEDGE (3), ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE (4) or for transacted sessions Session.SESSION_TRANSACTED (0)");
0:             }
commit:e08cc35
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidDestinationException;
/////////////////////////////////////////////////////////////////////////
1:             //TODO shouldn't this check be on userSpecifiedClientID rather than the value of clientID?
0:             syncSendPacket(info.copy());
/////////////////////////////////////////////////////////////////////////
1:     public void unsubscribe(String name) throws InvalidDestinationException, JMSException {
author:James Strachan
-------------------------------------------------------------------------------
commit:53756f3
/////////////////////////////////////////////////////////////////////////
0: public class ActiveMQConnection implements Connection, TopicConnection, QueueConnection, StatsCapable, Closeable, StreamConnection, TransportListener, EnhancedConnection {
commit:f6efc56
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.advisory.DestinationSource;
/////////////////////////////////////////////////////////////////////////
1:     private DestinationSource destinationSource;
/////////////////////////////////////////////////////////////////////////
1:                     if (destinationSource != null) {
1:                         destinationSource.stop();
1:                         destinationSource = null;
0:                     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the {@link DestinationSource} object which can be used to listen to destinations
1:      * being created or destroyed or to enquire about the current destinations available on the broker
0:      *
1:      * @return a lazily created destination source
0:      * @throws JMSException
1:      */
1:     public DestinationSource getDestinationSource() throws JMSException {
1:         if (destinationSource == null) {
1:             destinationSource = new DestinationSource(this);
1:             destinationSource.start();
0:         }
1:         return destinationSource;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:3d862f0
/////////////////////////////////////////////////////////////////////////
1:     private boolean exclusiveConsumer;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isExclusiveConsumer() {
1:         return exclusiveConsumer;
0:     }
0: 
1:     /**
0:      * Enables or disables whether or not queue consumers should be exclusive or not
0:      * for example to preserve ordering when not using
0:      * <a href="http://activemq.apache.org/message-groups.html">Message Groups</a>
0:      *
1:      * @param exclusiveConsumer
1:      */
1:     public void setExclusiveConsumer(boolean exclusiveConsumer) {
1:         this.exclusiveConsumer = exclusiveConsumer;
0:     }
/////////////////////////////////////////////////////////////////////////
commit:a92fb28
/////////////////////////////////////////////////////////////////////////
0:      * if the connection is not properly started via {@link #start()} and a message is received by a consumer.
0:      * 
0:      * It is a very common gotcha to forget to
commit:72cee90
/////////////////////////////////////////////////////////////////////////
0:      * Enables the timeout from a connection creation to when a warning is generated
commit:9d53c53
/////////////////////////////////////////////////////////////////////////
0:      * Enables the timemout from a connection creation to when a warning is generated
commit:78cf4b1
/////////////////////////////////////////////////////////////////////////
1:     private long warnAboutUnstartedConnectionTimeout = 500L;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:     private long timeCreated;
/////////////////////////////////////////////////////////////////////////
1:         this.timeCreated = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
1:     public long getWarnAboutUnstartedConnectionTimeout() {
1:         return warnAboutUnstartedConnectionTimeout;
0:     }
0: 
1:     /**
0:      * Enables the timemout from a session creation to when a warning is generated
0:      * if the connection is not properly started via {@link #start()}. It is a very
0:      * common gotcha to forget to
0:      * <a href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start the connection</a>
0:      * so this option makes the default case to create a warning if the user forgets.
0:      * To disable the warning just set the value to < 0 (say -1).
1:      */
1:     public void setWarnAboutUnstartedConnectionTimeout(long warnAboutUnstartedConnectionTimeout) {
1:         this.warnAboutUnstartedConnectionTimeout = warnAboutUnstartedConnectionTimeout;
0:     }
0: 
1:     /**
1:      * Returns the time this connection was created
1:      */
1:     public long getTimeCreated() {
1:         return timeCreated;
0:     }
commit:1807dbb
/////////////////////////////////////////////////////////////////////////
1:         if (blobTransferPolicy == null) {
1:             blobTransferPolicy = createBlobTransferPolicy();
0:         }
/////////////////////////////////////////////////////////////////////////
0:     }
0: 
1:     protected BlobTransferPolicy createBlobTransferPolicy() {
1:         return new BlobTransferPolicy();
0:     }
commit:3013c20
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested
/////////////////////////////////////////////////////////////////////////
0:      * href="http://activemq.apache.org/async-sends.html">Async Sends</a>
/////////////////////////////////////////////////////////////////////////
1:      * href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched
commit:05a8cba
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.blob.BlobTransferPolicy;
/////////////////////////////////////////////////////////////////////////
1:     private BlobTransferPolicy blobTransferPolicy;
/////////////////////////////////////////////////////////////////////////
0: 
1:     public BlobTransferPolicy getBlobTransferPolicy() {
1:         return blobTransferPolicy;
0:     }
0: 
1:     /**
0:      * Sets the policy used to describe how out-of-band BLOBs (Binary Large OBjects)
0:      * are transferred from producers to brokers to consumers
1:      */
1:     public void setBlobTransferPolicy(BlobTransferPolicy blobTransferPolicy) {
1:         this.blobTransferPolicy = blobTransferPolicy;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 getBlobTransferPolicy().setBrokerUploadUrl(brokerInfo.getBrokerUploadUrl());
commit:86faaef
/////////////////////////////////////////////////////////////////////////
1:     private MessageTransformer transformer;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public MessageTransformer getTransformer() {
1:         return transformer;
0:     }
0: 
1:     /**
0:      * Sets the transformer used to transform messages before they are sent on to the JMS bus
0:      * or when they are received from the bus but before they are delivered to the JMS client
1:      */
1:     public void setTransformer(MessageTransformer transformer) {
1:         this.transformer = transformer;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:      * @param o - the command to consume
commit:7249191
/////////////////////////////////////////////////////////////////////////
0:      * @throws Exception
commit:6cf2169
/////////////////////////////////////////////////////////////////////////
0:     private TaskRunnerFactory sessionTaskRunner = new TaskRunnerFactory("ActiveMQ Session Task",ThreadPriorities.INBOUND_CLIENT_SESSION,true,1000);
/////////////////////////////////////////////////////////////////////////
0:                     // TODO if we move the TaskRunnerFactory to the connection factory
0:                     // then we may need to call
0:                     sessionTaskRunner.shutdown();
/////////////////////////////////////////////////////////////////////////
1:     public TaskRunnerFactory getSessionTaskRunner() {
1:         return sessionTaskRunner;
0:     }
0: 
1:     public void setSessionTaskRunner(TaskRunnerFactory sessionTaskRunner) {
1:         this.sessionTaskRunner = sessionTaskRunner;
0:     }
0: 
0:     
commit:7339c6e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final IdGenerator clientIdGenerator;
0:     private final JMSStatsImpl factoryStats;
0:     private final JMSConnectionStatsImpl stats;
0:     
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQConnection(final Transport transport, IdGenerator clientIdGenerator, JMSStatsImpl factoryStats)
0:         this.transport = transport;
1:         this.clientIdGenerator = clientIdGenerator;
0:         this.factoryStats = factoryStats;
0:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
commit:ea35563
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             // If we were running, lets stop first.
0:             stop();
0:             synchronized (this) {
0:                 if (!closed.get()) {
0:                     closing.set(true);
0:                     if (advisoryConsumer != null) {
0:                         advisoryConsumer.dispose();
0:                         advisoryConsumer = null;
0:                     }
0:                     for (Iterator i = this.sessions.iterator(); i.hasNext();) {
0:                         ActiveMQSession s = (ActiveMQSession) i.next();
0:                         s.dispose();
0:                     }
0:                     for (Iterator i = this.connectionConsumers.iterator(); i.hasNext();) {
0:                         ActiveMQConnectionConsumer c = (ActiveMQConnectionConsumer) i.next();
0:                         c.dispose();
0:                     }
0:                     for (Iterator i = this.inputStreams.iterator(); i.hasNext();) {
0:                         ActiveMQInputStream c = (ActiveMQInputStream) i.next();
0:                         c.dispose();
0:                     }
0:                     for (Iterator i = this.outputStreams.iterator(); i.hasNext();) {
0:                         ActiveMQOutputStream c = (ActiveMQOutputStream) i.next();
0:                         c.dispose();
0:                     }
0:                     if (isConnectionInfoSentToBroker) {
0:                         syncSendPacket(info.createRemoveCommand(), closeTimeout);
0:                     }
0:                     asyncSendPacket(new ShutdownInfo());
0:                     ServiceSupport.dispose(this.transport);
0:                     started.set(false);
0: 
0:                     // TODO : ActiveMQConnectionFactory.onConnectionClose() not
0:                     // yet implemented.
0:                     // factory.onConnectionClose(this);
0: 
0:                     closed.set(true);
0:                     closing.set(false);
0:                 }
0:         finally {
1:             factoryStats.removeConnection(this);
0:         }
commit:4b08ea5
/////////////////////////////////////////////////////////////////////////
1:      * Sets whether or not timestamps on messages should be disabled or not. If
1:      * you disable them it adds a small performance boost.
/////////////////////////////////////////////////////////////////////////
1:      * If this flag is set then an larger prefetch limit is used - only
1:      * applicable for durable topic subscribers.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Enables/disables whether or not Message properties and MapMessage entries
1:      * support <a
0:      * href="http://incubator.apache.org/activemq/structured-message-properties-and-mapmessages.html">Nested
1:      * Structures</a> of Map and List objects
/////////////////////////////////////////////////////////////////////////
1:      * Forces the use of <a
0:      * href="http://incubator.apache.org/activemq/async-sends.html">Async Sends</a>
0:      * which adds a massive performance boost; but means that the send() method
0:      * will return immediately whether the message has been sent or not which
0:      * could lead to message loss.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * When an object is set on an ObjectMessage, the JMS spec requires the
1:      * object to be serialized by that set method. Enabling this flag causes the
1:      * object to not get serialized. The object may subsequently get serialized
1:      * if the message needs to be sent over a socket or stored to disk.
1:      */
/////////////////////////////////////////////////////////////////////////
commit:480433b
/////////////////////////////////////////////////////////////////////////
0:     protected boolean dispatchAsync = false;
/////////////////////////////////////////////////////////////////////////
0:                         dispatchAsync,alwaysSessionAsync);
/////////////////////////////////////////////////////////////////////////
0:         info.setDispatchAsync(dispatchAsync);
/////////////////////////////////////////////////////////////////////////
1:      * Sets the <a
0:      * href="http://incubator.apache.org/activemq/what-is-the-prefetch-limit-for.html">prefetch
1:      * policy</a> for consumers created by this connection.
/////////////////////////////////////////////////////////////////////////
0:         info.setDispatchAsync(dispatchAsync);
/////////////////////////////////////////////////////////////////////////
0:      * If this flag is set then a separate thread is not used for dispatching
0:      * messages for each Session in the Connection. However, a separate thread
0:      * is always used if there is more than one session, or the session isn't in
0:      * auto acknowledge or duplicates ok mode
0:      * 
0:      * @param alwaysSessionAsync
0:      *            The alwaysSessionAsync to set.
1:     public void setAlwaysSessionAsync(boolean alwaysSessionAsync) {
1:         this.alwaysSessionAsync = alwaysSessionAsync;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDispatchAsync() {
1:         return dispatchAsync;
1:     /**
1:      * Enables or disables the default setting of whether or not consumers have
1:      * their messages <a
0:      * href="http://incubator.apache.org/activemq/consumer-dispatch-async.html">dispatched
0:      * synchronously or asynchronously by the broker</a>.
0:      * 
0:      * For non-durable topics for example we typically dispatch synchronously by
0:      * default to minimize context switches which boost performance. However
0:      * sometimes its better to go slower to ensure that a single blocked
0:      * consumer socket does not block delivery to other consumers.
0:      * 
0:      * @param asyncDispatch
0:      *            If true then consumers created on this connection will default
0:      *            to having their messages dispatched asynchronously. The
0:      *            default value is false.
1:      */
1:     public void setDispatchAsync(boolean asyncDispatch) {
1:         this.dispatchAsync = asyncDispatch;
commit:ca067a6
/////////////////////////////////////////////////////////////////////////
1:     private boolean nestedMapAndListEnabled = true;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isNestedMapAndListEnabled() {
1:         return nestedMapAndListEnabled;
0:     }
0: 
1:     /**
0:      * Enables/disables whether or not Message properties and MapMessage entries support nested Map and List objects
1:      */
1:     public void setNestedMapAndListEnabled(boolean structuredMapsEnabled) {
1:         this.nestedMapAndListEnabled = structuredMapsEnabled;
0:     }
0: 
0: 
commit:87dcdce
/////////////////////////////////////////////////////////////////////////
0:      * Creates an output stream allowing full control over the delivery mode,
0:      * the priority and time to live of the messages and the properties added to
0:      * messages on the stream.
0:      * 
0:      * @param streamProperties
0:      *            defines a map of key-value pairs where the keys are strings
0:      *            and the values are primitive values (numbers and strings)
0:      *            which are appended to the messages similarly to using the
0:      *            {@link javax.jms.Message#setObjectProperty(String, Object)}
0:      *            method
commit:c085df4
/////////////////////////////////////////////////////////////////////////
0:      * Sets whether or not timestamps on messages should be disabled or not. If you disable them it adds a small performance boost.
/////////////////////////////////////////////////////////////////////////
1:      * Sets the timeout before a close is considered complete. Normally a
1:      * close() on a connection waits for confirmation from the broker; this
1:      * allows that operation to timeout to save the client hanging if there is
1:      * no broker
0:      * 
0:      * @param closeTimeout
0:      *            The closeTimeout to set.
/////////////////////////////////////////////////////////////////////////
0:      * Enables an optimised acknowledgement mode where messages are acknowledged in batches rather than individually
0:      * 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Enables the use of compression of the message bodies
0:      * 
0:      * @param useCompression
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Should a JMS message be copied to a new JMS Message object as part of the
1:      * send() method in JMS. This is enabled by default to be compliant with the
1:      * JMS specification. You can disable it if you do not mutate JMS messages
1:      * after they are sent for a performance boost
0:      * 
0:      * @param copyMessageOnSend
1:      */
commit:b06de59
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void ensureConnectionInfoSent() throws JMSException {
commit:0cc5d24
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Returns true if this connection has been started
0:      * 
0:      * @return true if this Connection is started
1:      */
1:     public boolean isStarted() {
0:         return started.get();
0:     }
0: 
0:     /**
1:      * Returns true if the connection is closed
1:      */
0:     public boolean isClosed() {
0:         return closed.get();
0:     }
0: 
0:     /**
1:      * Returns true if the connection is in the process of being closed
1:      */
1:     public boolean isClosing() {
1:         return closing.get();
0:     }
0:     
0:     /**
1:      * Returns true if the underlying transport has failed
1:      */
1:     public boolean isTransportFailed() {
1:         return transportFailed.get();
0:     }
0:     
0:     /**
/////////////////////////////////////////////////////////////////////////
commit:2bc9a83
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportListener;
/////////////////////////////////////////////////////////////////////////
0: public class ActiveMQConnection implements Connection, TopicConnection, QueueConnection, StatsCapable, Closeable,  StreamConnection, TransportListener {
/////////////////////////////////////////////////////////////////////////
0:     private final CopyOnWriteArrayList transportListeners = new CopyOnWriteArrayList();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Adds a transport listener so that a client can be notified of events in the underlying 
0:      * transport
0:      */
1:     public void addTransportListener(TransportListener transportListener) {
1:         transportListeners.add(transportListener);
0:     }
0:     
1:     public void removeTransportListener(TransportListener transportListener) {
1:         transportListeners.remove(transportListener);
0:     }
/////////////////////////////////////////////////////////////////////////
0:         if (isConnectionInfoSentToBroker || closed.get()) {
/////////////////////////////////////////////////////////////////////////
0:             if(!transportFailed.get() && !closing.get()){
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = transportListeners.iterator(); iter.hasNext();) {
0:             TransportListener listener = (TransportListener) iter.next();
1:             listener.onCommand(command);
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:         for (Iterator iter = transportListeners.iterator(); iter.hasNext();) {
0:             TransportListener listener = (TransportListener) iter.next();
0:             listener.onException(error);
0:         }
0:     
1:     public void transportInterupted() {
0:         for (Iterator iter = transportListeners.iterator(); iter.hasNext();) {
0:             TransportListener listener = (TransportListener) iter.next();
1:             listener.transportInterupted();
0:         }
0:     }
0: 
1:     public void transportResumed() {
0:         for (Iterator iter = transportListeners.iterator(); iter.hasNext();) {
0:             TransportListener listener = (TransportListener) iter.next();
1:             listener.transportResumed();
0:         }
0:     }
0: 
commit:daf48bb
/////////////////////////////////////////////////////////////////////////
1:     private IOException firstFailureError;
/////////////////////////////////////////////////////////////////////////
1:             throw new ConnectionFailedException(firstFailureError);
/////////////////////////////////////////////////////////////////////////
0:     protected void transportFailed(IOException error){
1:         if (firstFailureError == null) {
1:             firstFailureError = error;
0:         }
commit:8776a41
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.DeliveryMode;
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Creates a persistent output stream; individual messages will be written to disk/database by the broker
0:      */
0:     /**
0:      * Creates a non persistent output stream; messages will not be written to disk
0:      */
0:     public OutputStream createNonPersistentOutputStream(Destination dest) throws JMSException {
0:         return createOutputStream(dest, null, DeliveryMode.NON_PERSISTENT, ActiveMQMessage.DEFAULT_PRIORITY, ActiveMQMessage.DEFAULT_TIME_TO_LIVE);
0:     }
0: 
0:     /**
0:      * Creates an output stream allowing full control over the delivery mode, the priority and time to live of the messaages and the properties added to messages on the stream.
0:      */
commit:e6747ea
/////////////////////////////////////////////////////////////////////////
0:      * Returns the broker name if one is available or null if one is not available yet.
0:      */
1:     public String getBrokerName() {
0:         if (brokerInfo == null) {
0:             return null;
0:         }
0:         return brokerInfo.getBrokerName();
0:     }
0:    
0:     /**
0:      * Returns the broker information if it is available or null if it is not available yet.
0:      */
1:     public BrokerInfo getBrokerInfo() {
1:         return brokerInfo;
0:     }
0: 
0:     /**
commit:c8d74e7
/////////////////////////////////////////////////////////////////////////
commit:ffb9d2a
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Sets the redelivery policy to be used when messages are rolled back
0:      */
1:     public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
0:         this.redeliveryPolicy = redeliveryPolicy;
0:     }
0: 
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:bd7d59c
/////////////////////////////////////////////////////////////////////////
0:     private boolean useSyncSend=false;
0:     private boolean watchTopicAdvisories=true;
/////////////////////////////////////////////////////////////////////////
0:         if( watchTopicAdvisories ) {
0:         	advisoryConsumer = new AdvisoryConsumer(this, consumerId);
0:         }        
/////////////////////////////////////////////////////////////////////////
0:     
0: 	public void setUseSyncSend(boolean forceSyncSend) {
0: 		this.useSyncSend = forceSyncSend;
0: 	}
0: 
0: 
0: 	public synchronized boolean isWatchTopicAdvisories() {
0: 		return watchTopicAdvisories;
0: 	}
0: 
0: 
0: 	public synchronized void setWatchTopicAdvisories(boolean watchTopicAdvisories) {
0: 		this.watchTopicAdvisories = watchTopicAdvisories;
0: 	}
0:         
/////////////////////////////////////////////////////////////////////////
0:         checkClosedOrFailed();  
0: 
0:         for(Iterator i=this.sessions.iterator();i.hasNext();){
0:             ActiveMQSession s=(ActiveMQSession) i.next();
0:             if( s.isInUse(destination) ) {
0:             	throw new JMSException("A consumer is consuming from the temporary destination");
0:             }
0:         }        
0:         
/////////////////////////////////////////////////////////////////////////
0:     	
0:     	// If we are not watching the advisories.. then 
0:     	// we will assume that the temp destination does exist.
0:     	if( advisoryConsumer==null )
0:     		return false;
0:         	
commit:e5b45f6
/////////////////////////////////////////////////////////////////////////
0:                     	// If we announced ourselfs to the broker.. Try to let the broker
0:                         // know that the connection is being shutdown.
0:                         asyncSendPacket(new ShutdownInfo());
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:fa63d90
/////////////////////////////////////////////////////////////////////////
0:         return "ActiveMQConnection {id="+info.getConnectionId()+",clientId="+info.getClientId()+",started="+started.get()+"}";
============================================================================