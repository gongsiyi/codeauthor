1:06da208: /**
1:06da208:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:06da208:  * contributor license agreements.  See the NOTICE file distributed with
1:06da208:  * this work for additional information regarding copyright ownership.
1:06da208:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:06da208:  * (the "License"); you may not use this file except in compliance with
1:06da208:  * the License.  You may obtain a copy of the License at
1:06da208:  *
1:06da208:  *      http://www.apache.org/licenses/LICENSE-2.0
1:06da208:  *
1:06da208:  * Unless required by applicable law or agreed to in writing, software
1:06da208:  * distributed under the License is distributed on an "AS IS" BASIS,
1:06da208:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:06da208:  * See the License for the specific language governing permissions and
1:06da208:  * limitations under the License.
1:06da208:  */
5:eaafb4c: 
1:06da208: package org.apache.activemq;
1:982b728: 
1:06da208: import java.util.Map;
1:06da208: import java.util.concurrent.ConcurrentHashMap;
1:06da208: import java.util.concurrent.atomic.AtomicInteger;
1:3b08860: 
1:06da208: import javax.jms.Connection;
1:06da208: import javax.jms.ConnectionFactory;
1:06da208: import javax.jms.Destination;
1:eaafb4c: import javax.jms.JMSException;
1:06da208: import javax.jms.MessageConsumer;
1:06da208: import javax.jms.MessageProducer;
1:06da208: import javax.jms.Session;
1:06da208: import javax.jms.TextMessage;
1:eaafb4c: 
1:06da208: import org.apache.activemq.broker.BrokerService;
1:982b728: import org.junit.After;
1:982b728: import org.junit.Before;
1:982b728: import org.junit.Test;
1:982b728: import org.junit.Rule;
1:982b728: import org.junit.rules.TestName;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:eaafb4c: 
1:982b728: import static org.junit.Assert.*;
1:982b728: 
1:ef82a4b: public class JmsRollbackRedeliveryTest {
1:982b728:     @Rule
1:982b728:     public TestName testName = new TestName();
1:982b728: 
1:8bf987b:     protected static final Logger LOG = LoggerFactory.getLogger(JmsRollbackRedeliveryTest.class);
1:eaafb4c:     final int nbMessages = 10;
1:eaafb4c:     final String destinationName = "Destination";
1:3804d66:     final String brokerUrl = "vm://localhost?create=false";
1:eaafb4c:     boolean consumerClose = true;
1:eaafb4c:     boolean rollback = true;
1:cb519da:     BrokerService broker;
1:982b728: 
1:982b728:     @Before
1:eaafb4c:     public void setUp() throws Exception {
1:ef82a4b:         LOG.debug("Starting " + testName.getMethodName());
1:cb519da:         broker = new BrokerService();
1:eaafb4c:         broker.setPersistent(false);
1:eaafb4c:         broker.setUseJmx(false);
1:eaafb4c:         broker.start();
1:982b728:         broker.waitUntilStarted();
1:eaafb4c:     }
1:982b728: 
1:982b728:     @After
1:cb519da:     public void tearDown() throws Exception {
1:cb519da:         if (broker != null) {
1:cb519da:             broker.stop();
1:982b728:             broker.waitUntilStopped();
1:cb519da:         }
1:ef82a4b:         LOG.debug("Finishing " + testName.getMethodName());
1:ef82a4b:         Thread.sleep(100);
1:cb519da:     }
1:982b728:     
1:982b728:     @Test
1:06da208:     public void testRedelivery() throws Exception {
1:3804d66:         doTestRedelivery(brokerUrl, false);
1:3b08860:     }
1:982b728: 
1:982b728:     @Test
1:3b08860:     public void testRedeliveryWithInterleavedProducer() throws Exception {
1:3804d66:         doTestRedelivery(brokerUrl, true);
1:3b08860:     }
1:982b728: 
1:cb519da: 
1:982b728:     @Test
1:3804d66:     public void testRedeliveryWithPrefetch0() throws Exception {
1:3804d66:         doTestRedelivery(brokerUrl + "?jms.prefetchPolicy.queuePrefetch=0", true);
1:3804d66:     }
1:982b728: 
1:982b728:     @Test
1:3804d66:     public void testRedeliveryWithPrefetch1() throws Exception {
1:3804d66:         doTestRedelivery(brokerUrl + "?jms.prefetchPolicy.queuePrefetch=1", true);
1:3804d66:     }
1:3804d66:     
1:3b08860:     public void doTestRedelivery(String brokerUrl, boolean interleaveProducer) throws Exception {
1:ef82a4b:         LOG.debug("entering doTestRedelivery interleaveProducer is " + interleaveProducer);
1:3b08860:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerUrl);
1:3804d66:         
1:eaafb4c:         Connection connection = connectionFactory.createConnection();
1:06da208:         connection.start();
1:3b08860: 
1:3b08860:         if (interleaveProducer) {
1:3b08860:             populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);
1:3b08860:         } else {
1:3b08860:             populateDestination(nbMessages, destinationName, connection);
1:3b08860:         }
1:3b08860:         
1:06da208:         // Consume messages and rollback transactions
2:06da208:         {
1:06da208:             AtomicInteger received = new AtomicInteger();
1:eaafb4c:             Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();
2:eaafb4c:             while (received.get() < nbMessages) {
1:eaafb4c:                 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
2:06da208:                 Destination destination = session.createQueue(destinationName);
1:06da208:                 MessageConsumer consumer = session.createConsumer(destination);
1:eaafb4c:                 TextMessage msg = (TextMessage) consumer.receive(6000000);
1:eaafb4c:                 if (msg != null) {
1:eaafb4c:                     if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {
1:eaafb4c:                         LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
2:eaafb4c:                         assertTrue(msg.getJMSRedelivered());
1:3804d66:                         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
1:eaafb4c:                         session.commit();
1:eaafb4c:                     } else {
1:eaafb4c:                         LOG.info("Rollback message " + msg.getText() + " id: " +  msg.getJMSMessageID());
1:7343337:                         assertFalse("should not have redelivery flag set, id: " + msg.getJMSMessageID(), msg.getJMSRedelivered());
1:eaafb4c:                         session.rollback();
1:eaafb4c:                     }
1:eaafb4c:                 }
1:eaafb4c:                 consumer.close();
1:eaafb4c:                 session.close();
1:eaafb4c:             }
1:eaafb4c:         }
1:eaafb4c:     }
1:982b728: 
1:982b728:     @Test
1:eaafb4c:     public void testRedeliveryOnSingleConsumer() throws Exception {
1:982b728: 
1:3804d66:         ConnectionFactory connectionFactory = 
1:3804d66:             new ActiveMQConnectionFactory(brokerUrl);
1:3804d66:         Connection connection = connectionFactory.createConnection();
1:3804d66:         connection.start();
1:4046599: 
1:3b08860:         populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);
1:3804d66: 
1:eaafb4c:         // Consume messages and rollback transactions
1:eaafb4c:         {
1:eaafb4c:             AtomicInteger received = new AtomicInteger();
1:eaafb4c:             Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();
1:eaafb4c:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:eaafb4c:             Destination destination = session.createQueue(destinationName);
1:eaafb4c:             MessageConsumer consumer = session.createConsumer(destination);            
1:3804d66:             while (received.get() < nbMessages) {
1:eaafb4c:                 TextMessage msg = (TextMessage) consumer.receive(6000000);
1:eaafb4c:                 if (msg != null) {
1:eaafb4c:                     if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {
1:eaafb4c:                         LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:eaafb4c:                         assertTrue(msg.getJMSRedelivered());
1:eaafb4c:                         session.commit();
1:eaafb4c:                     } else {
1:eaafb4c:                         LOG.info("Rollback message " + msg.getText() + " id: " +  msg.getJMSMessageID());
1:eaafb4c:                         session.rollback();
1:eaafb4c:                     }
1:eaafb4c:                 }
1:eaafb4c:             }
1:eaafb4c:             consumer.close();
1:eaafb4c:             session.close();
1:eaafb4c:         }
1:eaafb4c:     }
1:3b08860: 
1:3b08860: 
1:982b728:     @Test
1:eaafb4c:     public void testRedeliveryOnSingleSession() throws Exception {
1:3b08860: 
1:3804d66:         ConnectionFactory connectionFactory = 
1:3804d66:             new ActiveMQConnectionFactory(brokerUrl); 
1:eaafb4c:         Connection connection = connectionFactory.createConnection();
1:eaafb4c:         connection.start();
1:eaafb4c: 
1:3804d66:         populateDestination(nbMessages, destinationName, connection);
1:eaafb4c: 
1:eaafb4c:         // Consume messages and rollback transactions
1:eaafb4c:         {
1:eaafb4c:             AtomicInteger received = new AtomicInteger();
1:eaafb4c:             Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();
1:eaafb4c:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:eaafb4c:             Destination destination = session.createQueue(destinationName);
1:eaafb4c:             while (received.get() < nbMessages) {
1:eaafb4c:                 MessageConsumer consumer = session.createConsumer(destination);            
1:06da208:                 TextMessage msg = (TextMessage) consumer.receive(6000000);
1:eaafb4c:                 if (msg != null) {
1:eaafb4c:                     if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {
1:eaafb4c:                         LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:eaafb4c:                         assertTrue(msg.getJMSRedelivered());
1:eaafb4c:                         session.commit();
1:06da208:                     } else {
1:06da208:                         LOG.info("Rollback message " + msg.getText() + " id: " +  msg.getJMSMessageID());
1:06da208:                         session.rollback();
1:eaafb4c:                     }
1:eaafb4c:                 }
1:eaafb4c:                 consumer.close();
4:06da208:             }
1:eaafb4c:             session.close();
1:06da208:         }
1:06da208:     }
1:eaafb4c:     
1:564a9c2:     // AMQ-1593
1:982b728:     @Test
1:564a9c2:     public void testValidateRedeliveryCountOnRollback() throws Exception {
1:eaafb4c: 
2:564a9c2:         final int numMessages = 1;
1:564a9c2:        ConnectionFactory connectionFactory = 
1:3804d66:             new ActiveMQConnectionFactory(brokerUrl);
1:eaafb4c:         Connection connection = connectionFactory.createConnection();
1:eaafb4c:         connection.start();
1:eaafb4c: 
1:564a9c2:         populateDestination(numMessages, destinationName, connection);
1:eaafb4c: 
1:eaafb4c:         {
1:eaafb4c:             AtomicInteger received = new AtomicInteger();
1:564a9c2:             final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();
1:564a9c2:             while (received.get() < maxRetries) {
1:564a9c2:                 Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:eaafb4c:                 Destination destination = session.createQueue(destinationName);
1:eaafb4c: 
1:eaafb4c:                 MessageConsumer consumer = session.createConsumer(destination);            
1:eaafb4c:                 TextMessage msg = (TextMessage) consumer.receive(1000);
1:06da208:                 if (msg != null) {
1:564a9c2:                     LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:564a9c2:                     assertEquals("redelivery property matches deliveries", received.get(), msg.getLongProperty("JMSXDeliveryCount"));
1:564a9c2:                     session.rollback();
1:eaafb4c:                 }
2:06da208:                 session.close();
1:06da208:             }
1:4046599:             consumeMessage(connection, maxRetries + 1);
1:06da208:         }
1:06da208:     }
1:4046599:     
1:564a9c2:     // AMQ-1593
1:982b728:     @Test
1:564a9c2:     public void testValidateRedeliveryCountOnRollbackWithPrefetch0() throws Exception {
1:564a9c2: 
1:4046599:        final int numMessages = 1;
1:564a9c2:        ConnectionFactory connectionFactory = 
1:564a9c2:             new ActiveMQConnectionFactory(brokerUrl + "?jms.prefetchPolicy.queuePrefetch=0");
1:564a9c2:         Connection connection = connectionFactory.createConnection();
1:564a9c2:         connection.start();
1:564a9c2: 
1:564a9c2:         populateDestination(numMessages, destinationName, connection);
1:564a9c2: 
1:564a9c2:         {
1:564a9c2:             AtomicInteger received = new AtomicInteger();
1:564a9c2:             final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();
1:564a9c2:             while (received.get() < maxRetries) {
1:564a9c2:                 Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:564a9c2:                 Destination destination = session.createQueue(destinationName);
1:564a9c2: 
1:564a9c2:                 MessageConsumer consumer = session.createConsumer(destination);            
1:564a9c2:                 TextMessage msg = (TextMessage) consumer.receive(1000);
1:564a9c2:                 if (msg != null) {
1:564a9c2:                     LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:564a9c2:                     assertEquals("redelivery property matches deliveries", received.get(), msg.getLongProperty("JMSXDeliveryCount"));
1:564a9c2:                     session.rollback();
1:564a9c2:                 }
1:564a9c2:                 session.close();
1:564a9c2:             }
1:564a9c2:             
1:4046599:             consumeMessage(connection, maxRetries + 1);
1:564a9c2:         }
1:564a9c2:     }
1:eaafb4c: 
1:eaafb4c: 
1:4046599:     private void consumeMessage(Connection connection, final int deliveryCount)
1:4046599:             throws JMSException {
1:4046599:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:4046599:         Destination destination = session.createQueue(destinationName);
1:4046599:         MessageConsumer consumer = session.createConsumer(destination);            
1:4046599:         TextMessage msg = (TextMessage) consumer.receive(1000);
1:4046599:         assertNotNull(msg);
1:4046599:         assertEquals("redelivery property matches deliveries", deliveryCount, msg.getLongProperty("JMSXDeliveryCount"));
1:4046599:         session.commit();
1:4046599:         session.close();
1:4046599:     }
1:4046599: 
1:982b728:     @Test
1:3804d66:     public void testRedeliveryPropertyWithNoRollback() throws Exception {
1:4046599:         final int numMessages = 1;
1:3804d66:         ConnectionFactory connectionFactory = 
1:3804d66:             new ActiveMQConnectionFactory(brokerUrl);
1:06da208:         Connection connection = connectionFactory.createConnection();
1:eaafb4c:         connection.start();
1:eaafb4c: 
1:4046599:         populateDestination(numMessages, destinationName, connection);
1:3804d66:         connection.close();
1:3804d66:         
1:3804d66:         {
1:3804d66:             AtomicInteger received = new AtomicInteger();
1:4046599:             final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();
1:4046599:             while (received.get() < maxRetries) {
1:3804d66:                 connection = connectionFactory.createConnection();
1:3804d66:                 connection.start();
1:4046599:                 Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:3804d66:                 Destination destination = session.createQueue(destinationName);
1:3804d66: 
1:3804d66:                 MessageConsumer consumer = session.createConsumer(destination);            
1:3804d66:                 TextMessage msg = (TextMessage) consumer.receive(2000);
1:3804d66:                 if (msg != null) {
1:4046599:                     LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:4046599:                     assertEquals("redelivery property matches deliveries", received.get(), msg.getLongProperty("JMSXDeliveryCount"));
1:3804d66:                 }
1:3804d66:                 session.close();
1:3804d66:                 connection.close();
1:3804d66:             }
1:4046599:             connection = connectionFactory.createConnection();
1:4046599:             connection.start();
1:4046599:             consumeMessage(connection, maxRetries + 1);
1:3804d66:         }
1:3804d66:     }
1:3804d66:     
1:eaafb4c:     private void populateDestination(final int nbMessages,
1:eaafb4c:             final String destinationName, Connection connection)
1:eaafb4c:             throws JMSException {
1:3804d66:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:eaafb4c:         Destination destination = session.createQueue(destinationName);
1:eaafb4c:         MessageProducer producer = session.createProducer(destination);
1:eaafb4c:         for (int i = 1; i <= nbMessages; i++) {
1:eaafb4c:             producer.send(session.createTextMessage("<hello id='" + i + "'/>"));
1:eaafb4c:         }
1:eaafb4c:         producer.close();
1:eaafb4c:         session.close();
1:eaafb4c:     }
1:3b08860: 
1:eaafb4c:     
1:3b08860:     private void populateDestinationWithInterleavedProducer(final int nbMessages,
1:3b08860:             final String destinationName, Connection connection)
1:3b08860:             throws JMSException {
1:3b08860:         Session session1 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3b08860:         Destination destination1 = session1.createQueue(destinationName);
1:3b08860:         MessageProducer producer1 = session1.createProducer(destination1);
1:3b08860:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:3b08860:         Destination destination2 = session2.createQueue(destinationName);
1:3b08860:         MessageProducer producer2 = session2.createProducer(destination2);
1:3b08860:         
1:3b08860:         for (int i = 1; i <= nbMessages; i++) {
1:3b08860:             if (i%2 == 0) {
1:3b08860:                 producer1.send(session1.createTextMessage("<hello id='" + i + "'/>"));
1:3b08860:             } else {
1:3b08860:                 producer2.send(session2.createTextMessage("<hello id='" + i + "'/>"));
1:3b08860:             }
1:3b08860:         }
1:3b08860:         producer1.close();
1:3b08860:         session1.close();
1:3b08860:         producer2.close();
1:3b08860:         session2.close();
1:3b08860:     }
1:3b08860: 
1:06da208: }
============================================================================
author:Kevin Earls
-------------------------------------------------------------------------------
commit:ef82a4b
/////////////////////////////////////////////////////////////////////////
1: public class JmsRollbackRedeliveryTest {
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Starting " + testName.getMethodName());
1:         LOG.debug("Finishing " + testName.getMethodName());
1:         Thread.sleep(100);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("entering doTestRedelivery interleaveProducer is " + interleaveProducer);
commit:982b728
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.Rule;
1: import org.junit.rules.TestName;
1: import static org.junit.Assert.*;
1: 
0: public class JmsRollbackRedeliveryTest /*extends AutoFailTestSupport*/ {
1:     @Rule
1:     public TestName testName = new TestName();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Before
0:         //setAutoFail(true);
0:         //super.setUp();
1: 
0:         LOG.info(">>>> Starting " + testName.getMethodName());
1:         broker.waitUntilStarted();
1: 
1: 
1:     @After
0:         //super.tearDown();
1:             broker.waitUntilStopped();
1:     @Test
1:     @Test
1: 
1:     @Test
1: 
1:     @Test
0:         LOG.info(">>>> entering doTestRedelivery interleaveProducer is " + interleaveProducer);
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:     @Test
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     protected static final Logger LOG = LoggerFactory.getLogger(JmsRollbackRedeliveryTest.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:cb519da
/////////////////////////////////////////////////////////////////////////
1:     BrokerService broker;
1:         broker = new BrokerService();
1: 
1:     public void tearDown() throws Exception {
0:         super.tearDown();
1:         if (broker != null) {
1:             broker.stop();
1:         }
1:     }
commit:7343337
/////////////////////////////////////////////////////////////////////////
1:                         assertFalse("should not have redelivery flag set, id: " + msg.getJMSMessageID(), msg.getJMSRedelivered());
commit:4046599
/////////////////////////////////////////////////////////////////////////
1:             consumeMessage(connection, maxRetries + 1);
1:        final int numMessages = 1;
/////////////////////////////////////////////////////////////////////////
1:             
1:             consumeMessage(connection, maxRetries + 1);
1: 
1:     private void consumeMessage(Connection connection, final int deliveryCount)
1:             throws JMSException {
1:         Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         Destination destination = session.createQueue(destinationName);
1:         MessageConsumer consumer = session.createConsumer(destination);            
1:         TextMessage msg = (TextMessage) consumer.receive(1000);
1:         assertNotNull(msg);
1:         assertEquals("redelivery property matches deliveries", deliveryCount, msg.getLongProperty("JMSXDeliveryCount"));
1:         session.commit();
1:         session.close();
1:     }
1: 
1:         final int numMessages = 1;
1:         populateDestination(numMessages, destinationName, connection);
1:             final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();
1:             while (received.get() < maxRetries) {
1:                 Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:                     LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:                     assertEquals("redelivery property matches deliveries", received.get(), msg.getLongProperty("JMSXDeliveryCount"));
1:             connection = connectionFactory.createConnection();
1:             connection.start();
1:             consumeMessage(connection, maxRetries + 1);
commit:564a9c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // AMQ-1593
1:     public void testValidateRedeliveryCountOnRollback() throws Exception {
1:         final int numMessages = 1;
1:        ConnectionFactory connectionFactory = 
1:         populateDestination(numMessages, destinationName, connection);
1:             final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();
1:             while (received.get() < maxRetries) {
1:                 Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:                     LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:                     assertEquals("redelivery property matches deliveries", received.get(), msg.getLongProperty("JMSXDeliveryCount"));
1:                     session.rollback();
1:     // AMQ-1593
1:     public void testValidateRedeliveryCountOnRollbackWithPrefetch0() throws Exception {
1: 
1:         final int numMessages = 1;
1:        ConnectionFactory connectionFactory = 
1:             new ActiveMQConnectionFactory(brokerUrl + "?jms.prefetchPolicy.queuePrefetch=0");
1:         Connection connection = connectionFactory.createConnection();
1:         connection.start();
1: 
1:         populateDestination(numMessages, destinationName, connection);
1: 
1:         {
1:             AtomicInteger received = new AtomicInteger();
1:             final int maxRetries = new RedeliveryPolicy().getMaximumRedeliveries();
1:             while (received.get() < maxRetries) {
1:                 Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:                 Destination destination = session.createQueue(destinationName);
1: 
1:                 MessageConsumer consumer = session.createConsumer(destination);            
1:                 TextMessage msg = (TextMessage) consumer.receive(1000);
1:                 if (msg != null) {
1:                     LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:                     assertEquals("redelivery property matches deliveries", received.get(), msg.getLongProperty("JMSXDeliveryCount"));
1:                     session.rollback();
1:                 }
1:                 session.close();
1:             }
1:         }
1:     }
1: 
commit:3804d66
/////////////////////////////////////////////////////////////////////////
1:     final String brokerUrl = "vm://localhost?create=false";
/////////////////////////////////////////////////////////////////////////
1:         doTestRedelivery(brokerUrl, false);
1:         doTestRedelivery(brokerUrl, true);
1:     public void testRedeliveryWithPrefetch0() throws Exception {
1:         doTestRedelivery(brokerUrl + "?jms.prefetchPolicy.queuePrefetch=0", true);
1:     }
1:     
1:     public void testRedeliveryWithPrefetch1() throws Exception {
1:         doTestRedelivery(brokerUrl + "?jms.prefetchPolicy.queuePrefetch=1", true);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                         assertEquals(2, msg.getLongProperty("JMSXDeliveryCount"));
0:                         assertFalse(msg.getJMSRedelivered());
/////////////////////////////////////////////////////////////////////////
1:         ConnectionFactory connectionFactory = 
1:             new ActiveMQConnectionFactory(brokerUrl);
/////////////////////////////////////////////////////////////////////////
1:         ConnectionFactory connectionFactory = 
1:             new ActiveMQConnectionFactory(brokerUrl); 
/////////////////////////////////////////////////////////////////////////
1:         ConnectionFactory connectionFactory = 
1:             new ActiveMQConnectionFactory(brokerUrl);
/////////////////////////////////////////////////////////////////////////
1:     public void testRedeliveryPropertyWithNoRollback() throws Exception {
0:         ConnectionFactory connectionFactory = 
1:             new ActiveMQConnectionFactory(brokerUrl);
1:         Connection connection = connectionFactory.createConnection();
1:         connection.start();
1: 
1:         populateDestination(nbMessages, destinationName, connection);
1:         connection.close();
1:         
1:         {
1:             AtomicInteger received = new AtomicInteger();
1:             while (received.get() < nbMessages) {
1:                 connection = connectionFactory.createConnection();
1:                 connection.start();
1:                 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                 Destination destination = session.createQueue(destinationName);
1: 
1:                 MessageConsumer consumer = session.createConsumer(destination);            
1:                 TextMessage msg = (TextMessage) consumer.receive(2000);
1:                 if (msg != null) {
0:                     LOG.info("Received message " + msg.getText() + 
0:                             " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
0:                     assertFalse(msg.getJMSRedelivered());
0:                     assertEquals(1, msg.getLongProperty("JMSXDeliveryCount"));
1:                 }
1:                 session.close();
1:                 connection.close();
1:             }
1:         }
1:     }
1:     
commit:3b08860
/////////////////////////////////////////////////////////////////////////
0: public class JmsRollbackRedeliveryTest extends AutoFailTestSupport {
/////////////////////////////////////////////////////////////////////////
0:         setAutoFail(true);
0:         super.setUp();
1: 
0:         doTestRedelivery("vm://localhost", false);
1:     }
1: 
1:     public void testRedeliveryWithInterleavedProducer() throws Exception {
0:         doTestRedelivery("vm://localhost", true);
1:     }
1: 
1:     public void doTestRedelivery(String brokerUrl, boolean interleaveProducer) throws Exception {
1:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerUrl);
1:         
1:         if (interleaveProducer) {
1:             populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);
1:         } else {
1:             populateDestination(nbMessages, destinationName, connection);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:        
1:         populateDestinationWithInterleavedProducer(nbMessages, destinationName, connection);
/////////////////////////////////////////////////////////////////////////
0:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://localhost"); 
/////////////////////////////////////////////////////////////////////////
0:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://localhost");
/////////////////////////////////////////////////////////////////////////
1: 
1:     private void populateDestinationWithInterleavedProducer(final int nbMessages,
1:             final String destinationName, Connection connection)
1:             throws JMSException {
1:         Session session1 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination1 = session1.createQueue(destinationName);
1:         MessageProducer producer1 = session1.createProducer(destination1);
1:         Session session2 = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination2 = session2.createQueue(destinationName);
1:         MessageProducer producer2 = session2.createProducer(destination2);
1:         
1:         for (int i = 1; i <= nbMessages; i++) {
1:             if (i%2 == 0) {
1:                 producer1.send(session1.createTextMessage("<hello id='" + i + "'/>"));
1:             } else {
1:                 producer2.send(session2.createTextMessage("<hello id='" + i + "'/>"));
1:             }
1:         }
1:         producer1.close();
1:         session1.close();
1:         producer2.close();
1:         session2.close();
1:     }
1: 
commit:eaafb4c
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
1:     final int nbMessages = 10;
1:     final String destinationName = "Destination";
1:     boolean consumerClose = true;
1:     boolean rollback = true;
1:     
1:     public void setUp() throws Exception {
0:         BrokerService broker = new BrokerService();
1:         broker.setPersistent(false);
1:         broker.setUseJmx(false);
1:         broker.start();
1:     
0:         populateDestination(nbMessages, destinationName, connection);
/////////////////////////////////////////////////////////////////////////
1:                         assertTrue(msg.getJMSRedelivered());
1:                 consumer.close();
1:                 session.close();
1:             }
1:         }
1:     }
1: 
1:    
1:     public void testRedeliveryOnSingleConsumer() throws Exception {
1: 
0:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://localhost");
1:         Connection connection = connectionFactory.createConnection();
1:         connection.start();
1: 
0:         populateDestination(nbMessages, destinationName, connection);
1: 
1:         // Consume messages and rollback transactions
1:         {
1:             AtomicInteger received = new AtomicInteger();
1:             Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();
1:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:             Destination destination = session.createQueue(destinationName);
1:             MessageConsumer consumer = session.createConsumer(destination);            
1:             while (received.get() < nbMessages) {
1:                 TextMessage msg = (TextMessage) consumer.receive(6000000);
1:                 if (msg != null) {
1:                     if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {
1:                         LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:                         assertTrue(msg.getJMSRedelivered());
1:                         session.commit();
1:                     } else {
1:                         LOG.info("Rollback message " + msg.getText() + " id: " +  msg.getJMSMessageID());
1:                         session.rollback();
1:                     }
1:                 }
1:             }
1:             consumer.close();
1:             session.close();
1:         }
1:     }
1:     
1:     public void testRedeliveryOnSingleSession() throws Exception {
1: 
0:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://localhost?jms.redeliveryPolicy.maximumRedeliveries=100");
1:         Connection connection = connectionFactory.createConnection();
1:         connection.start();
1: 
0:         populateDestination(nbMessages, destinationName, connection);
1: 
1:         // Consume messages and rollback transactions
1:         {
1:             AtomicInteger received = new AtomicInteger();
1:             Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();
1:             Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:             Destination destination = session.createQueue(destinationName);
1:             while (received.get() < nbMessages) {
1:                 MessageConsumer consumer = session.createConsumer(destination);            
1:                 TextMessage msg = (TextMessage) consumer.receive(6000000);
1:                 if (msg != null) {
1:                     if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {
1:                         LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:                         assertTrue(msg.getJMSRedelivered());
1:                         session.commit();
1:                     } else {
1:                         LOG.info("Rollback message " + msg.getText() + " id: " +  msg.getJMSMessageID());
1:                         session.rollback();
1:                     }
1:                 }
1:                 consumer.close();
1:             }
1:             session.close();
1:         }
1:     }
1:     
0:     public void testRedeliveryOnSessionCloseWithNoRollback() throws Exception {
1: 
0:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://localhost?jms.redeliveryPolicy.maximumRedeliveries=100");
1:         Connection connection = connectionFactory.createConnection();
1:         connection.start();
1: 
0:         populateDestination(nbMessages, destinationName, connection);
1: 
1:         {
1:             AtomicInteger received = new AtomicInteger();
1:             Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();
1:             while (received.get() < nbMessages) {
1:                 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:                 Destination destination = session.createQueue(destinationName);
1: 
1:                 MessageConsumer consumer = session.createConsumer(destination);            
1:                 TextMessage msg = (TextMessage) consumer.receive(1000);
1:                 if (msg != null) {
1:                     if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {
1:                         LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
1:                         assertTrue(msg.getJMSRedelivered());
1:                         session.commit();
1:                     }
1:     
1:     private void populateDestination(final int nbMessages,
1:             final String destinationName, Connection connection)
1:             throws JMSException {
0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Destination destination = session.createQueue(destinationName);
1:         MessageProducer producer = session.createProducer(destination);
1:         for (int i = 1; i <= nbMessages; i++) {
1:             producer.send(session.createTextMessage("<hello id='" + i + "'/>"));
1:         }
1:         producer.close();
1:         session.close();
1:     }
1:     
commit:06da208
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.activemq;
0: 
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.atomic.AtomicInteger;
0: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.Destination;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
0: 
0: import junit.framework.TestCase;
0: 
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: public class JmsRollbackRedeliveryTest extends TestCase {
0:     protected static final Log LOG = LogFactory.getLog(JmsRollbackRedeliveryTest.class);
0:     private boolean consumerClose = true;
0: 
0:     public void testRedeliveryNoConsumerClose() throws Exception {
0:         consumerClose = false;
0:         testRedelivery();
1:     }
0:     
1:     public void testRedelivery() throws Exception {
0: 
0:         final int nbMessages = 10;
0:         final String destinationName = "Destination";
0: 
0:         BrokerService broker = new BrokerService();
0:         broker.setPersistent(false);
0:         broker.setUseJmx(false);
0:         broker.start();
0: 
0:         ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://localhost?jms.redeliveryPolicy.maximumRedeliveries=100");
0: 
1:         Connection connection = connectionFactory.createConnection();
1:         connection.start();
0: 
0:         // Enqueue nbMessages messages
1:         {
0:             Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             Destination destination = session.createQueue(destinationName);
0:             MessageProducer producer = session.createProducer(destination);
0:             for (int i = 1; i <= nbMessages; i++) {
0:                 producer.send(session.createTextMessage("<hello id='" + i + "'/>"));
1:             }
0:             producer.close();
1:             session.close();
1:         }
0: 
1:         // Consume messages and rollback transactions
1:         {
1:             AtomicInteger received = new AtomicInteger();
0:             Map<String, Boolean> rolledback = new ConcurrentHashMap<String, Boolean>();
0:             while (received.get() < nbMessages) {
0:                 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);
1:                 Destination destination = session.createQueue(destinationName);
1:                 MessageConsumer consumer = session.createConsumer(destination);
1:                 TextMessage msg = (TextMessage) consumer.receive(6000000);
1:                 if (msg != null) {
0:                     if (msg != null && rolledback.put(msg.getText(), Boolean.TRUE) != null) {
0:                         LOG.info("Received message " + msg.getText() + " (" + received.getAndIncrement() + ")" + msg.getJMSMessageID());
0:                         session.commit();
1:                     } else {
1:                         LOG.info("Rollback message " + msg.getText() + " id: " +  msg.getJMSMessageID());
1:                         session.rollback();
1:                     }
1:                 }
0:                 if (consumerClose ) {
0:                     consumer.close();
1:                 }
1:                 session.close();
1:             }
1:         }
1:     }
1: }
============================================================================