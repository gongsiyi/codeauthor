2:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f0e6f26:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:f0e6f26:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
2:d29ca2a:  */
1:f812e34: 
1:b66559e: package org.apache.activemq.jms.pool;
1:a59c9ba: 
1:b496c0a: import java.util.List;
1:b496c0a: import java.util.concurrent.CopyOnWriteArrayList;
1:74a7a8b: import java.util.concurrent.atomic.AtomicBoolean;
1:a59c9ba: 
1:f91abd3: import javax.jms.Connection;
1:f91abd3: import javax.jms.ExceptionListener;
1:2a7c349: import javax.jms.IllegalStateException;
1:f91abd3: import javax.jms.JMSException;
1:f91abd3: import javax.jms.Session;
1:f91abd3: import javax.jms.TemporaryQueue;
1:f91abd3: import javax.jms.TemporaryTopic;
1:f812e34: 
1:6d6ed4e: import org.apache.commons.pool2.KeyedPooledObjectFactory;
1:6d6ed4e: import org.apache.commons.pool2.PooledObject;
1:6d6ed4e: import org.apache.commons.pool2.impl.DefaultPooledObject;
1:6d6ed4e: import org.apache.commons.pool2.impl.GenericKeyedObjectPool;
1:7c7c505: import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;
1:b53d8ea: import org.slf4j.Logger;
1:b53d8ea: import org.slf4j.LoggerFactory;
1:f812e34: 
1:b53d8ea: /**
1:d29ca2a:  * Holds a real JMS connection along with the session pools associated with it.
1:a59c9ba:  * <p/>
1:a59c9ba:  * Instances of this class are shared amongst one or more PooledConnection object and must
1:a59c9ba:  * track the session objects that are loaned out for cleanup on close as well as ensuring
1:a59c9ba:  * that the temporary destinations of the managed Connection are purged when all references
1:a59c9ba:  * to this ConnectionPool are released.
1:c0bc3e0:  */
1:b53d8ea: public class ConnectionPool implements ExceptionListener {
1:b53d8ea:     private static final transient Logger LOG = LoggerFactory.getLogger(ConnectionPool.class);
1:858ab26: 
1:b66559e:     protected Connection connection;
1:c0bc3e0:     private int referenceCount;
1:f812e34:     private long lastUsed = System.currentTimeMillis();
1:f664be7:     private final long firstUsed = lastUsed;
1:f812e34:     private boolean hasExpired;
1:f812e34:     private int idleTimeout = 30 * 1000;
1:4dd5b5e:     private long expiryTimeout = 0l;
1:2a7c349:     private boolean useAnonymousProducers = true;
1:f812e34: 
1:a59c9ba:     private final AtomicBoolean started = new AtomicBoolean(false);
1:f91abd3:     private final GenericKeyedObjectPool<SessionKey, SessionHolder> sessionPool;
1:a59c9ba:     private final List<PooledSession> loanedSessions = new CopyOnWriteArrayList<PooledSession>();
1:b53d8ea:     private boolean reconnectOnException;
1:b53d8ea:     private ExceptionListener parentExceptionListener;
1:a59c9ba: 
1:b66559e:     public ConnectionPool(Connection connection) {
1:7c7c505:         final GenericKeyedObjectPoolConfig poolConfig = new GenericKeyedObjectPoolConfig();
1:7c7c505:         poolConfig.setJmxEnabled(false);
1:b66559e:         this.connection = wrap(connection);
1:b65c0d1:         try {
1:b65c0d1:             this.connection.setExceptionListener(this);
1:b65c0d1:         } catch (JMSException ex) {
1:b65c0d1:             LOG.warn("Could not set exception listener on create of ConnectionPool");
1:b65c0d1:         }
1:f664be7: 
1:a59c9ba:         // Create our internal Pool of session instances.
1:f91abd3:         this.sessionPool = new GenericKeyedObjectPool<SessionKey, SessionHolder>(
1:6d6ed4e:             new KeyedPooledObjectFactory<SessionKey, SessionHolder>() {
1:f664be7:                 @Override
1:6d6ed4e:                 public PooledObject<SessionHolder> makeObject(SessionKey sessionKey) throws Exception {
1:6d6ed4e: 
1:6d6ed4e:                     return new DefaultPooledObject<SessionHolder>(new SessionHolder(makeSession(sessionKey)));
1:b53d8ea:                 }
1:a59c9ba: 
1:f664be7:                 @Override
1:6d6ed4e:                 public void destroyObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) throws Exception {
1:b65c0d1:                     pooledObject.getObject().close();
1:a59c9ba:                 }
1:a59c9ba: 
1:f664be7:                 @Override
1:6d6ed4e:                 public boolean validateObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) {
1:a59c9ba:                     return true;
1:a59c9ba:                 }
1:6d6ed4e: 
1:6d6ed4e:                 @Override
1:6d6ed4e:                 public void activateObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) throws Exception {
1:6d6ed4e:                 }
1:6d6ed4e: 
1:6d6ed4e:                 @Override
1:6d6ed4e:                 public void passivateObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) throws Exception {
1:6d6ed4e:                 }
1:7c7c505:             }, poolConfig
1:a59c9ba:         );
1:a59c9ba:     }
1:a59c9ba: 
1:b66559e:     // useful when external failure needs to force expiry
1:b66559e:     public void setHasExpired(boolean val) {
1:b66559e:         hasExpired = val;
1:b66559e:     }
1:b66559e: 
1:b66559e:     protected Session makeSession(SessionKey key) throws JMSException {
1:b66559e:         return connection.createSession(key.isTransacted(), key.getAckMode());
1:b66559e:     }
1:b66559e: 
1:b66559e:     protected Connection wrap(Connection connection) {
1:b66559e:         return connection;
1:b66559e:     }
1:b66559e: 
1:b66559e:     protected void unWrap(Connection connection) {
1:b66559e:     }
1:b66559e: 
1:d29ca2a:     public void start() throws JMSException {
1:d29ca2a:         if (started.compareAndSet(false, true)) {
1:b53d8ea:             try {
1:f0e6f26:                 connection.start();
1:f0e6f26:             } catch (JMSException e) {
1:f0e6f26:                 started.set(false);
1:2e64abc:                 if (isReconnectOnException()) {
1:2e64abc:                     close();
1:2e64abc:                 }
1:f0e6f26:                 throw(e);
1:b53d8ea:             }
1:b53d8ea:         }
1:f0e6f26:     }
1:a59c9ba: 
1:b66559e:     public synchronized Connection getConnection() {
1:d29ca2a:         return connection;
1:f812e34:     }
1:a59c9ba: 
1:d29ca2a:     public Session createSession(boolean transacted, int ackMode) throws JMSException {
1:d29ca2a:         SessionKey key = new SessionKey(transacted, ackMode);
1:a59c9ba:         PooledSession session;
1:a59c9ba:         try {
1:f395c70:             session = new PooledSession(key, sessionPool.borrowObject(key), sessionPool, key.isTransacted(), useAnonymousProducers);
1:f395c70:             session.addSessionEventListener(new PooledSessionEventListener() {
1:f395c70: 
1:f395c70:                 @Override
1:f395c70:                 public void onTemporaryTopicCreate(TemporaryTopic tempTopic) {
1:f395c70:                 }
1:f395c70: 
1:f395c70:                 @Override
1:f395c70:                 public void onTemporaryQueueCreate(TemporaryQueue tempQueue) {
1:f395c70:                 }
1:f395c70: 
1:f395c70:                 @Override
1:f395c70:                 public void onSessionClosed(PooledSession session) {
1:f395c70:                     ConnectionPool.this.loanedSessions.remove(session);
1:f395c70:                 }
1:f395c70:             });
1:f395c70:             this.loanedSessions.add(session);
1:a59c9ba:         } catch (Exception e) {
1:b66559e:             IllegalStateException illegalStateException = new IllegalStateException(e.toString());
1:b66559e:             illegalStateException.initCause(e);
1:b66559e:             throw illegalStateException;
1:a59c9ba:         }
1:2e57fb5:         return session;
1:a59c9ba:     }
1:a59c9ba: 
1:fc00993:     public synchronized void close() {
1:f812e34:         if (connection != null) {
1:f0e6f26:             try {
1:a59c9ba:                 sessionPool.close();
1:a59c9ba:             } catch (Exception e) {
1:f812e34:             } finally {
1:f0e6f26:                 try {
1:f812e34:                     connection.close();
1:f0e6f26:                 } catch (Exception e) {
2:ef1d355:                 } finally {
1:f812e34:                     connection = null;
1:a59c9ba:                 }
1:f0e6f26:             }
1:f0e6f26:         }
1:f812e34:     }
1:6687d56: 
1:fc00993:     public synchronized void incrementReferenceCount() {
1:f812e34:         referenceCount++;
1:f812e34:         lastUsed = System.currentTimeMillis();
1:f812e34:     }
1:8fc47c6: 
1:fc00993:     public synchronized void decrementReferenceCount() {
1:f812e34:         referenceCount--;
1:f812e34:         lastUsed = System.currentTimeMillis();
1:f812e34:         if (referenceCount == 0) {
1:a59c9ba:             // Loaned sessions are those that are active in the sessionPool and
1:a59c9ba:             // have not been closed by the client before closing the connection.
1:a59c9ba:             // These need to be closed so that all session's reflect the fact
1:a59c9ba:             // that the parent Connection is closed.
1:bfd1be5:             for (PooledSession session : this.loanedSessions) {
1:bfd1be5:                 try {
1:f395c70:                     session.close();
1:bfd1be5:                 } catch (Exception e) {
1:bfd1be5:                 }
1:bfd1be5:             }
1:bfd1be5:             this.loanedSessions.clear();
1:f664be7: 
1:b66559e:             unWrap(getConnection());
1:4dd5b5e: 
1:f664be7:             expiredCheck();
1:320d87c:         }
1:f812e34:     }
1:bfd1be5: 
1:dc607bb:     /**
1:a59c9ba:      * Determines if this Connection has expired.
1:a59c9ba:      * <p/>
1:a59c9ba:      * A ConnectionPool is considered expired when all references to it are released AND either
1:a59c9ba:      * the configured idleTimeout has elapsed OR the configured expiryTimeout has elapsed.
1:a59c9ba:      * Once a ConnectionPool is determined to have expired its underlying Connection is closed.
1:a59c9ba:      *
1:f812e34:      * @return true if this connection has expired.
1:f812e34:      */
1:fc00993:     public synchronized boolean expiredCheck() {
1:858ab26: 
1:858ab26:         boolean expired = false;
1:858ab26: 
1:f812e34:         if (connection == null) {
1:f664be7:             return true;
1:f812e34:         }
1:a59c9ba: 
1:b66559e:         if (hasExpired) {
1:f812e34:             if (referenceCount == 0) {
1:b53d8ea:                 close();
1:858ab26:                 expired = true;
9:f812e34:             }
1:f812e34:         }
1:a59c9ba: 
1:5b1412d:         if (expiryTimeout > 0 && (firstUsed + expiryTimeout) - System.currentTimeMillis() < 0) {
1:f812e34:             hasExpired = true;
1:f812e34:             if (referenceCount == 0) {
1:f664be7:                 close();
1:858ab26:                 expired = true;
1:f664be7:             }
1:f812e34:         }
1:f664be7: 
1:858ab26:         // Only set hasExpired here is no references, as a Connection with references is by
1:858ab26:         // definition not idle at this time.
1:5b1412d:         if (referenceCount == 0 && idleTimeout > 0 && (lastUsed + idleTimeout) - System.currentTimeMillis() < 0) {
1:f664be7:             hasExpired = true;
2:f812e34:             close();
1:858ab26:             expired = true;
1:f812e34:         }
1:a59c9ba: 
1:858ab26:         return expired;
1:f812e34:     }
1:f0e6f26: 
1:f812e34:     public int getIdleTimeout() {
1:f812e34:         return idleTimeout;
1:f812e34:     }
1:320d87c: 
1:f812e34:     public void setIdleTimeout(int idleTimeout) {
1:f812e34:         this.idleTimeout = idleTimeout;
1:f812e34:     }
1:f812e34: 
1:4dd5b5e:     public void setExpiryTimeout(long expiryTimeout) {
1:a59c9ba:         this.expiryTimeout = expiryTimeout;
1:4dd5b5e:     }
1:f0e6f26: 
1:4dd5b5e:     public long getExpiryTimeout() {
1:4dd5b5e:         return expiryTimeout;
1:bfd1be5:     }
1:bfd1be5: 
1:a59c9ba:     public int getMaximumActiveSessionPerConnection() {
1:4441001:         return this.sessionPool.getMaxTotalPerKey();
1:bfd1be5:     }
1:4dd5b5e: 
1:a59c9ba:     public void setMaximumActiveSessionPerConnection(int maximumActiveSessionPerConnection) {
1:4441001:         this.sessionPool.setMaxTotalPerKey(maximumActiveSessionPerConnection);
1:a59c9ba:     }
1:a59c9ba: 
1:2a7c349:     public boolean isUseAnonymousProducers() {
1:2a7c349:         return this.useAnonymousProducers;
1:2a7c349:     }
1:2a7c349: 
1:2a7c349:     public void setUseAnonymousProducers(boolean value) {
1:2a7c349:         this.useAnonymousProducers = value;
1:2a7c349:     }
1:2a7c349: 
1:a59c9ba:     /**
1:a59c9ba:      * @return the total number of Pooled session including idle sessions that are not
1:a59c9ba:      *          currently loaned out to any client.
1:a59c9ba:      */
1:a59c9ba:     public int getNumSessions() {
1:a59c9ba:         return this.sessionPool.getNumIdle() + this.sessionPool.getNumActive();
1:a59c9ba:     }
1:a59c9ba: 
1:a59c9ba:     /**
1:a59c9ba:      * @return the total number of Sessions that are in the Session pool but not loaned out.
1:a59c9ba:      */
1:a59c9ba:     public int getNumIdleSessions() {
1:a59c9ba:         return this.sessionPool.getNumIdle();
1:a59c9ba:     }
1:a59c9ba: 
1:a59c9ba:     /**
1:a59c9ba:      * @return the total number of Session's that have been loaned to PooledConnection instances.
1:a59c9ba:      */
1:a59c9ba:     public int getNumActiveSessions() {
1:a59c9ba:         return this.sessionPool.getNumActive();
1:a59c9ba:     }
1:a59c9ba: 
1:a59c9ba:     /**
1:a59c9ba:      * Configure whether the createSession method should block when there are no more idle sessions and the
1:a59c9ba:      * pool already contains the maximum number of active sessions.  If false the create method will fail
1:a59c9ba:      * and throw an exception.
1:a59c9ba:      *
1:a59c9ba:      * @param block
1:a59c9ba:      * 		Indicates whether blocking should be used to wait for more space to create a session.
1:a59c9ba:      */
1:a59c9ba:     public void setBlockIfSessionPoolIsFull(boolean block) {
1:6d6ed4e:         this.sessionPool.setBlockWhenExhausted(block);
1:a59c9ba:     }
1:a59c9ba: 
1:a59c9ba:     public boolean isBlockIfSessionPoolIsFull() {
1:6d6ed4e:         return this.sessionPool.getBlockWhenExhausted();
1:4dd5b5e:     }
1:f812e34: 
1:f812e34:     /**
1:dc607bb:      * Returns the timeout to use for blocking creating new sessions
1:dc607bb:      *
1:dc607bb:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:dc607bb:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:dc607bb:      */
1:dc607bb:     public long getBlockIfSessionPoolIsFullTimeout() {
1:6d6ed4e:         return this.sessionPool.getMaxWaitMillis();
1:dc607bb:     }
1:dc607bb: 
1:dc607bb:     /**
1:dc607bb:      * Controls the behavior of the internal session pool. By default the call to
1:dc607bb:      * Connection.getSession() will block if the session pool is full.  This setting
1:dc607bb:      * will affect how long it blocks and throws an exception after the timeout.
1:dc607bb:      *
1:dc607bb:      * The size of the session pool is controlled by the @see #maximumActive
1:dc607bb:      * property.
1:dc607bb:      *
1:dc607bb:      * Whether or not the call to create session blocks is controlled by the @see #blockIfSessionPoolIsFull
1:dc607bb:      * property
1:dc607bb:      *
1:dc607bb:      * @param blockIfSessionPoolIsFullTimeout - if blockIfSessionPoolIsFullTimeout is true,
1:dc607bb:      *                                        then use this setting to configure how long to block before retry
1:dc607bb:      */
1:dc607bb:     public void setBlockIfSessionPoolIsFullTimeout(long blockIfSessionPoolIsFullTimeout) {
1:6d6ed4e:         this.sessionPool.setMaxWaitMillis(blockIfSessionPoolIsFullTimeout);
1:dc607bb:     }
1:dc607bb: 
1:c0bc3e0:     /**
1:b53d8ea:      * @return true if the underlying connection will be renewed on JMSException, false otherwise
1:b53d8ea:      */
1:b53d8ea:     public boolean isReconnectOnException() {
1:b53d8ea:         return reconnectOnException;
1:b53d8ea:     }
1:b53d8ea: 
1:b53d8ea:     /**
1:b53d8ea:      * Controls weather the underlying connection should be reset (and renewed) on JMSException
1:b53d8ea:      *
1:b53d8ea:      * @param reconnectOnException
1:b53d8ea:      *          Boolean value that configures whether reconnect on exception should happen
1:b53d8ea:      */
1:b53d8ea:     public void setReconnectOnException(boolean reconnectOnException) {
1:b53d8ea:         this.reconnectOnException = reconnectOnException;
1:b65c0d1:     }
1:b65c0d1: 
1:b65c0d1:     ExceptionListener getParentExceptionListener() {
1:b65c0d1:         return parentExceptionListener;
1:b65c0d1:     }
1:b65c0d1: 
1:b65c0d1:     void setParentExceptionListener(ExceptionListener parentExceptionListener) {
1:b65c0d1:         this.parentExceptionListener = parentExceptionListener;
1:b53d8ea:     }
1:b53d8ea: 
1:b53d8ea:     @Override
1:b53d8ea:     public void onException(JMSException exception) {
1:b65c0d1:         if (isReconnectOnException()) {
1:b65c0d1:             close();
1:b65c0d1:         }
2:b53d8ea:         if (parentExceptionListener != null) {
1:b53d8ea:             parentExceptionListener.onException(exception);
1:b53d8ea:         }
1:b53d8ea:     }
1:b53d8ea: 
1:f664be7:     @Override
1:8fc47c6:     public String toString() {
1:8fc47c6:         return "ConnectionPool[" + connection + "]";
1:b53d8ea:     }
1:8fc47c6: }
============================================================================
author:giliva
-------------------------------------------------------------------------------
commit:5b1412d
/////////////////////////////////////////////////////////////////////////
1:         if (expiryTimeout > 0 && (firstUsed + expiryTimeout) - System.currentTimeMillis() < 0) {
/////////////////////////////////////////////////////////////////////////
1:         if (referenceCount == 0 && idleTimeout > 0 && (lastUsed + idleTimeout) - System.currentTimeMillis() < 0) {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:2e64abc
/////////////////////////////////////////////////////////////////////////
1:                 if (isReconnectOnException()) {
1:                     close();
1:                 }
commit:b65c0d1
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             this.connection.setExceptionListener(this);
1:         } catch (JMSException ex) {
1:             LOG.warn("Could not set exception listener on create of ConnectionPool");
1:         }
/////////////////////////////////////////////////////////////////////////
1:                     pooledObject.getObject().close();
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     ExceptionListener getParentExceptionListener() {
1:         return parentExceptionListener;
1:     }
1: 
1:     void setParentExceptionListener(ExceptionListener parentExceptionListener) {
1:         this.parentExceptionListener = parentExceptionListener;
1:         if (isReconnectOnException()) {
1:             close();
1:         }
commit:f91abd3
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Connection;
1: import javax.jms.ExceptionListener;
1: import javax.jms.JMSException;
1: import javax.jms.Session;
1: import javax.jms.TemporaryQueue;
1: import javax.jms.TemporaryTopic;
/////////////////////////////////////////////////////////////////////////
1:     private final GenericKeyedObjectPool<SessionKey, SessionHolder> sessionPool;
/////////////////////////////////////////////////////////////////////////
1:         this.sessionPool = new GenericKeyedObjectPool<SessionKey, SessionHolder>(
0:             new KeyedPoolableObjectFactory<SessionKey, SessionHolder>() {
0:                 public void activateObject(SessionKey key, SessionHolder session) throws Exception {
0:                 public void destroyObject(SessionKey key, SessionHolder session) throws Exception {
0:                 public SessionHolder makeObject(SessionKey key) throws Exception {
0:                     return new SessionHolder(makeSession(key));
0:                 public void passivateObject(SessionKey key, SessionHolder session) throws Exception {
0:                 public boolean validateObject(SessionKey key, SessionHolder session) {
commit:f395c70
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.TemporaryQueue;
0: import javax.jms.TemporaryTopic;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final GenericKeyedObjectPool<SessionKey, Session> sessionPool;
/////////////////////////////////////////////////////////////////////////
0:         this.sessionPool = new GenericKeyedObjectPool<SessionKey, Session>(
0:             new KeyedPoolableObjectFactory<SessionKey, Session>() {
0:                 public void activateObject(SessionKey key, Session session) throws Exception {
0:                 public void destroyObject(SessionKey key, Session session) throws Exception {
1:                     session.close();
0:                 public Session makeObject(SessionKey key) throws Exception {
0:                     return makeSession(key);
0:                 public void passivateObject(SessionKey key, Session session) throws Exception {
0:                 public boolean validateObject(SessionKey key, Session session) {
/////////////////////////////////////////////////////////////////////////
1:             session = new PooledSession(key, sessionPool.borrowObject(key), sessionPool, key.isTransacted(), useAnonymousProducers);
1:             session.addSessionEventListener(new PooledSessionEventListener() {
1: 
1:                 @Override
1:                 public void onTemporaryTopicCreate(TemporaryTopic tempTopic) {
1:                 }
1: 
1:                 @Override
1:                 public void onTemporaryQueueCreate(TemporaryQueue tempQueue) {
1:                 }
1: 
1:                 @Override
1:                 public void onSessionClosed(PooledSession session) {
1:                     ConnectionPool.this.loanedSessions.remove(session);
1:                 }
1:             });
1:             this.loanedSessions.add(session);
commit:2a7c349
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.IllegalStateException;
/////////////////////////////////////////////////////////////////////////
1:     private boolean useAnonymousProducers = true;
/////////////////////////////////////////////////////////////////////////
0:                     return new PooledSession(key, session, sessionPool, key.isTransacted(), useAnonymousProducers);
/////////////////////////////////////////////////////////////////////////
1:     public boolean isUseAnonymousProducers() {
1:         return this.useAnonymousProducers;
1:     }
1: 
1:     public void setUseAnonymousProducers(boolean value) {
1:         this.useAnonymousProducers = value;
1:     }
1: 
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:7c7c505
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;
/////////////////////////////////////////////////////////////////////////
1:         final GenericKeyedObjectPoolConfig poolConfig = new GenericKeyedObjectPoolConfig();
1:         poolConfig.setJmxEnabled(false);
/////////////////////////////////////////////////////////////////////////
1:             }, poolConfig
author:Jeff Genender
-------------------------------------------------------------------------------
commit:4441001
/////////////////////////////////////////////////////////////////////////
1:         return this.sessionPool.getMaxTotalPerKey();
1:         this.sessionPool.setMaxTotalPerKey(maximumActiveSessionPerConnection);
commit:6d6ed4e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.pool2.BasePooledObjectFactory;
0: import org.apache.commons.pool2.KeyedObjectPool;
1: import org.apache.commons.pool2.KeyedPooledObjectFactory;
1: import org.apache.commons.pool2.PooledObject;
1: import org.apache.commons.pool2.impl.DefaultPooledObject;
1: import org.apache.commons.pool2.impl.GenericKeyedObjectPool;
0: import org.apache.commons.pool2.impl.GenericObjectPool;
/////////////////////////////////////////////////////////////////////////
1:             new KeyedPooledObjectFactory<SessionKey, SessionHolder>() {
1:                 public PooledObject<SessionHolder> makeObject(SessionKey sessionKey) throws Exception {
1: 
1:                     return new DefaultPooledObject<SessionHolder>(new SessionHolder(makeSession(sessionKey)));
1:                 public void destroyObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) throws Exception {
0:                     ((SessionHolder)pooledObject.getObject()).close();
1:                 public boolean validateObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) {
1: 
1:                 @Override
1:                 public void activateObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) throws Exception {
1:                 }
1: 
1:                 @Override
1:                 public void passivateObject(SessionKey sessionKey, PooledObject<SessionHolder> pooledObject) throws Exception {
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         return this.sessionPool.getMaxTotal();
0:         this.sessionPool.setMaxTotal(maximumActiveSessionPerConnection);
/////////////////////////////////////////////////////////////////////////
1:         this.sessionPool.setBlockWhenExhausted(block);
1:         return this.sessionPool.getBlockWhenExhausted();
/////////////////////////////////////////////////////////////////////////
1:         return this.sessionPool.getMaxWaitMillis();
/////////////////////////////////////////////////////////////////////////
1:         this.sessionPool.setMaxWaitMillis(blockIfSessionPoolIsFullTimeout);
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:b53d8ea
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.*;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1: public class ConnectionPool implements ExceptionListener {
1:     private static final transient Logger LOG = LoggerFactory.getLogger(ConnectionPool.class);
/////////////////////////////////////////////////////////////////////////
1:     private boolean reconnectOnException;
1:     private ExceptionListener parentExceptionListener;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return true if the underlying connection will be renewed on JMSException, false otherwise
1:      */
1:     public boolean isReconnectOnException() {
1:         return reconnectOnException;
1:     }
1: 
1:     /**
1:      * Controls weather the underlying connection should be reset (and renewed) on JMSException
1:      *
1:      * @param reconnectOnException
1:      *          Boolean value that configures whether reconnect on exception should happen
1:      */
1:     public void setReconnectOnException(boolean reconnectOnException) {
1:         this.reconnectOnException = reconnectOnException;
1:         try {
0:             if (isReconnectOnException()) {
0:                 if (connection.getExceptionListener() != null) {
0:                     parentExceptionListener = connection.getExceptionListener();
1:                 }
0:                 connection.setExceptionListener(this);
0:             } else {
1:                 if (parentExceptionListener != null) {
0:                     connection.setExceptionListener(parentExceptionListener);
1:                 }
0:                 parentExceptionListener = null;
1:             }
0:         } catch (JMSException jmse) {
0:             LOG.warn("Cannot set reconnect exception listener", jmse);
1:         }
1:     }
1: 
1:     @Override
1:     public void onException(JMSException exception) {
1:         close();
1:         if (parentExceptionListener != null) {
1:             parentExceptionListener.onException(exception);
1:         }
1:     }
1: 
author:Christian Posta
-------------------------------------------------------------------------------
commit:dc607bb
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the timeout to use for blocking creating new sessions
1:      *
1:      * @return true if the pooled Connection createSession method will block when the limit is hit.
1:      * @see #setBlockIfSessionPoolIsFull(boolean)
1:      */
1:     public long getBlockIfSessionPoolIsFullTimeout() {
0:         return this.sessionPool.getMaxWait();
1:     }
1: 
1:     /**
1:      * Controls the behavior of the internal session pool. By default the call to
1:      * Connection.getSession() will block if the session pool is full.  This setting
1:      * will affect how long it blocks and throws an exception after the timeout.
1:      *
1:      * The size of the session pool is controlled by the @see #maximumActive
1:      * property.
1:      *
1:      * Whether or not the call to create session blocks is controlled by the @see #blockIfSessionPoolIsFull
1:      * property
1:      *
1:      * @param blockIfSessionPoolIsFullTimeout - if blockIfSessionPoolIsFullTimeout is true,
1:      *                                        then use this setting to configure how long to block before retry
1:      */
1:     public void setBlockIfSessionPoolIsFullTimeout(long blockIfSessionPoolIsFullTimeout) {
0:         this.sessionPool.setMaxWait(blockIfSessionPoolIsFullTimeout);
1:     }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:b66559e
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.jms.pool;
0: import javax.jms.Connection;
0: import javax.jms.IllegalStateException;
/////////////////////////////////////////////////////////////////////////
1:     protected Connection connection;
/////////////////////////////////////////////////////////////////////////
1:     public ConnectionPool(Connection connection) {
1:         this.connection = wrap(connection);
/////////////////////////////////////////////////////////////////////////
0:                     Session session = makeSession(key);
0:                     return new PooledSession(key, session, sessionPool, key.isTransacted());
/////////////////////////////////////////////////////////////////////////
1:     // useful when external failure needs to force expiry
1:     public void setHasExpired(boolean val) {
1:         hasExpired = val;
1:     }
1: 
1:     protected Session makeSession(SessionKey key) throws JMSException {
1:         return connection.createSession(key.isTransacted(), key.getAckMode());
1:     }
1: 
1:     protected Connection wrap(Connection connection) {
1:         return connection;
1:     }
1: 
1:     protected void unWrap(Connection connection) {
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public synchronized Connection getConnection() {
/////////////////////////////////////////////////////////////////////////
1:             IllegalStateException illegalStateException = new IllegalStateException(e.toString());
1:             illegalStateException.initCause(e);
1:             throw illegalStateException;
/////////////////////////////////////////////////////////////////////////
1:             unWrap(getConnection());
/////////////////////////////////////////////////////////////////////////
1:         if (hasExpired) {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:858ab26
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final transient Logger LOG = LoggerFactory.getLogger(ConnectionPool.class);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         boolean expired = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 expired = true;
1:                 expired = true;
1:         // Only set hasExpired here is no references, as a Connection with references is by
1:         // definition not idle at this time.
1:             expired = true;
1:         return expired;
commit:f664be7
/////////////////////////////////////////////////////////////////////////
1:     private final long firstUsed = lastUsed;
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             expiredCheck();
/////////////////////////////////////////////////////////////////////////
0:         if (hasExpired || hasFailed) {
0:         if (expiryTimeout > 0 && System.currentTimeMillis() > firstUsed + expiryTimeout) {
1: 
0:         if (referenceCount == 0 && idleTimeout > 0 && System.currentTimeMillis() > lastUsed + idleTimeout) {
1:             hasExpired = true;
1:             close();
1:             return true;
1:         }
1: 
commit:a59c9ba
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.activemq.ActiveMQSession;
0: import org.apache.activemq.util.JMSExceptionSupport;
0: import org.apache.commons.pool.KeyedPoolableObjectFactory;
0: import org.apache.commons.pool.impl.GenericKeyedObjectPool;
0: import org.apache.commons.pool.impl.GenericObjectPool;
1:  * <p/>
1:  * Instances of this class are shared amongst one or more PooledConnection object and must
1:  * track the session objects that are loaned out for cleanup on close as well as ensuring
1:  * that the temporary destinations of the managed Connection are purged when all references
1:  * to this ConnectionPool are released.
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean started = new AtomicBoolean(false);
0:     private final GenericKeyedObjectPool<SessionKey, PooledSession> sessionPool;
1:     private final List<PooledSession> loanedSessions = new CopyOnWriteArrayList<PooledSession>();
1: 
0:     public ConnectionPool(ActiveMQConnection connection) {
1: 
0:         this.connection = connection;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Create our internal Pool of session instances.
0:         this.sessionPool = new GenericKeyedObjectPool<SessionKey, PooledSession>(
0:             new KeyedPoolableObjectFactory<SessionKey, PooledSession>() {
1: 
0:                 @Override
0:                 public void activateObject(SessionKey key, PooledSession session) throws Exception {
0:                     ConnectionPool.this.loanedSessions.add(session);
1:                 }
1: 
0:                 @Override
0:                 public void destroyObject(SessionKey key, PooledSession session) throws Exception {
0:                     ConnectionPool.this.loanedSessions.remove(session);
0:                     session.getInternalSession().close();
1:                 }
1: 
0:                 @Override
0:                 public PooledSession makeObject(SessionKey key) throws Exception {
0:                     ActiveMQSession session = (ActiveMQSession)
0:                             ConnectionPool.this.connection.createSession(key.isTransacted(), key.getAckMode());
0:                     return new PooledSession(key, session, sessionPool);
1:                 }
1: 
0:                 @Override
0:                 public void passivateObject(SessionKey key, PooledSession session) throws Exception {
0:                     ConnectionPool.this.loanedSessions.remove(session);
1:                 }
1: 
0:                 @Override
0:                 public boolean validateObject(SessionKey key, PooledSession session) {
1:                     return true;
1:                 }
1:             }
1:         );
/////////////////////////////////////////////////////////////////////////
1:         PooledSession session;
1:         try {
0:             session = sessionPool.borrowObject(key);
1:         } catch (Exception e) {
0:             throw JMSExceptionSupport.create(e);
1:                 sessionPool.close();
1:             } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
1:             // Loaned sessions are those that are active in the sessionPool and
1:             // have not been closed by the client before closing the connection.
1:             // These need to be closed so that all session's reflect the fact
1:             // that the parent Connection is closed.
/////////////////////////////////////////////////////////////////////////
0:             // We only clean up temporary destinations when all users of this
0:             // connection have called close.
/////////////////////////////////////////////////////////////////////////
1:      * Determines if this Connection has expired.
1:      * <p/>
1:      * A ConnectionPool is considered expired when all references to it are released AND either
1:      * the configured idleTimeout has elapsed OR the configured expiryTimeout has elapsed.
1:      * Once a ConnectionPool is determined to have expired its underlying Connection is closed.
1:      *
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.expiryTimeout = expiryTimeout;
1:     public int getMaximumActiveSessionPerConnection() {
0:         return this.sessionPool.getMaxActive();
1:     public void setMaximumActiveSessionPerConnection(int maximumActiveSessionPerConnection) {
0:         this.sessionPool.setMaxActive(maximumActiveSessionPerConnection);
1:     }
1: 
1:     /**
1:      * @return the total number of Pooled session including idle sessions that are not
1:      *          currently loaned out to any client.
1:      */
1:     public int getNumSessions() {
1:         return this.sessionPool.getNumIdle() + this.sessionPool.getNumActive();
1:     }
1: 
1:     /**
1:      * @return the total number of Sessions that are in the Session pool but not loaned out.
1:      */
1:     public int getNumIdleSessions() {
1:         return this.sessionPool.getNumIdle();
1:     }
1: 
1:     /**
1:      * @return the total number of Session's that have been loaned to PooledConnection instances.
1:      */
1:     public int getNumActiveSessions() {
1:         return this.sessionPool.getNumActive();
1:     }
1: 
1:     /**
1:      * Configure whether the createSession method should block when there are no more idle sessions and the
1:      * pool already contains the maximum number of active sessions.  If false the create method will fail
1:      * and throw an exception.
1:      *
1:      * @param block
1:      * 		Indicates whether blocking should be used to wait for more space to create a session.
1:      */
1:     public void setBlockIfSessionPoolIsFull(boolean block) {
0:         this.sessionPool.setWhenExhaustedAction(
0:                 (block ? GenericObjectPool.WHEN_EXHAUSTED_BLOCK : GenericObjectPool.WHEN_EXHAUSTED_FAIL));
1:     }
1: 
1:     public boolean isBlockIfSessionPoolIsFull() {
0:         return this.sessionPool.getWhenExhaustedAction() == GenericObjectPool.WHEN_EXHAUSTED_BLOCK;
commit:6687d56
/////////////////////////////////////////////////////////////////////////
0:         // should be expired due to a connection failure.
/////////////////////////////////////////////////////////////////////////
1: 
commit:bfd1be5
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentLinkedQueue;
/////////////////////////////////////////////////////////////////////////
0:     private ConcurrentLinkedQueue<PooledSession> loanedSessions = new ConcurrentLinkedQueue<PooledSession>();
/////////////////////////////////////////////////////////////////////////
0:         this.loanedSessions.add(session);
/////////////////////////////////////////////////////////////////////////
1:             for (PooledSession session : this.loanedSessions) {
1:                 try {
0:                     session.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:             this.loanedSessions.clear();
1: 
/////////////////////////////////////////////////////////////////////////
0:     void onSessionReturned(PooledSession session) {
0:         this.loanedSessions.remove(session);
1:     }
1: 
0:     void onSessionInvalidated(PooledSession session) {
0:         this.loanedSessions.remove(session);
1:     }
commit:f0e6f26
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
0:     private ConcurrentHashMap<SessionKey, SessionPool> cache;
/////////////////////////////////////////////////////////////////////////
0:         this(connection, new ConcurrentHashMap<SessionKey, SessionPool>(), poolFactory);
/////////////////////////////////////////////////////////////////////////
0:         });
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionPool(ActiveMQConnection connection, ConcurrentHashMap<SessionKey, SessionPool> cache, ObjectPoolFactory poolFactory) {
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 connection.start();
1:             } catch (JMSException e) {
1:                 started.set(false);
1:                 throw(e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         SessionPool pool = null;
0:         pool = cache.get(key);
0:             SessionPool newPool = createSessionPool(key);
0:             SessionPool prevPool = cache.putIfAbsent(key, newPool);
0:             if (prevPool != null && prevPool != newPool) {
0:                 // newPool was not the first one to be associated with this
0:                 // key... close created session pool
1:                 try {
0:                     newPool.close();
1:                 } catch (Exception e) {
0:                     throw new JMSException(e.getMessage());
1:                 }
1:             }
0:             pool = cache.get(key); // this will return a non-null value...
/////////////////////////////////////////////////////////////////////////
1: 
0:             // only clean up temp destinations when all users
/////////////////////////////////////////////////////////////////////////
0:         if (hasFailed
/////////////////////////////////////////////////////////////////////////
1: 
commit:320d87c
/////////////////////////////////////////////////////////////////////////
1:             
0:             // only clean up temp destinations when all users 
0:             // of this connection have called close
0:             if (getConnection() != null) {
0:                 getConnection().cleanUpTempDestinations();
1:             }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:8fc47c6
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Override
1:     public String toString() {
1:         return "ConnectionPool[" + connection + "]";
1:     }
author:Gary Tully
-------------------------------------------------------------------------------
commit:b496c0a
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
0:     private List<PooledSession> loanedSessions = new CopyOnWriteArrayList<PooledSession>();
commit:9353ea5
/////////////////////////////////////////////////////////////////////////
commit:4dd5b5e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private long firstUsed = lastUsed;
1:     private long expiryTimeout = 0l;
/////////////////////////////////////////////////////////////////////////
0:                     System.err.println("HasFaile=true on :" + error);
0:                     Thread.dumpStack();
/////////////////////////////////////////////////////////////////////////
0:         if (hasFailed 
0:                 || (idleTimeout > 0 && System.currentTimeMillis() > lastUsed + idleTimeout)
0:                 || expiryTimeout > 0 && System.currentTimeMillis() > firstUsed + expiryTimeout) {
/////////////////////////////////////////////////////////////////////////
1:     public void setExpiryTimeout(long expiryTimeout) {
0:         this.expiryTimeout  = expiryTimeout;
1:     }
1:     
1:     public long getExpiryTimeout() {
1:         return expiryTimeout;
1:     }
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:0bbc0ac
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private Map<SessionKey, SessionPool> cache;
/////////////////////////////////////////////////////////////////////////
0:         this(connection, new HashMap<SessionKey, SessionPool>(), poolFactory, transactionManager);
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionPool(ActiveMQConnection connection, Map<SessionKey, SessionPool> cache, ObjectPoolFactory poolFactory,
/////////////////////////////////////////////////////////////////////////
0:             SessionPool pool = cache.get(key);
/////////////////////////////////////////////////////////////////////////
0:                 Iterator<SessionPool> i = cache.values().iterator();
0:                     SessionPool pool = i.next();
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:             boolean isXa = transactionManager != null && transactionManager.getStatus() != Status.STATUS_NO_TRANSACTION;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     public synchronized ActiveMQConnection getConnection() {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void close() {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void incrementReferenceCount() {
1:     public synchronized void decrementReferenceCount() {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized boolean expiredCheck() {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
1:     private long lastUsed = System.currentTimeMillis();
0:     private boolean hasFailed;
1:     private boolean hasExpired;
1:     private int idleTimeout = 30 * 1000;
0:     public ConnectionPool(ActiveMQConnection connection, ObjectPoolFactory poolFactory,
0:                           TransactionManager transactionManager) {
0:         // Add a transport Listener so that we can notice if this connection
0:         // should be expired due to
0:         connection.addTransportListener(new TransportListener() {
0:             public void onCommand(Object command) {
1:             }
1: 
0:             public void onException(IOException error) {
0:                 synchronized (ConnectionPool.this) {
0:                     hasFailed = true;
1:                 }
1:             }
1: 
0:             public void transportInterupted() {
1:             }
1: 
0:             public void transportResumed() {
1:             }
0:         });
0:     public ConnectionPool(ActiveMQConnection connection, Map cache, ObjectPoolFactory poolFactory,
0:                           TransactionManager transactionManager) {
/////////////////////////////////////////////////////////////////////////
0:             SessionPool pool = (SessionPool)cache.get(key);
/////////////////////////////////////////////////////////////////////////
1:         if (connection != null) {
0:             try {
0:                 Iterator i = cache.values().iterator();
0:                 while (i.hasNext()) {
0:                     SessionPool pool = (SessionPool)i.next();
0:                     i.remove();
0:                     try {
0:                         pool.close();
0:                     } catch (Exception e) {
1:                     }
1:                 }
1:             } finally {
1:                     connection.close();
1:                     connection = null;
1:             }
1:         }
1:         referenceCount++;
1:         lastUsed = System.currentTimeMillis();
1:     }
0:     synchronized public void decrementReferenceCount() {
1:         referenceCount--;
1:         lastUsed = System.currentTimeMillis();
1:         if (referenceCount == 0) {
0:             expiredCheck();
1:         }
1:     }
1:     /**
1:      * @return true if this connection has expired.
1:      */
0:     synchronized public boolean expiredCheck() {
1:         if (connection == null) {
0:             return true;
1:         }
0:         if (hasExpired) {
1:             if (referenceCount == 0) {
1:                 close();
1:             }
0:             return true;
1:         }
0:         if (hasFailed || (idleTimeout > 0 && System.currentTimeMillis() > lastUsed + idleTimeout)) {
1:             hasExpired = true;
1:             if (referenceCount == 0) {
1:                 close();
1:             }
0:             return true;
1:         }
0:         return false;
1:     }
1:     public int getIdleTimeout() {
1:         return idleTimeout;
1:     }
1:     public void setIdleTimeout(int idleTimeout) {
1:         this.idleTimeout = idleTimeout;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:c0bc3e0
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Map;
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.transport.TransportListener;
0: import org.apache.commons.pool.ObjectPoolFactory;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0: 	
1:     private int referenceCount;
0: 	private long lastUsed;
0: 	private boolean hasFailed;
0: 	private int idleTimeout = 30*1000;
0:         // Add a transport Listener so that we can notice if this connection should be expired due to 
0:         // a connection failure.
0:         connection.addTransportListener(new TransportListener(){
0: 			public void onCommand(Object command) {
0: 			}
0: 			public void onException(IOException error) {
0: 				synchronized(ConnectionPool.this) {
0: 					hasFailed = true;
0: 				}
0: 			}
0: 			public void transportInterupted() {
0: 			}
0: 			public void transportResumed() {
0: 			}
0: 		});
/////////////////////////////////////////////////////////////////////////
0:     synchronized public ActiveMQConnection getConnection() {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void close() {
0:     	if( connection!=null ) {
0: 	        Iterator i = cache.values().iterator();
0: 	        while (i.hasNext()) {
0: 	            SessionPool pool = (SessionPool) i.next();
0: 	            i.remove();
0: 	            try {
0: 	                pool.close();
0: 	            } catch (Exception e) {
0: 	            }
0: 	        }
0:             	connection.close();
0:             } catch (Exception e) {
0: 	        connection = null;
0:     	}
0:     synchronized public void incrementReferenceCount() {
0: 		referenceCount++;
0: 	}
0: 
0: 	synchronized public void decrementReferenceCount() {
0: 		referenceCount--;
0: 		if( referenceCount == 0 ) {
0: 			lastUsed = System.currentTimeMillis();
0: 			expiredCheck();
0: 		}
0: 	}
0: 
1: 	/**
0: 	 * @return true if this connection has expired.
1: 	 */
0: 	synchronized public boolean expiredCheck() {
0: 		if( connection == null )
0: 			return true;
0: 		if( hasFailed || idleTimeout> 0 && System.currentTimeMillis() > lastUsed+idleTimeout ) {
0: 			if( referenceCount == 0 ) {
0: 				close();
0: 			}
0: 			return true;
0: 		}
0: 		return false;
0: 	}
0: 
0: 	public int getIdleTimeout() {
0: 		return idleTimeout;
0: 	}
0: 
0: 	public void setIdleTimeout(int idleTimeout) {
0: 		this.idleTimeout = idleTimeout;
0: 	}
0: 
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.activemq.pool;
0: 
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
0: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.util.JMSExceptionSupport;
0: 
0: import javax.jms.JMSException;
0: import javax.jms.Session;
0: 
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Map;
0: 
1: /**
1:  * Holds a real JMS connection along with the session pools associated with it.
0:  * 
0:  * @version $Revision$
1:  */
0: public class ConnectionPool {
0:     private ActiveMQConnection connection;
0:     private Map cache;
0:     private AtomicBoolean started = new AtomicBoolean(false);
0: 
0:     public ConnectionPool(ActiveMQConnection connection) {
0:         this(connection, new HashMap());
0:     }
0: 
0:     public ConnectionPool(ActiveMQConnection connection, Map cache) {
0:         this.connection = connection;
0:         this.cache = cache;
0:     }
0: 
1:     public void start() throws JMSException {
1:         if (started.compareAndSet(false, true)) {
0:             connection.start();
0:         }
0:     }
0: 
0:     public ActiveMQConnection getConnection() {
1:         return connection;
0:     }
0: 
1:     public Session createSession(boolean transacted, int ackMode) throws JMSException {
1:         SessionKey key = new SessionKey(transacted, ackMode);
0:         SessionPool pool = (SessionPool) cache.get(key);
0:         if (pool == null) {
0:             pool = new SessionPool(this, key);
0:             cache.put(key, pool);
0:         }
0:         return pool.borrowSession();
0:     }
0: 
0:     public void close() throws JMSException {
0:         Iterator i = cache.values().iterator();
0:         while (i.hasNext()) {
0:             SessionPool pool = (SessionPool) i.next();
0:             i.remove();
0:             try {
0:                 pool.close();
0:             }
0:             catch (Exception e) {
0:                 throw JMSExceptionSupport.create(e);
0:             }
0:         }
0:         connection.close();
0:         connection = null;
0:     }
0: 
0: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:b94342f
/////////////////////////////////////////////////////////////////////////
0:         	try {
0:         		connection.start();
0:         	} catch (JMSException e) {
0:         		started.set(false);
0:         		throw(e);
0:         	}
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:2e57fb5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionPool(ActiveMQConnection connection, ObjectPoolFactory poolFactory) {
0:         this(connection, new HashMap<SessionKey, SessionPool>(), poolFactory);
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionPool(ActiveMQConnection connection, Map<SessionKey, SessionPool> cache, ObjectPoolFactory poolFactory) {
/////////////////////////////////////////////////////////////////////////
0:         SessionKey key = new SessionKey(transacted, ackMode);
0:         SessionPool pool = cache.get(key);
0:         if (pool == null) {
0:             pool = createSessionPool(key);
0:             cache.put(key, pool);
0:         PooledSession session = pool.borrowSession();
1:         return session;
/////////////////////////////////////////////////////////////////////////
0:     protected SessionPool createSessionPool(SessionKey key) {
0:         return new SessionPool(this, key, poolFactory.createPool());
commit:8704012
/////////////////////////////////////////////////////////////////////////
0: import javax.transaction.RollbackException;
0: import javax.transaction.Status;
0: import javax.transaction.SystemException;
0: import javax.transaction.TransactionManager;
0: import javax.transaction.xa.XAResource;
/////////////////////////////////////////////////////////////////////////
0:     private TransactionManager transactionManager;
0: 	private long lastUsed = System.currentTimeMillis();
0:     public ConnectionPool(ActiveMQConnection connection, ObjectPoolFactory poolFactory, TransactionManager transactionManager) {
0:         this(connection, new HashMap(), poolFactory, transactionManager);
/////////////////////////////////////////////////////////////////////////
0:     public ConnectionPool(ActiveMQConnection connection, Map cache, ObjectPoolFactory poolFactory, TransactionManager transactionManager) {
0:         this.transactionManager = transactionManager;
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             boolean isXa = (transactionManager != null && transactionManager.getStatus() != Status.STATUS_NO_TRANSACTION);
0:             if (isXa) {
0:                 transacted = true;
0:                 ackMode = Session.SESSION_TRANSACTED;
0:             }
0:             SessionKey key = new SessionKey(transacted, ackMode);
0:             SessionPool pool = (SessionPool) cache.get(key);
0:             if (pool == null) {
0:                 pool = new SessionPool(this, key, poolFactory.createPool());
0:                 cache.put(key, pool);
0:             }
0:             PooledSession session = pool.borrowSession();
0:             if (isXa) {
0:                 session.setIgnoreClose(true);
0:                 transactionManager.getTransaction().registerSynchronization(new Synchronization(session));
0:                 incrementReferenceCount();
0:                 transactionManager.getTransaction().enlistResource(createXaResource(session));
0:             }
0:             return session;
0:         } catch (RollbackException e) {
0:             final JMSException jmsException = new JMSException("Rollback Exception");
0:             jmsException.initCause(e);
0:             throw jmsException;
0:         } catch (SystemException e) {
0:             final JMSException jmsException = new JMSException("System Exception");
0:             jmsException.initCause(e);
0:             throw jmsException;
/////////////////////////////////////////////////////////////////////////
0: 		lastUsed = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0:         long t = System.currentTimeMillis();
0: 		if( hasFailed || idleTimeout> 0 && t > lastUsed+idleTimeout ) {
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected XAResource createXaResource(PooledSession session) throws JMSException {
0:         return session.getSession().getTransactionContext();
0:     }
0:     protected class Synchronization implements javax.transaction.Synchronization {
0:         private final PooledSession session;
0: 
0:         private Synchronization(PooledSession session) {
0:             this.session = session;
0:         }
0: 
0:         public void beforeCompletion() {
0:         }
0:         
0:         public void afterCompletion(int status) {
0:             try {
0:                 // This will return session to the pool.
0:                 session.setIgnoreClose(false);
0:                 session.close();
0:                 decrementReferenceCount();
0:             } catch (JMSException e) {
0:                 throw new RuntimeException(e);
0:             }
0:         }
0:     }
0:     
author:Robert Davies
-------------------------------------------------------------------------------
commit:6c52d28
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         });       
0:         //
0:         // make sure that we set the hasFailed flag, in case the transport already failed
0:         // prior to the addition of our new TransportListener
0:         //
0:         if(connection.isTransportFailed()) {
0:             hasFailed = true;
0:         }
/////////////////////////////////////////////////////////////////////////
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:         protected Synchronization(PooledSession session) {
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:ef1d355
/////////////////////////////////////////////////////////////////////////
0: 	private boolean hasExpired;
/////////////////////////////////////////////////////////////////////////
0:     		try {
0: 		        Iterator i = cache.values().iterator();
0: 		        while (i.hasNext()) {
0: 		            SessionPool pool = (SessionPool) i.next();
0: 		            i.remove();
0: 		            try {
0: 		                pool.close();
0: 		            } catch (Exception e) {
0: 		            }
0: 		        }
1:     		} finally {
0:                 try {
0:                 	connection.close();
0:                 } catch (Exception e) {
1:                 } finally {
0:         	        connection = null;
0:                 }
0:     		}
0: 		lastUsed = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0: 		if( connection == null ) {
0: 		}
0: 		if( hasExpired ) {
0: 			if( referenceCount == 0 ) {
0: 				close();
0: 			}
0: 			return true;
0: 		}
0: 		if( hasFailed || ( idleTimeout>0 && System.currentTimeMillis() > lastUsed+idleTimeout) ) {
0: 			hasExpired=true;
author:James Strachan
-------------------------------------------------------------------------------
commit:2fd7ccb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.pool.ObjectPoolFactory;
/////////////////////////////////////////////////////////////////////////
0:     private ObjectPoolFactory poolFactory;
0:     public ConnectionPool(ActiveMQConnection connection, ObjectPoolFactory poolFactory) {
0:         this(connection, new HashMap(), poolFactory);
0:     public ConnectionPool(ActiveMQConnection connection, Map cache, ObjectPoolFactory poolFactory) {
0:         this.poolFactory = poolFactory;
/////////////////////////////////////////////////////////////////////////
0:             pool = new SessionPool(this, key, poolFactory.createPool());
============================================================================