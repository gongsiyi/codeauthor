1:e11ece1: /**
1:e11ece1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:e11ece1:  * contributor license agreements.  See the NOTICE file distributed with
1:e11ece1:  * this work for additional information regarding copyright ownership.
1:e11ece1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:e11ece1:  * (the "License"); you may not use this file except in compliance with
1:e11ece1:  * the License.  You may obtain a copy of the License at
1:e11ece1:  *
1:e11ece1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:e11ece1:  *
1:e11ece1:  * Unless required by applicable law or agreed to in writing, software
1:e11ece1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e11ece1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e11ece1:  * See the License for the specific language governing permissions and
1:e11ece1:  * limitations under the License.
1:e11ece1:  */
1:1aab71b: package org.apache.activemq.store.kahadb.disk.index;
4:e11ece1: 
1:e11ece1: import java.io.DataInput;
1:e11ece1: import java.io.DataOutput;
1:e11ece1: import java.io.IOException;
1:e11ece1: import java.util.Iterator;
1:e11ece1: import java.util.Map.Entry;
1:e11ece1: import java.util.NoSuchElementException;
1:e11ece1: 
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Page;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.LinkedNode;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.LinkedNodeList;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.Marshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1:e11ece1: 
1:e11ece1: /**
1:f77b252:  * The ListNode class represents a node in the List object graph. It is stored
1:f77b252:  * in one overflowing Page of a PageFile.
1:e11ece1:  */
1:f77b252: public final class ListNode<Key, Value> {
1:e11ece1: 
1:2b10259:     private final static boolean ADD_FIRST = true;
1:2b10259:     private final static boolean ADD_LAST = false;
1:e11ece1: 
1:e11ece1:     // The index that this node is part of.
1:f77b252:     private ListIndex<Key, Value> containingList;
1:2b10259: 
1:e11ece1:     // The page associated with this node
1:f77b252:     private Page<ListNode<Key, Value>> page;
1:e11ece1: 
1:bf59b7d:     private LinkedNodeList<KeyValueEntry<Key, Value>> entries = new LinkedNodeList<KeyValueEntry<Key, Value>>() {
1:bf59b7d: 
1:bf59b7d:         @Override
1:bf59b7d:         public String toString() {
1:bf59b7d:             return "PageId:" + page.getPageId() + ", index:" + containingList + super.toString();
1:bf59b7d:         }
1:bf59b7d:     };
1:e11ece1: 
1:e11ece1:     // The next page after this one.
1:bf59b7d:     private long next = ListIndex.NOT_SET;
1:e11ece1: 
1:f77b252:     static final class KeyValueEntry<Key, Value> extends LinkedNode<KeyValueEntry<Key, Value>> implements Entry<Key, Value> {
1:e11ece1: 
1:e11ece1:         private final Key key;
1:334ade2:         private Value value;
1:e11ece1: 
1:e11ece1:         public KeyValueEntry(Key key, Value value) {
1:e11ece1:             this.key = key;
1:e11ece1:             this.value = value;
13:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public Key getKey() {
1:e11ece1:             return key;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public Value getValue() {
1:e11ece1:             return value;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public Value setValue(Value value) {
1:334ade2:             Value oldValue = this.value;
1:334ade2:             this.value = value;
1:334ade2:             return oldValue;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public String toString() {
1:e11ece1:             return "{" + key + ":" + value + "}";
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:f77b252:     private final class ListNodeIterator implements Iterator<ListNode<Key, Value>> {
1:e11ece1: 
1:e11ece1:         private final Transaction tx;
1:f77b252:         private final ListIndex<Key, Value> index;
1:f77b252:         ListNode<Key, Value> nextEntry;
1:e11ece1: 
1:f77b252:         private ListNodeIterator(Transaction tx, ListNode<Key, Value> current) {
1:e11ece1:             this.tx = tx;
1:e11ece1:             nextEntry = current;
1:bf59b7d:             index = current.getContainingList();
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public boolean hasNext() {
1:f77b252:             return nextEntry != null;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:f77b252:         public ListNode<Key, Value> next() {
1:f77b252:             ListNode<Key, Value> current = nextEntry;
1:f77b252:             if (current != null) {
1:bf59b7d:                 if (current.next != ListIndex.NOT_SET) {
1:e11ece1:                     try {
1:2b10259:                         nextEntry = index.loadNode(tx, current.next);
1:e11ece1:                     } catch (IOException unexpected) {
1:f77b252:                         IllegalStateException e = new IllegalStateException("failed to load next: " + current.next + ", reason: "
1:f77b252:                                 + unexpected.getLocalizedMessage());
1:e11ece1:                         e.initCause(unexpected);
1:e11ece1:                         throw e;
1:e11ece1:                     }
1:2b10259:                 } else {
1:e11ece1:                     nextEntry = null;
1:e11ece1:                 }
1:e11ece1:             }
1:e11ece1:             return current;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public void remove() {
2:e11ece1:             throw new UnsupportedOperationException();
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:334ade2:     final class ListIterator implements Iterator<Entry<Key, Value>> {
1:e11ece1: 
1:e11ece1:         private final Transaction tx;
1:f77b252:         private final ListIndex<Key, Value> targetList;
1:f77b252:         ListNode<Key, Value> currentNode, previousNode;
1:e11ece1:         KeyValueEntry<Key, Value> nextEntry;
1:bf59b7d:         KeyValueEntry<Key, Value> entryToRemove;
1:e11ece1: 
1:f77b252:         private ListIterator(Transaction tx, ListNode<Key, Value> current, long start) {
1:e11ece1:             this.tx = tx;
1:bf59b7d:             this.currentNode = current;
1:bf59b7d:             this.targetList = current.getContainingList();
2:e11ece1:             nextEntry = current.entries.getHead();
1:bf59b7d:             if (start > 0) {
1:bf59b7d:                 moveToRequestedStart(start);
1:bf59b7d:             }
1:e11ece1:         }
1:e11ece1: 
1:bf59b7d:         private void moveToRequestedStart(final long start) {
1:bf59b7d:             long count = 0;
1:bf59b7d:             while (hasNext() && count < start) {
1:bf59b7d:                 next();
1:bf59b7d:                 count++;
1:bf59b7d:             }
1:bf59b7d:             if (!hasNext()) {
1:bf59b7d:                 throw new NoSuchElementException("Index " + start + " out of current range: " + count);
1:bf59b7d:             }
1:bf59b7d:         }
1:bf59b7d: 
1:bf59b7d:         private KeyValueEntry<Key, Value> getFromNextNode() {
1:bf59b7d:             KeyValueEntry<Key, Value> result = null;
1:bf59b7d:             if (currentNode.getNext() != ListIndex.NOT_SET) {
1:e11ece1:                 try {
1:bf59b7d:                     previousNode = currentNode;
1:bf59b7d:                     currentNode = targetList.loadNode(tx, currentNode.getNext());
1:e11ece1:                 } catch (IOException unexpected) {
1:e11ece1:                     NoSuchElementException e = new NoSuchElementException(unexpected.getLocalizedMessage());
1:e11ece1:                     e.initCause(unexpected);
1:e11ece1:                     throw e;
1:e11ece1:                 }
1:bf59b7d:                 result = currentNode.entries.getHead();
1:e11ece1:             }
1:bf59b7d:             return result;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public boolean hasNext() {
1:bf59b7d:             if (nextEntry == null) {
2:bf59b7d:                 nextEntry = getFromNextNode();
1:bf59b7d:             }
1:bf59b7d:             return nextEntry != null;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public Entry<Key, Value> next() {
1:f77b252:             if (nextEntry != null) {
1:bf59b7d:                 entryToRemove = nextEntry;
1:bf59b7d:                 nextEntry = entryToRemove.getNext();
1:bf59b7d:                 return entryToRemove;
2:e11ece1:             } else {
1:e11ece1:                 throw new NoSuchElementException();
1:e11ece1:             }
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:e11ece1:         public void remove() {
1:bf59b7d:             if (entryToRemove == null) {
1:bf59b7d:                 throw new IllegalStateException("can only remove once, call hasNext();next() again");
1:e11ece1:             }
1:e11ece1:             try {
1:bf59b7d:                 entryToRemove.unlink();
1:d635a36: 
1:f77b252:                 ListNode<Key, Value> toRemoveNode = null;
1:bf59b7d:                 if (currentNode.entries.isEmpty()) {
1:bf59b7d:                     // may need to free this node
1:bf59b7d:                     if (currentNode.isHead() && currentNode.isTail()) {
1:bf59b7d:                         // store empty list
1:bf59b7d:                     } else if (currentNode.isHead()) {
1:f77b252:                         // merge next node into existing headNode as we don't want to
1:f77b252:                         // change our headPageId b/c that is our identity
1:f77b252:                         ListNode<Key, Value> headNode = currentNode;
1:1463bec:                         nextEntry = getFromNextNode(); // will move currentNode
1:1463bec: 
1:1463bec:                         if (currentNode.isTail()) {
1:1463bec:                             targetList.setTailPageId(headNode.getPageId());
1:1463bec:                         }
1:1463bec:                         // copy next/currentNode into head
1:1463bec:                         headNode.setEntries(currentNode.entries);
1:1463bec:                         headNode.setNext(currentNode.getNext());
1:1463bec:                         headNode.store(tx);
1:bf59b7d:                         toRemoveNode = currentNode;
1:1463bec:                         currentNode = headNode;
1:1463bec: 
1:bf59b7d:                     } else if (currentNode.isTail()) {
1:bf59b7d:                         toRemoveNode = currentNode;
1:bf59b7d:                         previousNode.setNext(ListIndex.NOT_SET);
1:bf59b7d:                         previousNode.store(tx);
1:bf59b7d:                         targetList.setTailPageId(previousNode.getPageId());
1:e11ece1:                     } else {
1:f77b252:                         toRemoveNode = currentNode;
1:f77b252:                         previousNode.setNext(toRemoveNode.getNext());
1:f77b252:                         previousNode.store(tx);
1:c73027d:                         currentNode = previousNode;
1:bf59b7d:                     }
1:bf59b7d:                 }
1:d635a36: 
1:734fb7d:                 targetList.onRemove(entryToRemove);
1:d635a36:                 entryToRemove = null;
1:bf59b7d: 
1:bf59b7d:                 if (toRemoveNode != null) {
1:bf59b7d:                     tx.free(toRemoveNode.getPage());
1:bf59b7d:                 } else {
1:bf59b7d:                     currentNode.store(tx);
1:bf59b7d:                 }
1:e11ece1:             } catch (IOException unexpected) {
1:5609826:                 IllegalStateException e = new IllegalStateException(unexpected.getLocalizedMessage());
1:e11ece1:                 e.initCause(unexpected);
1:e11ece1:                 throw e;
1:e11ece1:             }
1:e11ece1:         }
1:e11ece1: 
1:334ade2:         ListNode<Key, Value> getCurrent() {
1:334ade2:             return this.currentNode;
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     /**
1:e11ece1:      * The Marshaller is used to store and load the data in the ListNode into a Page.
1:e11ece1:      *
1:e11ece1:      * @param <Key>
1:e11ece1:      * @param <Value>
1:e11ece1:      */
1:f77b252:     static public final class NodeMarshaller<Key, Value> extends VariableMarshaller<ListNode<Key, Value>> {
1:bf59b7d:         private final Marshaller<Key> keyMarshaller;
1:bf59b7d:         private final Marshaller<Value> valueMarshaller;
1:e11ece1: 
1:bf59b7d:         public NodeMarshaller(Marshaller<Key> keyMarshaller, Marshaller<Value> valueMarshaller) {
1:bf59b7d:             this.keyMarshaller = keyMarshaller;
1:bf59b7d:             this.valueMarshaller = valueMarshaller;
1:e11ece1:         }
1:e11ece1: 
1:734fb7d:         @Override
1:f77b252:         public void writePayload(ListNode<Key, Value> node, DataOutput os) throws IOException {
1:2b10259:             os.writeLong(node.next);
1:f77b252:             short count = (short) node.entries.size(); // cast may truncate
1:f77b252:                                                        // value...
1:f77b252:             if (count != node.entries.size()) {
1:e11ece1:                 throw new IOException("short over flow, too many entries in list: " + node.entries.size());
1:e11ece1:             }
1:e11ece1: 
1:e11ece1:             os.writeShort(count);
1:e11ece1:             KeyValueEntry<Key, Value> entry = node.entries.getHead();
2:e11ece1:             while (entry != null) {
1:bf59b7d:                 keyMarshaller.writePayload((Key) entry.getKey(), os);
1:bf59b7d:                 valueMarshaller.writePayload((Value) entry.getValue(), os);
2:e11ece1:                 entry = entry.getNext();
1:e11ece1:             }
1:e11ece1:         }
1:e11ece1: 
1:e11ece1:         @Override
1:82e3be3:         @SuppressWarnings({ "unchecked", "rawtypes" })
1:f77b252:         public ListNode<Key, Value> readPayload(DataInput is) throws IOException {
1:f77b252:             ListNode<Key, Value> node = new ListNode<Key, Value>();
1:1463bec:             node.setNext(is.readLong());
1:e11ece1:             final short size = is.readShort();
1:e11ece1:             for (short i = 0; i < size; i++) {
1:f77b252:                 node.entries.addLast(new KeyValueEntry(keyMarshaller.readPayload(is), valueMarshaller.readPayload(is)));
1:e11ece1:             }
1:e11ece1:             return node;
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public Value put(Transaction tx, Key key, Value value) throws IOException {
1:e11ece1:         if (key == null) {
1:e11ece1:             throw new IllegalArgumentException("Key cannot be null");
1:e11ece1:         }
1:bf59b7d:         entries.addLast(new KeyValueEntry<Key, Value>(key, value));
1:2b10259:         store(tx, ADD_LAST);
1:e11ece1:         return null;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public Value addFirst(Transaction tx, Key key, Value value) throws IOException {
1:e11ece1:         if (key == null) {
1:e11ece1:             throw new IllegalArgumentException("Key cannot be null");
1:e11ece1:         }
1:bf59b7d:         entries.addFirst(new KeyValueEntry<Key, Value>(key, value));
1:2b10259:         store(tx, ADD_FIRST);
1:e11ece1:         return null;
1:e11ece1:     }
1:e11ece1: 
1:334ade2:     public void storeUpdate(Transaction tx) throws IOException {
1:be8e58b:         store(tx, ADD_LAST);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     private void store(Transaction tx, boolean addFirst) throws IOException {
1:e11ece1:         try {
1:be8e58b:             // keeping splitting till we get down to a single entry
1:be8e58b:             // then we need to overflow the value
1:be8e58b:             getContainingList().storeNode(tx, this, entries.size() == 1);
1:e11ece1: 
1:d2610fa:             if (this.next == -1) {
1:d2610fa:                 getContainingList().setTailPageId(getPageId());
1:e11ece1:             }
1:e11ece1: 
1:f77b252:         } catch (Transaction.PageOverflowIOException e) {
1:e11ece1:             // If we get an overflow
1:e11ece1:             split(tx, addFirst);
1:e11ece1:         }
1:e11ece1:     }
1:e11ece1: 
1:2b10259:     private void store(Transaction tx) throws IOException {
1:b24dfb9:         getContainingList().storeNode(tx, this, true);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     private void split(Transaction tx, boolean isAddFirst) throws IOException {
1:bf59b7d:         ListNode<Key, Value> extension = getContainingList().createNode(tx);
1:e11ece1:         if (isAddFirst) {
1:2b10259:             // head keeps the first entry, insert extension with the rest
1:2b10259:             extension.setEntries(entries.getHead().splitAfter());
1:e11ece1:             extension.setNext(this.getNext());
2:d2610fa:             extension.store(tx, isAddFirst);
1:e11ece1:             this.setNext(extension.getPageId());
1:e11ece1:         } else {
1:e11ece1:             extension.setEntries(entries.getTail().getPrevious().splitAfter());
1:be8e58b:             extension.setNext(this.getNext());
1:e11ece1:             extension.store(tx, isAddFirst);
1:bf59b7d:             getContainingList().setTailPageId(extension.getPageId());
1:e11ece1:             this.setNext(extension.getPageId());
1:e11ece1:         }
2:e11ece1:         store(tx, true);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     // called after a split
1:e11ece1:     private void setEntries(LinkedNodeList<KeyValueEntry<Key, Value>> list) {
1:e11ece1:         this.entries = list;
1:e11ece1:     }
1:e11ece1: 
1:bf59b7d:     public Value get(Transaction tx, Key key) {
1:e11ece1:         if (key == null) {
1:e11ece1:             throw new IllegalArgumentException("Key cannot be null");
1:e11ece1:         }
2:e11ece1:         Value result = null;
1:e11ece1:         KeyValueEntry<Key, Value> nextEntry = entries.getTail();
1:e11ece1:         while (nextEntry != null) {
1:e11ece1:             if (nextEntry.getKey().equals(key)) {
1:f77b252:                 result = nextEntry.getValue();
2:e11ece1:                 break;
1:e11ece1:             }
1:e11ece1:             nextEntry = nextEntry.getPrevious();
1:e11ece1:         }
2:e11ece1:         return result;
1:e11ece1:     }
1:e11ece1: 
1:f77b252:     public boolean isEmpty(final Transaction tx) {
1:e11ece1:         return entries.isEmpty();
1:e11ece1:     }
1:e11ece1: 
1:f77b252:     public Entry<Key, Value> getFirst(Transaction tx) {
1:e11ece1:         return entries.getHead();
1:e11ece1:     }
1:e11ece1: 
1:f77b252:     public Entry<Key, Value> getLast(Transaction tx) {
1:e11ece1:         return entries.getTail();
1:e11ece1:     }
1:e11ece1: 
1:f77b252:     public Iterator<Entry<Key, Value>> iterator(final Transaction tx, long pos) throws IOException {
1:e11ece1:         return new ListIterator(tx, this, pos);
1:e11ece1:     }
1:e11ece1: 
1:f77b252:     public Iterator<Entry<Key, Value>> iterator(final Transaction tx) throws IOException {
1:e11ece1:         return new ListIterator(tx, this, 0);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     Iterator<ListNode<Key, Value>> listNodeIterator(final Transaction tx) throws IOException {
1:e11ece1:         return new ListNodeIterator(tx, this);
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public void clear(Transaction tx) throws IOException {
1:e11ece1:         entries.clear();
1:e11ece1:         tx.free(this.getPageId());
1:e11ece1:     }
1:e11ece1: 
1:bf59b7d:     public boolean contains(Transaction tx, Key key) {
1:e11ece1:         if (key == null) {
1:e11ece1:             throw new IllegalArgumentException("Key cannot be null");
1:e11ece1:         }
1:e11ece1:         boolean found = false;
1:e11ece1:         KeyValueEntry<Key, Value> nextEntry = entries.getTail();
1:e11ece1:         while (nextEntry != null) {
1:e11ece1:             if (nextEntry.getKey().equals(key)) {
1:e11ece1:                 found = true;
1:e11ece1:                 break;
1:e11ece1:             }
1:e11ece1:             nextEntry = nextEntry.getPrevious();
1:e11ece1:         }
1:e11ece1:         return found;
1:e11ece1:     }
1:e11ece1: 
1:f77b252:     // /////////////////////////////////////////////////////////////////
1:e11ece1:     // Implementation methods
1:f77b252:     // /////////////////////////////////////////////////////////////////
1:e11ece1: 
1:e11ece1:     public long getPageId() {
1:e11ece1:         return page.getPageId();
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public Page<ListNode<Key, Value>> getPage() {
1:e11ece1:         return page;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public void setPage(Page<ListNode<Key, Value>> page) {
1:e11ece1:         this.page = page;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public long getNext() {
1:e11ece1:         return next;
1:e11ece1:     }
1:e11ece1: 
1:e11ece1:     public void setNext(long next) {
1:e11ece1:         this.next = next;
1:e11ece1:     }
1:bf59b7d: 
1:bf59b7d:     public void setContainingList(ListIndex<Key, Value> list) {
1:bf59b7d:         this.containingList = list;
1:bf59b7d:     }
1:bf59b7d: 
1:f77b252:     public ListIndex<Key, Value> getContainingList() {
1:bf59b7d:         return containingList;
1:bf59b7d:     }
1:bf59b7d: 
1:bf59b7d:     public boolean isHead() {
1:bf59b7d:         return getPageId() == containingList.getHeadPageId();
1:bf59b7d:     }
1:bf59b7d: 
1:bf59b7d:     public boolean isTail() {
1:bf59b7d:         return getPageId() == containingList.getTailPageId();
1:bf59b7d:     }
1:bf59b7d: 
1:bf59b7d:     public int size(Transaction tx) {
1:bf59b7d:         return entries.size();
1:bf59b7d:     }
1:bf59b7d: 
1:e11ece1:     @Override
1:e11ece1:     public String toString() {
1:f77b252:         return "[ListNode(" + (page != null ? page.getPageId() + "->" + next : "null") + ")[" + entries.size() + "]]";
1:e11ece1:     }
1:e11ece1: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:d635a36
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                 entryToRemove = null;
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                 targetList.onRemove(entryToRemove);
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
author:Gary Tully
-------------------------------------------------------------------------------
commit:c73027d
/////////////////////////////////////////////////////////////////////////
1:                         currentNode = previousNode;
commit:be8e58b
/////////////////////////////////////////////////////////////////////////
1:         store(tx, ADD_LAST);
1:             // keeping splitting till we get down to a single entry
1:             // then we need to overflow the value
1:             getContainingList().storeNode(tx, this, entries.size() == 1);
/////////////////////////////////////////////////////////////////////////
1:             extension.setNext(this.getNext());
commit:b24dfb9
/////////////////////////////////////////////////////////////////////////
1:         getContainingList().storeNode(tx, this, true);
/////////////////////////////////////////////////////////////////////////
0:         getContainingList().storeNode(tx, this, true);
commit:1463bec
/////////////////////////////////////////////////////////////////////////
0:                         // merge next node into existing headNode
0:                         // as we don't want to change our headPageId b/c
0:                         // that is our identity
0:                         ListNode<Key,Value> headNode = currentNode;
1:                         nextEntry = getFromNextNode(); // will move currentNode
1: 
1:                         if (currentNode.isTail()) {
1:                             targetList.setTailPageId(headNode.getPageId());
1:                         }
1:                         // copy next/currentNode into head
1:                         headNode.setEntries(currentNode.entries);
1:                         headNode.setNext(currentNode.getNext());
1:                         headNode.store(tx);
1:                         currentNode = headNode;
1: 
/////////////////////////////////////////////////////////////////////////
1:             node.setNext(is.readLong());
commit:bf59b7d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.util.Marshaller;
/////////////////////////////////////////////////////////////////////////
0:     private ListIndex<Key,Value> containingList;
1:     private LinkedNodeList<KeyValueEntry<Key, Value>> entries = new LinkedNodeList<KeyValueEntry<Key, Value>>() {
1: 
1:         @Override
1:         public String toString() {
1:             return "PageId:" + page.getPageId() + ", index:" + containingList + super.toString();
1:         }
1:     };
1:     private long next = ListIndex.NOT_SET;
/////////////////////////////////////////////////////////////////////////
0:         private final ListIndex<Key,Value> index;
0:         private ListNodeIterator(Transaction tx, ListNode<Key,Value> current) {
1:             index = current.getContainingList();
/////////////////////////////////////////////////////////////////////////
0:             if( current !=null ) {
1:                 if (current.next != ListIndex.NOT_SET) {
/////////////////////////////////////////////////////////////////////////
0:         private final ListIndex<Key,Value> targetList;
0:         ListNode<Key,Value> currentNode, previousNode;
1:         KeyValueEntry<Key, Value> entryToRemove;
0:         private ListIterator(Transaction tx, ListNode<Key,Value> current, long start) {
1:             this.currentNode = current;
1:             this.targetList = current.getContainingList();
1:             if (start > 0) {
1:                 moveToRequestedStart(start);
1:         }
1:         private void moveToRequestedStart(final long start) {
1:             long count = 0;
1:             while (hasNext() && count < start) {
1:                 next();
1:                 count++;
1:             }
1:             if (!hasNext()) {
1:                 throw new NoSuchElementException("Index " + start + " out of current range: " + count);
1:             }
1:         }
1: 
1:         private KeyValueEntry<Key, Value> getFromNextNode() {
1:             KeyValueEntry<Key, Value> result = null;
1:             if (currentNode.getNext() != ListIndex.NOT_SET) {
1:                     previousNode = currentNode;
1:                     currentNode = targetList.loadNode(tx, currentNode.getNext());
1:                 result = currentNode.entries.getHead();
1:             return result;
1:             if (nextEntry == null) {
1:                 nextEntry = getFromNextNode();
1:             }
1:             return nextEntry != null;
1:                 entryToRemove = nextEntry;
1:                 nextEntry = entryToRemove.getNext();
1:                 return entryToRemove;
1:             if (entryToRemove == null) {
1:                 throw new IllegalStateException("can only remove once, call hasNext();next() again");
1:                 entryToRemove.unlink();
0:                 entryToRemove = null;
0:                 ListNode<Key,Value> toRemoveNode = null;
1:                 if (currentNode.entries.isEmpty()) {
1:                     // may need to free this node
1:                     if (currentNode.isHead() && currentNode.isTail()) {
1:                         // store empty list
1:                     } else if (currentNode.isHead()) {
0:                         // new head
1:                         toRemoveNode = currentNode;
1:                         nextEntry = getFromNextNode();
0:                         targetList.setHeadPageId(currentNode.getPageId());
1:                     } else if (currentNode.isTail()) {
1:                         toRemoveNode = currentNode;
1:                         previousNode.setNext(ListIndex.NOT_SET);
1:                         previousNode.store(tx);
1:                         targetList.setTailPageId(previousNode.getPageId());
1:                     }
1:                 }
0:                 targetList.onRemove();
1: 
1:                 if (toRemoveNode != null) {
1:                     tx.free(toRemoveNode.getPage());
1:                 } else {
1:                     currentNode.store(tx);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:     static public final class NodeMarshaller<Key,Value> extends VariableMarshaller<ListNode<Key,Value>> {
1:         private final Marshaller<Key> keyMarshaller;
1:         private final Marshaller<Value> valueMarshaller;
1:         public NodeMarshaller(Marshaller<Key> keyMarshaller, Marshaller<Value> valueMarshaller) {
1:             this.keyMarshaller = keyMarshaller;
1:             this.valueMarshaller = valueMarshaller;
/////////////////////////////////////////////////////////////////////////
1:                 keyMarshaller.writePayload((Key) entry.getKey(), os);
1:                 valueMarshaller.writePayload((Value) entry.getValue(), os);
0:             ListNode<Key,Value> node = new ListNode<Key,Value>();
0:                         new KeyValueEntry(keyMarshaller.readPayload(is),
0:                                                      valueMarshaller.readPayload(is)));
1:         entries.addLast(new KeyValueEntry<Key, Value>(key, value));
/////////////////////////////////////////////////////////////////////////
1:         entries.addFirst(new KeyValueEntry<Key, Value>(key, value));
0:             getContainingList().storeNode(tx, this, false);
/////////////////////////////////////////////////////////////////////////
0:         getContainingList().storeNode(tx, this, false);
1:         ListNode<Key, Value> extension = getContainingList().createNode(tx);
1:             getContainingList().setTailPageId(extension.getPageId());
0:         store(tx);
/////////////////////////////////////////////////////////////////////////
1:     public Value get(Transaction tx, Key key) {
/////////////////////////////////////////////////////////////////////////
0:     public boolean isEmpty(final Transaction tx)  {
0:     public Entry<Key,Value> getFirst(Transaction tx) {
0:     public Entry<Key,Value> getLast(Transaction tx) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean contains(Transaction tx, Key key) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setContainingList(ListIndex<Key, Value> list) {
1:         this.containingList = list;
1:     }
1: 
0:     public ListIndex<Key,Value> getContainingList() {
1:         return containingList;
1:     }
1: 
1:     public boolean isHead() {
1:         return getPageId() == containingList.getHeadPageId();
1:     }
1: 
1:     public boolean isTail() {
1:         return getPageId() == containingList.getTailPageId();
1:     }
1: 
1:     public int size(Transaction tx) {
1:         return entries.size();
1:     }
1: 
0:         return "[ListNode(" + (page != null ?  page.getPageId() + "->" + next : "null") + ")[" + entries.size() + "]]";
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1:     private final static boolean ADD_FIRST = true;
1:     private final static boolean ADD_LAST = false;
0:     private final static long NOT_SET = -1;
1: 
0:     private long next = NOT_SET;
/////////////////////////////////////////////////////////////////////////
0:                 if (nextEntry.next != NOT_SET) {
1:                         nextEntry = index.loadNode(tx, current.next);
/////////////////////////////////////////////////////////////////////////
0:         ListNode<Key,Value> current, prev;
0:         private ListIterator(Transaction tx, ListNode<Key,Value> current, long nextIndex) throws IOException {
0:             if (nextIndex > 0 && nextEntry != null) {
0:                 for (long i=0; i<nextIndex; i++) {
/////////////////////////////////////////////////////////////////////////
0:             if (current.getNext() != NOT_SET) {
0:                     prev = current;
0:                     current = index.loadNode(tx, current.getNext());
/////////////////////////////////////////////////////////////////////////
0:                 doRemove(tx, current, prev, toRemove);
/////////////////////////////////////////////////////////////////////////
1:             os.writeLong(node.next);
/////////////////////////////////////////////////////////////////////////
0:             node.next = is.readLong();
/////////////////////////////////////////////////////////////////////////
0:     private void doRemove(final Transaction tx, final ListNode current, final ListNode prev, KeyValueEntry<Key, Value> entry) throws IOException {
0:                     if (current.getNext() != NOT_SET) {
1:                     } else {
0:                         //  store current in empty state
0:                         store(tx);
0:                     prev.setNext(current.next);
0:                     index.storeNode(tx, prev, false);
0:             store(tx);
/////////////////////////////////////////////////////////////////////////
1:         store(tx, ADD_LAST);
/////////////////////////////////////////////////////////////////////////
1:         store(tx, ADD_FIRST);
0:             index.storeNode(tx, this, false);
1:     private void store(Transaction tx) throws IOException {
0:         index.storeNode(tx, this, false);
0:         ListNode<Key, Value> extension = index.createNode(tx);
1:             // head keeps the first entry, insert extension with the rest
1:             extension.setEntries(entries.getHead().splitAfter());
/////////////////////////////////////////////////////////////////////////
0:     public Iterator<Entry<Key,Value>> iterator(final Transaction tx, long pos) throws IOException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return "[ListNode(" + page.getPageId() + "->" + next + ") " + entries.toString() + "]";
commit:5609826
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         IllegalStateException e = new IllegalStateException("failed to load next: " + current.next + ", reason: " + unexpected.getLocalizedMessage());
/////////////////////////////////////////////////////////////////////////
0:                 throw new IllegalStateException("can only remove once, call next again");
1:                 IllegalStateException e = new IllegalStateException(unexpected.getLocalizedMessage());
commit:e11ece1
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.kahadb.index;
1: 
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
0: import java.io.PrintWriter;
0: import java.util.ArrayList;
0: import java.util.Arrays;
1: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.List;
0: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.NoSuchElementException;
0: import javax.swing.plaf.basic.BasicInternalFrameTitlePane;
0: import org.apache.kahadb.index.BTreeIndex.Prefixer;
0: import org.apache.kahadb.page.Page;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.util.LinkedNode;
0: import org.apache.kahadb.util.LinkedNodeList;
0: import org.apache.kahadb.util.VariableMarshaller;
0: import sun.plugin.dom.exception.InvalidStateException;
0: import sun.tools.tree.ReturnStatement;
0: import sun.util.resources.CurrencyNames_th_TH;
1: 
1: /**
0:  * The ListNode class represents a node in the List object graph.  It is stored in
0:  * one overflowing Page of a PageFile.
1:  */
0: public final class ListNode<Key,Value> {
1: 
1:     // The index that this node is part of.
0:     private final ListIndex<Key,Value> index;
0:     // The parent node or null if this is the root node of the List
0:     private ListNode<Key,Value> parent;
1:     // The page associated with this node
0:     private Page<ListNode<Key,Value>> page;
1: 
0:     protected LinkedNodeList<KeyValueEntry<Key, Value>> entries = new LinkedNodeList<KeyValueEntry<Key, Value>>();
1: 
1:     // The next page after this one.
0:     private long next = -1;
1: 
0:     public int size(Transaction tx) {
0:         return entries.size();
1:     }
1: 
0:     static final class KeyValueEntry<Key, Value> extends LinkedNode<KeyValueEntry<Key, Value>> implements Entry<Key, Value>
0:     {
1:         private final Key key;
0:         private final Value value;
1: 
1:         public KeyValueEntry(Key key, Value value) {
1:             this.key = key;
1:             this.value = value;
1:         }
1: 
1:         public Key getKey() {
1:             return key;
1:         }
1: 
1:         public Value getValue() {
1:             return value;
1:         }
1: 
1:         public Value setValue(Value value) {
1:             throw new UnsupportedOperationException();
1:         }
1: 
1:         @Override
1:         public String toString() {
1:             return "{" + key + ":" + value + "}";
1:         }
1:     }
1: 
0:     private final class ListNodeIterator implements Iterator<ListNode<Key,Value>> {
1: 
1:         private final Transaction tx;
0:         ListNode<Key,Value> nextEntry;
1: 
0:         private ListNodeIterator(Transaction tx, ListNode<Key,Value> current) throws IOException {
1:             this.tx = tx;
1:             nextEntry = current;
1:         }
1: 
1:         public boolean hasNext() {
0:             return nextEntry !=null;
1:         }
1: 
0:         public ListNode<Key,Value> next() {
0:             ListNode<Key,Value> current = nextEntry;
0:             if( nextEntry !=null ) {
0:                 if (nextEntry.next != -1) {
1:                     try {
0:                         nextEntry = index.loadNode(tx, current.next, current);
1:                     } catch (IOException unexpected) {
0:                         InvalidStateException e = new InvalidStateException("failed to load next: " + current.next + ", reason: " + unexpected.getLocalizedMessage());
1:                         e.initCause(unexpected);
1:                         throw e;
1:                     }
1:                 } else {
1:                     nextEntry = null;
1:                 }
1:             }
1:             return current;
1:         }
1: 
1:         public void remove() {
1:             throw new UnsupportedOperationException();
1:         }
1:     }
1: 
0:     private final class ListIterator implements Iterator<Entry<Key, Value>> {
1: 
1:         private final Transaction tx;
0:         ListNode<Key,Value> current;
1:         KeyValueEntry<Key, Value> nextEntry;
0:         KeyValueEntry<Key, Value>  toRemove;
1: 
0:         private ListIterator(Transaction tx, ListNode<Key,Value> current, int nextIndex) throws IOException {
1:             this.tx = tx;
0:             this.current = current;
1:             nextEntry = current.entries.getHead();
0:             if (nextIndex > 0) {
0:                 for (int i=0; i<nextIndex; i++) {
0:                     nextEntry = nextEntry.getNext();
0:                     if (nextEntry == null) {
0:                         if (!nextFromNextListNode())
0:                             throw new NoSuchElementException("Index out of range: " + nextIndex);
1:                         }
1:                     }
1:                 }
1:             }
1: 
0:         private boolean nextFromNextListNode() {
0:             boolean haveNext = false;
0:             if (current.getNext() != -1) {
1:                 try {
0:                     current = index.loadNode(tx, current.getNext(), current);
1:                 } catch (IOException unexpected) {
1:                     NoSuchElementException e = new NoSuchElementException(unexpected.getLocalizedMessage());
1:                     e.initCause(unexpected);
1:                     throw e;
1:                 }
1:                 nextEntry = current.entries.getHead();
0:                 haveNext = nextEntry != null;
1:             }
0:             return haveNext;
1:         }
1: 
1:         public boolean hasNext() {
0:             return nextEntry !=null || nextFromNextListNode();
1:         }
1: 
1:         public Entry<Key, Value> next() {
0:             if( nextEntry !=null ) {
0:                 toRemove = nextEntry;
0:                 nextEntry=toRemove.getNext();
0:                 return toRemove;
1:             } else {
1:                 throw new NoSuchElementException();
1:             }
1:         }
1: 
1:         public void remove() {
0:             if (toRemove == null) {
0:                 throw new InvalidStateException("can only remove once, call next again");
1:             }
1:             try {
0:                 doRemove(tx, current, toRemove);
0:                 index.onRemove();
0:                 toRemove = null;
1:             } catch (IOException unexpected) {
0:                 InvalidStateException e = new InvalidStateException(unexpected.getLocalizedMessage());
1:                 e.initCause(unexpected);
1:                 throw e;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * The Marshaller is used to store and load the data in the ListNode into a Page.
1:      *
1:      * @param <Key>
1:      * @param <Value>
1:      */
0:     static public class Marshaller<Key,Value> extends VariableMarshaller<ListNode<Key,Value>> {
0:         private final ListIndex<Key,Value> index;
1: 
0:         public Marshaller(ListIndex<Key,Value> index) {
0:             this.index = index;
1:         }
1: 
0:         public void writePayload(ListNode<Key,Value> node, DataOutput os) throws IOException {
0:             // Write the keys
0:             short count = (short)node.entries.size(); // cast may truncate value...
0:             if( count != node.entries.size() ) {
1:                 throw new IOException("short over flow, too many entries in list: " + node.entries.size());
1:             }
1: 
1:             os.writeShort(count);
1:             KeyValueEntry<Key, Value> entry = node.entries.getHead();
1:             while (entry != null) {
0:                 index.getKeyMarshaller().writePayload((Key) entry.getKey(), os);
0:                 index.getValueMarshaller().writePayload((Value) entry.getValue(), os);
1:                 entry = entry.getNext();
1:             }
1:         }
1: 
0:         @SuppressWarnings("unchecked")
0:         public ListNode<Key,Value> readPayload(DataInput is) throws IOException {
0:             ListNode<Key,Value> node = new ListNode<Key,Value>(index);
1:             final short size = is.readShort();
1:             for (short i = 0; i < size; i++) {
0:                 node.entries.addLast(
0:                         new KeyValueEntry(index.getKeyMarshaller().readPayload(is),
0:                                                      index.getValueMarshaller().readPayload(is)));
1:             }
1:             return node;
1:         }
1:     }
1: 
0:     public ListNode(ListIndex<Key, Value> index) {
0:         this.index = index;
1:     }
1: 
0:     public void setEmpty() {
1:     }
1: 
0:     public Value remove(Transaction tx, Key key) throws IOException {
1:         Value result = null;
0:         KeyValueEntry<Key, Value> entry = entries.getHead();
1:         while (entry != null) {
0:             if (entry.getKey().equals(key)) {
0:                  result = entry.getValue();
0:                  doRemove(tx, this, entry);
1:                  break;
1:             }
1:             entry = entry.getNext();
1:         }
1:         return result;
1:     }
1: 
0:     private void doRemove(Transaction tx, ListNode current, KeyValueEntry<Key, Value> entry) throws IOException {
0:         entry.unlink();
0:         if (current.entries.isEmpty()) {
0:                 if (current.getPageId() == index.getHeadPageId()) {
0:                     if (current.getNext() != -1) {
0:                         // new head
0:                         index.setHeadPageId(current.getNext());
0:                         tx.free(current.getPageId());
1:                     }
1:                 } else {
0:                     // need to unlink the node
0:                     current.parent.setNext(current.getNext());
0:                     tx.free(current.getPageId());
0:                     index.storeNode(tx, current.parent, false);
1:                 }
1:         } else {
1:             store(tx, true);
1:         }
1:     }
1: 
1:     public Value put(Transaction tx, Key key, Value value) throws IOException {
1:         if (key == null) {
1:             throw new IllegalArgumentException("Key cannot be null");
1:         }
0:         entries.addLast(new KeyValueEntry(key, value));
0:         store(tx, false);
1:         return null;
1:     }
1: 
1:     public Value addFirst(Transaction tx, Key key, Value value) throws IOException {
1:         if (key == null) {
1:             throw new IllegalArgumentException("Key cannot be null");
1:         }
0:         entries.addFirst(new KeyValueEntry(key, value));
1:         store(tx, true);
1:         return null;
1:     }
1: 
1:     private void store(Transaction tx, boolean addFirst) throws IOException {
1:         try {
0:             index.storeNode(tx, this, allowOverflow());
0:         } catch ( Transaction.PageOverflowIOException e ) {
1:                 // If we get an overflow
1:                 split(tx, addFirst);
1:         }
1:     }
1: 
0:     private boolean allowOverflow() {
0:         return false;
1:     }
1: 
1:     private void split(Transaction tx, boolean isAddFirst) throws IOException {
0:         ListNode<Key, Value> extension = index.createNode(tx, this);
1:         if (isAddFirst) {
0:             extension.setEntries(entries.getHead().splitAfter());
1:             extension.setNext(this.getNext());
1:             this.setNext(extension.getPageId());
0:         }  else {
0:             index.setTailPageId(extension.getPageId());
1:             this.setNext(extension.getPageId());
1:             extension.setEntries(entries.getTail().getPrevious().splitAfter());
1:         }
0:         index.storeNode(tx, this, false);
1:         extension.store(tx, isAddFirst);
1:     }
1: 
1:     // called after a split
1:     private void setEntries(LinkedNodeList<KeyValueEntry<Key, Value>> list) {
1:         this.entries = list;
1:     }
1: 
0:     public Value get(Transaction tx, Key key) throws IOException {
1:         if (key == null) {
1:             throw new IllegalArgumentException("Key cannot be null");
1:         }
1:         Value result = null;
1:         KeyValueEntry<Key, Value> nextEntry = entries.getTail();
1:         while (nextEntry != null) {
1:             if (nextEntry.getKey().equals(key)) {
0:                 result =  nextEntry.getValue();
1:                 break;
1:             }
1:             nextEntry = nextEntry.getPrevious();
1:         }
1:         return result;
1:     }
1: 
0:     public boolean isEmpty(final Transaction tx) throws IOException {
1:         return entries.isEmpty();
1:     }
1: 
0:     public Entry<Key,Value> getFirst(Transaction tx) throws IOException {
1:         return entries.getHead();
1:     }
1: 
0:     public Entry<Key,Value> getLast(Transaction tx) throws IOException {
1:         return entries.getTail();
1:     }
1: 
0:     public Iterator<Entry<Key,Value>> iterator(final Transaction tx, int pos) throws IOException {
1:         return new ListIterator(tx, this, pos);
1:     }
1: 
0:     public Iterator<Entry<Key,Value>> iterator(final Transaction tx) throws IOException {
1:         return new ListIterator(tx, this, 0);
1:     }
1: 
1:     Iterator<ListNode<Key, Value>> listNodeIterator(final Transaction tx) throws IOException {
1:         return new ListNodeIterator(tx, this);
1:     }
1: 
1:     public void clear(Transaction tx) throws IOException {
1:         entries.clear();
1:         tx.free(this.getPageId());
1:     }
1: 
0:     public boolean contains(Transaction tx, Key key) throws IOException {
1:         if (key == null) {
1:             throw new IllegalArgumentException("Key cannot be null");
1:         }
1:         boolean found = false;
1:         KeyValueEntry<Key, Value> nextEntry = entries.getTail();
1:         while (nextEntry != null) {
1:             if (nextEntry.getKey().equals(key)) {
1:                 found = true;
1:                 break;
1:             }
1:             nextEntry = nextEntry.getPrevious();
1:         }
1:         return found;
1:     }
1: 
0:     ///////////////////////////////////////////////////////////////////
1:     // Implementation methods
0:     ///////////////////////////////////////////////////////////////////
1:  
1:     public long getPageId() {
1:         return page.getPageId();
1:     }
1: 
0:     public ListNode<Key, Value> getParent() {
0:         return parent;
1:     }
1: 
0:     public void setParent(ListNode<Key, Value> parent) {
0:         this.parent = parent;
1:     }
1: 
1:     public Page<ListNode<Key, Value>> getPage() {
1:         return page;
1:     }
1: 
1:     public void setPage(Page<ListNode<Key, Value>> page) {
1:         this.page = page;
1:     }
1: 
1:     public long getNext() {
1:         return next;
1:     }
1: 
1:     public void setNext(long next) {
1:         this.next = next;
1:     }
1:     
1:     @Override
1:     public String toString() {
0:         return "[ListNode "+ entries.toString() + "]";
1:     }
1: }
1: 
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.disk.index;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.page.Page;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1: import org.apache.activemq.store.kahadb.disk.util.LinkedNode;
1: import org.apache.activemq.store.kahadb.disk.util.LinkedNodeList;
1: import org.apache.activemq.store.kahadb.disk.util.Marshaller;
1: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
commit:715010a
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:f77b252
/////////////////////////////////////////////////////////////////////////
1:  * The ListNode class represents a node in the List object graph. It is stored
1:  * in one overflowing Page of a PageFile.
1: public final class ListNode<Key, Value> {
0: 
1:     private ListIndex<Key, Value> containingList;
1:     private Page<ListNode<Key, Value>> page;
/////////////////////////////////////////////////////////////////////////
1:     static final class KeyValueEntry<Key, Value> extends LinkedNode<KeyValueEntry<Key, Value>> implements Entry<Key, Value> {
0: 
/////////////////////////////////////////////////////////////////////////
1:     private final class ListNodeIterator implements Iterator<ListNode<Key, Value>> {
1:         private final ListIndex<Key, Value> index;
1:         ListNode<Key, Value> nextEntry;
1:         private ListNodeIterator(Transaction tx, ListNode<Key, Value> current) {
1:             return nextEntry != null;
1:         public ListNode<Key, Value> next() {
1:             ListNode<Key, Value> current = nextEntry;
1:             if (current != null) {
1:                         IllegalStateException e = new IllegalStateException("failed to load next: " + current.next + ", reason: "
1:                                 + unexpected.getLocalizedMessage());
/////////////////////////////////////////////////////////////////////////
1:         private final ListIndex<Key, Value> targetList;
1:         ListNode<Key, Value> currentNode, previousNode;
1:         private ListIterator(Transaction tx, ListNode<Key, Value> current, long start) {
/////////////////////////////////////////////////////////////////////////
1:             if (nextEntry != null) {
/////////////////////////////////////////////////////////////////////////
1:                 ListNode<Key, Value> toRemoveNode = null;
1:                         // merge next node into existing headNode as we don't want to
1:                         // change our headPageId b/c that is our identity
1:                         ListNode<Key, Value> headNode = currentNode;
/////////////////////////////////////////////////////////////////////////
0:                     } else {
1:                         toRemoveNode = currentNode;
1:                         previousNode.setNext(toRemoveNode.getNext());
1:                         previousNode.store(tx);
/////////////////////////////////////////////////////////////////////////
1:     static public final class NodeMarshaller<Key, Value> extends VariableMarshaller<ListNode<Key, Value>> {
/////////////////////////////////////////////////////////////////////////
1:         public void writePayload(ListNode<Key, Value> node, DataOutput os) throws IOException {
1:             short count = (short) node.entries.size(); // cast may truncate
1:                                                        // value...
1:             if (count != node.entries.size()) {
/////////////////////////////////////////////////////////////////////////
1:         public ListNode<Key, Value> readPayload(DataInput is) throws IOException {
1:             ListNode<Key, Value> node = new ListNode<Key, Value>();
1:                 node.entries.addLast(new KeyValueEntry(keyMarshaller.readPayload(is), valueMarshaller.readPayload(is)));
/////////////////////////////////////////////////////////////////////////
1:         } catch (Transaction.PageOverflowIOException e) {
0:             // When we split to a node of one element we can span multiple pages for that
0:             // entry, otherwise we keep the entries on one page to avoid fragmented reads
0:             // and segment the list traversal.
/////////////////////////////////////////////////////////////////////////
0:         } catch (Transaction.PageOverflowIOException e) {
/////////////////////////////////////////////////////////////////////////
0:         } else {
/////////////////////////////////////////////////////////////////////////
1:                 result = nextEntry.getValue();
/////////////////////////////////////////////////////////////////////////
1:     public boolean isEmpty(final Transaction tx) {
1:     public Entry<Key, Value> getFirst(Transaction tx) {
1:     public Entry<Key, Value> getLast(Transaction tx) {
1:     public Iterator<Entry<Key, Value>> iterator(final Transaction tx, long pos) throws IOException {
1:     public Iterator<Entry<Key, Value>> iterator(final Transaction tx) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     // /////////////////////////////////////////////////////////////////
1:     // /////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public ListIndex<Key, Value> getContainingList() {
/////////////////////////////////////////////////////////////////////////
1:         return "[ListNode(" + (page != null ? page.getPageId() + "->" + next : "null") + ")[" + entries.size() + "]]";
commit:d2610fa
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:             if (this.next == -1) {
1:                 getContainingList().setTailPageId(getPageId());
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:             extension.setNext(this.getNext());
1:             extension.store(tx, isAddFirst);
0:         }  else {
1:             extension.store(tx, isAddFirst);
0:             this.setNext(extension.getPageId());
commit:334ade2
/////////////////////////////////////////////////////////////////////////
1:         private Value value;
/////////////////////////////////////////////////////////////////////////
1:             Value oldValue = this.value;
1:             this.value = value;
1:             return oldValue;
/////////////////////////////////////////////////////////////////////////
1:     final class ListIterator implements Iterator<Entry<Key, Value>> {
/////////////////////////////////////////////////////////////////////////
0: 
1:         ListNode<Key, Value> getCurrent() {
1:             return this.currentNode;
0:         }
/////////////////////////////////////////////////////////////////////////
1:     public void storeUpdate(Transaction tx) throws IOException {
0:         try {
0:             if (this.entries.size() == 1) {
0:                 getContainingList().storeNode(tx, this, true);
0:             } else {
0:                 getContainingList().storeNode(tx, this, false);
0:             }
0:         } catch ( Transaction.PageOverflowIOException e ) {
0:             split(tx, ADD_FIRST);
0:         }
0:     }
0: 
0:             // When we split to a node of one element we can span multiple
0:             // pages for that entry, otherwise we keep the entries on one
0:             // page to avoid fragmented reads and segment the list traversal.
0:             if (this.entries.size() == 1) {
0:                 getContainingList().storeNode(tx, this, true);
0:             } else {
0:                 getContainingList().storeNode(tx, this, false);
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (this.entries.size() == 1) {
0:             getContainingList().storeNode(tx, this, true);
0:         } else {
0:             getContainingList().storeNode(tx, this, false);
0:         }
/////////////////////////////////////////////////////////////////////////
0:         store(tx, true);
commit:82e3be3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings({ "unchecked", "rawtypes" })
/////////////////////////////////////////////////////////////////////////
0:             // If we get an overflow
0:             split(tx, addFirst);
/////////////////////////////////////////////////////////////////////////
0: 
============================================================================