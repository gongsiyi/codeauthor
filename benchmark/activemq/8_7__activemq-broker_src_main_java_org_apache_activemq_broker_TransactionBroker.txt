1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker;
7:d29ca2a: 
1:d29ca2a: 
1:74a7a8b: import java.util.ArrayList;
1:74a7a8b: import java.util.Iterator;
1:74a7a8b: import java.util.LinkedHashMap;
1:ecf89a6: import java.util.List;
1:74a7a8b: import java.util.Map;
1:86cbdfd: import java.util.concurrent.ConcurrentHashMap;
1:d29ca2a: 
1:74a7a8b: import javax.jms.JMSException;
1:74a7a8b: import javax.transaction.xa.XAException;
1:74a7a8b: 
1:1d242a2: import org.apache.activemq.broker.jmx.ManagedRegionBroker;
1:101e711: import org.apache.activemq.broker.region.Destination;
1:101e711: import org.apache.activemq.command.ActiveMQDestination;
1:101e711: import org.apache.activemq.command.BaseCommand;
1:d29ca2a: import org.apache.activemq.command.ConnectionInfo;
1:d29ca2a: import org.apache.activemq.command.LocalTransactionId;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:7bd8fb6: import org.apache.activemq.command.ProducerInfo;
1:d29ca2a: import org.apache.activemq.command.TransactionId;
1:d29ca2a: import org.apache.activemq.command.XATransactionId;
1:7bd8fb6: import org.apache.activemq.state.ProducerState;
1:d29ca2a: import org.apache.activemq.store.TransactionRecoveryListener;
1:d29ca2a: import org.apache.activemq.store.TransactionStore;
1:d29ca2a: import org.apache.activemq.transaction.LocalTransaction;
1:25a252f: import org.apache.activemq.transaction.Synchronization;
1:d29ca2a: import org.apache.activemq.transaction.Transaction;
1:d29ca2a: import org.apache.activemq.transaction.XATransaction;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:d29ca2a: import org.apache.activemq.util.WrappedException;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: /**
1:230a86c:  * This broker filter handles the transaction related operations in the Broker
1:230a86c:  * interface.
1:b0c2a40:  * 
1:d29ca2a:  * 
1:d29ca2a:  */
1:d29ca2a: public class TransactionBroker extends BrokerFilter {
1:230a86c: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TransactionBroker.class);
1:d29ca2a: 
1:d29ca2a:     // The prepared XA transactions.
1:d29ca2a:     private TransactionStore transactionStore;
1:8e83b7f:     private Map<TransactionId, XATransaction> xaTransactions = new LinkedHashMap<TransactionId, XATransaction>();
1:ea70e82:     final ConnectionContext context = new ConnectionContext();
1:d29ca2a: 
1:d29ca2a:     public TransactionBroker(Broker next, TransactionStore transactionStore) {
1:d29ca2a:         super(next);
1:230a86c:         this.transactionStore = transactionStore;
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     // ////////////////////////////////////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // Life cycle Methods
1:d29ca2a:     //
1:230a86c:     // ////////////////////////////////////////////////////////////////////////////
1:230a86c: 
1:d29ca2a:     /**
1:d29ca2a:      * Recovers any prepared transactions.
1:d29ca2a:      */
1:d29ca2a:     public void start() throws Exception {
1:230a86c:         transactionStore.start();
2:d29ca2a:         try {
1:d29ca2a:             context.setBroker(this);
1:d29ca2a:             context.setInRecoveryMode(true);
1:ecf89a6:             context.setTransactions(new ConcurrentHashMap<TransactionId, Transaction>());
1:d29ca2a:             context.setProducerFlowControl(false);
1:84eb9f8:             final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:84eb9f8:             producerExchange.setMutable(true);
1:84eb9f8:             producerExchange.setConnectionContext(context);
1:7bd8fb6:             producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
1:84eb9f8:             final ConsumerBrokerExchange consumerExchange = new ConsumerBrokerExchange();
1:84eb9f8:             consumerExchange.setConnectionContext(context);
1:d29ca2a:             transactionStore.recover(new TransactionRecoveryListener() {
1:d29ca2a:                 public void recover(XATransactionId xid, Message[] addedMessages, MessageAck[] aks) {
1:d29ca2a:                     try {
1:d29ca2a:                         beginTransaction(context, xid);
1:1d242a2:                         XATransaction transaction = (XATransaction) getTransaction(context, xid, false);
1:d29ca2a:                         for (int i = 0; i < addedMessages.length; i++) {
1:1d242a2:                             forceDestinationWakeupOnCompletion(context, transaction, addedMessages[i].getDestination(), addedMessages[i]);
1:d29ca2a:                         }
1:d29ca2a:                         for (int i = 0; i < aks.length; i++) {
1:1d242a2:                             forceDestinationWakeupOnCompletion(context, transaction, aks[i].getDestination(), aks[i]);
1:d29ca2a:                         }
1:101e711:                         transaction.setState(Transaction.PREPARED_STATE);
1:1d242a2:                         registerMBean(transaction);
1:e1bbde7:                         LOG.debug("recovered prepared transaction: {}", transaction.getTransactionId());
1:d29ca2a:                     } catch (Throwable e) {
1:d29ca2a:                         throw new WrappedException(e);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             });
1:d29ca2a:         } catch (WrappedException e) {
1:d29ca2a:             Throwable cause = e.getCause();
1:230a86c:             throw IOExceptionSupport.create("Recovery Failed: " + cause.getMessage(), cause);
1:101e711:         }
1:d29ca2a:         next.start();
1:d29ca2a:     }
1:230a86c: 
1:1d242a2:     private void registerMBean(XATransaction transaction) {
1:1d242a2:         if (getBrokerService().getRegionBroker() instanceof ManagedRegionBroker ) {
1:1d242a2:             ManagedRegionBroker managedRegionBroker = (ManagedRegionBroker) getBrokerService().getRegionBroker();
1:1d242a2:             managedRegionBroker.registerRecoveredTransactionMBean(transaction);
1:d29ca2a:         }
1:1d242a2:     }
1:d29ca2a: 
1:1d242a2:     private void forceDestinationWakeupOnCompletion(ConnectionContext context, Transaction transaction,
1:1d242a2:                                                     ActiveMQDestination amqDestination, BaseCommand ack) throws Exception {
1:ea70e82:         registerSync(amqDestination, transaction, ack);
1:1d242a2:     }
1:d29ca2a: 
1:ea70e82:     private void registerSync(ActiveMQDestination destination, Transaction transaction, BaseCommand command) {
1:ea70e82:         Synchronization sync = new PreparedDestinationCompletion(this, destination, command.isMessage());
1:64f3492:         // ensure one per destination in the list
1:60624c4:         Synchronization existing = transaction.findMatching(sync);
1:60624c4:         if (existing != null) {
1:60624c4:            ((PreparedDestinationCompletion)existing).incrementOpCount();
2:d29ca2a:         } else {
1:60624c4:             transaction.addSynchronization(sync);
1:60624c4:         }
1:101e711:     }
1:d29ca2a: 
1:101e711:     static class PreparedDestinationCompletion extends Synchronization {
1:ea70e82:         private final TransactionBroker transactionBroker;
1:ea70e82:         final ActiveMQDestination destination;
1:101e711:         final boolean messageSend;
1:60624c4:         int opCount = 1;
1:ea70e82:         public PreparedDestinationCompletion(final TransactionBroker transactionBroker, ActiveMQDestination destination, boolean messageSend) {
1:ea70e82:             this.transactionBroker = transactionBroker;
1:64f3492:             this.destination = destination;
1:101e711:             // rollback relevant to acks, commit to sends
1:101e711:             this.messageSend = messageSend;
1:101e711:         }
1:d29ca2a: 
1:60624c4:         public void incrementOpCount() {
1:60624c4:             opCount++;
1:60624c4:         }
1:d29ca2a: 
1:101e711:         @Override
1:101e711:         public int hashCode() {
1:64f3492:             return System.identityHashCode(destination) +
1:101e711:                     System.identityHashCode(Boolean.valueOf(messageSend));
1:101e711:         }
1:d29ca2a: 
1:101e711:         @Override
1:101e711:         public boolean equals(Object other) {
1:101e711:             return other instanceof PreparedDestinationCompletion &&
1:64f3492:                     destination.equals(((PreparedDestinationCompletion) other).destination) &&
1:101e711:                     messageSend == ((PreparedDestinationCompletion) other).messageSend;
1:101e711:         }
1:d29ca2a: 
1:101e711:         @Override
1:101e711:         public void afterRollback() throws Exception {
1:101e711:             if (!messageSend) {
1:ea70e82:                 Destination dest = transactionBroker.addDestination(transactionBroker.context, destination, false);
1:ea70e82:                 dest.clearPendingMessages(opCount);
1:ea70e82:                 dest.getDestinationStatistics().getMessages().add(opCount);
1:e1bbde7:                 LOG.debug("cleared pending from afterRollback: {}", destination);
1:101e711:             }
1:101e711:         }
1:d29ca2a: 
1:101e711:         @Override
1:101e711:         public void afterCommit() throws Exception {
1:ea70e82:             Destination dest = transactionBroker.addDestination(transactionBroker.context, destination, false);
1:101e711:             if (messageSend) {
1:ea70e82:                 dest.clearPendingMessages(opCount);
1:ea70e82:                 dest.getDestinationStatistics().getEnqueues().add(opCount);
1:ea70e82:                 dest.getDestinationStatistics().getMessages().add(opCount);
1:e1bbde7:                 LOG.debug("cleared pending from afterCommit: {}", destination);
1:230a86c:             } else {
1:ea70e82:                 dest.getDestinationStatistics().getDequeues().add(opCount);
1:101e711:             }
1:101e711:         }
1:101e711:     }
1:d29ca2a: 
1:d29ca2a:     public void stop() throws Exception {
1:d29ca2a:         transactionStore.stop();
1:d29ca2a:         next.stop();
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     // ////////////////////////////////////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // BrokerFilter overrides
1:d29ca2a:     //
1:230a86c:     // ////////////////////////////////////////////////////////////////////////////
1:7f5213b:     public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Exception {
1:ecf89a6:         List<TransactionId> txs = new ArrayList<TransactionId>();
1:230a86c:         synchronized (xaTransactions) {
1:8e83b7f:             for (Iterator<XATransaction> iter = xaTransactions.values().iterator(); iter.hasNext();) {
1:ecf89a6:                 Transaction tx = iter.next();
1:ecf89a6:                 if (tx.isPrepared()) {
1:e1bbde7:                     LOG.debug("prepared transaction: {}", tx.getTransactionId());
1:d29ca2a:                     txs.add(tx.getTransactionId());
1:ecf89a6:                 }
1:d29ca2a:             }
1:101e711:         }
1:d29ca2a:         XATransactionId rc[] = new XATransactionId[txs.size()];
1:d29ca2a:         txs.toArray(rc);
1:e1bbde7:         LOG.debug("prepared transaction list size: {}", rc.length);
1:d29ca2a:         return rc;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void beginTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:d29ca2a:         // the transaction may have already been started.
1:230a86c:         if (xid.isXATransaction()) {
1:8e83b7f:             XATransaction transaction = null;
1:230a86c:             synchronized (xaTransactions) {
1:ecf89a6:                 transaction = xaTransactions.get(xid);
1:ecf89a6:                 if (transaction != null) {
1:d29ca2a:                     return;
1:ecf89a6:                 }
1:8e83b7f:                 transaction = new XATransaction(transactionStore, (XATransactionId)xid, this, context.getConnectionId());
1:230a86c:                 xaTransactions.put(xid, transaction);
1:101e711:             }
1:230a86c:         } else {
1:ecf89a6:             Map<TransactionId, Transaction> transactionMap = context.getTransactions();
1:ecf89a6:             Transaction transaction = transactionMap.get(xid);
1:ecf89a6:             if (transaction != null) {
1:230a86c:                 throw new JMSException("Transaction '" + xid + "' has already been started.");
1:ecf89a6:             }
1:230a86c:             transaction = new LocalTransaction(transactionStore, (LocalTransactionId)xid, context);
1:230a86c:             transactionMap.put(xid, transaction);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:7f5213b:     public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:d29ca2a:         Transaction transaction = getTransaction(context, xid, false);
1:d29ca2a:         return transaction.prepare();
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {
1:d29ca2a:         Transaction transaction = getTransaction(context, xid, true);
1:d29ca2a:         transaction.commit(onePhase);
1:d29ca2a:     }
1:d29ca2a: 
1:7f5213b:     public void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:d29ca2a:         Transaction transaction = getTransaction(context, xid, true);
2:d29ca2a:         transaction.rollback();
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void forgetTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:d29ca2a:         Transaction transaction = getTransaction(context, xid, true);
1:d29ca2a:         transaction.rollback();
1:d29ca2a:     }
1:230a86c: 
1:84eb9f8:     public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {
1:230a86c:         // This method may be invoked recursively.
1:d29ca2a:         // Track original tx so that it can be restored.
1:84eb9f8:         final ConnectionContext context = consumerExchange.getConnectionContext();
2:d29ca2a:         Transaction originalTx = context.getTransaction();
1:230a86c:         Transaction transaction = null;
1:230a86c:         if (ack.isInTransaction()) {
1:d29ca2a:             transaction = getTransaction(context, ack.getTransactionId(), false);
1:d29ca2a:         }
2:d29ca2a:         context.setTransaction(transaction);
1:230a86c:         try {
1:84eb9f8:             next.acknowledge(consumerExchange, ack);
1:230a86c:         } finally {
2:d29ca2a:             context.setTransaction(originalTx);
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {
2:d29ca2a:         // This method may be invoked recursively.
1:d29ca2a:         // Track original tx so that it can be restored.
1:230a86c:         final ConnectionContext context = producerExchange.getConnectionContext();
1:230a86c:         Transaction originalTx = context.getTransaction();
1:230a86c:         Transaction transaction = null;
1:230a86c:         if (message.getTransactionId() != null) {
1:230a86c:             transaction = getTransaction(context, message.getTransactionId(), false);
1:d29ca2a:         }
1:f556076:         context.setTransaction(transaction);
1:f556076:         try {
1:f556076:             next.send(producerExchange, message);
1:f556076:         } finally {
1:f556076:             context.setTransaction(originalTx);
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:7f5213b:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {
1:ecf89a6:         for (Iterator<Transaction> iter = context.getTransactions().values().iterator(); iter.hasNext();) {
1:d29ca2a:             try {
1:ecf89a6:                 Transaction transaction = iter.next();
1:230a86c:                 transaction.rollback();
1:230a86c:             } catch (Exception e) {
1:fc00993:                 LOG.warn("ERROR Rolling back disconnected client's transactions: ", e);
1:d29ca2a:             }
1:d29ca2a:             iter.remove();
1:d29ca2a:         }
1:d29ca2a: 
1:230a86c:         synchronized (xaTransactions) {
1:fd4e136:             // first find all txs that belongs to the connection
1:fd4e136:             ArrayList<XATransaction> txs = new ArrayList<XATransaction>();
1:fd4e136:             for (XATransaction tx : xaTransactions.values()) {
1:101e711:                 if (tx.getConnectionId() != null && tx.getConnectionId().equals(info.getConnectionId()) && !tx.isPrepared()) {
1:fd4e136:                     txs.add(tx);
1:d29ca2a:                 }
1:101e711:             }
1:d29ca2a: 
1:fd4e136:             // then remove them
1:fd4e136:             // two steps needed to avoid ConcurrentModificationException, from removeTransaction()
1:fd4e136:             for (XATransaction tx : txs) {
1:d29ca2a:                 try {
1:fd4e136:                     tx.rollback();
1:fd4e136:                 } catch (Exception e) {
1:fd4e136:                     LOG.warn("ERROR Rolling back disconnected client's xa transactions: ", e);
1:2dd5b77:                 }
1:2dd5b77:             }
1:d29ca2a: 
1:44ef96e:         }
1:d29ca2a:         next.removeConnection(context, info, error);
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     // ////////////////////////////////////////////////////////////////////////////
1:d29ca2a:     //
1:d29ca2a:     // Implementation help methods.
1:d29ca2a:     //
1:230a86c:     // ////////////////////////////////////////////////////////////////////////////
1:230a86c:     public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {
1:c7b93d1:         Transaction transaction = null;
1:c7b93d1:         if (xid.isXATransaction()) {
1:c7b93d1:             synchronized (xaTransactions) {
1:c7b93d1:                 transaction = xaTransactions.get(xid);
1:c7b93d1:             }
1:c7b93d1:         } else {
1:c7b93d1:             transaction = context.getTransactions().get(xid);
4:fd4e136:         }
1:ecf89a6:         if (transaction != null) {
1:d29ca2a:             return transaction;
1:ecf89a6:         }
1:230a86c:         if (xid.isXATransaction()) {
1:ab1e9c7:             XAException e = XATransaction.newXAException("Transaction '" + xid + "' has not been started.", XAException.XAER_NOTA);
1:d29ca2a:             throw e;
1:230a86c:         } else {
1:230a86c:             throw new JMSException("Transaction '" + xid + "' has not been started.");
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void removeTransaction(XATransactionId xid) {
1:230a86c:         synchronized (xaTransactions) {
1:d29ca2a:             xaTransactions.remove(xid);
1:230a86c:         }
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     final ConnectionContext context = new ConnectionContext();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         registerSync(amqDestination, transaction, ack);
1:     private void registerSync(ActiveMQDestination destination, Transaction transaction, BaseCommand command) {
1:         Synchronization sync = new PreparedDestinationCompletion(this, destination, command.isMessage());
/////////////////////////////////////////////////////////////////////////
1:         private final TransactionBroker transactionBroker;
1:         final ActiveMQDestination destination;
1:         public PreparedDestinationCompletion(final TransactionBroker transactionBroker, ActiveMQDestination destination, boolean messageSend) {
1:             this.transactionBroker = transactionBroker;
/////////////////////////////////////////////////////////////////////////
1:                 Destination dest = transactionBroker.addDestination(transactionBroker.context, destination, false);
1:                 dest.clearPendingMessages(opCount);
1:                 dest.getDestinationStatistics().getMessages().add(opCount);
1:             Destination dest = transactionBroker.addDestination(transactionBroker.context, destination, false);
1:                 dest.clearPendingMessages(opCount);
1:                 dest.getDestinationStatistics().getEnqueues().add(opCount);
1:                 dest.getDestinationStatistics().getMessages().add(opCount);
1:                 dest.getDestinationStatistics().getDequeues().add(opCount);
commit:c7b93d1
/////////////////////////////////////////////////////////////////////////
1:         Transaction transaction = null;
1:         if (xid.isXATransaction()) {
1:             synchronized (xaTransactions) {
1:                 transaction = xaTransactions.get(xid);
1:             }
1:         } else {
1:             transaction = context.getTransactions().get(xid);
commit:ab1e9c7
/////////////////////////////////////////////////////////////////////////
1:             XAException e = XATransaction.newXAException("Transaction '" + xid + "' has not been started.", XAException.XAER_NOTA);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:f556076
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         context.setTransaction(transaction);
1:         try {
1:             next.send(producerExchange, message);
1:         } finally {
1:             context.setTransaction(originalTx);
/////////////////////////////////////////////////////////////////////////
commit:2852a8b
/////////////////////////////////////////////////////////////////////////
0:         if (audit == null) {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("recovered prepared transaction: {}", transaction.getTransactionId());
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("cleared pending from afterRollback: {}", destination);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("cleared pending from afterCommit: {}", destination);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("prepared transaction: {}", tx.getTransactionId());
1:         LOG.debug("prepared transaction list size: {}", rc.length);
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("IGNORING duplicate message {}", message);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:7bd8fb6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.state.ProducerState;
/////////////////////////////////////////////////////////////////////////
1:             producerExchange.setProducerState(new ProducerState(new ProducerInfo()));
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     private Map<TransactionId, Transaction> xaTransactions = new LinkedHashMap<TransactionId, Transaction>();
0:     private ActiveMQMessageAudit audit;
/////////////////////////////////////////////////////////////////////////
1:             context.setTransactions(new ConcurrentHashMap<TransactionId, Transaction>());
/////////////////////////////////////////////////////////////////////////
1:         List<TransactionId> txs = new ArrayList<TransactionId>();
0:             for (Iterator<Transaction> iter = xaTransactions.values().iterator(); iter.hasNext();) {
1:                 Transaction tx = iter.next();
1:                 if (tx.isPrepared()) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 transaction = xaTransactions.get(xid);
1:                 if (transaction != null) {
1:                 }
1:             Map<TransactionId, Transaction> transactionMap = context.getTransactions();
1:             Transaction transaction = transactionMap.get(xid);
1:             if (transaction != null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<Transaction> iter = context.getTransactions().values().iterator(); iter.hasNext();) {
1:                 Transaction transaction = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         if (transaction != null) {
1:         }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(TransactionBroker.class);
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("IGNORING duplicate message " + message);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("ERROR Rolling back disconnected client's transactions: ", e);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: import java.util.Map;
1: import javax.jms.JMSException;
1: import javax.transaction.xa.XAException;
1: 
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1:  * This broker filter handles the transaction related operations in the Broker
1:  * interface.
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.transactionStore = transactionStore;
1: 
1:     // ////////////////////////////////////////////////////////////////////////////
1:     // ////////////////////////////////////////////////////////////////////////////
1: 
1:         transactionStore.start();
/////////////////////////////////////////////////////////////////////////
0:                             acknowledge(consumerExchange, aks[i]);
/////////////////////////////////////////////////////////////////////////
1:             throw IOExceptionSupport.create("Recovery Failed: " + cause.getMessage(), cause);
1: 
1:     // ////////////////////////////////////////////////////////////////////////////
1:     // ////////////////////////////////////////////////////////////////////////////
1:         synchronized (xaTransactions) {
0:             for (Iterator iter = xaTransactions.values().iterator(); iter.hasNext();) {
0:                 Transaction tx = (Transaction)iter.next();
0:                 if (tx.isPrepared())
/////////////////////////////////////////////////////////////////////////
1:     public void beginTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:         if (xid.isXATransaction()) {
1:             Transaction transaction = null;
1:             synchronized (xaTransactions) {
0:                 transaction = (Transaction)xaTransactions.get(xid);
0:                 if (transaction != null)
0:                 transaction = new XATransaction(transactionStore, (XATransactionId)xid, this);
1:                 xaTransactions.put(xid, transaction);
1:         } else {
0:             Map transactionMap = context.getTransactions();
0:             Transaction transaction = (Transaction)transactionMap.get(xid);
0:             if (transaction != null)
1:                 throw new JMSException("Transaction '" + xid + "' has already been started.");
1:             transaction = new LocalTransaction(transactionStore, (LocalTransactionId)xid, context);
1:             transactionMap.put(xid, transaction);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         // This method may be invoked recursively.
1:         Transaction transaction = null;
1:         if (ack.isInTransaction()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void send(ProducerBrokerExchange producerExchange, final Message message) throws Exception {
1:         final ConnectionContext context = producerExchange.getConnectionContext();
1:         Transaction originalTx = context.getTransaction();
0:         Transaction transaction = null;
0:         Synchronization sync = null;
1:         if (message.getTransactionId() != null) {
1:             transaction = getTransaction(context, message.getTransactionId(), false);
0:             if (transaction != null) {
0:                 sync = new Synchronization() {
0:                     public void afterRollback() {
0:                         if (audit != null) {
/////////////////////////////////////////////////////////////////////////
0:         if (audit == null || !audit.isDuplicateMessageReference(message)) {
1:             try {
0:                 next.send(producerExchange, message);
1:             } finally {
1:         } else {
0:             if (sync != null && transaction != null) {
0:             if (log.isDebugEnabled()) {
0:                 log.debug("IGNORING duplicate message " + message);
1: 
0:                 Transaction transaction = (Transaction)iter.next();
1:                 transaction.rollback();
1:             } catch (Exception e) {
1: 
1:     // ////////////////////////////////////////////////////////////////////////////
1:     // ////////////////////////////////////////////////////////////////////////////
1:     public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {
0:         Map transactionMap = null;
1:         synchronized (xaTransactions) {
0:             transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();
0:         Transaction transaction = (Transaction)transactionMap.get(xid);
0:         if (transaction != null)
1:         if (xid.isXATransaction()) {
0:             XAException e = new XAException("Transaction '" + xid + "' has not been started.");
0:             e.errorCode = XAException.XAER_NOTA;
1:         } else {
1:             throw new JMSException("Transaction '" + xid + "' has not been started.");
1:     public void removeTransaction(XATransactionId xid) {
1:         synchronized (xaTransactions) {
1: 
0:     public synchronized void brokerServiceStarted() {
0:         if (getBrokerService().isSupportFailOver() && audit == null) {
0:             audit = new ActiveMQMessageAudit();
1:     }
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void beginTransaction(ConnectionContext context, TransactionId xid) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:     public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {
1:     public void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:     public void forgetTransaction(ConnectionContext context, TransactionId xid) throws Exception {
0:     public void acknowledge(ConnectionContext context, MessageAck ack) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void send(ConnectionContext context, Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.store.TransactionRecoveryListener;
1: import org.apache.activemq.store.TransactionStore;
1: import org.apache.activemq.transaction.LocalTransaction;
1: import org.apache.activemq.transaction.Transaction;
1: import org.apache.activemq.transaction.XATransaction;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.WrappedException;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import javax.jms.JMSException;
0: import javax.transaction.xa.XAException;
1: 
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.Map;
1: 
1: /**
0:  * This broker filter handles the transaction related operations in the Broker interface.
1:  * 
0:  * @version $Revision: 1.10 $
1:  */
1: public class TransactionBroker extends BrokerFilter {
1:     
0:     private static final Log log = LogFactory.getLog(TransactionBroker.class);
1: 
1:     // The prepared XA transactions.
1:     private TransactionStore transactionStore;
0:     private ConcurrentHashMap xaTransactions = new ConcurrentHashMap();
1: 
1:     public TransactionBroker(Broker next, TransactionStore transactionStore) {
1:         super(next);
0:         this.transactionStore=transactionStore;
1:     }
1:     
0:     //////////////////////////////////////////////////////////////////////////////
1:     //
1:     // Life cycle Methods
1:     //
0:     //////////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Recovers any prepared transactions.
1:      */
1:     public void start() throws Exception {
1:         next.start();
0:         transactionStore.start();
1:         try {
0:             final ConnectionContext context = new ConnectionContext();
1:             context.setBroker(this);
1:             context.setInRecoveryMode(true);
0:             context.setTransactions(new ConcurrentHashMap());
1:             context.setProducerFlowControl(false);
1:             
1:             transactionStore.recover(new TransactionRecoveryListener() {
1:                 public void recover(XATransactionId xid, Message[] addedMessages, MessageAck[] aks) {
1:                     try {
1:                         beginTransaction(context, xid);
1:                         for (int i = 0; i < addedMessages.length; i++) {
0:                             send(context, addedMessages[i]);
1:                         }
1:                         for (int i = 0; i < aks.length; i++) {
0:                             acknowledge(context, aks[i]);                    
1:                         }
0:                         prepareTransaction(context, xid);
1:                     } catch (Throwable e) {
1:                         throw new WrappedException(e);
1:                     }
1:                 }
1:             });
1:         } catch (WrappedException e) {
1:             Throwable cause = e.getCause();
0:             throw IOExceptionSupport.create("Recovery Failed: "+cause.getMessage(), cause);
1:         }
1:     }
1:     
1:     public void stop() throws Exception {
1:         transactionStore.stop();
1:         next.stop();
1:     }
1:  
1: 
0:     //////////////////////////////////////////////////////////////////////////////
1:     //
1:     // BrokerFilter overrides
1:     //
0:     //////////////////////////////////////////////////////////////////////////////
0:     public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Throwable {
0:         ArrayList txs = new ArrayList();
0:         for (Iterator iter = xaTransactions.values().iterator(); iter.hasNext();) {
0:             Transaction tx = (Transaction) iter.next();
0:             if( tx.isPrepared() )
1:                 txs.add(tx.getTransactionId());
1:         }
1:         XATransactionId rc[] = new XATransactionId[txs.size()];
1:         txs.toArray(rc);
1:         return rc;
1:     }
1: 
0:     public void beginTransaction(ConnectionContext context, TransactionId xid) throws Throwable {
1:         
1:         // the transaction may have already been started.
0:         if( xid.isXATransaction() ) {
0:             Transaction transaction = (Transaction)xaTransactions.get(xid);
0:             if( transaction != null  )
1:                 return;
0:             transaction = new XATransaction(transactionStore, (XATransactionId)xid, this);
0:             xaTransactions.put(xid, transaction);
1:         } else {
0:             Map transactionMap = context.getTransactions();        
0:             Transaction transaction = (Transaction)transactionMap.get(xid);
0:             if( transaction != null  )
0:                 throw new JMSException("Transaction '"+xid+"' has already been started.");
1:             
0:             transaction = new LocalTransaction(transactionStore, (LocalTransactionId)xid, context);
0:             transactionMap.put(xid, transaction);
1:         }
1:     }
1: 
0:     public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Throwable {
1:         Transaction transaction = getTransaction(context, xid, false);
1:         return transaction.prepare();
1:     }
1:     
0:     public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Throwable {
1:         Transaction transaction = getTransaction(context, xid, true);
1:         transaction.commit(onePhase);
1:     }
1: 
0:     public void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Throwable {
1:         Transaction transaction = getTransaction(context, xid, true);
1:         transaction.rollback();
1:     }
1:     
0:     public void forgetTransaction(ConnectionContext context, TransactionId xid) throws Throwable {
1:         Transaction transaction = getTransaction(context, xid, true);
1:         transaction.rollback();
1:     }
1:     
0:     public void acknowledge(ConnectionContext context, MessageAck ack) throws Throwable {
1:         // This method may be invoked recursively.  
1:         // Track original tx so that it can be restored.
1:         Transaction originalTx = context.getTransaction();
0:         Transaction transaction=null;
0:         if( ack.isInTransaction() ) {
1:             transaction = getTransaction(context, ack.getTransactionId(), false);
1:         }
1:         context.setTransaction(transaction);
1:         try {
0:             next.acknowledge(context, ack);
0:         } finally {
1:             context.setTransaction(originalTx);
1:         }
1:     }
1:     
0:     public void send(ConnectionContext context, Message message) throws Throwable {
1:         // This method may be invoked recursively.  
1:         // Track original tx so that it can be restored.
1:         Transaction originalTx = context.getTransaction();
0:         Transaction transaction=null;
0:         if( message.getTransactionId()!=null ) {
0:             transaction = getTransaction(context, message.getTransactionId(), false);
1:         }
1:         context.setTransaction(transaction);
1:         try {
0:             next.send(context, message);
0:         } finally {
1:             context.setTransaction(originalTx);
1:         }
1:     }
1:     
0:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Throwable {
0:         for (Iterator iter = context.getTransactions().values().iterator(); iter.hasNext();) {
1:             try {
0:                 Transaction transaction = (Transaction) iter.next();
1:                 transaction.rollback();            
1:             }
0:             catch (Exception e) {
0:                 log.warn("ERROR Rolling back disconnected client's transactions: ", e);
1:             }
1:             iter.remove();
1:         }
1:         next.removeConnection(context, info, error);
1:     }
1:     
0:     //////////////////////////////////////////////////////////////////////////////
1:     //
1:     // Implementation help methods.
1:     //
0:     //////////////////////////////////////////////////////////////////////////////
0:     public Transaction getTransaction(ConnectionContext context, TransactionId xid, boolean mightBePrepared) throws JMSException, XAException {
0:         Map transactionMap = xid.isXATransaction() ? xaTransactions : context.getTransactions();        
0:         Transaction transaction = (Transaction)transactionMap.get(xid);
1: 
0:         if( transaction != null  )
1:             return transaction;
1:         
0:         if( xid.isXATransaction() ) {
0:             XAException e = new XAException("Transaction '" + xid + "' has not been started.");
0:             e.errorCode = XAException.XAER_NOTA;
1:             throw e;
1:         } else {
0:             throw new JMSException("Transaction '" + xid + "' has not been started.");
1:         }
1:     }
1: 
0:     public void removeTransaction(XATransactionId xid) {
1:         xaTransactions.remove(xid);
1:     }
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:60624c4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Synchronization existing = transaction.findMatching(sync);
1:         if (existing != null) {
1:            ((PreparedDestinationCompletion)existing).incrementOpCount();
0:         } else {
1:             transaction.addSynchronization(sync);
1:         }
1:         int opCount = 1;
1:         public void incrementOpCount() {
1:             opCount++;
1:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 destination.getDestinationStatistics().getEnqueues().add(opCount);
0:                 destination.getDestinationStatistics().getMessages().add(opCount);
0:             } else {
0:                 destination.getDestinationStatistics().getDequeues().add(opCount);
0:                 destination.getDestinationStatistics().getMessages().subtract(opCount);
commit:64f3492
/////////////////////////////////////////////////////////////////////////
0:         Synchronization sync = new PreparedDestinationCompletion(destination, command.isMessage());
1:         // ensure one per destination in the list
0:         transaction.removeSynchronization(sync);
0:         transaction.addSynchronization(sync);
0:         final Destination destination;
0:         public PreparedDestinationCompletion(final Destination destination, boolean messageSend) {
1:             this.destination = destination;
1:             return System.identityHashCode(destination) +
1:                     destination.equals(((PreparedDestinationCompletion) other).destination) &&
0:                 destination.clearPendingMessages();
0:                     LOG.debug("cleared pending from afterRollback : " + destination);
/////////////////////////////////////////////////////////////////////////
0:                 destination.clearPendingMessages();
0:                     LOG.debug("cleared pending from afterCommit : " + destination);
commit:1d242a2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.ManagedRegionBroker;
/////////////////////////////////////////////////////////////////////////
1:                         XATransaction transaction = (XATransaction) getTransaction(context, xid, false);
1:                             forceDestinationWakeupOnCompletion(context, transaction, addedMessages[i].getDestination(), addedMessages[i]);
1:                             forceDestinationWakeupOnCompletion(context, transaction, aks[i].getDestination(), aks[i]);
1:                         registerMBean(transaction);
/////////////////////////////////////////////////////////////////////////
1:     private void registerMBean(XATransaction transaction) {
1:         if (getBrokerService().getRegionBroker() instanceof ManagedRegionBroker ) {
1:             ManagedRegionBroker managedRegionBroker = (ManagedRegionBroker) getBrokerService().getRegionBroker();
1:             managedRegionBroker.registerRecoveredTransactionMBean(transaction);
1:         }
1:     }
0: 
1:     private void forceDestinationWakeupOnCompletion(ConnectionContext context, Transaction transaction,
1:                                                     ActiveMQDestination amqDestination, BaseCommand ack) throws Exception {
commit:101e711
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.List;
0: import java.util.Map;
1: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.BaseCommand;
/////////////////////////////////////////////////////////////////////////
0:                         Transaction transaction = getTransaction(context, xid, false);
0:                             kickDestinationOnCompletion(context, transaction, addedMessages[i].getDestination(), addedMessages[i]);
0:                             kickDestinationOnCompletion(context, transaction, aks[i].getDestination(), aks[i]);
1:                         transaction.setState(Transaction.PREPARED_STATE);
0:                         LOG.debug("recovered prepared transaction: " + transaction.getTransactionId());
/////////////////////////////////////////////////////////////////////////
0:     private void kickDestinationOnCompletion(ConnectionContext context, Transaction transaction,
0:                                              ActiveMQDestination amqDestination, BaseCommand ack) throws Exception {
0:         Destination destination =  addDestination(context, amqDestination, false);
0:         registerSync(destination, transaction, ack);
1:     }
0: 
0:     private void registerSync(Destination destination, Transaction transaction, BaseCommand command) {
0:         if (destination instanceof Queue) {
0:             Synchronization sync = new PreparedDestinationCompletion((Queue) destination, command.isMessage());
0:             // ensure one per destination in the list
0:             transaction.removeSynchronization(sync);
0:             transaction.addSynchronization(sync);
1:         }
1:     }
0: 
1:     static class PreparedDestinationCompletion extends Synchronization {
0:         final Queue queue;
1:         final boolean messageSend;
0:         public PreparedDestinationCompletion(final Queue queue, boolean messageSend) {
0:             this.queue = queue;
1:             // rollback relevant to acks, commit to sends
1:             this.messageSend = messageSend;
1:         }
0: 
1:         @Override
1:         public int hashCode() {
0:             return System.identityHashCode(queue) +
1:                     System.identityHashCode(Boolean.valueOf(messageSend));
1:         }
0: 
1:         @Override
1:         public boolean equals(Object other) {
1:             return other instanceof PreparedDestinationCompletion &&
0:                     queue.equals(((PreparedDestinationCompletion) other).queue) &&
1:                     messageSend == ((PreparedDestinationCompletion) other).messageSend;
1:         }
0: 
1:         @Override
1:         public void afterRollback() throws Exception {
1:             if (!messageSend) {
0:                 queue.clearPendingMessages();
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("cleared pending from afterRollback : " + queue);
1:                 }
1:             }
1:         }
0: 
1:         @Override
1:         public void afterCommit() throws Exception {
1:             if (messageSend) {
0:                 queue.clearPendingMessages();
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("cleared pending from afterCommit : " + queue);
1:                 }
1:             }
1:         }
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("prepared transaction list size: " + rc.length);
/////////////////////////////////////////////////////////////////////////
1:                 if (tx.getConnectionId() != null && tx.getConnectionId().equals(info.getConnectionId()) && !tx.isPrepared()) {
commit:2dd5b77
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("prepared transaction: " + tx.getTransactionId());
1:                     }
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("prepared transacton list size: " + rc.length);
1:         }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:44ef96e
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("recovered prepared transaction: " + transaction.getTransactionId());
1:                         }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(TransactionBroker.class);
commit:fd4e136
/////////////////////////////////////////////////////////////////////////
0: 
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:         synchronized (xaTransactions) {
1:             // first find all txs that belongs to the connection
1:             ArrayList<XATransaction> txs = new ArrayList<XATransaction>();
1:             for (XATransaction tx : xaTransactions.values()) {
0:                 if (tx.getConnectionId().equals(info.getConnectionId()) && !tx.isPrepared()) {
1:                     txs.add(tx);
1:                 }
1:             }
1:             // then remove them
1:             // two steps needed to avoid ConcurrentModificationException, from removeTransaction()
1:             for (XATransaction tx : txs) {
0:                 try {
1:                     tx.rollback();
1:                 } catch (Exception e) {
1:                     LOG.warn("ERROR Rolling back disconnected client's xa transactions: ", e);
1:                 }
1:             }
0: 
commit:8e83b7f
/////////////////////////////////////////////////////////////////////////
1:     private Map<TransactionId, XATransaction> xaTransactions = new LinkedHashMap<TransactionId, XATransaction>();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<XATransaction> iter = xaTransactions.values().iterator(); iter.hasNext();) {
/////////////////////////////////////////////////////////////////////////
1:             XATransaction transaction = null;
1:                 transaction = new XATransaction(transactionStore, (XATransactionId)xid, this, context.getConnectionId());
/////////////////////////////////////////////////////////////////////////
0: 
0:         for (XATransaction tx : xaTransactions.values()) {
0:              if (tx.getConnectionId().equals(info.getConnectionId()) && !tx.isPrepared()) {
commit:c0daffa
/////////////////////////////////////////////////////////////////////////
0: 
0:         for (Transaction tx : xaTransactions.values()) {
0:            try {
0:              if (!tx.isPrepared()) {
0:                 tx.rollback();
0:              }
0:            } catch (Exception e) {
0:                LOG.warn("ERROR Rolling back disconnected client's xa transactions: ", e);
0:            }
0:         }
author:Robert Davies
-------------------------------------------------------------------------------
commit:1ee0017
/////////////////////////////////////////////////////////////////////////
0:                             audit.rollback(message);
0:         if (audit == null || !audit.isDuplicate(message)) {
commit:25a252f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transaction.Synchronization;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     ActiveMQMessageAudit audit;
/////////////////////////////////////////////////////////////////////////
0:     public void send(ProducerBrokerExchange producerExchange,final Message message) throws Exception{
0:         // This method may be invoked recursively.
0:         final ConnectionContext context=producerExchange.getConnectionContext();
0:         Transaction originalTx=context.getTransaction();
0:         Synchronization sync=null;
0:         if(message.getTransactionId()!=null){
0:             transaction=getTransaction(context,message.getTransactionId(),false);
0:             if(transaction!=null){
0:                 sync=new Synchronization(){
0: 
0:                     public void afterRollback(){
0:                         if(audit!=null){
0:                             audit.rollbackMessageReference(message);
0:                         }
0:                     }
0:                 };
0:                 transaction.addSynchronization(sync);
0:             }
0:         if(audit==null||!audit.isDuplicateMessageReference(message)){
0:             context.setTransaction(transaction);
0:             try{
0:                 next.send(producerExchange,message);
0:             }finally{
0:                 context.setTransaction(originalTx);
0:             }
0:         }else{
0:             if(sync!=null&&transaction!=null){
0:                 transaction.removeSynchronization(sync);
0:             }
0:             if(log.isDebugEnabled()){
0:                 log.debug("IGNORING duplicate message "+message);
0:             }
/////////////////////////////////////////////////////////////////////////
0:     
0:     public synchronized void brokerServiceStarted(){
0:         super.brokerServiceStarted();
0:         if(getBrokerService().isSupportFailOver()&&audit==null){
0:             audit=new ActiveMQMessageAudit();
0:         }
0:     } 
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
1:             final ProducerBrokerExchange producerExchange = new ProducerBrokerExchange();
1:             producerExchange.setMutable(true);
1:             producerExchange.setConnectionContext(context);
1:             final ConsumerBrokerExchange consumerExchange = new ConsumerBrokerExchange();
1:             consumerExchange.setConnectionContext(context);
0:                             send(producerExchange, addedMessages[i]);
0:                             acknowledge(consumerExchange, aks[i]);                    
/////////////////////////////////////////////////////////////////////////
1:     public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {
1:         final ConnectionContext context = consumerExchange.getConnectionContext();
/////////////////////////////////////////////////////////////////////////
1:             next.acknowledge(consumerExchange, ack);
0:     public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {
0:         final ConnectionContext context = producerExchange.getConnectionContext();
/////////////////////////////////////////////////////////////////////////
0:             next.send(producerExchange, message);
commit:3093ea0
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedHashMap;
/////////////////////////////////////////////////////////////////////////
0:     private Map xaTransactions = new LinkedHashMap();
/////////////////////////////////////////////////////////////////////////
0:         transactionStore.start();  
/////////////////////////////////////////////////////////////////////////
0:         next.start();
/////////////////////////////////////////////////////////////////////////
0:         synchronized(xaTransactions){
0:             for(Iterator iter=xaTransactions.values().iterator();iter.hasNext();){
0:                 Transaction tx=(Transaction)iter.next();
0:                 if(tx.isPrepared())
0:                     txs.add(tx.getTransactionId());
0:             }
0:     public void beginTransaction(ConnectionContext context,TransactionId xid) throws Exception{
0:         if(xid.isXATransaction()){
0:             Transaction transaction=null;
0:             synchronized(xaTransactions){
0:                 transaction=(Transaction)xaTransactions.get(xid);
0:                 if(transaction!=null)
0:                     return;
0:                 transaction=new XATransaction(transactionStore,(XATransactionId)xid,this);
0:                 xaTransactions.put(xid,transaction);
0:             }
0:         }else{
0:             Map transactionMap=context.getTransactions();
0:             Transaction transaction=(Transaction)transactionMap.get(xid);
0:             if(transaction!=null)
0:             transaction=new LocalTransaction(transactionStore,(LocalTransactionId)xid,context);
0:             transactionMap.put(xid,transaction);
/////////////////////////////////////////////////////////////////////////
0:     public Transaction getTransaction(ConnectionContext context,TransactionId xid,boolean mightBePrepared)
0:             throws JMSException,XAException{
0:         Map transactionMap=null;
0:         synchronized(xaTransactions){
0:             transactionMap=xid.isXATransaction()?xaTransactions:context.getTransactions();
0:         }
0:         Transaction transaction=(Transaction)transactionMap.get(xid);
0:         if(transaction!=null)
0:         if(xid.isXATransaction()){
0:             XAException e=new XAException("Transaction '"+xid+"' has not been started.");
0:             e.errorCode=XAException.XAER_NOTA;
0:         }else{
0:             throw new JMSException("Transaction '"+xid+"' has not been started.");
0:     public void removeTransaction(XATransactionId xid){
0:         synchronized(xaTransactions){
0:             xaTransactions.remove(xid);
0:         }
============================================================================