1:70706ef: /**
1:a58d36b:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:a58d36b:  * contributor license agreements.  See the NOTICE file distributed with
1:a58d36b:  * this work for additional information regarding copyright ownership.
1:a58d36b:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:a58d36b:  * (the "License"); you may not use this file except in compliance with
1:a58d36b:  * the License.  You may obtain a copy of the License at
1:70706ef:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
3:a58d36b:  *
1:a58d36b:  * Unless required by applicable law or agreed to in writing, software
1:a58d36b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a58d36b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a58d36b:  * See the License for the specific language governing permissions and
1:a58d36b:  * limitations under the License.
1:70706ef:  */
1:a58d36b: package org.apache.activemq.broker;
43:a58d36b: 
1:a58d36b: import javax.jms.DeliveryMode;
1:a58d36b: 
1:a58d36b: import junit.framework.Test;
1:ce18ec8: 
1:f812e34: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:f812e34: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
1:a58d36b: import org.apache.activemq.command.ActiveMQDestination;
1:a58d36b: import org.apache.activemq.command.ConnectionInfo;
1:a58d36b: import org.apache.activemq.command.ConsumerInfo;
1:a58d36b: import org.apache.activemq.command.LocalTransactionId;
1:a58d36b: import org.apache.activemq.command.Message;
1:a58d36b: import org.apache.activemq.command.MessageAck;
1:a58d36b: import org.apache.activemq.command.ProducerInfo;
1:a58d36b: import org.apache.activemq.command.SessionInfo;
1:a58d36b: 
1:a58d36b: public class MessageExpirationTest extends BrokerTestSupport {
1:230a86c: 
1:a58d36b:     public ActiveMQDestination destination;
1:7ac1bb8:     public int deliveryMode = DeliveryMode.NON_PERSISTENT;
1:a58d36b:     public int prefetch;
1:7ac1bb8:     public byte destinationType = ActiveMQDestination.QUEUE_TYPE;
1:a58d36b:     public boolean durableConsumer;
1:230a86c: 
1:a58d36b:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination, int deliveryMode, int timeToLive) {
1:230a86c:         Message message = createMessage(producerInfo, destination, deliveryMode);
1:230a86c:         long now = System.currentTimeMillis();
1:230a86c:         message.setTimestamp(now);
1:230a86c:         message.setExpiration(now + timeToLive);
1:a58d36b:         return message;
3:a58d36b:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestMessagesWaitingForUssageDecreaseExpire() {
1:230a86c:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:230a86c:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE),
1:933eb2f:                                                               Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
1:a58d36b:     }
1:230a86c: 
1:3b78804:     @Override
1:3b78804:     protected BrokerService createBroker() throws Exception {
1:3b78804:         BrokerService broker = new BrokerService();
1:3b78804:         broker.setPersistent(false);
1:3b78804:         return broker;
1:a58d36b:     }
1:9ba5e19: 
1:9ba5e19:     protected PolicyEntry getDefaultPolicy() {
1:9ba5e19:         PolicyEntry policy = super.getDefaultPolicy();
1:230a86c:         // disable spooling
1:9ba5e19:         policy.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
1:7ac1bb8:         // have aggressive expiry period to ensure no deadlock or clash
1:7ac1bb8:         policy.setExpireMessagesPeriod(100);
1:7ac1bb8:         
1:9ba5e19:         return policy;
1:9ba5e19:     }
1:230a86c: 
1:7ac1bb8:     public void testMessagesWaitingForUsageDecreaseExpire() throws Exception {
1:a58d36b: 
1:a58d36b:         // Start a producer
1:a58d36b:         final StubConnection connection = createConnection();
1:a58d36b:         ConnectionInfo connectionInfo = createConnectionInfo();
1:a58d36b:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:a58d36b:         final ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:a58d36b:         connection.send(connectionInfo);
1:a58d36b:         connection.send(sessionInfo);
1:a58d36b:         connection.send(producerInfo);
1:a58d36b: 
1:a58d36b:         // Start a consumer..
1:a58d36b:         final StubConnection connection2 = createConnection();
1:a58d36b:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:a58d36b:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:a58d36b:         connection2.send(connectionInfo2);
1:a58d36b:         connection2.send(sessionInfo2);
1:230a86c: 
1:a58d36b:         destination = createDestinationInfo(connection2, connectionInfo2, destinationType);
1:a58d36b:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:a58d36b:         consumerInfo2.setPrefetchSize(1);
1:57ea011:         connection2.request(consumerInfo2);
1:230a86c: 
1:230a86c:         // Reduce the limit so that only 1 message can flow through the broker
1:230a86c:         // at a time.
1:2b0024c:         broker.getSystemUsage().getMemoryUsage().setLimit(1);
1:230a86c: 
1:a58d36b:         final Message m1 = createMessage(producerInfo, destination, deliveryMode);
1:a58d36b:         final Message m2 = createMessage(producerInfo, destination, deliveryMode, 1000);
1:a58d36b:         final Message m3 = createMessage(producerInfo, destination, deliveryMode);
1:a58d36b:         final Message m4 = createMessage(producerInfo, destination, deliveryMode, 1000);
1:230a86c: 
1:230a86c:         // Produce in an async thread since the producer will be getting blocked
1:230a86c:         // by the usage manager..
1:a58d36b:         new Thread() {
1:230a86c:             public void run() {
1:a58d36b:                 // m1 and m3 should not expire.. but the others should.
1:a58d36b:                 try {
1:230a86c:                     connection.send(m1);
1:230a86c:                     connection.send(m2);
1:230a86c:                     connection.send(m3);
1:230a86c:                     connection.send(m4);
1:230a86c:                 } catch (Exception e) {
1:230a86c:                     e.printStackTrace();
1:230a86c:                 }
1:230a86c:             }
1:a58d36b:         }.start();
1:230a86c: 
1:a58d36b:         // Make sure only 1 message was delivered due to prefetch == 1
1:a58d36b:         Message m = receiveMessage(connection2);
1:a58d36b:         assertNotNull(m);
1:a58d36b:         assertEquals(m1.getMessageId(), m.getMessageId());
1:a58d36b:         assertNoMessagesLeft(connection);
1:230a86c: 
1:a58d36b:         // Sleep before we ack so that the messages expire on the usage manager
3:a58d36b:         Thread.sleep(1500);
1:a58d36b:         connection2.send(createAck(consumerInfo2, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:230a86c:         // 2nd message received should be m3.. it should have expired 2nd
1:230a86c:         // message sent.
1:a58d36b:         m = receiveMessage(connection2);
1:a58d36b:         assertNotNull(m);
1:a58d36b:         assertEquals(m3.getMessageId(), m.getMessageId());
1:230a86c: 
1:a58d36b:         // Sleep before we ack so that the messages expire on the usage manager
1:a58d36b:         Thread.sleep(1500);
1:a58d36b:         connection2.send(createAck(consumerInfo2, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:a58d36b:         // And there should be no messages left now..
1:a58d36b:         assertNoMessagesLeft(connection2);
1:230a86c: 
1:a58d36b:         connection.send(closeConnectionInfo(connectionInfo));
1:a58d36b:         connection.send(closeConnectionInfo(connectionInfo2));
1:a58d36b:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestMessagesInLongTransactionExpire() {
1:66e8011:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.PERSISTENT), Integer.valueOf(DeliveryMode.NON_PERSISTENT)});
1:230a86c:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:230a86c:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:a58d36b:     }
1:230a86c: 
1:a58d36b:     public void testMessagesInLongTransactionExpire() throws Exception {
1:230a86c: 
1:a58d36b:         // Start a producer and consumer
1:a58d36b:         StubConnection connection = createConnection();
1:a58d36b:         ConnectionInfo connectionInfo = createConnectionInfo();
1:a58d36b:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:a58d36b:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:a58d36b:         connection.send(connectionInfo);
1:a58d36b:         connection.send(sessionInfo);
1:a58d36b:         connection.send(producerInfo);
1:a58d36b: 
1:a58d36b:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:230a86c: 
1:a58d36b:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:a58d36b:         consumerInfo.setPrefetchSize(1000);
1:a58d36b:         connection.send(consumerInfo);
1:230a86c: 
1:a58d36b:         // Start the tx..
1:a58d36b:         LocalTransactionId txid = createLocalTransaction(sessionInfo);
1:a58d36b:         connection.send(createBeginTransaction(connectionInfo, txid));
1:230a86c: 
1:a58d36b:         // m1 and m3 should not expire.. but the others should.
1:a58d36b:         Message m1 = createMessage(producerInfo, destination, deliveryMode);
1:a58d36b:         m1.setTransactionId(txid);
2:a58d36b:         connection.send(m1);
1:a58d36b:         Message m = createMessage(producerInfo, destination, deliveryMode, 1000);
1:a58d36b:         m.setTransactionId(txid);
1:a58d36b:         connection.send(m);
1:a58d36b:         Message m3 = createMessage(producerInfo, destination, deliveryMode);
1:a58d36b:         m3.setTransactionId(txid);
1:230a86c:         connection.send(m3);
1:a58d36b:         m = createMessage(producerInfo, destination, deliveryMode, 1000);
1:a58d36b:         m.setTransactionId(txid);
1:a58d36b:         connection.send(m);
1:230a86c: 
1:230a86c:         // Sleep before we commit so that the messages expire on the commit
1:230a86c:         // list..
1:230a86c:         Thread.sleep(1500);
1:a58d36b:         connection.send(createCommitTransaction1Phase(connectionInfo, txid));
1:230a86c: 
1:a58d36b:         m = receiveMessage(connection);
1:a58d36b:         assertNotNull(m);
1:a58d36b:         assertEquals(m1.getMessageId(), m.getMessageId());
1:a58d36b:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:230a86c:         // 2nd message received should be m3.. it should have expired 2nd
1:230a86c:         // message sent.
1:a58d36b:         m = receiveMessage(connection);
1:a58d36b:         assertNotNull(m);
1:a58d36b:         assertEquals(m3.getMessageId(), m.getMessageId());
1:a58d36b:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:a58d36b:         // And there should be no messages left now..
1:a58d36b:         assertNoMessagesLeft(connection);
1:230a86c: 
1:a58d36b:         connection.send(closeConnectionInfo(connectionInfo));
1:a58d36b:     }
1:230a86c: 
1:230a86c:     public void initCombosForTestMessagesInSubscriptionPendingListExpire() {
2:230a86c:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
2:230a86c:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
2:230a86c:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1:a58d36b:     }
1:230a86c: 
1:a58d36b:     public void testMessagesInSubscriptionPendingListExpire() throws Exception {
1:230a86c: 
1:a58d36b:         // Start a producer and consumer
1:a58d36b:         StubConnection connection = createConnection();
1:a58d36b:         ConnectionInfo connectionInfo = createConnectionInfo();
1:a58d36b:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:a58d36b:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:a58d36b:         connection.send(connectionInfo);
1:a58d36b:         connection.send(sessionInfo);
1:a58d36b:         connection.send(producerInfo);
1:a58d36b: 
1:a58d36b:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:a58d36b: 
1:a58d36b:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:a58d36b:         consumerInfo.setPrefetchSize(1);
1:a58d36b:         connection.send(consumerInfo);
1:230a86c: 
1:a58d36b:         // m1 and m3 should not expire.. but the others should.
1:a58d36b:         Message m1 = createMessage(producerInfo, destination, deliveryMode);
1:a58d36b:         connection.send(m1);
1:a58d36b:         connection.send(createMessage(producerInfo, destination, deliveryMode, 1000));
1:a58d36b:         Message m3 = createMessage(producerInfo, destination, deliveryMode);
1:230a86c:         connection.send(m3);
1:a58d36b:         connection.send(createMessage(producerInfo, destination, deliveryMode, 1000));
1:230a86c: 
1:a58d36b:         // Make sure only 1 message was delivered due to prefetch == 1
1:a58d36b:         Message m = receiveMessage(connection);
1:a58d36b:         assertNotNull(m);
1:a58d36b:         assertEquals(m1.getMessageId(), m.getMessageId());
1:a58d36b:         assertNoMessagesLeft(connection);
1:230a86c: 
1:a58d36b:         // Sleep before we ack so that the messages expire on the pending list..
1:230a86c:         Thread.sleep(1500);
1:a58d36b:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:230a86c:         // 2nd message received should be m3.. it should have expired 2nd
1:230a86c:         // message sent.
1:a58d36b:         m = receiveMessage(connection);
1:a58d36b:         assertNotNull(m);
1:a58d36b:         assertEquals(m3.getMessageId(), m.getMessageId());
1:a58d36b:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:230a86c: 
1:a58d36b:         // And there should be no messages left now..
1:a58d36b:         assertNoMessagesLeft(connection);
1:230a86c: 
1:a58d36b:         connection.send(closeConnectionInfo(connectionInfo));
1:a58d36b:     }
1:a58d36b: 
1:a58d36b:     public static Test suite() {
1:a58d36b:         return suite(MessageExpirationTest.class);
1:a58d36b:     }
1:230a86c: 
1:a58d36b:     public static void main(String[] args) {
1:a58d36b:         junit.textui.TestRunner.run(suite());
1:a58d36b:     }
1:a58d36b: 
1:a58d36b: }
============================================================================
author:Gary Tully
-------------------------------------------------------------------------------
commit:66e8011
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.PERSISTENT), Integer.valueOf(DeliveryMode.NON_PERSISTENT)});
commit:ce18ec8
/////////////////////////////////////////////////////////////////////////
1: 
commit:7ac1bb8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
1:     public int deliveryMode = DeliveryMode.NON_PERSISTENT;
1:     public byte destinationType = ActiveMQDestination.QUEUE_TYPE;
/////////////////////////////////////////////////////////////////////////
1:         // have aggressive expiry period to ensure no deadlock or clash
1:         policy.setExpireMessagesPeriod(100);
1:         
1:     public void testMessagesWaitingForUsageDecreaseExpire() throws Exception {
/////////////////////////////////////////////////////////////////////////
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Robert Davies
-------------------------------------------------------------------------------
commit:ad3799c
/////////////////////////////////////////////////////////////////////////
0:     public void XtestMessagesWaitingForUssageDecreaseExpire() throws Exception {
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
0:         broker.getUsageManager().getMemoryUsage().setLimit(1);
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE),
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 //Integer.valueOf(DeliveryMode.PERSISTENT)
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)
/////////////////////////////////////////////////////////////////////////
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)
0:                 Integer.valueOf(DeliveryMode.NON_PERSISTENT), 
0:                 Integer.valueOf(DeliveryMode.PERSISTENT)} );        
0:                 Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TOPIC_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)
commit:57ea011
/////////////////////////////////////////////////////////////////////////
1:         connection2.request(consumerInfo2);
commit:9ba5e19
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected PolicyEntry getDefaultPolicy() {
1:         PolicyEntry policy = super.getDefaultPolicy();
0:         //disable spooling
1:         policy.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
1:         return policy;
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:2b0024c
/////////////////////////////////////////////////////////////////////////
1:         broker.getSystemUsage().getMemoryUsage().setLimit(1);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:                                                               Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE)});
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT)});
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     public void xinitCombosForTestMessagesInSubscriptionPendingListExpire() {
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),});
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         Message message = createMessage(producerInfo, destination, deliveryMode);
1:         long now = System.currentTimeMillis();
1:         message.setTimestamp(now);
1:         message.setExpiration(now + timeToLive);
1: 
1:     public void initCombosForTestMessagesWaitingForUssageDecreaseExpire() {
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE),
0:                                                               Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),});
/////////////////////////////////////////////////////////////////////////
1: 
1:         // disable spooling
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         // Reduce the limit so that only 1 message can flow through the broker
1:         // at a time.
1: 
1: 
1:         // Produce in an async thread since the producer will be getting blocked
1:         // by the usage manager..
1:             public void run() {
1:                     connection.send(m1);
1:                     connection.send(m2);
1:                     connection.send(m3);
1:                     connection.send(m4);
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1: 
1: 
1: 
1:         // 2nd message received should be m3.. it should have expired 2nd
1:         // message sent.
1: 
1: 
1: 
1: 
0:      * Small regression. Looks like persistent messages to a queue are not being
0:      * timedout when in a long transaction. See:
0:      * http://issues.apache.org/activemq/browse/AMQ-1269 Commenting out the
0:      * DeliveryMode.PERSISTENT test combination for now.
1:     public void initCombosForTestMessagesInLongTransactionExpire() {
0:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT),
0:         // Integer.valueOf(DeliveryMode.PERSISTENT)
0:                              });
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         connection.send(m3);
1: 
1:         // Sleep before we commit so that the messages expire on the commit
1:         // list..
1:         Thread.sleep(1500);
1: 
1: 
1:         // 2nd message received should be m3.. it should have expired 2nd
1:         // message sent.
1: 
1: 
0:     public void TestMessagesInSubscriptionPendingListExpire() {
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
1:     public void initCombosForTestMessagesInSubscriptionPendingListExpire() {
1:         addCombinationValues("deliveryMode", new Object[] {Integer.valueOf(DeliveryMode.NON_PERSISTENT), Integer.valueOf(DeliveryMode.PERSISTENT)});
1:         addCombinationValues("destinationType", new Object[] {Byte.valueOf(ActiveMQDestination.QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TOPIC_TYPE),
1:                                                               Byte.valueOf(ActiveMQDestination.TEMP_QUEUE_TYPE), Byte.valueOf(ActiveMQDestination.TEMP_TOPIC_TYPE)});
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         connection.send(m3);
1: 
1: 
1:         Thread.sleep(1500);
1: 
1:         // 2nd message received should be m3.. it should have expired 2nd
1:         // message sent.
1: 
1: 
1: 
1: 
commit:70706ef
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Small regression.  Looks like persistent messages to a queue 
0:      * are not being timedout when in a long transaction.       
0:      * See: http://issues.apache.org/activemq/browse/AMQ-1269
1:      *
0:      * Commenting out the DeliveryMode.PERSISTENT test combination for now.
1:      */
0:                 //new Integer(DeliveryMode.PERSISTENT)
0:                 } );        
commit:a58d36b
/////////////////////////////////////////////////////////////////////////
0: /**
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.broker;
1: 
1: import javax.jms.DeliveryMode;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.SessionInfo;
1: 
1: public class MessageExpirationTest extends BrokerTestSupport {
1:     
1:     public ActiveMQDestination destination;
0:     public int deliveryMode;
1:     public int prefetch;
0:     public byte destinationType;
1:     public boolean durableConsumer;
1:     
1:     protected Message createMessage(ProducerInfo producerInfo, ActiveMQDestination destination, int deliveryMode, int timeToLive) {
0:     	Message message = createMessage(producerInfo, destination, deliveryMode);
0:     	long now = System.currentTimeMillis();
0:     	message.setTimestamp(now);
0:     	message.setExpiration(now+timeToLive);
1:         return message;
1:     }
1:     
1:     
0:     public void initCombosForTestMessagesWaitingForUssageDecreaseExpire() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE),
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 } );
1:     }
1: 
0:     public void testMessagesWaitingForUssageDecreaseExpire() throws Exception {
1:         
1:         // Start a producer
1:         final StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         final ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         
1:         // Start a consumer..
1:         final StubConnection connection2 = createConnection();
1:         ConnectionInfo connectionInfo2 = createConnectionInfo();
1:         SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2);
1:         connection2.send(connectionInfo2);
1:         connection2.send(sessionInfo2);
1:         
1:         destination = createDestinationInfo(connection2, connectionInfo2, destinationType);
1:         ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination);
1:         consumerInfo2.setPrefetchSize(1);
0:         connection2.send(consumerInfo2);
1:         
0:         // Reduce the limit so that only 1 message can flow through the broker at a time.
0:         broker.getMemoryManager().setLimit(1);
1:         
1:         final Message m1 = createMessage(producerInfo, destination, deliveryMode);
1:         final Message m2 = createMessage(producerInfo, destination, deliveryMode, 1000);
1:         final Message m3 = createMessage(producerInfo, destination, deliveryMode);
1:         final Message m4 = createMessage(producerInfo, destination, deliveryMode, 1000);
1:         
0:         // Produce in an async thread since the producer will be getting blocked by the usage manager..
1:         new Thread() {
0:         	public void run() {
1:                 // m1 and m3 should not expire.. but the others should.
1:                 try {
1: 					connection.send(m1);
0: 					connection.send(m2);
0: 					connection.send(m3);  
0: 					connection.send(m4);
0: 				} catch (Exception e) {
0: 					e.printStackTrace();
1: 				}        		
1:         	}
1:         }.start();
1:         
1:                 
1:         // Make sure only 1 message was delivered due to prefetch == 1
1:         Message m = receiveMessage(connection2);
1:         assertNotNull(m);
1:         assertEquals(m1.getMessageId(), m.getMessageId());
1:         assertNoMessagesLeft(connection);
1:         
1:         // Sleep before we ack so that the messages expire on the usage manager
1:         Thread.sleep(1500);
1:         connection2.send(createAck(consumerInfo2, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
0:         // 2nd message received should be m3.. it should have expired 2nd message sent.
1:         m = receiveMessage(connection2);
1:         assertNotNull(m);
1:         assertEquals(m3.getMessageId(), m.getMessageId());
1:         
1:         // Sleep before we ack so that the messages expire on the usage manager
1:         Thread.sleep(1500);
1:         connection2.send(createAck(consumerInfo2, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
1:         // And there should be no messages left now..
1:         assertNoMessagesLeft(connection2);
1:         
1:         connection.send(closeConnectionInfo(connectionInfo));
1:         connection.send(closeConnectionInfo(connectionInfo2));
1:     }
1:     
1:     
0:     public void initCombosForTestMessagesInLongTransactionExpire() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)
0:                 } );
1:     }
1:     
1:     public void testMessagesInLongTransactionExpire() throws Exception {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:         
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setPrefetchSize(1000);
1:         connection.send(consumerInfo);
1: 
1:         // Start the tx..
1:         LocalTransactionId txid = createLocalTransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1:         
1:         // m1 and m3 should not expire.. but the others should.
1:         Message m1 = createMessage(producerInfo, destination, deliveryMode);
1:         m1.setTransactionId(txid);
1:         connection.send(m1);
1:         Message m = createMessage(producerInfo, destination, deliveryMode, 1000);
1:         m.setTransactionId(txid);
1:         connection.send(m);
1:         Message m3 = createMessage(producerInfo, destination, deliveryMode);
1:         m3.setTransactionId(txid);
0:         connection.send(m3);  
1:         m = createMessage(producerInfo, destination, deliveryMode, 1000);
1:         m.setTransactionId(txid);
1:         connection.send(m);
1:         
0:         // Sleep before we commit so that the messages expire on the commit list..
1:         Thread.sleep(1500);        
1:         connection.send(createCommitTransaction1Phase(connectionInfo, txid));
1:                 
1:         m = receiveMessage(connection);
1:         assertNotNull(m);
1:         assertEquals(m1.getMessageId(), m.getMessageId());
1:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
0:         // 2nd message received should be m3.. it should have expired 2nd message sent.
1:         m = receiveMessage(connection);
1:         assertNotNull(m);
1:         assertEquals(m3.getMessageId(), m.getMessageId());
1:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
1:         // And there should be no messages left now..
1:         assertNoMessagesLeft(connection);
1:         
1:         connection.send(closeConnectionInfo(connectionInfo));
1:     }
1: 
1: 
0:     public void TestMessagesInSubscriptionPendingListExpire() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)
0:                 } );
1:     }
1:     
0:     public void initCombosForTestMessagesInSubscriptionPendingListExpire() {    
0:         addCombinationValues( "deliveryMode", new Object[]{ 
0:                 new Integer(DeliveryMode.NON_PERSISTENT), 
0:                 new Integer(DeliveryMode.PERSISTENT)} );        
0:         addCombinationValues( "destinationType", new Object[]{ 
0:                 new Byte(ActiveMQDestination.QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TOPIC_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_QUEUE_TYPE), 
0:                 new Byte(ActiveMQDestination.TEMP_TOPIC_TYPE)
0:                 } );
1:     }
1: 
1:     public void testMessagesInSubscriptionPendingListExpire() throws Exception {
1:         
1:         // Start a producer and consumer
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         destination = createDestinationInfo(connection, connectionInfo, destinationType);
1:         
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setPrefetchSize(1);
1:         connection.send(consumerInfo);
1:         
1:         // m1 and m3 should not expire.. but the others should.
1:         Message m1 = createMessage(producerInfo, destination, deliveryMode);
1:         connection.send(m1);
1:         connection.send(createMessage(producerInfo, destination, deliveryMode, 1000));
1:         Message m3 = createMessage(producerInfo, destination, deliveryMode);
0:         connection.send(m3);  
1:         connection.send(createMessage(producerInfo, destination, deliveryMode, 1000));
1:                 
1:         // Make sure only 1 message was delivered due to prefetch == 1
1:         Message m = receiveMessage(connection);
1:         assertNotNull(m);
1:         assertEquals(m1.getMessageId(), m.getMessageId());
1:         assertNoMessagesLeft(connection);
1:         
1:         // Sleep before we ack so that the messages expire on the pending list..
1:         Thread.sleep(1500);        
1:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
0:         // 2nd message received should be m3.. it should have expired 2nd message sent.
1:         m = receiveMessage(connection);
1:         assertNotNull(m);
1:         assertEquals(m3.getMessageId(), m.getMessageId());
1:         connection.send(createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE));
1:         
1:         // And there should be no messages left now..
1:         assertNoMessagesLeft(connection);
1:         
1:         connection.send(closeConnectionInfo(connectionInfo));
1:     }
1:     
1:     public static Test suite() {
1:         return suite(MessageExpirationTest.class);
1:     }
1:     
1:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
1: 
1: }
author:James Strachan
-------------------------------------------------------------------------------
commit:3b78804
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy;
0: import org.apache.activemq.broker.region.policy.VMPendingSubscriberMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected BrokerService createBroker() throws Exception {
1:         BrokerService broker = new BrokerService();
1:         broker.setPersistent(false);
0: 
0:         // lets disable spooling
0:         PolicyEntry policy = new PolicyEntry();
0:         policy.setPendingSubscriberPolicy(new VMPendingSubscriberMessageStoragePolicy());
0: 
0:         PolicyMap map = new PolicyMap();
0:         map.setDefaultEntry(policy);
0:         broker.setDestinationPolicy(map);
0:         
1:         return broker;
0:     }
0: 
============================================================================