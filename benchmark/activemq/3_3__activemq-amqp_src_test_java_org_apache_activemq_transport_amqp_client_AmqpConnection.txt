1:84cd815: /*
1:72839b7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:72839b7:  * contributor license agreements.  See the NOTICE file distributed with
1:72839b7:  * this work for additional information regarding copyright ownership.
1:72839b7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:72839b7:  * (the "License"); you may not use this file except in compliance with
1:72839b7:  * the License.  You may obtain a copy of the License at
1:72839b7:  *
1:72839b7:  *      http://www.apache.org/licenses/LICENSE-2.0
1:72839b7:  *
1:72839b7:  * Unless required by applicable law or agreed to in writing, software
1:72839b7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72839b7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72839b7:  * See the License for the specific language governing permissions and
1:72839b7:  * limitations under the License.
1:72839b7:  */
1:72839b7: package org.apache.activemq.transport.amqp.client;
2:72839b7: 
1:72839b7: import static org.apache.activemq.transport.amqp.AmqpSupport.CONNECTION_OPEN_FAILED;
1:72839b7: 
1:72839b7: import java.io.IOException;
1:72839b7: import java.net.URI;
1:72839b7: import java.nio.ByteBuffer;
1:72839b7: import java.util.Collections;
1:72839b7: import java.util.List;
1:72839b7: import java.util.Map;
1:72839b7: import java.util.UUID;
1:72839b7: import java.util.concurrent.ScheduledExecutorService;
1:4f7c9ec: import java.util.concurrent.ScheduledThreadPoolExecutor;
1:72839b7: import java.util.concurrent.ThreadFactory;
1:72839b7: import java.util.concurrent.TimeUnit;
1:72839b7: import java.util.concurrent.atomic.AtomicBoolean;
1:72839b7: import java.util.concurrent.atomic.AtomicLong;
1:72839b7: 
1:4b4cf7c: import org.apache.activemq.transport.InactivityIOException;
1:72839b7: import org.apache.activemq.transport.amqp.client.sasl.SaslAuthenticator;
1:82a5839: import org.apache.activemq.transport.amqp.client.transport.NettyTransportListener;
1:8448cf1: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
1:72839b7: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
1:82a5839: import org.apache.activemq.transport.amqp.client.util.IdGenerator;
1:8448cf1: import org.apache.activemq.transport.amqp.client.util.NoOpAsyncResult;
1:fddbac2: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
1:72839b7: import org.apache.qpid.proton.amqp.Symbol;
1:72839b7: import org.apache.qpid.proton.engine.Collector;
1:72839b7: import org.apache.qpid.proton.engine.Connection;
1:4b4cf7c: import org.apache.qpid.proton.engine.EndpointState;
1:72839b7: import org.apache.qpid.proton.engine.Event;
1:72839b7: import org.apache.qpid.proton.engine.Event.Type;
1:72839b7: import org.apache.qpid.proton.engine.Sasl;
1:72839b7: import org.apache.qpid.proton.engine.Transport;
1:72839b7: import org.apache.qpid.proton.engine.impl.CollectorImpl;
1:84cd815: import org.apache.qpid.proton.engine.impl.TransportImpl;
1:72839b7: import org.slf4j.Logger;
1:72839b7: import org.slf4j.LoggerFactory;
1:72839b7: 
1:8448cf1: import io.netty.buffer.ByteBuf;
1:8448cf1: import io.netty.buffer.Unpooled;
1:8448cf1: import io.netty.util.ReferenceCountUtil;
1:8448cf1: 
1:82a5839: public class AmqpConnection extends AmqpAbstractResource<Connection> implements NettyTransportListener {
1:72839b7: 
1:72839b7:     private static final Logger LOG = LoggerFactory.getLogger(AmqpConnection.class);
1:72839b7: 
1:8448cf1:     private static final NoOpAsyncResult NOOP_REQUEST = new NoOpAsyncResult();
1:8448cf1: 
1:72839b7:     private static final int DEFAULT_MAX_FRAME_SIZE = 1024 * 1024 * 1;
1:72839b7:     // NOTE: Limit default channel max to signed short range to deal with
1:72839b7:     //       brokers that don't currently handle the unsigned range well.
1:72839b7:     private static final int DEFAULT_CHANNEL_MAX = 32767;
1:72839b7:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1:72839b7: 
1:f37b005:     public static final long DEFAULT_CONNECT_TIMEOUT = 515000;
1:72839b7:     public static final long DEFAULT_CLOSE_TIMEOUT = 30000;
1:8448cf1:     public static final long DEFAULT_DRAIN_TIMEOUT = 60000;
1:72839b7: 
1:4f7c9ec:     private ScheduledThreadPoolExecutor serializer;
1:72839b7:     private final AtomicBoolean closed = new AtomicBoolean();
1:72839b7:     private final AtomicBoolean connected = new AtomicBoolean();
1:72839b7:     private final AtomicLong sessionIdGenerator = new AtomicLong();
1:272fb2b:     private final AtomicLong txIdGenerator = new AtomicLong();
1:72839b7:     private final Collector protonCollector = new CollectorImpl();
1:31c55f7:     private final org.apache.activemq.transport.amqp.client.transport.NettyTransport transport;
1:72839b7:     private final Transport protonTransport = Transport.Factory.create();
1:72839b7: 
1:72839b7:     private final String username;
1:72839b7:     private final String password;
1:72839b7:     private final URI remoteURI;
1:72839b7:     private final String connectionId;
1:72839b7:     private List<Symbol> offeredCapabilities = Collections.emptyList();
1:72839b7:     private Map<Symbol, Object> offeredProperties = Collections.emptyMap();
1:72839b7: 
1:24a7941:     private volatile AmqpFrameValidator sentFrameInspector;
1:24a7941:     private volatile AmqpFrameValidator receivedFrameInspector;
1:4b4cf7c:     private AmqpConnectionListener listener;
1:72839b7:     private SaslAuthenticator authenticator;
1:ce5628a:     private String mechanismRestriction;
1:ce5628a:     private String authzid;
1:72839b7: 
1:4b4cf7c:     private int idleTimeout = 0;
1:4b4cf7c:     private boolean idleProcessingDisabled;
1:72839b7:     private String containerId;
1:72839b7:     private boolean authenticated;
1:72839b7:     private int channelMax = DEFAULT_CHANNEL_MAX;
1:72839b7:     private long connectTimeout = DEFAULT_CONNECT_TIMEOUT;
1:72839b7:     private long closeTimeout = DEFAULT_CLOSE_TIMEOUT;
1:8448cf1:     private long drainTimeout = DEFAULT_DRAIN_TIMEOUT;
1:84cd815:     private boolean trace;
1:72839b7: 
1:31c55f7:     public AmqpConnection(org.apache.activemq.transport.amqp.client.transport.NettyTransport transport, String username, String password) {
1:72839b7:         setEndpoint(Connection.Factory.create());
1:72839b7:         getEndpoint().collect(protonCollector);
1:72839b7: 
1:72839b7:         this.transport = transport;
1:72839b7:         this.username = username;
1:72839b7:         this.password = password;
1:72839b7:         this.connectionId = CONNECTION_ID_GENERATOR.generateId();
1:82a5839:         this.remoteURI = transport.getRemoteLocation();
1:72839b7: 
1:4f7c9ec:         this.serializer = new ScheduledThreadPoolExecutor(1, new ThreadFactory() {
1:72839b7: 
3:72839b7:             @Override
1:72839b7:             public Thread newThread(Runnable runner) {
1:72839b7:                 Thread serial = new Thread(runner);
1:72839b7:                 serial.setDaemon(true);
1:72839b7:                 serial.setName(toString());
1:72839b7:                 return serial;
2:72839b7:             }
1:84cd815:         });
1:84cd815: 
1:4f7c9ec:         // Ensure timely shutdown
1:4f7c9ec:         this.serializer.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
1:4f7c9ec:         this.serializer.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
1:4f7c9ec: 
1:72839b7:         this.transport.setTransportListener(this);
1:88efa01:         this.transport.setMaxFrameSize(getMaxFrameSize());
1:84cd815:     }
1:72839b7: 
1:72839b7:     public void connect() throws Exception {
1:72839b7:         if (connected.compareAndSet(false, true)) {
1:72839b7:             transport.connect();
1:72839b7: 
1:72839b7:             final ClientFuture future = new ClientFuture();
1:72839b7:             serializer.execute(new Runnable() {
1:84cd815:                 @Override
1:72839b7:                 public void run() {
1:72839b7:                     getEndpoint().setContainer(safeGetContainerId());
1:72839b7:                     getEndpoint().setHostname(remoteURI.getHost());
1:72839b7:                     if (!getOfferedCapabilities().isEmpty()) {
1:72839b7:                         getEndpoint().setOfferedCapabilities(getOfferedCapabilities().toArray(new Symbol[0]));
1:84cd815:                     }
1:72839b7:                     if (!getOfferedProperties().isEmpty()) {
1:72839b7:                         getEndpoint().setProperties(getOfferedProperties());
1:84cd815:                     }
1:72839b7: 
1:4b4cf7c:                     if (getIdleTimeout() > 0) {
1:4b4cf7c:                         protonTransport.setIdleTimeout(getIdleTimeout());
1:4b4cf7c:                     }
1:72839b7:                     protonTransport.setMaxFrameSize(getMaxFrameSize());
1:72839b7:                     protonTransport.setChannelMax(getChannelMax());
1:72839b7:                     protonTransport.bind(getEndpoint());
1:72839b7:                     Sasl sasl = protonTransport.sasl();
1:72839b7:                     if (sasl != null) {
1:72839b7:                         sasl.client();
1:72839b7:                     }
1:ce5628a:                     authenticator = new SaslAuthenticator(sasl, username, password, authzid, mechanismRestriction);
1:24a7941:                     ((TransportImpl) protonTransport).setProtocolTracer(new AmqpProtocolTracer(AmqpConnection.this));
1:72839b7:                     open(future);
1:72839b7: 
1:8448cf1:                     pumpToProtonTransport(future);
1:72839b7:                 }
2:72839b7:             });
1:72839b7: 
1:8a34ca0:             try {
1:8a34ca0:                 if (connectTimeout <= 0) {
1:8a34ca0:                     future.sync();
1:8a34ca0:                 } else {
1:8a34ca0:                     future.sync(connectTimeout, TimeUnit.MILLISECONDS);
1:8a34ca0:                     if (getEndpoint().getRemoteState() != EndpointState.ACTIVE) {
1:8a34ca0:                         throw new IOException("Failed to connect after configured timeout.");
1:8a34ca0:                     }
1:a812131:                 }
1:8a34ca0:             } catch (Throwable error) {
1:8a34ca0:                 try {
1:8a34ca0:                     close();
1:8a34ca0:                 } catch (Throwable ignore) {}
1:8a34ca0: 
1:8a34ca0:                 throw error;
1:72839b7:             }
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     public boolean isConnected() {
1:72839b7:         return transport.isConnected() && connected.get();
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void close() {
1:72839b7:         if (closed.compareAndSet(false, true)) {
1:72839b7:             final ClientFuture request = new ClientFuture();
1:72839b7:             serializer.execute(new Runnable() {
1:72839b7: 
1:84cd815:                 @Override
1:72839b7:                 public void run() {
1:72839b7:                     try {
1:72839b7: 
1:72839b7:                         // If we are not connected then there is nothing we can do now
1:72839b7:                         // just signal success.
1:72839b7:                         if (!transport.isConnected()) {
1:72839b7:                             request.onSuccess();
1:72839b7:                         }
1:72839b7: 
1:72839b7:                         if (getEndpoint() != null) {
1:72839b7:                             close(request);
2:72839b7:                         } else {
1:72839b7:                             request.onSuccess();
1:72839b7:                         }
1:72839b7: 
1:8448cf1:                         pumpToProtonTransport(request);
1:72839b7:                     } catch (Exception e) {
1:72839b7:                         LOG.debug("Caught exception while closing proton connection");
1:72839b7:                     }
1:72839b7:                 }
1:72839b7:             });
1:72839b7: 
1:82a5839:             try {
1:72839b7:                 if (closeTimeout <= 0) {
1:72839b7:                     request.sync();
1:72839b7:                 } else {
1:72839b7:                     request.sync(closeTimeout, TimeUnit.MILLISECONDS);
1:72839b7:                 }
1:72839b7:             } catch (IOException e) {
1:72839b7:                 LOG.warn("Error caught while closing Provider: ", e.getMessage());
1:72839b7:             } finally {
1:72839b7:                 if (transport != null) {
1:72839b7:                     try {
1:82a5839:                         transport.close();
1:72839b7:                     } catch (Exception e) {
1:72839b7:                         LOG.debug("Cuaght exception while closing down Transport: {}", e.getMessage());
1:72839b7:                     }
1:72839b7:                 }
1:72839b7: 
1:a35d23d:                 serializer.shutdownNow();
1:a35d23d:                 try {
1:a35d23d:                     if (!serializer.awaitTermination(10, TimeUnit.SECONDS)) {
1:a35d23d:                         LOG.warn("Serializer didn't shutdown cleanly");
1:a35d23d:                     }
1:a35d23d:                 } catch (InterruptedException e) {
1:a35d23d:                 }
1:72839b7:             }
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Creates a new Session instance used to create AMQP resources like
1:72839b7:      * senders and receivers.
1:72839b7:      *
1:72839b7:      * @return a new AmqpSession that can be used to create links.
1:72839b7:      *
1:72839b7:      * @throws Exception if an error occurs during creation.
1:72839b7:      */
1:72839b7:     public AmqpSession createSession() throws Exception {
1:72839b7:         checkClosed();
1:72839b7: 
1:72839b7:         final AmqpSession session = new AmqpSession(AmqpConnection.this, getNextSessionId());
1:72839b7:         final ClientFuture request = new ClientFuture();
1:72839b7: 
1:72839b7:         serializer.execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:72839b7:                 checkClosed();
1:72839b7:                 session.setEndpoint(getEndpoint().session());
1:1a0f73e:                 session.setStateInspector(getStateInspector());
1:72839b7:                 session.open(request);
1:8448cf1:                 pumpToProtonTransport(request);
1:72839b7:             }
1:72839b7:         });
1:72839b7: 
1:72839b7:         request.sync();
1:72839b7: 
1:72839b7:         return session;
1:72839b7:     }
1:72839b7: 
1:31834ed:     //----- Access to low level IO for specific test cases -------------------//
1:31834ed: 
1:31834ed:     public void sendRawBytes(final byte[] rawData) throws Exception {
1:31834ed:         checkClosed();
1:31834ed: 
1:31834ed:         final ClientFuture request = new ClientFuture();
1:31834ed: 
1:31834ed:         serializer.execute(new Runnable() {
1:31834ed: 
1:31834ed:             @Override
1:31834ed:             public void run() {
1:31834ed:                 checkClosed();
1:31834ed:                 try {
1:82a5839:                     transport.send(Unpooled.wrappedBuffer(rawData));
1:31834ed:                 } catch (IOException e) {
1:31834ed:                     fireClientException(e);
1:31834ed:                 } finally {
1:31834ed:                     request.onSuccess();
1:31834ed:                 }
1:31834ed:             }
1:31834ed:         });
1:31834ed: 
1:31834ed:         request.sync();
1:31834ed:     }
1:31834ed: 
1:72839b7:     //----- Configuration accessors ------------------------------------------//
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the user name that was used to authenticate this connection.
1:72839b7:      */
1:72839b7:     public String getUsername() {
1:72839b7:         return username;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the password that was used to authenticate this connection.
1:72839b7:      */
1:72839b7:     public String getPassword() {
1:72839b7:         return password;
1:72839b7:     }
1:72839b7: 
1:ce5628a:     public void setAuthzid(String authzid) {
1:ce5628a:         this.authzid = authzid;
1:72839b7:     }
1:72839b7: 
1:ce5628a:     public String getAuthzid() {
1:ce5628a:         return authzid;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the URI of the remote peer this connection attached to.
1:72839b7:      */
1:72839b7:     public URI getRemoteURI() {
1:72839b7:         return remoteURI;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the container ID that will be set as the container Id.
1:72839b7:      */
1:72839b7:     public String getContainerId() {
1:72839b7:         return this.containerId;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Sets the container Id that will be configured on the connection prior to
1:72839b7:      * connecting to the remote peer.  Calling this after connect has no effect.
1:72839b7:      *
1:72839b7:      * @param containerId
1:72839b7:      * 		  the container Id to use on the connection.
1:72839b7:      */
1:72839b7:     public void setContainerId(String containerId) {
1:72839b7:         this.containerId = containerId;
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * @return the currently set Max Frame Size value.
1:72839b7:      */
1:72839b7:     public int getMaxFrameSize() {
1:72839b7:         return DEFAULT_MAX_FRAME_SIZE;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public int getChannelMax() {
1:72839b7:         return channelMax;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setChannelMax(int channelMax) {
1:72839b7:         this.channelMax = channelMax;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public long getConnectTimeout() {
1:72839b7:         return connectTimeout;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setConnectTimeout(long connectTimeout) {
1:72839b7:         this.connectTimeout = connectTimeout;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public long getCloseTimeout() {
1:72839b7:         return closeTimeout;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setCloseTimeout(long closeTimeout) {
1:72839b7:         this.closeTimeout = closeTimeout;
1:72839b7:     }
1:72839b7: 
1:8448cf1:     public long getDrainTimeout() {
1:8448cf1:         return drainTimeout;
1:8448cf1:     }
1:8448cf1: 
1:8448cf1:     public void setDrainTimeout(long drainTimeout) {
1:8448cf1:         this.drainTimeout = drainTimeout;
1:8448cf1:     }
1:8448cf1: 
1:72839b7:     public List<Symbol> getOfferedCapabilities() {
1:72839b7:         return offeredCapabilities;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setOfferedCapabilities(List<Symbol> offeredCapabilities) {
1:72839b7:         if (offeredCapabilities != null) {
1:72839b7:             offeredCapabilities = Collections.emptyList();
1:72839b7:         }
1:72839b7: 
1:72839b7:         this.offeredCapabilities = offeredCapabilities;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public Map<Symbol, Object> getOfferedProperties() {
1:72839b7:         return offeredProperties;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public void setOfferedProperties(Map<Symbol, Object> offeredProperties) {
1:72839b7:         if (offeredProperties != null) {
1:72839b7:             offeredProperties = Collections.emptyMap();
1:72839b7:         }
1:72839b7: 
1:72839b7:         this.offeredProperties = offeredProperties;
1:72839b7:     }
1:72839b7: 
1:72839b7:     public Connection getConnection() {
1:fddbac2:         return UnmodifiableProxy.connectionProxy(getEndpoint());
1:72839b7:     }
1:72839b7: 
1:4b4cf7c:     public AmqpConnectionListener getListener() {
1:4b4cf7c:         return listener;
1:4b4cf7c:     }
1:4b4cf7c: 
1:4b4cf7c:     public void setListener(AmqpConnectionListener listener) {
1:4b4cf7c:         this.listener = listener;
1:4b4cf7c:     }
1:4b4cf7c: 
1:4b4cf7c:     public int getIdleTimeout() {
1:4b4cf7c:         return idleTimeout;
1:4b4cf7c:     }
1:4b4cf7c: 
1:4b4cf7c:     public void setIdleTimeout(int idleTimeout) {
1:4b4cf7c:         this.idleTimeout = idleTimeout;
1:4b4cf7c:     }
1:4b4cf7c: 
1:4b4cf7c:     public void setIdleProcessingDisabled(boolean value) {
1:4b4cf7c:         this.idleProcessingDisabled = value;
1:4b4cf7c:     }
1:4b4cf7c: 
1:4b4cf7c:     public boolean isIdleProcessingDisabled() {
1:4b4cf7c:         return idleProcessingDisabled;
1:4b4cf7c:     }
1:4b4cf7c: 
1:72839b7:     /**
1:ce5628a:      * Sets a restriction on the SASL mechanism to use (if offered by the server).
1:ce5628a:      *
1:ce5628a:      * @param mechanismRestriction the mechanism to use
1:ce5628a:      */
1:ce5628a:     public void setMechanismRestriction(String mechanismRestriction) {
1:ce5628a:         this.mechanismRestriction = mechanismRestriction;
1:72839b7:     }
1:72839b7: 
1:ce5628a:     public String getMechanismRestriction() {
1:ce5628a:         return mechanismRestriction;
1:72839b7:     }
1:72839b7: 
1:84cd815:     public boolean isTraceFrames() {
1:84cd815:         return trace;
1:84cd815:     }
1:84cd815: 
1:84cd815:     public void setTraceFrames(boolean trace) {
1:84cd815:         this.trace = trace;
1:84cd815:     }
1:84cd815: 
1:24a7941:     public AmqpFrameValidator getSentFrameInspector() {
1:24a7941:         return sentFrameInspector;
1:24a7941:     }
1:24a7941: 
1:24a7941:     public void setSentFrameInspector(AmqpFrameValidator amqpFrameInspector) {
1:24a7941:         this.sentFrameInspector = amqpFrameInspector;
1:24a7941:     }
1:24a7941: 
1:24a7941:     public AmqpFrameValidator getReceivedFrameInspector() {
1:24a7941:         return receivedFrameInspector;
1:24a7941:     }
1:24a7941: 
1:24a7941:     public void setReceivedFrameInspector(AmqpFrameValidator amqpFrameInspector) {
1:24a7941:         this.receivedFrameInspector = amqpFrameInspector;
1:24a7941:     }
1:24a7941: 
1:72839b7:     //----- Internal getters used from the child AmqpResource classes --------//
1:72839b7: 
1:72839b7:     ScheduledExecutorService getScheduler() {
1:72839b7:         return this.serializer;
1:72839b7:     }
1:72839b7: 
1:72839b7:     Connection getProtonConnection() {
1:72839b7:         return getEndpoint();
1:72839b7:     }
1:72839b7: 
1:272fb2b:     String getConnectionId() {
1:272fb2b:         return this.connectionId;
1:272fb2b:     }
1:272fb2b: 
1:272fb2b:     AmqpTransactionId getNextTransactionId() {
1:272fb2b:         return new AmqpTransactionId(connectionId + ":" + txIdGenerator.incrementAndGet());
1:272fb2b:     }
1:272fb2b: 
1:72839b7:     void pumpToProtonTransport() {
1:8448cf1:         pumpToProtonTransport(NOOP_REQUEST);
1:8448cf1:     }
1:8448cf1: 
1:8448cf1:     void pumpToProtonTransport(AsyncResult request) {
1:72839b7:         try {
1:72839b7:             boolean done = false;
1:72839b7:             while (!done) {
1:72839b7:                 ByteBuffer toWrite = protonTransport.getOutputBuffer();
1:72839b7:                 if (toWrite != null && toWrite.hasRemaining()) {
1:82a5839:                     ByteBuf outbound = transport.allocateSendBuffer(toWrite.remaining());
1:82a5839:                     outbound.writeBytes(toWrite);
1:82a5839:                     transport.send(outbound);
1:72839b7:                     protonTransport.outputConsumed();
1:72839b7:                 } else {
1:72839b7:                     done = true;
1:72839b7:                 }
1:72839b7:             }
1:72839b7:         } catch (IOException e) {
1:72839b7:             fireClientException(e);
1:8448cf1:             request.onFailure(e);
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     //----- Transport listener event hooks -----------------------------------//
1:72839b7: 
1:72839b7:     @Override
1:82a5839:     public void onData(final ByteBuf incoming) {
1:82a5839: 
1:82a5839:         // We need to retain until the serializer gets around to processing it.
1:82a5839:         ReferenceCountUtil.retain(incoming);
1:82a5839: 
1:72839b7:         serializer.execute(new Runnable() {
1:72839b7: 
1:72839b7:             @Override
1:72839b7:             public void run() {
1:82a5839:                 ByteBuffer source = incoming.nioBuffer();
1:31c55f7:                 LOG.trace("Client Received from Broker {} bytes:", source.remaining());
1:72839b7: 
1:4b4cf7c:                 if (protonTransport.isClosed()) {
1:4b4cf7c:                     LOG.debug("Ignoring incoming data because transport is closed");
1:4b4cf7c:                     return;
1:4b4cf7c:                 }
1:4b4cf7c: 
1:72839b7:                 do {
1:72839b7:                     ByteBuffer buffer = protonTransport.getInputBuffer();
1:72839b7:                     int limit = Math.min(buffer.remaining(), source.remaining());
1:72839b7:                     ByteBuffer duplicate = source.duplicate();
1:72839b7:                     duplicate.limit(source.position() + limit);
1:72839b7:                     buffer.put(duplicate);
1:72839b7:                     protonTransport.processInput();
1:72839b7:                     source.position(source.position() + limit);
1:72839b7:                 } while (source.hasRemaining());
1:72839b7: 
1:82a5839:                 ReferenceCountUtil.release(incoming);
1:82a5839: 
1:72839b7:                 // Process the state changes from the latest data and then answer back
1:72839b7:                 // any pending updates to the Broker.
1:72839b7:                 processUpdates();
4:72839b7:                 pumpToProtonTransport();
1:72839b7:             }
1:72839b7:         });
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     public void onTransportClosed() {
1:72839b7:         LOG.debug("The transport has unexpectedly closed");
1:31c55f7:         failed(getOpenAbortException());
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     public void onTransportError(Throwable cause) {
1:72839b7:         fireClientException(cause);
1:72839b7:     }
1:72839b7: 
1:72839b7:     //----- Internal implementation ------------------------------------------//
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doOpenCompletion() {
1:72839b7:         // If the remote indicates that a close is pending, don't open.
1:f595f3c:         if (getEndpoint().getRemoteProperties() == null ||
1:f595f3c:             !getEndpoint().getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {
1:4b4cf7c: 
1:4b4cf7c:             if (!isIdleProcessingDisabled()) {
1:037f91d:                 // Using nano time since it is not related to the wall clock, which may change
1:037f91d:                 long initialNow = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
1:037f91d:                 long initialKeepAliveDeadline = protonTransport.tick(initialNow);
1:f82eccd:                 if (initialKeepAliveDeadline != 0) {
1:4b4cf7c: 
1:4b4cf7c:                     getScheduler().schedule(new Runnable() {
1:4b4cf7c: 
1:4b4cf7c:                         @Override
1:4b4cf7c:                         public void run() {
1:4b4cf7c:                             try {
1:4b4cf7c:                                 if (getEndpoint().getLocalState() != EndpointState.CLOSED) {
1:4b4cf7c:                                     LOG.debug("Client performing next idle check");
1:037f91d:                                     // Using nano time since it is not related to the wall clock, which may change
1:037f91d:                                     long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
1:f82eccd:                                     long deadline = protonTransport.tick(now);
1:f82eccd: 
1:4b4cf7c:                                     pumpToProtonTransport();
1:4b4cf7c:                                     if (protonTransport.isClosed()) {
1:4b4cf7c:                                         LOG.debug("Transport closed after inactivity check.");
1:f82eccd:                                         throw new InactivityIOException("Channel was inactive for too long");
1:f82eccd:                                     } else {
1:f82eccd:                                         if(deadline != 0) {
1:f82eccd:                                             getScheduler().schedule(this, deadline - now, TimeUnit.MILLISECONDS);
1:f82eccd:                                         }
1:4b4cf7c:                                     }
1:4b4cf7c:                                 }
1:4b4cf7c:                             } catch (Exception e) {
1:72839b7:                                 try {
1:4b4cf7c:                                     transport.close();
1:82a5839:                                 } catch (IOException e1) {
1:82a5839:                                 }
1:4b4cf7c:                                 fireClientException(e);
1:4b4cf7c:                             }
1:4b4cf7c:                         }
1:037f91d:                     }, initialKeepAliveDeadline - initialNow, TimeUnit.MILLISECONDS);
1:4b4cf7c:                 }
1:4b4cf7c:             }
1:72839b7:             super.doOpenCompletion();
1:4b4cf7c:         }
1:72839b7:     }
1:4b4cf7c: 
1:72839b7:     @Override
1:72839b7:     protected void doOpenInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectOpenedResource(getConnection());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     @Override
1:72839b7:     protected void doClosedInspection() {
1:7c06d8d:         try {
1:7c06d8d:             getStateInspector().inspectClosedResource(getConnection());
1:7c06d8d:         } catch (Throwable error) {
1:7c06d8d:             getStateInspector().markAsInvalid(error.getMessage());
1:7c06d8d:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     protected void fireClientException(Throwable ex) {
1:4b4cf7c:         AmqpConnectionListener listener = this.listener;
1:72839b7:         if (listener != null) {
1:4b4cf7c:             listener.onException(ex);
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     protected void checkClosed() throws IllegalStateException {
1:72839b7:         if (closed.get()) {
1:72839b7:             throw new IllegalStateException("The Connection is already closed");
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     private void processUpdates() {
1:72839b7:         try {
1:72839b7:             Event protonEvent = null;
1:72839b7:             while ((protonEvent = protonCollector.peek()) != null) {
1:72839b7:                 if (!protonEvent.getType().equals(Type.TRANSPORT)) {
1:31c55f7:                     LOG.trace("Client: New Proton Event: {}", protonEvent.getType());
1:72839b7:                 }
1:72839b7: 
1:d9e22a9:                 AmqpEventSink amqpEventSink = null;
1:72839b7:                 switch (protonEvent.getType()) {
1:72839b7:                     case CONNECTION_REMOTE_CLOSE:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getConnection().getContext();
1:d9e22a9:                         amqpEventSink.processRemoteClose(this);
1:72839b7:                         break;
1:72839b7:                     case CONNECTION_REMOTE_OPEN:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getConnection().getContext();
1:d9e22a9:                         amqpEventSink.processRemoteOpen(this);
1:72839b7:                         break;
1:72839b7:                     case SESSION_REMOTE_CLOSE:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getSession().getContext();
1:d9e22a9:                         amqpEventSink.processRemoteClose(this);
1:72839b7:                         break;
1:72839b7:                     case SESSION_REMOTE_OPEN:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getSession().getContext();
1:d9e22a9:                         amqpEventSink.processRemoteOpen(this);
1:72839b7:                         break;
1:72839b7:                     case LINK_REMOTE_CLOSE:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:d9e22a9:                         amqpEventSink.processRemoteClose(this);
1:72839b7:                         break;
1:72839b7:                     case LINK_REMOTE_DETACH:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:d9e22a9:                         amqpEventSink.processRemoteDetach(this);
1:72839b7:                         break;
1:72839b7:                     case LINK_REMOTE_OPEN:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:d9e22a9:                         amqpEventSink.processRemoteOpen(this);
1:72839b7:                         break;
1:72839b7:                     case LINK_FLOW:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:d9e22a9:                         amqpEventSink.processFlowUpdates(this);
1:72839b7:                         break;
1:72839b7:                     case DELIVERY:
1:d9e22a9:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:d9e22a9:                         amqpEventSink.processDeliveryUpdates(this);
1:72839b7:                         break;
1:72839b7:                     default:
1:72839b7:                         break;
1:72839b7:                 }
1:72839b7: 
1:72839b7:                 protonCollector.pop();
1:72839b7:             }
1:72839b7: 
1:72839b7:             // We have to do this to pump SASL bytes in as SASL is not event driven yet.
1:72839b7:             if (!authenticated) {
1:72839b7:                 processSaslAuthentication();
1:72839b7:             }
1:72839b7:         } catch (Exception ex) {
1:72839b7:             LOG.warn("Caught Exception during update processing: {}", ex.getMessage(), ex);
1:72839b7:             fireClientException(ex);
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     private void processSaslAuthentication() {
1:72839b7:         if (authenticated || authenticator == null) {
1:72839b7:             return;
1:72839b7:         }
1:72839b7: 
1:72839b7:         try {
1:72839b7:             if (authenticator.authenticate()) {
1:72839b7:                 authenticator = null;
1:72839b7:                 authenticated = true;
1:72839b7:             }
1:72839b7:         } catch (SecurityException ex) {
1:72839b7:             failed(ex);
1:72839b7:         }
1:72839b7:     }
1:72839b7: 
1:72839b7:     private String getNextSessionId() {
1:72839b7:         return connectionId + ":" + sessionIdGenerator.incrementAndGet();
1:72839b7:     }
1:72839b7: 
1:72839b7:     private String safeGetContainerId() {
1:72839b7:         String containerId = getContainerId();
1:72839b7:         if (containerId == null || containerId.isEmpty()) {
1:72839b7:             containerId = UUID.randomUUID().toString();
1:72839b7:         }
1:72839b7: 
1:72839b7:         return containerId;
1:84cd815:     }
1:84cd815: 
1:72839b7:     @Override
1:72839b7:     public String toString() {
1:72839b7:         return "AmqpConnection { " + connectionId + " }";
1:72839b7:     }
1:72839b7: }
============================================================================
author:Robbie Gemmell
-------------------------------------------------------------------------------
commit:f82eccd
/////////////////////////////////////////////////////////////////////////
1:                 if (initialKeepAliveDeadline != 0) {
/////////////////////////////////////////////////////////////////////////
1:                                     long deadline = protonTransport.tick(now);
1: 
1:                                         throw new InactivityIOException("Channel was inactive for too long");
1:                                     } else {
1:                                         if(deadline != 0) {
1:                                             getScheduler().schedule(this, deadline - now, TimeUnit.MILLISECONDS);
1:                                         }
author:Timothy Bish
-------------------------------------------------------------------------------
commit:88efa01
/////////////////////////////////////////////////////////////////////////
1:         this.transport.setMaxFrameSize(getMaxFrameSize());
commit:4f7c9ec
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ScheduledThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
1:     private ScheduledThreadPoolExecutor serializer;
/////////////////////////////////////////////////////////////////////////
1:         this.serializer = new ScheduledThreadPoolExecutor(1, new ThreadFactory() {
/////////////////////////////////////////////////////////////////////////
1:         // Ensure timely shutdown
1:         this.serializer.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
1:         this.serializer.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
1: 
commit:fddbac2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
/////////////////////////////////////////////////////////////////////////
1:         return UnmodifiableProxy.connectionProxy(getEndpoint());
commit:8a34ca0
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 if (connectTimeout <= 0) {
1:                     future.sync();
1:                 } else {
1:                     future.sync(connectTimeout, TimeUnit.MILLISECONDS);
1:                     if (getEndpoint().getRemoteState() != EndpointState.ACTIVE) {
1:                         throw new IOException("Failed to connect after configured timeout.");
1:                     }
1:             } catch (Throwable error) {
1:                 try {
1:                     close();
1:                 } catch (Throwable ignore) {}
1: 
1:                 throw error;
commit:24a7941
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private volatile AmqpFrameValidator sentFrameInspector;
1:     private volatile AmqpFrameValidator receivedFrameInspector;
/////////////////////////////////////////////////////////////////////////
1:                     ((TransportImpl) protonTransport).setProtocolTracer(new AmqpProtocolTracer(AmqpConnection.this));
/////////////////////////////////////////////////////////////////////////
1:     public AmqpFrameValidator getSentFrameInspector() {
1:         return sentFrameInspector;
1:     }
1: 
1:     public void setSentFrameInspector(AmqpFrameValidator amqpFrameInspector) {
1:         this.sentFrameInspector = amqpFrameInspector;
1:     }
1: 
1:     public AmqpFrameValidator getReceivedFrameInspector() {
1:         return receivedFrameInspector;
1:     }
1: 
1:     public void setReceivedFrameInspector(AmqpFrameValidator amqpFrameInspector) {
1:         this.receivedFrameInspector = amqpFrameInspector;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:a35d23d
/////////////////////////////////////////////////////////////////////////
1:                 serializer.shutdownNow();
1:                 try {
1:                     if (!serializer.awaitTermination(10, TimeUnit.SECONDS)) {
1:                         LOG.warn("Serializer didn't shutdown cleanly");
1:                     }
1:                 } catch (InterruptedException e) {
1:                 }
commit:84cd815
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.engine.impl.ProtocolTracer;
1: import org.apache.qpid.proton.engine.impl.TransportImpl;
0: import org.apache.qpid.proton.framing.TransportFrame;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger TRACE_FRAMES = LoggerFactory.getLogger(AmqpConnection.class.getPackage().getName() + ".FRAMES");
/////////////////////////////////////////////////////////////////////////
1:     private boolean trace;
/////////////////////////////////////////////////////////////////////////
0:                     updateTracer();
/////////////////////////////////////////////////////////////////////////
1:     public boolean isTraceFrames() {
1:         return trace;
1:     }
1: 
1:     public void setTraceFrames(boolean trace) {
1:         this.trace = trace;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void updateTracer() {
0:         if (isTraceFrames()) {
0:             ((TransportImpl) protonTransport).setProtocolTracer(new ProtocolTracer() {
1:                 @Override
0:                 public void receivedFrame(TransportFrame transportFrame) {
0:                     TRACE_FRAMES.trace("{} | RECV: {}", getRemoteURI(), transportFrame.getBody());
1:                 }
1: 
1:                 @Override
0:                 public void sentFrame(TransportFrame transportFrame) {
0:                     TRACE_FRAMES.trace("{} | SENT: {}", this, transportFrame.getBody());
1:                 }
1:             });
1:         }
1:     }
1: 
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final org.apache.activemq.transport.amqp.client.transport.NettyTransport transport;
/////////////////////////////////////////////////////////////////////////
1:     public AmqpConnection(org.apache.activemq.transport.amqp.client.transport.NettyTransport transport, String username, String password) {
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace("Client Received from Broker {} bytes:", source.remaining());
/////////////////////////////////////////////////////////////////////////
1:         failed(getOpenAbortException());
/////////////////////////////////////////////////////////////////////////
1:                     LOG.trace("Client: New Proton Event: {}", protonEvent.getType());
commit:f595f3c
/////////////////////////////////////////////////////////////////////////
1:         if (getEndpoint().getRemoteProperties() == null ||
1:             !getEndpoint().getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {
commit:8448cf1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.AsyncResult;
1: import org.apache.activemq.transport.amqp.client.util.NoOpAsyncResult;
/////////////////////////////////////////////////////////////////////////
1: import io.netty.buffer.ByteBuf;
1: import io.netty.buffer.Unpooled;
1: import io.netty.util.ReferenceCountUtil;
1: 
1:     private static final NoOpAsyncResult NOOP_REQUEST = new NoOpAsyncResult();
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static final long DEFAULT_DRAIN_TIMEOUT = 60000;
/////////////////////////////////////////////////////////////////////////
1:     private long drainTimeout = DEFAULT_DRAIN_TIMEOUT;
/////////////////////////////////////////////////////////////////////////
1:                     pumpToProtonTransport(future);
/////////////////////////////////////////////////////////////////////////
1:                         pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:                 pumpToProtonTransport(request);
/////////////////////////////////////////////////////////////////////////
1:     public long getDrainTimeout() {
1:         return drainTimeout;
1:     }
1: 
1:     public void setDrainTimeout(long drainTimeout) {
1:         this.drainTimeout = drainTimeout;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         pumpToProtonTransport(NOOP_REQUEST);
1:     }
1: 
1:     void pumpToProtonTransport(AsyncResult request) {
/////////////////////////////////////////////////////////////////////////
1:             request.onFailure(e);
commit:d9e22a9
/////////////////////////////////////////////////////////////////////////
1:                 AmqpEventSink amqpEventSink = null;
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getConnection().getContext();
1:                         amqpEventSink.processRemoteClose(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getConnection().getContext();
1:                         amqpEventSink.processRemoteOpen(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getSession().getContext();
1:                         amqpEventSink.processRemoteClose(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getSession().getContext();
1:                         amqpEventSink.processRemoteOpen(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:                         amqpEventSink.processRemoteClose(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:                         amqpEventSink.processRemoteDetach(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:                         amqpEventSink.processRemoteOpen(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:                         amqpEventSink.processFlowUpdates(this);
1:                         amqpEventSink = (AmqpEventSink) protonEvent.getLink().getContext();
1:                         amqpEventSink.processDeliveryUpdates(this);
commit:272fb2b
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicLong txIdGenerator = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
1:     String getConnectionId() {
1:         return this.connectionId;
1:     }
1: 
1:     AmqpTransactionId getNextTransactionId() {
1:         return new AmqpTransactionId(connectionId + ":" + txIdGenerator.incrementAndGet());
1:     }
1: 
commit:82a5839
/////////////////////////////////////////////////////////////////////////
0: import io.netty.buffer.ByteBuf;
0: import io.netty.buffer.Unpooled;
0: import io.netty.util.ReferenceCountUtil;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.amqp.client.transport.NettyTransport;
1: import org.apache.activemq.transport.amqp.client.transport.NettyTransportListener;
1: import org.apache.activemq.transport.amqp.client.util.IdGenerator;
/////////////////////////////////////////////////////////////////////////
1: public class AmqpConnection extends AmqpAbstractResource<Connection> implements NettyTransportListener {
/////////////////////////////////////////////////////////////////////////
0:     private final NettyTransport transport;
/////////////////////////////////////////////////////////////////////////
0:     public AmqpConnection(NettyTransport transport, String username, String password) {
/////////////////////////////////////////////////////////////////////////
1:         this.remoteURI = transport.getRemoteLocation();
/////////////////////////////////////////////////////////////////////////
1:                     transport.send(Unpooled.wrappedBuffer(rawData));
/////////////////////////////////////////////////////////////////////////
1:                     ByteBuf outbound = transport.allocateSendBuffer(toWrite.remaining());
1:                     outbound.writeBytes(toWrite);
1:                     transport.send(outbound);
/////////////////////////////////////////////////////////////////////////
1:     public void onData(final ByteBuf incoming) {
1: 
1:         // We need to retain until the serializer gets around to processing it.
1:         ReferenceCountUtil.retain(incoming);
1: 
1:                 ByteBuffer source = incoming.nioBuffer();
/////////////////////////////////////////////////////////////////////////
1:                 ReferenceCountUtil.release(incoming);
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 try {
1:                                     transport.close();
1:                                 } catch (IOException e1) {
1:                                 }
commit:7c06d8d
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             getStateInspector().inspectOpenedResource(getConnection());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
1:         try {
1:             getStateInspector().inspectClosedResource(getConnection());
1:         } catch (Throwable error) {
1:             getStateInspector().markAsInvalid(error.getMessage());
1:         }
commit:f37b005
/////////////////////////////////////////////////////////////////////////
1:     public static final long DEFAULT_CONNECT_TIMEOUT = 515000;
commit:a812131
/////////////////////////////////////////////////////////////////////////
0:                 if (getEndpoint().getRemoteState() != EndpointState.ACTIVE) {
0:                     throw new IOException("Failed to connect after configured timeout.");
1:                 }
commit:4b4cf7c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.InactivityIOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.engine.EndpointState;
/////////////////////////////////////////////////////////////////////////
1:     private AmqpConnectionListener listener;
1:     private int idleTimeout = 0;
1:     private boolean idleProcessingDisabled;
/////////////////////////////////////////////////////////////////////////
1:                     if (getIdleTimeout() > 0) {
1:                         protonTransport.setIdleTimeout(getIdleTimeout());
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     public AmqpConnectionListener getListener() {
1:         return listener;
1:     }
1: 
1:     public void setListener(AmqpConnectionListener listener) {
1:         this.listener = listener;
1:     }
1: 
1:     public int getIdleTimeout() {
1:         return idleTimeout;
1:     }
1: 
1:     public void setIdleTimeout(int idleTimeout) {
1:         this.idleTimeout = idleTimeout;
1:     }
1: 
1:     public void setIdleProcessingDisabled(boolean value) {
1:         this.idleProcessingDisabled = value;
1:     }
1: 
1:     public boolean isIdleProcessingDisabled() {
1:         return idleProcessingDisabled;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (protonTransport.isClosed()) {
1:                     LOG.debug("Ignoring incoming data because transport is closed");
1:                     return;
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (!isIdleProcessingDisabled()) {
0:                 long nextKeepAliveTime = protonTransport.tick(System.currentTimeMillis());
0:                 if (nextKeepAliveTime > 0) {
1: 
1:                     getScheduler().schedule(new Runnable() {
1: 
1:                         @Override
1:                         public void run() {
1:                             try {
1:                                 if (getEndpoint().getLocalState() != EndpointState.CLOSED) {
1:                                     LOG.debug("Client performing next idle check");
0:                                     long rescheduleAt = protonTransport.tick(System.currentTimeMillis()) - System.currentTimeMillis();
1:                                     pumpToProtonTransport();
1:                                     if (protonTransport.isClosed()) {
1:                                         LOG.debug("Transport closed after inactivity check.");
0:                                         throw new InactivityIOException("Channel was inactive for to long");
1:                                     }
1: 
0:                                     if (rescheduleAt > 0) {
0:                                         getScheduler().schedule(this, rescheduleAt, TimeUnit.MILLISECONDS);
1:                                     }
1:                                 }
1:                             } catch (Exception e) {
1:                                 transport.close();
1:                                 fireClientException(e);
1:                             }
1:                         }
0:                     }, nextKeepAliveTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:         AmqpConnectionListener listener = this.listener;
1:             listener.onException(ex);
commit:31834ed
/////////////////////////////////////////////////////////////////////////
1:     //----- Access to low level IO for specific test cases -------------------//
1: 
1:     public void sendRawBytes(final byte[] rawData) throws Exception {
1:         checkClosed();
1: 
1:         final ClientFuture request = new ClientFuture();
1: 
1:         serializer.execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1:                 try {
0:                     transport.send(ByteBuffer.wrap(rawData));
1:                 } catch (IOException e) {
1:                     fireClientException(e);
1:                 } finally {
1:                     request.onSuccess();
1:                 }
1:             }
1:         });
1: 
1:         request.sync();
1:     }
1: 
commit:1a0f73e
/////////////////////////////////////////////////////////////////////////
1:                 session.setStateInspector(getStateInspector());
commit:72839b7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.client;
1: 
1: import static org.apache.activemq.transport.amqp.AmqpSupport.CONNECTION_OPEN_FAILED;
1: 
1: import java.io.IOException;
1: import java.net.URI;
1: import java.nio.ByteBuffer;
1: import java.util.Collections;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.UUID;
0: import java.util.concurrent.Executors;
1: import java.util.concurrent.ScheduledExecutorService;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicLong;
1: 
1: import org.apache.activemq.transport.amqp.client.sasl.SaslAuthenticator;
1: import org.apache.activemq.transport.amqp.client.util.ClientFuture;
0: import org.apache.activemq.transport.amqp.client.util.ClientTcpTransport;
0: import org.apache.activemq.transport.amqp.client.util.UnmodifiableConnection;
0: import org.apache.activemq.util.IdGenerator;
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.engine.Collector;
1: import org.apache.qpid.proton.engine.Connection;
1: import org.apache.qpid.proton.engine.Event;
1: import org.apache.qpid.proton.engine.Event.Type;
1: import org.apache.qpid.proton.engine.Sasl;
1: import org.apache.qpid.proton.engine.Transport;
1: import org.apache.qpid.proton.engine.impl.CollectorImpl;
0: import org.fusesource.hawtbuf.Buffer;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
0: public class AmqpConnection extends AmqpAbstractResource<Connection> implements ClientTcpTransport.TransportListener {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AmqpConnection.class);
1: 
1:     private static final int DEFAULT_MAX_FRAME_SIZE = 1024 * 1024 * 1;
1:     // NOTE: Limit default channel max to signed short range to deal with
1:     //       brokers that don't currently handle the unsigned range well.
1:     private static final int DEFAULT_CHANNEL_MAX = 32767;
1:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1: 
0:     public static final long DEFAULT_CONNECT_TIMEOUT = 15000;
1:     public static final long DEFAULT_CLOSE_TIMEOUT = 30000;
1: 
0:     private final ScheduledExecutorService serializer;
1:     private final AtomicBoolean closed = new AtomicBoolean();
1:     private final AtomicBoolean connected = new AtomicBoolean();
1:     private final AtomicLong sessionIdGenerator = new AtomicLong();
1:     private final Collector protonCollector = new CollectorImpl();
0:     private final ClientTcpTransport transport;
1:     private final Transport protonTransport = Transport.Factory.create();
1: 
1:     private final String username;
1:     private final String password;
1:     private final URI remoteURI;
1:     private final String connectionId;
1:     private List<Symbol> offeredCapabilities = Collections.emptyList();
1:     private Map<Symbol, Object> offeredProperties = Collections.emptyMap();
1: 
0:     private AmqpClientListener listener;
1:     private SaslAuthenticator authenticator;
1: 
1:     private String containerId;
1:     private boolean authenticated;
1:     private int channelMax = DEFAULT_CHANNEL_MAX;
1:     private long connectTimeout = DEFAULT_CONNECT_TIMEOUT;
1:     private long closeTimeout = DEFAULT_CLOSE_TIMEOUT;
1: 
0:     public AmqpConnection(ClientTcpTransport transport, String username, String password) {
1:         setEndpoint(Connection.Factory.create());
1:         getEndpoint().collect(protonCollector);
1: 
1:         this.transport = transport;
1:         this.username = username;
1:         this.password = password;
1:         this.connectionId = CONNECTION_ID_GENERATOR.generateId();
0:         this.remoteURI = transport.getRemoteURI();
1: 
0:         this.serializer = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {
1: 
1:             @Override
1:             public Thread newThread(Runnable runner) {
1:                 Thread serial = new Thread(runner);
1:                 serial.setDaemon(true);
1:                 serial.setName(toString());
1:                 return serial;
1:             }
1:         });
1: 
1:         this.transport.setTransportListener(this);
1:     }
1: 
1:     public void connect() throws Exception {
1:         if (connected.compareAndSet(false, true)) {
1:             transport.connect();
1: 
1:             final ClientFuture future = new ClientFuture();
1:             serializer.execute(new Runnable() {
1:                 @Override
1:                 public void run() {
1:                     getEndpoint().setContainer(safeGetContainerId());
1:                     getEndpoint().setHostname(remoteURI.getHost());
1:                     if (!getOfferedCapabilities().isEmpty()) {
1:                         getEndpoint().setOfferedCapabilities(getOfferedCapabilities().toArray(new Symbol[0]));
1:                     }
1:                     if (!getOfferedProperties().isEmpty()) {
1:                         getEndpoint().setProperties(getOfferedProperties());
1:                     }
1: 
1:                     protonTransport.setMaxFrameSize(getMaxFrameSize());
1:                     protonTransport.setChannelMax(getChannelMax());
1:                     protonTransport.bind(getEndpoint());
1:                     Sasl sasl = protonTransport.sasl();
1:                     if (sasl != null) {
1:                         sasl.client();
1:                     }
0:                     authenticator = new SaslAuthenticator(sasl, username, password);
1:                     open(future);
1: 
1:                     pumpToProtonTransport();
1:                 }
1:             });
1: 
0:             if (connectTimeout <= 0) {
0:                 future.sync();
1:             } else {
0:                 future.sync(connectTimeout, TimeUnit.MILLISECONDS);
1:             }
1:         }
1:     }
1: 
1:     public boolean isConnected() {
1:         return transport.isConnected() && connected.get();
1:     }
1: 
1:     public void close() {
1:         if (closed.compareAndSet(false, true)) {
1:             final ClientFuture request = new ClientFuture();
1:             serializer.execute(new Runnable() {
1: 
1:                 @Override
1:                 public void run() {
1:                     try {
1: 
1:                         // If we are not connected then there is nothing we can do now
1:                         // just signal success.
1:                         if (!transport.isConnected()) {
1:                             request.onSuccess();
1:                         }
1: 
1:                         if (getEndpoint() != null) {
1:                             close(request);
1:                         } else {
1:                             request.onSuccess();
1:                         }
1: 
1:                         pumpToProtonTransport();
1:                     } catch (Exception e) {
1:                         LOG.debug("Caught exception while closing proton connection");
1:                     }
1:                 }
1:             });
1: 
1:             try {
1:                 if (closeTimeout <= 0) {
1:                     request.sync();
1:                 } else {
1:                     request.sync(closeTimeout, TimeUnit.MILLISECONDS);
1:                 }
1:             } catch (IOException e) {
1:                 LOG.warn("Error caught while closing Provider: ", e.getMessage());
1:             } finally {
1:                 if (transport != null) {
1:                     try {
0:                         transport.close();
1:                     } catch (Exception e) {
1:                         LOG.debug("Cuaght exception while closing down Transport: {}", e.getMessage());
1:                     }
1:                 }
1: 
0:                 serializer.shutdown();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Creates a new Session instance used to create AMQP resources like
1:      * senders and receivers.
1:      *
1:      * @return a new AmqpSession that can be used to create links.
1:      *
1:      * @throws Exception if an error occurs during creation.
1:      */
1:     public AmqpSession createSession() throws Exception {
1:         checkClosed();
1: 
1:         final AmqpSession session = new AmqpSession(AmqpConnection.this, getNextSessionId());
1:         final ClientFuture request = new ClientFuture();
1: 
1:         serializer.execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 checkClosed();
1: 
1:                 session.setEndpoint(getEndpoint().session());
1:                 session.open(request);
1: 
1:                 pumpToProtonTransport();
1:             }
1:         });
1: 
1:         request.sync();
1: 
1:         return session;
1:     }
1: 
1:     //----- Configuration accessors ------------------------------------------//
1: 
1:     /**
1:      * @return the user name that was used to authenticate this connection.
1:      */
1:     public String getUsername() {
1:         return username;
1:     }
1: 
1:     /**
1:      * @return the password that was used to authenticate this connection.
1:      */
1:     public String getPassword() {
1:         return password;
1:     }
1: 
1:     /**
1:      * @return the URI of the remote peer this connection attached to.
1:      */
1:     public URI getRemoteURI() {
1:         return remoteURI;
1:     }
1: 
1:     /**
1:      * @return the container ID that will be set as the container Id.
1:      */
1:     public String getContainerId() {
1:         return this.containerId;
1:     }
1: 
1:     /**
1:      * Sets the container Id that will be configured on the connection prior to
1:      * connecting to the remote peer.  Calling this after connect has no effect.
1:      *
1:      * @param containerId
1:      * 		  the container Id to use on the connection.
1:      */
1:     public void setContainerId(String containerId) {
1:         this.containerId = containerId;
1:     }
1: 
1:     /**
1:      * @return the currently set Max Frame Size value.
1:      */
1:     public int getMaxFrameSize() {
1:         return DEFAULT_MAX_FRAME_SIZE;
1:     }
1: 
1:     public int getChannelMax() {
1:         return channelMax;
1:     }
1: 
1:     public void setChannelMax(int channelMax) {
1:         this.channelMax = channelMax;
1:     }
1: 
1:     public long getConnectTimeout() {
1:         return connectTimeout;
1:     }
1: 
1:     public void setConnectTimeout(long connectTimeout) {
1:         this.connectTimeout = connectTimeout;
1:     }
1: 
1:     public long getCloseTimeout() {
1:         return closeTimeout;
1:     }
1: 
1:     public void setCloseTimeout(long closeTimeout) {
1:         this.closeTimeout = closeTimeout;
1:     }
1: 
1:     public List<Symbol> getOfferedCapabilities() {
1:         return offeredCapabilities;
1:     }
1: 
1:     public void setOfferedCapabilities(List<Symbol> offeredCapabilities) {
1:         if (offeredCapabilities != null) {
1:             offeredCapabilities = Collections.emptyList();
1:         }
1: 
1:         this.offeredCapabilities = offeredCapabilities;
1:     }
1: 
1:     public Map<Symbol, Object> getOfferedProperties() {
1:         return offeredProperties;
1:     }
1: 
1:     public void setOfferedProperties(Map<Symbol, Object> offeredProperties) {
1:         if (offeredProperties != null) {
1:             offeredProperties = Collections.emptyMap();
1:         }
1: 
1:         this.offeredProperties = offeredProperties;
1:     }
1: 
1:     public Connection getConnection() {
0:         return new UnmodifiableConnection(getEndpoint());
1:     }
1: 
1:     //----- Internal getters used from the child AmqpResource classes --------//
1: 
1:     ScheduledExecutorService getScheduler() {
1:         return this.serializer;
1:     }
1: 
1:     Connection getProtonConnection() {
1:         return getEndpoint();
1:     }
1: 
1:     void pumpToProtonTransport() {
1:         try {
1:             boolean done = false;
1:             while (!done) {
1:                 ByteBuffer toWrite = protonTransport.getOutputBuffer();
1:                 if (toWrite != null && toWrite.hasRemaining()) {
0:                     transport.send(toWrite);
1:                     protonTransport.outputConsumed();
1:                 } else {
1:                     done = true;
1:                 }
1:             }
1:         } catch (IOException e) {
1:             fireClientException(e);
1:         }
1:     }
1: 
1:     //----- Transport listener event hooks -----------------------------------//
1: 
1:     @Override
0:     public void onData(final Buffer input) {
1:         serializer.execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
0:                 ByteBuffer source = input.toByteBuffer();
0:                 LOG.trace("Received from Broker {} bytes:", source.remaining());
1: 
1:                 do {
1:                     ByteBuffer buffer = protonTransport.getInputBuffer();
1:                     int limit = Math.min(buffer.remaining(), source.remaining());
1:                     ByteBuffer duplicate = source.duplicate();
1:                     duplicate.limit(source.position() + limit);
1:                     buffer.put(duplicate);
1:                     protonTransport.processInput();
1:                     source.position(source.position() + limit);
1:                 } while (source.hasRemaining());
1: 
1:                 // Process the state changes from the latest data and then answer back
1:                 // any pending updates to the Broker.
1:                 processUpdates();
1:                 pumpToProtonTransport();
1:             }
1:         });
1:     }
1: 
1:     @Override
1:     public void onTransportClosed() {
1:         LOG.debug("The transport has unexpectedly closed");
1:     }
1: 
1:     @Override
1:     public void onTransportError(Throwable cause) {
1:         fireClientException(cause);
1:     }
1: 
1:     //----- Internal implementation ------------------------------------------//
1: 
1:     @Override
1:     protected void doOpenCompletion() {
1:         // If the remote indicates that a close is pending, don't open.
0:         if (!getEndpoint().getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) {
1:             super.doOpenCompletion();
1:         }
1:     }
1: 
1:     @Override
1:     protected void doOpenInspection() {
0:         getStateInspector().inspectOpenedResource(getConnection());
1:     }
1: 
1:     @Override
1:     protected void doClosedInspection() {
0:         getStateInspector().inspectClosedResource(getConnection());
1:     }
1: 
1:     protected void fireClientException(Throwable ex) {
0:         AmqpClientListener listener = this.listener;
1:         if (listener != null) {
0:             listener.onClientException(ex);
1:         }
1:     }
1: 
1:     protected void checkClosed() throws IllegalStateException {
1:         if (closed.get()) {
1:             throw new IllegalStateException("The Connection is already closed");
1:         }
1:     }
1: 
1:     private void processUpdates() {
1:         try {
1:             Event protonEvent = null;
1:             while ((protonEvent = protonCollector.peek()) != null) {
1:                 if (!protonEvent.getType().equals(Type.TRANSPORT)) {
0:                     LOG.trace("New Proton Event: {}", protonEvent.getType());
1:                 }
1: 
0:                 AmqpResource amqpResource = null;
1:                 switch (protonEvent.getType()) {
1:                     case CONNECTION_REMOTE_CLOSE:
0:                         amqpResource = (AmqpConnection) protonEvent.getConnection().getContext();
0:                         amqpResource.processRemoteClose(this);
1:                         break;
1:                     case CONNECTION_REMOTE_OPEN:
0:                         amqpResource = (AmqpConnection) protonEvent.getConnection().getContext();
0:                         amqpResource.processRemoteOpen(this);
1:                         break;
1:                     case SESSION_REMOTE_CLOSE:
0:                         amqpResource = (AmqpSession) protonEvent.getSession().getContext();
0:                         amqpResource.processRemoteClose(this);
1:                         break;
1:                     case SESSION_REMOTE_OPEN:
0:                         amqpResource = (AmqpSession) protonEvent.getSession().getContext();
0:                         amqpResource.processRemoteOpen(this);
1:                         break;
1:                     case LINK_REMOTE_CLOSE:
0:                         amqpResource = (AmqpResource) protonEvent.getLink().getContext();
0:                         amqpResource.processRemoteClose(this);
1:                         break;
1:                     case LINK_REMOTE_DETACH:
0:                         amqpResource = (AmqpResource) protonEvent.getLink().getContext();
0:                         amqpResource.processRemoteDetach(this);
1:                         break;
1:                     case LINK_REMOTE_OPEN:
0:                         amqpResource = (AmqpResource) protonEvent.getLink().getContext();
0:                         amqpResource.processRemoteOpen(this);
1:                         break;
1:                     case LINK_FLOW:
0:                         amqpResource = (AmqpResource) protonEvent.getLink().getContext();
0:                         amqpResource.processFlowUpdates(this);
1:                         break;
1:                     case DELIVERY:
0:                         amqpResource = (AmqpResource) protonEvent.getLink().getContext();
0:                         amqpResource.processDeliveryUpdates(this);
1:                         break;
1:                     default:
1:                         break;
1:                 }
1: 
1:                 protonCollector.pop();
1:             }
1: 
1:             // We have to do this to pump SASL bytes in as SASL is not event driven yet.
1:             if (!authenticated) {
1:                 processSaslAuthentication();
1:             }
1:         } catch (Exception ex) {
1:             LOG.warn("Caught Exception during update processing: {}", ex.getMessage(), ex);
1:             fireClientException(ex);
1:         }
1:     }
1: 
1:     private void processSaslAuthentication() {
1:         if (authenticated || authenticator == null) {
1:             return;
1:         }
1: 
1:         try {
1:             if (authenticator.authenticate()) {
1:                 authenticator = null;
1:                 authenticated = true;
1:             }
1:         } catch (SecurityException ex) {
1:             failed(ex);
1:         }
1:     }
1: 
1:     private String getNextSessionId() {
1:         return connectionId + ":" + sessionIdGenerator.incrementAndGet();
1:     }
1: 
1:     private String safeGetContainerId() {
1:         String containerId = getContainerId();
1:         if (containerId == null || containerId.isEmpty()) {
1:             containerId = UUID.randomUUID().toString();
1:         }
1: 
1:         return containerId;
1:     }
1: 
1:     @Override
1:     public String toString() {
1:         return "AmqpConnection { " + connectionId + " }";
1:     }
1: }
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:ce5628a
/////////////////////////////////////////////////////////////////////////
1:     private String mechanismRestriction;
1:     private String authzid;
/////////////////////////////////////////////////////////////////////////
1:                     authenticator = new SaslAuthenticator(sasl, username, password, authzid, mechanismRestriction);
/////////////////////////////////////////////////////////////////////////
1:     public void setAuthzid(String authzid) {
1:         this.authzid = authzid;
0:     }
0: 
1:     public String getAuthzid() {
1:         return authzid;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Sets a restriction on the SASL mechanism to use (if offered by the server).
1:      *
1:      * @param mechanismRestriction the mechanism to use
1:      */
1:     public void setMechanismRestriction(String mechanismRestriction) {
1:         this.mechanismRestriction = mechanismRestriction;
0:     }
0: 
1:     public String getMechanismRestriction() {
1:         return mechanismRestriction;
0:     }
0: 
commit:037f91d
/////////////////////////////////////////////////////////////////////////
1:                 // Using nano time since it is not related to the wall clock, which may change
1:                 long initialNow = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
1:                 long initialKeepAliveDeadline = protonTransport.tick(initialNow);
0:                 if (initialKeepAliveDeadline > 0) {
/////////////////////////////////////////////////////////////////////////
1:                                     // Using nano time since it is not related to the wall clock, which may change
1:                                     long now = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
0:                                     long rescheduleAt = protonTransport.tick(now) - now;
/////////////////////////////////////////////////////////////////////////
1:                     }, initialKeepAliveDeadline - initialNow, TimeUnit.MILLISECONDS);
============================================================================