1:d29ca2a: /**
1:7f883f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7f883f6:  * contributor license agreements.  See the NOTICE file distributed with
1:7f883f6:  * this work for additional information regarding copyright ownership.
1:7f883f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7f883f6:  * (the "License"); you may not use this file except in compliance with
1:7f883f6:  * the License.  You may obtain a copy of the License at
3:3601e81:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3601e81:  *
1:7f883f6:  * Unless required by applicable law or agreed to in writing, software
1:7f883f6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7f883f6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7f883f6:  * See the License for the specific language governing permissions and
1:7f883f6:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.jmx;
1:f5dcc9d: 
1:1a5ad28: import java.io.IOException;
1:4997427: import java.util.*;
1:1a5ad28: import java.util.Map.Entry;
1:1a5ad28: import java.util.concurrent.ConcurrentHashMap;
1:1a5ad28: import java.util.concurrent.CopyOnWriteArraySet;
1:584c133: import java.util.concurrent.ExecutorService;
1:1a5ad28: import java.util.concurrent.ThreadPoolExecutor;
1:f5dcc9d: 
1:11579bb: import javax.jms.IllegalStateException;
1:1a5ad28: import javax.management.InstanceNotFoundException;
1:1a5ad28: import javax.management.MalformedObjectNameException;
1:1a5ad28: import javax.management.ObjectName;
1:1a5ad28: import javax.management.openmbean.CompositeData;
1:1a5ad28: import javax.management.openmbean.CompositeDataSupport;
1:1a5ad28: import javax.management.openmbean.CompositeType;
1:1a5ad28: import javax.management.openmbean.OpenDataException;
1:1a5ad28: import javax.management.openmbean.TabularData;
1:1a5ad28: import javax.management.openmbean.TabularDataSupport;
1:1a5ad28: import javax.management.openmbean.TabularType;
1:e600876: 
1:ed5d43b: import org.apache.activemq.broker.Broker;
1:4098942: import org.apache.activemq.broker.BrokerService;
1:c82f6f3: import org.apache.activemq.broker.ConnectionContext;
1:629b18c: import org.apache.activemq.broker.ProducerBrokerExchange;
1:c717221: import org.apache.activemq.broker.jmx.OpenTypeSupport.OpenTypeFactory;
1:e600876: import org.apache.activemq.broker.region.Destination;
1:e600876: import org.apache.activemq.broker.region.DestinationFactory;
1:e600876: import org.apache.activemq.broker.region.DestinationInterceptor;
1:11579bb: import org.apache.activemq.broker.region.DurableTopicSubscription;
1:11579bb: import org.apache.activemq.broker.region.MessageReference;
1:11579bb: import org.apache.activemq.broker.region.NullMessageReference;
1:e600876: import org.apache.activemq.broker.region.Queue;
1:e600876: import org.apache.activemq.broker.region.Region;
1:e600876: import org.apache.activemq.broker.region.RegionBroker;
1:e600876: import org.apache.activemq.broker.region.Subscription;
1:e600876: import org.apache.activemq.broker.region.Topic;
1:e600876: import org.apache.activemq.broker.region.TopicRegion;
1:e600876: import org.apache.activemq.broker.region.TopicSubscription;
1:1982d54: import org.apache.activemq.broker.region.policy.AbortSlowAckConsumerStrategy;
1:383d12e: import org.apache.activemq.broker.region.policy.AbortSlowConsumerStrategy;
1:d29ca2a: import org.apache.activemq.command.ActiveMQDestination;
1:c717221: import org.apache.activemq.command.ActiveMQMessage;
1:c82f6f3: import org.apache.activemq.command.ActiveMQTopic;
1:fde22a8: import org.apache.activemq.command.ConnectionInfo;
1:3601e81: import org.apache.activemq.command.ConsumerInfo;
1:c717221: import org.apache.activemq.command.Message;
1:11579bb: import org.apache.activemq.command.MessageAck;
1:0afb7f9: import org.apache.activemq.command.MessageId;
1:7092b19: import org.apache.activemq.command.ProducerInfo;
1:c82f6f3: import org.apache.activemq.command.SubscriptionInfo;
1:1a5ad28: import org.apache.activemq.thread.Scheduler;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:1d242a2: import org.apache.activemq.transaction.XATransaction;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:3cd3fd3: import org.apache.activemq.util.ServiceStopper;
1:c82f6f3: import org.apache.activemq.util.SubscriptionKey;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:71c0d44: 
1:d29ca2a: public class ManagedRegionBroker extends RegionBroker {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ManagedRegionBroker.class);
1:1ec71bd:     private final ManagementContext managementContext;
1:d29ca2a:     private final ObjectName brokerObjectName;
1:ecf89a6:     private final Map<ObjectName, DestinationView> topics = new ConcurrentHashMap<ObjectName, DestinationView>();
1:ecf89a6:     private final Map<ObjectName, DestinationView> queues = new ConcurrentHashMap<ObjectName, DestinationView>();
1:ecf89a6:     private final Map<ObjectName, DestinationView> temporaryQueues = new ConcurrentHashMap<ObjectName, DestinationView>();
1:ecf89a6:     private final Map<ObjectName, DestinationView> temporaryTopics = new ConcurrentHashMap<ObjectName, DestinationView>();
1:ecf89a6:     private final Map<ObjectName, SubscriptionView> queueSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:ecf89a6:     private final Map<ObjectName, SubscriptionView> topicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:ecf89a6:     private final Map<ObjectName, SubscriptionView> durableTopicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:ecf89a6:     private final Map<ObjectName, SubscriptionView> inactiveDurableTopicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:ecf89a6:     private final Map<ObjectName, SubscriptionView> temporaryQueueSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:ecf89a6:     private final Map<ObjectName, SubscriptionView> temporaryTopicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:7092b19:     private final Map<ObjectName, ProducerView> queueProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:7092b19:     private final Map<ObjectName, ProducerView> topicProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:7092b19:     private final Map<ObjectName, ProducerView> temporaryQueueProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:7092b19:     private final Map<ObjectName, ProducerView> temporaryTopicProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:629b18c:     private final Map<ObjectName, ProducerView> dynamicDestinationProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:ecf89a6:     private final Map<SubscriptionKey, ObjectName> subscriptionKeys = new ConcurrentHashMap<SubscriptionKey, ObjectName>();
1:ecf89a6:     private final Map<Subscription, ObjectName> subscriptionMap = new ConcurrentHashMap<Subscription, ObjectName>();
1:ecf89a6:     private final Set<ObjectName> registeredMBeans = new CopyOnWriteArraySet<ObjectName>();
1:ed5d43b:     /* This is the first broker in the broker interceptor chain. */
1:ed5d43b:     private Broker contextBroker;
1:3bf0245: 
1:584c133:     private final ExecutorService asyncInvokeService;
1:584c133:     private final long mbeanTimeout;
1:584c133: 
1:1ec71bd:     public ManagedRegionBroker(BrokerService brokerService, ManagementContext context, ObjectName brokerObjectName, TaskRunnerFactory taskRunnerFactory, SystemUsage memoryManager,
1:1a5ad28:                                DestinationFactory destinationFactory, DestinationInterceptor destinationInterceptor,Scheduler scheduler,ThreadPoolExecutor executor) throws IOException {
1:1a5ad28:         super(brokerService, taskRunnerFactory, memoryManager, destinationFactory, destinationInterceptor,scheduler,executor);
1:1ec71bd:         this.managementContext = context;
1:230a86c:         this.brokerObjectName = brokerObjectName;
1:584c133:         this.mbeanTimeout = brokerService.getMbeanInvocationTimeout();
1:584c133:         this.asyncInvokeService = mbeanTimeout > 0 ? executor : null;;
1:3bf0245:     }
1:f5dcc9d: 
1:e600876:     @Override
1:c82f6f3:     public void start() throws Exception {
1:c82f6f3:         super.start();
1:6c0df67:         // build all existing durable subscriptions
1:c82f6f3:         buildExistingSubscriptions();
1:132f662:     }
1:7092b19: 
1:e600876:     @Override
1:230a86c:     protected void doStop(ServiceStopper stopper) {
1:3cd3fd3:         super.doStop(stopper);
1:3cd3fd3:         // lets remove any mbeans not yet removed
1:ecf89a6:         for (Iterator<ObjectName> iter = registeredMBeans.iterator(); iter.hasNext();) {
1:ecf89a6:             ObjectName name = iter.next();
1:c717221:             try {
1:1ec71bd:                 managementContext.unregisterMBean(name);
1:230a86c:             } catch (InstanceNotFoundException e) {
1:e1bbde7:                 LOG.warn("The MBean {} is no longer registered with JMX", name);
1:230a86c:             } catch (Exception e) {
1:230a86c:                 stopper.onException(this, e);
1:c37859a:             }
1:a20de10:         }
1:3cd3fd3:         registeredMBeans.clear();
1:bfaff9b:     }
1:4fc1712: 
1:e600876:     @Override
1:6d8e2c5:     protected Region createQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:230a86c:         return new ManagedQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:05d271a:     }
1:132f662: 
1:e600876:     @Override
1:6d8e2c5:     protected Region createTempQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:1005fc5:         return new ManagedTempQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:6c0df67:     }
1:bfaff9b: 
1:4fc1712:     @Override
1:6d8e2c5:     protected Region createTempTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:230a86c:         return new ManagedTempTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:6c0df67:     }
1:6c0df67: 
1:1a5ad28:     @Override
1:6d8e2c5:     protected Region createTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:230a86c:         return new ManagedTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:6c0df67:     }
1:6c0df67: 
1:230a86c:     public void register(ActiveMQDestination destName, Destination destination) {
1:bfaff9b:         // TODO refactor to allow views for custom destinations
1:c82f6f3:         try {
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createDestinationName(brokerObjectName, destName);
1:3601e81:             DestinationView view;
1:bfaff9b:             if (destination instanceof Queue) {
1:230a86c:                 view = new QueueView(this, (Queue)destination);
1:230a86c:             } else if (destination instanceof Topic) {
1:230a86c:                 view = new TopicView(this, (Topic)destination);
1:71c0d44:             } else {
1:bfaff9b:                 view = null;
1:e1bbde7:                 LOG.warn("JMX View is not supported for custom destination {}", destination);
1:71c0d44:             }
1:383d12e:             if (view != null) {
1:230a86c:                 registerDestination(objectName, destName, view);
1:bfaff9b:             }
1:230a86c:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Failed to register destination {}", destName, e);
1:6c0df67:         }
1:6c0df67:     }
1:71c0d44: 
1:230a86c:     public void unregister(ActiveMQDestination destName) {
1:230a86c:         try {
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createDestinationName(brokerObjectName, destName);
1:07d4e8c:             unregisterDestination(objectName);
1:230a86c:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Failed to unregister {}", destName, e);
1:6c0df67:         }
1:6c0df67:     }
1:6c0df67: 
1:230a86c:     public ObjectName registerSubscription(ConnectionContext context, Subscription sub) {
1:947659c:         String connectionClientId = context.getClientId();
1:63a660a: 
1:230a86c:         SubscriptionKey key = new SubscriptionKey(context.getClientId(), sub.getConsumerInfo().getSubscriptionName());
1:230a86c:         try {
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createSubscriptionName(brokerObjectName, connectionClientId, sub.getConsumerInfo());
1:3601e81:             SubscriptionView view;
1:4fc1712:             if (sub.getConsumerInfo().getConsumerId().getConnectionId().equals("OFFLINE")) {
1:4fc1712:                 // add offline subscribers to inactive list
1:4fc1712:                 SubscriptionInfo info = new SubscriptionInfo();
1:4fc1712:                 info.setClientId(context.getClientId());
1:4fc1712:                 info.setSubscriptionName(sub.getConsumerInfo().getSubscriptionName());
1:4fc1712:                 info.setDestination(sub.getConsumerInfo().getDestination());
1:79c9f2d:                 info.setSelector(sub.getSelector());
1:e23b8ea:                 addInactiveSubscription(key, info, sub);
1:bfaff9b:             } else {
1:f5dcc9d:                 String userName = brokerService.isPopulateUserNameInMBeans() ? context.getUserName() : null;
1:4fc1712:                 if (sub.getConsumerInfo().isDurable()) {
1:e06685f:                     view = new DurableSubscriptionView(this, brokerService, context.getClientId(), userName, sub);
5:230a86c:                 } else {
1:4fc1712:                     if (sub instanceof TopicSubscription) {
1:f5dcc9d:                         view = new TopicSubscriptionView(context.getClientId(), userName, (TopicSubscription) sub);
1:4fc1712:                     } else {
1:f5dcc9d:                         view = new SubscriptionView(context.getClientId(), userName, sub);
1:4fc1712:                     }
1:6c0df67:                 }
1:4fc1712:                 registerSubscription(objectName, sub.getConsumerInfo(), key, view);
1:6c0df67:             }
1:230a86c:             subscriptionMap.put(sub, objectName);
1:7092b19:             return objectName;
1:230a86c:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Failed to register subscription {}", sub, e);
1:0def1d4:             return null;
1:7092b19:         }
1:1d242a2:     }
1:7092b19: 
1:1a5ad28:     @Override
1:fde22a8:     public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {
1:fde22a8:         super.addConnection(context, info);
1:fde22a8:         this.contextBroker.getBrokerService().incrementCurrentConnections();
1:fde22a8:         this.contextBroker.getBrokerService().incrementTotalConnections();
1:fde22a8:     }
1:fde22a8: 
1:fde22a8:     @Override
1:fde22a8:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {
1:fde22a8:         super.removeConnection(context, info, error);
1:fde22a8:         this.contextBroker.getBrokerService().decrementCurrentConnections();
1:fde22a8:     }
1:fde22a8: 
1:fde22a8:     @Override
1:4fc1712:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:4fc1712:         Subscription sub = super.addConsumer(context, info);
1:4fc1712:         SubscriptionKey subscriptionKey = new SubscriptionKey(sub.getContext().getClientId(), sub.getConsumerInfo().getSubscriptionName());
1:4fc1712:         ObjectName inactiveName = subscriptionKeys.get(subscriptionKey);
1:4fc1712:         if (inactiveName != null) {
1:4fc1712:             // if it was inactive, register it
1:4fc1712:             registerSubscription(context, sub);
1:4fc1712:         }
1:4fc1712:         return sub;
1:4fc1712:     }
1:7092b19: 
1:4fc1712:     @Override
1:4fc1712:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:4fc1712:         for (Subscription sub : subscriptionMap.keySet()) {
1:4fc1712:             if (sub.getConsumerInfo().equals(info)) {
1:4fc1712:                // unregister all consumer subs
1:4fc1712:                unregisterSubscription(subscriptionMap.get(sub), true);
1:4fc1712:             }
1:4fc1712:         }
1:4fc1712:         super.removeConsumer(context, info);
1:4fc1712:     }
1:7092b19: 
1:7092b19:     @Override
1:63a660a:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:7092b19:         super.addProducer(context, info);
1:7092b19:         String connectionClientId = context.getClientId();
1:7d7d6fa:         ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, context.getClientId(), info);
1:f5dcc9d:         String userName = brokerService.isPopulateUserNameInMBeans() ? context.getUserName() : null;
1:f5dcc9d:         ProducerView view = new ProducerView(info, connectionClientId, userName, this);
1:7092b19:         registerProducer(objectName, info.getDestination(), view);
1:7092b19:     }
1:7092b19: 
1:7092b19:     @Override
1:7092b19:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:7d7d6fa:         ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, context.getClientId(), info);
1:7092b19:         unregisterProducer(objectName);
1:7092b19:         super.removeProducer(context, info);
1:7092b19:     }
1:7092b19: 
1:629b18c:     @Override
1:629b18c:     public void send(ProducerBrokerExchange exchange, Message message) throws Exception {
1:629b18c:         if (exchange != null && exchange.getProducerState() != null && exchange.getProducerState().getInfo() != null) {
1:629b18c:             ProducerInfo info = exchange.getProducerState().getInfo();
1:629b18c:             if (info.getDestination() == null && info.getProducerId() != null) {
1:7d7d6fa:                 ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, exchange.getConnectionContext().getClientId(), info);
1:629b18c:                 ProducerView view = this.dynamicDestinationProducers.get(objectName);
1:629b18c:                 if (view != null) {
1:629b18c:                     ActiveMQDestination dest = message.getDestination();
1:629b18c:                     if (dest != null) {
1:629b18c:                         view.setLastUsedDestinationName(dest);
1:629b18c:                     }
1:629b18c:                 }
1:629b18c:             }
1:629b18c:          }
1:629b18c:         super.send(exchange, message);
1:629b18c:     }
1:629b18c: 
1:230a86c:     public void unregisterSubscription(Subscription sub) {
1:ecf89a6:         ObjectName name = subscriptionMap.remove(sub);
1:230a86c:         if (name != null) {
1:230a86c:             try {
1:4fc1712:                 SubscriptionKey subscriptionKey = new SubscriptionKey(sub.getContext().getClientId(), sub.getConsumerInfo().getSubscriptionName());
1:3fdf986:                 ObjectName inactiveName = subscriptionKeys.remove(subscriptionKey);
1:4fc1712:                 if (inactiveName != null) {
1:4fc1712:                     inactiveDurableTopicSubscribers.remove(inactiveName);
1:054fc6a:                     managementContext.unregisterMBean(inactiveName);
1:4fc1712:                 }
1:230a86c:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Failed to unregister subscription {}", sub, e);
1:6c0df67:             }
1:6c0df67:         }
1:c717221:     }
1:ed96e2e: 
1:230a86c:     protected void registerDestination(ObjectName key, ActiveMQDestination dest, DestinationView view) throws Exception {
1:7092b19:         if (dest.isQueue()) {
1:7092b19:             if (dest.isTemporary()) {
1:230a86c:                 temporaryQueues.put(key, view);
1:7092b19:             } else {
1:230a86c:                 queues.put(key, view);
1:c717221:             }
1:7092b19:         } else {
1:7092b19:             if (dest.isTemporary()) {
1:230a86c:                 temporaryTopics.put(key, view);
1:230a86c:             } else {
1:230a86c:                 topics.put(key, view);
1:c82f6f3:             }
1:c82f6f3:         }
1:230a86c:         try {
1:584c133:             AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);
1:cafe4cb:             registeredMBeans.add(key);
1:cafe4cb:         } catch (Throwable e) {
1:e1bbde7:             LOG.warn("Failed to register MBean {}", key);
1:e1bbde7:             LOG.debug("Failure reason: ", e);
1:7092b19:         }
1:c82f6f3:     }
1:4fc1712: 
1:230a86c:     protected void unregisterDestination(ObjectName key) throws Exception {
1:1d242a2: 
1:2290502:         DestinationView view = removeAndRemember(topics, key, null);
1:2290502:         view = removeAndRemember(queues, key, view);
1:2290502:         view = removeAndRemember(temporaryQueues, key, view);
1:2290502:         view = removeAndRemember(temporaryTopics, key, view);
1:230a86c:         if (registeredMBeans.remove(key)) {
1:230a86c:             try {
1:1ec71bd:                 managementContext.unregisterMBean(key);
1:cafe4cb:             } catch (Throwable e) {
1:e1bbde7:                 LOG.warn("Failed to unregister MBean {}", key);
1:e1bbde7:                 LOG.debug("Failure reason: ", e);
1:c82f6f3:             }
1:c82f6f3:         }
1:bfaff9b:         if (view != null) {
1:383d12e:             key = view.getSlowConsumerStrategy();
1:383d12e:             if (key!= null && registeredMBeans.remove(key)) {
1:383d12e:                 try {
1:383d12e:                     managementContext.unregisterMBean(key);
1:383d12e:                 } catch (Throwable e) {
1:e1bbde7:                     LOG.warn("Failed to unregister slow consumer strategy MBean {}", key);
1:e1bbde7:                     LOG.debug("Failure reason: ", e);
1:383d12e:                 }
1:383d12e:             }
1:383d12e:         }
1:383d12e:     }
1:383d12e: 
1:7092b19:     protected void registerProducer(ObjectName key, ActiveMQDestination dest, ProducerView view) throws Exception {
1:71c0d44: 
1:71c0d44:         if (dest != null) {
1:71c0d44:             if (dest.isQueue()) {
1:71c0d44:                 if (dest.isTemporary()) {
1:71c0d44:                     temporaryQueueProducers.put(key, view);
1:71c0d44:                 } else {
1:71c0d44:                     queueProducers.put(key, view);
1:71c0d44:                 }
1:7092b19:             } else {
1:71c0d44:                 if (dest.isTemporary()) {
1:71c0d44:                     temporaryTopicProducers.put(key, view);
1:71c0d44:                 } else {
1:71c0d44:                     topicProducers.put(key, view);
1:71c0d44:                 }
1:7092b19:             }
1:629b18c:         } else {
1:629b18c:             dynamicDestinationProducers.put(key, view);
1:7092b19:         }
1:71c0d44: 
1:7092b19:         try {
1:584c133:             AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);
1:7092b19:             registeredMBeans.add(key);
1:7092b19:         } catch (Throwable e) {
1:e1bbde7:             LOG.warn("Failed to register MBean {}", key);
1:e1bbde7:             LOG.debug("Failure reason: ", e);
1:7092b19:         }
1:7092b19:     }
1:7092b19: 
1:7092b19:     protected void unregisterProducer(ObjectName key) throws Exception {
1:7092b19:         queueProducers.remove(key);
1:7092b19:         topicProducers.remove(key);
1:7092b19:         temporaryQueueProducers.remove(key);
1:7092b19:         temporaryTopicProducers.remove(key);
1:629b18c:         dynamicDestinationProducers.remove(key);
1:7092b19:         if (registeredMBeans.remove(key)) {
1:7092b19:             try {
1:7092b19:                 managementContext.unregisterMBean(key);
1:7092b19:             } catch (Throwable e) {
1:e1bbde7:                 LOG.warn("Failed to unregister MBean {}", key);
1:e1bbde7:                 LOG.debug("Failure reason: ", e);
1:7092b19:             }
1:7092b19:         }
1:7092b19:     }
1:7092b19: 
1:2290502:     private DestinationView removeAndRemember(Map<ObjectName, DestinationView> map, ObjectName key, DestinationView view) {
1:383d12e:         DestinationView candidate = map.remove(key);
1:383d12e:         if (candidate != null && view == null) {
1:383d12e:             view = candidate;
1:383d12e:         }
1:2290502:         return candidate != null ? candidate : view;
6:3601e81:     }
1:383d12e: 
1:230a86c:     protected void registerSubscription(ObjectName key, ConsumerInfo info, SubscriptionKey subscriptionKey, SubscriptionView view) throws Exception {
1:230a86c:         ActiveMQDestination dest = info.getDestination();
2:230a86c:         if (dest.isQueue()) {
3:230a86c:             if (dest.isTemporary()) {
1:230a86c:                 temporaryQueueSubscribers.put(key, view);
1:230a86c:             } else {
1:230a86c:                 queueSubscribers.put(key, view);
1:3601e81:             }
1:230a86c:         } else {
1:230a86c:             if (dest.isTemporary()) {
1:230a86c:                 temporaryTopicSubscribers.put(key, view);
1:230a86c:             } else {
1:caca105:                 if (info.isDurable()) {
1:230a86c:                     durableTopicSubscribers.put(key, view);
1:6c0df67:                     // unregister any inactive durable subs
1:230a86c:                     try {
1:4fc1712:                         ObjectName inactiveName = subscriptionKeys.get(subscriptionKey);
1:230a86c:                         if (inactiveName != null) {
1:c82f6f3:                             inactiveDurableTopicSubscribers.remove(inactiveName);
1:3cd3fd3:                             registeredMBeans.remove(inactiveName);
1:1ec71bd:                             managementContext.unregisterMBean(inactiveName);
1:3601e81:                         }
1:230a86c:                     } catch (Throwable e) {
1:e1bbde7:                         LOG.error("Unable to unregister inactive durable subscriber {}", subscriptionKey, e);
1:3601e81:                     }
1:230a86c:                 } else {
1:230a86c:                     topicSubscribers.put(key, view);
1:3601e81:                 }
1:3601e81:             }
1:3601e81:         }
1:383d12e: 
1:cafe4cb:         try {
1:584c133:             AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);
1:cafe4cb:             registeredMBeans.add(key);
1:cafe4cb:         } catch (Throwable e) {
1:e1bbde7:             LOG.warn("Failed to register MBean {}", key);
1:e1bbde7:             LOG.debug("Failure reason: ", e);
1:3601e81:         }
1:3601e81:     }
1:6c0df67: 
1:4fc1712:     protected void unregisterSubscription(ObjectName key, boolean addToInactive) throws Exception {
1:3601e81:         queueSubscribers.remove(key);
1:3601e81:         topicSubscribers.remove(key);
1:3601e81:         temporaryQueueSubscribers.remove(key);
1:3601e81:         temporaryTopicSubscribers.remove(key);
1:230a86c:         if (registeredMBeans.remove(key)) {
1:cafe4cb:             try {
1:1ec71bd:                 managementContext.unregisterMBean(key);
1:cafe4cb:             } catch (Throwable e) {
1:e1bbde7:                 LOG.warn("Failed to unregister MBean {}", key);
1:e1bbde7:                 LOG.debug("Failure reason: ", e);
1:05d271a:             }
1:c82f6f3:         }
1:230a86c:         DurableSubscriptionView view = (DurableSubscriptionView)durableTopicSubscribers.remove(key);
1:230a86c:         if (view != null) {
1:6c0df67:             // need to put this back in the inactive list
1:230a86c:             SubscriptionKey subscriptionKey = new SubscriptionKey(view.getClientId(), view.getSubscriptionName());
1:4fc1712:             if (addToInactive) {
1:4fc1712:                 SubscriptionInfo info = new SubscriptionInfo();
1:4fc1712:                 info.setClientId(subscriptionKey.getClientId());
1:4fc1712:                 info.setSubscriptionName(subscriptionKey.getSubscriptionName());
1:4fc1712:                 info.setDestination(new ActiveMQTopic(view.getDestinationName()));
1:79c9f2d:                 info.setSelector(view.getSelector());
1:e23b8ea:                 addInactiveSubscription(subscriptionKey, info, (brokerService.isKeepDurableSubsActive() ? view.subscription : null));
1:4fc1712:             }
1:6c0df67:         }
1:c82f6f3:     }
1:6c0df67: 
1:230a86c:     protected void buildExistingSubscriptions() throws Exception {
1:ecf89a6:         Map<SubscriptionKey, SubscriptionInfo> subscriptions = new HashMap<SubscriptionKey, SubscriptionInfo>();
1:f5dcc9d:         Set<ActiveMQDestination> destinations = destinationFactory.getDestinations();
1:230a86c:         if (destinations != null) {
1:f5dcc9d:             for (ActiveMQDestination dest : destinations) {
1:7092b19:                 if (dest.isTopic()) {
1:230a86c:                     SubscriptionInfo[] infos = destinationFactory.getAllDurableSubscriptions((ActiveMQTopic)dest);
1:230a86c:                     if (infos != null) {
1:c82f6f3:                         for (int i = 0; i < infos.length; i++) {
1:c82f6f3:                             SubscriptionInfo info = infos[i];
1:c82f6f3:                             SubscriptionKey key = new SubscriptionKey(info);
1:05f82a9:                             if (!alreadyKnown(key)) {
1:e1bbde7:                                 LOG.debug("Restoring durable subscription MBean {}", info);
1:05f82a9:                                 subscriptions.put(key, info);
1:05f82a9:                             }
1:c82f6f3:                         }
1:c82f6f3:                     }
1:c82f6f3:                 }
1:c82f6f3:             }
1:c82f6f3:         }
1:6c0df67: 
1:f5dcc9d:         for (Map.Entry<SubscriptionKey, SubscriptionInfo> entry : subscriptions.entrySet()) {
1:f5dcc9d:             addInactiveSubscription(entry.getKey(), entry.getValue(), null);
1:c82f6f3:         }
1:c82f6f3:     }
1:6c0df67: 
1:05f82a9:     private boolean alreadyKnown(SubscriptionKey key) {
1:05f82a9:         boolean known = false;
1:05f82a9:         known = ((TopicRegion) getTopicRegion()).durableSubscriptionExists(key);
1:e1bbde7:         LOG.trace("Sub with key: {}, {} already registered", key, (known ? "": "not"));
1:05f82a9:         return known;
1:05f82a9:     }
1:05f82a9: 
1:caca105:     protected void addInactiveSubscription(SubscriptionKey key, SubscriptionInfo info, Subscription subscription) {
1:230a86c:         try {
1:caca105:             ConsumerInfo offlineConsumerInfo = subscription != null ? subscription.getConsumerInfo() : ((TopicRegion)getTopicRegion()).createInactiveConsumerInfo(info);
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createSubscriptionName(brokerObjectName, info.getClientId(), offlineConsumerInfo);
1:e06685f:             SubscriptionView view = new InactiveDurableSubscriptionView(this, brokerService, key.getClientId(), info, subscription);
1:6c0df67: 
1:230a86c:             try {
1:584c133:                 AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);
1:cafe4cb:                 registeredMBeans.add(objectName);
1:230a86c:             } catch (Throwable e) {
1:e1bbde7:                 LOG.warn("Failed to register MBean {}", key);
1:e1bbde7:                 LOG.debug("Failure reason: ", e);
1:383d12e:             }
1:383d12e: 
1:230a86c:             inactiveDurableTopicSubscribers.put(objectName, view);
1:c82f6f3:             subscriptionKeys.put(key, objectName);
1:230a86c:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Failed to register subscription {}", info, e);
1:05f82a9:         }
1:c82f6f3:     }
1:6c0df67: 
1:230a86c:     public CompositeData[] browse(SubscriptionView view) throws OpenDataException {
1:11579bb:         Message[] messages = getSubscriberMessages(view);
1:11579bb:         CompositeData c[] = new CompositeData[messages.length];
1:230a86c:         for (int i = 0; i < c.length; i++) {
1:230a86c:             try {
1:11579bb:                 c[i] = OpenTypeSupport.convert(messages[i]);
1:230a86c:             } catch (Throwable e) {
1:e1bbde7:                 LOG.error("Failed to browse: {}", view, e);
1:3601e81:             }
1:3601e81:         }
1:c717221:         return c;
1:c717221:     }
1:6c0df67: 
1:230a86c:     public TabularData browseAsTable(SubscriptionView view) throws OpenDataException {
1:230a86c:         OpenTypeFactory factory = OpenTypeSupport.getFactory(ActiveMQMessage.class);
1:11579bb:         Message[] messages = getSubscriberMessages(view);
1:230a86c:         CompositeType ct = factory.getCompositeType();
1:230a86c:         TabularType tt = new TabularType("MessageList", "MessageList", ct, new String[] {"JMSMessageID"});
1:230a86c:         TabularDataSupport rc = new TabularDataSupport(tt);
1:11579bb:         for (int i = 0; i < messages.length; i++) {
1:11579bb:             rc.put(new CompositeDataSupport(ct, factory.getFields(messages[i])));
1:c717221:         }
1:c717221:         return rc;
1:c717221:     }
1:6c0df67: 
1:11579bb:     public void remove(SubscriptionView view, String messageId)  throws Exception {
1:11579bb:         ActiveMQDestination destination = getTopicDestination(view);
1:11579bb:         if (destination != null) {
1:cc9b9b0:             final Destination topic = getTopicRegion().getDestinationMap().get(destination);
1:11579bb:             final MessageAck messageAck = new MessageAck();
1:11579bb:             messageAck.setMessageID(new MessageId(messageId));
1:11579bb:             messageAck.setDestination(destination);
1:11579bb: 
1:11579bb:             topic.getMessageStore().removeMessage(brokerService.getAdminConnectionContext(), messageAck);
1:11579bb: 
1:11579bb:             // if sub is active, remove from cursor
1:11579bb:             if (view.subscription instanceof DurableTopicSubscription) {
1:11579bb:                 final DurableTopicSubscription durableTopicSubscription = (DurableTopicSubscription) view.subscription;
1:11579bb:                 final MessageReference messageReference = new NullMessageReference();
1:11579bb:                 messageReference.getMessage().setMessageId(messageAck.getFirstMessageId());
1:11579bb:                 durableTopicSubscription.getPending().remove(messageReference);
1:11579bb:             }
1:11579bb: 
1:11579bb:         } else {
1:11579bb:             throw new IllegalStateException("can't determine topic for sub:" + view);
1:11579bb:         }
1:c717221:     }
1:6c0df67: 
1:11579bb:     protected Message[] getSubscriberMessages(SubscriptionView view) {
1:11579bb:         ActiveMQDestination destination = getTopicDestination(view);
1:11579bb:         if (destination != null) {
1:cc9b9b0:             Destination topic = getTopicRegion().getDestinationMap().get(destination);
1:11579bb:             return topic.browse();
1:6c0df67: 
1:11579bb:         } else {
1:11579bb:             LOG.warn("can't determine topic to browse for sub:" + view);
1:11579bb:             return new Message[]{};
1:11579bb:         }
1:c717221:     }
1:6c0df67: 
1:11579bb:     private ActiveMQDestination getTopicDestination(SubscriptionView view) {
1:11579bb:         ActiveMQDestination destination = null;
1:11579bb:         if (view.subscription instanceof DurableTopicSubscription) {
1:11579bb:             destination = new ActiveMQTopic(view.getDestinationName());
1:11579bb:         } else if (view instanceof InactiveDurableSubscriptionView) {
1:11579bb:             destination = ((InactiveDurableSubscriptionView)view).subscriptionInfo.getDestination();
1:11579bb:         }
1:11579bb:         return destination;
1:c717221:     }
1:6c0df67: 
1:4997427:     private ObjectName[] onlyNonSuppressed (Set<ObjectName> set){
1:4997427:         List<ObjectName> nonSuppressed = new ArrayList<ObjectName>();
1:4997427:         for(ObjectName key : set){
1:4997427:             if (managementContext.isAllowedToRegister(key)){
1:4997427:                 nonSuppressed.add(key);
1:4997427:             }
1:4997427:         }
1:4997427:         return nonSuppressed.toArray(new ObjectName[nonSuppressed.size()]);
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getTopics() {
1:ecf89a6:         Set<ObjectName> set = topics.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c717221: 
1:4997427:     protected ObjectName[] getTopicsNonSuppressed() {
1:4997427:         return onlyNonSuppressed(topics.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getQueues() {
1:ecf89a6:         Set<ObjectName> set = queues.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c717221: 
1:4997427:     protected ObjectName[] getQueuesNonSuppressed() {
1:4997427:         return onlyNonSuppressed(queues.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getTemporaryTopics() {
1:ecf89a6:         Set<ObjectName> set = temporaryTopics.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c717221: 
1:4997427:     protected ObjectName[] getTemporaryTopicsNonSuppressed() {
1:4997427:         return onlyNonSuppressed(temporaryTopics.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getTemporaryQueues() {
1:ecf89a6:         Set<ObjectName> set = temporaryQueues.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c717221: 
1:4997427:     protected ObjectName[] getTemporaryQueuesNonSuppressed() {
1:4997427:         return onlyNonSuppressed(temporaryQueues.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getTopicSubscribers() {
1:ecf89a6:         Set<ObjectName> set = topicSubscribers.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c717221: 
1:4997427:     protected ObjectName[] getTopicSubscribersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(topicSubscribers.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getDurableTopicSubscribers() {
1:ecf89a6:         Set<ObjectName> set = durableTopicSubscribers.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c717221: 
1:4997427:     protected ObjectName[] getDurableTopicSubscribersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(durableTopicSubscribers.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getQueueSubscribers() {
1:ecf89a6:         Set<ObjectName> set = queueSubscribers.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c717221: 
1:4997427:     protected ObjectName[] getQueueSubscribersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(queueSubscribers.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getTemporaryTopicSubscribers() {
1:ecf89a6:         Set<ObjectName> set = temporaryTopicSubscribers.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c82f6f3: 
1:4997427:     protected ObjectName[] getTemporaryTopicSubscribersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(temporaryTopicSubscribers.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getTemporaryQueueSubscribers() {
1:ecf89a6:         Set<ObjectName> set = temporaryQueueSubscribers.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
1:c82f6f3: 
1:4997427:     protected ObjectName[] getTemporaryQueueSubscribersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(temporaryQueueSubscribers.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     protected ObjectName[] getInactiveDurableTopicSubscribers() {
1:ecf89a6:         Set<ObjectName> set = inactiveDurableTopicSubscribers.keySet();
1:ecf89a6:         return set.toArray(new ObjectName[set.size()]);
1:3601e81:     }
3:c82f6f3: 
1:4997427:     protected ObjectName[] getInactiveDurableTopicSubscribersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(inactiveDurableTopicSubscribers.keySet());
1:4997427:     }
1:4997427: 
1:7092b19:     protected ObjectName[] getTopicProducers() {
1:7092b19:         Set<ObjectName> set = topicProducers.keySet();
1:7092b19:         return set.toArray(new ObjectName[set.size()]);
1:7092b19:     }
1:7092b19: 
1:4997427:     protected ObjectName[] getTopicProducersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(topicProducers.keySet());
1:4997427:     }
1:4997427: 
1:7092b19:     protected ObjectName[] getQueueProducers() {
1:7092b19:         Set<ObjectName> set = queueProducers.keySet();
1:7092b19:         return set.toArray(new ObjectName[set.size()]);
1:7092b19:     }
1:7092b19: 
1:4997427:     protected ObjectName[] getQueueProducersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(queueProducers.keySet());
1:4997427:     }
1:4997427: 
1:7092b19:     protected ObjectName[] getTemporaryTopicProducers() {
1:7092b19:         Set<ObjectName> set = temporaryTopicProducers.keySet();
1:7092b19:         return set.toArray(new ObjectName[set.size()]);
1:7092b19:     }
1:7092b19: 
1:4997427:     protected ObjectName[] getTemporaryTopicProducersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(temporaryTopicProducers.keySet());
1:4997427:     }
1:4997427: 
1:7092b19:     protected ObjectName[] getTemporaryQueueProducers() {
1:7092b19:         Set<ObjectName> set = temporaryQueueProducers.keySet();
1:7092b19:         return set.toArray(new ObjectName[set.size()]);
1:7092b19:     }
1:7092b19: 
1:4997427:     protected ObjectName[] getTemporaryQueueProducersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(temporaryQueueProducers.keySet());
1:4997427:     }
1:4997427: 
1:629b18c:     protected ObjectName[] getDynamicDestinationProducers() {
1:629b18c:         Set<ObjectName> set = dynamicDestinationProducers.keySet();
1:629b18c:         return set.toArray(new ObjectName[set.size()]);
1:629b18c:     }
1:629b18c: 
1:4997427:     protected ObjectName[] getDynamicDestinationProducersNonSuppressed() {
1:4997427:         return onlyNonSuppressed(dynamicDestinationProducers.keySet());
1:4997427:     }
1:4997427: 
1:230a86c:     public Broker getContextBroker() {
1:ed5d43b:         return contextBroker;
1:3601e81:     }
1:c82f6f3: 
1:230a86c:     public void setContextBroker(Broker contextBroker) {
1:230a86c:         this.contextBroker = contextBroker;
1:c37859a:     }
1:c37859a: 
1:383d12e:     public ObjectName registerSlowConsumerStrategy(AbortSlowConsumerStrategy strategy) throws MalformedObjectNameException {
1:383d12e:         ObjectName objectName = null;
1:383d12e:         try {
1:7d7d6fa:             objectName = BrokerMBeanSupport.createAbortSlowConsumerStrategyName(brokerObjectName, strategy);
1:383d12e:             if (!registeredMBeans.contains(objectName))  {
1:1982d54: 
1:1982d54:                 AbortSlowConsumerStrategyView view = null;
1:1982d54:                 if (strategy instanceof AbortSlowAckConsumerStrategy) {
1:1982d54:                     view = new AbortSlowAckConsumerStrategyView(this, (AbortSlowAckConsumerStrategy) strategy);
1:1982d54:                 } else {
1:1982d54:                     view = new AbortSlowConsumerStrategyView(this, strategy);
1:1982d54:                 }
1:1982d54: 
1:584c133:                 AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);
1:383d12e:                 registeredMBeans.add(objectName);
1:383d12e:             }
1:383d12e:         } catch (Exception e) {
1:e1bbde7:             LOG.warn("Failed to register MBean {}", strategy);
1:e1bbde7:             LOG.debug("Failure reason: ", e);
1:383d12e:         }
1:7092b19:         return objectName;
1:383d12e:     }
1:383d12e: 
1:1d242a2:     public void registerRecoveredTransactionMBean(XATransaction transaction) {
1:1d242a2:         try {
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);
1:1d242a2:             if (!registeredMBeans.contains(objectName))  {
1:1d242a2:                 RecoveredXATransactionView view = new RecoveredXATransactionView(this, transaction);
1:584c133:                 AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);
1:1d242a2:                 registeredMBeans.add(objectName);
1:1d242a2:             }
1:1d242a2:         } catch (Exception e) {
1:e1bbde7:             LOG.warn("Failed to register prepared transaction MBean {}", transaction);
1:e1bbde7:             LOG.debug("Failure reason: ", e);
1:1d242a2:         }
1:1d242a2:     }
1:1d242a2: 
1:1d242a2:     public void unregister(XATransaction transaction) {
1:1d242a2:         try {
1:7d7d6fa:             ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);
1:1d242a2:             if (registeredMBeans.remove(objectName)) {
1:1d242a2:                 try {
1:1d242a2:                     managementContext.unregisterMBean(objectName);
1:1d242a2:                 } catch (Throwable e) {
1:e1bbde7:                     LOG.warn("Failed to unregister MBean {}", objectName);
1:e1bbde7:                     LOG.debug("Failure reason: ", e);
1:1d242a2:                 }
1:1d242a2:             }
1:1d242a2:         } catch (Exception e) {
1:e1bbde7:             LOG.warn("Failed to create object name to unregister {}", transaction, e);
1:1d242a2:         }
1:1d242a2:     }
1:1d242a2: 
1:383d12e:     public ObjectName getSubscriberObjectName(Subscription key) {
1:383d12e:         return subscriptionMap.get(key);
1:383d12e:     }
1:383d12e: 
1:383d12e:     public Subscription getSubscriber(ObjectName key) {
1:383d12e:         Subscription sub = null;
1:383d12e:         for (Entry<Subscription, ObjectName> entry: subscriptionMap.entrySet()) {
1:383d12e:             if (entry.getValue().equals(key)) {
1:383d12e:                 sub = entry.getKey();
1:383d12e:                 break;
1:383d12e:             }
1:383d12e:         }
1:383d12e:         return sub;
1:383d12e:     }
1:c82f6f3: 
1:ed96e2e:     public Map<ObjectName, DestinationView> getQueueViews() {
1:ed96e2e:         return queues;
1:ed96e2e:     }
1:6630e81: 
1:6630e81:     public Map<ObjectName, DestinationView> getTopicViews() {
1:6630e81:         return topics;
1:6630e81:     }
1:6630e81: 
1:6630e81:     public DestinationView getQueueView(String queueName) throws MalformedObjectNameException {
1:6630e81:         ObjectName objName = BrokerMBeanSupport.createDestinationName(brokerObjectName.toString(), "Queue", queueName);
1:6630e81:         return queues.get(objName);
1:6630e81:     }
1:3601e81: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:6630e81
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Map<ObjectName, DestinationView> getTopicViews() {
1:         return topics;
1:     }
1: 
1:     public DestinationView getQueueView(String queueName) throws MalformedObjectNameException {
1:         ObjectName objName = BrokerMBeanSupport.createDestinationName(brokerObjectName.toString(), "Queue", queueName);
1:         return queues.get(objName);
1:     }
author:Jeff Genender
-------------------------------------------------------------------------------
commit:4997427
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1:     private ObjectName[] onlyNonSuppressed (Set<ObjectName> set){
1:         List<ObjectName> nonSuppressed = new ArrayList<ObjectName>();
1:         for(ObjectName key : set){
1:             if (managementContext.isAllowedToRegister(key)){
1:                 nonSuppressed.add(key);
1:             }
1:         }
1:         return nonSuppressed.toArray(new ObjectName[nonSuppressed.size()]);
1:     }
1: 
1:     protected ObjectName[] getTopicsNonSuppressed() {
1:         return onlyNonSuppressed(topics.keySet());
1:     }
1: 
1:     protected ObjectName[] getQueuesNonSuppressed() {
1:         return onlyNonSuppressed(queues.keySet());
1:     }
1: 
1:     protected ObjectName[] getTemporaryTopicsNonSuppressed() {
1:         return onlyNonSuppressed(temporaryTopics.keySet());
1:     }
1: 
1:     protected ObjectName[] getTemporaryQueuesNonSuppressed() {
1:         return onlyNonSuppressed(temporaryQueues.keySet());
1:     }
1: 
1:     protected ObjectName[] getTopicSubscribersNonSuppressed() {
1:         return onlyNonSuppressed(topicSubscribers.keySet());
1:     }
1: 
1:     protected ObjectName[] getDurableTopicSubscribersNonSuppressed() {
1:         return onlyNonSuppressed(durableTopicSubscribers.keySet());
1:     }
1: 
1:     protected ObjectName[] getQueueSubscribersNonSuppressed() {
1:         return onlyNonSuppressed(queueSubscribers.keySet());
1:     }
1: 
1:     protected ObjectName[] getTemporaryTopicSubscribersNonSuppressed() {
1:         return onlyNonSuppressed(temporaryTopicSubscribers.keySet());
1:     }
1: 
1:     protected ObjectName[] getTemporaryQueueSubscribersNonSuppressed() {
1:         return onlyNonSuppressed(temporaryQueueSubscribers.keySet());
1:     }
1: 
1:     protected ObjectName[] getInactiveDurableTopicSubscribersNonSuppressed() {
1:         return onlyNonSuppressed(inactiveDurableTopicSubscribers.keySet());
1:     }
1: 
1:     protected ObjectName[] getTopicProducersNonSuppressed() {
1:         return onlyNonSuppressed(topicProducers.keySet());
1:     }
1: 
1:     protected ObjectName[] getQueueProducersNonSuppressed() {
1:         return onlyNonSuppressed(queueProducers.keySet());
1:     }
1: 
1:     protected ObjectName[] getTemporaryTopicProducersNonSuppressed() {
1:         return onlyNonSuppressed(temporaryTopicProducers.keySet());
1:     }
1: 
1:     protected ObjectName[] getTemporaryQueueProducersNonSuppressed() {
1:         return onlyNonSuppressed(temporaryQueueProducers.keySet());
1:     }
1: 
1:     protected ObjectName[] getDynamicDestinationProducersNonSuppressed() {
1:         return onlyNonSuppressed(dynamicDestinationProducers.keySet());
1:     }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:cc9b9b0
/////////////////////////////////////////////////////////////////////////
1:             final Destination topic = getTopicRegion().getDestinationMap().get(destination);
/////////////////////////////////////////////////////////////////////////
1:             Destination topic = getTopicRegion().getDestinationMap().get(destination);
commit:11579bb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.IllegalStateException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.DurableTopicSubscription;
1: import org.apache.activemq.broker.region.MessageReference;
1: import org.apache.activemq.broker.region.NullMessageReference;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageAck;
/////////////////////////////////////////////////////////////////////////
1:         Message[] messages = getSubscriberMessages(view);
1:         CompositeData c[] = new CompositeData[messages.length];
1:                 c[i] = OpenTypeSupport.convert(messages[i]);
/////////////////////////////////////////////////////////////////////////
1:         Message[] messages = getSubscriberMessages(view);
1:         for (int i = 0; i < messages.length; i++) {
1:             rc.put(new CompositeDataSupport(ct, factory.getFields(messages[i])));
1:     public void remove(SubscriptionView view, String messageId)  throws Exception {
1:         ActiveMQDestination destination = getTopicDestination(view);
1:         if (destination != null) {
0:             final Topic topic = (Topic) getTopicRegion().getDestinationMap().get(destination);
1:             final MessageAck messageAck = new MessageAck();
1:             messageAck.setMessageID(new MessageId(messageId));
1:             messageAck.setDestination(destination);
1: 
1:             topic.getMessageStore().removeMessage(brokerService.getAdminConnectionContext(), messageAck);
1: 
1:             // if sub is active, remove from cursor
1:             if (view.subscription instanceof DurableTopicSubscription) {
1:                 final DurableTopicSubscription durableTopicSubscription = (DurableTopicSubscription) view.subscription;
1:                 final MessageReference messageReference = new NullMessageReference();
1:                 messageReference.getMessage().setMessageId(messageAck.getFirstMessageId());
1:                 durableTopicSubscription.getPending().remove(messageReference);
1:             }
1: 
1:         } else {
1:             throw new IllegalStateException("can't determine topic for sub:" + view);
1:     }
1:     protected Message[] getSubscriberMessages(SubscriptionView view) {
1:         ActiveMQDestination destination = getTopicDestination(view);
1:         if (destination != null) {
0:             Topic topic = (Topic) getTopicRegion().getDestinationMap().get(destination);
1:             return topic.browse();
1:         } else {
1:             LOG.warn("can't determine topic to browse for sub:" + view);
1:             return new Message[]{};
1:     }
1:     private ActiveMQDestination getTopicDestination(SubscriptionView view) {
1:         ActiveMQDestination destination = null;
1:         if (view.subscription instanceof DurableTopicSubscription) {
1:             destination = new ActiveMQTopic(view.getDestinationName());
1:         } else if (view instanceof InactiveDurableSubscriptionView) {
1:             destination = ((InactiveDurableSubscriptionView)view).subscriptionInfo.getDestination();
1:         }
1:         return destination;
commit:3fdf986
/////////////////////////////////////////////////////////////////////////
1:                 ObjectName inactiveName = subscriptionKeys.remove(subscriptionKey);
author:Timothy Bish
-------------------------------------------------------------------------------
commit:fde22a8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConnectionInfo;
/////////////////////////////////////////////////////////////////////////
1:     public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {
1:         super.addConnection(context, info);
1:         this.contextBroker.getBrokerService().incrementCurrentConnections();
1:         this.contextBroker.getBrokerService().incrementTotalConnections();
1:     }
1: 
1:     @Override
1:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {
1:         super.removeConnection(context, info, error);
1:         this.contextBroker.getBrokerService().decrementCurrentConnections();
1:     }
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("The MBean {} is no longer registered with JMX", name);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("JMX View is not supported for custom destination {}", destination);
1:             LOG.error("Failed to register destination {}", destName, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Failed to unregister {}", destName, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Failed to register subscription {}", sub, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Failed to unregister subscription {}", sub, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to register MBean {}", key);
1:             LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Failed to unregister MBean {}", key);
1:                 LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Failed to unregister slow consumer strategy MBean {}", key);
1:                     LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to register MBean {}", key);
1:             LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Failed to unregister MBean {}", key);
1:                 LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.error("Unable to unregister inactive durable subscriber {}", subscriptionKey, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to register MBean {}", key);
1:             LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Failed to unregister MBean {}", key);
1:                 LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.debug("Restoring durable subscription MBean {}", info);
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("Sub with key: {}, {} already registered", key, (known ? "": "not"));
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Failed to register MBean {}", key);
1:                 LOG.debug("Failure reason: ", e);
1:             LOG.error("Failed to register subscription {}", info, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Failed to browse: {}", view, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to browse messages for Subscription {}", view, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to register MBean {}", strategy);
1:             LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to register prepared transaction MBean {}", transaction);
1:             LOG.debug("Failure reason: ", e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Failed to unregister MBean {}", objectName);
1:                     LOG.debug("Failure reason: ", e);
1:             LOG.warn("Failed to create object name to unregister {}", transaction, e);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:1982d54
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.AbortSlowAckConsumerStrategy;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 AbortSlowConsumerStrategyView view = null;
1:                 if (strategy instanceof AbortSlowAckConsumerStrategy) {
1:                     view = new AbortSlowAckConsumerStrategyView(this, (AbortSlowAckConsumerStrategy) strategy);
1:                 } else {
1:                     view = new AbortSlowConsumerStrategyView(this, strategy);
1:                 }
1: 
commit:63a660a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = BrokerMBeanSuppurt.createDestinationName(brokerObjectName, destName);
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = BrokerMBeanSuppurt.createDestinationName(brokerObjectName, destName);
/////////////////////////////////////////////////////////////////////////
1: 
0:             ObjectName objectName = BrokerMBeanSuppurt.createSubscriptionName(brokerObjectName, connectionClientId, sub.getConsumerInfo());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
0:         ObjectName objectName = BrokerMBeanSuppurt.createProducerName(brokerObjectName, context.getClientId(), info);
/////////////////////////////////////////////////////////////////////////
0:         ObjectName objectName = BrokerMBeanSuppurt.createProducerName(brokerObjectName, context.getClientId(), info);
/////////////////////////////////////////////////////////////////////////
0:                 ObjectName objectName = BrokerMBeanSuppurt.createProducerName(brokerObjectName, exchange.getConnectionContext().getClientId(), info);
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = BrokerMBeanSuppurt.createSubscriptionName(brokerObjectName, info.getClientId(), offlineConsumerInfo);
/////////////////////////////////////////////////////////////////////////
0:             objectName = BrokerMBeanSuppurt.createAbortSlowConsumerStrategyName(brokerObjectName, strategy);
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = BrokerMBeanSuppurt.createXATransactionName(brokerObjectName, transaction);
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = BrokerMBeanSuppurt.createXATransactionName(brokerObjectName, transaction);
/////////////////////////////////////////////////////////////////////////
commit:e600876
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.broker.region.Destination;
1: import org.apache.activemq.broker.region.DestinationFactory;
0: import org.apache.activemq.broker.region.DestinationFactoryImpl;
1: import org.apache.activemq.broker.region.DestinationInterceptor;
1: import org.apache.activemq.broker.region.Queue;
1: import org.apache.activemq.broker.region.Region;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.broker.region.Topic;
1: import org.apache.activemq.broker.region.TopicRegion;
1: import org.apache.activemq.broker.region.TopicSubscription;
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 @Override
1:                 @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
0:         objectNameStr += ",Service=SlowConsumerStrategy,InstanceName="+ JMXSupport.encodeObjectNamePart(strategy.getName());
commit:584c133
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ExecutorService;
/////////////////////////////////////////////////////////////////////////
1:     private final ExecutorService asyncInvokeService;
1:     private final long mbeanTimeout;
1: 
1:         this.mbeanTimeout = brokerService.getMbeanInvocationTimeout();
1:         this.asyncInvokeService = mbeanTimeout > 0 ? executor : null;;
/////////////////////////////////////////////////////////////////////////
1:             AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);
/////////////////////////////////////////////////////////////////////////
1:             AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);
/////////////////////////////////////////////////////////////////////////
1:             AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, key);
/////////////////////////////////////////////////////////////////////////
1:                 AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);
/////////////////////////////////////////////////////////////////////////
1:                 AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);
/////////////////////////////////////////////////////////////////////////
1:                 AsyncAnnotatedMBean.registerMBean(asyncInvokeService, mbeanTimeout, managementContext, view, objectName);
commit:f5dcc9d
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 String userName = brokerService.isPopulateUserNameInMBeans() ? context.getUserName() : null;
0:                     view = new DurableSubscriptionView(this, context.getClientId(), userName, sub);
1:                         view = new TopicSubscriptionView(context.getClientId(), userName, (TopicSubscription) sub);
1:                         view = new SubscriptionView(context.getClientId(), userName, sub);
/////////////////////////////////////////////////////////////////////////
0:         Hashtable<String, String> map = brokerJmxObjectName.getKeyPropertyList();
/////////////////////////////////////////////////////////////////////////
1:         String userName = brokerService.isPopulateUserNameInMBeans() ? context.getUserName() : null;
1:         ProducerView view = new ProducerView(info, connectionClientId, userName, this);
/////////////////////////////////////////////////////////////////////////
1:         Set<ActiveMQDestination> destinations = destinationFactory.getDestinations();
1:             for (ActiveMQDestination dest : destinations) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (Map.Entry<SubscriptionKey, SubscriptionInfo> entry : subscriptions.entrySet()) {
1:             addInactiveSubscription(entry.getKey(), entry.getValue(), null);
/////////////////////////////////////////////////////////////////////////
0:         Hashtable<String, String> map = brokerObjectName.getKeyPropertyList();
/////////////////////////////////////////////////////////////////////////
0:         Hashtable<String, String> map = brokerObjectName.getKeyPropertyList();
/////////////////////////////////////////////////////////////////////////
0:         Hashtable<String, String> map = brokerObjectName.getKeyPropertyList();
/////////////////////////////////////////////////////////////////////////
0:         Hashtable<String, String> map = brokerObjectName.getKeyPropertyList();
commit:6ad39a3
/////////////////////////////////////////////////////////////////////////
0:             destinationType += "Dynamic";
commit:d34967b
/////////////////////////////////////////////////////////////////////////
0:             destinationType += "dynamic";
0:             destinationName = null;
/////////////////////////////////////////////////////////////////////////
0:                                                + destinationType + ","
0:                                                + (destinationName != null ? destinationName + "," : "")
commit:629b18c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.ProducerBrokerExchange;
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ObjectName, ProducerView> dynamicDestinationProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void send(ProducerBrokerExchange exchange, Message message) throws Exception {
1:         if (exchange != null && exchange.getProducerState() != null && exchange.getProducerState().getInfo() != null) {
1:             ProducerInfo info = exchange.getProducerState().getInfo();
1:             if (info.getDestination() == null && info.getProducerId() != null) {
0:                 ObjectName objectName = createObjectName(info, exchange.getConnectionContext().getClientId());
1:                 ProducerView view = this.dynamicDestinationProducers.get(objectName);
1:                 if (view != null) {
1:                     ActiveMQDestination dest = message.getDestination();
1:                     if (dest != null) {
1:                         view.setLastUsedDestinationName(dest);
1:                     }
1:                 }
1:             }
1:          }
1:         super.send(exchange, message);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         } else {
1:             dynamicDestinationProducers.put(key, view);
/////////////////////////////////////////////////////////////////////////
1:         dynamicDestinationProducers.remove(key);
/////////////////////////////////////////////////////////////////////////
1:     protected ObjectName[] getDynamicDestinationProducers() {
1:         Set<ObjectName> set = dynamicDestinationProducers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:     }
1: 
commit:71c0d44
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (dest != null) {
1:             if (dest.isQueue()) {
1:                 if (dest.isTemporary()) {
1:                     temporaryQueueProducers.put(key, view);
1:                 } else {
1:                     queueProducers.put(key, view);
1:                 }
1:                 if (dest.isTemporary()) {
1:                     temporaryTopicProducers.put(key, view);
1:                 } else {
1:                     topicProducers.put(key, view);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:         Hashtable<String, String> map = brokerObjectName.getKeyPropertyList();
/////////////////////////////////////////////////////////////////////////
0:         String destinationType = "destinationType=";
0:         String destinationName = "destinationName=";
1: 
0:         if (producerInfo.getDestination() == null) {
0:             destinationType += "NOTSET";
0:             destinationName += "NOTSET";
1:         } else {
0:             destinationType += producerInfo.getDestination().getDestinationTypeAsString();
0:             destinationName += JMXSupport.encodeObjectNamePart(producerInfo.getDestination().getPhysicalName());
1:         }
1: 
commit:7092b19
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ProducerInfo;
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ObjectName, ProducerView> queueProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:     private final Map<ObjectName, ProducerView> topicProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:     private final Map<ObjectName, ProducerView> temporaryQueueProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
1:     private final Map<ObjectName, ProducerView> temporaryTopicProducers = new ConcurrentHashMap<ObjectName, ProducerView>();
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     public void addProducer(ConnectionContext context, ProducerInfo info)
0:             throws Exception {
1:         super.addProducer(context, info);
1:         String connectionClientId = context.getClientId();
0:         ObjectName objectName = createObjectName(info, connectionClientId);
0:         ProducerView view = new ProducerView(info, connectionClientId, this);
1:         registerProducer(objectName, info.getDestination(), view);
1:     }
1: 
1:     @Override
1:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
0:         ObjectName objectName = createObjectName(info, context.getClientId());
1:         unregisterProducer(objectName);
1:         super.removeProducer(context, info);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected void registerProducer(ObjectName key, ActiveMQDestination dest, ProducerView view) throws Exception {
1:         if (dest.isQueue()) {
1:             if (dest.isTemporary()) {
0:                 temporaryQueueProducers.put(key, view);
1:             } else {
0:                 queueProducers.put(key, view);
1:             }
1:         } else {
1:             if (dest.isTemporary()) {
0:                 temporaryTopicProducers.put(key, view);
1:             } else {
0:                 topicProducers.put(key, view);
1:             }
1:         }
1:         try {
0:             AnnotatedMBean.registerMBean(managementContext, view, key);
1:             registeredMBeans.add(key);
1:         } catch (Throwable e) {
0:             LOG.warn("Failed to register MBean: " + key);
0:             LOG.debug("Failure reason: " + e, e);
1:         }
1:     }
1: 
1:     protected void unregisterProducer(ObjectName key) throws Exception {
1:         queueProducers.remove(key);
1:         topicProducers.remove(key);
1:         temporaryQueueProducers.remove(key);
1:         temporaryTopicProducers.remove(key);
1:         if (registeredMBeans.remove(key)) {
1:             try {
1:                 managementContext.unregisterMBean(key);
1:             } catch (Throwable e) {
0:                 LOG.warn("Failed to unregister MBean: " + key);
0:                 LOG.debug("Failure reason: " + e, e);
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (dest.isTopic()) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected ObjectName[] getTopicProducers() {
1:         Set<ObjectName> set = topicProducers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:     }
1: 
1:     protected ObjectName[] getQueueProducers() {
1:         Set<ObjectName> set = queueProducers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:     }
1: 
1:     protected ObjectName[] getTemporaryTopicProducers() {
1:         Set<ObjectName> set = temporaryTopicProducers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:     }
1: 
1:     protected ObjectName[] getTemporaryQueueProducers() {
1:         Set<ObjectName> set = temporaryQueueProducers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected ObjectName createObjectName(ProducerInfo producerInfo, String connectionClientId) throws MalformedObjectNameException {
0:         // Build the object name for the producer info
0:         Hashtable map = brokerObjectName.getKeyPropertyList();
1: 
0:         String destinationType = "destinationType=" + producerInfo.getDestination().getDestinationTypeAsString();
0:         String destinationName = "destinationName=" + JMXSupport.encodeObjectNamePart(producerInfo.getDestination().getPhysicalName());
0:         String clientId = "clientId=" + JMXSupport.encodeObjectNamePart(connectionClientId);
0:         String producerId = "producerId=" + JMXSupport.encodeObjectNamePart(producerInfo.getProducerId().toString());
1: 
0:         ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName") + ","
0:                                                + "Type=Producer" + ","
0:                                                + destinationType + "," + destinationName + ","
0:                                                + clientId + "," + producerId);
1:         return objectName;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return objectName;
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e06685f
/////////////////////////////////////////////////////////////////////////
1:                     view = new DurableSubscriptionView(this, brokerService, context.getClientId(), userName, sub);
/////////////////////////////////////////////////////////////////////////
1:             SubscriptionView view = new InactiveDurableSubscriptionView(this, brokerService, key.getClientId(), info, subscription);
commit:ed96e2e
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Map<ObjectName, DestinationView> getQueueViews() {
1:         return queues;
1:     }
commit:79c9f2d
/////////////////////////////////////////////////////////////////////////
1:                 info.setSelector(sub.getSelector());
0:                 addInactiveSubscription(key, info);
/////////////////////////////////////////////////////////////////////////
1:                 info.setSelector(view.getSelector());
0:                 addInactiveSubscription(subscriptionKey, info);
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ManagedRegionBroker.class);
commit:054fc6a
/////////////////////////////////////////////////////////////////////////
1:                     managementContext.unregisterMBean(inactiveName);
commit:4fc1712
/////////////////////////////////////////////////////////////////////////
1:             if (sub.getConsumerInfo().getConsumerId().getConnectionId().equals("OFFLINE")) {
1:                 // add offline subscribers to inactive list
1:                 SubscriptionInfo info = new SubscriptionInfo();
1:                 info.setClientId(context.getClientId());
1:                 info.setSubscriptionName(sub.getConsumerInfo().getSubscriptionName());
1:                 info.setDestination(sub.getConsumerInfo().getDestination());
0:                 addInactiveSubscription(key, info);
1:                 if (sub.getConsumerInfo().isDurable()) {
0:                     view = new DurableSubscriptionView(this, context.getClientId(), sub);
1:                     if (sub instanceof TopicSubscription) {
0:                         view = new TopicSubscriptionView(context.getClientId(), (TopicSubscription) sub);
1:                     } else {
0:                         view = new SubscriptionView(context.getClientId(), sub);
1:                     }
1:                 registerSubscription(objectName, sub.getConsumerInfo(), key, view);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:         Subscription sub = super.addConsumer(context, info);
1:         SubscriptionKey subscriptionKey = new SubscriptionKey(sub.getContext().getClientId(), sub.getConsumerInfo().getSubscriptionName());
1:         ObjectName inactiveName = subscriptionKeys.get(subscriptionKey);
1:         if (inactiveName != null) {
1:             // if it was inactive, register it
1:             registerSubscription(context, sub);
1:         }
1:         return sub;
1:     }
1: 
1:     @Override
1:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:         for (Subscription sub : subscriptionMap.keySet()) {
1:             if (sub.getConsumerInfo().equals(info)) {
1:                // unregister all consumer subs
1:                unregisterSubscription(subscriptionMap.get(sub), true);
1:             }
1:         }
1:         super.removeConsumer(context, info);
1:     }
1: 
1:                 SubscriptionKey subscriptionKey = new SubscriptionKey(sub.getContext().getClientId(), sub.getConsumerInfo().getSubscriptionName());
1:                 ObjectName inactiveName = subscriptionKeys.get(subscriptionKey);
1:                 if (inactiveName != null) {
1:                     inactiveDurableTopicSubscribers.remove(inactiveName);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     protected void unregisterSubscription(ObjectName key, boolean addToInactive) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             if (addToInactive) {
1:                 SubscriptionInfo info = new SubscriptionInfo();
1:                 info.setClientId(subscriptionKey.getClientId());
1:                 info.setSubscriptionName(subscriptionKey.getSubscriptionName());
1:                 info.setDestination(new ActiveMQTopic(view.getDestinationName()));
0:                 addInactiveSubscription(subscriptionKey, info);
1:             }
commit:af65ba7
/////////////////////////////////////////////////////////////////////////
0:             persistentMode += "Durable,subscriptionID=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getSubscriptionName());
commit:ced6909
/////////////////////////////////////////////////////////////////////////
0:             AnnotatedMBean.registerMBean(managementContext, view, key);
/////////////////////////////////////////////////////////////////////////
0:             AnnotatedMBean.registerMBean(managementContext, view, key);
/////////////////////////////////////////////////////////////////////////
0:                 AnnotatedMBean.registerMBean(managementContext, view, objectName);
author:Gary Tully
-------------------------------------------------------------------------------
commit:7d7d6fa
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createDestinationName(brokerObjectName, destName);
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createDestinationName(brokerObjectName, destName);
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createSubscriptionName(brokerObjectName, connectionClientId, sub.getConsumerInfo());
/////////////////////////////////////////////////////////////////////////
1:         ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, context.getClientId(), info);
/////////////////////////////////////////////////////////////////////////
1:         ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, context.getClientId(), info);
/////////////////////////////////////////////////////////////////////////
1:                 ObjectName objectName = BrokerMBeanSupport.createProducerName(brokerObjectName, exchange.getConnectionContext().getClientId(), info);
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createSubscriptionName(brokerObjectName, info.getClientId(), offlineConsumerInfo);
/////////////////////////////////////////////////////////////////////////
1:             objectName = BrokerMBeanSupport.createAbortSlowConsumerStrategyName(brokerObjectName, strategy);
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);
/////////////////////////////////////////////////////////////////////////
1:             ObjectName objectName = BrokerMBeanSupport.createXATransactionName(brokerObjectName, transaction);
commit:1005fc5
/////////////////////////////////////////////////////////////////////////
1:         return new ManagedTempQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
commit:2290502
/////////////////////////////////////////////////////////////////////////
1:         DestinationView view = removeAndRemember(topics, key, null);
1:         view = removeAndRemember(queues, key, view);
1:         view = removeAndRemember(temporaryQueues, key, view);
1:         view = removeAndRemember(temporaryTopics, key, view);
/////////////////////////////////////////////////////////////////////////
1:     private DestinationView removeAndRemember(Map<ObjectName, DestinationView> map, ObjectName key, DestinationView view) {
1:         return candidate != null ? candidate : view;
commit:e23b8ea
/////////////////////////////////////////////////////////////////////////
1:                 addInactiveSubscription(key, info, sub);
/////////////////////////////////////////////////////////////////////////
1:                 addInactiveSubscription(subscriptionKey, info, (brokerService.isKeepDurableSubsActive() ? view.subscription : null));
commit:caca105
/////////////////////////////////////////////////////////////////////////
0:         String objectNameStr = getSubscriptionObjectName(sub.getConsumerInfo(), connectionClientId, brokerJmxObjectName);
/////////////////////////////////////////////////////////////////////////
0:                 addInactiveSubscription(key, info, sub);
/////////////////////////////////////////////////////////////////////////
0:     public static String getSubscriptionObjectName(ConsumerInfo info, String connectionClientId, ObjectName brokerJmxObjectName) {
0:         String destinationType = "destinationType=" + info.getDestination().getDestinationTypeAsString();
0:         String destinationName = "destinationName=" + JMXSupport.encodeObjectNamePart(info.getDestination().getPhysicalName());
1:         if (info.isDurable()) {
0:             persistentMode += "Durable,subscriptionID=" + JMXSupport.encodeObjectNamePart(info.getSubscriptionName());
0:             if (info.getConsumerId() != null) {
0:                 consumerId = ",consumerId=" + JMXSupport.encodeObjectNamePart(info.getConsumerId().toString());
/////////////////////////////////////////////////////////////////////////
0:                 addInactiveSubscription(subscriptionKey, info, (brokerService.isKeepDurableSubsActive() ? view.subscription : null));
/////////////////////////////////////////////////////////////////////////
0:             addInactiveSubscription(key, info, null);
/////////////////////////////////////////////////////////////////////////
1:     protected void addInactiveSubscription(SubscriptionKey key, SubscriptionInfo info, Subscription subscription) {
1:             ConsumerInfo offlineConsumerInfo = subscription != null ? subscription.getConsumerInfo() : ((TopicRegion)getTopicRegion()).createInactiveConsumerInfo(info);
0:             ObjectName objectName = new ObjectName(getSubscriptionObjectName(offlineConsumerInfo, info.getClientId(), brokerObjectName));
0:             SubscriptionView view = new InactiveDurableSubscriptionView(this, key.getClientId(), info, subscription);
commit:1d242a2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transaction.XATransaction;
/////////////////////////////////////////////////////////////////////////
0:     protected ObjectName createObjectName(XATransaction transaction) throws MalformedObjectNameException {
0:         Hashtable map = brokerObjectName.getKeyPropertyList();
0:         ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName")
0:                                                + "," + "Type=RecoveredXaTransaction"
0:                                                + "," + "Xid="
0:                                                + JMXSupport.encodeObjectNamePart(transaction.getTransactionId().toString()));
0:         return objectName;
1:     }
1: 
1:     public void registerRecoveredTransactionMBean(XATransaction transaction) {
1:         try {
0:             ObjectName objectName = createObjectName(transaction);
1:             if (!registeredMBeans.contains(objectName))  {
1:                 RecoveredXATransactionView view = new RecoveredXATransactionView(this, transaction);
0:                 AnnotatedMBean.registerMBean(managementContext, view, objectName);
1:                 registeredMBeans.add(objectName);
1:             }
1:         } catch (Exception e) {
0:             LOG.warn("Failed to register prepared transaction MBean: " + transaction);
0:             LOG.debug("Failure reason: " + e, e);
1:         }
1:     }
1: 
1:     public void unregister(XATransaction transaction) {
1:         try {
0:             ObjectName objectName = createObjectName(transaction);
1:             if (registeredMBeans.remove(objectName)) {
1:                 try {
1:                     managementContext.unregisterMBean(objectName);
1:                 } catch (Throwable e) {
0:                     LOG.warn("Failed to unregister MBean: " + objectName);
0:                     LOG.debug("Failure reason: " + e, e);
1:                 }
1:             }
1:         } catch (Exception e) {
0:             LOG.warn("Failed to create object name to unregister " + transaction, e);
1:         }
1:     }
1: 
commit:383d12e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.AbortSlowConsumerStrategy;
0: import org.apache.activemq.broker.region.policy.SlowConsumerStrategy;
/////////////////////////////////////////////////////////////////////////
1: 
0:         DestinationView view = null;
0:         removeAndRemember(topics, key, view);
0:         removeAndRemember(queues, key, view);
0:         removeAndRemember(temporaryQueues, key, view);
0:         removeAndRemember(temporaryTopics, key, view);
/////////////////////////////////////////////////////////////////////////
1:         if (view != null) {
1:             key = view.getSlowConsumerStrategy();
1:             if (key!= null && registeredMBeans.remove(key)) {
1:                 try {
1:                     managementContext.unregisterMBean(key);
1:                 } catch (Throwable e) {
0:                     LOG.warn("Failed to unregister slow consumer strategy MBean: " + key);
0:                     LOG.debug("Failure reason: " + e, e);
1:                 }
1:             }
1:         }
1:     }
1: 
0:     private void removeAndRemember(Map<ObjectName, DestinationView> map, ObjectName key, DestinationView view) {
1:         DestinationView candidate = map.remove(key);
1:         if (candidate != null && view == null) {
1:             view = candidate;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public ObjectName registerSlowConsumerStrategy(AbortSlowConsumerStrategy strategy) throws MalformedObjectNameException {
1:         ObjectName objectName = null;
1:         try {
0:             objectName = createObjectName(strategy);
1:             if (!registeredMBeans.contains(objectName))  {
0:                 AbortSlowConsumerStrategyView view = new AbortSlowConsumerStrategyView(this, strategy);
0:                 AnnotatedMBean.registerMBean(managementContext, view, objectName);
1:                 registeredMBeans.add(objectName);
1:             }
1:         } catch (Exception e) {
0:             LOG.warn("Failed to register MBean: " + strategy);
0:             LOG.debug("Failure reason: " + e, e);
1:         }
0:         return objectName;
1:     }
1: 
0:     private ObjectName createObjectName(AbortSlowConsumerStrategy strategy) throws MalformedObjectNameException{
0:         Hashtable map = brokerObjectName.getKeyPropertyList();
0:         ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName") + ","
0:                             + "Type=SlowConsumerStrategy," + "InstanceName=" + JMXSupport.encodeObjectNamePart(strategy.getName()));
0:         return objectName;            
1:     }
1: 
1:     public ObjectName getSubscriberObjectName(Subscription key) {
1:         return subscriptionMap.get(key);
1:     }
1: 
1:     public Subscription getSubscriber(ObjectName key) {
1:         Subscription sub = null;
1:         for (Entry<Subscription, ObjectName> entry: subscriptionMap.entrySet()) {
1:             if (entry.getValue().equals(key)) {
1:                 sub = entry.getKey();
1:                 break;
1:             }
1:         }
1:         return sub;
1:     }
commit:05f82a9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.TopicRegion;
/////////////////////////////////////////////////////////////////////////
0:                 if (dest.isTopic()) {                
1:                             if (!alreadyKnown(key)) {
0:                                 LOG.debug("Restoring durable subscription mbean: " + info);
1:                                 subscriptions.put(key, info);
1:                             }
/////////////////////////////////////////////////////////////////////////
1:     private boolean alreadyKnown(SubscriptionKey key) {
1:         boolean known = false;
1:         known = ((TopicRegion) getTopicRegion()).durableSubscriptionExists(key);
0:         if (LOG.isTraceEnabled()) {
0:             LOG.trace("Sub with key: " + key + ", " + (known ? "": "not") +  " already registered");
1:         }
1:         return known;
1:     }
1: 
commit:132f662
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 public boolean isDuplicate(MessageId id) {
0:                     return false;
1:                 }
author:Robert Davies
-------------------------------------------------------------------------------
commit:c37859a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.*;
/////////////////////////////////////////////////////////////////////////
0:         String objectNameStr = brokerJmxObjectName.toString();
0:         objectNameStr += getDestinationType(info.getDestination()) + ",endpoint=Consumer";
0:         objectNameStr += ",clientId=" +  JMXSupport.encodeObjectNamePart(connectionClientId);
0:         objectNameStr += ",consumerId=";
0:         if (info.isDurable()){
0:             objectNameStr += "Durable(" +  JMXSupport.encodeObjectNamePart(connectionClientId + ":" + info.getSubscriptionName()) +")";
0:             objectNameStr += JMXSupport.encodeObjectNamePart(info.getConsumerId().toString());
/////////////////////////////////////////////////////////////////////////
0:     protected ObjectName createObjectName(ActiveMQDestination destination) throws MalformedObjectNameException {
0:         String objectNameStr = brokerObjectName.toString();
0:         objectNameStr += getDestinationType(destination);
0:         return new ObjectName(objectNameStr);
1:     }
1: 
0:     protected static String getDestinationType(ActiveMQDestination destination){
0:         String result = "";
0:         if (destination != null){
0:             result = ",destinationType="+ JMXSupport.encodeObjectNamePart(destination.getDestinationTypeAsString()) +  ",destinationName=" + JMXSupport.encodeObjectNamePart(destination.getPhysicalName());
1:         }
0:         return result;
0:         String objectNameStr = brokerObjectName.toString();
0:             objectNameStr += ",endpoint=dynamicProducer";
0:             objectNameStr += getDestinationType(producerInfo.getDestination()) + ",endpoint=Producer";
0:         objectNameStr += ",clientId=" + JMXSupport.encodeObjectNamePart(connectionClientId);
0:         objectNameStr += ",producerId=" + JMXSupport.encodeObjectNamePart(producerInfo.getProducerId().toString());
0:         return new ObjectName(objectNameStr);
/////////////////////////////////////////////////////////////////////////
0:         ObjectName objectName = new ObjectName(brokerObjectName.toString()
0:                                                + "," + "transactionType=RecoveredXaTransaction"
/////////////////////////////////////////////////////////////////////////
0:         String objectNameStr = this.brokerObjectName.toString();
0:         objectNameStr += "Service=SlowConsumerStrategy,InstanceName="+ JMXSupport.encodeObjectNamePart(strategy.getName());
0:         ObjectName objectName = new ObjectName(objectNameStr);
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
1: import java.util.Map.Entry;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CopyOnWriteArraySet;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import javax.management.InstanceNotFoundException;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
1: import javax.management.openmbean.CompositeData;
1: import javax.management.openmbean.CompositeDataSupport;
1: import javax.management.openmbean.CompositeType;
1: import javax.management.openmbean.OpenDataException;
1: import javax.management.openmbean.TabularData;
1: import javax.management.openmbean.TabularDataSupport;
1: import javax.management.openmbean.TabularType;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                DestinationFactory destinationFactory, DestinationInterceptor destinationInterceptor,Scheduler scheduler,ThreadPoolExecutor executor) throws IOException {
1:         super(brokerService, taskRunnerFactory, memoryManager, destinationFactory, destinationInterceptor,scheduler,executor);
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
0:     @Override
0:     @Override
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.Map.Entry;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArraySet;
0: import javax.management.InstanceNotFoundException;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
0: import javax.management.openmbean.CompositeData;
0: import javax.management.openmbean.CompositeDataSupport;
0: import javax.management.openmbean.CompositeType;
0: import javax.management.openmbean.OpenDataException;
0: import javax.management.openmbean.TabularData;
0: import javax.management.openmbean.TabularDataSupport;
0: import javax.management.openmbean.TabularType;
1:     private final ManagementContext managementContext;
/////////////////////////////////////////////////////////////////////////
1:     public ManagedRegionBroker(BrokerService brokerService, ManagementContext context, ObjectName brokerObjectName, TaskRunnerFactory taskRunnerFactory, SystemUsage memoryManager,
1:         this.managementContext = context;
/////////////////////////////////////////////////////////////////////////
1:                 managementContext.unregisterMBean(name);
/////////////////////////////////////////////////////////////////////////
0:             managementContext.registerMBean(view, key);
/////////////////////////////////////////////////////////////////////////
1:                 managementContext.unregisterMBean(key);
/////////////////////////////////////////////////////////////////////////
1:                             managementContext.unregisterMBean(inactiveName);
/////////////////////////////////////////////////////////////////////////
0:             managementContext.registerMBean(view, key);
/////////////////////////////////////////////////////////////////////////
1:                 managementContext.unregisterMBean(key);
/////////////////////////////////////////////////////////////////////////
0:                 managementContext.registerMBean(view, objectName);
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     public ManagedRegionBroker(BrokerService brokerService, MBeanServer mbeanServer, ObjectName brokerObjectName, TaskRunnerFactory taskRunnerFactory, SystemUsage memoryManager,
/////////////////////////////////////////////////////////////////////////
1:     protected Region createQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:     protected Region createTempQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:     protected Region createTempTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:     protected Region createTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
commit:3a5f48d
/////////////////////////////////////////////////////////////////////////
0:                 public boolean recoverMessage(Message message) throws Exception{
0:                     return true;
0:                 public boolean recoverMessageReference(MessageId messageReference) throws Exception{
commit:8068c5e
/////////////////////////////////////////////////////////////////////////
0:                             log.debug("Restoring durable subscription: "+info);
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
1: 
0:                 public boolean hasSpace(){
0:                     return true;
1:                 }
commit:a20de10
/////////////////////////////////////////////////////////////////////////
0:     public ObjectName registerSubscription(ConnectionContext context,Subscription sub){
0:         Hashtable map=brokerObjectName.getKeyPropertyList();
0:         String objectNameStr=brokerObjectName.getDomain()+":"+"BrokerName="+map.get("BrokerName")+",Type=Subscription,";
0:         String destinationType="destinationType="+sub.getConsumerInfo().getDestination().getDestinationTypeAsString();
0:         String destinationName="destinationName="
0:                 +JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getDestination().getPhysicalName());
0:         String clientId="clientId="+JMXSupport.encodeObjectNamePart(context.getClientId());
0:         String persistentMode="persistentMode=";
0:         String consumerId="";
0:         SubscriptionKey key=new SubscriptionKey(context.getClientId(),sub.getConsumerInfo().getSubcriptionName());
0:         if(sub.getConsumerInfo().isDurable()){
0:             persistentMode+="Durable, subscriptionID="
0:                     +JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getSubcriptionName());
0:         }else{
0:             persistentMode+="Non-Durable";
0:             if(sub.getConsumerInfo()!=null&&sub.getConsumerInfo().getConsumerId()!=null){
0:                 consumerId=",consumerId="
0:                         +JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getConsumerId().toString());
1:             }
0:         objectNameStr+=persistentMode+",";
0:         objectNameStr+=destinationType+",";
0:         objectNameStr+=destinationName+",";
0:         objectNameStr+=clientId;
0:         objectNameStr+=consumerId;
0:         try{
0:             ObjectName objectName=new ObjectName(objectNameStr);
0:             if(sub.getConsumerInfo().isDurable()){
0:                 view=new DurableSubscriptionView(this,context.getClientId(),sub);
0:             }else{
0:                 if(sub instanceof TopicSubscription){
0:                     view=new TopicSubscriptionView(context.getClientId(),(TopicSubscription)sub);
0:                 }else{
0:                     view=new SubscriptionView(context.getClientId(),sub);
0:             registerSubscription(objectName,sub.getConsumerInfo(),key,view);
0:             subscriptionMap.put(sub,objectName);
0:         }catch(Exception e){
0:             log.error("Failed to register subscription "+sub,e);
commit:bfaff9b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.DestinationFactory;
0: import org.apache.activemq.broker.region.DestinationFactoryImpl;
/////////////////////////////////////////////////////////////////////////
0:                     TaskRunnerFactory taskRunnerFactory,UsageManager memoryManager, DestinationFactory destinationFactory, DestinationInterceptor destinationInterceptor)
0:         super(brokerService,taskRunnerFactory,memoryManager, destinationFactory, destinationInterceptor);
/////////////////////////////////////////////////////////////////////////
0:             DestinationFactory destinationFactory){
0:         return new ManagedQueueRegion(this,destinationStatistics,memoryManager,taskRunnerFactory,destinationFactory);
0:     protected Region createTempQueueRegion(UsageManager memoryManager,TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory){
0:         return new ManagedTempQueueRegion(this,destinationStatistics,memoryManager,taskRunnerFactory, destinationFactory);
0:     protected Region createTempTopicRegion(UsageManager memoryManager,TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory){
0:         return new ManagedTempTopicRegion(this,destinationStatistics,memoryManager,taskRunnerFactory, destinationFactory);
0:             DestinationFactory destinationFactory){
0:         return new ManagedTopicRegion(this,destinationStatistics,memoryManager,taskRunnerFactory, destinationFactory);
1:         // TODO refactor to allow views for custom destinations
1:             if (destination instanceof Queue) {
0:             } else if (destination instanceof Topic){
1:             } else {
1:                 view = null;
0:                 log.warn("JMX View is not supported for custom destination: " + destination);
1:             if (view != null) {
0:                 registerDestination(objectName,destName,view);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         Set destinations=destinationFactory.getDestinations();
0:                     SubscriptionInfo[] infos= destinationFactory.getAllDurableSubscriptions((ActiveMQTopic) dest);
/////////////////////////////////////////////////////////////////////////
0:         //TODO It is very dangerous operation for big backlogs
0:         if (!(destinationFactory instanceof DestinationFactoryImpl)) {
0:             throw new RuntimeException("unsupported by " + destinationFactory);
1:         }
0:         PersistenceAdapter adapter = ((DestinationFactoryImpl)destinationFactory).getPersistenceAdapter(); 
0:             TopicMessageStore store=adapter.createTopicMessageStore(topic);
/////////////////////////////////////////////////////////////////////////
1:         
commit:2373eb2
/////////////////////////////////////////////////////////////////////////
0:         ObjectName name=(ObjectName) subscriptionMap.remove(sub);
/////////////////////////////////////////////////////////////////////////
0:                 log.error("failed to browse : " + view,e);
commit:05d271a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             name=key.toString();
0:         }else{
0:             name=sub.getConsumerInfo().getConsumerId().toString();
/////////////////////////////////////////////////////////////////////////
0:         if(registeredMBeans.remove(key)){
0:             mbeanServer.unregisterMBean(key);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if(registeredMBeans.remove(key)){
0:             mbeanServer.unregisterMBean(key);
1:         }
commit:6c0df67
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final Map subscriptionKeys=new ConcurrentHashMap();
0:     private final Map subscriptionMap=new ConcurrentHashMap();
0:     private final Set registeredMBeans=new CopyOnWriteArraySet();
0:                     TaskRunnerFactory taskRunnerFactory,UsageManager memoryManager,PersistenceAdapter adapter)
0:                     throws IOException{
1: 
0:     public void start() throws Exception{
1:         // build all existing durable subscriptions
0:     protected void doStop(ServiceStopper stopper){
0:         for(Iterator iter=registeredMBeans.iterator();iter.hasNext();){
0:             ObjectName name=(ObjectName) iter.next();
0:             try{
0:             }catch(InstanceNotFoundException e){
0:                 log.warn("The MBean: "+name+" is no longer registered with JMX");
0:             }catch(Exception e){
0:                 stopper.onException(this,e);
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName=createObjectName(destName);
0:                 view=new QueueView(this,(Queue) destination);
0:                 view=new TopicView(this,(Topic) destination);
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName=createObjectName(destName);
/////////////////////////////////////////////////////////////////////////
0:         String name="";
0:         SubscriptionKey key=new SubscriptionKey(context.getClientId(),sub.getConsumerInfo().getSubcriptionName());
0:         if(sub.getConsumerInfo().isDurable()){
0:             name=key.toString();
1:         }
0:         if(sub.getConsumerInfo()!=null&&sub.getConsumerInfo().getConsumerId()!=null){
0:             name+="."+sub.getConsumerInfo().getConsumerId();
1:         }
0:             ObjectName objectName=new ObjectName(brokerObjectName.getDomain()+":"+"BrokerName="+map.get("BrokerName")
0:                             +","+"Type=Subscription,"+"active=true,"+"name="+JMXSupport.encodeObjectNamePart(name)+"");
0:                 if(sub instanceof TopicSubscription){
0:                     view=new TopicSubscriptionView(context.getClientId(),(TopicSubscription) sub);
0:                 }else{
0:             subscriptionMap.put(sub,objectName);
/////////////////////////////////////////////////////////////////////////
0:     protected void registerSubscription(ObjectName key,ConsumerInfo info,SubscriptionKey subscriptionKey,
0:                     SubscriptionView view) throws Exception{
/////////////////////////////////////////////////////////////////////////
1:                     // unregister any inactive durable subs
0:                     try{
0:                         ObjectName inactiveName=(ObjectName) subscriptionKeys.get(subscriptionKey);
0:                         if(inactiveName!=null){
0:                         log.error("Unable to unregister inactive durable subscriber: "+subscriptionKey,e);
/////////////////////////////////////////////////////////////////////////
0:         DurableSubscriptionView view=(DurableSubscriptionView) durableTopicSubscribers.remove(key);
0:         if(view!=null){
1:             // need to put this back in the inactive list
0:             SubscriptionKey subscriptionKey=new SubscriptionKey(view.getClientId(),view.getSubscriptionName());
0:             SubscriptionInfo info=new SubscriptionInfo();
0:             addInactiveSubscription(subscriptionKey,info);
1: 
0:         Map subscriptions=new HashMap();
0:         Set destinations=adaptor.getDestinations();
0:         if(destinations!=null){
0:             for(Iterator iter=destinations.iterator();iter.hasNext();){
0:                 ActiveMQDestination dest=(ActiveMQDestination) iter.next();
0:                 if(dest.isTopic()){
0:                     TopicMessageStore store=adaptor.createTopicMessageStore((ActiveMQTopic) dest);
0:                     SubscriptionInfo[] infos=store.getAllSubscriptions();
0:                     if(infos!=null){
0:                         for(int i=0;i<infos.length;i++){
0:                             SubscriptionInfo info=infos[i];
0:                             SubscriptionKey key=new SubscriptionKey(info);
1:                         }
0:         for(Iterator i=subscriptions.entrySet().iterator();i.hasNext();){
0:             Map.Entry entry=(Entry) i.next();
0:             SubscriptionKey key=(SubscriptionKey) entry.getKey();
0:             SubscriptionInfo info=(SubscriptionInfo) entry.getValue();
0:             addInactiveSubscription(key,info);
1: 
0:             ObjectName objectName=new ObjectName(brokerObjectName.getDomain()+":"+"BrokerName="+map.get("BrokerName")
0:                             +","+"Type=Subscription,"+"active=false,"+"name="
0:                             +JMXSupport.encodeObjectNamePart(key.toString())+"");
0:             SubscriptionView view=new InactiveDurableSubscriptionView(this,key.getClientId(),info);
0:             subscriptionKeys.put(key,objectName);
1: 
0:         List messages=getSubscriberMessages(view);
/////////////////////////////////////////////////////////////////////////
0:         List messages=getSubscriberMessages(view);
/////////////////////////////////////////////////////////////////////////
1: 
0:         final List result=new ArrayList();
0:         try{
0:             ActiveMQTopic topic=new ActiveMQTopic(view.getDestinationName());
0:             TopicMessageStore store=adaptor.createTopicMessageStore(topic);
/////////////////////////////////////////////////////////////////////////
0:             log.error("Failed to browse messages for Subscription "+view,e);
1: 
0:     protected ObjectName[] getTopics(){
0:         Set set=topics.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
0:     protected ObjectName[] getQueues(){
0:         Set set=queues.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getTemporaryTopics(){
0:         Set set=temporaryTopics.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getTemporaryQueues(){
0:         Set set=temporaryQueues.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getTopicSubscribers(){
0:         Set set=topicSubscribers.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getDurableTopicSubscribers(){
0:         Set set=durableTopicSubscribers.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getQueueSubscribers(){
0:         Set set=queueSubscribers.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getTemporaryTopicSubscribers(){
0:         Set set=temporaryTopicSubscribers.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getTemporaryQueueSubscribers(){
0:         Set set=temporaryQueueSubscribers.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     protected ObjectName[] getInactiveDurableTopicSubscribers(){
0:         Set set=inactiveDurableTopicSubscribers.keySet();
0:         return (ObjectName[]) set.toArray(new ObjectName[set.size()]);
1:     }
1: 
0:     public Broker getContextBroker(){
0:     public void setContextBroker(Broker contextBroker){
0:         this.contextBroker=contextBroker;
0:     protected ObjectName createObjectName(ActiveMQDestination destName) throws MalformedObjectNameException{
0:         ObjectName objectName=new ObjectName(brokerObjectName.getDomain()+":"+"BrokerName="+map.get("BrokerName")+","
0:                         +"Type="+JMXSupport.encodeObjectNamePart(destName.getDestinationTypeAsString())+","
0:                         +"Destination="+JMXSupport.encodeObjectNamePart(destName.getPhysicalName()));
commit:cbd5960
/////////////////////////////////////////////////////////////////////////
0:         String name = key.toString() + ":" + sub.getConsumerInfo().getConsumerId().toString();
commit:6cb66e4
/////////////////////////////////////////////////////////////////////////
0:                     TaskRunnerFactory taskRunnerFactory,UsageManager memoryManager,PersistenceAdapter adapter) throws IOException{
0:         super(brokerService,taskRunnerFactory,memoryManager,adapter);
/////////////////////////////////////////////////////////////////////////
0:                     PersistenceAdapter adapter){
0:         return new ManagedQueueRegion(this,destinationStatistics,memoryManager,taskRunnerFactory,adapter);
/////////////////////////////////////////////////////////////////////////
0:                     PersistenceAdapter adapter){
0:         return new ManagedTopicRegion(this,destinationStatistics,memoryManager,taskRunnerFactory,adapter);
commit:c717221
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
0: import javax.management.openmbean.CompositeData;
0: import javax.management.openmbean.CompositeDataSupport;
0: import javax.management.openmbean.CompositeType;
0: import javax.management.openmbean.OpenDataException;
0: import javax.management.openmbean.TabularData;
0: import javax.management.openmbean.TabularDataSupport;
0: import javax.management.openmbean.TabularType;
1: import org.apache.activemq.broker.jmx.OpenTypeSupport.OpenTypeFactory;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.Message;
0: import org.apache.activemq.store.MessageRecoveryListener;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
0:                 view=new DurableSubscriptionView(this,context.getClientId(),sub);
/////////////////////////////////////////////////////////////////////////
0:             SubscriptionView view = new InactiveDurableSubscriptionView(this,key.getClientId(),info);
/////////////////////////////////////////////////////////////////////////
0:     public CompositeData[] browse(SubscriptionView view) throws OpenDataException{
0:         List messages = getSubscriberMessages(view);
0:         CompositeData c[]=new CompositeData[messages.size()];
0:         for(int i=0;i<c.length;i++){
0:             try{
0:                 c[i]=OpenTypeSupport.convert((Message) messages.get(i));
0:             }catch(Throwable e){
0:                 e.printStackTrace();
1:             }
1:         }
1:         return c;
1:     }
1: 
0:     public TabularData browseAsTable(SubscriptionView view) throws OpenDataException{
0:         OpenTypeFactory factory=OpenTypeSupport.getFactory(ActiveMQMessage.class);
0:         List messages = getSubscriberMessages(view);
0:         CompositeType ct=factory.getCompositeType();
0:         TabularType tt=new TabularType("MessageList","MessageList",ct,new String[] { "JMSMessageID" });
0:         TabularDataSupport rc=new TabularDataSupport(tt);
0:         for(int i=0;i<messages.size();i++){
0:             rc.put(new CompositeDataSupport(ct,factory.getFields(messages.get(i))));
1:         }
1:         return rc;
1:     }
1:     
0:     protected List getSubscriberMessages(SubscriptionView view){
0:         final List result = new ArrayList();
1:         try {
0:         ActiveMQTopic  topic = new ActiveMQTopic(view.getDestinationName());
0:         TopicMessageStore store = adaptor.createTopicMessageStore(topic);
1:        
1:        
0:             store.recover(new MessageRecoveryListener(){
0:                 public void recoverMessage(Message message) throws Throwable{
0:                     result.add(message);
1:                 }
1: 
0:                 public void recoverMessageReference(String messageReference) throws Throwable{}
1: 
0:                 public void finished(){}
0:             });
0:         }catch(Throwable e){
0:             log.error("Failed to browse messages for Subscription " + view,e);
1:         }
0:         return result;
1:     }
1:     
commit:2eae054
/////////////////////////////////////////////////////////////////////////
commit:c82f6f3
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.Map.Entry;
1: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.broker.region.DurableTopicSubscription;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.SubscriptionInfo;
0: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.util.SubscriptionKey;
/////////////////////////////////////////////////////////////////////////
0:     private final Map inactiveDurableTopicSubscribers=new ConcurrentHashMap();
0:     private final Map subscriptionKeys = new ConcurrentHashMap();
0:     private final Map subscriptionMap = new ConcurrentHashMap();
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void start() throws Exception {
1:         super.start();
0:         //build all existing durable subscriptions
1:         buildExistingSubscriptions();
1:         
1:     }
/////////////////////////////////////////////////////////////////////////
0:     public void registerSubscription(ConnectionContext context,Subscription sub){
0:        // NEED CONTEXT TO GET CLIENT ID AND USE Subscription KEY!!!
0:         SubscriptionKey key = new SubscriptionKey(context.getClientId(),sub.getConsumerInfo().getSubcriptionName());
0:         String name = key.toString() + ":" + sub.getConsumerInfo().toString();
0:         map.put("name",JMXSupport.encodeObjectNamePart(name));
0:         map.put("active", "true");
0:                 view=new DurableSubscriptionView(context.getClientId(),sub);
0:                 view=new SubscriptionView(context.getClientId(),sub);
0:             subscriptionMap.put(sub,objectName);
0:             registerSubscription(objectName,sub.getConsumerInfo(),key,view);
0:         ObjectName name=(ObjectName) subscriptionMap.get(sub);
0:         if(name!=null){
0:             try{
0:                 unregisterSubscription(name);
0:             }catch(Exception e){
0:                 log.error("Failed to unregister subscription "+sub,e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:     protected void registerSubscription(ObjectName key,ConsumerInfo info,SubscriptionKey subscriptionKey,SubscriptionView view) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:                     //unregister any inactive durable subs
1:                     try {
0:                         ObjectName inactiveName = (ObjectName) subscriptionKeys.get(subscriptionKey);
0:                         if (inactiveName != null){
1:                             inactiveDurableTopicSubscribers.remove(inactiveName);
0:                             mbeanServer.unregisterMBean(inactiveName);
1:                         }
0:                     }catch(Exception e){
0:                         log.error("Unable to unregister inactive durable subscriber: " + subscriptionKey,e);
1:                     }
/////////////////////////////////////////////////////////////////////////
0:         inactiveDurableTopicSubscribers.remove(key);
0:         DurableSubscriptionView view = (DurableSubscriptionView) durableTopicSubscribers.remove(key);
0:         if (view != null){
0:             //need to put this back in the inactive list
0:             SubscriptionKey subscriptionKey = new SubscriptionKey(view.getClientId(),view.getSubscriptionName());
0:             SubscriptionInfo info = new SubscriptionInfo();
0:             info.setClientId(subscriptionKey.getClientId());
0:             info.setSubcriptionName(subscriptionKey.getSubscriptionName());
0:             info.setDestination(new ActiveMQTopic(view.getDestinationName()));
0:             addInactiveSubscription(subscriptionKey, info);
1:         }
1:         
1:        
1:     }
1:     
0:     protected void buildExistingSubscriptions() throws Exception{
0:         Map subscriptions = new HashMap();
0:         Set destinations = adaptor.getDestinations();
0:         if (destinations != null){
0:             for (Iterator iter = destinations.iterator(); iter.hasNext();){
0:                 ActiveMQDestination dest = (ActiveMQDestination) iter.next();
0:                 if (dest.isTopic()){
0:                     TopicMessageStore store = adaptor.createTopicMessageStore((ActiveMQTopic) dest);
0:                     SubscriptionInfo[] infos = store.getAllSubscriptions();
0:                     if (infos != null){
1:                         for (int i = 0; i < infos.length; i++) {
1:                             
1:                             SubscriptionInfo info = infos[i];
0:                             log.debug("Restoring durable subscription: "+infos);
1:                             SubscriptionKey key = new SubscriptionKey(info);
0:                             subscriptions.put(key,info);
1:                         }   
1:                     }
1:                 }
1:             }
1:         }
0:         for (Iterator i = subscriptions.entrySet().iterator();i.hasNext();){
0:             Map.Entry entry = (Entry) i.next();
0:             SubscriptionKey key = (SubscriptionKey) entry.getKey();
0:             SubscriptionInfo info = (SubscriptionInfo) entry.getValue();
0:             addInactiveSubscription(key, info);
1:         }
1:     }
1:     
0:     protected void addInactiveSubscription(SubscriptionKey key,SubscriptionInfo info){
0:         Hashtable map=new Hashtable(brokerObjectName.getKeyPropertyList());
0:         map.put("Type",JMXSupport.encodeObjectNamePart("Subscription"));
0:         map.put("name",JMXSupport.encodeObjectNamePart(key.toString()));
0:         map.put("active", "false");
0:         try{
0:             ObjectName objectName=new ObjectName(brokerObjectName.getDomain(),map);
0:             SubscriptionView view = new InactiveDurableSubscriptionView(key.getClientId(),info);
0:             mbeanServer.registerMBean(view,objectName);
0:             inactiveDurableTopicSubscribers.put(objectName,view);
1:             subscriptionKeys.put(key, objectName);
0:         }catch(Exception e){
0:             log.error("Failed to register subscription "+info,e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected ObjectName[] getInactiveDurableTopicSubscribers(){
0:         Set set = inactiveDurableTopicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
commit:3601e81
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
0:  * the License. You may obtain a copy of the License at
1:  * 
1:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: import java.io.IOException;
0: import java.util.Hashtable;
0: import java.util.Map;
0: import java.util.Set;
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: public class ManagedRegionBroker extends RegionBroker{
0:     private static final Log log=LogFactory.getLog(ManagedRegionBroker.class);
0:     private final Map topics=new ConcurrentHashMap();
0:     private final Map queues=new ConcurrentHashMap();
0:     private final Map temporaryQueues=new ConcurrentHashMap();
0:     private final Map temporaryTopics=new ConcurrentHashMap();
0:     private final Map queueSubscribers=new ConcurrentHashMap();
0:     private final Map topicSubscribers=new ConcurrentHashMap();
0:     private final Map durableTopicSubscribers=new ConcurrentHashMap();
0:     private final Map temporaryQueueSubscribers=new ConcurrentHashMap();
0:     private final Map temporaryTopicSubscribers=new ConcurrentHashMap();
0:     public ManagedRegionBroker(BrokerService brokerService,MBeanServer mbeanServer,ObjectName brokerObjectName,
0:                     TaskRunnerFactory taskRunnerFactory,UsageManager memoryManager,PersistenceAdapter adapter,
0:                     PolicyMap policyMap) throws IOException{
0:         super(brokerService,taskRunnerFactory,memoryManager,adapter,policyMap);
0:         this.mbeanServer=mbeanServer;
0:         this.brokerObjectName=brokerObjectName;
0:     protected Region createQueueRegion(UsageManager memoryManager,TaskRunnerFactory taskRunnerFactory,
0:                     PersistenceAdapter adapter,PolicyMap policyMap){
0:         return new ManagedQueueRegion(this,destinationStatistics,memoryManager,taskRunnerFactory,adapter,policyMap);
0:     protected Region createTempQueueRegion(UsageManager memoryManager,TaskRunnerFactory taskRunnerFactory){
0:         return new ManagedTempQueueRegion(this,destinationStatistics,memoryManager,taskRunnerFactory);
1:     }
0: 
0:     protected Region createTempTopicRegion(UsageManager memoryManager,TaskRunnerFactory taskRunnerFactory){
0:         return new ManagedTempTopicRegion(this,destinationStatistics,memoryManager,taskRunnerFactory);
1:     }
0: 
0:     protected Region createTopicRegion(UsageManager memoryManager,TaskRunnerFactory taskRunnerFactory,
0:                     PersistenceAdapter adapter,PolicyMap policyMap){
0:         return new ManagedTopicRegion(this,destinationStatistics,memoryManager,taskRunnerFactory,adapter,policyMap);
1:     }
0: 
0:     public void register(ActiveMQDestination destName,Destination destination){
0:         Hashtable map=new Hashtable(brokerObjectName.getKeyPropertyList());
0:         map.put("Destination",JMXSupport.encodeObjectNamePart(destName.getPhysicalName()));
0:         try{
0:             ObjectName destObjectName=new ObjectName(brokerObjectName.getDomain(),map);
1:             DestinationView view;
0:             if(destination instanceof Queue){
0:                 view=new QueueView((Queue) destination);
0:             }else{
0:                 view=new TopicView((Topic) destination);
1:             }
0:             registerDestination(destObjectName,destName,view);
0:         }catch(Exception e){
0:             log.error("Failed to register destination "+destName,e);
0:     public void unregister(ActiveMQDestination destName){
0:         Hashtable map=new Hashtable(brokerObjectName.getKeyPropertyList());
0:         map.put("Destination",JMXSupport.encodeObjectNamePart(destName.getPhysicalName()));
0:         try{
0:             ObjectName destObjectName=new ObjectName(brokerObjectName.getDomain(),map);
0:             unregisterDestination(destObjectName);
0:         }catch(Exception e){
0:             log.error("Failed to unregister "+destName,e);
1:         }
0:     public void registerSubscription(Subscription sub){
0:         Hashtable map=new Hashtable(brokerObjectName.getKeyPropertyList());
0:         map.put("Type",JMXSupport.encodeObjectNamePart("Subscription"));
0:         map.put("name",JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().toString()));
0:         try{
0:             ObjectName objectName=new ObjectName(brokerObjectName.getDomain(),map);
1:             SubscriptionView view;
0:             if(sub.getConsumerInfo().isDurable()){
0:                 view=new DurableSubscriptionView(sub);
0:             }else{
0:                 view=new SubscriptionView(sub);
1:             }
0:             registerSubscription(objectName,sub.getConsumerInfo(),view);
0:         }catch(Exception e){
0:             log.error("Failed to register subscription "+sub,e);
1:         }
0:     public void unregisterSubscription(Subscription sub){
0:         Hashtable map=new Hashtable(brokerObjectName.getKeyPropertyList());
0:         map.put("Type",JMXSupport.encodeObjectNamePart("Subscription"));
0:         map.put("name",JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().toString()));
0:         try{
0:             ObjectName objectName=new ObjectName(brokerObjectName.getDomain(),map);
0:             unregisterSubscription(objectName);
0:         }catch(Exception e){
0:             log.error("Failed to unregister subscription "+sub,e);
1:         }
1:     }
0: 
0:     protected void registerDestination(ObjectName key,ActiveMQDestination dest,DestinationView view) throws Exception{
0:         if(dest.isQueue()){
0:             if(dest.isTemporary()){
0:                 temporaryQueues.put(key,view);
0:             }else{
0:                 queues.put(key,view);
1:             }
0:         }else{
0:             if(dest.isTemporary()){
0:                 temporaryTopics.put(key,view);
0:             }else{
0:                 topics.put(key,view);
1:             }
1:         }
0:         mbeanServer.registerMBean(view,key);
1:     }
0: 
0:     protected void unregisterDestination(ObjectName key) throws Exception{
0:         topics.remove(key);
0:         queues.remove(key);
0:         temporaryQueues.remove(key);
0:         temporaryTopics.remove(key);
0:         mbeanServer.unregisterMBean(key);
1:     }
0: 
0:     protected void registerSubscription(ObjectName key,ConsumerInfo info,SubscriptionView view) throws Exception{
0:         ActiveMQDestination dest=info.getDestination();
0:         if(dest.isQueue()){
0:             if(dest.isTemporary()){
0:                 temporaryQueueSubscribers.put(key,view);
0:             }else{
0:                 queueSubscribers.put(key,view);
1:             }
0:         }else{
0:             if(dest.isTemporary()){
0:                 temporaryTopicSubscribers.put(key,view);
0:             }else{
0:                 if(info.isDurable()){
0:                     durableTopicSubscribers.put(key,view);
0:                 }else{
0:                     topicSubscribers.put(key,view);
1:                 }
1:             }
1:         }
0:         mbeanServer.registerMBean(view,key);
1:     }
0: 
0:     protected void unregisterSubscription(ObjectName key) throws Exception{
1:         queueSubscribers.remove(key);
1:         topicSubscribers.remove(key);
0:         durableTopicSubscribers.remove(key);
1:         temporaryQueueSubscribers.remove(key);
1:         temporaryTopicSubscribers.remove(key);
0:         mbeanServer.unregisterMBean(key);
1:     }
0:     
0:     protected  ObjectName[] getTopics(){
0:         Set set = topics.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     protected ObjectName[] getQueues(){
0:         Set set = queues.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     protected ObjectName[] getTemporaryTopics(){
0:         Set set = temporaryTopics.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     protected ObjectName[] getTemporaryQueues(){
0:         Set set = temporaryQueues.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     
0:     protected ObjectName[] getTopicSubscribers(){
0:         Set set = topicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     protected ObjectName[] getDurableTopicSubscribers(){
0:         Set set = durableTopicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     protected ObjectName[] getQueueSubscribers(){
0:         Set set = queueSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     protected ObjectName[] getTemporaryTopicSubscribers(){
0:         Set set = temporaryTopicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     }
0:     protected ObjectName[] getTemporaryQueueSubscribers(){
0:         Set set = temporaryQueueSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
commit:4098942
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
0:     public ManagedRegionBroker(BrokerService brokerService,MBeanServer mbeanServer, ObjectName brokerObjectName, TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, PersistenceAdapter adapter, PolicyMap policyMap) throws IOException {
0:         super(brokerService,taskRunnerFactory, memoryManager, adapter, policyMap);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:13829ef
/////////////////////////////////////////////////////////////////////////
0:         return new ManagedTempQueueRegion(this, brokerService, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:             info.setSubscriptionName(subscriptionKey.getSubscriptionName());
/////////////////////////////////////////////////////////////////////////
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ObjectName, DestinationView> topics = new ConcurrentHashMap<ObjectName, DestinationView>();
1:     private final Map<ObjectName, DestinationView> queues = new ConcurrentHashMap<ObjectName, DestinationView>();
1:     private final Map<ObjectName, DestinationView> temporaryQueues = new ConcurrentHashMap<ObjectName, DestinationView>();
1:     private final Map<ObjectName, DestinationView> temporaryTopics = new ConcurrentHashMap<ObjectName, DestinationView>();
1:     private final Map<ObjectName, SubscriptionView> queueSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:     private final Map<ObjectName, SubscriptionView> topicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:     private final Map<ObjectName, SubscriptionView> durableTopicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:     private final Map<ObjectName, SubscriptionView> inactiveDurableTopicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:     private final Map<ObjectName, SubscriptionView> temporaryQueueSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:     private final Map<ObjectName, SubscriptionView> temporaryTopicSubscribers = new ConcurrentHashMap<ObjectName, SubscriptionView>();
1:     private final Map<SubscriptionKey, ObjectName> subscriptionKeys = new ConcurrentHashMap<SubscriptionKey, ObjectName>();
1:     private final Map<Subscription, ObjectName> subscriptionMap = new ConcurrentHashMap<Subscription, ObjectName>();
1:     private final Set<ObjectName> registeredMBeans = new CopyOnWriteArraySet<ObjectName>();
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ObjectName> iter = registeredMBeans.iterator(); iter.hasNext();) {
1:             ObjectName name = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         ObjectName name = subscriptionMap.remove(sub);
/////////////////////////////////////////////////////////////////////////
0:                         ObjectName inactiveName = subscriptionKeys.get(subscriptionKey);
/////////////////////////////////////////////////////////////////////////
1:         Map<SubscriptionKey, SubscriptionInfo> subscriptions = new HashMap<SubscriptionKey, SubscriptionInfo>();
/////////////////////////////////////////////////////////////////////////
0:         List<Message> messages = getSubscriberMessages(view);
0:                 c[i] = OpenTypeSupport.convert(messages.get(i));
/////////////////////////////////////////////////////////////////////////
0:         List<Message> messages = getSubscriberMessages(view);
/////////////////////////////////////////////////////////////////////////
0:     protected List<Message> getSubscriberMessages(SubscriptionView view) {
0:         final List<Message> result = new ArrayList<Message>();
/////////////////////////////////////////////////////////////////////////
1:         Set<ObjectName> set = topics.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = queues.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = temporaryTopics.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = temporaryQueues.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = topicSubscribers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = durableTopicSubscribers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = queueSubscribers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = temporaryTopicSubscribers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = temporaryQueueSubscribers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
1:         Set<ObjectName> set = inactiveDurableTopicSubscribers.keySet();
1:         return set.toArray(new ObjectName[set.size()]);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(ManagedRegionBroker.class);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("The MBean: " + name + " is no longer registered with JMX");
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("JMX View is not supported for custom destination: " + destination);
0:             LOG.error("Failed to register destination " + destName, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to unregister " + destName, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to register subscription " + sub, e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Failed to unregister subscription " + sub, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to register MBean: " + key);
0:             LOG.debug("Failure reason: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Failed to unregister MBean: " + key);
0:                 LOG.debug("Failure reason: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.error("Unable to unregister inactive durable subscriber: " + subscriptionKey, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to register MBean: " + key);
0:             LOG.debug("Failure reason: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Failed to unregister MBean: " + key);
0:                 LOG.debug("Failure reason: " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("Restoring durable subscription: " + info);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Failed to register MBean: " + key);
0:                 LOG.debug("Failure reason: " + e, e);
0:             LOG.error("Failed to register subscription " + info, e);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("failed to browse : " + view, e);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Failed to browse messages for Subscription " + view, e);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:     public ManagedRegionBroker(BrokerService brokerService, MBeanServer mbeanServer, ObjectName brokerObjectName, TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager,
0:                                DestinationFactory destinationFactory, DestinationInterceptor destinationInterceptor) throws IOException {
0:         super(brokerService, taskRunnerFactory, memoryManager, destinationFactory, destinationInterceptor);
0:         this.mbeanServer = mbeanServer;
1:         this.brokerObjectName = brokerObjectName;
0:     public void start() throws Exception {
1:     protected void doStop(ServiceStopper stopper) {
0:         for (Iterator iter = registeredMBeans.iterator(); iter.hasNext();) {
0:             ObjectName name = (ObjectName)iter.next();
1:             try {
1:             } catch (InstanceNotFoundException e) {
0:                 log.warn("The MBean: " + name + " is no longer registered with JMX");
1:             } catch (Exception e) {
1:                 stopper.onException(this, e);
0:     protected Region createQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:         return new ManagedQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
0:     protected Region createTempQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
0:         return new ManagedTempQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
0:     protected Region createTempTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:         return new ManagedTempTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
0:     protected Region createTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:         return new ManagedTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:     public void register(ActiveMQDestination destName, Destination destination) {
1:         try {
0:             ObjectName objectName = createObjectName(destName);
1:                 view = new QueueView(this, (Queue)destination);
1:             } else if (destination instanceof Topic) {
1:                 view = new TopicView(this, (Topic)destination);
1:                 registerDestination(objectName, destName, view);
1:         } catch (Exception e) {
0:             log.error("Failed to register destination " + destName, e);
1:     public void unregister(ActiveMQDestination destName) {
1:         try {
0:             ObjectName objectName = createObjectName(destName);
1:         } catch (Exception e) {
0:             log.error("Failed to unregister " + destName, e);
1:     public ObjectName registerSubscription(ConnectionContext context, Subscription sub) {
0:         Hashtable map = brokerObjectName.getKeyPropertyList();
0:         String objectNameStr = brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName") + ",Type=Subscription,";
0:         String destinationType = "destinationType=" + sub.getConsumerInfo().getDestination().getDestinationTypeAsString();
0:         String destinationName = "destinationName=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getDestination().getPhysicalName());
0:         String clientId = "clientId=" + JMXSupport.encodeObjectNamePart(context.getClientId());
0:         String persistentMode = "persistentMode=";
0:         String consumerId = "";
1:         SubscriptionKey key = new SubscriptionKey(context.getClientId(), sub.getConsumerInfo().getSubscriptionName());
0:         if (sub.getConsumerInfo().isDurable()) {
0:             persistentMode += "Durable, subscriptionID=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getSubscriptionName());
1:         } else {
0:             persistentMode += "Non-Durable";
0:             if (sub.getConsumerInfo() != null && sub.getConsumerInfo().getConsumerId() != null) {
0:                 consumerId = ",consumerId=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getConsumerId().toString());
0:         objectNameStr += persistentMode + ",";
0:         objectNameStr += destinationType + ",";
0:         objectNameStr += destinationName + ",";
0:         objectNameStr += clientId;
0:         objectNameStr += consumerId;
1:         try {
0:             ObjectName objectName = new ObjectName(objectNameStr);
0:             if (sub.getConsumerInfo().isDurable()) {
0:                 view = new DurableSubscriptionView(this, context.getClientId(), sub);
1:             } else {
0:                 if (sub instanceof TopicSubscription) {
0:                     view = new TopicSubscriptionView(context.getClientId(), (TopicSubscription)sub);
1:                 } else {
0:                     view = new SubscriptionView(context.getClientId(), sub);
0:             registerSubscription(objectName, sub.getConsumerInfo(), key, view);
1:             subscriptionMap.put(sub, objectName);
1:         } catch (Exception e) {
0:             log.error("Failed to register subscription " + sub, e);
1:     public void unregisterSubscription(Subscription sub) {
0:         ObjectName name = (ObjectName)subscriptionMap.remove(sub);
1:         if (name != null) {
1:             try {
1:             } catch (Exception e) {
0:                 log.error("Failed to unregister subscription " + sub, e);
1:     protected void registerDestination(ObjectName key, ActiveMQDestination dest, DestinationView view) throws Exception {
1:         if (dest.isQueue()) {
1:             if (dest.isTemporary()) {
1:                 temporaryQueues.put(key, view);
1:             } else {
1:                 queues.put(key, view);
1:         } else {
1:             if (dest.isTemporary()) {
1:                 temporaryTopics.put(key, view);
1:             } else {
1:                 topics.put(key, view);
0:             mbeanServer.registerMBean(view, key);
0:             log.warn("Failed to register MBean: " + key);
0:             log.debug("Failure reason: " + e, e);
0:         }
1:     protected void unregisterDestination(ObjectName key) throws Exception {
1:         if (registeredMBeans.remove(key)) {
0:                 mbeanServer.unregisterMBean(key);
0:                 log.warn("Failed to unregister MBean: " + key);
0:                 log.debug("Failure reason: " + e, e);
0:             }
1:     protected void registerSubscription(ObjectName key, ConsumerInfo info, SubscriptionKey subscriptionKey, SubscriptionView view) throws Exception {
1:         ActiveMQDestination dest = info.getDestination();
1:         if (dest.isQueue()) {
1:             if (dest.isTemporary()) {
1:                 temporaryQueueSubscribers.put(key, view);
1:             } else {
1:                 queueSubscribers.put(key, view);
1:         } else {
1:             if (dest.isTemporary()) {
1:                 temporaryTopicSubscribers.put(key, view);
1:             } else {
0:                 if (info.isDurable()) {
1:                     durableTopicSubscribers.put(key, view);
1:                     try {
0:                         ObjectName inactiveName = (ObjectName)subscriptionKeys.get(subscriptionKey);
1:                         if (inactiveName != null) {
1:                     } catch (Throwable e) {
0:                         log.error("Unable to unregister inactive durable subscriber: " + subscriptionKey, e);
1:                 } else {
1:                     topicSubscribers.put(key, view);
0: 
0:             mbeanServer.registerMBean(view, key);
0:             log.warn("Failed to register MBean: " + key);
0:             log.debug("Failure reason: " + e, e);
0: 
0:     protected void unregisterSubscription(ObjectName key) throws Exception {
1:         if (registeredMBeans.remove(key)) {
0:                 log.warn("Failed to unregister MBean: " + key);
0:                 log.debug("Failure reason: " + e, e);
1:         DurableSubscriptionView view = (DurableSubscriptionView)durableTopicSubscribers.remove(key);
1:         if (view != null) {
1:             SubscriptionKey subscriptionKey = new SubscriptionKey(view.getClientId(), view.getSubscriptionName());
0:             SubscriptionInfo info = new SubscriptionInfo();
0:             addInactiveSubscription(subscriptionKey, info);
1:     protected void buildExistingSubscriptions() throws Exception {
0:         Map subscriptions = new HashMap();
0:         Set destinations = destinationFactory.getDestinations();
1:         if (destinations != null) {
0:             for (Iterator iter = destinations.iterator(); iter.hasNext();) {
0:                 ActiveMQDestination dest = (ActiveMQDestination)iter.next();
0:                 if (dest.isTopic()) {
1:                     SubscriptionInfo[] infos = destinationFactory.getAllDurableSubscriptions((ActiveMQTopic)dest);
1:                     if (infos != null) {
0:                         for (int i = 0; i < infos.length; i++) {
0:                             SubscriptionInfo info = infos[i];
0:                             log.debug("Restoring durable subscription: " + info);
0:                             SubscriptionKey key = new SubscriptionKey(info);
0:                             subscriptions.put(key, info);
0:         for (Iterator i = subscriptions.entrySet().iterator(); i.hasNext();) {
0:             Map.Entry entry = (Entry)i.next();
0:             SubscriptionKey key = (SubscriptionKey)entry.getKey();
0:             SubscriptionInfo info = (SubscriptionInfo)entry.getValue();
0:             addInactiveSubscription(key, info);
0:     protected void addInactiveSubscription(SubscriptionKey key, SubscriptionInfo info) {
0:         Hashtable map = brokerObjectName.getKeyPropertyList();
1:         try {
0:             ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName") + "," + "Type=Subscription," + "active=false,"
0:                                                    + "name=" + JMXSupport.encodeObjectNamePart(key.toString()) + "");
0:             SubscriptionView view = new InactiveDurableSubscriptionView(this, key.getClientId(), info);
0: 
0:                 mbeanServer.registerMBean(view, objectName);
0:                 log.warn("Failed to register MBean: " + key);
0:                 log.debug("Failure reason: " + e, e);
0:             }
0: 
1:             inactiveDurableTopicSubscribers.put(objectName, view);
0:             subscriptionKeys.put(key, objectName);
1:         } catch (Exception e) {
0:             log.error("Failed to register subscription " + info, e);
1:     public CompositeData[] browse(SubscriptionView view) throws OpenDataException {
0:         List messages = getSubscriberMessages(view);
0:         CompositeData c[] = new CompositeData[messages.size()];
1:         for (int i = 0; i < c.length; i++) {
1:             try {
0:                 c[i] = OpenTypeSupport.convert((Message)messages.get(i));
1:             } catch (Throwable e) {
0:                 log.error("failed to browse : " + view, e);
1:     public TabularData browseAsTable(SubscriptionView view) throws OpenDataException {
1:         OpenTypeFactory factory = OpenTypeSupport.getFactory(ActiveMQMessage.class);
0:         List messages = getSubscriberMessages(view);
1:         CompositeType ct = factory.getCompositeType();
1:         TabularType tt = new TabularType("MessageList", "MessageList", ct, new String[] {"JMSMessageID"});
1:         TabularDataSupport rc = new TabularDataSupport(tt);
0:         for (int i = 0; i < messages.size(); i++) {
0:             rc.put(new CompositeDataSupport(ct, factory.getFields(messages.get(i))));
0:     protected List getSubscriberMessages(SubscriptionView view) {
0:         // TODO It is very dangerous operation for big backlogs
0:         PersistenceAdapter adapter = ((DestinationFactoryImpl)destinationFactory).getPersistenceAdapter();
0:         final List result = new ArrayList();
1:         try {
0:             ActiveMQTopic topic = new ActiveMQTopic(view.getDestinationName());
0:             TopicMessageStore store = adapter.createTopicMessageStore(topic);
0:             store.recover(new MessageRecoveryListener() {
0:                 public boolean recoverMessage(Message message) throws Exception {
0:                 public boolean recoverMessageReference(MessageId messageReference) throws Exception {
0:                     throw new RuntimeException("Should not be called.");
0:                 public void finished() {
0:                 }
0:                 public boolean hasSpace() {
1:         } catch (Throwable e) {
0:             log.error("Failed to browse messages for Subscription " + view, e);
0: 
1:     protected ObjectName[] getTopics() {
0:         Set set = topics.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getQueues() {
0:         Set set = queues.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getTemporaryTopics() {
0:         Set set = temporaryTopics.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getTemporaryQueues() {
0:         Set set = temporaryQueues.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getTopicSubscribers() {
0:         Set set = topicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getDurableTopicSubscribers() {
0:         Set set = durableTopicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getQueueSubscribers() {
0:         Set set = queueSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getTemporaryTopicSubscribers() {
0:         Set set = temporaryTopicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getTemporaryQueueSubscribers() {
0:         Set set = temporaryQueueSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     protected ObjectName[] getInactiveDurableTopicSubscribers() {
0:         Set set = inactiveDurableTopicSubscribers.keySet();
0:         return (ObjectName[])set.toArray(new ObjectName[set.size()]);
1:     public Broker getContextBroker() {
1:     public void setContextBroker(Broker contextBroker) {
1:         this.contextBroker = contextBroker;
0:     protected ObjectName createObjectName(ActiveMQDestination destName) throws MalformedObjectNameException {
0:         Hashtable map = brokerObjectName.getKeyPropertyList();
0:         ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName") + "," + "Type="
0:                                                + JMXSupport.encodeObjectNamePart(destName.getDestinationTypeAsString()) + "," + "Destination="
0:                                                + JMXSupport.encodeObjectNamePart(destName.getPhysicalName()));
commit:0afb7f9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
0:                 public void recoverMessageReference(MessageId messageReference) throws Exception{
0:                 	throw new RuntimeException("Should not be called.");
0:                 }
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArraySet;
commit:cafe4cb
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             mbeanServer.registerMBean(view,key);
1:             registeredMBeans.add(key);
1:         } catch (Throwable e) {
0:             log.warn("Failed to register MBean: "+key);
0:             log.debug("Failure reason: "+e,e);
0:         }            
/////////////////////////////////////////////////////////////////////////
1:             try {
0:         		mbeanServer.unregisterMBean(key);
1:             } catch (Throwable e) {
0:                 log.warn("Failed to unregister MBean: "+key);
0:                 log.debug("Failure reason: "+e,e);
0:             }            
/////////////////////////////////////////////////////////////////////////
0:                     }catch(Throwable e){
/////////////////////////////////////////////////////////////////////////
0:         
0:         try {
0:             mbeanServer.registerMBean(view,key);
1:             registeredMBeans.add(key);
1:         } catch (Throwable e) {
0:             log.warn("Failed to register MBean: "+key);
0:             log.debug("Failure reason: "+e,e);
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 mbeanServer.unregisterMBean(key);
1:             } catch (Throwable e) {
0:                 log.warn("Failed to unregister MBean: "+key);
0:                 log.debug("Failure reason: "+e,e);
0:             }
/////////////////////////////////////////////////////////////////////////
0:             
0:             try {
0:                 mbeanServer.registerMBean(view,objectName);
1:                 registeredMBeans.add(objectName);
0:             } catch (Throwable e) {
0:                 log.warn("Failed to register MBean: "+key);
0:                 log.debug("Failure reason: "+e,e);
0:             }            
0:             
commit:333158a
/////////////////////////////////////////////////////////////////////////
0:         SubscriptionKey key=new SubscriptionKey(context.getClientId(),sub.getConsumerInfo().getSubscriptionName());
0:                     +JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getSubscriptionName());
commit:44aece5
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         
0:             persistentMode = "Durable, subscriptionID=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getSubcriptionName());
/////////////////////////////////////////////////////////////////////////
0:         	ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName")
0:                         + "," + "Type=Subscription, persistentMode=" + persistentMode + ", destinationType=" + destinationType + ", destinationName=" + JMXSupport.encodeObjectNamePart(destinationName) + ", clientID=" + JMXSupport.encodeObjectNamePart(clientID) + "");
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
0:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:18d616c
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             name = key.toString();
0:         } else {
0:             name = sub.getConsumerInfo().getConsumerId().toString();
0:         
commit:c4e99fe
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.Map.Entry;
0: 
0: import javax.management.InstanceNotFoundException;
0: import javax.management.MBeanServer;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
0: import javax.management.openmbean.CompositeData;
0: import javax.management.openmbean.CompositeDataSupport;
0: import javax.management.openmbean.CompositeType;
0: import javax.management.openmbean.OpenDataException;
0: import javax.management.openmbean.TabularData;
0: import javax.management.openmbean.TabularDataSupport;
0: import javax.management.openmbean.TabularType;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
0:         String name = key.toString();
commit:07d4e8c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Hashtable map=brokerObjectName.getKeyPropertyList();
0:         	ObjectName objectName = new ObjectName(
0:         			brokerObjectName.getDomain()+":"+
0:             		"BrokerName="+map.get("BrokerName")+","+
0:             		"Type="+JMXSupport.encodeObjectNamePart(destName.getDestinationTypeAsString())+","+
0:                     "Destination="+JMXSupport.encodeObjectNamePart(destName.getPhysicalName())
0:             		);
0:             registerDestination(objectName,destName,view);
/////////////////////////////////////////////////////////////////////////
0:         	ObjectName objectName = new ObjectName(
0:         			brokerObjectName.getDomain()+":"+
0:             		"BrokerName="+map.get("BrokerName")+","+
0:             		"Type="+JMXSupport.encodeObjectNamePart(destName.getDestinationTypeAsString())+","+
0:                     "Destination="+JMXSupport.encodeObjectNamePart(destName.getPhysicalName())
0:             		);
1:             unregisterDestination(objectName);
/////////////////////////////////////////////////////////////////////////
0:         Hashtable map=brokerObjectName.getKeyPropertyList();
0:         	
0:         	ObjectName objectName = new ObjectName(
0:         			brokerObjectName.getDomain()+":"+
0:             		"BrokerName="+map.get("BrokerName")+","+
0:             		"Type=Subscription,"+
0:             		"active=true,"+
0:                     "name="+JMXSupport.encodeObjectNamePart(name)+""
0:             		);
0: 
/////////////////////////////////////////////////////////////////////////
0:         Hashtable map=brokerObjectName.getKeyPropertyList();
0:         	ObjectName objectName = new ObjectName(
0:         			brokerObjectName.getDomain()+":"+
0:             		"BrokerName="+map.get("BrokerName")+","+
0:             		"Type=Subscription,"+
0:             		"active=false,"+
0:                     "name="+JMXSupport.encodeObjectNamePart(key.toString())+""
0:             		);
0: 
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:                 public void recoverMessage(Message message) throws Exception{
0:                 public void recoverMessageReference(String messageReference) throws Exception{}
commit:ed5d43b
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     
1:     /* This is the first broker in the broker interceptor chain. */
1:     private Broker contextBroker;
/////////////////////////////////////////////////////////////////////////
0:                 view=new QueueView(this, (Queue) destination);
0:                 view=new TopicView(this, (Topic) destination);
/////////////////////////////////////////////////////////////////////////
0: 
0:     public Broker getContextBroker() {
1:         return contextBroker;
0:     }
0: 
0:     public void setContextBroker(Broker contextBroker) {
0:         this.contextBroker = contextBroker;
0:     }
commit:e6f5d30
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.Queue;
0: import org.apache.activemq.broker.region.Subscription;
0: import org.apache.activemq.broker.region.Topic;
/////////////////////////////////////////////////////////////////////////
0:         Object view;
0:         if( destination instanceof Queue ) {
0:             view = new QueueView((Queue) destination);
0:         } else {
0:             view = new TopicView((Topic) destination);
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void registerSubscription(Subscription sub) {
0:         // TODO: Use this to expose subscriptions to the JMX bus for management
0:     }
0: 
0:     public void unregisterSubscription(Subscription sub) {
0:         // TODO: Use this to expose subscriptions to the JMX bus for management
0:     }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.jmx;
0: 
0: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.Region;
0: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.memory.UsageManager;
0: import org.apache.activemq.store.PersistenceAdapter;
1: import org.apache.activemq.thread.TaskRunnerFactory;
0: import org.apache.activemq.util.JMXSupport;
0: 
0: import javax.management.MBeanServer;
0: import javax.management.ObjectName;
0: 
0: import java.io.IOException;
0: import java.util.Hashtable;
0: 
1: public class ManagedRegionBroker extends RegionBroker {
0: 
0:     private final MBeanServer mbeanServer;
1:     private final ObjectName brokerObjectName;
0: 
0:     public ManagedRegionBroker(MBeanServer mbeanServer, ObjectName brokerObjectName, TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, PersistenceAdapter adapter, PolicyMap policyMap) throws IOException {
0:         super(taskRunnerFactory, memoryManager, adapter, policyMap);
0:         this.mbeanServer = mbeanServer;
0:         this.brokerObjectName = brokerObjectName;
0:     }
0: 
0:     protected Region createQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, PersistenceAdapter adapter, PolicyMap policyMap) {
0:         return new ManagedQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, adapter, policyMap);
0:     }
0:     
0:     protected Region createTempQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory) {
0:         return new ManagedTempQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory);
0:     }
0:     
0:     protected Region createTempTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory) {
0:         return new ManagedTempTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory);
0:     }
0:     
0:     protected Region createTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, PersistenceAdapter adapter, PolicyMap policyMap) {
0:         return new ManagedTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, adapter, policyMap);
0:     }
0: 
0:     public void register(ActiveMQDestination destName, Destination destination) throws Throwable {
0:         
0:         // Build the object name for the destination
0:         Hashtable map = new Hashtable(brokerObjectName.getKeyPropertyList());
0:         map.put("Type",JMXSupport.encodeObjectNamePart(destName.getDestinationTypeAsString()));
0:         map.put("Destination", JMXSupport.encodeObjectNamePart(destName.getPhysicalName()));
0:         ObjectName destObjectName= new ObjectName(brokerObjectName.getDomain(), map);
0:         
0:         DestinationViewMBean view = new DestinationView(destination);
0:         
0:         mbeanServer.registerMBean(view, destObjectName);        
0:     }
0: 
0:     public void unregister(ActiveMQDestination destName) throws Throwable {
0:         // Build the object name for the destination
0:         Hashtable map = new Hashtable(brokerObjectName.getKeyPropertyList());
0:         map.put("Type",JMXSupport.encodeObjectNamePart(destName.getDestinationTypeAsString()));
0:         map.put("Destination", JMXSupport.encodeObjectNamePart(destName.getPhysicalName()));
0:         ObjectName destObjectName= new ObjectName(brokerObjectName.getDomain(), map);
0:         
0:         mbeanServer.unregisterMBean(destObjectName);        
0:     }
0: }
author:James Strachan
-------------------------------------------------------------------------------
commit:947659c
/////////////////////////////////////////////////////////////////////////
1:         String connectionClientId = context.getClientId();
0:         ObjectName brokerJmxObjectName = brokerObjectName;
0:         String objectNameStr = getSubscriptionObjectName(sub, connectionClientId, brokerJmxObjectName);
0: 
/////////////////////////////////////////////////////////////////////////
0:     public static String getSubscriptionObjectName(Subscription sub, String connectionClientId, ObjectName brokerJmxObjectName) {
0:         Hashtable map = brokerJmxObjectName.getKeyPropertyList();
0:         String brokerDomain = brokerJmxObjectName.getDomain();
0:         String objectNameStr = brokerDomain + ":" + "BrokerName=" + map.get("BrokerName") + ",Type=Subscription,";
0:         String destinationType = "destinationType=" + sub.getConsumerInfo().getDestination().getDestinationTypeAsString();
0:         String destinationName = "destinationName=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getDestination().getPhysicalName());
0:         String clientId = "clientId=" + JMXSupport.encodeObjectNamePart(connectionClientId);
0:         String persistentMode = "persistentMode=";
0:         String consumerId = "";
0:         if (sub.getConsumerInfo().isDurable()) {
0:             persistentMode += "Durable, subscriptionID=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getSubscriptionName());
0:         } else {
0:             persistentMode += "Non-Durable";
0:             if (sub.getConsumerInfo() != null && sub.getConsumerInfo().getConsumerId() != null) {
0:                 consumerId = ",consumerId=" + JMXSupport.encodeObjectNamePart(sub.getConsumerInfo().getConsumerId().toString());
0:             }
0:         }
0:         objectNameStr += persistentMode + ",";
0:         objectNameStr += destinationType + ",";
0:         objectNameStr += destinationName + ",";
0:         objectNameStr += clientId;
0:         objectNameStr += consumerId;
0:         return objectNameStr;
0:     }
0: 
commit:da67a38
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.DestinationInterceptor;
/////////////////////////////////////////////////////////////////////////
0:                     TaskRunnerFactory taskRunnerFactory,UsageManager memoryManager,PersistenceAdapter adapter, DestinationInterceptor destinationInterceptor)
0:         super(brokerService,taskRunnerFactory,memoryManager,adapter, destinationInterceptor);
commit:9173284
/////////////////////////////////////////////////////////////////////////
0: 
0: public class ManagedRegionBroker extends RegionBroker {
0:     private static final Log log = LogFactory.getLog(ManagedRegionBroker.class);
0:     private final Map topics = new ConcurrentHashMap();
0:     private final Map queues = new ConcurrentHashMap();
0:     private final Map temporaryQueues = new ConcurrentHashMap();
0:     private final Map temporaryTopics = new ConcurrentHashMap();
0:     private final Map queueSubscribers = new ConcurrentHashMap();
0:     private final Map topicSubscribers = new ConcurrentHashMap();
0:     private final Map durableTopicSubscribers = new ConcurrentHashMap();
0:     private final Map inactiveDurableTopicSubscribers = new ConcurrentHashMap();
0:     private final Map temporaryQueueSubscribers = new ConcurrentHashMap();
0:     private final Map temporaryTopicSubscribers = new ConcurrentHashMap();
0:     private final Map subscriptionKeys = new ConcurrentHashMap();
0:     private final Map subscriptionMap = new ConcurrentHashMap();
0:     private final Set registeredMBeans = new CopyOnWriteArraySet();
commit:0def1d4
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     public ObjectName registerSubscription(ConnectionContext context,Subscription sub){
/////////////////////////////////////////////////////////////////////////
0:             return objectName;
1:             return null;
commit:d47ce01
/////////////////////////////////////////////////////////////////////////
0:             catch (InstanceNotFoundException e) {
0:                 log.warn("The MBean: " + name + " is no longer registered with JMX");
0:             }
commit:3cd3fd3
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceStopper;
0: import javax.management.InstanceNotFoundException;
0: import javax.management.MBeanRegistrationException;
0: import javax.management.MBeanServer;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
0: import javax.management.openmbean.CompositeData;
0: import javax.management.openmbean.CompositeDataSupport;
0: import javax.management.openmbean.CompositeType;
0: import javax.management.openmbean.OpenDataException;
0: import javax.management.openmbean.TabularData;
0: import javax.management.openmbean.TabularDataSupport;
0: import javax.management.openmbean.TabularType;
0: 
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.Map.Entry;
0: 
/////////////////////////////////////////////////////////////////////////
0:     private final Set registeredMBeans = new CopyOnWriteArraySet();
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void doStop(ServiceStopper stopper) {
1:         super.doStop(stopper);
0:         
1:         // lets remove any mbeans not yet removed
0:         for (Iterator iter = registeredMBeans.iterator(); iter.hasNext();) {
0:             ObjectName name = (ObjectName) iter.next();
0:             try {
0:                 mbeanServer.unregisterMBean(name);
0:             }
0:             catch (Exception e) {
0:                 stopper.onException(this, e);
0:             }
0:         }
1:         registeredMBeans.clear();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = createObjectName(destName);
/////////////////////////////////////////////////////////////////////////
0:             ObjectName objectName = createObjectName(destName);
/////////////////////////////////////////////////////////////////////////
0:         registeredMBeans.add(key);
/////////////////////////////////////////////////////////////////////////
0:         registeredMBeans.remove(key);
/////////////////////////////////////////////////////////////////////////
1:                             registeredMBeans.remove(inactiveName);
/////////////////////////////////////////////////////////////////////////
0:         registeredMBeans.add(key);
/////////////////////////////////////////////////////////////////////////
0:         registeredMBeans.remove(key);
/////////////////////////////////////////////////////////////////////////
0:             registeredMBeans.add(objectName);
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected ObjectName createObjectName(ActiveMQDestination destName) throws MalformedObjectNameException {
0:         // Build the object name for the destination
0:         Hashtable map=brokerObjectName.getKeyPropertyList();
0:         ObjectName objectName = new ObjectName(
0:                 brokerObjectName.getDomain()+":"+
0:                 "BrokerName="+map.get("BrokerName")+","+
0:                 "Type="+JMXSupport.encodeObjectNamePart(destName.getDestinationTypeAsString())+","+
0:                 "Destination="+JMXSupport.encodeObjectNamePart(destName.getPhysicalName())
0:                 );
0:         return objectName;
0:     }
commit:062dc56
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.TopicSubscription;
/////////////////////////////////////////////////////////////////////////
0:                 if (sub instanceof TopicSubscription) {
0:                     view = new TopicSubscriptionView(context.getClientId(),(TopicSubscription) sub);
0:                 }
0:                 else {
0:                     view=new SubscriptionView(context.getClientId(),sub);
0:                 }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:62cb1b6
/////////////////////////////////////////////////////////////////////////
0:     public ObjectName registerSubscription(ConnectionContext context, Subscription sub) {
0:         Hashtable map = brokerObjectName.getKeyPropertyList();
0:         String persistentMode = "";
0:         String destinationType = "";
0:         String destinationName = "";
0:         String clientID = "";
0:         SubscriptionKey key = new SubscriptionKey(context.getClientId(), sub.getConsumerInfo().getSubcriptionName());
0:         if (sub.getConsumerInfo().isDurable()) {
0:             persistentMode = "Durable";
0: 
0:         } else {
0:             persistentMode = "Non-Durable";
0: 
0:         destinationType = sub.getConsumerInfo().getDestination().getDestinationTypeAsString();
0:         destinationName = sub.getConsumerInfo().getDestination().getPhysicalName();
0:         clientID = context.getClientId();
0: 
0:         try {
0:             ObjectName objectName = new ObjectName(brokerObjectName.getDomain() + ":" + "BrokerName=" + map.get("BrokerName")
0:                     + "," + "Type=Subscription, persistentMode=" + persistentMode + ", destinationType=" + destinationType + " ,destinationName=" + JMXSupport.encodeObjectNamePart(destinationName) + " ,clientID=" + JMXSupport.encodeObjectNamePart(clientID) + "");
0:             if (sub.getConsumerInfo().isDurable()) {
0:                 view = new DurableSubscriptionView(this, context.getClientId(), sub);
0:             } else {
0:                 if (sub instanceof TopicSubscription) {
0:                     view = new TopicSubscriptionView(context.getClientId(), (TopicSubscription) sub);
0:                 } else {
0:                     view = new SubscriptionView(context.getClientId(), sub);
0:             registerSubscription(objectName, sub.getConsumerInfo(), key, view);
0:             subscriptionMap.put(sub, objectName);
0:         } catch (Exception e) {
0:             log.error("Failed to register subscription " + sub, e);
============================================================================