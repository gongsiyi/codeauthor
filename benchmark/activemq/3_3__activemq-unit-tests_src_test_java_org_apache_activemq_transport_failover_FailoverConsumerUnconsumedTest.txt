1:862cd71: /**
1:862cd71:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:862cd71:  * contributor license agreements.  See the NOTICE file distributed with
1:862cd71:  * this work for additional information regarding copyright ownership.
1:862cd71:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:862cd71:  * (the "License"); you may not use this file except in compliance with
1:862cd71:  * the License.  You may obtain a copy of the License at
1:862cd71:  *
1:862cd71:  *      http://www.apache.org/licenses/LICENSE-2.0
1:862cd71:  *
1:862cd71:  * Unless required by applicable law or agreed to in writing, software
1:862cd71:  * distributed under the License is distributed on an "AS IS" BASIS,
1:862cd71:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:862cd71:  * See the License for the specific language governing permissions and
1:862cd71:  * limitations under the License.
1:862cd71:  */
1:862cd71: package org.apache.activemq.transport.failover;
1:862cd71: 
1:862cd71: import static org.junit.Assert.assertTrue;
1:862cd71: 
1:862cd71: import java.util.Vector;
1:862cd71: import java.util.concurrent.CountDownLatch;
1:862cd71: import java.util.concurrent.Executors;
1:862cd71: import java.util.concurrent.TimeUnit;
1:862cd71: 
1:862cd71: import javax.jms.Destination;
1:862cd71: import javax.jms.JMSException;
1:82c4ab8: import javax.jms.Message;
1:82c4ab8: import javax.jms.MessageListener;
1:862cd71: import javax.jms.MessageProducer;
1:862cd71: import javax.jms.Queue;
1:862cd71: import javax.jms.Session;
1:862cd71: import javax.jms.TextMessage;
1:862cd71: 
1:862cd71: import org.apache.activemq.ActiveMQConnection;
1:862cd71: import org.apache.activemq.ActiveMQConnectionFactory;
1:862cd71: import org.apache.activemq.ActiveMQMessageConsumer;
1:862cd71: import org.apache.activemq.ActiveMQMessageTransformation;
1:862cd71: import org.apache.activemq.ActiveMQSession;
1:862cd71: import org.apache.activemq.broker.BrokerPlugin;
1:862cd71: import org.apache.activemq.broker.BrokerPluginSupport;
1:862cd71: import org.apache.activemq.broker.BrokerService;
1:862cd71: import org.apache.activemq.broker.ConnectionContext;
1:862cd71: import org.apache.activemq.broker.region.Subscription;
1:862cd71: import org.apache.activemq.command.ConsumerId;
1:862cd71: import org.apache.activemq.command.ConsumerInfo;
1:862cd71: import org.apache.activemq.command.SessionId;
1:862cd71: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:862cd71: import org.junit.After;
1:862cd71: import org.junit.Test;
1:862cd71: 
1:862cd71: // see https://issues.apache.org/activemq/browse/AMQ-2573
1:862cd71: public class FailoverConsumerUnconsumedTest {
1:862cd71: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(FailoverConsumerUnconsumedTest.class);
1:862cd71:     private static final String QUEUE_NAME = "FailoverWithUnconsumed";
1:883eed0:     private static final String TRANSPORT_URI = "tcp://localhost:0";
1:883eed0:     private String url;
1:862cd71:     final int prefetch = 10;
1:862cd71:     BrokerService broker;
1:862cd71: 
1:862cd71:     @After
1:862cd71:     public void stopBroker() throws Exception {
1:862cd71:         if (broker != null) {
1:862cd71:             broker.stop();
1:862cd71:         }
1:862cd71:     }
1:862cd71: 
1:862cd71:     public void startBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1:862cd71:         broker = createBroker(deleteAllMessagesOnStartup);
1:862cd71:         broker.start();
1:862cd71:     }
1:862cd71: 
1:862cd71:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1:883eed0:         return createBroker(deleteAllMessagesOnStartup, TRANSPORT_URI);
1:862cd71:     }
1:862cd71: 
1:883eed0:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup, String bindAddress) throws Exception {
1:862cd71:         broker = new BrokerService();
1:883eed0:         broker.addConnector(bindAddress);
1:862cd71:         broker.setDeleteAllMessagesOnStartup(deleteAllMessagesOnStartup);
1:862cd71: 
1:883eed0:         this.url = broker.getTransportConnectors().get(0).getConnectUri().toString();
9:883eed0: 
1:862cd71:         return broker;
1:862cd71:     }
1:862cd71: 
1:862cd71:     @Test
1:862cd71:     public void testFailoverConsumerDups() throws Exception {
1:862cd71:         doTestFailoverConsumerDups(true);
1:862cd71:     }
1:862cd71: 
1:862cd71:     @Test
1:862cd71:     public void testFailoverConsumerDupsNoAdvisoryWatch() throws Exception {
1:862cd71:         doTestFailoverConsumerDups(false);
1:862cd71:     }
1:862cd71: 
1:7d8ce02:     @SuppressWarnings("unchecked")
1:82c4ab8:     @Test
1:82c4ab8:     public void testFailoverClientAckMissingRedelivery() throws Exception {
1:82c4ab8: 
1:82c4ab8:         final int maxConsumers = 2;
1:82c4ab8:         broker = createBroker(true);
1:82c4ab8: 
1:82c4ab8:         broker.setPlugins(new BrokerPlugin[] {
1:82c4ab8:                 new BrokerPluginSupport() {
1:82c4ab8:                     int consumerCount;
1:82c4ab8: 
1:82c4ab8:                     // broker is killed on x create consumer
1:82c4ab8:                     @Override
1:82c4ab8:                     public Subscription addConsumer(ConnectionContext context,
1:82c4ab8:                             final ConsumerInfo info) throws Exception {
1:82c4ab8:                          if (++consumerCount == maxConsumers) {
1:82c4ab8:                              context.setDontSendReponse(true);
1:82c4ab8:                              Executors.newSingleThreadExecutor().execute(new Runnable() {
1:82c4ab8:                                  public void run() {
1:82c4ab8:                                      LOG.info("Stopping broker on consumer: " + info.getConsumerId());
1:82c4ab8:                                      try {
1:82c4ab8:                                          broker.stop();
1:82c4ab8:                                      } catch (Exception e) {
1:82c4ab8:                                          e.printStackTrace();
1:82c4ab8:                                      }
1:82c4ab8:                                  }
1:82c4ab8:                              });
1:82c4ab8:                          }
1:82c4ab8:                         return super.addConsumer(context, info);
1:82c4ab8:                     }
1:82c4ab8:                 }
1:82c4ab8:         });
1:82c4ab8:         broker.start();
1:82c4ab8: 
1:82c4ab8:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:82c4ab8:         cf.setWatchTopicAdvisories(false);
1:82c4ab8: 
1:82c4ab8:         final ActiveMQConnection connection = (ActiveMQConnection) cf.createConnection();
1:82c4ab8:         connection.start();
1:82c4ab8: 
1:82c4ab8:         final Session consumerSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:82c4ab8:         final Queue destination = consumerSession.createQueue(QUEUE_NAME + "?jms.consumer.prefetch=" + prefetch);
1:82c4ab8: 
1:82c4ab8:         final Vector<TestConsumer> testConsumers = new Vector<TestConsumer>();
1:82c4ab8:         TestConsumer testConsumer = new TestConsumer(consumerSession, destination, connection);
1:82c4ab8:         testConsumer.setMessageListener(new MessageListener() {
1:82c4ab8:             @Override
1:82c4ab8:             public void onMessage(Message message) {
1:82c4ab8:                 try {
1:82c4ab8:                     LOG.info("onMessage:" + message.getJMSMessageID());
1:82c4ab8:                 } catch (JMSException e) {
1:82c4ab8:                     e.printStackTrace();
1:82c4ab8:                 }
1:82c4ab8:             }
1:82c4ab8:         });
1:82c4ab8:         testConsumers.add(testConsumer);
1:82c4ab8: 
1:82c4ab8: 
1:82c4ab8:         produceMessage(consumerSession, destination, maxConsumers * prefetch);
1:82c4ab8: 
1:82c4ab8:         assertTrue("add messages are delivered", Wait.waitFor(new Wait.Condition() {
1:82c4ab8:             public boolean isSatisified() throws Exception {
1:82c4ab8:                 int totalDelivered = 0;
1:82c4ab8:                 for (TestConsumer testConsumer : testConsumers) {
1:82c4ab8:                     long delivered = testConsumer.deliveredSize();
1:82c4ab8:                     LOG.info(testConsumer.getConsumerId() + " delivered: " + delivered);
1:82c4ab8:                     totalDelivered += delivered;
1:82c4ab8:                 }
1:82c4ab8:                 return totalDelivered == maxConsumers * prefetch;
1:82c4ab8:             }
1:82c4ab8:         }));
1:82c4ab8: 
1:82c4ab8:         final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);
1:82c4ab8: 
1:82c4ab8:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:82c4ab8:             public void run() {
1:82c4ab8:                 try {
1:82c4ab8:                     LOG.info("add last consumer...");
1:82c4ab8:                     TestConsumer testConsumer = new TestConsumer(consumerSession, destination, connection);
1:82c4ab8:                     testConsumer.setMessageListener(new MessageListener() {
1:82c4ab8:                                 @Override
1:82c4ab8:                                 public void onMessage(Message message) {
1:82c4ab8:                                     try {
1:82c4ab8:                                         LOG.info("onMessage:" + message.getJMSMessageID());
1:82c4ab8:                                     } catch (JMSException e) {
1:82c4ab8:                                         e.printStackTrace();
1:82c4ab8:                                     }
1:82c4ab8:                                 }
1:82c4ab8:                             });
1:82c4ab8:                     testConsumers.add(testConsumer);
1:82c4ab8:                     shutdownConsumerAdded.countDown();
1:82c4ab8:                     LOG.info("done add last consumer");
1:82c4ab8:                 } catch (Exception e) {
1:82c4ab8:                     e.printStackTrace();
1:82c4ab8:                 }
1:82c4ab8:             }
1:82c4ab8:         });
1:82c4ab8: 
1:82c4ab8:         // will be stopped by the plugin
1:82c4ab8:         broker.waitUntilStopped();
1:82c4ab8: 
1:82c4ab8:         broker = createBroker(false, this.url);
1:82c4ab8:         broker.start();
1:82c4ab8: 
1:82c4ab8:         assertTrue("consumer added through failover", shutdownConsumerAdded.await(30, TimeUnit.SECONDS));
1:82c4ab8: 
1:82c4ab8:         // each should again get prefetch messages - all unacked deliveries should be rolledback
1:82c4ab8:         assertTrue("after restart all messages are re dispatched", Wait.waitFor(new Wait.Condition() {
1:82c4ab8:             public boolean isSatisified() throws Exception {
1:82c4ab8:                 int totalDelivered = 0;
1:82c4ab8:                 for (TestConsumer testConsumer : testConsumers) {
1:82c4ab8:                     long delivered = testConsumer.deliveredSize();
1:82c4ab8:                     LOG.info(testConsumer.getConsumerId() + " delivered: " + delivered);
1:82c4ab8:                     totalDelivered += delivered;
1:82c4ab8:                 }
1:82c4ab8:                 return totalDelivered == maxConsumers * prefetch;
1:82c4ab8:             }
1:82c4ab8:         }));
1:82c4ab8: 
1:82c4ab8:         assertTrue("after restart each got prefetch amount", Wait.waitFor(new Wait.Condition() {
1:82c4ab8:             public boolean isSatisified() throws Exception {
1:82c4ab8:                 for (TestConsumer testConsumer : testConsumers) {
1:82c4ab8:                     long delivered = testConsumer.deliveredSize();
1:82c4ab8:                     LOG.info(testConsumer.getConsumerId() + " delivered: " + delivered);
1:82c4ab8:                     if (delivered != prefetch) {
1:82c4ab8:                         return false;
1:82c4ab8:                     }
1:82c4ab8:                 }
1:82c4ab8:                 return true;
1:82c4ab8:             }
1:82c4ab8:         }));
1:82c4ab8: 
1:82c4ab8:         connection.close();
1:82c4ab8:     }
1:82c4ab8: 
1:82c4ab8:     @SuppressWarnings("unchecked")
1:862cd71:     public void doTestFailoverConsumerDups(final boolean watchTopicAdvisories) throws Exception {
1:21e641d: 
1:862cd71:         final int maxConsumers = 4;
1:862cd71:         broker = createBroker(true);
1:862cd71: 
1:862cd71:         broker.setPlugins(new BrokerPlugin[] {
1:862cd71:                 new BrokerPluginSupport() {
1:862cd71:                     int consumerCount;
1:862cd71: 
1:862cd71:                     // broker is killed on x create consumer
1:862cd71:                     @Override
1:862cd71:                     public Subscription addConsumer(ConnectionContext context,
1:862cd71:                             final ConsumerInfo info) throws Exception {
1:862cd71:                          if (++consumerCount == maxConsumers + (watchTopicAdvisories ? 1:0)) {
1:862cd71:                              context.setDontSendReponse(true);
1:862cd71:                              Executors.newSingleThreadExecutor().execute(new Runnable() {
1:862cd71:                                  public void run() {
1:862cd71:                                      LOG.info("Stopping broker on consumer: " + info.getConsumerId());
1:862cd71:                                      try {
1:862cd71:                                          broker.stop();
1:862cd71:                                      } catch (Exception e) {
1:862cd71:                                          e.printStackTrace();
1:862cd71:                                      }
1:862cd71:                                  }
1:862cd71:                              });
1:862cd71:                          }
1:862cd71:                         return super.addConsumer(context, info);
1:862cd71:                     }
1:862cd71:                 }
1:862cd71:         });
1:862cd71:         broker.start();
1:862cd71: 
1:862cd71:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:862cd71:         cf.setWatchTopicAdvisories(watchTopicAdvisories);
1:862cd71: 
1:862cd71:         final ActiveMQConnection connection = (ActiveMQConnection) cf.createConnection();
1:862cd71:         connection.start();
1:862cd71: 
1:862cd71:         final Session consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:862cd71:         final Queue destination = consumerSession.createQueue(QUEUE_NAME + "?jms.consumer.prefetch=" + prefetch);
1:862cd71: 
1:862cd71:         final Vector<TestConsumer> testConsumers = new Vector<TestConsumer>();
1:862cd71:         for (int i=0; i<maxConsumers -1; i++) {
1:862cd71:             testConsumers.add(new TestConsumer(consumerSession, destination, connection));
1:862cd71:         }
1:862cd71: 
1:862cd71:         produceMessage(consumerSession, destination, maxConsumers * prefetch);
1:862cd71: 
1:862cd71:         assertTrue("add messages are dispatched", Wait.waitFor(new Wait.Condition() {
1:862cd71:             public boolean isSatisified() throws Exception {
1:862cd71:                 int totalUnconsumed = 0;
1:862cd71:                 for (TestConsumer testConsumer : testConsumers) {
1:862cd71:                     long unconsumed = testConsumer.unconsumedSize();
1:862cd71:                     LOG.info(testConsumer.getConsumerId() + " unconsumed: " + unconsumed);
1:862cd71:                     totalUnconsumed += unconsumed;
1:862cd71:                 }
1:862cd71:                 return totalUnconsumed == (maxConsumers-1) * prefetch;
1:862cd71:             }
1:862cd71:         }));
1:862cd71: 
1:82c4ab8:         final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);
1:862cd71: 
1:862cd71:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:862cd71:             public void run() {
1:862cd71:                 try {
1:862cd71:                     LOG.info("add last consumer...");
1:862cd71:                     testConsumers.add(new TestConsumer(consumerSession, destination, connection));
1:82c4ab8:                     shutdownConsumerAdded.countDown();
1:862cd71:                     LOG.info("done add last consumer");
1:862cd71:                 } catch (Exception e) {
1:862cd71:                     e.printStackTrace();
1:862cd71:                 }
1:862cd71:             }
1:862cd71:         });
1:862cd71: 
1:862cd71:         // will be stopped by the plugin
1:862cd71:         broker.waitUntilStopped();
1:862cd71: 
1:21e641d:         // verify interrupt
1:21e641d:         assertTrue("add messages dispatched and unconsumed are cleaned up", Wait.waitFor(new Wait.Condition() {
1:21e641d:             public boolean isSatisified() throws Exception {
1:21e641d:                 int totalUnconsumed = 0;
1:21e641d:                 for (TestConsumer testConsumer : testConsumers) {
1:21e641d:                     long unconsumed = testConsumer.unconsumedSize();
1:21e641d:                     LOG.info(testConsumer.getConsumerId() + " unconsumed: " + unconsumed);
1:21e641d:                     totalUnconsumed += unconsumed;
1:21e641d:                 }
1:21e641d:                 return totalUnconsumed == 0;
1:21e641d:             }
1:21e641d:         }));
1:21e641d: 
1:883eed0:         broker = createBroker(false, this.url);
1:862cd71:         broker.start();
1:862cd71: 
1:82c4ab8:         assertTrue("consumer added through failover", shutdownConsumerAdded.await(30, TimeUnit.SECONDS));
1:883eed0: 
1:862cd71:         // each should again get prefetch messages - all unconsumed deliveries should be rolledback
1:862cd71:         assertTrue("after start all messages are re dispatched", Wait.waitFor(new Wait.Condition() {
1:862cd71:             public boolean isSatisified() throws Exception {
1:862cd71:                 int totalUnconsumed = 0;
1:862cd71:                 for (TestConsumer testConsumer : testConsumers) {
1:862cd71:                     long unconsumed = testConsumer.unconsumedSize();
1:862cd71:                     LOG.info(testConsumer.getConsumerId() + " after restart: unconsumed: " + unconsumed);
1:862cd71:                     totalUnconsumed += unconsumed;
1:862cd71:                 }
1:862cd71:                 return totalUnconsumed == (maxConsumers) * prefetch;
1:862cd71:             }
1:862cd71:         }));
1:862cd71: 
1:862cd71:         connection.close();
1:862cd71:     }
1:862cd71: 
1:862cd71:     private void produceMessage(final Session producerSession, Queue destination, long count)
1:862cd71:         throws JMSException {
1:862cd71:         MessageProducer producer = producerSession.createProducer(destination);
1:862cd71:         for (int i=0; i<count; i++) {
1:862cd71:             TextMessage message = producerSession.createTextMessage("Test message " + i);
1:862cd71:             producer.send(message);
1:862cd71:         }
1:862cd71:         producer.close();
1:862cd71:     }
1:862cd71: 
1:862cd71:     // allow access to unconsumedMessages
1:862cd71:     class TestConsumer extends ActiveMQMessageConsumer {
1:862cd71: 
1:862cd71:         TestConsumer(Session consumerSession, Destination destination, ActiveMQConnection connection) throws Exception {
1:862cd71:             super((ActiveMQSession) consumerSession,
1:862cd71:                 new ConsumerId(new SessionId(connection.getConnectionInfo().getConnectionId(),1), nextGen()),
1:862cd71:                 ActiveMQMessageTransformation.transformDestination(destination), null, "",
1:862cd71:                 prefetch, -1, false, false, true, null);
1:862cd71:         }
1:862cd71: 
1:862cd71:         public int unconsumedSize() {
1:862cd71:             return unconsumedMessages.size();
1:862cd71:         }
1:82c4ab8: 
1:82c4ab8:         public int deliveredSize() {
1:82c4ab8:             return deliveredMessages.size();
1:82c4ab8:         }
1:862cd71:     }
1:862cd71: 
1:862cd71:     static long idGen = 100;
1:862cd71:     private static long nextGen() {
1:862cd71:         idGen -=5;
1:862cd71:         return idGen;
1:862cd71:     }
1:862cd71: }
============================================================================
author:Gary Tully
-------------------------------------------------------------------------------
commit:82c4ab8
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testFailoverClientAckMissingRedelivery() throws Exception {
1: 
1:         final int maxConsumers = 2;
1:         broker = createBroker(true);
1: 
1:         broker.setPlugins(new BrokerPlugin[] {
1:                 new BrokerPluginSupport() {
1:                     int consumerCount;
1: 
1:                     // broker is killed on x create consumer
1:                     @Override
1:                     public Subscription addConsumer(ConnectionContext context,
1:                             final ConsumerInfo info) throws Exception {
1:                          if (++consumerCount == maxConsumers) {
1:                              context.setDontSendReponse(true);
1:                              Executors.newSingleThreadExecutor().execute(new Runnable() {
1:                                  public void run() {
1:                                      LOG.info("Stopping broker on consumer: " + info.getConsumerId());
1:                                      try {
1:                                          broker.stop();
1:                                      } catch (Exception e) {
1:                                          e.printStackTrace();
1:                                      }
1:                                  }
1:                              });
1:                          }
1:                         return super.addConsumer(context, info);
1:                     }
1:                 }
1:         });
1:         broker.start();
1: 
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         cf.setWatchTopicAdvisories(false);
1: 
1:         final ActiveMQConnection connection = (ActiveMQConnection) cf.createConnection();
1:         connection.start();
1: 
1:         final Session consumerSession = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         final Queue destination = consumerSession.createQueue(QUEUE_NAME + "?jms.consumer.prefetch=" + prefetch);
1: 
1:         final Vector<TestConsumer> testConsumers = new Vector<TestConsumer>();
1:         TestConsumer testConsumer = new TestConsumer(consumerSession, destination, connection);
1:         testConsumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 try {
1:                     LOG.info("onMessage:" + message.getJMSMessageID());
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1:         testConsumers.add(testConsumer);
1: 
1: 
1:         produceMessage(consumerSession, destination, maxConsumers * prefetch);
1: 
1:         assertTrue("add messages are delivered", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 int totalDelivered = 0;
1:                 for (TestConsumer testConsumer : testConsumers) {
1:                     long delivered = testConsumer.deliveredSize();
1:                     LOG.info(testConsumer.getConsumerId() + " delivered: " + delivered);
1:                     totalDelivered += delivered;
1:                 }
1:                 return totalDelivered == maxConsumers * prefetch;
1:             }
1:         }));
1: 
1:         final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);
1: 
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {
1:             public void run() {
1:                 try {
1:                     LOG.info("add last consumer...");
1:                     TestConsumer testConsumer = new TestConsumer(consumerSession, destination, connection);
1:                     testConsumer.setMessageListener(new MessageListener() {
1:                                 @Override
1:                                 public void onMessage(Message message) {
1:                                     try {
1:                                         LOG.info("onMessage:" + message.getJMSMessageID());
1:                                     } catch (JMSException e) {
1:                                         e.printStackTrace();
1:                                     }
1:                                 }
1:                             });
1:                     testConsumers.add(testConsumer);
1:                     shutdownConsumerAdded.countDown();
1:                     LOG.info("done add last consumer");
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
1:         // will be stopped by the plugin
1:         broker.waitUntilStopped();
1: 
1:         broker = createBroker(false, this.url);
1:         broker.start();
1: 
1:         assertTrue("consumer added through failover", shutdownConsumerAdded.await(30, TimeUnit.SECONDS));
1: 
1:         // each should again get prefetch messages - all unacked deliveries should be rolledback
1:         assertTrue("after restart all messages are re dispatched", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 int totalDelivered = 0;
1:                 for (TestConsumer testConsumer : testConsumers) {
1:                     long delivered = testConsumer.deliveredSize();
1:                     LOG.info(testConsumer.getConsumerId() + " delivered: " + delivered);
1:                     totalDelivered += delivered;
1:                 }
1:                 return totalDelivered == maxConsumers * prefetch;
1:             }
1:         }));
1: 
1:         assertTrue("after restart each got prefetch amount", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 for (TestConsumer testConsumer : testConsumers) {
1:                     long delivered = testConsumer.deliveredSize();
1:                     LOG.info(testConsumer.getConsumerId() + " delivered: " + delivered);
1:                     if (delivered != prefetch) {
1:                         return false;
1:                     }
1:                 }
1:                 return true;
1:             }
1:         }));
1: 
1:         connection.close();
1:     }
1: 
1:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1:         final CountDownLatch shutdownConsumerAdded = new CountDownLatch(1);
1:                     shutdownConsumerAdded.countDown();
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("consumer added through failover", shutdownConsumerAdded.await(30, TimeUnit.SECONDS));
/////////////////////////////////////////////////////////////////////////
1: 
1:         public int deliveredSize() {
1:             return deliveredMessages.size();
1:         }
commit:21e641d
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify interrupt
1:         assertTrue("add messages dispatched and unconsumed are cleaned up", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 int totalUnconsumed = 0;
1:                 for (TestConsumer testConsumer : testConsumers) {
1:                     long unconsumed = testConsumer.unconsumedSize();
1:                     LOG.info(testConsumer.getConsumerId() + " unconsumed: " + unconsumed);
1:                     totalUnconsumed += unconsumed;
1:                 }
1:                 return totalUnconsumed == 0;
1:             }
1:         }));
1: 
commit:862cd71
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.failover;
1: 
1: import static org.junit.Assert.assertTrue;
1: 
1: import java.util.Vector;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: 
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.ActiveMQMessageConsumer;
1: import org.apache.activemq.ActiveMQMessageTransformation;
1: import org.apache.activemq.ActiveMQSession;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerPluginSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.util.Wait;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: import org.junit.After;
1: import org.junit.Test;
1: 
1: // see https://issues.apache.org/activemq/browse/AMQ-2573
1: public class FailoverConsumerUnconsumedTest {
1: 	
0:     private static final Log LOG = LogFactory.getLog(FailoverConsumerUnconsumedTest.class);
1: 	private static final String QUEUE_NAME = "FailoverWithUnconsumed";
0: 	private String url = "tcp://localhost:61616";
1: 	final int prefetch = 10;
1: 	BrokerService broker;
1: 	
0: 	public void startCleanBroker() throws Exception {
0: 	    startBroker(true);
1: 	}
1: 	
1: 	@After
1: 	public void stopBroker() throws Exception {
1: 	    if (broker != null) {
1: 	        broker.stop();
1: 	    }
1: 	}
1: 	
1: 	public void startBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1: 	    broker = createBroker(deleteAllMessagesOnStartup);
1:         broker.start();
1: 	}
1: 
1: 	public BrokerService createBroker(boolean deleteAllMessagesOnStartup) throws Exception {   
1: 	    broker = new BrokerService();
0: 	    broker.addConnector(url);
1: 	    broker.setDeleteAllMessagesOnStartup(deleteAllMessagesOnStartup);
1: 	    return broker;
1: 	}
1: 
1: 	@Test
1: 	public void testFailoverConsumerDups() throws Exception {
1: 	    doTestFailoverConsumerDups(true);
1: 	}
1: 	 
1: 	@Test
1:     public void testFailoverConsumerDupsNoAdvisoryWatch() throws Exception {
1:         doTestFailoverConsumerDups(false);
1:     }
1: 	
1: 	public void doTestFailoverConsumerDups(final boolean watchTopicAdvisories) throws Exception {
1: 	    
1: 	    final int maxConsumers = 4;
1:         broker = createBroker(true);
1:             
1:         broker.setPlugins(new BrokerPlugin[] {
1:                 new BrokerPluginSupport() {
1:                     int consumerCount;
1: 
1:                     // broker is killed on x create consumer
1:                     @Override
1:                     public Subscription addConsumer(ConnectionContext context,
1:                             final ConsumerInfo info) throws Exception {
1:                          if (++consumerCount == maxConsumers + (watchTopicAdvisories ? 1:0)) {
1:                              context.setDontSendReponse(true);
1:                              Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:                                  public void run() {
1:                                      LOG.info("Stopping broker on consumer: " + info.getConsumerId());
1:                                      try {
1:                                          broker.stop();
1:                                      } catch (Exception e) {
1:                                          e.printStackTrace();
1:                                      }
1:                                  }
1:                              });
1:                          }
1:                         return super.addConsumer(context, info);
1:                     }
1:                 }
1:         });
1:         broker.start();
1:         
1:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory("failover:(" + url + ")");
1:         cf.setWatchTopicAdvisories(watchTopicAdvisories);
1:         
1:         final ActiveMQConnection connection = (ActiveMQConnection) cf.createConnection();
1:         connection.start();
1:         
1:         final Session consumerSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         final Queue destination = consumerSession.createQueue(QUEUE_NAME + "?jms.consumer.prefetch=" + prefetch);
1: 
1:         final Vector<TestConsumer> testConsumers = new Vector<TestConsumer>();
1:         for (int i=0; i<maxConsumers -1; i++) {
1:             testConsumers.add(new TestConsumer(consumerSession, destination, connection));
1:         }
1:         
1:         produceMessage(consumerSession, destination, maxConsumers * prefetch);
1:                
1:         assertTrue("add messages are dispatched", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 int totalUnconsumed = 0;
1:                 for (TestConsumer testConsumer : testConsumers) {
1:                     long unconsumed = testConsumer.unconsumedSize();
1:                     LOG.info(testConsumer.getConsumerId() + " unconsumed: " + unconsumed);
1:                     totalUnconsumed += unconsumed;
1:                 }   
1:                 return totalUnconsumed == (maxConsumers-1) * prefetch;
1:             }
1:         }));
1:         
0:         final CountDownLatch commitDoneLatch = new CountDownLatch(1);
1:         
1:         Executors.newSingleThreadExecutor().execute(new Runnable() {   
1:             public void run() {
1:                 try {
1:                     LOG.info("add last consumer...");
1:                     testConsumers.add(new TestConsumer(consumerSession, destination, connection));
0:                     commitDoneLatch.countDown();
1:                     LOG.info("done add last consumer");
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1:                
1:         // will be stopped by the plugin
1:         broker.waitUntilStopped();
0:         broker = createBroker(false);
1:         broker.start();
1: 
0:         assertTrue("consumer added through failover", commitDoneLatch.await(30, TimeUnit.SECONDS));
1:         
1:         // each should again get prefetch messages - all unconsumed deliveries should be rolledback
1:         assertTrue("after start all messages are re dispatched", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 int totalUnconsumed = 0;
1:                 for (TestConsumer testConsumer : testConsumers) {
1:                     long unconsumed = testConsumer.unconsumedSize();
1:                     LOG.info(testConsumer.getConsumerId() + " after restart: unconsumed: " + unconsumed);
1:                     totalUnconsumed += unconsumed;
1:                 }   
1:                 return totalUnconsumed == (maxConsumers) * prefetch;
1:             }
1:         }));
1:         
1:         connection.close();
1:     }
1:         
1:     private void produceMessage(final Session producerSession, Queue destination, long count)
1:         throws JMSException {
1:         MessageProducer producer = producerSession.createProducer(destination);
1:         for (int i=0; i<count; i++) {
1:             TextMessage message = producerSession.createTextMessage("Test message " + i);
1:             producer.send(message);
1:         }
1:         producer.close();
1:     }
1:     
1:     // allow access to unconsumedMessages
1:     class TestConsumer extends ActiveMQMessageConsumer {
1:         
1:         TestConsumer(Session consumerSession, Destination destination, ActiveMQConnection connection) throws Exception {
1:             super((ActiveMQSession) consumerSession, 
1:                 new ConsumerId(new SessionId(connection.getConnectionInfo().getConnectionId(),1), nextGen()), 
1:                 ActiveMQMessageTransformation.transformDestination(destination), null, "",
1:                 prefetch, -1, false, false, true, null);
1:         }
1:     
1:         public int unconsumedSize() {
1:             return unconsumedMessages.size();
1:         }
1:     }
1:     
1:     static long idGen = 100;
1:     private static long nextGen() {
1:         idGen -=5;
1:         return idGen;
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:7d8ce02
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
commit:883eed0
/////////////////////////////////////////////////////////////////////////
1: 
0:     private static final String QUEUE_NAME = "FailoverWithUnconsumed";
1:     private static final String TRANSPORT_URI = "tcp://localhost:0";
1:     private String url;
0:     final int prefetch = 10;
0:     BrokerService broker;
1: 
0:     @After
0:     public void stopBroker() throws Exception {
0:         if (broker != null) {
0:             broker.stop();
0:         }
0:     }
1: 
0:     public void startBroker(boolean deleteAllMessagesOnStartup) throws Exception {
0:         broker = createBroker(deleteAllMessagesOnStartup);
0:     }
0:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup) throws Exception {
1:         return createBroker(deleteAllMessagesOnStartup, TRANSPORT_URI);
0:     }
1:     public BrokerService createBroker(boolean deleteAllMessagesOnStartup, String bindAddress) throws Exception {
0:         broker = new BrokerService();
1:         broker.addConnector(bindAddress);
0:         broker.setDeleteAllMessagesOnStartup(deleteAllMessagesOnStartup);
1: 
1:         this.url = broker.getTransportConnectors().get(0).getConnectUri().toString();
1: 
0:         return broker;
0:     }
1: 
0:     @Test
0:     public void testFailoverConsumerDups() throws Exception {
0:         doTestFailoverConsumerDups(true);
0:     }
1: 
0:     @Test
1: 
0:     public void doTestFailoverConsumerDups(final boolean watchTopicAdvisories) throws Exception {
1: 
0:         final int maxConsumers = 4;
1: 
/////////////////////////////////////////////////////////////////////////
0:                              Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:                 }
0: 
0: 
0:         Executors.newSingleThreadExecutor().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker(false, this.url);
0: 
/////////////////////////////////////////////////////////////////////////
0:                 }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:             super((ActiveMQSession) consumerSession,
0:                 new ConsumerId(new SessionId(connection.getConnectionInfo().getConnectionId(),1), nextGen()),
0: 
0: 
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(FailoverConsumerUnconsumedTest.class);
============================================================================