1:5cbb4db: /**
1:5cbb4db:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:5cbb4db:  * contributor license agreements.  See the NOTICE file distributed with
1:5cbb4db:  * this work for additional information regarding copyright ownership.
1:5cbb4db:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:5cbb4db:  * (the "License"); you may not use this file except in compliance with
1:5cbb4db:  * the License.  You may obtain a copy of the License at
1:5cbb4db:  *
1:5cbb4db:  *      http://www.apache.org/licenses/LICENSE-2.0
1:5cbb4db:  *
1:5cbb4db:  * Unless required by applicable law or agreed to in writing, software
1:5cbb4db:  * distributed under the License is distributed on an "AS IS" BASIS,
1:5cbb4db:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5cbb4db:  * See the License for the specific language governing permissions and
1:5cbb4db:  * limitations under the License.
1:4f1754b:  */
1:5cbb4db: package org.apache.activemq.usecases;
71:ec11e82: 
1:0b86397: import javax.management.openmbean.TabularData;
1:57f5d49: import org.apache.activemq.ActiveMQConnectionFactory;
1:f4f416a: import org.apache.activemq.broker.BrokerService;
1:f4f416a: import org.apache.activemq.broker.jmx.DurableSubscriptionViewMBean;
1:57f5d49: import org.apache.activemq.command.ActiveMQTopic;
1:57f5d49: import org.apache.activemq.command.MessageId;
1:57f5d49: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:57f5d49: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1:f4f416a: import org.apache.activemq.transport.vm.VMTransport;
1:f4f416a: import org.apache.activemq.transport.vm.VMTransportFactory;
1:f4f416a: import org.apache.activemq.transport.vm.VMTransportServer;
1:57f5d49: import org.junit.Ignore;
1:57f5d49: import org.junit.Test;
1:57f5d49: import org.slf4j.Logger;
1:57f5d49: import org.slf4j.LoggerFactory;
1:ec11e82: 
1:2d121f4: import javax.jms.Connection;
1:2d121f4: import javax.jms.JMSException;
1:2d121f4: import javax.jms.Message;
1:2d121f4: import javax.jms.MessageConsumer;
1:2d121f4: import javax.jms.MessageProducer;
1:2d121f4: import javax.jms.Session;
1:f4f416a: import javax.management.ObjectName;
1:f4f416a: import javax.management.openmbean.CompositeData;
1:57f5d49: import java.util.HashSet;
1:57f5d49: import java.util.concurrent.ExecutorService;
1:57f5d49: import java.util.concurrent.Executors;
1:57f5d49: import java.util.concurrent.TimeUnit;
1:ec11e82: 
1:57f5d49: import static org.junit.Assert.*;
1:ec11e82: 
1:57f5d49: public class DurableSubscriptionOfflineTest extends DurableSubscriptionOfflineTestBase {
1:ec11e82: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubscriptionOfflineTest.class);
1:ec11e82: 
1:646d023:     @Override
1:5cbb4db:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
1:caca105:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://" + getName(true));
1:caca105:         connectionFactory.setWatchTopicAdvisories(false);
1:caca105:         return connectionFactory;
10:ec11e82:     }
1:4f1754b: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:57f5d49:     public void testConsumeAllMatchedMessages() throws Exception {
3:ec11e82:         // create durable subscription
2:ec11e82:         Connection con = createConnection();
6:ec11e82:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
7:ec11e82:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
13:ec11e82:         session.close();
9:ec11e82:         con.close();
1:ec11e82: 
6:ec11e82:         // send messages
8:ec11e82:         con = createConnection();
8:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
6:ec11e82:         MessageProducer producer = session.createProducer(null);
1:ec11e82: 
5:ec11e82:         int sent = 0;
9:ec11e82:         for (int i = 0; i < 10; i++) {
1:57f5d49:             sent++;
9:ec11e82:             Message message = session.createMessage();
1:57f5d49:             message.setStringProperty("filter", "true");
7:ec11e82:             producer.send(topic, message);
1:ec11e82:         }
1:ec11e82: 
1:57f5d49:         Thread.sleep(1 * 1000);
1:57f5d49: 
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
3:ec11e82:         // consume messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
5:ec11e82:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:57f5d49:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
7:ec11e82:         consumer.setMessageListener(listener);
1:ec11e82: 
12:ec11e82:         Thread.sleep(3 * 1000);
1:ec11e82: 
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
5:ec11e82:         assertEquals(sent, listener.count);
1:ec11e82:     }
1:ec11e82: 
1:f4f416a:     @Test(timeout = 60 * 1000)
1:f4f416a:     public void testBrowseOfflineSub() throws Exception {
1:f4f416a:         // create durable subscription
1:f4f416a:         Connection con = createConnection();
1:f4f416a:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:f4f416a:         session.createDurableSubscriber(topic, "SubsId");
1:f4f416a:         session.close();
1:f4f416a:         con.close();
1:f4f416a: 
1:f4f416a:         // send messages
1:f4f416a:         con = createConnection();
1:f4f416a:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:f4f416a:         MessageProducer producer = session.createProducer(null);
1:f4f416a: 
1:f4f416a:         for (int i = 0; i < 10; i++) {
1:f4f416a:             Message message = session.createMessage();
1:f4f416a:             message.setStringProperty("filter", "true");
1:f4f416a:             producer.send(topic, message);
1:f4f416a:         }
1:f4f416a: 
1:f4f416a:         Thread.sleep(1 * 1000);
1:f4f416a: 
1:f4f416a:         session.close();
1:f4f416a:         con.close();
1:f4f416a: 
1:f4f416a:         // browse the durable sub
1:f4f416a:         ObjectName[] subs = broker.getAdminView().getInactiveDurableTopicSubscribers();
1:f4f416a:         assertEquals(1, subs.length);
1:f4f416a:         ObjectName subName = subs[0];
1:f4f416a:         DurableSubscriptionViewMBean sub = (DurableSubscriptionViewMBean)
1:f4f416a:                 broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true);
1:f4f416a:         CompositeData[] data  = sub.browse();
1:f4f416a:         assertNotNull(data);
1:f4f416a:         assertEquals(10, data.length);
1:0b86397: 
1:0b86397:         TabularData tabularData = sub.browseAsTable();
1:0b86397:         assertNotNull(tabularData);
1:0b86397:         assertEquals(10, tabularData.size());
1:0b86397: 
1:f4f416a:     }
1:ec11e82: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testTwoOfflineSubscriptionCanConsume() throws Exception {
3:ec11e82:         // create durable subscription 1
3:ec11e82:         Connection con = createConnection("cliId1");
1:ec11e82:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
2:ec11e82:         // create durable subscription 2
2:ec11e82:         Connection con2 = createConnection("cliId2");
4:ec11e82:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
3:ec11e82:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:57f5d49:         DurableSubscriptionOfflineTestListener listener2 = new DurableSubscriptionOfflineTestListener();
5:ec11e82:         consumer2.setMessageListener(listener2);
1:ec11e82: 
1:ec11e82:         // send messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageProducer producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:         int sent = 0;
1:ec11e82:         for (int i = 0; i < 10; i++) {
5:ec11e82:             sent++;
1:ec11e82:             Message message = session.createMessage();
3:ec11e82:             message.setStringProperty("filter", "true");
1:ec11e82:             producer.send(topic, message);
1:ec11e82:         }
1:ec11e82: 
7:ec11e82:         Thread.sleep(1 * 1000);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
4:ec11e82:         // test online subs
1:ec11e82:         Thread.sleep(3 * 1000);
4:ec11e82:         session2.close();
4:ec11e82:         con2.close();
1:ec11e82: 
2:ec11e82:         assertEquals(sent, listener2.count);
1:ec11e82: 
1:ec11e82:         // consume messages
4:ec11e82:         con = createConnection("cliId1");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:57f5d49:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
1:ec11e82:         consumer.setMessageListener(listener);
1:ec11e82: 
1:ec11e82:         Thread.sleep(3 * 1000);
1:ec11e82: 
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
2:ec11e82:         assertEquals("offline consumer got all", sent, listener.count);
1:ec11e82:     }
1:ec11e82: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testRemovedDurableSubDeletes() throws Exception {
1:57f5d49:         String filter = "$a='A1' AND (($b=true AND $c=true) OR ($d='D1' OR $d='D2'))";
1:ec11e82:         // create durable subscription 1
1:ec11e82:         Connection con = createConnection("cliId1");
1:ec11e82:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         // send messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageProducer producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:         for (int i = 0; i < 10; i++) {
1:ec11e82:             Message message = session.createMessage();
1:ec11e82:             message.setStringProperty("filter", "true");
1:ec11e82:             producer.send(topic, message);
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         Thread.sleep(1 * 1000);
1:ec11e82: 
1:ec11e82:         Connection con2 = createConnection("cliId1");
1:ec11e82:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session2.unsubscribe("SubsId");
1:ec11e82:         session2.close();
1:ec11e82:         con2.close();
1:ec11e82: 
1:ec11e82:         // see if retroactive can consumer any
1:ec11e82:         topic = new ActiveMQTopic(topic.getPhysicalName() + "?consumer.retroactive=true");
4:ec11e82:         con = createConnection("offCli2");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:57f5d49:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
1:ec11e82:         consumer.setMessageListener(listener);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82:         assertEquals(0, listener.count);
1:ec11e82:     }
1:ec11e82: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testRemovedDurableSubDeletesFromIndex() throws Exception {
1:ec11e82: 
1:ec11e82:         if (! (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter)) {
2:ec11e82:             return;
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         final int numMessages = 2750;
1:ec11e82: 
1:ec11e82:         KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
1:ec11e82:         PageFile pageFile = kahaDBPersistenceAdapter.getStore().getPageFile();
1:ec11e82:         LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() + ", fileSize:" + pageFile.getFile().length());
1:ec11e82: 
1:ec11e82:         long lastDiff = 0;
1:ec11e82:         for (int repeats=0; repeats<2; repeats++) {
1:ec11e82: 
1:ec11e82:             LOG.info("Iteration: "+ repeats  + " Count:" + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount());
1:ec11e82: 
1:ec11e82:             Connection con = createConnection("cliId1" + "-" + repeats);
1:ec11e82:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:             session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:ec11e82:             session.close();
1:ec11e82:             con.close();
1:ec11e82: 
1:ec11e82:             // send messages
1:ec11e82:             con = createConnection();
1:ec11e82:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:             MessageProducer producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:             for (int i = 0; i < numMessages; i++) {
1:ec11e82:                 Message message = session.createMessage();
1:ec11e82:                 message.setStringProperty("filter", "true");
1:ec11e82:                 producer.send(topic, message);
1:ec11e82:             }
1:ec11e82:             con.close();
1:ec11e82: 
1:ec11e82:             Connection con2 = createConnection("cliId1" + "-" + repeats);
1:ec11e82:             Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:             session2.unsubscribe("SubsId");
1:ec11e82:             session2.close();
1:ec11e82:             con2.close();
1:ec11e82: 
1:ec11e82:             LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() +  " diff: " + (pageFile.getPageCount() - pageFile.getFreePageCount()) + " fileSize:" + pageFile.getFile().length());
1:ec11e82: 
1:ec11e82:             if (lastDiff != 0) {
1:ec11e82:                 assertEquals("Only use X pages per iteration: " + repeats, lastDiff, pageFile.getPageCount() - pageFile.getFreePageCount());
1:ec11e82:             }
1:ec11e82:             lastDiff = pageFile.getPageCount() - pageFile.getFreePageCount();
1:ec11e82:         }
1:ec11e82:     }
1:ec11e82: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testInterleavedOfflineSubscriptionCanConsumeAfterUnsub() throws Exception {
3:ec11e82:         // create offline subs 1
4:ec11e82:         Connection con = createConnection("offCli1");
1:ec11e82:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
3:ec11e82:         // create offline subs 2
1:ec11e82:         con = createConnection("offCli2");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", null, true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         // send messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageProducer producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:         int sent = 0;
1:ec11e82:         for (int i = 0; i < 10; i++) {
3:ec11e82:             boolean filter = (int) (Math.random() * 2) >= 1;
1:ec11e82: 
1:ec11e82:             sent++;
1:ec11e82: 
1:ec11e82:             Message message = session.createMessage();
3:ec11e82:             message.setStringProperty("filter", filter ? "true" : "false");
1:ec11e82:             producer.send(topic, message);
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         Thread.sleep(1 * 1000);
1:ec11e82: 
1:ec11e82:         Connection con2 = createConnection("offCli1");
1:ec11e82:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session2.unsubscribe("SubsId");
1:ec11e82:         session2.close();
1:ec11e82:         con2.close();
1:ec11e82: 
2:ec11e82:         // consume all messages
1:ec11e82:         con = createConnection("offCli2");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:57f5d49:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener("SubsId");
1:ec11e82:         consumer.setMessageListener(listener);
1:ec11e82: 
1:ec11e82:         Thread.sleep(3 * 1000);
1:ec11e82: 
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         assertEquals("offline consumer got all", sent, listener.count);
1:ec11e82:     }
1:ec11e82: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testNoDuplicateOnConcurrentSendTranCommitAndActivate() throws Exception {
1:ec11e82:         final int messageCount = 1000;
1:ec11e82:         Connection con = null;
1:ec11e82:         Session session = null;
1:ec11e82:         final int numConsumers = 10;
1:ec11e82:         for (int i = 0; i <= numConsumers; i++) {
1:ec11e82:             con = createConnection("cli" + i);
1:ec11e82:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:             session.createDurableSubscriber(topic, "SubsId", null, true);
1:ec11e82:             session.close();
1:ec11e82:             con.close();
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         class CheckForDupsClient implements Runnable {
1:ec11e82:             HashSet<Long> ids = new HashSet<Long>();
1:ec11e82:             final int id;
1:ec11e82: 
1:ec11e82:             public CheckForDupsClient(int id) {
1:ec11e82:                 this.id = id;
1:ec11e82:             }
1:ec11e82: 
1:ec11e82:             @Override
1:ec11e82:             public void run() {
1:ec11e82:                 try {
1:ec11e82:                     Connection con = createConnection("cli" + id);
1:ec11e82:                     Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:                     for (int j=0;j<2;j++) {
1:ec11e82:                         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:ec11e82:                         for (int i = 0; i < messageCount/2; i++) {
1:ec11e82:                             Message message = consumer.receive(4000);
1:ec11e82:                             assertNotNull(message);
1:ec11e82:                             long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
1:ec11e82:                             assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
1:ec11e82:                         }
1:ec11e82:                         consumer.close();
1:ec11e82:                     }
1:ec11e82: 
1:ec11e82:                     // verify no duplicates left
1:ec11e82:                     MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:ec11e82:                     Message message = consumer.receive(4000);
1:ec11e82:                     if (message != null) {
1:ec11e82:                         long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
1:ec11e82:                         assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
1:ec11e82:                     }
1:ec11e82:                     assertNull(message);
1:ec11e82: 
1:ec11e82: 
1:ec11e82:                     session.close();
1:ec11e82:                     con.close();
1:ec11e82:                 } catch (Throwable e) {
1:ec11e82:                     e.printStackTrace();
1:ec11e82:                     exceptions.add(e);
1:ec11e82:                 }
1:ec11e82:             }
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         final String payLoad = new String(new byte[1000]);
1:ec11e82:         con = createConnection();
1:ec11e82:         final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);
1:ec11e82:         MessageProducer producer = sendSession.createProducer(topic);
1:ec11e82:         for (int i = 0; i < messageCount; i++) {
1:ec11e82:             producer.send(sendSession.createTextMessage(payLoad));
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         ExecutorService executorService = Executors.newCachedThreadPool();
1:ec11e82: 
1:ec11e82:         // concurrent commit and activate
1:ec11e82:         executorService.execute(new Runnable() {
1:ec11e82:             @Override
1:ec11e82:             public void run() {
1:ec11e82:                 try {
1:ec11e82:                     sendSession.commit();
1:ec11e82:                 } catch (JMSException e) {
1:ec11e82:                     e.printStackTrace();
1:ec11e82:                     exceptions.add(e);
1:ec11e82:                 }
1:ec11e82:             }
1:ec11e82:         });
1:ec11e82:         for (int i = 0; i < numConsumers; i++) {
1:ec11e82:             executorService.execute(new CheckForDupsClient(i));
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         executorService.shutdown();
1:ec11e82:         executorService.awaitTermination(5, TimeUnit.MINUTES);
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:ec11e82:     }
1:4f1754b: 
1:ec11e82: 
1:be8990e:     @Test(timeout = 2 * 60 * 1000)
1:57f5d49:     public void testOrderOnActivateDeactivate() throws Exception {
1:ec11e82:         for (int i=0;i<10;i++) {
1:ec11e82:             LOG.info("Iteration: " + i);
1:ec11e82:             doTestOrderOnActivateDeactivate();
5:ec11e82:             broker.stop();
1:a7533ba:             broker.waitUntilStopped();
1:ec11e82:             createBroker(true /*deleteAllMessages*/);
1:ec11e82:         }
1:ec11e82:     }
1:ec11e82: 
1:ec11e82: 
1:6b4d077:     public void doTestOrderOnActivateDeactivate() throws Exception {
1:6b4d077:         final int messageCount = 1000;
1:6b4d077:         Connection con = null;
1:6b4d077:         Session session = null;
1:6b4d077:         final int numConsumers = 4;
1:6b4d077:         for (int i = 0; i <= numConsumers; i++) {
1:6b4d077:             con = createConnection("cli" + i);
1:ec11e82:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:             session.createDurableSubscriber(topic, "SubsId", null, true);
1:ec11e82:             session.close();
1:ec11e82:             con.close();
1:ec11e82:         }
1:ec11e82: 
1:6b4d077:         final String url = "failover:(tcp://localhost:"
1:57f5d49:                 + (broker.getTransportConnectors().get(1).getConnectUri()).getPort()
1:57f5d49:                 + "?wireFormat.maxInactivityDuration=0)?"
1:57f5d49:                 + "jms.watchTopicAdvisories=false&"
1:57f5d49:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&"
1:57f5d49:                 + "jms.sendAcksAsync=true&"
1:57f5d49:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&"
1:57f5d49:                 + "useExponentialBackOff=true";
1:6b4d077:         final ActiveMQConnectionFactory clientFactory = new ActiveMQConnectionFactory(url);
1:ec11e82: 
1:6b4d077:         class CheckOrderClient implements Runnable {
1:6b4d077:             final int id;
1:6b4d077:             int runCount = 0;
1:ec11e82: 
1:6b4d077:             public CheckOrderClient(int id) {
1:6b4d077:                 this.id = id;
1:ec11e82:             }
1:ec11e82: 
1:ec11e82:             @Override
1:6b4d077:             public void run() {
1:6b4d077:                 try {
1:6b4d077:                     synchronized (this) {
1:6b4d077:                         Connection con = clientFactory.createConnection();
1:6b4d077:                         con.setClientID("cli" + id);
1:6b4d077:                         con.start();
1:6b4d077:                         Session session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:ec11e82:                         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:6b4d077:                         int nextId = 0;
1:ec11e82: 
1:6b4d077:                         ++runCount;
1:6b4d077:                         int i=0;
1:6b4d077:                         for (; i < messageCount/2; i++) {
1:6b4d077:                             Message message = consumer.receiveNoWait();
1:6b4d077:                             if (message == null) {
1:6b4d077:                                 break;
1:ec11e82:                             }
1:6b4d077:                             long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
1:6b4d077:                             assertEquals(id + " expected order: runCount: " + runCount  + " id: " + message.getJMSMessageID(), ++nextId, producerSequenceId);
1:ec11e82:                         }
1:6b4d077:                         LOG.info(con.getClientID() + " peeked " + i);
1:ec11e82:                         session.close();
1:ec11e82:                         con.close();
1:ec11e82:                     }
1:6b4d077:                 } catch (Throwable e) {
1:3307d57:                     e.printStackTrace();
1:6b4d077:                     exceptions.add(e);
1:ec11e82:                 }
1:ec11e82:             }
1:ec11e82:         }
1:ec11e82: 
1:6b4d077:         Runnable producer = new Runnable() {
1:6b4d077:             final String payLoad = new String(new byte[600]);
1:ec11e82: 
1:ec11e82:             @Override
1:6b4d077:             public void run() {
1:6b4d077:                 try {
1:ec11e82:                     Connection con = createConnection();
1:6b4d077:                     final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);
1:6b4d077:                     MessageProducer producer = sendSession.createProducer(topic);
1:6b4d077:                     for (int i = 0; i < messageCount; i++) {
1:6b4d077:                         producer.send(sendSession.createTextMessage(payLoad));
1:ec11e82:                     }
1:6b4d077:                     LOG.info("About to commit: " + messageCount);
1:6b4d077:                     sendSession.commit();
1:6b4d077:                     LOG.info("committed: " + messageCount);
1:ec11e82:                     con.close();
1:6b4d077:                 } catch (Exception e) {
2:6b4d077:                     e.printStackTrace();
1:6b4d077:                     exceptions.add(e);
1:ec11e82:                 }
1:ec11e82:             }
1:6b4d077:         };
1:ec11e82: 
1:6b4d077:         ExecutorService executorService = Executors.newCachedThreadPool();
1:ec11e82: 
1:6b4d077:         // concurrent commit and activate
1:6b4d077:         for (int i = 0; i < numConsumers; i++) {
1:6b4d077:             final CheckOrderClient client = new CheckOrderClient(i);
1:6b4d077:             for (int j=0; j<100; j++) {
1:6b4d077:                 executorService.execute(client);
1:ec11e82:             }
1:ec11e82:         }
1:6b4d077:         executorService.execute(producer);
1:ec11e82: 
1:6b4d077:         executorService.shutdown();
1:6b4d077:         executorService.awaitTermination(5, TimeUnit.MINUTES);
1:ec11e82:         con.close();
1:ec11e82: 
1:6b4d077:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:ec11e82:     }
1:ec11e82: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testUnmatchedSubUnsubscribeDeletesAll() throws Exception {
1:ec11e82:         // create offline subs 1
1:ec11e82:         Connection con = createConnection("offCli1");
1:ec11e82:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         // send messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageProducer producer = session.createProducer(null);
1:ec11e82: 
2:ec11e82:         int filtered = 0;
1:ec11e82:         for (int i = 0; i < 10; i++) {
1:ec11e82:             boolean filter = (i %2 == 0); //(int) (Math.random() * 2) >= 1;
3:ec11e82:             if (filter)
4:ec11e82:                 filtered++;
1:ec11e82: 
1:ec11e82:             Message message = session.createMessage();
1:ec11e82:             message.setStringProperty("filter", filter ? "true" : "false");
1:ec11e82:             producer.send(topic, message);
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         LOG.info("sent: " + filtered);
1:ec11e82:         Thread.sleep(1 * 1000);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
2:ec11e82:         // test offline subs
3:ec11e82:         con = createConnection("offCli1");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.unsubscribe("SubsId");
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         con = createConnection("offCli1");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:57f5d49:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
1:ec11e82:         consumer.setMessageListener(listener);
1:ec11e82: 
1:ec11e82:         Thread.sleep(3 * 1000);
1:ec11e82: 
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         assertEquals(0, listener.count);
1:ec11e82:     }
1:ec11e82: 
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testAllConsumed() throws Exception {
1:ec11e82:         final String filter = "filter = 'true'";
1:ec11e82:         Connection con = createConnection("cli1");
1:ec11e82:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", filter, true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         con = createConnection("cli2");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", filter, true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         // send messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageProducer producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:         int sent = 0;
1:ec11e82:         for (int i = 0; i < 10; i++) {
1:ec11e82:             Message message = session.createMessage();
1:ec11e82:             message.setStringProperty("filter", "true");
1:ec11e82:             producer.send(topic, message);
1:ec11e82:             sent++;
1:ec11e82:         }
1:ec11e82: 
1:ec11e82:         LOG.info("sent: " + sent);
1:ec11e82:         Thread.sleep(1 * 1000);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         con = createConnection("cli1");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:57f5d49:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
1:ec11e82:         consumer.setMessageListener(listener);
1:ec11e82:         Thread.sleep(3 * 1000);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         assertEquals(sent, listener.count);
1:ec11e82: 
1:ec11e82:         LOG.info("cli2 pull 2");
1:ec11e82:         con = createConnection("cli2");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:ec11e82:         assertNotNull("got message", consumer.receive(2000));
1:ec11e82:         assertNotNull("got message", consumer.receive(2000));
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         // send messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:         sent = 0;
1:ec11e82:         for (int i = 0; i < 2; i++) {
1:ec11e82:             Message message = session.createMessage();
1:ec11e82:             message.setStringProperty("filter", i==1 ? "true" : "false");
1:ec11e82:             producer.send(topic, message);
1:ec11e82:             sent++;
1:ec11e82:         }
2:ec11e82:         LOG.info("sent: " + sent);
1:ec11e82:         Thread.sleep(1 * 1000);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         LOG.info("cli1 again, should get 1 new ones");
1:ec11e82:         con = createConnection("cli1");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:57f5d49:         listener = new DurableSubscriptionOfflineTestListener();
1:ec11e82:         consumer.setMessageListener(listener);
1:ec11e82:         Thread.sleep(3 * 1000);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         assertEquals(1, listener.count);
1:ec11e82:     }
1:ec11e82: 
1:ec11e82:     // https://issues.apache.org/jira/browse/AMQ-3190
1:57f5d49:     @Test(timeout = 60 * 1000)
1:ec11e82:     public void testNoMissOnMatchingSubAfterRestart() throws Exception {
1:ec11e82: 
1:ec11e82:         final String filter = "filter = 'true'";
1:ec11e82:         Connection con = createConnection("cli1");
1:ec11e82:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
3:ec11e82:         session.createDurableSubscriber(topic, "SubsId", filter, true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         // send unmatched messages
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         MessageProducer producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:         int sent = 0;
1:ec11e82:         // message for cli1 to keep it interested
1:ec11e82:         Message message = session.createMessage();
1:ec11e82:         message.setStringProperty("filter", "true");
1:ec11e82:         message.setIntProperty("ID", 0);
1:ec11e82:         producer.send(topic, message);
1:ec11e82:         sent++;
1:ec11e82: 
1:ec11e82:         for (int i = sent; i < 10; i++) {
1:ec11e82:             message = session.createMessage();
2:ec11e82:             message.setStringProperty("filter", "false");
1:ec11e82:             message.setIntProperty("ID", i);
1:ec11e82:             producer.send(topic, message);
1:ec11e82:             sent++;
1:ec11e82:         }
1:ec11e82:         con.close();
1:ec11e82:         LOG.info("sent: " + sent);
1:ec11e82: 
1:ec11e82:         // new sub at id 10
1:ec11e82:         con = createConnection("cli2");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         session.createDurableSubscriber(topic, "SubsId", filter, true);
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         destroyBroker();
1:ec11e82:         createBroker(false);
1:ec11e82: 
1:ec11e82:         con = createConnection();
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         producer = session.createProducer(null);
1:ec11e82: 
1:ec11e82:         for (int i = sent; i < 30; i++) {
1:ec11e82:             message = session.createMessage();
1:ec11e82:             message.setStringProperty("filter", "true");
1:ec11e82:             message.setIntProperty("ID", i);
1:ec11e82:             producer.send(topic, message);
1:ec11e82:             sent++;
1:ec11e82:         }
1:ec11e82:         con.close();
1:ec11e82:         LOG.info("sent: " + sent);
1:ec11e82: 
1:ec11e82:         // pick up the first of the next twenty messages
1:ec11e82:         con = createConnection("cli2");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
2:ec11e82:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:ec11e82:         Message m = consumer.receive(3000);
1:ec11e82:         assertEquals("is message 10", 10, m.getIntProperty("ID"));
1:ec11e82: 
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82: 
1:ec11e82:         // pick up the first few messages for client1
1:ec11e82:         con = createConnection("cli1");
1:ec11e82:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:ec11e82:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:ec11e82:         m = consumer.receive(3000);
1:ec11e82:         assertEquals("is message 0", 0, m.getIntProperty("ID"));
1:ec11e82:         m = consumer.receive(3000);
1:ec11e82:         assertEquals("is message 10", 10, m.getIntProperty("ID"));
1:ec11e82: 
1:ec11e82:         session.close();
1:ec11e82:         con.close();
1:ec11e82:     }
1:ec11e82: 
1:ec11e82: 
1:4b868f4: //    // https://issues.apache.org/jira/browse/AMQ-3768
1:4b868f4: //    public void testPageReuse() throws Exception {
1:4b868f4: //        Connection con = null;
1:4b868f4: //        Session session = null;
171:4b868f4: //
1:4b868f4: //        final int numConsumers = 115;
1:4b868f4: //        for (int i=0; i<=numConsumers;i++) {
2:4b868f4: //            con = createConnection("cli" + i);
3:4b868f4: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4b868f4: //            session.createDurableSubscriber(topic, "SubsId", null, true);
3:4b868f4: //            session.close();
4:4b868f4: //            con.close();
17:4b868f4: //        }
1:4b868f4: //
1:4b868f4: //        // populate ack locations
12:4b868f4: //        con = createConnection();
25:4b868f4: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
9:4b868f4: //        MessageProducer producer = session.createProducer(null);
1:4b868f4: //        Message message = session.createTextMessage(new byte[10].toString());
1:4b868f4: //        producer.send(topic, message);
33:4b868f4: //        con.close();
1:4b868f4: //
1:4b868f4: //        // we have a split, remove all but the last so that
1:4b868f4: //        // the head pageid changes in the acklocations listindex
1:4b868f4: //        for (int i=0; i<=numConsumers -1; i++) {
1:4b868f4: //            con = createConnection("cli" + i);
1:4b868f4: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4b868f4: //            session.unsubscribe("SubsId");
1:4b868f4: //            session.close();
1:4b868f4: //            con.close();
1:4b868f4: //        }
1:4b868f4: //
1:4b868f4: //        destroyBroker();
1:4b868f4: //        createBroker(false);
1:4b868f4: //
1:4b868f4: //        // create a bunch more subs to reuse the freed page and get us in a knot
1:4b868f4: //        for (int i=1; i<=numConsumers;i++) {
1:4b868f4: //            con = createConnection("cli" + i);
1:4b868f4: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4b868f4: //            session.createDurableSubscriber(topic, "SubsId", filter, true);
1:4b868f4: //            session.close();
1:4b868f4: //            con.close();
1:4b868f4: //        }
20:4b868f4: //    }
1:4b868f4: //
1:4b868f4: //    public void testRedeliveryFlag() throws Exception {
1:4b868f4: //
1:4b868f4: //        Connection con;
1:4b868f4: //        Session session;
1:4b868f4: //        final int numClients = 2;
1:4b868f4: //        for (int i=0; i<numClients; i++) {
1:4b868f4: //            con = createConnection("cliId" + i);
1:4b868f4: //            session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:4b868f4: //            session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:4b868f4: //            session.close();
1:4b868f4: //            con.close();
1:4b868f4: //        }
1:4b868f4: //
1:4b868f4: //        final Random random = new Random();
1:4b868f4: //
10:4b868f4: //        // send messages
1:4b868f4: //        con = createConnection();
1:4b868f4: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4b868f4: //        MessageProducer producer = session.createProducer(null);
1:4b868f4: //
1:4b868f4: //        final int count = 1000;
1:4b868f4: //        for (int i = 0; i < count; i++) {
13:4b868f4: //            Message message = session.createMessage();
5:4b868f4: //            message.setStringProperty("filter", "true");
13:4b868f4: //            producer.send(topic, message);
1:4b868f4: //        }
33:4b868f4: //        session.close();
1:4b868f4: //        con.close();
1:4b868f4: //
1:4b868f4: //        class Client implements Runnable {
1:4b868f4: //            Connection con;
1:4b868f4: //            Session session;
1:4b868f4: //            String clientId;
1:4b868f4: //            Client(String id) {
1:4b868f4: //                this.clientId = id;
7:4b868f4: //            }
1:4b868f4: //
4:4b868f4: //            @Override
2:4b868f4: //            public void run() {
1:4b868f4: //                MessageConsumer consumer = null;
1:4b868f4: //                Message message = null;
1:4b868f4: //
2:4b868f4: //                try {
1:4b868f4: //                    for (int i = -1; i < random.nextInt(10); i++) {
1:4b868f4: //                        // go online and take none
1:4b868f4: //                        con = createConnection(clientId);
1:4b868f4: //                        session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:4b868f4: //                        consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:4b868f4: //                        session.close();
1:4b868f4: //                        con.close();
1:4b868f4: //                    }
1:4b868f4: //
1:4b868f4: //                    // consume 1
1:4b868f4: //                    con = createConnection(clientId);
1:4b868f4: //                    session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:4b868f4: //                    consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:4b868f4: //                    message = consumer.receive(4000);
1:4b868f4: //                    assertNotNull("got message", message);
1:4b868f4: //                    // it is not reliable as it depends on broker dispatch rather than client receipt
1:4b868f4: //                    // and delivered ack
1:4b868f4: //                    //  assertFalse("not redelivered", message.getJMSRedelivered());
1:4b868f4: //                    message.acknowledge();
2:4b868f4: //                    session.close();
2:4b868f4: //                    con.close();
1:4b868f4: //
1:4b868f4: //                    // peek all
1:4b868f4: //                    for (int j = -1; j < random.nextInt(10); j++) {
1:4b868f4: //                        con = createConnection(clientId);
1:4b868f4: //                        session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:4b868f4: //                        consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:4b868f4: //
1:4b868f4: //                        for (int i = 0; i < count - 1; i++) {
1:4b868f4: //                            assertNotNull("got message", consumer.receive(4000));
1:4b868f4: //                        }
1:4b868f4: //                        // no ack
1:4b868f4: //                        session.close();
1:4b868f4: //                        con.close();
1:4b868f4: //                    }
1:4b868f4: //
1:4b868f4: //                    // consume remaining
1:4b868f4: //                    con = createConnection(clientId);
1:4b868f4: //                    session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:4b868f4: //                    consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:4b868f4: //
1:4b868f4: //                    for (int i = 0; i < count - 1; i++) {
1:4b868f4: //                        message = consumer.receive(4000);
1:4b868f4: //                        assertNotNull("got message", message);
1:4b868f4: //                        assertTrue("is redelivered", message.getJMSRedelivered());
3:4b868f4: //                    }
1:4b868f4: //                    message.acknowledge();
1:4b868f4: //                    session.close();
1:4b868f4: //                    con.close();
1:4b868f4: //
1:4b868f4: //                    con = createConnection(clientId);
1:4b868f4: //                    session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:4b868f4: //                    consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:4b868f4: //                    assertNull("no message left", consumer.receive(2000));
1:4b868f4: //                } catch (Throwable throwable) {
1:4b868f4: //                    throwable.printStackTrace();
1:4b868f4: //                    exceptions.add(throwable);
2:4b868f4: //                }
1:4b868f4: //            }
1:4b868f4: //        }
1:4b868f4: //        ExecutorService executorService = Executors.newCachedThreadPool();
1:4b868f4: //        for (int i=0; i<numClients; i++) {
1:4b868f4: //            executorService.execute(new Client("cliId" + i));
1:4b868f4: //        }
1:4b868f4: //        executorService.shutdown();
1:4b868f4: //        executorService.awaitTermination(10, TimeUnit.MINUTES);
1:4b868f4: //        assertTrue("No exceptions expected, but was: " + exceptions, exceptions.isEmpty());
1:4b868f4: //    }
1:ec11e82: 
1:ec11e82: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:0b86397
/////////////////////////////////////////////////////////////////////////
1: import javax.management.openmbean.TabularData;
/////////////////////////////////////////////////////////////////////////
1: 
1:         TabularData tabularData = sub.browseAsTable();
1:         assertNotNull(tabularData);
1:         assertEquals(10, tabularData.size());
1: 
author:Christian Posta
-------------------------------------------------------------------------------
commit:f4f416a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.jmx.DurableSubscriptionViewMBean;
1: import org.apache.activemq.transport.vm.VMTransport;
1: import org.apache.activemq.transport.vm.VMTransportFactory;
1: import org.apache.activemq.transport.vm.VMTransportServer;
/////////////////////////////////////////////////////////////////////////
1: import javax.management.ObjectName;
1: import javax.management.openmbean.CompositeData;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testBrowseOfflineSub() throws Exception {
1:         // create durable subscription
1:         Connection con = createConnection();
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId");
1:         session.close();
1:         con.close();
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         for (int i = 0; i < 10; i++) {
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "true");
1:             producer.send(topic, message);
1:         }
1: 
1:         Thread.sleep(1 * 1000);
1: 
1:         session.close();
1:         con.close();
1: 
1:         // browse the durable sub
1:         ObjectName[] subs = broker.getAdminView().getInactiveDurableTopicSubscribers();
1:         assertEquals(1, subs.length);
1:         ObjectName subName = subs[0];
1:         DurableSubscriptionViewMBean sub = (DurableSubscriptionViewMBean)
1:                 broker.getManagementContext().newProxyInstance(subName, DurableSubscriptionViewMBean.class, true);
1:         CompositeData[] data  = sub.browse();
1:         assertNotNull(data);
1:         assertEquals(10, data.length);
1:     }
author:Kevin Earls
-------------------------------------------------------------------------------
commit:be8990e
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 2 * 60 * 1000)
commit:57f5d49
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1: import org.junit.Ignore;
1: import org.junit.Test;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: import java.util.HashSet;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import static org.junit.Assert.*;
1: public class DurableSubscriptionOfflineTest extends DurableSubscriptionOfflineTestBase {
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testConsumeAllMatchedMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             sent++;
1:             message.setStringProperty("filter", "true");
1:         Thread.sleep(1 * 1000);
1: 
/////////////////////////////////////////////////////////////////////////
1:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         DurableSubscriptionOfflineTestListener listener2 = new DurableSubscriptionOfflineTestListener();
/////////////////////////////////////////////////////////////////////////
1:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:         String filter = "$a='A1' AND (($b=true AND $c=true) OR ($d='D1' OR $d='D2'))";
/////////////////////////////////////////////////////////////////////////
1:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener("SubsId");
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("see https://issues.apache.org/jira/browse/AMQ-4874")
1:     @Test(timeout = 60 * 1000)
1:     public void testOrderOnActivateDeactivate() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                 + (broker.getTransportConnectors().get(1).getConnectUri()).getPort()
1:                 + "?wireFormat.maxInactivityDuration=0)?"
1:                 + "jms.watchTopicAdvisories=false&"
1:                 + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&"
1:                 + "jms.sendAcksAsync=true&"
1:                 + "initialReconnectDelay=100&maxReconnectDelay=30000&"
1:                 + "useExponentialBackOff=true";
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         DurableSubscriptionOfflineTestListener listener = new DurableSubscriptionOfflineTestListener();
/////////////////////////////////////////////////////////////////////////
1:         listener = new DurableSubscriptionOfflineTestListener();
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4f1754b
/////////////////////////////////////////////////////////////////////////
1: 
0:     /*
0:      * Ignoring for now, see https://issues.apache.org/jira/browse/AMQ-4874
1:      */
0:     public void XXXtestOrderOnActivateDeactivate() throws Exception {
/////////////////////////////////////////////////////////////////////////
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:798eb1f
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestOfflineSubscriptionAfterRestart() throws Exception {
commit:ec11e82
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0: import javax.management.ObjectName;
0: import org.apache.activemq.broker.jmx.DurableSubscriptionViewMBean;
0: import org.apache.activemq.broker.jmx.TopicViewMBean;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.disk.page.PageFile;
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestConsumeOnlyMatchedMessages() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
0:         this.addCombinationValues("usePrioritySupport",
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
1:     }
1: 
0:     public void testConsumeOnlyMatchedMessages() throws Exception {
1:         // create durable subscription
1:         Connection con = createConnection();
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int sent = 0;
1:         for (int i = 0; i < 10; i++) {
0:             boolean filter = i % 2 == 1;
1:             if (filter)
1:                 sent++;
1: 
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", filter ? "true" : "false");
1:             producer.send(topic, message);
1:         }
1: 
1:         session.close();
1:         con.close();
1: 
1:         // consume messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
1:         consumer.setMessageListener(listener);
1: 
1:         Thread.sleep(3 * 1000);
1: 
1:         session.close();
1:         con.close();
1: 
1:         assertEquals(sent, listener.count);
1:     }
1: 
0:      public void testConsumeAllMatchedMessages() throws Exception {
1:          // create durable subscription
1:          Connection con = createConnection();
1:          Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:          session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:          session.close();
1:          con.close();
1: 
1:          // send messages
1:          con = createConnection();
1:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:          MessageProducer producer = session.createProducer(null);
1: 
1:          int sent = 0;
1:          for (int i = 0; i < 10; i++) {
1:              sent++;
1:              Message message = session.createMessage();
1:              message.setStringProperty("filter", "true");
1:              producer.send(topic, message);
1:          }
1: 
1:          Thread.sleep(1 * 1000);
1: 
1:          session.close();
1:          con.close();
1: 
1:          // consume messages
1:          con = createConnection();
1:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:          MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          Listener listener = new Listener();
1:          consumer.setMessageListener(listener);
1: 
1:          Thread.sleep(3 * 1000);
1: 
1:          session.close();
1:          con.close();
1: 
1:          assertEquals(sent, listener.count);
1:      }
1: 
0:     public void initCombosForTestVerifyAllConsumedAreAcked() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
0:         this.addCombinationValues("usePrioritySupport",
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
1:     }
1: 
0:      public void testVerifyAllConsumedAreAcked() throws Exception {
1:          // create durable subscription
1:          Connection con = createConnection();
1:          Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:          session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:          session.close();
1:          con.close();
1: 
1:          // send messages
1:          con = createConnection();
1:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:          MessageProducer producer = session.createProducer(null);
1: 
1:          int sent = 0;
1:          for (int i = 0; i < 10; i++) {
1:              sent++;
1:              Message message = session.createMessage();
1:              message.setStringProperty("filter", "true");
1:              producer.send(topic, message);
1:          }
1: 
1:          Thread.sleep(1 * 1000);
1: 
1:          session.close();
1:          con.close();
1: 
1:          // consume messages
1:          con = createConnection();
1:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:          MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          Listener listener = new Listener();
1:          consumer.setMessageListener(listener);
1: 
1:          Thread.sleep(3 * 1000);
1: 
1:          session.close();
1:          con.close();
1: 
0:          LOG.info("Consumed: " + listener.count);
1:          assertEquals(sent, listener.count);
1: 
0:          // consume messages again, should not get any
1:          con = createConnection();
1:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          listener = new Listener();
1:          consumer.setMessageListener(listener);
1: 
1:          Thread.sleep(3 * 1000);
1: 
1:          session.close();
1:          con.close();
1: 
1:          assertEquals(0, listener.count);
1:      }
1: 
1:     public void testTwoOfflineSubscriptionCanConsume() throws Exception {
1:         // create durable subscription 1
1:         Connection con = createConnection("cliId1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         // create durable subscription 2
1:         Connection con2 = createConnection("cliId2");
1:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener2 = new Listener();
1:         consumer2.setMessageListener(listener2);
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int sent = 0;
1:         for (int i = 0; i < 10; i++) {
1:             sent++;
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "true");
1:             producer.send(topic, message);
1:         }
1: 
1:         Thread.sleep(1 * 1000);
1:         session.close();
1:         con.close();
1: 
1:         // test online subs
1:         Thread.sleep(3 * 1000);
1:         session2.close();
1:         con2.close();
1: 
1:         assertEquals(sent, listener2.count);
1: 
1:         // consume messages
1:         con = createConnection("cliId1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
1:         consumer.setMessageListener(listener);
1: 
1:         Thread.sleep(3 * 1000);
1: 
1:         session.close();
1:         con.close();
1: 
1:         assertEquals("offline consumer got all", sent, listener.count);
1:     }
1: 
0:     public void initCombosForTestJMXCountersWithOfflineSubs() throws Exception {
0:         this.addCombinationValues("keepDurableSubsActive",
0:                 new Object[]{Boolean.TRUE, Boolean.FALSE});
1:     }
1: 
0:     public void testJMXCountersWithOfflineSubs() throws Exception {
1:         // create durable subscription 1
1:         Connection con = createConnection("cliId1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", null, true);
1:         session.close();
1:         con.close();
1: 
0:         // restart broker
1:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int sent = 0;
1:         for (int i = 0; i < 10; i++) {
1:             sent++;
1:             Message message = session.createMessage();
1:             producer.send(topic, message);
1:         }
1:         session.close();
1:         con.close();
1: 
0:         // consume some messages
1:         con = createConnection("cliId1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1: 
0:         for (int i=0; i<sent/2; i++) {
0:             Message m =  consumer.receive(4000);
0:             assertNotNull("got message: " + i, m);
0:             LOG.info("Got :" + i + ", " + m);
1:         }
1: 
0:         // check some counters while active
0:         ObjectName activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];
0:         LOG.info("active durable sub name: " + activeDurableSubName);
0:         final DurableSubscriptionViewMBean durableSubscriptionView = (DurableSubscriptionViewMBean)
0:                 broker.getManagementContext().newProxyInstance(activeDurableSubName, DurableSubscriptionViewMBean.class, true);
1: 
0:         assertTrue("is active", durableSubscriptionView.isActive());
0:         assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView.getEnqueueCounter());
0:         assertTrue("correct waiting acks", Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return 5 == durableSubscriptionView.getMessageCountAwaitingAcknowledge();
1:             }
0:         }));
0:         assertEquals("correct dequeue", 5, durableSubscriptionView.getDequeueCounter());
1: 
1: 
0:         ObjectName destinationName = broker.getAdminView().getTopics()[0];
0:         TopicViewMBean topicView = (TopicViewMBean) broker.getManagementContext().newProxyInstance(destinationName, TopicViewMBean.class, true);
0:         assertEquals("correct enqueue", 10, topicView.getEnqueueCount());
0:         assertEquals("still zero dequeue, we don't decrement on each sub ack to stop exceeding the enqueue count with multiple subs", 0, topicView.getDequeueCount());
0:         assertEquals("inflight", 5, topicView.getInFlightCount());
1: 
1:         session.close();
1:         con.close();
1: 
0:         // check some counters when inactive
0:         ObjectName inActiveDurableSubName = broker.getAdminView().getInactiveDurableTopicSubscribers()[0];
0:         LOG.info("inactive durable sub name: " + inActiveDurableSubName);
0:         DurableSubscriptionViewMBean durableSubscriptionView1 = (DurableSubscriptionViewMBean)
0:                 broker.getManagementContext().newProxyInstance(inActiveDurableSubName, DurableSubscriptionViewMBean.class, true);
1: 
0:         assertTrue("is not active", !durableSubscriptionView1.isActive());
0:         assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView1.getEnqueueCounter());
0:         assertEquals("correct awaiting ack", 0, durableSubscriptionView1.getMessageCountAwaitingAcknowledge());
0:         assertEquals("correct dequeue", keepDurableSubsActive ? 5 : 0, durableSubscriptionView1.getDequeueCounter());
1: 
0:         // destination view
0:         assertEquals("correct enqueue", 10, topicView.getEnqueueCount());
0:         assertEquals("still zero dequeue, we don't decrement on each sub ack to stop exceeding the enqueue count with multiple subs", 0, topicView.getDequeueCount());
0:         assertEquals("inflight back to 0 after deactivate", 0, topicView.getInFlightCount());
1: 
0:         // consume the rest
1:         con = createConnection("cliId1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1: 
0:         for (int i=0; i<sent/2;i++) {
0:             Message m =  consumer.receive(30000);
0:             assertNotNull("got message: " + i, m);
0:             LOG.info("Got :" + i + ", " + m);
1:         }
1: 
0:         activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];
0:         LOG.info("durable sub name: " + activeDurableSubName);
0:         final DurableSubscriptionViewMBean durableSubscriptionView2 = (DurableSubscriptionViewMBean)
0:                 broker.getManagementContext().newProxyInstance(activeDurableSubName, DurableSubscriptionViewMBean.class, true);
1: 
0:         assertTrue("is active", durableSubscriptionView2.isActive());
0:         assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView2.getEnqueueCounter());
0:         assertTrue("correct dequeue", Wait.waitFor(new Wait.Condition() {
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 long val = durableSubscriptionView2.getDequeueCounter();
0:                 LOG.info("dequeue count:" + val);
0:                 return 10 == val;
1:             }
0:         }));
1:     }
1: 
0:     public void initCombosForTestOfflineSubscriptionCanConsumeAfterOnlineSubs() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
0:         this.addCombinationValues("usePrioritySupport",
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
1:     }
1: 
0:     public void testOfflineSubscriptionCanConsumeAfterOnlineSubs() throws Exception {
1:         Connection con = createConnection("offCli1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         con = createConnection("offCli2");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
0:         Connection con2 = createConnection("onlineCli1");
1:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener2 = new Listener();
1:         consumer2.setMessageListener(listener2);
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int sent = 0;
1:         for (int i = 0; i < 10; i++) {
1:             sent++;
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "true");
1:             producer.send(topic, message);
1:         }
1: 
1:         Thread.sleep(1 * 1000);
1:         session.close();
1:         con.close();
1: 
1:         // test online subs
1:         Thread.sleep(3 * 1000);
1:         session2.close();
1:         con2.close();
1:         assertEquals(sent, listener2.count);
1: 
0:         // restart broker
1:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
1: 
0:         // test offline
1:         con = createConnection("offCli1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: 
0:         Connection con3 = createConnection("offCli2");
0:         Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: 
0:         Listener listener = new Listener();
1:         consumer.setMessageListener(listener);
0:         Listener listener3 = new Listener();
0:         consumer3.setMessageListener(listener3);
1: 
1:         Thread.sleep(3 * 1000);
1: 
1:         session.close();
1:         con.close();
0:         session3.close();
0:         con3.close();
1: 
1:         assertEquals(sent, listener.count);
0:         assertEquals(sent, listener3.count);
1:     }
1: 
0:     public void initCombosForTestInterleavedOfflineSubscriptionCanConsume() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1:     }
1: 
0:     public void testInterleavedOfflineSubscriptionCanConsume() throws Exception {
1:         // create durable subscription 1
1:         Connection con = createConnection("cliId1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int sent = 0;
1:         for (int i = 0; i < 10; i++) {
1:             sent++;
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "true");
1:             producer.send(topic, message);
1:         }
1: 
1:         Thread.sleep(1 * 1000);
1: 
1:         // create durable subscription 2
1:         Connection con2 = createConnection("cliId2");
1:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener2 = new Listener();
1:         consumer2.setMessageListener(listener2);
1: 
0:         assertEquals(0, listener2.count);
1:         session2.close();
1:         con2.close();
1: 
0:         // send some more
1:         for (int i = 0; i < 10; i++) {
1:             sent++;
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "true");
1:             producer.send(topic, message);
1:         }
1: 
1:         Thread.sleep(1 * 1000);
1:         session.close();
1:         con.close();
1: 
0:         con2 = createConnection("cliId2");
0:         session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         listener2 = new Listener("cliId2");
1:         consumer2.setMessageListener(listener2);
1:         // test online subs
1:         Thread.sleep(3 * 1000);
1: 
0:         assertEquals(10, listener2.count);
1: 
1:         // consume all messages
1:         con = createConnection("cliId1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener("cliId1");
1:         consumer.setMessageListener(listener);
1: 
1:         Thread.sleep(3 * 1000);
1: 
1:         session.close();
1:         con.close();
1: 
1:         assertEquals("offline consumer got all", sent, listener.count);
1:     }
1: 
0:     public void initCombosForTestMixOfOnLineAndOfflineSubsGetAllMatched() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1:     }
1: 
0:     private static String filter = "$a='A1' AND (($b=true AND $c=true) OR ($d='D1' OR $d='D2'))";
0:     public void testMixOfOnLineAndOfflineSubsGetAllMatched() throws Exception {
1:         // create offline subs 1
1:         Connection con = createConnection("offCli1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", filter, true);
1:         session.close();
1:         con.close();
1: 
1:         // create offline subs 2
1:         con = createConnection("offCli2");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", filter, true);
1:         session.close();
1:         con.close();
1: 
0:         // create online subs
0:         Connection con2 = createConnection("onlineCli1");
1:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener2 = new Listener();
1:         consumer2.setMessageListener(listener2);
1: 
0:         // create non-durable consumer
0:         Connection con4 = createConnection("nondurableCli");
0:         Session session4 = con4.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer4 = session4.createConsumer(topic, filter, true);
0:         Listener listener4 = new Listener();
0:         consumer4.setMessageListener(listener4);
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
0:         boolean hasRelevant = false;
1:         int filtered = 0;
0:         for (int i = 0; i < 100; i++) {
0:             int postf = (int) (Math.random() * 9) + 1;
0:             String d = "D" + postf;
1: 
0:             if ("D1".equals(d) || "D2".equals(d)) {
0:                 hasRelevant = true;
1:                 filtered++;
1:             }
1: 
1:             Message message = session.createMessage();
0:             message.setStringProperty("$a", "A1");
0:             message.setStringProperty("$d", d);
1:             producer.send(topic, message);
1:         }
1: 
1:         Message message = session.createMessage();
0:         message.setStringProperty("$a", "A1");
0:         message.setBooleanProperty("$b", true);
0:         message.setBooleanProperty("$c", hasRelevant);
1:         producer.send(topic, message);
1: 
0:         if (hasRelevant)
1:             filtered++;
1: 
1:         Thread.sleep(1 * 1000);
1:         session.close();
1:         con.close();
1: 
1:         Thread.sleep(3 * 1000);
1: 
0:         // test non-durable consumer
0:         session4.close();
0:         con4.close();
0:         assertEquals(filtered, listener4.count); // succeeded!
1: 
1:         // test online subs
1:         session2.close();
1:         con2.close();
0:         assertEquals(filtered, listener2.count); // succeeded!
1: 
0:         // test offline 1
1:         con = createConnection("offCli1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener = new FilterCheckListener();
1:         consumer.setMessageListener(listener);
1: 
1:         Thread.sleep(3 * 1000);
1:         session.close();
1:         con.close();
1: 
0:         assertEquals(filtered, listener.count);
1: 
0:         // test offline 2
0:         Connection con3 = createConnection("offCli2");
0:         Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener3 = new FilterCheckListener();
0:         consumer3.setMessageListener(listener3);
1: 
1:         Thread.sleep(3 * 1000);
0:         session3.close();
0:         con3.close();
1: 
0:         assertEquals(filtered, listener3.count);
0:         assertTrue("no unexpected exceptions: " + exceptions, exceptions.isEmpty());
1:     }
1: 
1:     public void testRemovedDurableSubDeletes() throws Exception {
1:         // create durable subscription 1
1:         Connection con = createConnection("cliId1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         for (int i = 0; i < 10; i++) {
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "true");
1:             producer.send(topic, message);
1:         }
1: 
1:         Thread.sleep(1 * 1000);
1: 
1:         Connection con2 = createConnection("cliId1");
1:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session2.unsubscribe("SubsId");
1:         session2.close();
1:         con2.close();
1: 
1:         // see if retroactive can consumer any
1:         topic = new ActiveMQTopic(topic.getPhysicalName() + "?consumer.retroactive=true");
1:         con = createConnection("offCli2");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener = new Listener();
1:         consumer.setMessageListener(listener);
1:         session.close();
1:         con.close();
1:         assertEquals(0, listener.count);
1:     }
1: 
1:     public void testRemovedDurableSubDeletesFromIndex() throws Exception {
1: 
1:         if (! (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter)) {
1:             return;
1:         }
1: 
1:         final int numMessages = 2750;
1: 
1:         KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
1:         PageFile pageFile = kahaDBPersistenceAdapter.getStore().getPageFile();
1:         LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() + ", fileSize:" + pageFile.getFile().length());
1: 
1:         long lastDiff = 0;
1:         for (int repeats=0; repeats<2; repeats++) {
1: 
1:             LOG.info("Iteration: "+ repeats  + " Count:" + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount());
1: 
1:             Connection con = createConnection("cliId1" + "-" + repeats);
1:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:             session.close();
1:             con.close();
1: 
1:             // send messages
1:             con = createConnection();
1:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             MessageProducer producer = session.createProducer(null);
1: 
1:             for (int i = 0; i < numMessages; i++) {
1:                 Message message = session.createMessage();
1:                 message.setStringProperty("filter", "true");
1:                 producer.send(topic, message);
1:             }
1:             con.close();
1: 
1:             Connection con2 = createConnection("cliId1" + "-" + repeats);
1:             Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session2.unsubscribe("SubsId");
1:             session2.close();
1:             con2.close();
1: 
1:             LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() +  " diff: " + (pageFile.getPageCount() - pageFile.getFreePageCount()) + " fileSize:" + pageFile.getFile().length());
1: 
1:             if (lastDiff != 0) {
1:                 assertEquals("Only use X pages per iteration: " + repeats, lastDiff, pageFile.getPageCount() - pageFile.getFreePageCount());
1:             }
1:             lastDiff = pageFile.getPageCount() - pageFile.getFreePageCount();
1:         }
1:     }
1: 
0:     public void initCombosForTestOfflineSubscriptionWithSelectorAfterRestart() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1:     }
1: 
0:     public void testOfflineSubscriptionWithSelectorAfterRestart() throws Exception {
1: 
0:         if (PersistenceAdapterChoice.LevelDB == defaultPersistenceAdapter) {
0:             // https://issues.apache.org/jira/browse/AMQ-4296
1:             return;
1:         }
1: 
1:         // create offline subs 1
1:         Connection con = createConnection("offCli1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         // create offline subs 2
1:         con = createConnection("offCli2");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int filtered = 0;
1:         for (int i = 0; i < 10; i++) {
1:             boolean filter = (int) (Math.random() * 2) >= 1;
1:             if (filter)
1:                 filtered++;
1: 
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", filter ? "true" : "false");
1:             producer.send(topic, message);
1:         }
1: 
1:         LOG.info("sent: " + filtered);
1:         Thread.sleep(1 * 1000);
1:         session.close();
1:         con.close();
1: 
0:         // restart broker
1:         Thread.sleep(3 * 1000);
1:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
1: 
0:         // send more messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(null);
1: 
1:         for (int i = 0; i < 10; i++) {
1:             boolean filter = (int) (Math.random() * 2) >= 1;
1:             if (filter)
1:                 filtered++;
1: 
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", filter ? "true" : "false");
1:             producer.send(topic, message);
1:         }
1: 
0:         LOG.info("after restart, total sent with filter='true': " + filtered);
1:         Thread.sleep(1 * 1000);
1:         session.close();
1:         con.close();
1: 
1:         // test offline subs
1:         con = createConnection("offCli1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener("1>");
1:         consumer.setMessageListener(listener);
1: 
0:         Connection con3 = createConnection("offCli2");
0:         Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener3 = new Listener();
0:         consumer3.setMessageListener(listener3);
1: 
1:         Thread.sleep(3 * 1000);
1: 
1:         session.close();
1:         con.close();
0:         session3.close();
0:         con3.close();
1: 
0:         assertEquals(filtered, listener.count);
0:         assertEquals(filtered, listener3.count);
1:     }
1: 
0:     public void initCombosForTestOfflineAfterRestart() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1:     }
1: 
0:     public void testOfflineSubscriptionAfterRestart() throws Exception {
1:         // create offline subs 1
1:         Connection con = createConnection("offCli1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, false);
0:         Listener listener = new Listener();
1:         consumer.setMessageListener(listener);
1: 
1:         // send messages
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int sent = 0;
1:         for (int i = 0; i < 10; i++) {
1:             sent++;
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "false");
1:             producer.send(topic, message);
1:         }
1: 
1:         LOG.info("sent: " + sent);
0:         Thread.sleep(5 * 1000);
1:         session.close();
1:         con.close();
1: 
1:         assertEquals(sent, listener.count);
1: 
0:         // restart broker
1:         Thread.sleep(3 * 1000);
1:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
1: 
0:         // send more messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         producer = session.createProducer(null);
1: 
1:         for (int i = 0; i < 10; i++) {
1:             sent++;
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", "false");
1:             producer.send(topic, message);
1:         }
1: 
0:         LOG.info("after restart, sent: " + sent);
1:         Thread.sleep(1 * 1000);
1:         session.close();
1:         con.close();
1: 
1:         // test offline subs
1:         con = createConnection("offCli1");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:         consumer.setMessageListener(listener);
1: 
1:         Thread.sleep(3 * 1000);
1: 
1:         session.close();
1:         con.close();
1: 
1:         assertEquals(sent, listener.count);
1:     }
1: 
1:     public void testInterleavedOfflineSubscriptionCanConsumeAfterUnsub() throws Exception {
1:         // create offline subs 1
1:         Connection con = createConnection("offCli1");
1:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1:         session.close();
1:         con.close();
1: 
1:         // create offline subs 2
1:         con = createConnection("offCli2");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", null, true);
1:         session.close();
1:         con.close();
1: 
1:         // send messages
1:         con = createConnection();
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageProducer producer = session.createProducer(null);
1: 
1:         int sent = 0;
1:         for (int i = 0; i < 10; i++) {
1:             boolean filter = (int) (Math.random() * 2) >= 1;
1: 
1:             sent++;
1: 
1:             Message message = session.createMessage();
1:             message.setStringProperty("filter", filter ? "true" : "false");
1:             producer.send(topic, message);
1:         }
1: 
1:         Thread.sleep(1 * 1000);
1: 
1:         Connection con2 = createConnection("offCli1");
1:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session2.unsubscribe("SubsId");
1:         session2.close();
1:         con2.close();
1: 
1:         // consume all messages
1:         con = createConnection("offCli2");
1:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0:         Listener listener = new Listener("SubsId");
1:         consumer.setMessageListener(listener);
1: 
1:         Thread.sleep(3 * 1000);
1: 
1:         session.close();
1:         con.close();
1: 
1:         assertEquals("offline consumer got all", sent, listener.count);
1:     }
1: 
1:     public void testNoDuplicateOnConcurrentSendTranCommitAndActivate() throws Exception {
1:         final int messageCount = 1000;
1:         Connection con = null;
1:         Session session = null;
1:         final int numConsumers = 10;
1:         for (int i = 0; i <= numConsumers; i++) {
1:             con = createConnection("cli" + i);
1:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             session.createDurableSubscriber(topic, "SubsId", null, true);
1:             session.close();
1:             con.close();
1:         }
1: 
1:         class CheckForDupsClient implements Runnable {
1:             HashSet<Long> ids = new HashSet<Long>();
1:             final int id;
1: 
1:             public CheckForDupsClient(int id) {
1:                 this.id = id;
1:             }
1: 
1:             @Override
1:             public void run() {
1:                 try {
1:                     Connection con = createConnection("cli" + id);
1:                     Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                     for (int j=0;j<2;j++) {
1:                         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:                         for (int i = 0; i < messageCount/2; i++) {
1:                             Message message = consumer.receive(4000);
1:                             assertNotNull(message);
1:                             long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
1:                             assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
1:                         }
1:                         consumer.close();
1:                     }
1: 
1:                     // verify no duplicates left
1:                     MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:                     Message message = consumer.receive(4000);
1:                     if (message != null) {
1:                         long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
1:                         assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
1:                     }
1:                     assertNull(message);
1: 
1: 
1:                     session.close();
1:                     con.close();
1:                 } catch (Throwable e) {
1:                     e.printStackTrace();
1:                     exceptions.add(e);
1:                 }
1:             }
1:         }
1: 
1:         final String payLoad = new String(new byte[1000]);
1:         con = createConnection();
1:         final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);
1:         MessageProducer producer = sendSession.createProducer(topic);
1:         for (int i = 0; i < messageCount; i++) {
1:             producer.send(sendSession.createTextMessage(payLoad));
1:         }
1: 
1:         ExecutorService executorService = Executors.newCachedThreadPool();
1: 
1:         // concurrent commit and activate
1:         executorService.execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     sendSession.commit();
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                     exceptions.add(e);
1:                 }
1:             }
1:         });
1:         for (int i = 0; i < numConsumers; i++) {
1:             executorService.execute(new CheckForDupsClient(i));
1:         }
1: 
1:         executorService.shutdown();
1:         executorService.awaitTermination(5, TimeUnit.MINUTES);
1:         con.close();
1: 
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:     }
1: 
0:     public void testOrderOnActivateDeactivate() throws Exception {
1:         for (int i=0;i<10;i++) {
1:             LOG.info("Iteration: " + i);
1:             doTestOrderOnActivateDeactivate();
1:             broker.stop();
1:             createBroker(true /*deleteAllMessages*/);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public void testUnmatchedSubUnsubscribeDeletesAll() throws Exception {
0:         // create offline subs 1
0:         Connection con = createConnection("offCli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int filtered = 0;
0:         for (int i = 0; i < 10; i++) {
1:             boolean filter = (i %2 == 0); //(int) (Math.random() * 2) >= 1;
0:             if (filter)
0:                 filtered++;
0: 
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", filter ? "true" : "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         LOG.info("sent: " + filtered);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         // test offline subs
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.unsubscribe("SubsId");
0:         session.close();
0:         con.close();
0: 
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(0, listener.count);
0:     }
0: 
1:     public void testAllConsumed() throws Exception {
1:         final String filter = "filter = 'true'";
1:         Connection con = createConnection("cli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
1:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:             sent++;
0:         }
0: 
1:         LOG.info("sent: " + sent);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
1:         con = createConnection("cli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Thread.sleep(3 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(sent, listener.count);
0: 
1:         LOG.info("cli2 pull 2");
1:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:         assertNotNull("got message", consumer.receive(2000));
1:         assertNotNull("got message", consumer.receive(2000));
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         producer = session.createProducer(null);
0: 
1:         sent = 0;
1:         for (int i = 0; i < 2; i++) {
0:             Message message = session.createMessage();
1:             message.setStringProperty("filter", i==1 ? "true" : "false");
0:             producer.send(topic, message);
0:             sent++;
0:         }
1:         LOG.info("sent: " + sent);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
1:         LOG.info("cli1 again, should get 1 new ones");
1:         con = createConnection("cli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Thread.sleep(3 * 1000);
0:         session.close();
0:         con.close();
0: 
1:         assertEquals(1, listener.count);
0:     }
0: 
1:     // https://issues.apache.org/jira/browse/AMQ-3190
1:     public void testNoMissOnMatchingSubAfterRestart() throws Exception {
0: 
1:         final String filter = "filter = 'true'";
1:         Connection con = createConnection("cli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
1:         // send unmatched messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
1:         // message for cli1 to keep it interested
0:         Message message = session.createMessage();
0:         message.setStringProperty("filter", "true");
1:         message.setIntProperty("ID", 0);
0:         producer.send(topic, message);
0:         sent++;
0: 
1:         for (int i = sent; i < 10; i++) {
1:             message = session.createMessage();
0:             message.setStringProperty("filter", "false");
1:             message.setIntProperty("ID", i);
0:             producer.send(topic, message);
0:             sent++;
0:         }
0:         con.close();
1:         LOG.info("sent: " + sent);
0: 
1:         // new sub at id 10
1:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
1:         destroyBroker();
1:         createBroker(false);
0: 
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         producer = session.createProducer(null);
0: 
1:         for (int i = sent; i < 30; i++) {
1:             message = session.createMessage();
0:             message.setStringProperty("filter", "true");
1:             message.setIntProperty("ID", i);
0:             producer.send(topic, message);
0:             sent++;
0:         }
0:         con.close();
1:         LOG.info("sent: " + sent);
0: 
1:         // pick up the first of the next twenty messages
1:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:         Message m = consumer.receive(3000);
1:         assertEquals("is message 10", 10, m.getIntProperty("ID"));
0: 
0:         session.close();
0:         con.close();
0: 
1:         // pick up the first few messages for client1
1:         con = createConnection("cli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
1:         m = consumer.receive(3000);
1:         assertEquals("is message 0", 0, m.getIntProperty("ID"));
1:         m = consumer.receive(3000);
1:         assertEquals("is message 10", 10, m.getIntProperty("ID"));
0: 
0:         session.close();
0:         con.close();
0:     }
commit:4b868f4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: //    public void initCombosForTestConsumeOnlyMatchedMessages() throws Exception {
0: //        this.addCombinationValues("defaultPersistenceAdapter",
0: //                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
0: //        this.addCombinationValues("usePrioritySupport",
0: //                new Object[]{ Boolean.TRUE, Boolean.FALSE});
1: //    }
1: //
0: //    public void testConsumeOnlyMatchedMessages() throws Exception {
0: //        // create durable subscription
0: //        Connection con = createConnection();
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            boolean filter = i % 2 == 1;
0: //            if (filter)
0: //                sent++;
1: //
1: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", filter ? "true" : "false");
1: //            producer.send(topic, message);
1: //        }
1: //
1: //        session.close();
1: //        con.close();
1: //
0: //        // consume messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener = new Listener();
0: //        consumer.setMessageListener(listener);
1: //
0: //        Thread.sleep(3 * 1000);
1: //
1: //        session.close();
1: //        con.close();
1: //
0: //        assertEquals(sent, listener.count);
1: //    }
1: //
0: //     public void testConsumeAllMatchedMessages() throws Exception {
0: //         // create durable subscription
0: //         Connection con = createConnection();
0: //         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //         session.close();
0: //         con.close();
1: //
0: //         // send messages
0: //         con = createConnection();
0: //         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //         MessageProducer producer = session.createProducer(null);
1: //
0: //         int sent = 0;
0: //         for (int i = 0; i < 10; i++) {
0: //             sent++;
0: //             Message message = session.createMessage();
0: //             message.setStringProperty("filter", "true");
0: //             producer.send(topic, message);
0: //         }
1: //
0: //         Thread.sleep(1 * 1000);
1: //
0: //         session.close();
0: //         con.close();
1: //
0: //         // consume messages
0: //         con = createConnection();
0: //         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //         Listener listener = new Listener();
0: //         consumer.setMessageListener(listener);
1: //
0: //         Thread.sleep(3 * 1000);
1: //
0: //         session.close();
0: //         con.close();
1: //
0: //         assertEquals(sent, listener.count);
0: //     }
1: //
0: //    public void initCombosForTestVerifyAllConsumedAreAcked() throws Exception {
0: //        this.addCombinationValues("defaultPersistenceAdapter",
0: //               new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
0: //        this.addCombinationValues("usePrioritySupport",
0: //                new Object[]{ Boolean.TRUE, Boolean.FALSE});
1: //    }
1: //
0: //     public void testVerifyAllConsumedAreAcked() throws Exception {
0: //         // create durable subscription
0: //         Connection con = createConnection();
0: //         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //         session.close();
0: //         con.close();
1: //
0: //         // send messages
0: //         con = createConnection();
0: //         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //         MessageProducer producer = session.createProducer(null);
1: //
0: //         int sent = 0;
0: //         for (int i = 0; i < 10; i++) {
0: //             sent++;
0: //             Message message = session.createMessage();
0: //             message.setStringProperty("filter", "true");
0: //             producer.send(topic, message);
0: //         }
1: //
0: //         Thread.sleep(1 * 1000);
1: //
0: //         session.close();
0: //         con.close();
1: //
0: //         // consume messages
0: //         con = createConnection();
0: //         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //         Listener listener = new Listener();
0: //         consumer.setMessageListener(listener);
1: //
0: //         Thread.sleep(3 * 1000);
1: //
0: //         session.close();
0: //         con.close();
1: //
0: //         LOG.info("Consumed: " + listener.count);
0: //         assertEquals(sent, listener.count);
1: //
0: //         // consume messages again, should not get any
0: //         con = createConnection();
0: //         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //         consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //         listener = new Listener();
0: //         consumer.setMessageListener(listener);
1: //
0: //         Thread.sleep(3 * 1000);
1: //
0: //         session.close();
0: //         con.close();
1: //
0: //         assertEquals(0, listener.count);
0: //     }
1: //
0: //    public void testTwoOfflineSubscriptionCanConsume() throws Exception {
0: //        // create durable subscription 1
0: //        Connection con = createConnection("cliId1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
0: //        // create durable subscription 2
0: //        Connection con2 = createConnection("cliId2");
0: //        Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener2 = new Listener();
0: //        consumer2.setMessageListener(listener2);
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            sent++;
1: //            Message message = session.createMessage();
1: //            message.setStringProperty("filter", "true");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        Thread.sleep(1 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        // test online subs
0: //        Thread.sleep(3 * 1000);
0: //        session2.close();
0: //        con2.close();
1: //
0: //        assertEquals(sent, listener2.count);
1: //
0: //        // consume messages
0: //        con = createConnection("cliId1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener = new Listener();
0: //        consumer.setMessageListener(listener);
1: //
0: //        Thread.sleep(3 * 1000);
1: //
1: //        session.close();
1: //        con.close();
1: //
0: //        assertEquals("offline consumer got all", sent, listener.count);
1: //    }
1: //
0: //    public void initCombosForTestJMXCountersWithOfflineSubs() throws Exception {
0: //        this.addCombinationValues("keepDurableSubsActive",
0: //                new Object[]{Boolean.TRUE, Boolean.FALSE});
1: //    }
1: //
0: //    public void testJMXCountersWithOfflineSubs() throws Exception {
0: //        // create durable subscription 1
0: //        Connection con = createConnection("cliId1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", null, true);
1: //        session.close();
1: //        con.close();
1: //
0: //        // restart broker
0: //        broker.stop();
0: //        createBroker(false /*deleteAllMessages*/);
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            sent++;
1: //            Message message = session.createMessage();
1: //            producer.send(topic, message);
1: //        }
1: //        session.close();
1: //        con.close();
1: //
0: //        // consume some messages
0: //        con = createConnection("cliId1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1: //
0: //        for (int i=0; i<sent/2; i++) {
0: //            Message m =  consumer.receive(4000);
0: //            assertNotNull("got message: " + i, m);
0: //            LOG.info("Got :" + i + ", " + m);
1: //        }
1: //
0: //        // check some counters while active
0: //        ObjectName activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];
0: //        LOG.info("active durable sub name: " + activeDurableSubName);
0: //        final DurableSubscriptionViewMBean durableSubscriptionView = (DurableSubscriptionViewMBean)
0: //                broker.getManagementContext().newProxyInstance(activeDurableSubName, DurableSubscriptionViewMBean.class, true);
1: //
0: //        assertTrue("is active", durableSubscriptionView.isActive());
0: //        assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView.getEnqueueCounter());
0: //        assertTrue("correct waiting acks", Wait.waitFor(new Wait.Condition() {
1: //            @Override
0: //            public boolean isSatisified() throws Exception {
0: //                return 5 == durableSubscriptionView.getMessageCountAwaitingAcknowledge();
1: //            }
0: //        }));
0: //        assertEquals("correct dequeue", 5, durableSubscriptionView.getDequeueCounter());
1: //
1: //
0: //        ObjectName destinationName = broker.getAdminView().getTopics()[0];
0: //        TopicViewMBean topicView = (TopicViewMBean) broker.getManagementContext().newProxyInstance(destinationName, TopicViewMBean.class, true);
0: //        assertEquals("correct enqueue", 10, topicView.getEnqueueCount());
0: //        assertEquals("still zero dequeue, we don't decrement on each sub ack to stop exceeding the enqueue count with multiple subs", 0, topicView.getDequeueCount());
0: //        assertEquals("inflight", 5, topicView.getInFlightCount());
1: //
1: //        session.close();
1: //        con.close();
1: //
0: //        // check some counters when inactive
0: //        ObjectName inActiveDurableSubName = broker.getAdminView().getInactiveDurableTopicSubscribers()[0];
0: //        LOG.info("inactive durable sub name: " + inActiveDurableSubName);
0: //        DurableSubscriptionViewMBean durableSubscriptionView1 = (DurableSubscriptionViewMBean)
0: //                broker.getManagementContext().newProxyInstance(inActiveDurableSubName, DurableSubscriptionViewMBean.class, true);
1: //
0: //        assertTrue("is not active", !durableSubscriptionView1.isActive());
0: //        assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView1.getEnqueueCounter());
0: //        assertEquals("correct awaiting ack", 0, durableSubscriptionView1.getMessageCountAwaitingAcknowledge());
0: //        assertEquals("correct dequeue", keepDurableSubsActive ? 5 : 0, durableSubscriptionView1.getDequeueCounter());
1: //
0: //        // destination view
0: //        assertEquals("correct enqueue", 10, topicView.getEnqueueCount());
0: //        assertEquals("still zero dequeue, we don't decrement on each sub ack to stop exceeding the enqueue count with multiple subs", 0, topicView.getDequeueCount());
0: //        assertEquals("inflight back to 0 after deactivate", 0, topicView.getInFlightCount());
1: //
0: //        // consume the rest
0: //        con = createConnection("cliId1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1: //
0: //        for (int i=0; i<sent/2;i++) {
0: //            Message m =  consumer.receive(30000);
0: //            assertNotNull("got message: " + i, m);
0: //            LOG.info("Got :" + i + ", " + m);
1: //        }
1: //
0: //        activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];
0: //        LOG.info("durable sub name: " + activeDurableSubName);
0: //        final DurableSubscriptionViewMBean durableSubscriptionView2 = (DurableSubscriptionViewMBean)
0: //                broker.getManagementContext().newProxyInstance(activeDurableSubName, DurableSubscriptionViewMBean.class, true);
1: //
0: //        assertTrue("is active", durableSubscriptionView2.isActive());
0: //        assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView2.getEnqueueCounter());
0: //        assertTrue("correct dequeue", Wait.waitFor(new Wait.Condition() {
1: //            @Override
0: //            public boolean isSatisified() throws Exception {
0: //                long val = durableSubscriptionView2.getDequeueCounter();
0: //                LOG.info("dequeue count:" + val);
0: //                return 10 == val;
1: //            }
0: //        }));
1: //    }
1: //
0: //    public void initCombosForTestOfflineSubscriptionCanConsumeAfterOnlineSubs() throws Exception {
0: //        this.addCombinationValues("defaultPersistenceAdapter",
0: //                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
0: //        this.addCombinationValues("usePrioritySupport",
0: //                new Object[]{ Boolean.TRUE, Boolean.FALSE});
1: //    }
1: //
0: //    public void testOfflineSubscriptionCanConsumeAfterOnlineSubs() throws Exception {
0: //        Connection con = createConnection("offCli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
0: //        con = createConnection("offCli2");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
0: //        Connection con2 = createConnection("onlineCli1");
0: //        Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener2 = new Listener();
0: //        consumer2.setMessageListener(listener2);
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            sent++;
1: //            Message message = session.createMessage();
1: //            message.setStringProperty("filter", "true");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        Thread.sleep(1 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        // test online subs
0: //        Thread.sleep(3 * 1000);
0: //        session2.close();
0: //        con2.close();
0: //        assertEquals(sent, listener2.count);
1: //
0: //        // restart broker
0: //        broker.stop();
0: //        createBroker(false /*deleteAllMessages*/);
1: //
0: //        // test offline
0: //        con = createConnection("offCli1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //
0: //        Connection con3 = createConnection("offCli2");
0: //        Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //
0: //        Listener listener = new Listener();
0: //        consumer.setMessageListener(listener);
0: //        Listener listener3 = new Listener();
0: //        consumer3.setMessageListener(listener3);
1: //
0: //        Thread.sleep(3 * 1000);
1: //
1: //        session.close();
1: //        con.close();
0: //        session3.close();
0: //        con3.close();
1: //
0: //        assertEquals(sent, listener.count);
0: //        assertEquals(sent, listener3.count);
1: //    }
1: //
0: //    public void initCombosForTestInterleavedOfflineSubscriptionCanConsume() throws Exception {
0: //        this.addCombinationValues("defaultPersistenceAdapter",
0: //                new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1: //    }
1: //
0: //    public void testInterleavedOfflineSubscriptionCanConsume() throws Exception {
0: //        // create durable subscription 1
0: //        Connection con = createConnection("cliId1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            sent++;
1: //            Message message = session.createMessage();
1: //            message.setStringProperty("filter", "true");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        Thread.sleep(1 * 1000);
1: //
0: //        // create durable subscription 2
0: //        Connection con2 = createConnection("cliId2");
0: //        Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener2 = new Listener();
0: //        consumer2.setMessageListener(listener2);
1: //
0: //        assertEquals(0, listener2.count);
0: //        session2.close();
0: //        con2.close();
1: //
0: //        // send some more
0: //        for (int i = 0; i < 10; i++) {
0: //            sent++;
1: //            Message message = session.createMessage();
1: //            message.setStringProperty("filter", "true");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        Thread.sleep(1 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        con2 = createConnection("cliId2");
0: //        session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        listener2 = new Listener("cliId2");
0: //        consumer2.setMessageListener(listener2);
0: //        // test online subs
0: //        Thread.sleep(3 * 1000);
1: //
0: //        assertEquals(10, listener2.count);
1: //
0: //        // consume all messages
0: //        con = createConnection("cliId1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener = new Listener("cliId1");
0: //        consumer.setMessageListener(listener);
1: //
0: //        Thread.sleep(3 * 1000);
1: //
1: //        session.close();
1: //        con.close();
1: //
0: //        assertEquals("offline consumer got all", sent, listener.count);
1: //    }
1: //
0: //    public void initCombosForTestMixOfOnLineAndOfflineSubsGetAllMatched() throws Exception {
0: //        this.addCombinationValues("defaultPersistenceAdapter",
0: //                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1: //    }
1: //
0: //    private static String filter = "$a='A1' AND (($b=true AND $c=true) OR ($d='D1' OR $d='D2'))";
0: //    public void testMixOfOnLineAndOfflineSubsGetAllMatched() throws Exception {
0: //        // create offline subs 1
0: //        Connection con = createConnection("offCli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", filter, true);
1: //        session.close();
1: //        con.close();
1: //
0: //        // create offline subs 2
0: //        con = createConnection("offCli2");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", filter, true);
1: //        session.close();
1: //        con.close();
1: //
0: //        // create online subs
0: //        Connection con2 = createConnection("onlineCli1");
0: //        Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        Listener listener2 = new Listener();
0: //        consumer2.setMessageListener(listener2);
1: //
0: //        // create non-durable consumer
0: //        Connection con4 = createConnection("nondurableCli");
0: //        Session session4 = con4.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer4 = session4.createConsumer(topic, filter, true);
0: //        Listener listener4 = new Listener();
0: //        consumer4.setMessageListener(listener4);
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        boolean hasRelevant = false;
0: //        int filtered = 0;
0: //        for (int i = 0; i < 100; i++) {
0: //            int postf = (int) (Math.random() * 9) + 1;
0: //            String d = "D" + postf;
1: //
0: //            if ("D1".equals(d) || "D2".equals(d)) {
0: //                hasRelevant = true;
0: //                filtered++;
1: //            }
1: //
1: //            Message message = session.createMessage();
0: //            message.setStringProperty("$a", "A1");
0: //            message.setStringProperty("$d", d);
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        Message message = session.createMessage();
0: //        message.setStringProperty("$a", "A1");
0: //        message.setBooleanProperty("$b", true);
0: //        message.setBooleanProperty("$c", hasRelevant);
1: //        producer.send(topic, message);
1: //
0: //        if (hasRelevant)
0: //            filtered++;
1: //
0: //        Thread.sleep(1 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        Thread.sleep(3 * 1000);
1: //
0: //        // test non-durable consumer
0: //        session4.close();
0: //        con4.close();
0: //        assertEquals(filtered, listener4.count); // succeeded!
1: //
0: //        // test online subs
0: //        session2.close();
0: //        con2.close();
0: //        assertEquals(filtered, listener2.count); // succeeded!
1: //
0: //        // test offline 1
0: //        con = createConnection("offCli1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        Listener listener = new FilterCheckListener();
0: //        consumer.setMessageListener(listener);
1: //
0: //        Thread.sleep(3 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        assertEquals(filtered, listener.count);
1: //
0: //        // test offline 2
0: //        Connection con3 = createConnection("offCli2");
0: //        Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        Listener listener3 = new FilterCheckListener();
0: //        consumer3.setMessageListener(listener3);
1: //
0: //        Thread.sleep(3 * 1000);
0: //        session3.close();
0: //        con3.close();
1: //
0: //        assertEquals(filtered, listener3.count);
0: //        assertTrue("no unexpected exceptions: " + exceptions, exceptions.isEmpty());
1: //    }
1: //
0: //    public void testRemovedDurableSubDeletes() throws Exception {
0: //        // create durable subscription 1
0: //        Connection con = createConnection("cliId1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        for (int i = 0; i < 10; i++) {
1: //            Message message = session.createMessage();
1: //            message.setStringProperty("filter", "true");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        Thread.sleep(1 * 1000);
1: //
0: //        Connection con2 = createConnection("cliId1");
0: //        Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session2.unsubscribe("SubsId");
0: //        session2.close();
0: //        con2.close();
1: //
0: //        // see if retroactive can consumer any
0: //        topic = new ActiveMQTopic(topic.getPhysicalName() + "?consumer.retroactive=true");
0: //        con = createConnection("offCli2");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        Listener listener = new Listener();
0: //        consumer.setMessageListener(listener);
1: //        session.close();
1: //        con.close();
0: //        assertEquals(0, listener.count);
1: //    }
1: //
0: //    public void testRemovedDurableSubDeletesFromIndex() throws Exception {
1: //
0: //        if (! (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter)) {
0: //            return;
1: //        }
1: //
0: //        final int numMessages = 2750;
1: //
0: //        KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
0: //        PageFile pageFile = kahaDBPersistenceAdapter.getStore().getPageFile();
0: //        LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() + ", fileSize:" + pageFile.getFile().length());
1: //
0: //        long lastDiff = 0;
0: //        for (int repeats=0; repeats<2; repeats++) {
1: //
0: //            LOG.info("Iteration: "+ repeats  + " Count:" + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount());
1: //
0: //            Connection con = createConnection("cliId1" + "-" + repeats);
0: //            Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //            session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //            session.close();
1: //            con.close();
1: //
0: //            // send messages
0: //            con = createConnection();
1: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //            MessageProducer producer = session.createProducer(null);
1: //
0: //            for (int i = 0; i < numMessages; i++) {
0: //                Message message = session.createMessage();
0: //                message.setStringProperty("filter", "true");
0: //                producer.send(topic, message);
1: //            }
1: //            con.close();
1: //
0: //            Connection con2 = createConnection("cliId1" + "-" + repeats);
0: //            Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //            session2.unsubscribe("SubsId");
0: //            session2.close();
0: //            con2.close();
1: //
0: //            LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() +  " diff: " + (pageFile.getPageCount() - pageFile.getFreePageCount()) + " fileSize:" + pageFile.getFile().length());
1: //
0: //            if (lastDiff != 0) {
0: //                assertEquals("Only use X pages per iteration: " + repeats, lastDiff, pageFile.getPageCount() - pageFile.getFreePageCount());
1: //            }
0: //            lastDiff = pageFile.getPageCount() - pageFile.getFreePageCount();
1: //        }
1: //    }
1: //
0: //    public void initCombosForTestOfflineSubscriptionWithSelectorAfterRestart() throws Exception {
0: //        this.addCombinationValues("defaultPersistenceAdapter",
0: //                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1: //    }
1: //
0: //    public void testOfflineSubscriptionWithSelectorAfterRestart() throws Exception {
1: //
0: //        if (PersistenceAdapterChoice.LevelDB == defaultPersistenceAdapter) {
0: //            // https://issues.apache.org/jira/browse/AMQ-4296
0: //            return;
1: //        }
1: //
0: //        // create offline subs 1
0: //        Connection con = createConnection("offCli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
0: //        // create offline subs 2
0: //        con = createConnection("offCli2");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int filtered = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            boolean filter = (int) (Math.random() * 2) >= 1;
0: //            if (filter)
0: //                filtered++;
1: //
1: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", filter ? "true" : "false");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        LOG.info("sent: " + filtered);
0: //        Thread.sleep(1 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        // restart broker
0: //        Thread.sleep(3 * 1000);
0: //        broker.stop();
0: //        createBroker(false /*deleteAllMessages*/);
1: //
0: //        // send more messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        producer = session.createProducer(null);
1: //
0: //        for (int i = 0; i < 10; i++) {
0: //            boolean filter = (int) (Math.random() * 2) >= 1;
0: //            if (filter)
0: //                filtered++;
1: //
1: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", filter ? "true" : "false");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        LOG.info("after restart, total sent with filter='true': " + filtered);
0: //        Thread.sleep(1 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        // test offline subs
0: //        con = createConnection("offCli1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener = new Listener("1>");
0: //        consumer.setMessageListener(listener);
1: //
0: //        Connection con3 = createConnection("offCli2");
0: //        Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener3 = new Listener();
0: //        consumer3.setMessageListener(listener3);
1: //
0: //        Thread.sleep(3 * 1000);
1: //
1: //        session.close();
1: //        con.close();
0: //        session3.close();
0: //        con3.close();
1: //
0: //        assertEquals(filtered, listener.count);
0: //        assertEquals(filtered, listener3.count);
1: //    }
1: //
0: //    public void initCombosForTestOfflineAfterRestart() throws Exception {
0: //        this.addCombinationValues("defaultPersistenceAdapter",
0: //                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
1: //    }
1: //
0: //    public void testOfflineSubscriptionAfterRestart() throws Exception {
0: //        // create offline subs 1
0: //        Connection con = createConnection("offCli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, false);
0: //        Listener listener = new Listener();
0: //        consumer.setMessageListener(listener);
1: //
1: //        // send messages
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            sent++;
1: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", "false");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        LOG.info("sent: " + sent);
0: //        Thread.sleep(5 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        assertEquals(sent, listener.count);
1: //
0: //        // restart broker
0: //        Thread.sleep(3 * 1000);
0: //        broker.stop();
0: //        createBroker(false /*deleteAllMessages*/);
1: //
0: //        // send more messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        producer = session.createProducer(null);
1: //
0: //        for (int i = 0; i < 10; i++) {
0: //            sent++;
1: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", "false");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        LOG.info("after restart, sent: " + sent);
0: //        Thread.sleep(1 * 1000);
1: //        session.close();
1: //        con.close();
1: //
0: //        // test offline subs
0: //        con = createConnection("offCli1");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0: //        consumer.setMessageListener(listener);
1: //
0: //        Thread.sleep(3 * 1000);
1: //
1: //        session.close();
1: //        con.close();
1: //
0: //        assertEquals(sent, listener.count);
1: //    }
1: //
0: //    public void testInterleavedOfflineSubscriptionCanConsumeAfterUnsub() throws Exception {
0: //        // create offline subs 1
0: //        Connection con = createConnection("offCli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //        session.close();
1: //        con.close();
1: //
0: //        // create offline subs 2
0: //        con = createConnection("offCli2");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", null, true);
1: //        session.close();
1: //        con.close();
1: //
1: //        // send messages
1: //        con = createConnection();
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //        MessageProducer producer = session.createProducer(null);
1: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            boolean filter = (int) (Math.random() * 2) >= 1;
1: //
0: //            sent++;
1: //
1: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", filter ? "true" : "false");
1: //            producer.send(topic, message);
1: //        }
1: //
0: //        Thread.sleep(1 * 1000);
1: //
0: //        Connection con2 = createConnection("offCli1");
0: //        Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session2.unsubscribe("SubsId");
0: //        session2.close();
0: //        con2.close();
1: //
0: //        // consume all messages
0: //        con = createConnection("offCli2");
1: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0: //        Listener listener = new Listener("SubsId");
0: //        consumer.setMessageListener(listener);
1: //
0: //        Thread.sleep(3 * 1000);
1: //
1: //        session.close();
1: //        con.close();
1: //
0: //        assertEquals("offline consumer got all", sent, listener.count);
1: //    }
1: //
0: //    public void testNoDuplicateOnConcurrentSendTranCommitAndActivate() throws Exception {
0: //        final int messageCount = 1000;
1: //        Connection con = null;
1: //        Session session = null;
0: //        final int numConsumers = 10;
0: //        for (int i = 0; i <= numConsumers; i++) {
1: //            con = createConnection("cli" + i);
1: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //            session.createDurableSubscriber(topic, "SubsId", null, true);
1: //            session.close();
1: //            con.close();
1: //        }
1: //
0: //        class CheckForDupsClient implements Runnable {
0: //            HashSet<Long> ids = new HashSet<Long>();
0: //            final int id;
1: //
0: //            public CheckForDupsClient(int id) {
0: //                this.id = id;
1: //            }
1: //
1: //            @Override
1: //            public void run() {
1: //                try {
0: //                    Connection con = createConnection("cli" + id);
0: //                    Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //                    for (int j=0;j<2;j++) {
0: //                        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0: //                        for (int i = 0; i < messageCount/2; i++) {
0: //                            Message message = consumer.receive(4000);
0: //                            assertNotNull(message);
0: //                            long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
0: //                            assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
1: //                        }
0: //                        consumer.close();
1: //                    }
1: //
0: //                    // verify no duplicates left
0: //                    MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0: //                    Message message = consumer.receive(4000);
0: //                    if (message != null) {
0: //                        long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
0: //                        assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
1: //                    }
0: //                    assertNull(message);
1: //
1: //
1: //                    session.close();
1: //                    con.close();
0: //                } catch (Throwable e) {
0: //                    e.printStackTrace();
0: //                    exceptions.add(e);
1: //                }
1: //            }
1: //        }
1: //
0: //        final String payLoad = new String(new byte[1000]);
1: //        con = createConnection();
0: //        final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);
0: //        MessageProducer producer = sendSession.createProducer(topic);
0: //        for (int i = 0; i < messageCount; i++) {
0: //            producer.send(sendSession.createTextMessage(payLoad));
1: //        }
1: //
1: //        ExecutorService executorService = Executors.newCachedThreadPool();
1: //
0: //        // concurrent commit and activate
0: //        executorService.execute(new Runnable() {
1: //            @Override
1: //            public void run() {
1: //                try {
0: //                    sendSession.commit();
0: //                } catch (JMSException e) {
0: //                    e.printStackTrace();
0: //                    exceptions.add(e);
1: //                }
1: //            }
0: //        });
0: //        for (int i = 0; i < numConsumers; i++) {
0: //            executorService.execute(new CheckForDupsClient(i));
1: //        }
1: //
1: //        executorService.shutdown();
0: //        executorService.awaitTermination(5, TimeUnit.MINUTES);
1: //        con.close();
1: //
0: //        assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1: //    }
1: //
0: //    public void testOrderOnActivateDeactivate() throws Exception {
0: //        for (int i=0;i<10;i++) {
0: //            LOG.info("Iteration: " + i);
0: //            doTestOrderOnActivateDeactivate();
0: //            broker.stop();
0: //            createBroker(true /*deleteAllMessages*/);
1: //        }
1: //    }
/////////////////////////////////////////////////////////////////////////
0: //    public void testUnmatchedSubUnsubscribeDeletesAll() throws Exception {
0: //        // create offline subs 1
0: //        Connection con = createConnection("offCli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        session.close();
0: //        con.close();
0: //
0: //        // send messages
0: //        con = createConnection();
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageProducer producer = session.createProducer(null);
0: //
0: //        int filtered = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            boolean filter = (i %2 == 0); //(int) (Math.random() * 2) >= 1;
0: //            if (filter)
0: //                filtered++;
0: //
0: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", filter ? "true" : "false");
0: //            producer.send(topic, message);
0: //        }
0: //
0: //        LOG.info("sent: " + filtered);
0: //        Thread.sleep(1 * 1000);
0: //        session.close();
0: //        con.close();
0: //
0: //        // test offline subs
0: //        con = createConnection("offCli1");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.unsubscribe("SubsId");
0: //        session.close();
0: //        con.close();
0: //
0: //        con = createConnection("offCli1");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //        Listener listener = new Listener();
0: //        consumer.setMessageListener(listener);
0: //
0: //        Thread.sleep(3 * 1000);
0: //
0: //        session.close();
0: //        con.close();
0: //
0: //        assertEquals(0, listener.count);
0: //    }
0: //
0: //    public void testAllConsumed() throws Exception {
0: //        final String filter = "filter = 'true'";
0: //        Connection con = createConnection("cli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        session.close();
0: //        con.close();
0: //
0: //        con = createConnection("cli2");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        session.close();
0: //        con.close();
0: //
0: //        // send messages
0: //        con = createConnection();
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageProducer producer = session.createProducer(null);
0: //
0: //        int sent = 0;
0: //        for (int i = 0; i < 10; i++) {
0: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", "true");
0: //            producer.send(topic, message);
0: //            sent++;
0: //        }
0: //
0: //        LOG.info("sent: " + sent);
0: //        Thread.sleep(1 * 1000);
0: //        session.close();
0: //        con.close();
0: //
0: //        con = createConnection("cli1");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        Listener listener = new Listener();
0: //        consumer.setMessageListener(listener);
0: //        Thread.sleep(3 * 1000);
0: //        session.close();
0: //        con.close();
0: //
0: //        assertEquals(sent, listener.count);
0: //
0: //        LOG.info("cli2 pull 2");
0: //        con = createConnection("cli2");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        assertNotNull("got message", consumer.receive(2000));
0: //        assertNotNull("got message", consumer.receive(2000));
0: //        session.close();
0: //        con.close();
0: //
0: //        // send messages
0: //        con = createConnection();
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        producer = session.createProducer(null);
0: //
0: //        sent = 0;
0: //        for (int i = 0; i < 2; i++) {
0: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", i==1 ? "true" : "false");
0: //            producer.send(topic, message);
0: //            sent++;
0: //        }
0: //        LOG.info("sent: " + sent);
0: //        Thread.sleep(1 * 1000);
0: //        session.close();
0: //        con.close();
0: //
0: //        LOG.info("cli1 again, should get 1 new ones");
0: //        con = createConnection("cli1");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        listener = new Listener();
0: //        consumer.setMessageListener(listener);
0: //        Thread.sleep(3 * 1000);
0: //        session.close();
0: //        con.close();
0: //
0: //        assertEquals(1, listener.count);
0: //    }
0: //
0: //    // https://issues.apache.org/jira/browse/AMQ-3190
0: //    public void testNoMissOnMatchingSubAfterRestart() throws Exception {
0: //
0: //        final String filter = "filter = 'true'";
0: //        Connection con = createConnection("cli1");
0: //        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        session.close();
0: //        con.close();
0: //
0: //        // send unmatched messages
0: //        con = createConnection();
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageProducer producer = session.createProducer(null);
0: //
0: //        int sent = 0;
0: //        // message for cli1 to keep it interested
0: //        Message message = session.createMessage();
0: //        message.setStringProperty("filter", "true");
0: //        message.setIntProperty("ID", 0);
0: //        producer.send(topic, message);
0: //        sent++;
0: //
0: //        for (int i = sent; i < 10; i++) {
0: //            message = session.createMessage();
0: //            message.setStringProperty("filter", "false");
0: //            message.setIntProperty("ID", i);
0: //            producer.send(topic, message);
0: //            sent++;
0: //        }
0: //        con.close();
0: //        LOG.info("sent: " + sent);
0: //
0: //        // new sub at id 10
0: //        con = createConnection("cli2");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        session.close();
0: //        con.close();
0: //
1: //        destroyBroker();
1: //        createBroker(false);
0: //
0: //        con = createConnection();
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        producer = session.createProducer(null);
0: //
0: //        for (int i = sent; i < 30; i++) {
0: //            message = session.createMessage();
0: //            message.setStringProperty("filter", "true");
0: //            message.setIntProperty("ID", i);
0: //            producer.send(topic, message);
0: //            sent++;
0: //        }
0: //        con.close();
0: //        LOG.info("sent: " + sent);
0: //
0: //        // pick up the first of the next twenty messages
0: //        con = createConnection("cli2");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        Message m = consumer.receive(3000);
0: //        assertEquals("is message 10", 10, m.getIntProperty("ID"));
0: //
0: //        session.close();
0: //        con.close();
0: //
0: //        // pick up the first few messages for client1
0: //        con = createConnection("cli1");
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0: //        m = consumer.receive(3000);
0: //        assertEquals("is message 0", 0, m.getIntProperty("ID"));
0: //        m = consumer.receive(3000);
0: //        assertEquals("is message 10", 10, m.getIntProperty("ID"));
0: //
0: //        session.close();
0: //        con.close();
0: //    }
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("Should have less than three journal files left but was: " +
0:                 return pa.getStore().getJournal().getFileMap().size() <= 3;
1: //    // https://issues.apache.org/jira/browse/AMQ-3768
1: //    public void testPageReuse() throws Exception {
0: //        Connection con = null;
0: //        Session session = null;
0: //
1: //        final int numConsumers = 115;
1: //        for (int i=0; i<=numConsumers;i++) {
1: //            con = createConnection("cli" + i);
1: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //            session.createDurableSubscriber(topic, "SubsId", null, true);
1: //            session.close();
1: //            con.close();
0: //        }
0: //
1: //        // populate ack locations
0: //        con = createConnection();
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageProducer producer = session.createProducer(null);
1: //        Message message = session.createTextMessage(new byte[10].toString());
0: //        producer.send(topic, message);
0: //        con.close();
0: //
1: //        // we have a split, remove all but the last so that
1: //        // the head pageid changes in the acklocations listindex
1: //        for (int i=0; i<=numConsumers -1; i++) {
1: //            con = createConnection("cli" + i);
1: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //            session.unsubscribe("SubsId");
1: //            session.close();
1: //            con.close();
0: //        }
0: //
0: //        destroyBroker();
0: //        createBroker(false);
0: //
1: //        // create a bunch more subs to reuse the freed page and get us in a knot
1: //        for (int i=1; i<=numConsumers;i++) {
1: //            con = createConnection("cli" + i);
1: //            session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: //            session.createDurableSubscriber(topic, "SubsId", filter, true);
1: //            session.close();
1: //            con.close();
0: //        }
0: //    }
0: //
1: //    public void testRedeliveryFlag() throws Exception {
0: //
1: //        Connection con;
1: //        Session session;
1: //        final int numClients = 2;
1: //        for (int i=0; i<numClients; i++) {
1: //            con = createConnection("cliId" + i);
1: //            session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0: //            session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //            session.close();
1: //            con.close();
0: //        }
0: //
1: //        final Random random = new Random();
0: //
0: //        // send messages
0: //        con = createConnection();
0: //        session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: //        MessageProducer producer = session.createProducer(null);
0: //
1: //        final int count = 1000;
1: //        for (int i = 0; i < count; i++) {
0: //            Message message = session.createMessage();
0: //            message.setStringProperty("filter", "true");
0: //            producer.send(topic, message);
0: //        }
0: //        session.close();
0: //        con.close();
0: //
1: //        class Client implements Runnable {
1: //            Connection con;
1: //            Session session;
1: //            String clientId;
1: //            Client(String id) {
1: //                this.clientId = id;
0: //            }
0: //
0: //            @Override
0: //            public void run() {
1: //                MessageConsumer consumer = null;
1: //                Message message = null;
0: //
0: //                try {
1: //                    for (int i = -1; i < random.nextInt(10); i++) {
1: //                        // go online and take none
1: //                        con = createConnection(clientId);
1: //                        session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1: //                        consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //                        session.close();
1: //                        con.close();
1: //                    }
0: //
1: //                    // consume 1
1: //                    con = createConnection(clientId);
1: //                    session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1: //                    consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //                    message = consumer.receive(4000);
1: //                    assertNotNull("got message", message);
1: //                    // it is not reliable as it depends on broker dispatch rather than client receipt
1: //                    // and delivered ack
1: //                    //  assertFalse("not redelivered", message.getJMSRedelivered());
1: //                    message.acknowledge();
1: //                    session.close();
1: //                    con.close();
0: //
1: //                    // peek all
1: //                    for (int j = -1; j < random.nextInt(10); j++) {
1: //                        con = createConnection(clientId);
1: //                        session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1: //                        consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //
1: //                        for (int i = 0; i < count - 1; i++) {
1: //                            assertNotNull("got message", consumer.receive(4000));
0: //                        }
1: //                        // no ack
1: //                        session.close();
1: //                        con.close();
1: //                    }
0: //
1: //                    // consume remaining
1: //                    con = createConnection(clientId);
1: //                    session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1: //                    consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: //
1: //                    for (int i = 0; i < count - 1; i++) {
1: //                        message = consumer.receive(4000);
1: //                        assertNotNull("got message", message);
1: //                        assertTrue("is redelivered", message.getJMSRedelivered());
1: //                    }
1: //                    message.acknowledge();
1: //                    session.close();
1: //                    con.close();
0: //
1: //                    con = createConnection(clientId);
1: //                    session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1: //                    consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
1: //                    assertNull("no message left", consumer.receive(2000));
1: //                } catch (Throwable throwable) {
1: //                    throwable.printStackTrace();
1: //                    exceptions.add(throwable);
0: //                }
0: //            }
0: //        }
0: //        ExecutorService executorService = Executors.newCachedThreadPool();
1: //        for (int i=0; i<numClients; i++) {
1: //            executorService.execute(new Client("cliId" + i));
0: //        }
0: //        executorService.shutdown();
1: //        executorService.awaitTermination(10, TimeUnit.MINUTES);
1: //        assertTrue("No exceptions expected, but was: " + exceptions, exceptions.isEmpty());
0: //    }
commit:646d023
/////////////////////////////////////////////////////////////////////////
0:         final KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
0:         assertTrue("Should have three journal files left but was: " +
0:             pa.getStore().getJournal().getFileMap().size(), Wait.waitFor(new Wait.Condition() {
0: 
1:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return pa.getStore().getJournal().getFileMap().size() == 3;
0:             }
0:         }));
commit:f7f294f
/////////////////////////////////////////////////////////////////////////
0:         setAutoFail(true);
0:         setMaxTestTime(2 * 60 * 1000);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 } else {
commit:48effa8
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
commit:4743a20
/////////////////////////////////////////////////////////////////////////
commit:7b19989
/////////////////////////////////////////////////////////////////////////
0:         // TODO - readd PersistenceAdapterChoice.LevelDB and investigate failure cause.
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
commit:ef24cc9
commit:2dd8b61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     for (int j = -1; j < random.nextInt(10); j++) {
/////////////////////////////////////////////////////////////////////////
commit:59d13ad
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
0:     private final List<Throwable> exceptions = new ArrayList<Throwable>();
0:     @Override
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("only two journal file(s) left after restart", 2, pa.getStore().getJournal().getFileMap().size());
/////////////////////////////////////////////////////////////////////////
0:         @Override
/////////////////////////////////////////////////////////////////////////
0:         @Override
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:a7533ba
/////////////////////////////////////////////////////////////////////////
0:         broker.waitUntilStarted();
/////////////////////////////////////////////////////////////////////////
1:             broker.waitUntilStopped();
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(DurableSubscriptionOfflineTest.class);
author:Gary Tully
-------------------------------------------------------------------------------
commit:6a097b9
/////////////////////////////////////////////////////////////////////////
0: 
0:         if (PersistenceAdapterChoice.LevelDB == defaultPersistenceAdapter) {
0:             // https://issues.apache.org/jira/browse/AMQ-4296
0:             return;
0:         }
0: 
commit:eaac0d2
/////////////////////////////////////////////////////////////////////////
0:         LOG.info("after restart, total sent with filter='true': " + filtered);
/////////////////////////////////////////////////////////////////////////
0:         Listener listener = new Listener("1>");
commit:8e60ca9
/////////////////////////////////////////////////////////////////////////
0:         final int numMessages = 2750;
0:         for (int repeats=0; repeats<2; repeats++) {
/////////////////////////////////////////////////////////////////////////
0:                 assertEquals("Only use X pages per iteration: " + repeats, lastDiff, pageFile.getPageCount() - pageFile.getFreePageCount());
commit:91ac82a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.kahadb.page.PageFile;
/////////////////////////////////////////////////////////////////////////
0:     public void testRemovedDurableSubDeletesFromIndex() throws Exception {
0: 
0:         if (! (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter)) {
0:             return;
0:         }
0: 
0:         // fails for numMessages > 3000
0:         final int numMessages = 100;
0: 
0:         KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
0:         PageFile pageFile = kahaDBPersistenceAdapter.getStore().getPageFile();
0:         LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() + ", fileSize:" + pageFile.getFile().length());
0: 
0:         long lastDiff = 0;
0:         for (int repeats=0; repeats<4; repeats++) {
0: 
0:             LOG.info("Iteration: "+ repeats  + " Count:" + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount());
0: 
0:             Connection con = createConnection("cliId1" + "-" + repeats);
0:             Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:             session.close();
0:             con.close();
0: 
0:             // send messages
0:             con = createConnection();
0:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             MessageProducer producer = session.createProducer(null);
0: 
0:             for (int i = 0; i < numMessages; i++) {
0:                 Message message = session.createMessage();
0:                 message.setStringProperty("filter", "true");
0:                 producer.send(topic, message);
0:             }
0:             con.close();
0: 
0:             Connection con2 = createConnection("cliId1" + "-" + repeats);
0:             Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             session2.unsubscribe("SubsId");
0:             session2.close();
0:             con2.close();
0: 
0:             LOG.info("PageCount " + pageFile.getPageCount() + " f:" + pageFile.getFreePageCount() +  " diff: " + (pageFile.getPageCount() - pageFile.getFreePageCount()) + " fileSize:" + pageFile.getFile().length());
0: 
0:             if (lastDiff != 0) {
0:                 assertEquals("Only use X pages per iteration", lastDiff, pageFile.getPageCount() - pageFile.getFreePageCount());
0:             }
0:             lastDiff = pageFile.getPageCount() - pageFile.getFreePageCount();
0:         }
0:     }
0: 
commit:3307d57
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("No exceptions  " + exceptions.elements(), exceptions.isEmpty());
/////////////////////////////////////////////////////////////////////////
1:                 e.printStackTrace();
commit:6b4d077
/////////////////////////////////////////////////////////////////////////
0:         broker.addConnector("tcp://0.0.0.0:0");
/////////////////////////////////////////////////////////////////////////
0:     public void testOrderOnActivateDeactivate() throws Exception {
0:         for (int i=0;i<10;i++) {
0:             LOG.info("Iteration: " + i);
0:             doTestOrderOnActivateDeactivate();
0:             broker.stop();
0:             createBroker(true /*deleteAllMessages*/);
0:         }
0:     }
0: 
1:     public void doTestOrderOnActivateDeactivate() throws Exception {
1:         final int messageCount = 1000;
1:         Connection con = null;
1:         Session session = null;
1:         final int numConsumers = 4;
1:         for (int i = 0; i <= numConsumers; i++) {
1:             con = createConnection("cli" + i);
0:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             session.createDurableSubscriber(topic, "SubsId", null, true);
0:             session.close();
0:             con.close();
0:         }
0: 
1:         final String url = "failover:(tcp://localhost:"
0:             + (broker.getTransportConnectors().get(1).getConnectUri()).getPort()
0:             + "?wireFormat.maxInactivityDuration=0)?"
0:             + "jms.watchTopicAdvisories=false&"
0:             + "jms.alwaysSyncSend=true&jms.dispatchAsync=true&"
0:             + "jms.sendAcksAsync=true&"
0:             + "initialReconnectDelay=100&maxReconnectDelay=30000&"
0:             + "useExponentialBackOff=true";
1:         final ActiveMQConnectionFactory clientFactory = new ActiveMQConnectionFactory(url);
0: 
1:         class CheckOrderClient implements Runnable {
1:             final int id;
1:             int runCount = 0;
0: 
1:             public CheckOrderClient(int id) {
1:                 this.id = id;
0:             }
0: 
0:             @Override
1:             public void run() {
1:                 try {
1:                     synchronized (this) {
1:                         Connection con = clientFactory.createConnection();
1:                         con.setClientID("cli" + id);
1:                         con.start();
1:                         Session session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:                         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
1:                         int nextId = 0;
0: 
1:                         ++runCount;
1:                         int i=0;
1:                         for (; i < messageCount/2; i++) {
1:                             Message message = consumer.receiveNoWait();
1:                             if (message == null) {
1:                                 break;
0:                             }
1:                             long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
1:                             assertEquals(id + " expected order: runCount: " + runCount  + " id: " + message.getJMSMessageID(), ++nextId, producerSequenceId);
0:                         }
1:                         LOG.info(con.getClientID() + " peeked " + i);
0:                         session.close();
0:                         con.close();
0:                     }
1:                 } catch (Throwable e) {
1:                     e.printStackTrace();
1:                     exceptions.add(e);
0:                 }
0:             }
0:         }
0: 
1:         Runnable producer = new Runnable() {
1:             final String payLoad = new String(new byte[600]);
0: 
0:             @Override
1:             public void run() {
1:                 try {
0:                     Connection con = createConnection();
1:                     final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);
1:                     MessageProducer producer = sendSession.createProducer(topic);
1:                     for (int i = 0; i < messageCount; i++) {
1:                         producer.send(sendSession.createTextMessage(payLoad));
0:                     }
1:                     LOG.info("About to commit: " + messageCount);
1:                     sendSession.commit();
1:                     LOG.info("committed: " + messageCount);
0:                     con.close();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                     exceptions.add(e);
0:                 }
0:             }
1:         };
0: 
1:         ExecutorService executorService = Executors.newCachedThreadPool();
0: 
1:         // concurrent commit and activate
1:         for (int i = 0; i < numConsumers; i++) {
1:             final CheckOrderClient client = new CheckOrderClient(i);
1:             for (int j=0; j<100; j++) {
1:                 executorService.execute(client);
0:             }
0:         }
1:         executorService.execute(producer);
0: 
1:         executorService.shutdown();
1:         executorService.awaitTermination(5, TimeUnit.MINUTES);
0:         con.close();
0: 
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
0:     }
0: 
commit:53b29a2
/////////////////////////////////////////////////////////////////////////
0: import java.util.Random;
0: import java.util.HashSet;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
0:     private Vector<Throwable> exceptions = new Vector<Throwable>();
/////////////////////////////////////////////////////////////////////////
0:     public void testNoDuplicateOnConcurrentSendTranCommitAndActivate() throws Exception {
0:         final int messageCount = 1000;
0:         Connection con = null;
0:         Session session = null;
0:         final int numConsumers = 10;
0:         for (int i = 0; i <= numConsumers; i++) {
0:             con = createConnection("cli" + i);
0:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             session.createDurableSubscriber(topic, "SubsId", null, true);
0:             session.close();
0:             con.close();
0:         }
0: 
0:         class CheckForDupsClient implements Runnable {
0:             HashSet<Long> ids = new HashSet<Long>();
0:             final int id;
0: 
0:             public CheckForDupsClient(int id) {
0:                 this.id = id;
0:             }
0: 
0:             @Override
0:             public void run() {
0:                 try {
0:                     Connection con = createConnection("cli" + id);
0:                     Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:                     for (int j=0;j<2;j++) {
0:                         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0:                         for (int i = 0; i < messageCount/2; i++) {
0:                             Message message = consumer.receive(4000);
0:                             assertNotNull(message);
0:                             long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
0:                             assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
0:                         }
0:                         consumer.close();
0:                     }
0: 
0:                     // verify no duplicates left
0:                     MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0:                     Message message = consumer.receive(4000);
0:                     if (message != null) {
0:                         long producerSequenceId = new MessageId(message.getJMSMessageID()).getProducerSequenceId();
0:                         assertTrue("ID=" + id + " not a duplicate: " + producerSequenceId, ids.add(producerSequenceId));
0:                     }
0:                     assertNull(message);
0: 
0: 
0:                     session.close();
0:                     con.close();
0:                 } catch (Throwable e) {
0:                     e.printStackTrace();
0:                     exceptions.add(e);
0:                 }
0:             }
0:         }
0: 
0: 
0:         final String payLoad = new String(new byte[1000]);
0:         con = createConnection();
0:         final Session sendSession = con.createSession(true, Session.SESSION_TRANSACTED);
0:         MessageProducer producer = sendSession.createProducer(topic);
0:         for (int i = 0; i < messageCount; i++) {
0:             producer.send(sendSession.createTextMessage(payLoad));
0:         }
0: 
0:         ExecutorService executorService = Executors.newCachedThreadPool();
0: 
0:         // concurrent commit and activate
0:         executorService.execute(new Runnable() {
0:             @Override
0:             public void run() {
0:                 try {
0:                     sendSession.commit();
0:                 } catch (JMSException e) {
0:                     e.printStackTrace();
0:                     exceptions.add(e);
0:                 }
0:             }
0:         });
0:         for (int i = 0; i < numConsumers; i++) {
0:             executorService.execute(new CheckForDupsClient(i));
0:         }
0: 
0:         executorService.shutdown();
0:         executorService.awaitTermination(5, TimeUnit.MINUTES);
0:         con.close();
0: 
0:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void testRedeliveryFlag() throws Exception {
0: 
0:         Connection con;
0:         Session session;
0:         final int numClients = 2;
0:         for (int i=0; i<numClients; i++) {
0:             con = createConnection("cliId" + i);
0:             session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:             session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:             session.close();
0:             con.close();
0:         }
0: 
0:         final Random random = new Random();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         final int count = 1000;
0:         for (int i = 0; i < count; i++) {
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0:         session.close();
0:         con.close();
0: 
0:         class Client implements Runnable {
0:             Connection con;
0:             Session session;
0:             String clientId;
0:             Client(String id) {
0:                 this.clientId = id;
0:             }
0: 
0:             @Override
0:             public void run() {
0:                 MessageConsumer consumer = null;
0:                 Message message = null;
0: 
0:                 try {
0:                     for (int i = -1; i < random.nextInt(10); i++) {
0:                         // go online and take none
0:                         con = createConnection(clientId);
0:                         session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:                         consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:                         session.close();
0:                         con.close();
0:                     }
0: 
0:                     // consume 1
0:                     con = createConnection(clientId);
0:                     session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:                     consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:                     message = consumer.receive(4000);
0:                     assertNotNull("got message", message);
0:                     // it is not reliable as it depends on broker dispatch rather than client receipt
0:                     // and delivered ack
0:                     //  assertFalse("not redelivered", message.getJMSRedelivered());
0:                     message.acknowledge();
0:                     session.close();
0:                     con.close();
0: 
0:                     // peek all
0:                     for (int j = 0; j < random.nextInt(10); j++) {
0:                         con = createConnection(clientId);
0:                         session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:                         consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: 
0:                         for (int i = 0; i < count - 1; i++) {
0:                             assertNotNull("got message", consumer.receive(4000));
0:                         }
0:                         // no ack
0:                         session.close();
0:                         con.close();
0:                     }
0: 
0: 
0:                     // consume remaining
0:                     con = createConnection(clientId);
0:                     session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:                     consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: 
0:                     for (int i = 0; i < count - 1; i++) {
0:                         message = consumer.receive(4000);
0:                         assertNotNull("got message", message);
0:                         assertTrue("is redelivered", message.getJMSRedelivered());
0:                     }
0:                     message.acknowledge();
0:                     session.close();
0:                     con.close();
0: 
0:                     con = createConnection(clientId);
0:                     session = con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:                     consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:                     assertNull("no message left", consumer.receive(2000));
0:                 } catch (Throwable throwable) {
0:                     throwable.printStackTrace();
0:                     exceptions.add(throwable);
0:                 }
0:             }
0:         }
0:         ExecutorService executorService = Executors.newCachedThreadPool();
0:         for (int i=0; i<numClients; i++) {
0:             executorService.execute(new Client("cliId" + i));
0:         }
0:         executorService.shutdown();
0:         executorService.awaitTermination(10, TimeUnit.MINUTES);
0:         assertTrue("No exceptions", exceptions.isEmpty());
0:     }
0: 
commit:1463bec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQQueue;
/////////////////////////////////////////////////////////////////////////
0:     // https://issues.apache.org/jira/browse/AMQ-3768
0:     public void testPageReuse() throws Exception {
0:         Connection con = null;
0:         Session session = null;
0: 
0:         final int numConsumers = 115;
0:         for (int i=0; i<=numConsumers;i++) {
0:             con = createConnection("cli" + i);
0:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             session.createDurableSubscriber(topic, "SubsId", null, true);
0:             session.close();
0:             con.close();
0:         }
0: 
0: 
0:         // populate ack locations
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0:         Message message = session.createTextMessage(new byte[10].toString());
0:         producer.send(topic, message);
0:         con.close();
0: 
0:         // we have a split, remove all but the last so that
0:         // the head pageid changes in the acklocations listindex
0:         for (int i=0; i<=numConsumers -1; i++) {
0:             con = createConnection("cli" + i);
0:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             session.unsubscribe("SubsId");
0:             session.close();
0:             con.close();
0:         }
0: 
0:         destroyBroker();
0:         createBroker(false);
0: 
0:         // create a bunch more subs to reuse the freed page and get us in a knot
0:         for (int i=1; i<=numConsumers;i++) {
0:             con = createConnection("cli" + i);
0:             session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:             session.createDurableSubscriber(topic, "SubsId", filter, true);
0:             session.close();
0:             con.close();
0:         }
0:     }
0: 
commit:1595378
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:         broker = BrokerFactory.createBroker("broker:(vm://" + getName(true) +")");
/////////////////////////////////////////////////////////////////////////
0:         
0:             ((JDBCPersistenceAdapter)broker.getPersistenceAdapter()).setCleanupPeriod(2*1000);
0:             ((KahaDBPersistenceAdapter)broker.getPersistenceAdapter()).setJournalMaxFileLength(journalMaxFileLength);
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
/////////////////////////////////////////////////////////////////////////
0:      public void testConsumeAllMatchedMessages() throws Exception {
0:          // create durable subscription
0:          Connection con = createConnection();
0:          Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          session.close();
0:          con.close();
0:          // send messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageProducer producer = session.createProducer(null);
0:          int sent = 0;
0:          for (int i = 0; i < 10; i++) {
0:              sent++;
0:              Message message = session.createMessage();
0:              message.setStringProperty("filter", "true");
0:              producer.send(topic, message);
0:          }
0:          Thread.sleep(1 * 1000);
0:          session.close();
0:          con.close();
0:          // consume messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          Listener listener = new Listener();
0:          consumer.setMessageListener(listener);
0:          Thread.sleep(3 * 1000);
0:          session.close();
0:          con.close();
0:          assertEquals(sent, listener.count);
0:      }
0:     
0:                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
0:      public void testVerifyAllConsumedAreAcked() throws Exception {
0:          // create durable subscription
0:          Connection con = createConnection();
0:          Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          session.close();
0:          con.close();
0:          // send messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageProducer producer = session.createProducer(null);
0:          int sent = 0;
0:          for (int i = 0; i < 10; i++) {
0:              sent++;
0:              Message message = session.createMessage();
0:              message.setStringProperty("filter", "true");
0:              producer.send(topic, message);
0:          }
0:          Thread.sleep(1 * 1000);
0:          session.close();
0:          con.close();
0:          // consume messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          Listener listener = new Listener();
0:          consumer.setMessageListener(listener);
0:          Thread.sleep(3 * 1000);
0:          session.close();
0:          con.close();
0:          LOG.info("Consumed: " + listener.count);
0:          assertEquals(sent, listener.count);
0:          // consume messages again, should not get any
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          listener = new Listener();
0:          consumer.setMessageListener(listener);
0:          Thread.sleep(3 * 1000);
0:          session.close();
0:          con.close();
0:          assertEquals(0, listener.count);
0:      }
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
/////////////////////////////////////////////////////////////////////////
0:     }    
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:     
/////////////////////////////////////////////////////////////////////////
0:  
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:             boolean filter = (i %2 == 0); //(int) (Math.random() * 2) >= 1;
/////////////////////////////////////////////////////////////////////////
0:             message.setStringProperty("filter", i==1 ? "true" : "false");
/////////////////////////////////////////////////////////////////////////
0:  
/////////////////////////////////////////////////////////////////////////
0:         final String payload = new byte[40*1024].toString();
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Want: " + toSend  + ", current: " + listener.count);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("only one journal file left after restart", 1, pa.getStore().getJournal().getFileMap().size());
/////////////////////////////////////////////////////////////////////////
0:                 } catch (Exception ignored) {}
0:     public class FilterCheckListener extends Listener  {
/////////////////////////////////////////////////////////////////////////
0:                 }
0:                 else {
0:             }
0:             catch (JMSException e) {
commit:caca105
/////////////////////////////////////////////////////////////////////////
0: import javax.management.ObjectName;
0: import org.apache.activemq.broker.jmx.DurableSubscriptionViewMBean;
0: import org.apache.activemq.broker.jmx.TopicViewMBean;
/////////////////////////////////////////////////////////////////////////
0:     public boolean keepDurableSubsActive = true;
1:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://" + getName(true));
1:         connectionFactory.setWatchTopicAdvisories(false);
1:         return connectionFactory;
/////////////////////////////////////////////////////////////////////////
0:         broker.setAdvisorySupport(false);
0:         broker.setKeepDurableSubsActive(keepDurableSubsActive);
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestJMXCountersWithOfflineSubs() throws Exception {
0:         this.addCombinationValues("keepDurableSubsActive",
0:                 new Object[]{Boolean.TRUE, Boolean.FALSE});
0:     }
0: 
0:     public void testJMXCountersWithOfflineSubs() throws Exception {
0:         // create durable subscription 1
0:         Connection con = createConnection("cliId1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", null, true);
0:         session.close();
0:         con.close();
0: 
0:         // restart broker
0:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             producer.send(topic, message);
0:         }
0:         session.close();
0:         con.close();
0: 
0:         // consume some messages
0:         con = createConnection("cliId1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0: 
0:         for (int i=0; i<sent/2; i++) {
0:             Message m =  consumer.receive(4000);
0:             assertNotNull("got message: " + i, m);
0:             LOG.info("Got :" + i + ", " + m);
0:         }
0: 
0:         // check some counters while active
0:         ObjectName activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];
0:         LOG.info("active durable sub name: " + activeDurableSubName);
0:         final DurableSubscriptionViewMBean durableSubscriptionView = (DurableSubscriptionViewMBean)
0:                 broker.getManagementContext().newProxyInstance(activeDurableSubName, DurableSubscriptionViewMBean.class, true);
0: 
0:         assertTrue("is active", durableSubscriptionView.isActive());
0:         assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView.getEnqueueCounter());
0:         assertTrue("correct waiting acks", Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return 5 == durableSubscriptionView.getMessageCountAwaitingAcknowledge();
0:             }
0:         }));
0:         assertEquals("correct dequeue", 5, durableSubscriptionView.getDequeueCounter());
0: 
0: 
0:         ObjectName destinationName = broker.getAdminView().getTopics()[0];
0:         TopicViewMBean topicView = (TopicViewMBean) broker.getManagementContext().newProxyInstance(destinationName, TopicViewMBean.class, true);
0:         assertEquals("correct enqueue", 10, topicView.getEnqueueCount());
0:         assertEquals("still zero dequeue, we don't decrement on each sub ack to stop exceeding the enqueue count with multiple subs", 0, topicView.getDequeueCount());
0:         assertEquals("inflight", 5, topicView.getInFlightCount());
0: 
0:         session.close();
0:         con.close();
0: 
0:         // check some counters when inactive
0:         ObjectName inActiveDurableSubName = broker.getAdminView().getInactiveDurableTopicSubscribers()[0];
0:         LOG.info("inactive durable sub name: " + inActiveDurableSubName);
0:         DurableSubscriptionViewMBean durableSubscriptionView1 = (DurableSubscriptionViewMBean)
0:                 broker.getManagementContext().newProxyInstance(inActiveDurableSubName, DurableSubscriptionViewMBean.class, true);
0: 
0:         assertTrue("is not active", !durableSubscriptionView1.isActive());
0:         assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView1.getEnqueueCounter());
0:         assertEquals("correct awaiting ack", 0, durableSubscriptionView1.getMessageCountAwaitingAcknowledge());
0:         assertEquals("correct dequeue", keepDurableSubsActive ? 5 : 0, durableSubscriptionView1.getDequeueCounter());
0: 
0:         // destination view
0:         assertEquals("correct enqueue", 10, topicView.getEnqueueCount());
0:         assertEquals("still zero dequeue, we don't decrement on each sub ack to stop exceeding the enqueue count with multiple subs", 0, topicView.getDequeueCount());
0:         assertEquals("inflight back to 0 after deactivate", 0, topicView.getInFlightCount());
0: 
0:         // consume the rest
0:         con = createConnection("cliId1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0: 
0:         for (int i=0; i<sent/2;i++) {
0:             Message m =  consumer.receive(30000);
0:             assertNotNull("got message: " + i, m);
0:             LOG.info("Got :" + i + ", " + m);
0:         }
0: 
0:         activeDurableSubName = broker.getAdminView().getDurableTopicSubscribers()[0];
0:         LOG.info("durable sub name: " + activeDurableSubName);
0:         final DurableSubscriptionViewMBean durableSubscriptionView2 = (DurableSubscriptionViewMBean)
0:                 broker.getManagementContext().newProxyInstance(activeDurableSubName, DurableSubscriptionViewMBean.class, true);
0: 
0:         assertTrue("is active", durableSubscriptionView2.isActive());
0:         assertEquals("all enqueued", keepDurableSubsActive ? 10 : 0, durableSubscriptionView2.getEnqueueCounter());
0:         assertTrue("correct dequeue", Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 long val = durableSubscriptionView2.getDequeueCounter();
0:                 LOG.info("dequeue count:" + val);
0:                 return 10 == val;
0:             }
0:         }));
0: 
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         this.addCombinationValues("keepDurableSubsActive",
0:                 new Object[]{Boolean.TRUE, Boolean.FALSE});
commit:1c1aa17
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
0: import org.apache.activemq.util.Wait;
0: import org.apache.kahadb.journal.Journal;
0:     public boolean usePrioritySupport = Boolean.TRUE;
0:     public int journalMaxFileLength = Journal.DEFAULT_MAX_FILE_LENGTH;
/////////////////////////////////////////////////////////////////////////
0:         } else if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
0:             // have lots of journal files
0:             ((KahaDBPersistenceAdapter)broker.getPersistenceAdapter()).setJournalMaxFileLength(journalMaxFileLength);
/////////////////////////////////////////////////////////////////////////
0:     // use very small journal to get lots of files to cleanup
0:     public void initCombosForTestCleanupDeletedSubAfterRestart() throws Exception {
0:         this.addCombinationValues("journalMaxFileLength",
0:                 new Object[]{new Integer(64*1024)});
0:     }
0: 
0:     // https://issues.apache.org/jira/browse/AMQ-3206
0:     public void testCleanupDeletedSubAfterRestart() throws Exception {
0:         Connection con = createConnection("cli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", null, true);
0:         session.close();
0:         con.close();
0: 
0:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", null, true);
0:         session.close();
0:         con.close();
0: 
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         final int toSend = 500;
0:         final String payload = new byte[40*1024].toString();
0:         int sent = 0;
0:         for (int i = sent; i < toSend; i++) {
0:             Message message = session.createTextMessage(payload);
0:             message.setStringProperty("filter", "false");
0:             message.setIntProperty("ID", i);
0:             producer.send(topic, message);
0:             sent++;
0:         }
0:         con.close();
0:         LOG.info("sent: " + sent);
0: 
0:         // kill off cli1
0:         con = createConnection("cli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.unsubscribe("SubsId");
0: 
0:         destroyBroker();
0:         createBroker(false);
0: 
0:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0:         final Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         assertTrue("got all sent", Wait.waitFor(new Wait.Condition() {
0:             public boolean isSatisified() throws Exception {
0:                 LOG.info("Want: " + toSend  + ", current: " + listener.count);
0:                 return listener.count == toSend;
0:             }
0:         }));
0:         session.close();
0:         con.close();
0: 
0:         destroyBroker();
0:         createBroker(false);
0:         KahaDBPersistenceAdapter pa = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
0:         assertEquals("only one journal file left after restart", 1, pa.getStore().getJournal().getFileMap().size());
0:     }
0: 
commit:2d121f4
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
1: import javax.jms.Connection;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
0: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     // https://issues.apache.org/jira/browse/AMQ-3190
0:     public void testNoMissOnMatchingSubAfterRestart() throws Exception {
0: 
0:         final String filter = "filter = 'true'";
0:         Connection con = createConnection("cli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
0:         // send unmatched messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         // message for cli1 to keep it interested
0:         Message message = session.createMessage();
0:         message.setStringProperty("filter", "true");
0:         message.setIntProperty("ID", 0);
0:         producer.send(topic, message);
0:         sent++;
0: 
0:         for (int i = sent; i < 10; i++) {
0:             message = session.createMessage();
0:             message.setStringProperty("filter", "false");
0:             message.setIntProperty("ID", i);
0:             producer.send(topic, message);
0:             sent++;
0:         }
0:         con.close();
0:         LOG.info("sent: " + sent);
0: 
0: 
0:         // new sub at id 10
0:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
0:         destroyBroker();
0:         createBroker(false);
0: 
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         producer = session.createProducer(null);
0: 
0:         for (int i = sent; i < 30; i++) {
0:             message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             message.setIntProperty("ID", i);
0:             producer.send(topic, message);
0:             sent++;
0:         }
0:         con.close();
0:         LOG.info("sent: " + sent);
0: 
0:         // pick up the first of the next twenty messages
0:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Message m = consumer.receive(3000);
0:         assertEquals("is message 10", 10, m.getIntProperty("ID"));
0: 
0:         session.close();
0:         con.close();
0: 
0:         // pick up the first few messages for client1
0:         con = createConnection("cli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         m = consumer.receive(3000);
0:         assertEquals("is message 0", 0, m.getIntProperty("ID"));
0:         m = consumer.receive(3000);
0:         assertEquals("is message 10", 10, m.getIntProperty("ID"));
0: 
0:         session.close();
0:         con.close();
0:     }
0: 
commit:8191f19
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestOfflineSubscriptionWithSelectorAfterRestart() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestOfflineAfterRestart() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:     }
0: 
0:     public void testOfflineSubscriptionAfterRestart() throws Exception {
0:         // create offline subs 1
0:         Connection con = createConnection("offCli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, false);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0: 
0:         // send messages
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         LOG.info("sent: " + sent);
0:         Thread.sleep(5 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(sent, listener.count);
0: 
0:         // restart broker
0:         Thread.sleep(3 * 1000);
0:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
0: 
0:         // send more messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         producer = session.createProducer(null);
0: 
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         LOG.info("after restart, sent: " + sent);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         // test offline subs
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(sent, listener.count);
0:     }
commit:8871c67
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestMixOfOnLineAndOfflineSubsGetAllMatched() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             boolean filter = (int) (Math.random() * 2) >= 1;
/////////////////////////////////////////////////////////////////////////
0:             boolean filter = (int) (Math.random() * 2) >= 1;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void testInterleavedOfflineSubscriptionCanConsumeAfterUnsub() throws Exception {
0:         // create offline subs 1
0:         Connection con = createConnection("offCli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // create offline subs 2
0:         con = createConnection("offCli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", null, true);
0:         session.close();
0:         con.close();
0: 
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             boolean filter = (int) (Math.random() * 2) >= 1;
0: 
0:             sent++;
0: 
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", filter ? "true" : "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         Thread.sleep(1 * 1000);
0: 
0:         Connection con2 = createConnection("offCli1");
0:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session2.unsubscribe("SubsId");
0:         session2.close();
0:         con2.close();
0: 
0:         // consume all messages
0:         con = createConnection("offCli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", null, true);
0:         Listener listener = new Listener("SubsId");
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals("offline consumer got all", sent, listener.count);
0:     }
0: 
0: 
0:     public void testUnmatchedSubUnsubscribeDeletesAll() throws Exception {
0:         // create offline subs 1
0:         Connection con = createConnection("offCli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int filtered = 0;
0:         for (int i = 0; i < 10; i++) {
0:             boolean filter = (i %2 == 0); //(int) (Math.random() * 2) >= 1;
0:             if (filter)
0:                 filtered++;
0: 
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", filter ? "true" : "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         LOG.info("sent: " + filtered);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         // test offline subs
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.unsubscribe("SubsId");
0:         session.close();
0:         con.close();
0: 
0: 
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(0, listener.count);
0:     }
0: 
0: 
0:     public void testAllConsumed() throws Exception {
0:         final String filter = "filter = 'true'";
0:         Connection con = createConnection("cli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
0:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:             sent++;
0:         }
0: 
0:         LOG.info("sent: " + sent);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         con = createConnection("cli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Thread.sleep(3 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(sent, listener.count);
0: 
0:         LOG.info("cli2 pull 2");
0:         con = createConnection("cli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         assertNotNull("got message", consumer.receive(2000));
0:         assertNotNull("got message", consumer.receive(2000));
0:         session.close();
0:         con.close();
0: 
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         producer = session.createProducer(null);
0: 
0:         sent = 0;
0:         for (int i = 0; i < 2; i++) {
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", i==1 ? "true" : "false");
0:             producer.send(topic, message);
0:             sent++;
0:         }
0:         LOG.info("sent: " + sent);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0:  
0:         LOG.info("cli1 again, should get 1 new ones");
0:         con = createConnection("cli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Thread.sleep(3 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(1, listener.count);
0:     }
0: 
commit:3f0cf98
/////////////////////////////////////////////////////////////////////////
0:     public void testOfflineSubscriptionWithSelectorAfterRestart() throws Exception {
0:         // create offline subs 1
0:         Connection con = createConnection("offCli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // create offline subs 2
0:         con = createConnection("offCli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int filtered = 0;
0:         for (int i = 0; i < 10; i++) {
0:             boolean filter = (i %2 == 0); //(int) (Math.random() * 2) >= 1;
0:             if (filter)
0:                 filtered++;
0: 
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", filter ? "true" : "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         LOG.info("sent: " + filtered);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         // restart broker
0:         Thread.sleep(3 * 1000);
0:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
0:  
0:         // send more messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         producer = session.createProducer(null);
0: 
0:         for (int i = 0; i < 10; i++) {
0:             boolean filter = (i %2 == 0); //(int) (Math.random() * 2) >= 1;
0:             if (filter)
0:                 filtered++;
0: 
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", filter ? "true" : "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         LOG.info("after restart, sent: " + filtered);
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         // test offline subs
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0: 
0:         Connection con3 = createConnection("offCli2");
0:         Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener3 = new Listener();
0:         consumer3.setMessageListener(listener3);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0:         session3.close();
0:         con3.close();
0: 
0:         assertEquals(filtered, listener.count);
0:         assertEquals(filtered, listener3.count);
0:     }
commit:6dea944
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
/////////////////////////////////////////////////////////////////////////
0:     private Vector<Exception> exceptions = new Vector<Exception>();
/////////////////////////////////////////////////////////////////////////
0:         exceptions.clear();
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:     public void x_initCombosForTestMixOfOnLineAndOfflineSubsGetAllMatched() throws Exception {
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:     public void testMixOfOnLineAndOfflineSubsGetAllMatched() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         Listener listener = new FilterCheckListener();
/////////////////////////////////////////////////////////////////////////
0:         Listener listener3 = new FilterCheckListener();
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("no unexpected exceptions: " + exceptions, exceptions.isEmpty());
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info(id + ", " + message.getJMSMessageID());
0: 
0:     public class FilterCheckListener extends Listener  {
0: 
0:         public void onMessage(Message message) {
0:             count++;
0: 
0:             try {
0:                 Object b = message.getObjectProperty("$b");
0:                 if (b != null) {
0:                     boolean c = message.getBooleanProperty("$c");
0:                     assertTrue("", c);
0:                 }
0:                 else {
0:                     String d = message.getStringProperty("$d");
0:                     assertTrue("", "D1".equals(d) || "D2".equals(d));
0:                 }
0:             }
0:             catch (JMSException e) {
0:                 exceptions.add(e);
0:             }
0:         }
0:     }
commit:d8b1189
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ /*PersistenceAdapterChoice.KahaDB,*/ PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:         listener2 = new Listener("cliId2");
/////////////////////////////////////////////////////////////////////////
0:         Listener listener = new Listener("cliId1");
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void initCombosForTestMixOfOnLineAndOfflineSubsGetAllMAtched() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ /* PersistenceAdapterChoice.KahaDB,*/ PersistenceAdapterChoice.JDBC});
0:     }
0: 
0:     private static String filter = "$a='A1' AND (($b=true AND $c=true) OR ($d='D1' OR $d='D2'))";
0:     public void testMixOfOnLineAndOfflineSubsGetAllMAtched() throws Exception {
0:         // create offline subs 1
0:         Connection con = createConnection("offCli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
0:         // create offline subs 2
0:         con = createConnection("offCli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         session.close();
0:         con.close();
0: 
0:         // create online subs
0:         Connection con2 = createConnection("onlineCli1");
0:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener2 = new Listener();
0:         consumer2.setMessageListener(listener2);
0: 
0:         // create non-durable consumer
0:         Connection con4 = createConnection("nondurableCli");
0:         Session session4 = con4.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer4 = session4.createConsumer(topic, filter, true);
0:         Listener listener4 = new Listener();
0:         consumer4.setMessageListener(listener4);
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         boolean hasRelevant = false;
0:         int filtered = 0;
0:         for (int i = 0; i < 100; i++) {
0:             int postf = (int) (Math.random() * 9) + 1;
0:             String d = "D" + postf;
0: 
0:             if ("D1".equals(d) || "D2".equals(d)) {
0:                 hasRelevant = true;
0:                 filtered++;
0:             }
0: 
0:             Message message = session.createMessage();
0:             message.setStringProperty("$a", "A1");
0:             message.setStringProperty("$d", d);
0:             producer.send(topic, message);
0:         }
0: 
0:         Message message = session.createMessage();
0:         message.setStringProperty("$a", "A1");
0:         message.setBooleanProperty("$b", true);
0:         message.setBooleanProperty("$c", hasRelevant);
0:         producer.send(topic, message);
0: 
0:         if (hasRelevant)
0:             filtered++;
0: 
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         // test non-durable consumer
0:         session4.close();
0:         con4.close();
0:         assertEquals(filtered, listener4.count); // succeeded!
0: 
0:         // test online subs
0:         session2.close();
0:         con2.close();
0:         assertEquals(filtered, listener2.count); // succeeded!
0: 
0:         // test offline 1
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener = new Listener("offCli1");
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(filtered, listener.count);
0: 
0:         // test offline 2
0:         Connection con3 = createConnection("offCli2");
0:         Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener3 = new Listener();
0:         consumer3.setMessageListener(listener3);
0: 
0:         Thread.sleep(3 * 1000);
0:         session3.close();
0:         con3.close();
0: 
0:         assertEquals(filtered, listener3.count);
0:     }
0: 
0:     public void testRemovedDurableSubDeletes() throws Exception {
0:         // create durable subscription 1
0:         Connection con = createConnection("cliId1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0: 
0:         Thread.sleep(1 * 1000);
0: 
0:         Connection con2 = createConnection("cliId1");
0:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session2.unsubscribe("SubsId");
0:         session2.close();
0:         con2.close();
0: 
0:         // see if retroactive can consumer any
0:         topic = new ActiveMQTopic(topic.getPhysicalName() + "?consumer.retroactive=true");
0:         con = createConnection("offCli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", filter, true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         session.close();
0:         con.close();
0:         assertEquals(0, listener.count);
0:     }
0: 
0: 
0:         String id = null;
0:         Listener() {
0:         }
0:         Listener(String id) {
0:             this.id = id;
0:         }
0:             if (id != null) {
0:                 try {
0:                     LOG.error(id + ", " + message.getJMSMessageID());
0:                 } catch (Exception ignored) {}
0:             }
commit:fa4481c
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void initCombosForTestVerifyAllConsumedAreAcked() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:         this.addCombinationValues("usePrioritySupport",
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     public void initCombosForTestInterleavedOfflineSubscriptionCanConsume() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:     }
0: 
0:     public void testInterleavedOfflineSubscriptionCanConsume() throws Exception {
0:         // create durable subscription 1
0:         Connection con = createConnection("cliId1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0: 
0:         Thread.sleep(1 * 1000);
0: 
0:         // create durable subscription 2
0:         Connection con2 = createConnection("cliId2");
0:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener2 = new Listener();
0:         consumer2.setMessageListener(listener2);
0: 
0:         assertEquals(0, listener2.count);
0:         session2.close();
0:         con2.close();
0: 
0:         // send some more
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0: 
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         con2 = createConnection("cliId2");
0:         session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         listener2 = new Listener();
0:         consumer2.setMessageListener(listener2);
0:         // test online subs
0:         Thread.sleep(3 * 1000);
0: 
0:         assertEquals(10, listener2.count);
0: 
0:         // consume all messages
0:         con = createConnection("cliId1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals("offline consumer got all", sent, listener.count);
0:     }    
commit:06cbebc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0:         if (broker.getPersistenceAdapter() instanceof JDBCPersistenceAdapter) {
0:             // ensure it kicks in during tests
0:             ((JDBCPersistenceAdapter)broker.getPersistenceAdapter()).setCleanupPeriod(2*1000);
0:         }
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestOfflineSubscriptionCanConsumeAfterOnlineSubs() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:         this.addCombinationValues("usePrioritySupport",
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
0:     }
0: 
commit:0c3117a
/////////////////////////////////////////////////////////////////////////
0:         createBroker(true);
0:     }
0:     
0:     private void createBroker(boolean deleteAllMessages) throws Exception {
0:         broker.setDeleteAllMessagesOnStartup(deleteAllMessages);
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestConsumeOnlyMatchedMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void testOfflineSubscriptionCanConsumeAfterOnlineSubs() throws Exception {
0:         Connection con = createConnection("offCli1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         con = createConnection("offCli2");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         Connection con2 = createConnection("onlineCli1");
0:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener2 = new Listener();
0:         consumer2.setMessageListener(listener2);
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0: 
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         // test online subs
0:         Thread.sleep(3 * 1000);
0:         session2.close();
0:         con2.close();
0:         assertEquals(sent, listener2.count);
0: 
0:         // restart broker
0:         broker.stop();
0:         createBroker(false /*deleteAllMessages*/);
0: 
0:         // test offline
0:         con = createConnection("offCli1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: 
0:         Connection con3 = createConnection("offCli2");
0:         Session session3 = con3.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer3 = session3.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0: 
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Listener listener3 = new Listener();
0:         consumer3.setMessageListener(listener3);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0:         session3.close();
0:         con3.close();
0: 
0:         assertEquals(sent, listener.count);
0:         assertEquals(sent, listener3.count);
0:     }
commit:6fd292d
/////////////////////////////////////////////////////////////////////////
0:     public void x_initCombosForTestConsumeOnlyMatchedMessages() throws Exception {
0:     public void testConsumeOnlyMatchedMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:      public void testConsumeAllMatchedMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:      public void testVerifyAllConsumedAreAcked() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void testTwoOfflineSubscriptionCanConsume() throws Exception {
commit:6ddbba4
/////////////////////////////////////////////////////////////////////////
0:         return createConnection("cliName");
0:     }
0: 
0:     protected Connection createConnection(String name) throws Exception {
0:         con.setClientID(name);
/////////////////////////////////////////////////////////////////////////
0:          for (int i = 0; i < 10; i++) {
/////////////////////////////////////////////////////////////////////////
0:          assertEquals(sent, listener.count);
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void testOfflineSubscription4() throws Exception {
0:         // create durable subscription 1
0:         Connection con = createConnection("cliId1");
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // create durable subscription 2
0:         Connection con2 = createConnection("cliId2");
0:         Session session2 = con2.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer2 = session2.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener2 = new Listener();
0:         consumer2.setMessageListener(listener2);
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0: 
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0: 
0:         // test online subs
0:         Thread.sleep(3 * 1000);
0:         session2.close();
0:         con2.close();
0: 
0:         assertEquals(sent, listener2.count);
0: 
0:         // consume messages
0:         con = createConnection("cliId1");
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals("offline consumer got all", sent, listener.count);
0:     }
commit:514ef7d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(DurableSubscriptionOfflineTest.class);
/////////////////////////////////////////////////////////////////////////
0:         broker.getManagementContext().setCreateConnector(false);
/////////////////////////////////////////////////////////////////////////
0:      public void testOfflineSubscription2() throws Exception {
0:          // create durable subscription
0:          Connection con = createConnection();
0:          Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          session.close();
0:          con.close();
0: 
0:          // send messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageProducer producer = session.createProducer(null);
0: 
0:          int sent = 0;
0:          for (int i = 0; i < 10; i++) {
0:              sent++;
0:              Message message = session.createMessage();
0:              message.setStringProperty("filter", "true");
0:              producer.send(topic, message);
0:          }
0: 
0:          Thread.sleep(1 * 1000);
0: 
0:          session.close();
0:          con.close();
0: 
0:          // consume messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          Listener listener = new Listener();
0:          consumer.setMessageListener(listener);
0: 
0:          Thread.sleep(3 * 1000);
0: 
0:          session.close();
0:          con.close();
0: 
0:          assertEquals(sent, listener.count);
0:      }
0: 
0:      public void testOfflineSubscription3() throws Exception {
0:          // create durable subscription
0:          Connection con = createConnection();
0:          Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          session.close();
0:          con.close();
0: 
0:          // send messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageProducer producer = session.createProducer(null);
0: 
0:          final int numMessages = 10;
0:          int sent = 0;
0:          for (int i = 0; i < numMessages; i++) {
0:              sent++;
0:              Message message = session.createMessage();
0:              message.setStringProperty("filter", "true");
0:              producer.send(topic, message);
0:          }
0: 
0:          Thread.sleep(1 * 1000);
0: 
0:          session.close();
0:          con.close();
0: 
0:          // consume messages
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          Listener listener = new Listener();
0:          consumer.setMessageListener(listener);
0: 
0:          Thread.sleep(3 * 1000);
0: 
0:          session.close();
0:          con.close();
0: 
0:          LOG.info("Consumed: " + listener.count);
0:          assertEquals(numMessages, listener.count);
0: 
0:          // consume messages again, should not get any
0:          con = createConnection();
0:          session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:          consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:          listener = new Listener();
0:          consumer.setMessageListener(listener);
0: 
0:          Thread.sleep(3 * 1000);
0: 
0:          session.close();
0:          con.close();
0: 
0:          assertEquals(0, listener.count);
0:      }
0:     
commit:3432a75
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.Test;
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
0:     public Boolean usePrioritySupport = Boolean.TRUE;
0:         return new ActiveMQConnectionFactory("vm://" + getName(true));
/////////////////////////////////////////////////////////////////////////
0:     public static Test suite() {
0:         return suite(DurableSubscriptionOfflineTest.class);
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:         broker = BrokerFactory.createBroker("broker:(vm://" + getName(true) +")");
0:         broker.setBrokerName(getName(true));
0:         if (usePrioritySupport) {
0:             PolicyEntry policy = new PolicyEntry();
0:             policy.setPrioritizedMessages(true);
0:             PolicyMap policyMap = new PolicyMap();
0:             policyMap.setDefaultEntry(policy);
0:             broker.setDestinationPolicy(policyMap);
0:         }
0:         
0:         setDefaultPersistenceAdapter(broker);
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestOfflineSubscription() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:         this.addCombinationValues("usePrioritySupport",
0:                 new Object[]{ Boolean.TRUE, Boolean.FALSE});
0:     }
0: 
commit:5cbb4db
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.usecases;
0: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.BrokerFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
0: 
0: import javax.jms.*;
0: import java.io.File;
0: 
0: public class DurableSubscriptionOfflineTest extends org.apache.activemq.TestSupport {
0: 
0:     private BrokerService broker;
0:     private ActiveMQTopic topic;
0: 
1:     protected ActiveMQConnectionFactory createConnectionFactory() throws Exception {
0:         return new ActiveMQConnectionFactory("vm://" + getName());
0:     }
0: 
0:     @Override
0:     protected Connection createConnection() throws Exception {
0:         Connection con = super.createConnection();
0:         con.setClientID("cliName");
0:         con.start();
0:         return con;
0:     }
0: 
0:     protected void setUp() throws Exception {
0:         topic = (ActiveMQTopic) createDestination();
0:         createBroker();
0:         super.setUp();
0:     }
0: 
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
0:         destroyBroker();
0:     }
0: 
0:     private void createBroker() throws Exception {
0:         broker = BrokerFactory.createBroker("broker:(vm://localhost)");
0:         broker.setBrokerName(getName());
0:         broker.setDeleteAllMessagesOnStartup(true);
0: 
0:         broker.setPersistent(true);
0:         KahaDBPersistenceAdapter persistenceAdapter = new KahaDBPersistenceAdapter();
0:         persistenceAdapter.setDirectory(new File("activemq-data-kaha/" + getName()));
0:         broker.setPersistenceAdapter(persistenceAdapter);
0: 
0:         broker.start();
0:     }
0: 
0:     private void destroyBroker() throws Exception {
0:         if (broker != null)
0:             broker.stop();
0:     }
0: 
0:     public void testOfflineSubscription() throws Exception {
0:         // create durable subscription
0:         Connection con = createConnection();
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0: 
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0: 
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             boolean filter = i % 2 == 1;
0:             if (filter)
0:                 sent++;
0: 
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", filter ? "true" : "false");
0:             producer.send(topic, message);
0:         }
0: 
0:         session.close();
0:         con.close();
0: 
0:         // consume messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0: 
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(sent, listener.count);
0:     }
0: 
0:     public static class Listener implements MessageListener {
0:         int count = 0;
0: 
0:         public void onMessage(Message message) {
0:             count++;
0:         }
0:     }
0: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:77a679b
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:                new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{ PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.LevelDB, PersistenceAdapterChoice.JDBC});
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.disk.journal.Journal;
0: import org.apache.activemq.store.kahadb.disk.page.PageFile;
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:4a0bc68
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     private List<Throwable> exceptions = new ArrayList<Throwable>();
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("No exceptions expected, but was: " + exceptions, exceptions.isEmpty());
author:Robert Davies
-------------------------------------------------------------------------------
commit:8e61f51
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:         broker = BrokerFactory.createBroker("broker:(vm://" + getName(true) + ")");
/////////////////////////////////////////////////////////////////////////
0: 
0:             ((JDBCPersistenceAdapter) broker.getPersistenceAdapter()).setCleanupPeriod(2 * 1000);
0:             ((KahaDBPersistenceAdapter) broker.getPersistenceAdapter()).setJournalMaxFileLength(journalMaxFileLength);
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:                 new Object[]{Boolean.TRUE, Boolean.FALSE});
/////////////////////////////////////////////////////////////////////////
0:     public void testConsumeAllMatchedMessages() throws Exception {
0:         // create durable subscription
0:         Connection con = createConnection();
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0:         // consume messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Thread.sleep(3 * 1000);
0:         session.close();
0:         con.close();
0:         assertEquals(sent, listener.count);
0:     public void initCombosForTestVerifyAllConsumedAreAcked() throws Exception {
0:         this.addCombinationValues("defaultPersistenceAdapter",
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:         this.addCombinationValues("usePrioritySupport",
0:                 new Object[]{Boolean.TRUE, Boolean.FALSE});
0:     }
0:     public void testVerifyAllConsumedAreAcked() throws Exception {
0:         // create durable subscription
0:         Connection con = createConnection();
0:         Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         session.close();
0:         con.close();
0:         // send messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageProducer producer = session.createProducer(null);
0:         int sent = 0;
0:         for (int i = 0; i < 10; i++) {
0:             sent++;
0:             Message message = session.createMessage();
0:             message.setStringProperty("filter", "true");
0:             producer.send(topic, message);
0:         }
0:         Thread.sleep(1 * 1000);
0:         session.close();
0:         con.close();
0:         // consume messages
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         MessageConsumer consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         Listener listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Thread.sleep(3 * 1000);
0:         session.close();
0:         con.close();
0:         LOG.info("Consumed: " + listener.count);
0:         assertEquals(sent, listener.count);
0:         // consume messages again, should not get any
0:         con = createConnection();
0:         session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         consumer = session.createDurableSubscriber(topic, "SubsId", "filter = 'true'", true);
0:         listener = new Listener();
0:         consumer.setMessageListener(listener);
0:         Thread.sleep(3 * 1000);
0: 
0:         session.close();
0:         con.close();
0: 
0:         assertEquals(0, listener.count);
0:     }
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0:                 new Object[]{Boolean.TRUE, Boolean.FALSE});
/////////////////////////////////////////////////////////////////////////
0:     }
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0: 
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{PersistenceAdapterChoice.KahaDB, PersistenceAdapterChoice.JDBC});
/////////////////////////////////////////////////////////////////////////
0:             boolean filter = (i % 2 == 0); //(int) (Math.random() * 2) >= 1;
/////////////////////////////////////////////////////////////////////////
0:             message.setStringProperty("filter", i == 1 ? "true" : "false");
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 new Object[]{new Integer(64 * 1024)});
/////////////////////////////////////////////////////////////////////////
0:         final String payload = new byte[40 * 1024].toString();
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Want: " + toSend + ", current: " + listener.count);
/////////////////////////////////////////////////////////////////////////
0:         assertEquals("only one journal file left after restart", 1, pa.getStore().getJournalManager().getFileMap().size());
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:                 } catch (Exception ignored) {
0:                 }
0:     public class FilterCheckListener extends Listener {
/////////////////////////////////////////////////////////////////////////
0:                 } else {
0:             } catch (JMSException e) {
============================================================================