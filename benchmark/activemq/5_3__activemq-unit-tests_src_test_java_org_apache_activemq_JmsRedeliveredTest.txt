2:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
4:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
31:d29ca2a: 
1:dbb1d8b: import java.util.concurrent.TimeUnit;
1:d29ca2a: import javax.jms.Connection;
1:d29ca2a: import javax.jms.DeliveryMode;
1:d29ca2a: import javax.jms.Destination;
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.Message;
1:d29ca2a: import javax.jms.MessageConsumer;
1:d29ca2a: import javax.jms.MessageProducer;
1:d29ca2a: import javax.jms.Queue;
1:d29ca2a: import javax.jms.Session;
1:d29ca2a: import javax.jms.TextMessage;
1:d29ca2a: import javax.jms.Topic;
1:d29ca2a: 
1:d29ca2a: import junit.framework.Test;
1:d29ca2a: import junit.framework.TestCase;
1:d29ca2a: import junit.framework.TestSuite;
1:eb6c082: import org.apache.activemq.command.ConsumerControl;
1:a2c5c22: import org.apache.activemq.transport.vm.VMTransport;
1:a2c5c22: import org.apache.activemq.util.Wait;
1:d29ca2a: 
1:230a86c: /**
1:b0c2a40:  * 
1:d29ca2a:  */
1:d29ca2a: public class JmsRedeliveredTest extends TestCase {
1:d29ca2a: 
1:d29ca2a:     private Connection connection;
1:230a86c: 
1:230a86c:     /*
1:230a86c:      * (non-Javadoc)
1:230a86c:      * 
1:d29ca2a:      * @see junit.framework.TestCase#setUp()
1:d29ca2a:      */
1:d29ca2a:     protected void setUp() throws Exception {
1:d29ca2a:         connection = createConnection();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @see junit.framework.TestCase#tearDown()
1:d29ca2a:      */
1:d29ca2a:     protected void tearDown() throws Exception {
1:d29ca2a:         if (connection != null) {
1:d29ca2a:             connection.close();
1:d29ca2a:             connection = null;
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Creates a connection.
1:d29ca2a:      * 
1:d29ca2a:      * @return connection
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:230a86c:     protected Connection createConnection() throws Exception {
1:230a86c:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:230a86c:                                                                           "vm://localhost?broker.persistent=false");
1:d29ca2a:         return factory.createConnection();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Tests if a message unacknowledged message gets to be resent when the
1:230a86c:      * session is closed and then a new consumer session is created.
1:d29ca2a:      * 
1:d29ca2a:      */
1:d29ca2a:     public void testQueueSessionCloseMarksMessageRedelivered() throws JMSException {
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Queue queue = session.createQueue("queue-" + getName());
1:d29ca2a:         MessageProducer producer = createProducer(session, queue);
1:d29ca2a:         producer.send(createTextMessage(session));
1:d29ca2a: 
1:d29ca2a:         // Consume the message...
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(queue);
1:d29ca2a:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         // Don't ack the message.
1:230a86c: 
1:230a86c:         // Reset the session. This should cause the Unacked message to be
1:230a86c:         // redelivered.
1:d29ca2a:         session.close();
1:d29ca2a:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:230a86c: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         consumer = session.createConsumer(queue);
1:d29ca2a:         msg = consumer.receive(2000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         msg.acknowledge();
1:230a86c: 
1:eb6c082:         session.close();
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     
1:230a86c: 
1:3b08860:     public void testQueueSessionCloseMarksUnAckedMessageRedelivered() throws JMSException {
1:3b08860:         connection.start();
1:d29ca2a: 
1:3b08860:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Queue queue = session.createQueue("queue-" + getName());
1:3b08860:         MessageProducer producer = createProducer(session, queue);
1:3b08860:         producer.send(createTextMessage(session, "1"));
1:3b08860:         producer.send(createTextMessage(session, "2"));
1:d29ca2a: 
1:3b08860:         // Consume the message...
1:3b08860:         MessageConsumer consumer = session.createConsumer(queue);
1:3b08860:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:3b08860:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:3b08860:         assertEquals("1", ((TextMessage)msg).getText());
1:3b08860:         msg.acknowledge();
1:d29ca2a:         
1:3b08860:         // Don't ack the message.
1:3b08860:         msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:3b08860:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:3b08860:         assertEquals("2", ((TextMessage)msg).getText());
1:d29ca2a:         
1:230a86c:         // Reset the session. This should cause the Unacked message to be
1:230a86c:         // redelivered.
1:d29ca2a:         session.close();
1:3b08860:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:d29ca2a: 
1:3b08860:         // Attempt to Consume the message...
1:3b08860:         consumer = session.createConsumer(queue);
1:3b08860:         msg = consumer.receive(2000);
1:230a86c:         assertNotNull(msg);
1:3b08860:         assertEquals("2", ((TextMessage)msg).getText());
1:eb6c082:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:3b08860:         msg.acknowledge();
1:d29ca2a: 
1:3b08860:         session.close();
1:3b08860:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Tests session recovery and that the redelivered message is marked as
1:230a86c:      * such. Session uses client acknowledgement, the destination is a queue.
1:d29ca2a:      * 
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testQueueRecoverMarksMessageRedelivered() throws JMSException {
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:3b08860:         Queue queue = session.createQueue("queue-" + getName());
1:d29ca2a:         MessageProducer producer = createProducer(session, queue);
1:d29ca2a:         producer.send(createTextMessage(session));
1:d29ca2a: 
1:d29ca2a:         // Consume the message...
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(queue);
1:d29ca2a:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         // Don't ack the message.
1:d29ca2a: 
1:230a86c:         // Reset the session. This should cause the Unacked message to be
1:230a86c:         // redelivered.
1:d29ca2a:         session.recover();
1:230a86c: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         msg = consumer.receive(2000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         msg.acknowledge();
1:230a86c: 
1:d29ca2a:         session.close();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Tests rollback message to be marked as redelivered. Session uses client
1:230a86c:      * acknowledgement and the destination is a queue.
1:d29ca2a:      * 
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testQueueRollbackMarksMessageRedelivered() throws JMSException {
1:d29ca2a:         connection.start();
1:230a86c: 
1:d29ca2a:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Queue queue = session.createQueue("queue-" + getName());
1:d29ca2a:         MessageProducer producer = createProducer(session, queue);
1:d29ca2a:         producer.send(createTextMessage(session));
1:d29ca2a:         session.commit();
1:230a86c: 
1:d29ca2a:         // Get the message... Should not be redelivered.
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(queue);
1:d29ca2a:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:230a86c: 
1:d29ca2a:         // Rollback.. should cause redelivery.
1:d29ca2a:         session.rollback();
1:230a86c: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         msg = consumer.receive(2000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:230a86c: 
1:d29ca2a:         session.commit();
1:d29ca2a:         session.close();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Tests if the message gets to be re-delivered when the session closes and
1:230a86c:      * that the re-delivered message is marked as such. Session uses client
1:230a86c:      * acknowledgment, the destination is a topic and the consumer is a durable
1:230a86c:      * subscriber.
1:d29ca2a:      * 
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testDurableTopicSessionCloseMarksMessageRedelivered() throws JMSException {
1:a2c5c22:         connection.setClientID(getName());
1:a2c5c22:         connection.start();
1:eb6c082: 
1:d29ca2a:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Topic topic = session.createTopic("topic-" + getName());
1:d29ca2a:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub1");
1:a2c5c22: 
1:230a86c:         // This case only works with persistent messages since transient
1:230a86c:         // messages
1:0f502fa:         // are dropped when the consumer goes offline.
1:0f502fa:         MessageProducer producer = session.createProducer(topic);
1:0f502fa:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
1:d29ca2a:         producer.send(createTextMessage(session));
1:dbb1d8b: 
1:d29ca2a:         // Consume the message...
1:d29ca2a:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be re-delivered.", msg.getJMSRedelivered());
1:d29ca2a:         // Don't ack the message.
1:230a86c: 
1:230a86c:         // Reset the session. This should cause the Unacked message to be
1:230a86c:         // re-delivered.
1:d29ca2a:         session.close();
1:d29ca2a:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:230a86c: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         consumer = session.createDurableSubscriber(topic, "sub1");
1:d29ca2a:         msg = consumer.receive(2000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         msg.acknowledge();
1:230a86c: 
1:d29ca2a:         session.close();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Tests session recovery and that the redelivered message is marked as
1:230a86c:      * such. Session uses client acknowledgement, the destination is a topic and
1:230a86c:      * the consumer is a durable suscriber.
1:d29ca2a:      * 
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testDurableTopicRecoverMarksMessageRedelivered() throws JMSException {
1:d29ca2a:         connection.setClientID(getName());
1:d29ca2a:         connection.start();
1:230a86c: 
1:d29ca2a:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Topic topic = session.createTopic("topic-" + getName());
1:d29ca2a:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub1");
1:230a86c: 
2:d29ca2a:         MessageProducer producer = createProducer(session, topic);
1:d29ca2a:         producer.send(createTextMessage(session));
1:230a86c: 
1:d29ca2a:         // Consume the message...
1:d29ca2a:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         // Don't ack the message.
1:230a86c: 
1:230a86c:         // Reset the session. This should cause the Unacked message to be
1:230a86c:         // redelivered.
1:d29ca2a:         session.recover();
1:230a86c: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         msg = consumer.receive(2000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         msg.acknowledge();
1:230a86c: 
1:d29ca2a:         session.close();
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Tests rollback message to be marked as redelivered. Session uses client
1:230a86c:      * acknowledgement and the destination is a topic.
1:230a86c:      * 
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testDurableTopicRollbackMarksMessageRedelivered() throws JMSException {
1:d29ca2a:         connection.setClientID(getName());
1:d29ca2a:         connection.start();
1:230a86c: 
1:d29ca2a:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Topic topic = session.createTopic("topic-" + getName());
1:d29ca2a:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub1");
1:230a86c: 
1:d29ca2a:         MessageProducer producer = createProducer(session, topic);
1:d29ca2a:         producer.send(createTextMessage(session));
1:d29ca2a:         session.commit();
1:230a86c: 
1:d29ca2a:         // Get the message... Should not be redelivered.
1:d29ca2a:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:d29ca2a: 
1:d29ca2a:         // Rollback.. should cause redelivery.
1:d29ca2a:         session.rollback();
1:d29ca2a: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         msg = consumer.receive(2000);
14:d29ca2a:         assertNotNull(msg);
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:d29ca2a: 
1:d29ca2a:         session.commit();
1:d29ca2a:         session.close();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * 
1:d29ca2a:      * 
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testTopicRecoverMarksMessageRedelivered() throws JMSException {
1:d29ca2a: 
1:d29ca2a:         connection.setClientID(getName());
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Topic topic = session.createTopic("topic-" + getName());
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(topic);
1:230a86c: 
1:d29ca2a:         MessageProducer producer = createProducer(session, topic);
1:d29ca2a:         producer.send(createTextMessage(session));
1:230a86c: 
1:d29ca2a:         // Consume the message...
1:d29ca2a:         Message msg = consumer.receive(1000);
1:230a86c:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         // Don't ack the message.
1:230a86c: 
1:3b08860:         // Reset the session. This should cause the Unacked message to be
1:3b08860:         // redelivered.
1:d29ca2a:         session.recover();
1:230a86c: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         msg = consumer.receive(2000);
1:230a86c:         assertNotNull(msg);
1:230a86c:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:d29ca2a:         msg.acknowledge();
1:d29ca2a: 
1:d29ca2a:         session.close();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Tests rollback message to be marked as redelivered. Session uses client
1:230a86c:      * acknowledgement and the destination is a topic.
1:d29ca2a:      * 
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testTopicRollbackMarksMessageRedelivered() throws JMSException {
1:d29ca2a:         connection.setClientID(getName());
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:230a86c:         Topic topic = session.createTopic("topic-" + getName());
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(topic);
1:d29ca2a: 
1:d29ca2a:         MessageProducer producer = createProducer(session, topic);
1:d29ca2a:         producer.send(createTextMessage(session));
1:d29ca2a:         session.commit();
1:d29ca2a: 
1:d29ca2a:         // Get the message... Should not be redelivered.
1:d29ca2a:         Message msg = consumer.receive(1000);
1:d29ca2a:         assertNotNull(msg);
1:d29ca2a:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:d29ca2a: 
1:d29ca2a:         // Rollback.. should cause redelivery.
1:d29ca2a:         session.rollback();
1:d29ca2a: 
1:d29ca2a:         // Attempt to Consume the message...
1:d29ca2a:         msg = consumer.receive(2000);
1:d29ca2a:         assertNotNull(msg);
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:d29ca2a: 
1:d29ca2a:         session.commit();
1:d29ca2a:         session.close();
1:d29ca2a:     }
1:d29ca2a: 
1:eb6c082:     public void testNoReceiveConsumerDisconnectDoesIncrementRedelivery() throws Exception {
1:d29ca2a:         connection.setClientID(getName());
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:a2c5c22:         Connection keepBrokerAliveConnection = createConnection();
1:a2c5c22:         keepBrokerAliveConnection.start();
1:a2c5c22: 
1:a2c5c22:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:a2c5c22:         Queue queue = session.createQueue("queue-" + getName());
1:a2c5c22:         final MessageConsumer consumer = session.createConsumer(queue);
1:a2c5c22: 
1:a2c5c22:         MessageProducer producer = createProducer(session, queue);
1:a2c5c22:         producer.send(createTextMessage(session));
1:a2c5c22:         session.commit();
1:a2c5c22: 
1:a2c5c22:         Wait.waitFor(new Wait.Condition() {
1:a2c5c22:             @Override
1:a2c5c22:             public boolean isSatisified() throws Exception {
1:a2c5c22:                 return ((ActiveMQMessageConsumer)consumer).getMessageSize() == 1;
1:a2c5c22:             }
1:a2c5c22:         });
1:a2c5c22: 
1:eb6c082:         // whack the connection - like a rebalance or tcp drop - consumer does not get to communicate
1:eb6c082:         // a close and delivered sequence info to broker. So broker is in the dark and must increment
1:eb6c082:         // redelivery to be safe
1:a2c5c22:         ((ActiveMQConnection)connection).getTransport().narrow(VMTransport.class).stop();
1:a2c5c22: 
1:a2c5c22:         session = keepBrokerAliveConnection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:a2c5c22:         MessageConsumer messageConsumer = session.createConsumer(queue);
1:a2c5c22:         Message msg = messageConsumer.receive(1000);
1:a2c5c22:         assertNotNull(msg);
1:a2c5c22:         msg.acknowledge();
1:a2c5c22: 
1:d29ca2a:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:a2c5c22:         session.close();
1:eb6c082:         keepBrokerAliveConnection.close();
1:eb6c082:     }
1:eb6c082: 
1:eb6c082:     public void testNoReceiveConsumerAbortDoesNotIncrementRedelivery() throws Exception {
1:eb6c082:         connection.setClientID(getName());
1:eb6c082:         connection.start();
1:eb6c082: 
1:eb6c082:         Connection keepBrokerAliveConnection = createConnection();
1:eb6c082:         keepBrokerAliveConnection.start();
1:eb6c082: 
1:eb6c082:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:eb6c082:         Queue queue = session.createQueue("queue-" + getName());
1:eb6c082:         final MessageConsumer consumer = session.createConsumer(queue);
1:eb6c082: 
1:eb6c082:         MessageProducer producer = createProducer(session, queue);
1:eb6c082:         producer.send(createTextMessage(session));
1:eb6c082:         session.commit();
1:eb6c082: 
1:eb6c082:         Wait.waitFor(new Wait.Condition() {
1:eb6c082:             @Override
1:eb6c082:             public boolean isSatisified() throws Exception {
1:eb6c082:                 return ((ActiveMQMessageConsumer)consumer).getMessageSize() == 1;
1:eb6c082:             }
1:eb6c082:         });
1:a2c5c22: 
1:eb6c082:         // on abort via something like slowConsumerPolicy
1:eb6c082:         ConsumerControl consumerControl = new ConsumerControl();
1:eb6c082:         consumerControl.setConsumerId(((ActiveMQMessageConsumer)consumer).getConsumerId());
1:eb6c082:         consumerControl.setClose(true);
1:eb6c082:         ((ActiveMQConnection) connection).getTransport().narrow(VMTransport.class).getTransportListener().onCommand(consumerControl);
1:eb6c082: 
1:eb6c082:         Wait.waitFor(new Wait.Condition() {
1:eb6c082:             @Override
1:eb6c082:             public boolean isSatisified() throws Exception {
1:eb6c082:                 return ((ActiveMQMessageConsumer)consumer).getMessageSize() == 0;
1:eb6c082:             }
1:eb6c082:         });
1:eb6c082: 
1:eb6c082:         session = keepBrokerAliveConnection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:eb6c082:         MessageConsumer messageConsumer = session.createConsumer(queue);
1:eb6c082:         Message msg = messageConsumer.receive(1000);
1:eb6c082:         assertNotNull(msg);
1:eb6c082:         msg.acknowledge();
1:eb6c082: 
1:a2c5c22:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:3b08860:         session.close();
1:a2c5c22:         keepBrokerAliveConnection.close();
1:a2c5c22:     }
1:d29ca2a: 
1:dbb1d8b:     public void testNoReceiveConsumerDoesNotIncrementRedelivery() throws Exception {
1:dbb1d8b:         connection.setClientID(getName());
1:dbb1d8b:         connection.start();
1:dbb1d8b: 
1:dbb1d8b:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:dbb1d8b:         Queue queue = session.createQueue("queue-" + getName());
1:dbb1d8b:         MessageConsumer consumer = session.createConsumer(queue);
1:dbb1d8b: 
1:dbb1d8b:         MessageProducer producer = createProducer(session, queue);
1:dbb1d8b:         producer.send(createTextMessage(session));
1:dbb1d8b:         session.commit();
1:dbb1d8b: 
1:dbb1d8b:         TimeUnit.SECONDS.sleep(1);
1:dbb1d8b:         consumer.close();
1:dbb1d8b: 
1:dbb1d8b:         consumer = session.createConsumer(queue);
1:dbb1d8b:         Message msg = consumer.receive(1000);
1:dbb1d8b:         assertNotNull(msg);
1:dbb1d8b: 
1:dbb1d8b:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:dbb1d8b:         session.close();
1:dbb1d8b:     }
1:dbb1d8b: 
1:dbb1d8b:     public void testNoReceiveDurableConsumerDoesNotIncrementRedelivery() throws Exception {
1:dbb1d8b:         connection.setClientID(getName());
1:dbb1d8b:         connection.start();
1:dbb1d8b: 
1:dbb1d8b:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:dbb1d8b:         Topic topic = session.createTopic("topic-" + getName());
1:dbb1d8b:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub");
1:dbb1d8b: 
1:dbb1d8b:         MessageProducer producer = createProducer(session, topic);
1:dbb1d8b:         producer.send(createTextMessage(session));
1:dbb1d8b:         session.commit();
1:dbb1d8b: 
1:dbb1d8b:         TimeUnit.SECONDS.sleep(1);
1:dbb1d8b:         consumer.close();
1:dbb1d8b: 
1:dbb1d8b:         consumer = session.createDurableSubscriber(topic, "sub");
1:dbb1d8b:         Message msg = consumer.receive(1000);
1:dbb1d8b:         assertNotNull(msg);
1:dbb1d8b: 
1:dbb1d8b:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:dbb1d8b:         session.close();
1:dbb1d8b:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Creates a text message.
1:d29ca2a:      * 
2:d29ca2a:      * @param session
1:d29ca2a:      * @return TextMessage.
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     private TextMessage createTextMessage(Session session) throws JMSException {
1:3b08860:         return createTextMessage(session, "Hello");
1:d29ca2a:     }
1:230a86c: 
1:3b08860:     private TextMessage createTextMessage(Session session, String txt) throws JMSException {
1:3b08860:         return session.createTextMessage(txt);
1:d29ca2a:     }
1:d29ca2a:     
1:d29ca2a:     /**
1:230a86c:      * Creates a producer.
1:d29ca2a:      * 
1:230a86c:      * @param session
1:d29ca2a:      * @param queue - destination.
1:d29ca2a:      * @return MessageProducer
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     private MessageProducer createProducer(Session session, Destination queue) throws JMSException {
1:230a86c:         MessageProducer producer = session.createProducer(queue);
1:230a86c:         producer.setDeliveryMode(getDeliveryMode());
1:230a86c:         return producer;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * Returns delivery mode.
1:d29ca2a:      * 
1:230a86c:      * @return int - persistent delivery mode.
1:d29ca2a:      */
1:230a86c:     protected int getDeliveryMode() {
1:d29ca2a:         return DeliveryMode.PERSISTENT;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Run the JmsRedeliverTest with the delivery mode set as persistent.
1:d29ca2a:      */
1:fc00993:     public static final class PersistentCase extends JmsRedeliveredTest {
1:d29ca2a: 
1:d29ca2a:         /**
1:230a86c:          * Returns delivery mode.
1:d29ca2a:          * 
1:230a86c:          * @return int - persistent delivery mode.
1:d29ca2a:          */
3:d29ca2a:         protected int getDeliveryMode() {
1:d29ca2a:             return DeliveryMode.PERSISTENT;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Run the JmsRedeliverTest with the delivery mode set as non-persistent.
1:d29ca2a:      */
1:fc00993:     public static final class TransientCase extends JmsRedeliveredTest {
1:d29ca2a: 
1:d29ca2a:         /**
1:230a86c:          * Returns delivery mode.
1:d29ca2a:          * 
1:230a86c:          * @return int - non-persistent delivery mode.
1:d29ca2a:          */
1:230a86c:         protected int getDeliveryMode() {
1:d29ca2a:             return DeliveryMode.NON_PERSISTENT;
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public static Test suite() {
1:230a86c:         TestSuite suite = new TestSuite();
1:230a86c:         suite.addTestSuite(PersistentCase.class);
1:230a86c:         suite.addTestSuite(TransientCase.class);
1:d29ca2a:         return suite;
1:86cbdfd:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:gtully
-------------------------------------------------------------------------------
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
1:     public void testNoReceiveConsumerDisconnectDoesIncrementRedelivery() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         // whack the connection - like a rebalance or tcp drop - consumer does not get to communicate
1:         // a close and delivered sequence info to broker. So broker is in the dark and must increment
1:         // redelivery to be safe
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         session.close();
1:         keepBrokerAliveConnection.close();
1:     }
1: 
1:     public void testNoReceiveConsumerAbortDoesNotIncrementRedelivery() throws Exception {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Connection keepBrokerAliveConnection = createConnection();
1:         keepBrokerAliveConnection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:         Queue queue = session.createQueue("queue-" + getName());
1:         final MessageConsumer consumer = session.createConsumer(queue);
1: 
1:         MessageProducer producer = createProducer(session, queue);
1:         producer.send(createTextMessage(session));
1:         session.commit();
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return ((ActiveMQMessageConsumer)consumer).getMessageSize() == 1;
1:             }
1:         });
1: 
1:         // on abort via something like slowConsumerPolicy
1:         ConsumerControl consumerControl = new ConsumerControl();
1:         consumerControl.setConsumerId(((ActiveMQMessageConsumer)consumer).getConsumerId());
1:         consumerControl.setClose(true);
1:         ((ActiveMQConnection) connection).getTransport().narrow(VMTransport.class).getTransportListener().onCommand(consumerControl);
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return ((ActiveMQMessageConsumer)consumer).getMessageSize() == 0;
1:             }
1:         });
1: 
1:         session = keepBrokerAliveConnection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:         MessageConsumer messageConsumer = session.createConsumer(queue);
1:         Message msg = messageConsumer.receive(1000);
1:         assertNotNull(msg);
1:         msg.acknowledge();
1: 
commit:a2c5c22
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.vm.VMTransport;
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
0:     public void testNoReceiveConsumerDisconnectDoesNotIncrementRedelivery() throws Exception {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Connection keepBrokerAliveConnection = createConnection();
1:         keepBrokerAliveConnection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:         Queue queue = session.createQueue("queue-" + getName());
1:         final MessageConsumer consumer = session.createConsumer(queue);
1: 
1:         MessageProducer producer = createProducer(session, queue);
1:         producer.send(createTextMessage(session));
1:         session.commit();
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return ((ActiveMQMessageConsumer)consumer).getMessageSize() == 1;
1:             }
1:         });
1: 
0:         // whack the connection - like a rebalance or tcp drop
1:         ((ActiveMQConnection)connection).getTransport().narrow(VMTransport.class).stop();
1: 
1:         session = keepBrokerAliveConnection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:         MessageConsumer messageConsumer = session.createConsumer(queue);
1:         Message msg = messageConsumer.receive(1000);
1:         assertNotNull(msg);
1:         msg.acknowledge();
1: 
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         session.close();
1:         keepBrokerAliveConnection.close();
1:     }
1: 
commit:dbb1d8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:     public void testNoReceiveConsumerDoesNotIncrementRedelivery() throws Exception {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:         Queue queue = session.createQueue("queue-" + getName());
1:         MessageConsumer consumer = session.createConsumer(queue);
1: 
1:         MessageProducer producer = createProducer(session, queue);
1:         producer.send(createTextMessage(session));
1:         session.commit();
1: 
1:         TimeUnit.SECONDS.sleep(1);
1:         consumer.close();
1: 
1:         consumer = session.createConsumer(queue);
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);
1: 
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         session.close();
1:     }
1: 
1:     public void testNoReceiveDurableConsumerDoesNotIncrementRedelivery() throws Exception {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:         Topic topic = session.createTopic("topic-" + getName());
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub");
1: 
1:         MessageProducer producer = createProducer(session, topic);
1:         producer.send(createTextMessage(session));
1:         session.commit();
1: 
1:         TimeUnit.SECONDS.sleep(1);
1:         consumer.close();
1: 
1:         consumer = session.createDurableSubscriber(topic, "sub");
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);
1: 
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         session.close();
1:     }
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     public static final class PersistentCase extends JmsRedeliveredTest {
/////////////////////////////////////////////////////////////////////////
1:     public static final class TransientCase extends JmsRedeliveredTest {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /*
1:      * (non-Javadoc)
1:      * 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Creates a connection.
1:     protected Connection createConnection() throws Exception {
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(
1:                                                                           "vm://localhost?broker.persistent=false");
1:      * Tests if a message unacknowledged message gets to be resent when the
1:      * session is closed and then a new consumer session is created.
1:         Queue queue = session.createQueue("queue-" + getName());
1:         assertNotNull(msg);
1: 
1:         // Reset the session. This should cause the Unacked message to be
1:         // redelivered.
1: 
1:         assertNotNull(msg);
1: 
1:      * Tests session recovery and that the redelivered message is marked as
1:      * such. Session uses client acknowledgement, the destination is a queue.
/////////////////////////////////////////////////////////////////////////
1:         Queue queue = session.createQueue("queue-" + getName());
1:         assertNotNull(msg);
1: 
1:         // Reset the session. This should cause the Unacked message to be
1:         // redelivered.
1: 
1:         assertNotNull(msg);
1: 
1: 
1:      * Tests rollback message to be marked as redelivered. Session uses client
1:      * acknowledgement and the destination is a queue.
/////////////////////////////////////////////////////////////////////////
1:         Queue queue = session.createQueue("queue-" + getName());
1: 
1:         assertNotNull(msg);
1: 
1: 
1:         assertNotNull(msg);
1: 
1: 
1:      * Tests if the message gets to be re-delivered when the session closes and
1:      * that the re-delivered message is marked as such. Session uses client
1:      * acknowledgment, the destination is a topic and the consumer is a durable
1:      * subscriber.
/////////////////////////////////////////////////////////////////////////
1:         Topic topic = session.createTopic("topic-" + getName());
1:         // This case only works with persistent messages since transient
1:         // messages
/////////////////////////////////////////////////////////////////////////
1:         assertNotNull(msg);
1: 
1:         // Reset the session. This should cause the Unacked message to be
1:         // re-delivered.
1: 
1:         assertNotNull(msg);
1: 
1: 
1:      * Tests session recovery and that the redelivered message is marked as
1:      * such. Session uses client acknowledgement, the destination is a topic and
1:      * the consumer is a durable suscriber.
/////////////////////////////////////////////////////////////////////////
1:         Topic topic = session.createTopic("topic-" + getName());
/////////////////////////////////////////////////////////////////////////
1:         assertNotNull(msg);
1: 
1:         // Reset the session. This should cause the Unacked message to be
1:         // redelivered.
1: 
1:         assertNotNull(msg);
1: 
1: 
1:      * Tests rollback message to be marked as redelivered. Session uses client
1:      * acknowledgement and the destination is a topic.
/////////////////////////////////////////////////////////////////////////
1:         Topic topic = session.createTopic("topic-" + getName());
1: 
1:         assertNotNull(msg);
1: 
1: 
1:         assertNotNull(msg);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         Topic topic = session.createTopic("topic-" + getName());
/////////////////////////////////////////////////////////////////////////
1:         assertNotNull(msg);
1: 
1:         // Reset the session. This should cause the Unacked message to be
1:         // redelivered.
1: 
1:         assertNotNull(msg);
1: 
1: 
1:      * Tests rollback message to be marked as redelivered. Session uses client
1:      * acknowledgement and the destination is a topic.
1:      * 
/////////////////////////////////////////////////////////////////////////
1:         Topic topic = session.createTopic("topic-" + getName());
1: 
1:         assertNotNull(msg);
1: 
1: 
1:         assertNotNull(msg);
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Creates a producer.
1:      * @param session
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(getDeliveryMode());
1:         return producer;
1: 
1:      * Returns delivery mode.
1:      * @return int - persistent delivery mode.
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Returns delivery mode.
1:          * @return int - persistent delivery mode.
1:         protected int getDeliveryMode() {
/////////////////////////////////////////////////////////////////////////
1:          * Returns delivery mode.
1:          * @return int - non-persistent delivery mode.
1:         protected int getDeliveryMode() {
1: 
1:     public static Test suite() {
1:         TestSuite suite = new TestSuite();
1:         suite.addTestSuite(PersistentCase.class);
1:         suite.addTestSuite(TransientCase.class);
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: }
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:0f502fa
/////////////////////////////////////////////////////////////////////////
0:         // This case only works with persistent messages since transient messages
1:         // are dropped when the consumer goes offline.
1:         MessageProducer producer = session.createProducer(topic);
1:         producer.setDeliveryMode(DeliveryMode.PERSISTENT);
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.Topic;
1: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
1: 
1: import junit.framework.Test;
1: import junit.framework.TestCase;
1: import junit.framework.TestSuite;
1: 
1: /**
0:  * @version $Revision: 1.5 $
1:  */
1: public class JmsRedeliveredTest extends TestCase {
1: 
1:     private Connection connection;
1:     
0:     /* (non-Javadoc)
1:      * @see junit.framework.TestCase#setUp()
1:      */
1:     protected void setUp() throws Exception {
1:         connection = createConnection();
1:     }
1: 
1:     /**
1:      * @see junit.framework.TestCase#tearDown()
1:      */
1:     protected void tearDown() throws Exception {
1:         if (connection != null) {
1:             connection.close();
1:             connection = null;
1:         }
1:     }
1:     
1:     /**
0:      * Creates a connection. 
1:      * 
1:      * @return connection
1:      * @throws Exception
1:      */
0:     protected Connection createConnection() throws Exception{
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm://localhost?broker.persistent=false");
1:         return factory.createConnection();
1:     }
1: 
1:     /**
0:      * Tests if a message unacknowledged message gets to be resent when the session is closed and
0:      * then a new consumer session is created.     
1:      * 
1:      */
1:     public void testQueueSessionCloseMarksMessageRedelivered() throws JMSException {
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         Queue queue = session.createQueue("queue-"+getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         producer.send(createTextMessage(session));
1: 
1:         // Consume the message...
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         // Don't ack the message.
1:         
0:         // Reset the session.  This should cause the Unacked message to be redelivered.
1:         session.close();
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:                 
1:         // Attempt to Consume the message...
1:         consumer = session.createConsumer(queue);
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         msg.acknowledge();
1:         
1:         session.close();
1:     }
1: 
1:     /**
0:      * Tests session recovery and that the redelivered message is marked as such.
0:      * Session uses client acknowledgement, the destination is a queue.
1:      * 
1:      * @throws JMSException
1:      */
1:     public void testQueueRecoverMarksMessageRedelivered() throws JMSException {
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         Queue queue = session.createQueue("queue-"+getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         producer.send(createTextMessage(session));
1: 
1:         // Consume the message...
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         // Don't ack the message.
1:         
0:         // Reset the session.  This should cause the Unacked message to be redelivered.
1:         session.recover();
1:                 
1:         // Attempt to Consume the message...
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         msg.acknowledge();
1:         
1:         session.close();
1:     }
1:     
1:     /**
0:      * Tests rollback message to be marked as redelivered.
0:      * Session uses client acknowledgement and the destination is a queue.  
1:      * 
1:      * @throws JMSException
1:      */
1:     public void testQueueRollbackMarksMessageRedelivered() throws JMSException {
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
0:         Queue queue = session.createQueue("queue-"+getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         producer.send(createTextMessage(session));
1:         session.commit();
1:         
1:         // Get the message... Should not be redelivered.
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         
1:         // Rollback.. should cause redelivery.
1:         session.rollback();
1:                         
1:         // Attempt to Consume the message...
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         
1:         session.commit();
1:         session.close();
1:     }
1:     
1:     /**
0:      * Tests if the message gets to be re-delivered when the session closes and 
0:      * that the re-delivered message is marked as such.  
0:      * Session uses client acknowledgment, the destination is a topic and 
0:      * the consumer is a durable subscriber.
1:      * 
1:      * @throws JMSException
1:      */
1:     public void testDurableTopicSessionCloseMarksMessageRedelivered() throws JMSException {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         Topic topic = session.createTopic("topic-"+getName());
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub1");
1: 
1:         MessageProducer producer = createProducer(session, topic);
1:         producer.send(createTextMessage(session));
1: 
1:         // Consume the message...
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be re-delivered.", msg.getJMSRedelivered());
1:         // Don't ack the message.
1:         
0:         // Reset the session.  This should cause the Unacked message to be re-delivered.
1:         session.close();
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:                 
1:         // Attempt to Consume the message...
1:         consumer = session.createDurableSubscriber(topic, "sub1");
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         msg.acknowledge();
1:         
1:         session.close();
1:     }
1:     
1:     /**
0:      * Tests session recovery and that the redelivered message is marked as such.
0:      * Session uses client acknowledgement, the destination is a topic and
0:      * the consumer is a durable suscriber. 
1:      * 
1:      * @throws JMSException
1:      */
1:     public void testDurableTopicRecoverMarksMessageRedelivered() throws JMSException {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         Topic topic = session.createTopic("topic-"+getName());
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub1");
1: 
1:         MessageProducer producer = createProducer(session, topic);
1:         producer.send(createTextMessage(session));
1: 
1:         // Consume the message...
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         // Don't ack the message.
1:         
0:         // Reset the session.  This should cause the Unacked message to be redelivered.
1:         session.recover();
1:                 
1:         // Attempt to Consume the message...
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         msg.acknowledge();
1:         
1:         session.close();
1:     }
1:     
1:     /**
0:      * Tests rollback message to be marked as redelivered.
0:      * Session uses client acknowledgement and the destination is a topic.  
1:      * 
1:      * @throws JMSException
1:      */
1:     public void testDurableTopicRollbackMarksMessageRedelivered() throws JMSException {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
0:         Topic topic = session.createTopic("topic-"+getName());
1:         MessageConsumer consumer = session.createDurableSubscriber(topic, "sub1");
1: 
1:         MessageProducer producer = createProducer(session, topic);
1:         producer.send(createTextMessage(session));
1:         session.commit();
1:         
1:         // Get the message... Should not be redelivered.
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         
1:         // Rollback.. should cause redelivery.
1:         session.rollback();
1:                         
1:         // Attempt to Consume the message...
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         
1:         
1:         session.commit();
1:         session.close();
1:     }
1:      
1:     /**
1:      * 
1:      * 
1:      * @throws JMSException
1:      */
1:     public void testTopicRecoverMarksMessageRedelivered() throws JMSException {
1: 
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0:         Topic topic = session.createTopic("topic-"+getName());
1:         MessageConsumer consumer = session.createConsumer(topic);
1: 
1:         MessageProducer producer = createProducer(session, topic);
1:         producer.send(createTextMessage(session));
1: 
1:         // Consume the message...
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         // Don't ack the message.
1:         
0:         // Reset the session.  This should cause the Unacked message to be redelivered.
1:         session.recover();
1:                 
1:         // Attempt to Consume the message...
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         msg.acknowledge();
1:         
1:         session.close();
1:     }
1:     
1:     /**
0:      * Tests rollback message to be marked as redelivered.
0:      * Session uses client acknowledgement and the destination is a topic.  
1:      *  
1:      * @throws JMSException
1:      */
1:     public void testTopicRollbackMarksMessageRedelivered() throws JMSException {
1:         connection.setClientID(getName());
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
0:         Topic topic = session.createTopic("topic-"+getName());
1:         MessageConsumer consumer = session.createConsumer(topic);
1: 
1:         MessageProducer producer = createProducer(session, topic);
1:         producer.send(createTextMessage(session));
1:         session.commit();
1:         
1:         // Get the message... Should not be redelivered.
1:         Message msg = consumer.receive(1000);
1:         assertNotNull(msg);        
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         
1:         // Rollback.. should cause redelivery.
1:         session.rollback();
1:                         
1:         // Attempt to Consume the message...
1:         msg = consumer.receive(2000);
1:         assertNotNull(msg);        
1:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());        
1:         
1:         session.commit();
1:         session.close();
1:     }
1: 
1:     /**
1:      * Creates a text message.
1:      * 
1:      * @param session
1:      * @return TextMessage.
1:      * @throws JMSException
1:      */
1:     private TextMessage createTextMessage(Session session) throws JMSException {
0:         return session.createTextMessage("Hello");
1:     }
1:    
1:     /**
0:      * Creates a producer. 
1:      * 
1:      * @param session  
1:      * @param queue - destination.
1:      * @return MessageProducer
1:      * @throws JMSException
1:      */
1:     private MessageProducer createProducer(Session session, Destination queue) throws JMSException {
0:          MessageProducer producer = session.createProducer(queue);
0:          producer.setDeliveryMode(getDeliveryMode());
0:          return producer;
1:     }
1:     
1:     /**
0:      * Returns delivery mode.  
1:      * 
0:      * @return int - persistent delivery mode.  
1:      */
1:     protected int getDeliveryMode() {
1:         return DeliveryMode.PERSISTENT;
1:     }
1: 
1:     /**
1:      * Run the JmsRedeliverTest with the delivery mode set as persistent.
1:      */
0:     static final public class PersistentCase extends JmsRedeliveredTest {
1: 
1:     	/**
0:          * Returns delivery mode.  
1:          * 
0:          * @return int - persistent delivery mode.  
1:          */
1:     	protected int getDeliveryMode() {
1:             return DeliveryMode.PERSISTENT;
1:         }
1:     }
1: 
1:     /**
1:      * Run the JmsRedeliverTest with the delivery mode set as non-persistent.
1:      */
0:     static final public class TransientCase extends JmsRedeliveredTest {
1: 
1:         /**
0:          * Returns delivery mode.  
1:          * 
0:          * @return int - non-persistent delivery mode.  
1:          */
1:     	protected int getDeliveryMode() {
1:             return DeliveryMode.NON_PERSISTENT;
1:         }
1:     }
1:     
0:     public static Test suite() { 
0:         TestSuite suite= new TestSuite(); 
0:         suite.addTestSuite(PersistentCase.class); 
0:         suite.addTestSuite(TransientCase.class); 
1:         return suite;
1:     }
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:3b08860
/////////////////////////////////////////////////////////////////////////
0:     
0: 
1:     public void testQueueSessionCloseMarksUnAckedMessageRedelivered() throws JMSException {
1:         connection.start();
0: 
1:         Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
1:         Queue queue = session.createQueue("queue-" + getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         producer.send(createTextMessage(session, "1"));
1:         producer.send(createTextMessage(session, "2"));
0: 
1:         // Consume the message...
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         Message msg = consumer.receive(1000);
0:         assertNotNull(msg);
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         assertEquals("1", ((TextMessage)msg).getText());
1:         msg.acknowledge();
0:         
1:         // Don't ack the message.
1:         msg = consumer.receive(1000);
0:         assertNotNull(msg);
1:         assertFalse("Message should not be redelivered.", msg.getJMSRedelivered());
1:         assertEquals("2", ((TextMessage)msg).getText());
0:         
1:         // Reset the session. This should cause the Unacked message to be
1:         // redelivered.
1:         session.close();
1:         session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
0: 
1:         // Attempt to Consume the message...
1:         consumer = session.createConsumer(queue);
1:         msg = consumer.receive(2000);
0:         assertNotNull(msg);
1:         assertEquals("2", ((TextMessage)msg).getText());
0:         assertTrue("Message should be redelivered.", msg.getJMSRedelivered());
1:         msg.acknowledge();
0: 
1:         session.close();
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:         return createTextMessage(session, "Hello");
1:     private TextMessage createTextMessage(Session session, String txt) throws JMSException {
1:         return session.createTextMessage(txt);
0:     }
0:     
============================================================================