1:bb8d32c: /*
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
5:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
2:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.memory;
1:f812e34: 
1:9ef4259: import java.io.IOException;
1:9ef4259: import java.util.ArrayList;
1:cfe099d: import java.util.Collections;
1:9ef4259: import java.util.Iterator;
1:cfe099d: import java.util.LinkedHashMap;
1:6da08b2: import java.util.List;
1:cfe099d: import java.util.Map;
1:9ef4259: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:9ef4259: 
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:88c1084: import org.apache.activemq.command.MessageId;
1:d29ca2a: import org.apache.activemq.command.TransactionId;
1:d29ca2a: import org.apache.activemq.command.XATransactionId;
1:ad1f751: import org.apache.activemq.store.InlineListenableFuture;
1:ad1f751: import org.apache.activemq.store.ListenableFuture;
1:d29ca2a: import org.apache.activemq.store.MessageStore;
1:529e5c2: import org.apache.activemq.store.PersistenceAdapter;
1:d29ca2a: import org.apache.activemq.store.ProxyMessageStore;
1:d29ca2a: import org.apache.activemq.store.ProxyTopicMessageStore;
1:d29ca2a: import org.apache.activemq.store.TopicMessageStore;
1:d29ca2a: import org.apache.activemq.store.TransactionRecoveryListener;
1:d29ca2a: import org.apache.activemq.store.TransactionStore;
1:d29ca2a: 
3:d29ca2a: /**
1:d29ca2a:  * Provides a TransactionStore implementation that can create transaction aware
1:d29ca2a:  * MessageStore objects from non transaction aware MessageStore objects.
1:d29ca2a:  */
1:d29ca2a: public class MemoryTransactionStore implements TransactionStore {
1:d29ca2a: 
1:9ef4259:     protected ConcurrentMap<Object, Tx> inflightTransactions = new ConcurrentHashMap<Object, Tx>();
1:cfe099d:     protected Map<TransactionId, Tx> preparedTransactions = Collections.synchronizedMap(new LinkedHashMap<TransactionId, Tx>());
1:64f3492:     protected final PersistenceAdapter persistenceAdapter;
1:d29ca2a: 
1:d29ca2a:     private boolean doingRecover;
1:d29ca2a: 
1:529e5c2:     public class Tx {
1:bb8d32c: 
1:6da08b2:         public List<AddMessageCommand> messages = Collections.synchronizedList(new ArrayList<AddMessageCommand>());
1:d29ca2a: 
1:6da08b2:         public final List<RemoveMessageCommand> acks = Collections.synchronizedList(new ArrayList<RemoveMessageCommand>());
1:d29ca2a: 
1:d29ca2a:         public void add(AddMessageCommand msg) {
1:d29ca2a:             messages.add(msg);
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         public void add(RemoveMessageCommand ack) {
1:d29ca2a:             acks.add(ack);
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         public Message[] getMessages() {
1:d29ca2a:             Message rc[] = new Message[messages.size()];
1:f812e34:             int count = 0;
1:933eb2f:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:933eb2f:                 AddMessageCommand cmd = iter.next();
1:f812e34:                 rc[count++] = cmd.getMessage();
1:d29ca2a:             }
1:d29ca2a:             return rc;
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         public MessageAck[] getAcks() {
1:d29ca2a:             MessageAck rc[] = new MessageAck[acks.size()];
1:f812e34:             int count = 0;
1:933eb2f:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:933eb2f:                 RemoveMessageCommand cmd = iter.next();
1:f812e34:                 rc[count++] = cmd.getMessageAck();
1:d29ca2a:             }
1:d29ca2a:             return rc;
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         /**
1:d29ca2a:          * @throws IOException
1:d29ca2a:          */
1:d29ca2a:         public void commit() throws IOException {
1:529e5c2:             ConnectionContext ctx = new ConnectionContext();
1:529e5c2:             persistenceAdapter.beginTransaction(ctx);
1:529e5c2:             try {
1:529e5c2: 
1:529e5c2:                 // Do all the message adds.
1:529e5c2:                 for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:529e5c2:                     AddMessageCommand cmd = iter.next();
1:529e5c2:                     cmd.run(ctx);
1:529e5c2:                 }
1:529e5c2:                 // And removes..
1:529e5c2:                 for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:529e5c2:                     RemoveMessageCommand cmd = iter.next();
1:529e5c2:                     cmd.run(ctx);
1:529e5c2:                 }
1:529e5c2: 
1:ea70e82:                 persistenceAdapter.commitTransaction(ctx);
1:ea70e82: 
1:bb8d32c:             } catch (IOException e) {
1:529e5c2:                 persistenceAdapter.rollbackTransaction(ctx);
1:529e5c2:                 throw e;
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:529e5c2: 
1:d29ca2a:     public interface AddMessageCommand {
1:d29ca2a:         Message getMessage();
1:f812e34: 
1:64f3492:         MessageStore getMessageStore();
1:f812e34: 
1:529e5c2:         void run(ConnectionContext context) throws IOException;
1:cfe099d: 
1:cfe099d:         void setMessageStore(MessageStore messageStore);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public interface RemoveMessageCommand {
1:d29ca2a:         MessageAck getMessageAck();
1:529e5c2: 
1:529e5c2:         void run(ConnectionContext context) throws IOException;
1:f812e34: 
1:64f3492:         MessageStore getMessageStore();
1:529e5c2:     }
1:d29ca2a: 
1:529e5c2:     public MemoryTransactionStore(PersistenceAdapter persistenceAdapter) {
1:bb8d32c:         this.persistenceAdapter = persistenceAdapter;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public MessageStore proxy(MessageStore messageStore) {
1:cfe099d:         ProxyMessageStore proxyMessageStore = new ProxyMessageStore(messageStore) {
1:64f3492:             @Override
1:f812e34:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:f812e34:             }
1:f812e34: 
1:27262c8:             @Override
1:d40f398:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:d29ca2a:             }
1:d29ca2a: 
1:d40f398:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
1:ad1f751:                 return new InlineListenableFuture();
1:bb8d32c:             }
1:d29ca2a: 
1:d40f398:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canoptimize) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
1:ad1f751:                 return new InlineListenableFuture();
1:bb8d32c:             }
1:d29ca2a: 
1:d40f398:             @Override
1:f812e34:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:f812e34:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1:f812e34:             }
1:d29ca2a: 
1:d40f398:             @Override
1:50daa35:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:d29ca2a:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1:d29ca2a:             }
1:f812e34:         };
1:cfe099d:         onProxyQueueStore(proxyMessageStore);
1:cfe099d:         return proxyMessageStore;
1:cfe099d:     }
1:cfe099d: 
1:cfe099d:     protected void onProxyQueueStore(ProxyMessageStore proxyMessageStore) {
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public TopicMessageStore proxy(TopicMessageStore messageStore) {
1:64f3492:         ProxyTopicMessageStore proxyTopicMessageStore = new ProxyTopicMessageStore(messageStore) {
1:88c1084:             @Override
1:f812e34:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:f812e34:             }
1:f812e34: 
1:27262c8:             @Override
1:d40f398:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:f812e34:             }
1:d29ca2a: 
1:27262c8:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
1:ad1f751:                 return new InlineListenableFuture();
1:bb8d32c:             }
1:d29ca2a: 
1:27262c8:             @Override
1:ad1f751:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
1:69767a2:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
1:ad1f751:                 return new InlineListenableFuture();
1:bb8d32c:             }
1:d29ca2a: 
1:27262c8:             @Override
1:f812e34:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:f812e34:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1:d29ca2a:             }
1:d29ca2a: 
1:27262c8:             @Override
1:50daa35:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
1:d29ca2a:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1:d29ca2a:             }
1:d29ca2a: 
1:27262c8:             @Override
1:bb8d32c:             public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId, MessageAck ack)
1:bb8d32c:                 throws IOException {
1:bb8d32c:                 MemoryTransactionStore.this.acknowledge((TopicMessageStore) getDelegate(), clientId, subscriptionName, messageId, ack);
1:d29ca2a:             }
1:f812e34:         };
1:64f3492:         onProxyTopicStore(proxyTopicMessageStore);
1:64f3492:         return proxyTopicMessageStore;
1:d29ca2a:     }
1:d29ca2a: 
1:64f3492:     protected void onProxyTopicStore(ProxyTopicMessageStore proxyTopicMessageStore) {
1:64f3492:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:d29ca2a:      */
1:9ef4259:     @Override
1:64f3492:     public void prepare(TransactionId txid) throws IOException {
1:933eb2f:         Tx tx = inflightTransactions.remove(txid);
1:fc00993:         if (tx == null) {
1:d29ca2a:             return;
1:fc00993:         }
1:d29ca2a:         preparedTransactions.put(txid, tx);
1:fc00993:     }
1:f812e34: 
1:d29ca2a:     public Tx getTx(Object txid) {
1:933eb2f:         Tx tx = inflightTransactions.get(txid);
1:fc00993:         if (tx == null) {
1:6da08b2:             synchronized (inflightTransactions) {
1:6da08b2:                 tx = inflightTransactions.get(txid);
1:6da08b2:                 if ( tx == null) {
1:6da08b2:                     tx = new Tx();
1:6da08b2:                     inflightTransactions.put(txid, tx);
1:6da08b2:                 }
1:6da08b2:             }
1:d29ca2a:         }
1:d29ca2a:         return tx;
1:d29ca2a:     }
1:d29ca2a: 
1:64f3492:     public Tx getPreparedTx(TransactionId txid) {
1:64f3492:         Tx tx = preparedTransactions.get(txid);
1:d29ca2a:         if (tx == null) {
1:d29ca2a:             tx = new Tx();
1:64f3492:             preparedTransactions.put(txid, tx);
1:d29ca2a:         }
1:64f3492:         return tx;
1:64f3492:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:bb8d32c:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit, Runnable postCommit) throws IOException {
1:27262c8:         if (preCommit != null) {
1:27262c8:             preCommit.run();
1:64f3492:         }
1:d29ca2a:         Tx tx;
1:f812e34:         if (wasPrepared) {
1:ea70e82:             tx = preparedTransactions.get(txid);
1:d29ca2a:         } else {
1:933eb2f:             tx = inflightTransactions.remove(txid);
1:d29ca2a:         }
1:f812e34: 
1:15f85cd:         if (tx != null) {
1:d29ca2a:             tx.commit();
1:d29ca2a:         }
1:ea70e82:         if (wasPrepared) {
1:ea70e82:             preparedTransactions.remove(txid);
1:ea70e82:         }
1:46e2e6e:         if (postCommit != null) {
1:46e2e6e:             postCommit.run();
1:88c1084:         }
1:88c1084:     }
1:f812e34: 
1:d29ca2a:     /**
1:d29ca2a:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:d29ca2a:      */
1:9ef4259:     @Override
1:64f3492:     public void rollback(TransactionId txid) throws IOException {
1:d29ca2a:         preparedTransactions.remove(txid);
1:d29ca2a:         inflightTransactions.remove(txid);
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void start() throws Exception {
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:d29ca2a:     }
1:d29ca2a: 
1:9ef4259:     @Override
1:fc00993:     public synchronized void recover(TransactionRecoveryListener listener) throws IOException {
1:d29ca2a:         // All the inflight transactions get rolled back..
1:f812e34:         inflightTransactions.clear();
1:d29ca2a:         this.doingRecover = true;
1:d29ca2a:         try {
1:933eb2f:             for (Iterator<TransactionId> iter = preparedTransactions.keySet().iterator(); iter.hasNext();) {
1:933eb2f:                 Object txid = iter.next();
1:933eb2f:                 Tx tx = preparedTransactions.get(txid);
1:bb8d32c:                 listener.recover((XATransactionId) txid, tx.getMessages(), tx.getAcks());
1:64f3492:                 onRecovered(tx);
1:f812e34:             }
1:d29ca2a:         } finally {
1:d29ca2a:             this.doingRecover = false;
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:64f3492:     protected void onRecovered(Tx tx) {
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param message
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:69767a2:     void addMessage(final ConnectionContext context, final MessageStore destination, final Message message) throws IOException {
1:d29ca2a: 
1:fc00993:         if (doingRecover) {
1:d29ca2a:             return;
1:fc00993:         }
1:d29ca2a: 
1:f812e34:         if (message.getTransactionId() != null) {
1:d29ca2a:             Tx tx = getTx(message.getTransactionId());
1:d29ca2a:             tx.add(new AddMessageCommand() {
1:bb8d32c:                 @SuppressWarnings("unused")
1:cfe099d:                 MessageStore messageStore = destination;
1:bb8d32c: 
1:9ef4259:                 @Override
1:d29ca2a:                 public Message getMessage() {
1:d29ca2a:                     return message;
1:d29ca2a:                 }
1:f812e34: 
1:64f3492:                 @Override
1:64f3492:                 public MessageStore getMessageStore() {
1:64f3492:                     return destination;
1:d29ca2a:                 }
1:d29ca2a: 
1:9ef4259:                 @Override
1:529e5c2:                 public void run(ConnectionContext ctx) throws IOException {
1:529e5c2:                     destination.addMessage(ctx, message);
1:64f3492:                 }
1:529e5c2: 
1:cfe099d:                 @Override
1:cfe099d:                 public void setMessageStore(MessageStore messageStore) {
1:cfe099d:                     this.messageStore = messageStore;
1:cfe099d:                 }
1:cfe099d: 
1:d29ca2a:             });
1:d29ca2a:         } else {
1:69767a2:             destination.addMessage(context, message);
1:d29ca2a:         }
1:d29ca2a:     }
1:529e5c2: 
1:d29ca2a:     /**
1:d29ca2a:      * @param ack
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:f812e34:     final void removeMessage(final MessageStore destination, final MessageAck ack) throws IOException {
1:fc00993:         if (doingRecover) {
1:d29ca2a:             return;
1:fc00993:         }
1:d29ca2a: 
1:d29ca2a:         if (ack.isInTransaction()) {
1:d29ca2a:             Tx tx = getTx(ack.getTransactionId());
1:d29ca2a:             tx.add(new RemoveMessageCommand() {
1:9ef4259:                 @Override
1:d29ca2a:                 public MessageAck getMessageAck() {
1:d29ca2a:                     return ack;
1:d29ca2a:                 }
1:f812e34: 
1:9ef4259:                 @Override
1:529e5c2:                 public void run(ConnectionContext ctx) throws IOException {
1:529e5c2:                     destination.removeMessage(ctx, ack);
1:d29ca2a:                 }
1:d29ca2a: 
1:9ef4259:                 @Override
1:64f3492:                 public MessageStore getMessageStore() {
1:64f3492:                     return destination;
1:64f3492:                 }
1:d29ca2a:             });
1:d29ca2a:         } else {
2:d29ca2a:             destination.removeMessage(null, ack);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:bb8d32c:     public void acknowledge(final TopicMessageStore destination, final String clientId, final String subscriptionName, final MessageId messageId,
1:bb8d32c:         final MessageAck ack) throws IOException {
1:88c1084:         if (doingRecover) {
1:d29ca2a:             return;
1:64f3492:         }
1:d29ca2a: 
1:88c1084:         if (ack.isInTransaction()) {
1:88c1084:             Tx tx = getTx(ack.getTransactionId());
1:88c1084:             tx.add(new RemoveMessageCommand() {
1:9ef4259:                 @Override
1:88c1084:                 public MessageAck getMessageAck() {
1:88c1084:                     return ack;
1:88c1084:                 }
1:64f3492: 
1:27262c8:                 @Override
1:88c1084:                 public void run(ConnectionContext ctx) throws IOException {
1:88c1084:                     destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);
1:64f3492:                 }
1:64f3492: 
1:64f3492:                 @Override
1:64f3492:                 public MessageStore getMessageStore() {
1:64f3492:                     return destination;
1:88c1084:                 }
1:88c1084:             });
1:88c1084:         } else {
1:88c1084:             destination.acknowledge(null, clientId, subscriptionName, messageId, ack);
1:88c1084:         }
1:88c1084:     }
1:64f3492: 
1:d29ca2a:     public void delete() {
2:d29ca2a:         inflightTransactions.clear();
1:d29ca2a:         preparedTransactions.clear();
1:f812e34:         doingRecover = false;
1:d29ca2a:     }
1:d29ca2a: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1:                 persistenceAdapter.commitTransaction(ctx);
1: 
/////////////////////////////////////////////////////////////////////////
1:             tx = preparedTransactions.get(txid);
/////////////////////////////////////////////////////////////////////////
1:         if (wasPrepared) {
1:             preparedTransactions.remove(txid);
1:         }
commit:6da08b2
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         public List<AddMessageCommand> messages = Collections.synchronizedList(new ArrayList<AddMessageCommand>());
1:         public final List<RemoveMessageCommand> acks = Collections.synchronizedList(new ArrayList<RemoveMessageCommand>());
/////////////////////////////////////////////////////////////////////////
1:             synchronized (inflightTransactions) {
1:                 tx = inflightTransactions.get(txid);
1:                 if ( tx == null) {
1:                     tx = new Tx();
1:                     inflightTransactions.put(txid, tx);
1:                 }
1:             }
commit:ad1f751
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.InlineListenableFuture;
1: import org.apache.activemq.store.ListenableFuture;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
1:                 return new InlineListenableFuture();
1:             public ListenableFuture<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canoptimize) throws IOException {
1:                 return new InlineListenableFuture();
/////////////////////////////////////////////////////////////////////////
1:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
1:                 return new InlineListenableFuture();
1:             public ListenableFuture<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
1:                 return new InlineListenableFuture();
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.LinkedHashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     protected Map<TransactionId, Tx> preparedTransactions = Collections.synchronizedMap(new LinkedHashMap<TransactionId, Tx>());
/////////////////////////////////////////////////////////////////////////
1: 
1:         void setMessageStore(MessageStore messageStore);
/////////////////////////////////////////////////////////////////////////
1:         ProxyMessageStore proxyMessageStore = new ProxyMessageStore(messageStore) {
/////////////////////////////////////////////////////////////////////////
1:         onProxyQueueStore(proxyMessageStore);
1:         return proxyMessageStore;
1:     }
1: 
1:     protected void onProxyQueueStore(ProxyMessageStore proxyMessageStore) {
/////////////////////////////////////////////////////////////////////////
1:                 MessageStore messageStore = destination;
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 public void setMessageStore(MessageStore messageStore) {
1:                     this.messageStore = messageStore;
1:                 }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:bb8d32c
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:         this.persistenceAdapter = persistenceAdapter;
/////////////////////////////////////////////////////////////////////////
1:             }
1:             }
/////////////////////////////////////////////////////////////////////////
1:             }
1:             }
/////////////////////////////////////////////////////////////////////////
1:             public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId, MessageAck ack)
1:                 throws IOException {
1:                 MemoryTransactionStore.this.acknowledge((TopicMessageStore) getDelegate(), clientId, subscriptionName, messageId, ack);
/////////////////////////////////////////////////////////////////////////
1:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit, Runnable postCommit) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                 listener.recover((XATransactionId) txid, tx.getMessages(), tx.getAcks());
/////////////////////////////////////////////////////////////////////////
1:                 @SuppressWarnings("unused")
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void acknowledge(final TopicMessageStore destination, final String clientId, final String subscriptionName, final MessageId messageId,
1:         final MessageAck ack) throws IOException {
/////////////////////////////////////////////////////////////////////////
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.ArrayList;
0: import java.util.Collections;
1: import java.util.Iterator;
0: import java.util.LinkedHashMap;
0: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected ConcurrentMap<Object, Tx> inflightTransactions = new ConcurrentHashMap<Object, Tx>();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 @Override
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:69767a2
/////////////////////////////////////////////////////////////////////////
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
/////////////////////////////////////////////////////////////////////////
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), send);
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
1:                 MemoryTransactionStore.this.addMessage(context, getDelegate(), message);
/////////////////////////////////////////////////////////////////////////
1:     void addMessage(final ConnectionContext context, final MessageStore destination, final Message message) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             destination.addMessage(context, message);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
/////////////////////////////////////////////////////////////////////////
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:529e5c2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0:     final PersistenceAdapter persistenceAdapter;
1:     public class Tx {
/////////////////////////////////////////////////////////////////////////
1:             ConnectionContext ctx = new ConnectionContext();
1:             persistenceAdapter.beginTransaction(ctx);
1:             try {
1:                 
1:                 // Do all the message adds.
1:                 for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:                     AddMessageCommand cmd = iter.next();
1:                     cmd.run(ctx);
1:                 }
1:                 // And removes..
1:                 for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:                     RemoveMessageCommand cmd = iter.next();
1:                     cmd.run(ctx);
1:                 }
1:                 
0:             } catch ( IOException e ) {
1:                 persistenceAdapter.rollbackTransaction(ctx);
1:                 throw e;
0:             persistenceAdapter.commitTransaction(ctx);
1:     
1:         void run(ConnectionContext context) throws IOException;
1:         void run(ConnectionContext context) throws IOException;
1:     }
1:     
1:     public MemoryTransactionStore(PersistenceAdapter persistenceAdapter) {
0:         this.persistenceAdapter=persistenceAdapter;
/////////////////////////////////////////////////////////////////////////
1:                 public void run(ConnectionContext ctx) throws IOException {
1:                     destination.addMessage(ctx, message);
1: 
1:     
/////////////////////////////////////////////////////////////////////////
1:                 public void run(ConnectionContext ctx) throws IOException {
1:                     destination.removeMessage(ctx, ack);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     ConcurrentHashMap<Object, Tx> inflightTransactions = new ConcurrentHashMap<Object, Tx>();
0:     ConcurrentHashMap<TransactionId, Tx> preparedTransactions = new ConcurrentHashMap<TransactionId, Tx>();
0:         private ArrayList<AddMessageCommand> messages = new ArrayList<AddMessageCommand>();
0:         private ArrayList<RemoveMessageCommand> acks = new ArrayList<RemoveMessageCommand>();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
1:                 AddMessageCommand cmd = iter.next();
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
1:                 RemoveMessageCommand cmd = iter.next();
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<AddMessageCommand> iter = messages.iterator(); iter.hasNext();) {
0:                 AddMessageCommand cmd = iter.next();
0:             for (Iterator<RemoveMessageCommand> iter = acks.iterator(); iter.hasNext();) {
0:                 RemoveMessageCommand cmd = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         Tx tx = inflightTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:         Tx tx = inflightTransactions.get(txid);
/////////////////////////////////////////////////////////////////////////
0:             tx = preparedTransactions.remove(txid);
1:             tx = inflightTransactions.remove(txid);
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<TransactionId> iter = preparedTransactions.keySet().iterator(); iter.hasNext();) {
1:                 Object txid = iter.next();
1:                 Tx tx = preparedTransactions.get(txid);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:         if (tx == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (tx == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void recover(TransactionRecoveryListener listener) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         if (doingRecover) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (doingRecover) {
1:         }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:             int count = 0;
0:                 AddMessageCommand cmd = (AddMessageCommand)iter.next();
1:                 rc[count++] = cmd.getMessage();
1:             int count = 0;
0:                 RemoveMessageCommand cmd = (RemoveMessageCommand)iter.next();
1:                 rc[count++] = cmd.getMessageAck();
/////////////////////////////////////////////////////////////////////////
0:             // Do all the message adds.
0:                 AddMessageCommand cmd = (AddMessageCommand)iter.next();
0:                 RemoveMessageCommand cmd = (RemoveMessageCommand)iter.next();
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         return new ProxyMessageStore(messageStore) {
1:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), send);
1:             }
1: 
1:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1:             }
1:         };
0:         return new ProxyTopicMessageStore(messageStore) {
1:             public void addMessage(ConnectionContext context, final Message send) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), send);
1:             }
1: 
1:             public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1:             }
1:         };
0:         Tx tx = (Tx)inflightTransactions.remove(txid);
0:         Tx tx = (Tx)inflightTransactions.get(txid);
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (wasPrepared) {
0:             tx = (Tx)preparedTransactions.remove(txid);
0:             tx = (Tx)inflightTransactions.remove(txid);
1: 
0:         if (tx == null)
1: 
/////////////////////////////////////////////////////////////////////////
1:         inflightTransactions.clear();
0:             for (Iterator iter = preparedTransactions.keySet().iterator(); iter.hasNext();) {
0:                 Object txid = (Object)iter.next();
0:                 Tx tx = (Tx)preparedTransactions.get(txid);
0:                 listener.recover((XATransactionId)txid, tx.getMessages(), tx.getAcks());
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (doingRecover)
1: 
1:         if (message.getTransactionId() != null) {
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     final void removeMessage(final MessageStore destination, final MessageAck ack) throws IOException {
0:         if (doingRecover)
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         doingRecover = false;
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.memory;
1: 
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Iterator;
1: 
0: import javax.transaction.xa.XAException;
1: 
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.XATransactionId;
1: import org.apache.activemq.store.MessageStore;
1: import org.apache.activemq.store.ProxyMessageStore;
1: import org.apache.activemq.store.ProxyTopicMessageStore;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.store.TransactionRecoveryListener;
1: import org.apache.activemq.store.TransactionStore;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
1: /**
1:  * Provides a TransactionStore implementation that can create transaction aware
1:  * MessageStore objects from non transaction aware MessageStore objects.
1:  * 
0:  * @version $Revision: 1.4 $
1:  */
1: public class MemoryTransactionStore implements TransactionStore {
1: 
0:     ConcurrentHashMap inflightTransactions = new ConcurrentHashMap();
1: 
0:     ConcurrentHashMap preparedTransactions = new ConcurrentHashMap();
1: 
1:     private boolean doingRecover;
1: 
0:     public static class Tx {
0:         private ArrayList messages = new ArrayList();
1: 
0:         private ArrayList acks = new ArrayList();
1: 
1:         public void add(AddMessageCommand msg) {
1:             messages.add(msg);
1:         }
1: 
1:         public void add(RemoveMessageCommand ack) {
1:             acks.add(ack);
1:         }
1: 
1:         public Message[] getMessages() {
1:             Message rc[] = new Message[messages.size()];
0:             int count=0;
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 AddMessageCommand cmd = (AddMessageCommand) iter.next();
0:                 rc[count++] = cmd.getMessage(); 
1:             }
1:             return rc;
1:         }
1: 
1:         public MessageAck[] getAcks() {
1:             MessageAck rc[] = new MessageAck[acks.size()];
0:             int count=0;
0:             for (Iterator iter = acks.iterator(); iter.hasNext();) {
0:                 RemoveMessageCommand cmd = (RemoveMessageCommand) iter.next();
0:                 rc[count++] = cmd.getMessageAck(); 
1:             }
1:             return rc;
1:         }
1: 
1:         /**
1:          * @throws IOException
1:          */
1:         public void commit() throws IOException {
0:             // Do all the message adds.            
0:             for (Iterator iter = messages.iterator(); iter.hasNext();) {
0:                 AddMessageCommand cmd = (AddMessageCommand) iter.next();
0:                 cmd.run();
1:             }
0:             // And removes..
0:             for (Iterator iter = acks.iterator(); iter.hasNext();) {
0:                 RemoveMessageCommand cmd = (RemoveMessageCommand) iter.next();
0:                 cmd.run();
1:             }
1:         }
1:     }
1: 
1:     public interface AddMessageCommand {
1:         Message getMessage();
0:         void run() throws IOException;
1:     }
1: 
1:     public interface RemoveMessageCommand {
1:         MessageAck getMessageAck();
0:         void run() throws IOException;
1:     }
1: 
1:     public MessageStore proxy(MessageStore messageStore) {
0: 	    return new ProxyMessageStore(messageStore) {
0: 	        public void addMessage(ConnectionContext context, final Message send) throws IOException {
0: 	            MemoryTransactionStore.this.addMessage(getDelegate(), send);
1: 	        }
1: 	
0: 	        public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1: 	            MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1: 	        }
0: 	    };
1:     }
1: 
1:     public TopicMessageStore proxy(TopicMessageStore messageStore) {
0: 	    return new ProxyTopicMessageStore(messageStore) {
0: 	        public void addMessage(ConnectionContext context, final Message send) throws IOException {
0: 	            MemoryTransactionStore.this.addMessage(getDelegate(), send);
1: 	        }
0: 	        public void removeMessage(ConnectionContext context, final MessageAck ack) throws IOException {
1: 	            MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
1: 	        }
0: 	    };
1:     }
1: 
1:     /**
1:      * @see org.apache.activemq.store.TransactionStore#prepare(TransactionId)
1:      */
0:     public void prepare(TransactionId txid) {
0:         Tx tx = (Tx) inflightTransactions.remove(txid);
0:         if (tx == null)
1:             return;
1:         preparedTransactions.put(txid, tx);
1:     }
1: 
1:     public Tx getTx(Object txid) {
0:         Tx tx = (Tx) inflightTransactions.get(txid);
1:         if (tx == null) {
1:             tx = new Tx();
0:             inflightTransactions.put(txid, tx);
1:         }
1:         return tx;
1:     }
1: 
1:     /**
0:      * @throws XAException
0:      * @see org.apache.activemq.store.TransactionStore#commit(org.apache.activemq.service.Transaction)
1:      */
0:     public void commit(TransactionId txid, boolean wasPrepared) throws IOException {
1:         
1:         Tx tx;
0:         if( wasPrepared ) {
0:             tx = (Tx) preparedTransactions.remove(txid);
1:         } else {
0:             tx = (Tx) inflightTransactions.remove(txid);
1:         }
1:         
0:         if( tx == null )
1:             return;
1:         tx.commit();
1:         
1:     }
1: 
1:     /**
1:      * @see org.apache.activemq.store.TransactionStore#rollback(TransactionId)
1:      */
0:     public void rollback(TransactionId txid) {
1:         preparedTransactions.remove(txid);
1:         inflightTransactions.remove(txid);
1:     }
1: 
1:     public void start() throws Exception {
1:     }
1: 
1:     public void stop() throws Exception {
1:     }
1: 
0:     synchronized public void recover(TransactionRecoveryListener listener) throws IOException {
1:         // All the inflight transactions get rolled back..
1:         inflightTransactions.clear();        
1:         this.doingRecover = true;
1:         try {
0: 	        for (Iterator iter = preparedTransactions.keySet().iterator(); iter.hasNext();) {
0: 	            Object txid = (Object) iter.next();
0:                 Tx tx = (Tx) preparedTransactions.get(txid);
0:                 listener.recover((XATransactionId) txid, tx.getMessages(), tx.getAcks());
1: 	        }
1:         } finally {
1:             this.doingRecover = false;
1:         }
1:     }
1: 
1:     /**
1:      * @param message
1:      * @throws IOException
1:      */
0:     void addMessage(final MessageStore destination, final Message message) throws IOException {
1:         
0:         if( doingRecover )
1:             return;
1:         
0:         if (message.getTransactionId()!=null) {
1:             Tx tx = getTx(message.getTransactionId());
1:             tx.add(new AddMessageCommand() {
1:                 public Message getMessage() {
1:                     return message;
1:                 }
0:                 public void run() throws IOException {
0:                     destination.addMessage(null, message);
1:                 }
1:             });
1:         } else {
0:             destination.addMessage(null, message);
1:         }
1:     }
1:     
1:     /**
1:      * @param ack
1:      * @throws IOException
1:      */
0:     private void removeMessage(final MessageStore destination,final MessageAck ack) throws IOException {
0:         if( doingRecover )
1:             return;
1: 
1:         if (ack.isInTransaction()) {
1:             Tx tx = getTx(ack.getTransactionId());
1:             tx.add(new RemoveMessageCommand() {
1:                 public MessageAck getMessageAck() {
1:                     return ack;
1:                 }
0:                 public void run() throws IOException {
1:                     destination.removeMessage(null, ack);
1:                 }
1:             });
1:         } else {
1:             destination.removeMessage(null, ack);
1:         }
1:     }
1: 
1:     public void delete() {
1:         inflightTransactions.clear();
1:         preparedTransactions.clear();
0:         doingRecover=false;
1:     }
1:     
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:64f3492
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.jdbc.JDBCMessageStore;
/////////////////////////////////////////////////////////////////////////
0:     protected ConcurrentHashMap<Object, Tx> inflightTransactions = new ConcurrentHashMap<Object, Tx>();
0:     protected ConcurrentHashMap<TransactionId, Tx> preparedTransactions = new ConcurrentHashMap<TransactionId, Tx>();
1:     protected final PersistenceAdapter persistenceAdapter;
0:         public ArrayList<AddMessageCommand> messages = new ArrayList<AddMessageCommand>();
0:         public final ArrayList<RemoveMessageCommand> acks = new ArrayList<RemoveMessageCommand>();
/////////////////////////////////////////////////////////////////////////
1:         MessageStore getMessageStore();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         MessageStore getMessageStore();
/////////////////////////////////////////////////////////////////////////
1:         ProxyTopicMessageStore proxyTopicMessageStore = new ProxyTopicMessageStore(messageStore) {
/////////////////////////////////////////////////////////////////////////
1:         onProxyTopicStore(proxyTopicMessageStore);
1:         return proxyTopicMessageStore;
1:     }
1: 
1:     protected void onProxyTopicStore(ProxyTopicMessageStore proxyTopicMessageStore) {
1:     public void prepare(TransactionId txid) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     public Tx getPreparedTx(TransactionId txid) {
1:         Tx tx = preparedTransactions.get(txid);
0:         if (tx == null) {
0:             tx = new Tx();
1:             preparedTransactions.put(txid, tx);
1:         }
1:         return tx;
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public void rollback(TransactionId txid) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:                 onRecovered(tx);
1:     protected void onRecovered(Tx tx) {
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 public MessageStore getMessageStore() {
1:                     return destination;
1:                 }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:                 @Override
1:                 public MessageStore getMessageStore() {
1:                     return destination;
1:                 }
0:     public void acknowledge(final TopicMessageStore destination, final String clientId, final String subscriptionName,
/////////////////////////////////////////////////////////////////////////
0: 
1:                 @Override
1:                 public MessageStore getMessageStore() {
1:                     return destination;
1:                 }
commit:88c1084
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
0: 
1:             @Override
0:             public void acknowledge(ConnectionContext context, String clientId, String subscriptionName,
0:                             MessageId messageId, MessageAck ack) throws IOException {
0:                 MemoryTransactionStore.this.acknowledge((TopicMessageStore)getDelegate(), clientId,
0:                         subscriptionName, messageId, ack);
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     final void acknowledge(final TopicMessageStore destination, final String clientId, final String subscriptionName,
0:                            final MessageId messageId, final MessageAck ack) throws IOException {
1:         if (doingRecover) {
0:             return;
1:         }
0: 
1:         if (ack.isInTransaction()) {
1:             Tx tx = getTx(ack.getTransactionId());
1:             tx.add(new RemoveMessageCommand() {
1:                 public MessageAck getMessageAck() {
1:                     return ack;
1:                 }
0: 
1:                 public void run(ConnectionContext ctx) throws IOException {
1:                     destination.acknowledge(ctx, clientId, subscriptionName, messageId, ack);
1:                 }
1:             });
1:         } else {
1:             destination.acknowledge(null, clientId, subscriptionName, messageId, ack);
1:         }
1:     }
0: 
0: 
commit:46e2e6e
/////////////////////////////////////////////////////////////////////////
0:         // ensure message order w.r.t to cursor and store for setBatch()
0:         synchronized (this) {
0:             tx.commit();
1:             if (postCommit != null) {
1:                 postCommit.run();
0:             }
commit:e1389a6
/////////////////////////////////////////////////////////////////////////
0:     public void commit(TransactionId txid, boolean wasPrepared, Runnable done) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:             done.run();
0:         done.run();
commit:50daa35
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Future;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.AbstractMessageStore;
/////////////////////////////////////////////////////////////////////////
0:             public Future<Object> asyncAddQueueMessage(ConnectionContext context, Message message) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), message);
0:                 return AbstractMessageStore.FUTURE;
0:              }
0:              
0:              
1:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
0:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);       
0:             }
/////////////////////////////////////////////////////////////////////////
0:             public Future<Object> asyncAddTopicMessage(ConnectionContext context, Message message) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), message);
0:                 return AbstractMessageStore.FUTURE;
0:              }
0: 
0:             
1:             public void removeAsyncMessage(ConnectionContext context, MessageAck ack) throws IOException {
0:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);       
0:             }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:15f85cd
/////////////////////////////////////////////////////////////////////////
1:         if (tx != null) {
0:             tx.commit();
commit:6d041dc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Iterator;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.Future;
0: 
/////////////////////////////////////////////////////////////////////////
0:         tx.commit();
0:         if (postCommit != null) {
0:             postCommit.run();
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:d40f398
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), send);
0:             }
0: 
1:             @Override
0: 
1:             @Override
0:             public Future<Object> asyncAddQueueMessage(ConnectionContext context, Message message, boolean canoptimize) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), message);
0:                 return AbstractMessageStore.FUTURE;
0:              }
0: 
0: 
0:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
/////////////////////////////////////////////////////////////////////////
1:             public void addMessage(ConnectionContext context, final Message send, boolean canOptimize) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), send);
0:             }
0: 
1:             @Override
0:             public Future<Object> asyncAddTopicMessage(ConnectionContext context, Message message, boolean canOptimize) throws IOException {
0:                 MemoryTransactionStore.this.addMessage(getDelegate(), message);
0:                 return AbstractMessageStore.FUTURE;
0:              }
0: 
1:             @Override
0: 
0:                 MemoryTransactionStore.this.removeMessage(getDelegate(), ack);
/////////////////////////////////////////////////////////////////////////
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:27262c8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         private final ArrayList<AddMessageCommand> messages = new ArrayList<AddMessageCommand>();
0:         private final ArrayList<RemoveMessageCommand> acks = new ArrayList<RemoveMessageCommand>();
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
0:     public void commit(TransactionId txid, boolean wasPrepared, Runnable preCommit,Runnable postCommit) throws IOException {
1:         if (preCommit != null) {
1:             preCommit.run();
0:         }
/////////////////////////////////////////////////////////////////////////
0:             if (postCommit != null) {
0:                 postCommit.run();
0:             }
0:         if (postCommit != null) {
0:             postCommit.run();
0:         }
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     final void removeMessage(final MessageStore destination,final MessageAck ack) throws IOException {
============================================================================