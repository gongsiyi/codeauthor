1:433912f: /**
1:433912f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:433912f:  * contributor license agreements.  See the NOTICE file distributed with
1:433912f:  * this work for additional information regarding copyright ownership.
1:433912f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:433912f:  * (the "License"); you may not use this file except in compliance with
1:433912f:  * the License.  You may obtain a copy of the License at
1:433912f:  *
1:433912f:  *      http://www.apache.org/licenses/LICENSE-2.0
1:433912f:  *
1:433912f:  * Unless required by applicable law or agreed to in writing, software
1:433912f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:433912f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:433912f:  * See the License for the specific language governing permissions and
1:433912f:  * limitations under the License.
1:433912f:  */
2:433912f: 
1:433912f: package org.apache.activemq.broker.scheduler.memory;
1:433912f: 
1:433912f: import java.io.IOException;
1:433912f: import java.util.ArrayList;
1:433912f: import java.util.Collection;
1:433912f: import java.util.Date;
1:433912f: import java.util.Iterator;
1:433912f: import java.util.List;
1:433912f: import java.util.Map;
1:433912f: import java.util.Timer;
1:433912f: import java.util.TimerTask;
1:433912f: import java.util.TreeMap;
1:433912f: import java.util.concurrent.CopyOnWriteArrayList;
1:433912f: import java.util.concurrent.atomic.AtomicBoolean;
1:433912f: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:433912f: 
1:433912f: import javax.jms.MessageFormatException;
1:433912f: 
1:433912f: import org.apache.activemq.broker.scheduler.CronParser;
1:433912f: import org.apache.activemq.broker.scheduler.Job;
1:433912f: import org.apache.activemq.broker.scheduler.JobListener;
1:433912f: import org.apache.activemq.broker.scheduler.JobScheduler;
1:433912f: import org.apache.activemq.broker.scheduler.JobSupport;
1:433912f: import org.apache.activemq.util.ByteSequence;
1:433912f: import org.apache.activemq.util.IdGenerator;
1:433912f: import org.slf4j.Logger;
1:433912f: import org.slf4j.LoggerFactory;
1:433912f: 
1:433912f: /**
1:433912f:  * Implements an in-memory JobScheduler instance.
1:433912f:  */
1:433912f: public class InMemoryJobScheduler implements JobScheduler {
1:433912f: 
1:433912f:     private static final Logger LOG = LoggerFactory.getLogger(InMemoryJobScheduler.class);
1:433912f: 
1:433912f:     private static final IdGenerator ID_GENERATOR = new IdGenerator();
1:433912f: 
1:433912f:     private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
1:433912f:     private final String name;
1:9801622:     private final TreeMap<Long, ScheduledTask> jobs = new TreeMap<>();
1:433912f:     private final AtomicBoolean started = new AtomicBoolean(false);
1:433912f:     private final AtomicBoolean dispatchEnabled = new AtomicBoolean(false);
1:9801622:     private final List<JobListener> jobListeners = new CopyOnWriteArrayList<>();
1:433912f:     private final Timer timer = new Timer();
1:433912f: 
1:433912f:     public InMemoryJobScheduler(String name) {
1:433912f:         this.name = name;
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public String getName() throws Exception {
1:433912f:         return name;
1:433912f:     }
1:433912f: 
1:433912f:     public void start() throws Exception {
1:433912f:         if (started.compareAndSet(false, true)) {
1:433912f:             startDispatching();
1:433912f:             LOG.trace("JobScheduler[{}] started", name);
1:433912f:         }
1:433912f:     }
1:433912f: 
1:433912f:     public void stop() throws Exception {
1:433912f:         if (started.compareAndSet(true, false)) {
1:433912f:             stopDispatching();
1:433912f:             timer.cancel();
1:433912f:             jobs.clear();
1:433912f:             LOG.trace("JobScheduler[{}] stopped", name);
1:433912f:         }
1:433912f:     }
1:433912f: 
1:433912f:     public boolean isStarted() {
1:433912f:         return started.get();
1:433912f:     }
1:433912f: 
1:433912f:     public boolean isDispatchEnabled() {
1:433912f:         return dispatchEnabled.get();
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void startDispatching() throws Exception {
1:433912f:         dispatchEnabled.set(true);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void stopDispatching() throws Exception {
1:433912f:         dispatchEnabled.set(false);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void addListener(JobListener listener) throws Exception {
1:433912f:         this.jobListeners.add(listener);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void removeListener(JobListener listener) throws Exception {
1:433912f:         this.jobListeners.remove(listener);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void schedule(String jobId, ByteSequence payload, long delay) throws Exception {
1:433912f:         doSchedule(jobId, payload, "", 0, delay, 0);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void schedule(String jobId, ByteSequence payload, String cronEntry) throws Exception {
1:433912f:         doSchedule(jobId, payload, cronEntry, 0, 0, 0);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void schedule(String jobId, ByteSequence payload, String cronEntry, long delay, long period, int repeat) throws Exception {
1:433912f:         doSchedule(jobId, payload, cronEntry, delay, period, repeat);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void remove(long time) throws Exception {
1:433912f:         doRemoveRange(time, time);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void remove(String jobId) throws Exception {
1:433912f:         doRemoveJob(jobId);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void removeAllJobs() throws Exception {
1:433912f:         doRemoveRange(0, Long.MAX_VALUE);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public void removeAllJobs(long start, long finish) throws Exception {
1:433912f:         doRemoveRange(start, finish);
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public long getNextScheduleTime() throws Exception {
1:433912f:         long nextExecutionTime = -1L;
1:433912f: 
1:433912f:         lock.readLock().lock();
1:433912f:         try {
1:433912f:             if (!jobs.isEmpty()) {
1:433912f:                 nextExecutionTime = jobs.entrySet().iterator().next().getKey();
1:433912f:             }
1:433912f:         } finally {
1:433912f:             lock.readLock().unlock();
1:433912f:         }
1:433912f:         return nextExecutionTime;
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public List<Job> getNextScheduleJobs() throws Exception {
1:9801622:         List<Job> result = new ArrayList<>();
1:433912f:         lock.readLock().lock();
1:433912f:         try {
1:433912f:             if (!jobs.isEmpty()) {
1:433912f:                 result.addAll(jobs.entrySet().iterator().next().getValue().getAllJobs());
1:433912f:             }
1:433912f:         } finally {
1:433912f:             lock.readLock().unlock();
1:433912f:         }
1:433912f:         return result;
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public List<Job> getAllJobs() throws Exception {
1:9801622:         final List<Job> result = new ArrayList<>();
1:433912f:         this.lock.readLock().lock();
1:433912f:         try {
1:433912f:             for (Map.Entry<Long, ScheduledTask> entry : jobs.entrySet()) {
1:433912f:                 result.addAll(entry.getValue().getAllJobs());
1:433912f:             }
1:433912f:         } finally {
1:433912f:             this.lock.readLock().unlock();
1:433912f:         }
1:433912f: 
1:433912f:         return result;
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public List<Job> getAllJobs(long start, long finish) throws Exception {
1:9801622:         final List<Job> result = new ArrayList<>();
1:433912f:         this.lock.readLock().lock();
1:433912f:         try {
1:433912f:             for (Map.Entry<Long, ScheduledTask> entry : jobs.entrySet()) {
1:433912f:                 long jobTime = entry.getKey();
1:433912f:                 if (start <= jobTime && jobTime <= finish) {
1:433912f:                     result.addAll(entry.getValue().getAllJobs());
1:433912f:                 }
1:433912f:             }
1:433912f:         } finally {
1:433912f:             this.lock.readLock().unlock();
1:433912f:         }
1:433912f:         return result;
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public int hashCode() {
1:433912f:         return name.hashCode();
1:433912f:     }
1:433912f: 
1:433912f:     @Override
1:433912f:     public String toString() {
1:433912f:         return "JobScheduler: " + name;
1:433912f:     }
1:433912f: 
1:433912f:     private void doSchedule(final String jobId, final ByteSequence payload, final String cronEntry, long delay, long period, int repeat) throws IOException {
1:433912f:         long startTime = System.currentTimeMillis();
1:433912f:         long executionTime = 0;
1:433912f:         // round startTime - so we can schedule more jobs at the same time
1:2c828b2:         startTime = ((startTime + 500) / 500) * 500;
1:2c828b2: 
1:433912f:         if (cronEntry != null && cronEntry.length() > 0) {
1:433912f:             try {
1:433912f:                 executionTime = CronParser.getNextScheduledTime(cronEntry, startTime);
1:433912f:             } catch (MessageFormatException e) {
1:433912f:                 throw new IOException(e.getMessage());
1:433912f:             }
1:433912f:         }
1:433912f: 
1:433912f:         if (executionTime == 0) {
1:433912f:             // start time not set by CRON - so it it to the current time
1:433912f:             executionTime = startTime;
1:433912f:         }
1:433912f: 
1:433912f:         if (delay > 0) {
1:433912f:             executionTime += delay;
1:433912f:         } else {
1:433912f:             executionTime += period;
1:433912f:         }
1:433912f: 
1:433912f:         InMemoryJob newJob = new InMemoryJob(jobId);
1:433912f:         newJob.setStart(startTime);
1:433912f:         newJob.setCronEntry(cronEntry);
1:433912f:         newJob.setDelay(delay);
1:433912f:         newJob.setPeriod(period);
1:433912f:         newJob.setRepeat(repeat);
1:433912f:         newJob.setNextTime(executionTime);
1:433912f:         newJob.setPayload(payload.getData());
1:433912f: 
1:433912f:         LOG.trace("JobScheduler adding job[{}] to fire at: {}", jobId, JobSupport.getDateTime(executionTime));
1:433912f: 
1:433912f:         lock.writeLock().lock();
1:433912f:         try {
1:433912f:             ScheduledTask task = jobs.get(executionTime);
1:433912f:             if (task == null) {
1:433912f:                 task = new ScheduledTask(executionTime);
1:433912f:                 task.add(newJob);
1:433912f:                 jobs.put(task.getExecutionTime(), task);
1:433912f:                 timer.schedule(task, new Date(newJob.getNextTime()));
1:433912f:             } else {
1:433912f:                 task.add(newJob);
1:433912f:             }
1:433912f:         } finally {
1:433912f:             lock.writeLock().unlock();
1:433912f:         }
1:433912f:     }
1:433912f: 
1:433912f:     private void doReschedule(InMemoryJob job, long nextExecutionTime) {
1:433912f:         job.setNextTime(nextExecutionTime);
1:433912f:         job.incrementExecutionCount();
1:386210f:         if (!job.isCron()) {
1:386210f:             job.decrementRepeatCount();
1:386210f:         }
1:433912f: 
1:433912f:         LOG.trace("JobScheduler rescheduling job[{}] to fire at: {}", job.getJobId(), JobSupport.getDateTime(nextExecutionTime));
1:433912f: 
1:433912f:         lock.writeLock().lock();
1:433912f:         try {
1:433912f:             ScheduledTask task = jobs.get(nextExecutionTime);
1:433912f:             if (task == null) {
1:433912f:                 task = new ScheduledTask(nextExecutionTime);
1:433912f:                 task.add(job);
1:433912f:                 jobs.put(task.getExecutionTime(), task);
1:433912f:                 timer.schedule(task, new Date(task.getExecutionTime()));
1:433912f:             } else {
1:433912f:                 task.add(job);
1:433912f:             }
1:433912f:         } finally {
1:433912f:             lock.writeLock().unlock();
1:433912f:         }
1:433912f:     }
1:433912f: 
1:433912f:     private void doRemoveJob(String jobId) throws IOException {
1:433912f:         this.lock.writeLock().lock();
1:433912f:         try {
1:433912f:             Iterator<Map.Entry<Long, ScheduledTask>> scheduled = jobs.entrySet().iterator();
1:433912f:             while (scheduled.hasNext()) {
1:433912f:                 Map.Entry<Long, ScheduledTask> entry = scheduled.next();
1:433912f:                 ScheduledTask task = entry.getValue();
1:433912f:                 if (task.remove(jobId)) {
1:433912f:                     LOG.trace("JobScheduler removing job[{}]", jobId);
1:433912f:                     if (task.isEmpty()) {
1:433912f:                         task.cancel();
1:433912f:                         scheduled.remove();
1:433912f:                     }
1:433912f:                     return;
1:433912f:                 }
1:433912f:             }
1:433912f:         } finally {
1:433912f:             this.lock.writeLock().unlock();
1:433912f:         }
1:433912f:     }
1:433912f: 
1:433912f:     private void doRemoveRange(long start, long end) throws IOException {
1:433912f:         this.lock.writeLock().lock();
1:433912f:         try {
1:433912f:             Iterator<Map.Entry<Long, ScheduledTask>> scheduled = jobs.entrySet().iterator();
1:433912f:             while (scheduled.hasNext()) {
1:433912f:                 Map.Entry<Long, ScheduledTask> entry = scheduled.next();
1:433912f:                 long executionTime = entry.getKey();
1:433912f:                 if (start <= executionTime && executionTime <= end) {
1:433912f:                     ScheduledTask task = entry.getValue();
1:433912f:                     task.cancel();
1:433912f:                     scheduled.remove();
1:433912f:                 }
1:433912f: 
1:433912f:                 // Don't look beyond the end range.
1:433912f:                 if (end < executionTime) {
1:433912f:                     break;
1:433912f:                 }
1:433912f:             }
1:433912f:         } finally {
1:433912f:             this.lock.writeLock().unlock();
1:433912f:         }
1:433912f:     }
1:433912f: 
1:433912f:     private boolean canDispatch() {
1:433912f:         return isStarted() && isDispatchEnabled();
1:433912f:     }
1:433912f: 
1:433912f:     private long calculateNextExecutionTime(InMemoryJob job, long currentTime, int repeat) throws MessageFormatException {
1:433912f:         long result = currentTime;
1:433912f:         String cron = job.getCronEntry();
1:433912f:         if (cron != null && cron.length() > 0) {
1:433912f:             result = CronParser.getNextScheduledTime(cron, result);
1:433912f:         } else if (job.getRepeat() != 0) {
1:433912f:             result += job.getPeriod();
1:433912f:         }
1:433912f:         return result;
1:433912f:     }
1:433912f: 
1:433912f:     private void dispatch(InMemoryJob job) throws IllegalStateException, IOException {
1:433912f:         if (canDispatch()) {
1:433912f:             LOG.debug("Firing: {}", job);
1:433912f:             for (JobListener l : jobListeners) {
1:433912f:                 l.scheduledJob(job.getJobId(), new ByteSequence(job.getPayload()));
1:433912f:             }
1:433912f:         }
1:433912f:     }
1:433912f: 
1:433912f:     /*
1:433912f:      * A TimerTask instance that can aggregate the execution of a number
1:433912f:      * scheduled Jobs and handle rescheduling the jobs that require it.
1:433912f:      */
1:433912f:     private class ScheduledTask extends TimerTask {
1:433912f: 
1:9801622:         private final Map<String, InMemoryJob> jobs = new TreeMap<>();
1:433912f:         private final long executionTime;
1:433912f: 
1:433912f:         public ScheduledTask(long executionTime) {
1:433912f:             this.executionTime = executionTime;
1:433912f:         }
1:433912f: 
1:433912f:         public long getExecutionTime() {
1:433912f:             return executionTime;
1:433912f:         }
1:433912f: 
1:433912f:         /**
1:433912f:          * @return a Collection containing all the managed jobs for this task.
1:433912f:          */
1:433912f:         public Collection<InMemoryJob> getAllJobs() {
1:9801622:             return new ArrayList<>(jobs.values());
1:433912f:         }
1:433912f: 
1:433912f:         /**
1:433912f:          * @return true if the internal list of jobs has become empty.
1:433912f:          */
1:433912f:         public boolean isEmpty() {
1:433912f:             return jobs.isEmpty();
1:433912f:         }
1:433912f: 
1:433912f:         /**
1:433912f:          * Adds the job to the internal list of scheduled Jobs managed by this task.
1:433912f:          *
1:433912f:          * @param newJob
1:433912f:          *        the new job to add to the list of Jobs.
1:433912f:          */
1:433912f:         public void add(InMemoryJob newJob) {
1:433912f:             this.jobs.put(newJob.getJobId(), newJob);
1:433912f:         }
1:433912f: 
1:433912f:         /**
1:433912f:          * Removes the job from the internal list of scheduled Jobs managed by this task.
1:433912f:          *
1:433912f:          * @param jobId
1:433912f:          *        the job ID to remove from the list of Jobs.
1:433912f:          *
1:433912f:          * @return true if the job was removed from the list of managed jobs.
1:433912f:          */
1:433912f:         public boolean remove(String jobId) {
1:433912f:             return jobs.remove(jobId) != null;
1:433912f:         }
1:433912f: 
1:433912f:         @Override
1:433912f:         public void run() {
1:433912f:             if (!isStarted()) {
1:433912f:                 return;
1:433912f:             }
1:433912f: 
1:433912f:             try {
1:433912f:                 long currentTime = System.currentTimeMillis();
1:433912f:                 lock.writeLock().lock();
1:433912f:                 try {
1:433912f:                     // Remove this entry as it will now fire any scheduled jobs, if new
1:433912f:                     // jobs or rescheduled jobs land in the same time slot we want them
1:433912f:                     // to go into a new ScheduledTask in the Timer instance.
1:433912f:                     InMemoryJobScheduler.this.jobs.remove(executionTime);
1:433912f:                 } finally {
1:433912f:                     lock.writeLock().unlock();
1:433912f:                 }
1:433912f: 
1:433912f:                 long nextExecutionTime = 0;
1:433912f: 
1:433912f:                 for (InMemoryJob job : jobs.values()) {
1:433912f: 
1:433912f:                     if (!isStarted()) {
1:433912f:                         break;
1:433912f:                     }
1:433912f: 
1:433912f:                     int repeat = job.getRepeat();
1:433912f:                     nextExecutionTime = calculateNextExecutionTime(job, currentTime, repeat);
1:433912f:                     if (!job.isCron()) {
1:433912f:                         dispatch(job);
1:433912f:                         if (repeat != 0) {
1:433912f:                             // Reschedule for the next time, the scheduler will take care of
1:433912f:                             // updating the repeat counter on the update.
1:433912f:                             doReschedule(job, nextExecutionTime);
1:433912f:                         }
1:433912f:                     } else {
1:433912f:                         if (repeat == 0) {
1:433912f:                             // This is a non-repeating Cron entry so we can fire and forget it.
1:433912f:                             dispatch(job);
1:433912f:                         }
1:433912f: 
1:433912f:                         if (nextExecutionTime > currentTime) {
1:433912f:                             // Reschedule the cron job as a new event, if the cron entry signals
1:433912f:                             // a repeat then it will be stored separately and fired as a normal
1:433912f:                             // event with decrementing repeat.
1:433912f:                             doReschedule(job, nextExecutionTime);
1:433912f: 
1:433912f:                             if (repeat != 0) {
1:433912f:                                 // we have a separate schedule to run at this time
1:433912f:                                 // so the cron job is used to set of a separate schedule
1:433912f:                                 // hence we won't fire the original cron job to the
1:433912f:                                 // listeners but we do need to start a separate schedule
1:433912f:                                 String jobId = ID_GENERATOR.generateId();
1:433912f:                                 ByteSequence payload = new ByteSequence(job.getPayload());
1:433912f:                                 schedule(jobId, payload, "", job.getDelay(), job.getPeriod(), job.getRepeat());
1:433912f:                             }
1:433912f:                         }
1:433912f:                     }
1:433912f:                 }
1:433912f:             } catch (Throwable e) {
1:433912f:                 LOG.error("Error while processing scheduled job(s).", e);
1:433912f:             }
1:433912f:         }
1:433912f:     }
1:433912f: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:2c828b2
/////////////////////////////////////////////////////////////////////////
1:         startTime = ((startTime + 500) / 500) * 500;
1: 
commit:9801622
/////////////////////////////////////////////////////////////////////////
1:     private final TreeMap<Long, ScheduledTask> jobs = new TreeMap<>();
1:     private final List<JobListener> jobListeners = new CopyOnWriteArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         List<Job> result = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         final List<Job> result = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         final List<Job> result = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:         startTime = ((startTime + 500) / 1000) * 1000;
/////////////////////////////////////////////////////////////////////////
1:         private final Map<String, InMemoryJob> jobs = new TreeMap<>();
/////////////////////////////////////////////////////////////////////////
1:             return new ArrayList<>(jobs.values());
commit:386210f
/////////////////////////////////////////////////////////////////////////
1:         if (!job.isCron()) {
1:             job.decrementRepeatCount();
1:         }
/////////////////////////////////////////////////////////////////////////
commit:433912f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.broker.scheduler.memory;
1: 
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Collection;
1: import java.util.Date;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Timer;
1: import java.util.TimerTask;
1: import java.util.TreeMap;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
1: import javax.jms.MessageFormatException;
1: 
1: import org.apache.activemq.broker.scheduler.CronParser;
1: import org.apache.activemq.broker.scheduler.Job;
1: import org.apache.activemq.broker.scheduler.JobListener;
1: import org.apache.activemq.broker.scheduler.JobScheduler;
1: import org.apache.activemq.broker.scheduler.JobSupport;
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.util.IdGenerator;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Implements an in-memory JobScheduler instance.
1:  */
1: public class InMemoryJobScheduler implements JobScheduler {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(InMemoryJobScheduler.class);
1: 
1:     private static final IdGenerator ID_GENERATOR = new IdGenerator();
1: 
1:     private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
1:     private final String name;
0:     private final TreeMap<Long, ScheduledTask> jobs = new TreeMap<Long, ScheduledTask>();
1:     private final AtomicBoolean started = new AtomicBoolean(false);
1:     private final AtomicBoolean dispatchEnabled = new AtomicBoolean(false);
0:     private final List<JobListener> jobListeners = new CopyOnWriteArrayList<JobListener>();
1:     private final Timer timer = new Timer();
1: 
1:     public InMemoryJobScheduler(String name) {
1:         this.name = name;
1:     }
1: 
1:     @Override
1:     public String getName() throws Exception {
1:         return name;
1:     }
1: 
1:     public void start() throws Exception {
1:         if (started.compareAndSet(false, true)) {
1:             startDispatching();
1:             LOG.trace("JobScheduler[{}] started", name);
1:         }
1:     }
1: 
1:     public void stop() throws Exception {
1:         if (started.compareAndSet(true, false)) {
1:             stopDispatching();
1:             timer.cancel();
1:             jobs.clear();
1:             LOG.trace("JobScheduler[{}] stopped", name);
1:         }
1:     }
1: 
1:     public boolean isStarted() {
1:         return started.get();
1:     }
1: 
1:     public boolean isDispatchEnabled() {
1:         return dispatchEnabled.get();
1:     }
1: 
1:     @Override
1:     public void startDispatching() throws Exception {
1:         dispatchEnabled.set(true);
1:     }
1: 
1:     @Override
1:     public void stopDispatching() throws Exception {
1:         dispatchEnabled.set(false);
1:     }
1: 
1:     @Override
1:     public void addListener(JobListener listener) throws Exception {
1:         this.jobListeners.add(listener);
1:     }
1: 
1:     @Override
1:     public void removeListener(JobListener listener) throws Exception {
1:         this.jobListeners.remove(listener);
1:     }
1: 
1:     @Override
1:     public void schedule(String jobId, ByteSequence payload, long delay) throws Exception {
1:         doSchedule(jobId, payload, "", 0, delay, 0);
1:     }
1: 
1:     @Override
1:     public void schedule(String jobId, ByteSequence payload, String cronEntry) throws Exception {
1:         doSchedule(jobId, payload, cronEntry, 0, 0, 0);
1:     }
1: 
1:     @Override
1:     public void schedule(String jobId, ByteSequence payload, String cronEntry, long delay, long period, int repeat) throws Exception {
1:         doSchedule(jobId, payload, cronEntry, delay, period, repeat);
1:     }
1: 
1:     @Override
1:     public void remove(long time) throws Exception {
1:         doRemoveRange(time, time);
1:     }
1: 
1:     @Override
1:     public void remove(String jobId) throws Exception {
1:         doRemoveJob(jobId);
1:     }
1: 
1:     @Override
1:     public void removeAllJobs() throws Exception {
1:         doRemoveRange(0, Long.MAX_VALUE);
1:     }
1: 
1:     @Override
1:     public void removeAllJobs(long start, long finish) throws Exception {
1:         doRemoveRange(start, finish);
1:     }
1: 
1:     @Override
1:     public long getNextScheduleTime() throws Exception {
1:         long nextExecutionTime = -1L;
1: 
1:         lock.readLock().lock();
1:         try {
1:             if (!jobs.isEmpty()) {
1:                 nextExecutionTime = jobs.entrySet().iterator().next().getKey();
1:             }
1:         } finally {
1:             lock.readLock().unlock();
1:         }
1:         return nextExecutionTime;
1:     }
1: 
1:     @Override
1:     public List<Job> getNextScheduleJobs() throws Exception {
0:         List<Job> result = new ArrayList<Job>();
1:         lock.readLock().lock();
1:         try {
1:             if (!jobs.isEmpty()) {
1:                 result.addAll(jobs.entrySet().iterator().next().getValue().getAllJobs());
1:             }
1:         } finally {
1:             lock.readLock().unlock();
1:         }
1:         return result;
1:     }
1: 
1:     @Override
1:     public List<Job> getAllJobs() throws Exception {
0:         final List<Job> result = new ArrayList<Job>();
1:         this.lock.readLock().lock();
1:         try {
1:             for (Map.Entry<Long, ScheduledTask> entry : jobs.entrySet()) {
1:                 result.addAll(entry.getValue().getAllJobs());
1:             }
1:         } finally {
1:             this.lock.readLock().unlock();
1:         }
1: 
1:         return result;
1:     }
1: 
1:     @Override
1:     public List<Job> getAllJobs(long start, long finish) throws Exception {
0:         final List<Job> result = new ArrayList<Job>();
1:         this.lock.readLock().lock();
1:         try {
1:             for (Map.Entry<Long, ScheduledTask> entry : jobs.entrySet()) {
1:                 long jobTime = entry.getKey();
1:                 if (start <= jobTime && jobTime <= finish) {
1:                     result.addAll(entry.getValue().getAllJobs());
1:                 }
1:             }
1:         } finally {
1:             this.lock.readLock().unlock();
1:         }
1:         return result;
1:     }
1: 
1:     @Override
1:     public int hashCode() {
1:         return name.hashCode();
1:     }
1: 
1:     @Override
1:     public String toString() {
1:         return "JobScheduler: " + name;
1:     }
1: 
1:     private void doSchedule(final String jobId, final ByteSequence payload, final String cronEntry, long delay, long period, int repeat) throws IOException {
1:         long startTime = System.currentTimeMillis();
1:         long executionTime = 0;
1:         // round startTime - so we can schedule more jobs at the same time
0:         startTime = (startTime / 1000) * 1000;
1:         if (cronEntry != null && cronEntry.length() > 0) {
1:             try {
1:                 executionTime = CronParser.getNextScheduledTime(cronEntry, startTime);
1:             } catch (MessageFormatException e) {
1:                 throw new IOException(e.getMessage());
1:             }
1:         }
1: 
1:         if (executionTime == 0) {
1:             // start time not set by CRON - so it it to the current time
1:             executionTime = startTime;
1:         }
1: 
1:         if (delay > 0) {
1:             executionTime += delay;
1:         } else {
1:             executionTime += period;
1:         }
1: 
1:         InMemoryJob newJob = new InMemoryJob(jobId);
1:         newJob.setStart(startTime);
1:         newJob.setCronEntry(cronEntry);
1:         newJob.setDelay(delay);
1:         newJob.setPeriod(period);
1:         newJob.setRepeat(repeat);
1:         newJob.setNextTime(executionTime);
1:         newJob.setPayload(payload.getData());
1: 
1:         LOG.trace("JobScheduler adding job[{}] to fire at: {}", jobId, JobSupport.getDateTime(executionTime));
1: 
1:         lock.writeLock().lock();
1:         try {
1:             ScheduledTask task = jobs.get(executionTime);
1:             if (task == null) {
1:                 task = new ScheduledTask(executionTime);
1:                 task.add(newJob);
1:                 jobs.put(task.getExecutionTime(), task);
1:                 timer.schedule(task, new Date(newJob.getNextTime()));
1:             } else {
1:                 task.add(newJob);
1:             }
1:         } finally {
1:             lock.writeLock().unlock();
1:         }
1:     }
1: 
1:     private void doReschedule(InMemoryJob job, long nextExecutionTime) {
1:         job.setNextTime(nextExecutionTime);
1:         job.incrementExecutionCount();
0:         job.decrementRepeatCount();
1: 
1:         LOG.trace("JobScheduler rescheduling job[{}] to fire at: {}", job.getJobId(), JobSupport.getDateTime(nextExecutionTime));
1: 
1:         lock.writeLock().lock();
1:         try {
1:             ScheduledTask task = jobs.get(nextExecutionTime);
1:             if (task == null) {
1:                 task = new ScheduledTask(nextExecutionTime);
1:                 task.add(job);
1:                 jobs.put(task.getExecutionTime(), task);
1:                 timer.schedule(task, new Date(task.getExecutionTime()));
1:             } else {
1:                 task.add(job);
1:             }
1:         } finally {
1:             lock.writeLock().unlock();
1:         }
1: 
1:     }
1: 
1:     private void doRemoveJob(String jobId) throws IOException {
1:         this.lock.writeLock().lock();
1:         try {
1:             Iterator<Map.Entry<Long, ScheduledTask>> scheduled = jobs.entrySet().iterator();
1:             while (scheduled.hasNext()) {
1:                 Map.Entry<Long, ScheduledTask> entry = scheduled.next();
1:                 ScheduledTask task = entry.getValue();
1:                 if (task.remove(jobId)) {
1:                     LOG.trace("JobScheduler removing job[{}]", jobId);
1:                     if (task.isEmpty()) {
1:                         task.cancel();
1:                         scheduled.remove();
1:                     }
1:                     return;
1:                 }
1:             }
1:         } finally {
1:             this.lock.writeLock().unlock();
1:         }
1:     }
1: 
1:     private void doRemoveRange(long start, long end) throws IOException {
1:         this.lock.writeLock().lock();
1:         try {
1:             Iterator<Map.Entry<Long, ScheduledTask>> scheduled = jobs.entrySet().iterator();
1:             while (scheduled.hasNext()) {
1:                 Map.Entry<Long, ScheduledTask> entry = scheduled.next();
1:                 long executionTime = entry.getKey();
1:                 if (start <= executionTime && executionTime <= end) {
1:                     ScheduledTask task = entry.getValue();
1:                     task.cancel();
1:                     scheduled.remove();
1:                 }
1: 
1:                 // Don't look beyond the end range.
1:                 if (end < executionTime) {
1:                     break;
1:                 }
1:             }
1:         } finally {
1:             this.lock.writeLock().unlock();
1:         }
1:     }
1: 
1:     private boolean canDispatch() {
1:         return isStarted() && isDispatchEnabled();
1:     }
1: 
1:     private long calculateNextExecutionTime(InMemoryJob job, long currentTime, int repeat) throws MessageFormatException {
1:         long result = currentTime;
1:         String cron = job.getCronEntry();
1:         if (cron != null && cron.length() > 0) {
1:             result = CronParser.getNextScheduledTime(cron, result);
1:         } else if (job.getRepeat() != 0) {
1:             result += job.getPeriod();
1:         }
1:         return result;
1:     }
1: 
1:     private void dispatch(InMemoryJob job) throws IllegalStateException, IOException {
1:         if (canDispatch()) {
1:             LOG.debug("Firing: {}", job);
1:             for (JobListener l : jobListeners) {
1:                 l.scheduledJob(job.getJobId(), new ByteSequence(job.getPayload()));
1:             }
1:         }
1:     }
1: 
1:     /*
1:      * A TimerTask instance that can aggregate the execution of a number
1:      * scheduled Jobs and handle rescheduling the jobs that require it.
1:      */
1:     private class ScheduledTask extends TimerTask {
1: 
0:         private final Map<String, InMemoryJob> jobs = new TreeMap<String, InMemoryJob>();
1:         private final long executionTime;
1: 
1:         public ScheduledTask(long executionTime) {
1:             this.executionTime = executionTime;
1:         }
1: 
1:         public long getExecutionTime() {
1:             return executionTime;
1:         }
1: 
1:         /**
1:          * @return a Collection containing all the managed jobs for this task.
1:          */
1:         public Collection<InMemoryJob> getAllJobs() {
0:             return new ArrayList<InMemoryJob>(jobs.values());
1:         }
1: 
1:         /**
1:          * @return true if the internal list of jobs has become empty.
1:          */
1:         public boolean isEmpty() {
1:             return jobs.isEmpty();
1:         }
1: 
1:         /**
1:          * Adds the job to the internal list of scheduled Jobs managed by this task.
1:          *
1:          * @param newJob
1:          *        the new job to add to the list of Jobs.
1:          */
1:         public void add(InMemoryJob newJob) {
1:             this.jobs.put(newJob.getJobId(), newJob);
1:         }
1: 
1:         /**
1:          * Removes the job from the internal list of scheduled Jobs managed by this task.
1:          *
1:          * @param jobId
1:          *        the job ID to remove from the list of Jobs.
1:          *
1:          * @return true if the job was removed from the list of managed jobs.
1:          */
1:         public boolean remove(String jobId) {
1:             return jobs.remove(jobId) != null;
1:         }
1: 
1:         @Override
1:         public void run() {
1:             if (!isStarted()) {
1:                 return;
1:             }
1: 
1:             try {
1:                 long currentTime = System.currentTimeMillis();
1:                 lock.writeLock().lock();
1:                 try {
1:                     // Remove this entry as it will now fire any scheduled jobs, if new
1:                     // jobs or rescheduled jobs land in the same time slot we want them
1:                     // to go into a new ScheduledTask in the Timer instance.
1:                     InMemoryJobScheduler.this.jobs.remove(executionTime);
1:                 } finally {
1:                     lock.writeLock().unlock();
1:                 }
1: 
1:                 long nextExecutionTime = 0;
1: 
1:                 for (InMemoryJob job : jobs.values()) {
1: 
1:                     if (!isStarted()) {
1:                         break;
1:                     }
1: 
1:                     int repeat = job.getRepeat();
1:                     nextExecutionTime = calculateNextExecutionTime(job, currentTime, repeat);
1:                     if (!job.isCron()) {
1:                         dispatch(job);
1:                         if (repeat != 0) {
1:                             // Reschedule for the next time, the scheduler will take care of
1:                             // updating the repeat counter on the update.
1:                             doReschedule(job, nextExecutionTime);
1:                         }
1:                     } else {
1:                         if (repeat == 0) {
1:                             // This is a non-repeating Cron entry so we can fire and forget it.
1:                             dispatch(job);
1:                         }
1: 
1:                         if (nextExecutionTime > currentTime) {
1:                             // Reschedule the cron job as a new event, if the cron entry signals
1:                             // a repeat then it will be stored separately and fired as a normal
1:                             // event with decrementing repeat.
1:                             doReschedule(job, nextExecutionTime);
1: 
1:                             if (repeat != 0) {
1:                                 // we have a separate schedule to run at this time
1:                                 // so the cron job is used to set of a separate schedule
1:                                 // hence we won't fire the original cron job to the
1:                                 // listeners but we do need to start a separate schedule
1:                                 String jobId = ID_GENERATOR.generateId();
1:                                 ByteSequence payload = new ByteSequence(job.getPayload());
1:                                 schedule(jobId, payload, "", job.getDelay(), job.getPeriod(), job.getRepeat());
1:                             }
1:                         }
1:                     }
1:                 }
1:             } catch (Throwable e) {
1:                 LOG.error("Error while processing scheduled job(s).", e);
1:             }
1:         }
1:     }
1: }
============================================================================