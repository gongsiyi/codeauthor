3:dc98d96: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:2b5608f:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:f812e34:  *
1:dc98d96:  * Unless required by applicable law or agreed to in writing, software
1:dc98d96:  * distributed under the License is distributed on an "AS IS" BASIS,
1:dc98d96:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:dc98d96:  * See the License for the specific language governing permissions and
1:dc98d96:  * limitations under the License.
3:dc98d96:  */
1:98b61e4: package org.apache.activemq.transport.stomp;
1:fc00993: 
1:4bba15a: import java.io.BufferedReader;
1:4bba15a: import java.io.IOException;
1:4bba15a: import java.io.InputStream;
1:4bba15a: import java.io.InputStreamReader;
1:4bba15a: import java.io.OutputStreamWriter;
1:4bba15a: import java.io.PrintWriter;
1:9abbe82: import java.util.ArrayList;
1:4bba15a: import java.util.HashMap;
1:4bba15a: import java.util.Iterator;
1:4bba15a: import java.util.Map;
1:1c26408: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:1c26408: import java.util.concurrent.atomic.AtomicBoolean;
1:8ed8dd4: 
1:4bba15a: import javax.jms.JMSException;
1:4bba15a: 
1:bc45bf8: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:1fdcf59: import org.apache.activemq.advisory.AdvisorySupport;
1:4bba15a: import org.apache.activemq.broker.BrokerContext;
1:4bba15a: import org.apache.activemq.broker.BrokerContextAware;
1:c3d8ca7: import org.apache.activemq.command.ActiveMQDestination;
1:c3d8ca7: import org.apache.activemq.command.ActiveMQMessage;
1:c3d8ca7: import org.apache.activemq.command.ActiveMQTempQueue;
1:c3d8ca7: import org.apache.activemq.command.ActiveMQTempTopic;
1:c3d8ca7: import org.apache.activemq.command.Command;
1:c3d8ca7: import org.apache.activemq.command.CommandTypes;
1:c3d8ca7: import org.apache.activemq.command.ConnectionError;
1:c3d8ca7: import org.apache.activemq.command.ConnectionId;
1:c3d8ca7: import org.apache.activemq.command.ConnectionInfo;
1:c3d8ca7: import org.apache.activemq.command.ConsumerControl;
1:c3d8ca7: import org.apache.activemq.command.ConsumerId;
1:c3d8ca7: import org.apache.activemq.command.ConsumerInfo;
1:c3d8ca7: import org.apache.activemq.command.DestinationInfo;
1:c3d8ca7: import org.apache.activemq.command.ExceptionResponse;
1:c3d8ca7: import org.apache.activemq.command.LocalTransactionId;
1:c3d8ca7: import org.apache.activemq.command.MessageAck;
1:c3d8ca7: import org.apache.activemq.command.MessageDispatch;
1:c3d8ca7: import org.apache.activemq.command.MessageId;
1:c3d8ca7: import org.apache.activemq.command.ProducerId;
1:c3d8ca7: import org.apache.activemq.command.ProducerInfo;
1:c3d8ca7: import org.apache.activemq.command.RemoveSubscriptionInfo;
1:c3d8ca7: import org.apache.activemq.command.Response;
1:c3d8ca7: import org.apache.activemq.command.SessionId;
1:c3d8ca7: import org.apache.activemq.command.SessionInfo;
1:c3d8ca7: import org.apache.activemq.command.ShutdownInfo;
1:c3d8ca7: import org.apache.activemq.command.TransactionId;
1:c3d8ca7: import org.apache.activemq.command.TransactionInfo;
1:4bba15a: import org.apache.activemq.util.ByteArrayOutputStream;
1:4bba15a: import org.apache.activemq.util.FactoryFinder;
1:4bba15a: import org.apache.activemq.util.IOExceptionSupport;
1:4bba15a: import org.apache.activemq.util.IdGenerator;
1:4bba15a: import org.apache.activemq.util.IntrospectionSupport;
1:4bba15a: import org.apache.activemq.util.LongSequenceGenerator;
1:4bba15a: import org.slf4j.Logger;
1:4bba15a: import org.slf4j.LoggerFactory;
1:4bba15a: 
1:dc98d96: /**
1:dc98d96:  * @author <a href="http://hiramchirino.com">chirino</a>
1:dc98d96:  */
1:dc98d96: public class ProtocolConverter {
1:1c26408: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ProtocolConverter.class);
1:0885c60: 
1:fc00993:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1:0885c60: 
1:0885c60:     private static final String BROKER_VERSION;
1:0885c60:     private static final StompFrame ping = new StompFrame(Stomp.Commands.KEEPALIVE);
1:0885c60: 
1:0885c60:     static {
1:0885c60:         String version = "5.6.0";
1:12b26b6:         try(InputStream in = ProtocolConverter.class.getResourceAsStream("/org/apache/activemq/version.txt")) {
1:12b26b6:             if (in != null) {
1:12b26b6:                 try(InputStreamReader isr = new InputStreamReader(in);
1:12b26b6:                     BufferedReader reader = new BufferedReader(isr)) {
1:12b26b6:                     version = reader.readLine();
1:12b26b6:                 }
1:3b381e7:             }
1:12b26b6:         }catch(Exception e) {
1:0885c60:         }
1:12b26b6: 
1:0885c60:         BROKER_VERSION = version;
1:0885c60:     }
1:3b381e7: 
1:fc00993:     private final ConnectionId connectionId = new ConnectionId(CONNECTION_ID_GENERATOR.generateId());
1:dc98d96:     private final SessionId sessionId = new SessionId(connectionId, -1);
1:dc98d96:     private final ProducerId producerId = new ProducerId(sessionId, 1);
1:0885c60: 
1:dc98d96:     private final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
1:dc98d96:     private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
1:dc98d96:     private final LongSequenceGenerator transactionIdGenerator = new LongSequenceGenerator();
1:04a6379:     private final LongSequenceGenerator tempDestinationGenerator = new LongSequenceGenerator();
1:0885c60: 
1:9abbe82:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<>();
1:9abbe82:     private final ConcurrentMap<ConsumerId, StompSubscription> subscriptionsByConsumerId = new ConcurrentHashMap<>();
1:9abbe82:     private final ConcurrentMap<String, StompSubscription> subscriptions = new ConcurrentHashMap<>();
1:9abbe82:     private final ConcurrentMap<String, ActiveMQDestination> tempDestinations = new ConcurrentHashMap<>();
1:9abbe82:     private final ConcurrentMap<String, String> tempDestinationAmqToStompMap = new ConcurrentHashMap<>();
1:9abbe82:     private final Map<String, LocalTransactionId> transactions = new ConcurrentHashMap<>();
1:ceed011:     private final StompTransport stompTransport;
1:0885c60: 
1:9abbe82:     private final ConcurrentMap<String, AckEntry> pedingAcks = new ConcurrentHashMap<>();
1:6d08aca:     private final IdGenerator ACK_ID_GENERATOR = new IdGenerator();
1:6d08aca: 
1:f812e34:     private final Object commnadIdMutex = new Object();
1:f812e34:     private int lastCommandId;
1:dc98d96:     private final AtomicBoolean connected = new AtomicBoolean(false);
1:0885c60:     private final FrameTranslator frameTranslator = new LegacyFrameTranslator();
1:2b5608f:     private final FactoryFinder FRAME_TRANSLATOR_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/transport/frametranslator/");
1:11705e7:     private final BrokerContext brokerContext;
1:0885c60:     private String version = "1.0";
1:33edc99:     private long hbReadInterval;
1:33edc99:     private long hbWriteInterval;
1:d0ab117:     private float hbGracePeriodMultiplier = 1.0f;
1:33edc99:     private String defaultHeartBeat = Stomp.DEFAULT_HEART_BEAT;
1:5ebfbf0: 
1:6d08aca:     private static class AckEntry {
1:6d08aca: 
1:436f892:         private final String messageId;
1:436f892:         private final StompSubscription subscription;
1:6d08aca: 
1:6d08aca:         public AckEntry(String messageId, StompSubscription subscription) {
1:6d08aca:             this.messageId = messageId;
1:6d08aca:             this.subscription = subscription;
1:6d08aca:         }
1:6d08aca: 
1:6d08aca:         public MessageAck onMessageAck(TransactionId transactionId) {
1:6d08aca:             return subscription.onStompMessageAck(messageId, transactionId);
1:6d08aca:         }
1:6d08aca: 
1:6d08aca:         public MessageAck onMessageNack(TransactionId transactionId) throws ProtocolException {
1:6d08aca:             return subscription.onStompMessageNack(messageId, transactionId);
1:6d08aca:         }
1:6d08aca: 
1:6d08aca:         public String getMessageId() {
1:6d08aca:             return this.messageId;
1:6d08aca:         }
1:6d08aca: 
1:436f892:         @SuppressWarnings("unused")
1:6d08aca:         public StompSubscription getSubscription() {
1:6d08aca:             return this.subscription;
1:6d08aca:         }
1:6d08aca:     }
1:6d08aca: 
1:0885c60:     public ProtocolConverter(StompTransport stompTransport, BrokerContext brokerContext) {
1:ceed011:         this.stompTransport = stompTransport;
1:11705e7:         this.brokerContext = brokerContext;
1:0885c60:     }
1:603b215: 
1:dc98d96:     protected int generateCommandId() {
1:f812e34:         synchronized (commnadIdMutex) {
1:f812e34:             return lastCommandId++;
1:33edc99:         }
1:33edc99:     }
1:33edc99: 
1:471ea33:     protected ResponseHandler createResponseHandler(final StompFrame command) {
1:471ea33:         final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:471ea33:         if (receiptId != null) {
1:f812e34:             return new ResponseHandler() {
1:436f892:                 @Override
1:f812e34:                 public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:471ea33:                     if (response.isException()) {
1:471ea33:                         // Generally a command can fail.. but that does not invalidate the connection.
1:471ea33:                         // We report back the failure but we don't close the connection.
1:471ea33:                         Throwable exception = ((ExceptionResponse)response).getException();
1:471ea33:                         handleException(exception, command);
1:0885c60:                     } else {
1:471ea33:                         StompFrame sc = new StompFrame();
1:471ea33:                         sc.setAction(Stomp.Responses.RECEIPT);
1:471ea33:                         sc.setHeaders(new HashMap<String, String>(1));
1:471ea33:                         sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:ceed011:                         stompTransport.sendToStomp(sc);
1:3910056:                     }
1:471ea33:                 }
1:f812e34:             };
1:04a6379:         }
1:f812e34:         return null;
1:04a6379:     }
1:33edc99: 
1:f812e34:     protected void sendToActiveMQ(Command command, ResponseHandler handler) {
1:3b381e7:         command.setCommandId(generateCommandId());
1:3b381e7:         if (handler != null) {
1:3b381e7:             command.setResponseRequired(true);
1:3b381e7:             resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
1:3b381e7:         }
1:f33f32e:         stompTransport.sendToActiveMQ(command);
1:04a6379:     }
1:2b5608f: 
1:f812e34:     protected void sendToStomp(StompFrame command) throws IOException {
1:ceed011:         stompTransport.sendToStomp(command);
1:04a6379:     }
1:5ebfbf0: 
1:2b5608f:     protected FrameTranslator findTranslator(String header) {
1:533cedc:         return findTranslator(header, null, false);
1:1fdcf59:     }
1:1fdcf59: 
1:533cedc:     protected FrameTranslator findTranslator(String header, ActiveMQDestination destination, boolean advisory) {
1:5ebfbf0:         FrameTranslator translator = frameTranslator;
1:0885c60:         try {
1:5ebfbf0:             if (header != null) {
1:533cedc:                 translator = (FrameTranslator) FRAME_TRANSLATOR_FINDER.newInstance(header);
1:1fdcf59:             } else {
1:533cedc:                 if (destination != null && (advisory || AdvisorySupport.isAdvisoryTopic(destination))) {
1:1fdcf59:                     translator = new JmsFrameTranslator();
1:0885c60:                 }
1:5ebfbf0:             }
1:5ebfbf0:         } catch (Exception ignore) {
1:5ebfbf0:             // if anything goes wrong use the default translator
1:5ebfbf0:         }
1:0885c60: 
1:1fdcf59:         if (translator instanceof BrokerContextAware) {
1:1fdcf59:             ((BrokerContextAware)translator).setBrokerContext(brokerContext);
1:5ebfbf0:         }
1:0885c60: 
1:5ebfbf0:         return translator;
1:5ebfbf0:     }
1:0885c60: 
1:f812e34:     /**
1:533cedc:      * Convert a STOMP command
1:5ebfbf0:      *
1:5ebfbf0:      * @param command
1:5ebfbf0:      */
1:690b7bc:     public void onStompCommand(StompFrame command) throws IOException, JMSException {
1:5ebfbf0:         try {
1:5ebfbf0: 
1:f812e34:             if (command.getClass() == StompFrameError.class) {
1:f812e34:                 throw ((StompFrameError)command).getException();
1:1fdcf59:             }
1:1fdcf59: 
1:f812e34:             String action = command.getAction();
1:fc00993:             if (action.startsWith(Stomp.Commands.SEND)) {
1:f812e34:                 onStompSend(command);
1:fc00993:             } else if (action.startsWith(Stomp.Commands.ACK)) {
1:f812e34:                 onStompAck(command);
1:0885c60:             } else if (action.startsWith(Stomp.Commands.NACK)) {
1:0885c60:                 onStompNack(command);
1:fc00993:             } else if (action.startsWith(Stomp.Commands.BEGIN)) {
1:f812e34:                 onStompBegin(command);
1:fc00993:             } else if (action.startsWith(Stomp.Commands.COMMIT)) {
1:f812e34:                 onStompCommit(command);
1:fc00993:             } else if (action.startsWith(Stomp.Commands.ABORT)) {
1:f812e34:                 onStompAbort(command);
1:5fb4704:             } else if (action.startsWith(Stomp.Commands.SUBSCRIBE_PREFIX)) {
1:f812e34:                 onStompSubscribe(command);
1:5fb4704:             } else if (action.startsWith(Stomp.Commands.UNSUBSCRIBE_PREFIX)) {
1:f812e34:                 onStompUnsubscribe(command);
1:0885c60:             } else if (action.startsWith(Stomp.Commands.CONNECT) ||
1:0885c60:                        action.startsWith(Stomp.Commands.STOMP)) {
1:f812e34:                 onStompConnect(command);
1:fc00993:             } else if (action.startsWith(Stomp.Commands.DISCONNECT)) {
1:f812e34:                 onStompDisconnect(command);
1:3910056:             } else {
1:adf70bc:                 throw new ProtocolException("Unknown STOMP action: " + action, true);
1:2b5608f:             }
1:2b5608f: 
1:dc98d96:         } catch (ProtocolException e) {
1:471ea33:             handleException(e, command);
1:471ea33:             // Some protocol errors can cause the connection to get closed.
1:0885c60:             if (e.isFatal()) {
1:ceed011:                getStompTransport().onException(e);
1:2b5608f:             }
1:2b5608f:         }
1:fc00993:     }
1:471ea33: 
1:471ea33:     protected void handleException(Throwable exception, StompFrame command) throws IOException {
1:b595b8b:         if (command == null) {
1:b595b8b:             LOG.warn("Exception occurred while processing a command: {}", exception.toString());
1:b595b8b:         } else {
1:b595b8b:             LOG.warn("Exception occurred processing: {} -> {}", safeGetAction(command), exception.toString());
1:b595b8b:         }
1:b595b8b: 
1:78f85ed:         if (LOG.isDebugEnabled()) {
1:78f85ed:             LOG.debug("Exception detail", exception);
1:78f85ed:         }
1:78f85ed: 
1:b595b8b:         if (command != null && LOG.isTraceEnabled()) {
1:b595b8b:             LOG.trace("Command that caused the error: {}", command);
1:b595b8b:         }
1:b595b8b: 
1:471ea33:         // Let the stomp client know about any protocol errors.
1:471ea33:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:471ea33:         PrintWriter stream = new PrintWriter(new OutputStreamWriter(baos, "UTF-8"));
1:471ea33:         exception.printStackTrace(stream);
1:471ea33:         stream.close();
1:471ea33: 
1:9abbe82:         HashMap<String, String> headers = new HashMap<>();
1:471ea33:         headers.put(Stomp.Headers.Error.MESSAGE, exception.getMessage());
1:0885c60:         headers.put(Stomp.Headers.CONTENT_TYPE, "text/plain");
1:471ea33: 
1:b595b8b:         if (command != null) {
1:5ebfbf0:             final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:5ebfbf0:             if (receiptId != null) {
1:5ebfbf0:                 headers.put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:5ebfbf0:             }
1:471ea33:         }
1:471ea33: 
1:471ea33:         StompFrame errorMessage = new StompFrame(Stomp.Responses.ERROR, headers, baos.toByteArray());
1:471ea33:         sendToStomp(errorMessage);
1:471ea33:     }
1:530884a: 
1:f812e34:     protected void onStompSend(StompFrame command) throws IOException, JMSException {
1:f812e34:         checkConnected();
85:dc98d96: 
1:ecf89a6:         Map<String, String> headers = command.getHeaders();
1:0885c60:         String destination = headers.get(Stomp.Headers.Send.DESTINATION);
1:0885c60:         if (destination == null) {
1:0885c60:             throw new ProtocolException("SEND received without a Destination specified!");
1:0885c60:         }
1:0885c60: 
1:ecf89a6:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:7aec12e:         headers.remove("transaction");
1:dc98d96: 
1:dc98d96:         ActiveMQMessage message = convertMessage(command);
1:dc98d96: 
1:dc98d96:         message.setProducerId(producerId);
1:dc98d96:         MessageId id = new MessageId(producerId, messageIdGenerator.getNextSequenceId());
1:dc98d96:         message.setMessageId(id);
1:dc98d96: 
1:f812e34:         if (stompTx != null) {
1:ecf89a6:             TransactionId activemqTx = transactions.get(stompTx);
1:fc00993:             if (activemqTx == null) {
1:f812e34:                 throw new ProtocolException("Invalid transaction id: " + stompTx);
1:471ea33:             }
1:dc98d96:             message.setTransactionId(activemqTx);
1:fc00993:         }
1:5ebfbf0: 
1:dc98d96:         message.onSend();
1:57264bf:         message.beforeMarshall(null);
1:f33f32e:         sendToActiveMQ(message, createResponseHandler(command));
1:0885c60:     }
1:f6ebeec: 
1:0885c60:     protected void onStompNack(StompFrame command) throws ProtocolException {
1:0885c60: 
1:0885c60:         checkConnected();
1:0885c60: 
1:e3a1fc9:         if (this.version.equals(Stomp.V1_0)) {
1:0885c60:             throw new ProtocolException("NACK received but connection is in v1.0 mode.");
1:0885c60:         }
1:0885c60: 
1:0885c60:         Map<String, String> headers = command.getHeaders();
1:0885c60: 
1:0885c60:         String subscriptionId = headers.get(Stomp.Headers.Ack.SUBSCRIPTION);
1:6d08aca:         if (subscriptionId == null && !this.version.equals(Stomp.V1_2)) {
1:0885c60:             throw new ProtocolException("NACK received without a subscription id for acknowledge!");
1:0885c60:         }
1:0885c60: 
1:0885c60:         String messageId = headers.get(Stomp.Headers.Ack.MESSAGE_ID);
1:6d08aca:         if (messageId == null && !this.version.equals(Stomp.V1_2)) {
1:0885c60:             throw new ProtocolException("NACK received without a message-id to acknowledge!");
1:0885c60:         }
1:0885c60: 
1:6d08aca:         String ackId = headers.get(Stomp.Headers.Ack.ACK_ID);
1:6d08aca:         if (ackId == null && this.version.equals(Stomp.V1_2)) {
1:6d08aca:             throw new ProtocolException("NACK received without an ack header to acknowledge!");
1:6d08aca:         }
1:6d08aca: 
1:0885c60:         TransactionId activemqTx = null;
1:0885c60:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:0885c60:         if (stompTx != null) {
1:0885c60:             activemqTx = transactions.get(stompTx);
1:0885c60:             if (activemqTx == null) {
1:0885c60:                 throw new ProtocolException("Invalid transaction id: " + stompTx);
1:0885c60:             }
1:0885c60:         }
1:0885c60: 
1:6d08aca:         boolean nacked = false;
1:6d08aca: 
1:6d08aca:         if (ackId != null) {
1:52d95ee:             AckEntry pendingAck = this.pedingAcks.remove(ackId);
1:6d08aca:             if (pendingAck != null) {
1:6d08aca:                 messageId = pendingAck.getMessageId();
1:6d08aca:                 MessageAck ack = pendingAck.onMessageNack(activemqTx);
1:6d08aca:                 if (ack != null) {
1:6d08aca:                     sendToActiveMQ(ack, createResponseHandler(command));
1:6d08aca:                     nacked = true;
1:6d08aca:                 }
1:6d08aca:             }
1:6d08aca:         } else if (subscriptionId != null) {
1:0885c60:             StompSubscription sub = this.subscriptions.get(subscriptionId);
1:0885c60:             if (sub != null) {
1:0885c60:                 MessageAck ack = sub.onStompMessageNack(messageId, activemqTx);
1:0885c60:                 if (ack != null) {
1:f33f32e:                     sendToActiveMQ(ack, createResponseHandler(command));
1:6d08aca:                     nacked = true;
1:0885c60:                 }
1:0885c60:             }
1:fc00993:         }
1:6d08aca: 
1:6d08aca:         if (!nacked) {
1:6d08aca:             throw new ProtocolException("Unexpected NACK received for message-id [" + messageId + "]");
1:6d08aca:         }
1:0885c60:     }
1:0885c60: 
1:530884a:     protected void onStompAck(StompFrame command) throws ProtocolException {
1:f812e34:         checkConnected();
1:0885c60: 
1:ecf89a6:         Map<String, String> headers = command.getHeaders();
1:ecf89a6:         String messageId = headers.get(Stomp.Headers.Ack.MESSAGE_ID);
1:6d08aca:         if (messageId == null && !(this.version.equals(Stomp.V1_2))) {
1:dc98d96:             throw new ProtocolException("ACK received without a message-id to acknowledge!");
1:fc00993:         }
1:dc98d96: 
1:0885c60:         String subscriptionId = headers.get(Stomp.Headers.Ack.SUBSCRIPTION);
1:6d08aca:         if (subscriptionId == null && this.version.equals(Stomp.V1_1)) {
1:0885c60:             throw new ProtocolException("ACK received without a subscription id for acknowledge!");
1:0885c60:         }
1:0885c60: 
1:6d08aca:         String ackId = headers.get(Stomp.Headers.Ack.ACK_ID);
1:6d08aca:         if (ackId == null && this.version.equals(Stomp.V1_2)) {
1:6d08aca:             throw new ProtocolException("ACK received without a ack id for acknowledge!");
1:6d08aca:         }
1:6d08aca: 
1:f812e34:         TransactionId activemqTx = null;
1:ecf89a6:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:f812e34:         if (stompTx != null) {
1:ecf89a6:             activemqTx = transactions.get(stompTx);
1:fc00993:             if (activemqTx == null) {
1:f812e34:                 throw new ProtocolException("Invalid transaction id: " + stompTx);
1:fc00993:             }
1:f812e34:         }
1:dc98d96: 
1:f812e34:         boolean acked = false;
1:6d08aca: 
1:6d08aca:         if (ackId != null) {
1:52d95ee:             AckEntry pendingAck = this.pedingAcks.remove(ackId);
1:6d08aca:             if (pendingAck != null) {
1:6d08aca:                 messageId = pendingAck.getMessageId();
1:6d08aca:                 MessageAck ack = pendingAck.onMessageAck(activemqTx);
1:6d08aca:                 if (ack != null) {
1:6d08aca:                     sendToActiveMQ(ack, createResponseHandler(command));
1:6d08aca:                     acked = true;
1:6d08aca:                 }
1:6d08aca:             }
1:6d08aca: 
1:6d08aca:         } else if (subscriptionId != null) {
1:0885c60:             StompSubscription sub = this.subscriptions.get(subscriptionId);
1:0885c60:             if (sub != null) {
1:0885c60:                 MessageAck ack = sub.onStompMessageAck(messageId, activemqTx);
1:0885c60:                 if (ack != null) {
1:f33f32e:                     sendToActiveMQ(ack, createResponseHandler(command));
1:0885c60:                     acked = true;
1:0885c60:                 }
1:0885c60:             }
1:0885c60:         } else {
1:6d08aca:             // STOMP v1.0: acking with just a message id is very bogus since the same message id
1:0885c60:             // could have been sent to 2 different subscriptions on the same Stomp connection.
1:0885c60:             // For example, when 2 subs are created on the same topic.
1:0885c60:             for (StompSubscription sub : subscriptionsByConsumerId.values()) {
1:0885c60:                 MessageAck ack = sub.onStompMessageAck(messageId, activemqTx);
1:0885c60:                 if (ack != null) {
1:f33f32e:                     sendToActiveMQ(ack, createResponseHandler(command));
1:0885c60:                     acked = true;
1:0885c60:                     break;
1:0885c60:                 }
1:f812e34:             }
1:f812e34:         }
1:0885c60: 
1:fc00993:         if (!acked) {
1:f812e34:             throw new ProtocolException("Unexpected ACK received for message-id [" + messageId + "]");
1:fc00993:         }
1:f812e34:     }
1:dc98d96: 
1:f812e34:     protected void onStompBegin(StompFrame command) throws ProtocolException {
1:f812e34:         checkConnected();
1:dc98d96: 
1:ecf89a6:         Map<String, String> headers = command.getHeaders();
1:dc98d96: 
1:ecf89a6:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:dc98d96: 
1:dc98d96:         if (!headers.containsKey(Stomp.Headers.TRANSACTION)) {
1:dc98d96:             throw new ProtocolException("Must specify the transaction you are beginning");
1:f812e34:         }
1:dc98d96: 
1:f812e34:         if (transactions.get(stompTx) != null) {
1:c3d8ca7:             throw new ProtocolException("The transaction was already started: " + stompTx);
1:f812e34:         }
1:dc98d96: 
1:dc98d96:         LocalTransactionId activemqTx = new LocalTransactionId(connectionId, transactionIdGenerator.getNextSequenceId());
1:dc98d96:         transactions.put(stompTx, activemqTx);
1:dc98d96: 
1:dc98d96:         TransactionInfo tx = new TransactionInfo();
1:dc98d96:         tx.setConnectionId(connectionId);
1:dc98d96:         tx.setTransactionId(activemqTx);
1:dc98d96:         tx.setType(TransactionInfo.BEGIN);
1:dc98d96: 
1:f33f32e:         sendToActiveMQ(tx, createResponseHandler(command));
1:f812e34:     }
1:f6ebeec: 
1:f812e34:     protected void onStompCommit(StompFrame command) throws ProtocolException {
1:f812e34:         checkConnected();
1:dc98d96: 
1:ecf89a6:         Map<String, String> headers = command.getHeaders();
1:dc98d96: 
1:ecf89a6:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:f812e34:         if (stompTx == null) {
1:dc98d96:             throw new ProtocolException("Must specify the transaction you are committing");
1:f812e34:         }
1:dc98d96: 
1:ecf89a6:         TransactionId activemqTx = transactions.remove(stompTx);
1:f8485e3:         if (activemqTx == null) {
1:f812e34:             throw new ProtocolException("Invalid transaction id: " + stompTx);
1:f812e34:         }
1:dc98d96: 
1:0885c60:         for (StompSubscription sub : subscriptionsByConsumerId.values()) {
1:f6ebeec:             sub.onStompCommit(activemqTx);
1:f6ebeec:         }
1:dc98d96: 
1:52d95ee:         pedingAcks.clear();
1:52d95ee: 
1:dc98d96:         TransactionInfo tx = new TransactionInfo();
1:dc98d96:         tx.setConnectionId(connectionId);
1:dc98d96:         tx.setTransactionId(activemqTx);
1:dc98d96:         tx.setType(TransactionInfo.COMMIT_ONE_PHASE);
1:52d95ee: 
1:f33f32e:         sendToActiveMQ(tx, createResponseHandler(command));
1:f812e34:     }
1:5ebfbf0: 
1:f812e34:     protected void onStompAbort(StompFrame command) throws ProtocolException {
1:f812e34:         checkConnected();
1:ecf89a6:         Map<String, String> headers = command.getHeaders();
1:dc98d96: 
1:ecf89a6:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:f812e34:         if (stompTx == null) {
1:dc98d96:             throw new ProtocolException("Must specify the transaction you are committing");
1:f812e34:         }
1:dc98d96: 
1:ecf89a6:         TransactionId activemqTx = transactions.remove(stompTx);
1:f8485e3:         if (activemqTx == null) {
1:f812e34:             throw new ProtocolException("Invalid transaction id: " + stompTx);
1:f812e34:         }
1:0885c60:         for (StompSubscription sub : subscriptionsByConsumerId.values()) {
1:f6ebeec:             try {
1:5ebfbf0:                 sub.onStompAbort(activemqTx);
1:f6ebeec:             } catch (Exception e) {
1:5ebfbf0:                 throw new ProtocolException("Transaction abort failed", false, e);
1:f6ebeec:             }
1:f6ebeec:         }
1:dc98d96: 
1:52d95ee:         pedingAcks.clear();
1:dc98d96: 
1:dc98d96:         TransactionInfo tx = new TransactionInfo();
1:dc98d96:         tx.setConnectionId(connectionId);
1:dc98d96:         tx.setTransactionId(activemqTx);
1:dc98d96:         tx.setType(TransactionInfo.ROLLBACK);
1:dc98d96: 
1:f33f32e:         sendToActiveMQ(tx, createResponseHandler(command));
1:f812e34:     }
1:dc98d96: 
1:f812e34:     protected void onStompSubscribe(StompFrame command) throws ProtocolException {
1:f812e34:         checkConnected();
1:2b5608f:         FrameTranslator translator = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION));
1:ecf89a6:         Map<String, String> headers = command.getHeaders();
1:dc98d96: 
1:ecf89a6:         String subscriptionId = headers.get(Stomp.Headers.Subscribe.ID);
1:ecf89a6:         String destination = headers.get(Stomp.Headers.Subscribe.DESTINATION);
1:5ebfbf0: 
1:4fe2bd5:         if (!this.version.equals(Stomp.V1_0) && subscriptionId == null) {
1:0885c60:             throw new ProtocolException("SUBSCRIBE received without a subscription id!");
1:0885c60:         }
1:0885c60: 
1:bd31548:         final ActiveMQDestination actualDest = translator.convertDestination(this, destination, true);
1:dc98d96: 
1:5ebfbf0:         if (actualDest == null) {
1:bc45bf8:             throw new ProtocolException("Invalid 'null' Destination.");
1:5ebfbf0:         }
1:5ebfbf0: 
1:bd31548:         final ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
1:dc98d96:         ConsumerInfo consumerInfo = new ConsumerInfo(id);
1:bc45bf8:         consumerInfo.setPrefetchSize(actualDest.isQueue() ?
1:bc45bf8:                 ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH :
1:bc45bf8:                 headers.containsKey("activemq.subscriptionName") ?
1:bc45bf8:                         ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH : ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH);
1:dc98d96:         consumerInfo.setDispatchAsync(true);
1:dc98d96: 
1:0885c60:         String browser = headers.get(Stomp.Headers.Subscribe.BROWSER);
1:0885c60:         if (browser != null && browser.equals(Stomp.TRUE)) {
1:0885c60: 
1:4e4d072:             if (this.version.equals(Stomp.V1_0)) {
1:4e4d072:                 throw new ProtocolException("Queue Browser feature only valid for Stomp v1.1+ clients!");
1:0885c60:             }
1:0885c60: 
1:0885c60:             consumerInfo.setBrowser(true);
1:bc45bf8:             consumerInfo.setPrefetchSize(ActiveMQPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH);
1:0885c60:         }
1:0885c60: 
1:ecf89a6:         String selector = headers.remove(Stomp.Headers.Subscribe.SELECTOR);
1:6d08aca:         if (selector != null) {
1:6d08aca:             consumerInfo.setSelector("convert_string_expressions:" + selector);
1:2f25870:         }
1:dc98d96: 
1:dc98d96:         IntrospectionSupport.setProperties(consumerInfo, headers, "activemq.");
1:dc98d96: 
1:4bba15a:         if (actualDest.isQueue() && consumerInfo.getSubscriptionName() != null) {
1:556ee7b:             throw new ProtocolException("Invalid Subscription: cannot durably subscribe to a Queue destination!");
1:4bba15a:         }
1:4bba15a: 
1:c360c3e:         consumerInfo.setDestination(actualDest);
1:46160c7:         consumerInfo.setDispatchAsync(true);
1:dc98d96: 
1:0885c60:         StompSubscription stompSubscription;
1:0885c60:         if (!consumerInfo.isBrowser()) {
1:0885c60:             stompSubscription = new StompSubscription(this, subscriptionId, consumerInfo, headers.get(Stomp.Headers.TRANSFORMATION));
1:0885c60:         } else {
1:0885c60:             stompSubscription = new StompQueueBrowserSubscription(this, subscriptionId, consumerInfo, headers.get(Stomp.Headers.TRANSFORMATION));
1:0885c60:         }
1:fc00993:         stompSubscription.setDestination(actualDest);
1:dc98d96: 
1:ecf89a6:         String ackMode = headers.get(Stomp.Headers.Subscribe.ACK_MODE);
1:dc98d96:         if (Stomp.Headers.Subscribe.AckModeValues.CLIENT.equals(ackMode)) {
1:dc98d96:             stompSubscription.setAckMode(StompSubscription.CLIENT_ACK);
1:b1288f2:         } else if (Stomp.Headers.Subscribe.AckModeValues.INDIVIDUAL.equals(ackMode)) {
1:b1288f2:             stompSubscription.setAckMode(StompSubscription.INDIVIDUAL_ACK);
1:471ea33:         } else {
1:dc98d96:             stompSubscription.setAckMode(StompSubscription.AUTO_ACK);
1:f812e34:         }
1:dc98d96: 
1:dc98d96:         subscriptionsByConsumerId.put(id, stompSubscription);
1:0885c60:         // Stomp v1.0 doesn't need to set this header so we avoid an NPE if not set.
1:0885c60:         if (subscriptionId != null) {
1:0885c60:             subscriptions.put(subscriptionId, stompSubscription);
1:0885c60:         }
1:0885c60: 
1:bd31548:         final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:bd31548:         if (receiptId != null && consumerInfo.getPrefetchSize() > 0) {
1:bd31548: 
1:bd31548:             final StompFrame cmd = command;
1:bd31548:             final int prefetch = consumerInfo.getPrefetchSize();
1:bd31548: 
1:bd31548:             // Since dispatch could beat the receipt we set prefetch to zero to start and then
1:bd31548:             // once we've sent our Receipt we are safe to turn on dispatch if the response isn't
1:bd31548:             // an error message.
1:bd31548:             consumerInfo.setPrefetchSize(0);
1:bd31548: 
1:bd31548:             final ResponseHandler handler = new ResponseHandler() {
1:436f892:                 @Override
1:bd31548:                 public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:bd31548:                     if (response.isException()) {
1:bd31548:                         // Generally a command can fail.. but that does not invalidate the connection.
1:bd31548:                         // We report back the failure but we don't close the connection.
1:bd31548:                         Throwable exception = ((ExceptionResponse)response).getException();
1:bd31548:                         handleException(exception, cmd);
1:bd31548:                     } else {
1:bd31548:                         StompFrame sc = new StompFrame();
1:bd31548:                         sc.setAction(Stomp.Responses.RECEIPT);
1:bd31548:                         sc.setHeaders(new HashMap<String, String>(1));
1:bd31548:                         sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:bd31548:                         stompTransport.sendToStomp(sc);
1:bd31548: 
1:bd31548:                         ConsumerControl control = new ConsumerControl();
1:bd31548:                         control.setPrefetch(prefetch);
1:bd31548:                         control.setDestination(actualDest);
1:bd31548:                         control.setConsumerId(id);
1:bd31548: 
1:bd31548:                         sendToActiveMQ(control, null);
1:bd31548:                     }
1:bd31548:                 }
1:bd31548:             };
1:bd31548: 
1:bd31548:             sendToActiveMQ(consumerInfo, handler);
1:bd31548:         } else {
1:bd31548:             sendToActiveMQ(consumerInfo, createResponseHandler(command));
1:bd31548:         }
1:f812e34:     }
1:0885c60: 
1:f812e34:     protected void onStompUnsubscribe(StompFrame command) throws ProtocolException {
1:f812e34:         checkConnected();
1:ecf89a6:         Map<String, String> headers = command.getHeaders();
1:603b215: 
1:f812e34:         ActiveMQDestination destination = null;
1:dc98d96:         Object o = headers.get(Stomp.Headers.Unsubscribe.DESTINATION);
1:fc00993:         if (o != null) {
1:1c26408:             destination = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION)).convertDestination(this, (String)o, true);
1:fc00993:         }
1:dc98d96: 
1:ecf89a6:         String subscriptionId = headers.get(Stomp.Headers.Unsubscribe.ID);
1:4fe2bd5:         if (!this.version.equals(Stomp.V1_0) && subscriptionId == null) {
1:0885c60:             throw new ProtocolException("UNSUBSCRIBE received without a subscription id!");
1:0885c60:         }
1:dc98d96: 
1:f812e34:         if (subscriptionId == null && destination == null) {
1:dc98d96:             throw new ProtocolException("Must specify the subscriptionId or the destination you are unsubscribing from");
1:f812e34:         }
1:5ebfbf0: 
1:4c92244:         // check if it is a durable subscription
1:5ebfbf0:         String durable = command.getHeaders().get("activemq.subscriptionName");
1:27a74d3:         String clientId = durable;
1:4fe2bd5:         if (!this.version.equals(Stomp.V1_0)) {
1:27a74d3:             clientId = connectionInfo.getClientId();
1:27a74d3:         }
1:6d08aca: 
1:4c92244:         if (durable != null) {
1:4c92244:             RemoveSubscriptionInfo info = new RemoveSubscriptionInfo();
1:27a74d3:             info.setClientId(clientId);
1:4c92244:             info.setSubscriptionName(durable);
1:4c92244:             info.setConnectionId(connectionId);
1:f33f32e:             sendToActiveMQ(info, createResponseHandler(command));
1:4c92244:             return;
1:530884a:         }
1:0885c60: 
1:0885c60:         if (subscriptionId != null) {
1:0885c60:             StompSubscription sub = this.subscriptions.remove(subscriptionId);
1:0885c60:             if (sub != null) {
1:f33f32e:                 sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
1:dc98d96:                 return;
1:f812e34:             }
1:0885c60:         } else {
1:0885c60:             // Unsubscribing using a destination is a bit weird if multiple subscriptions
1:0885c60:             // are created with the same destination.
1:0885c60:             for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
1:0885c60:                 StompSubscription sub = iter.next();
1:0885c60:                 if (destination != null && destination.equals(sub.getDestination())) {
1:f33f32e:                     sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
1:0885c60:                     iter.remove();
1:0885c60:                     return;
1:0885c60:                 }
1:0885c60:             }
1:f812e34:         }
1:5ebfbf0: 
1:dc98d96:         throw new ProtocolException("No subscription matched.");
1:f812e34:     }
1:690b7bc: 
1:690b7bc:     ConnectionInfo connectionInfo = new ConnectionInfo();
1:5ebfbf0: 
1:471ea33:     protected void onStompConnect(final StompFrame command) throws ProtocolException {
1:dc98d96: 
1:f812e34:         if (connected.get()) {
1:c3d8ca7:             throw new ProtocolException("Already connected.");
1:f812e34:         }
1:dc98d96: 
1:ecf89a6:         final Map<String, String> headers = command.getHeaders();
1:dc98d96: 
1:dc98d96:         // allow anyone to login for now
1:ecf89a6:         String login = headers.get(Stomp.Headers.Connect.LOGIN);
1:ecf89a6:         String passcode = headers.get(Stomp.Headers.Connect.PASSCODE);
1:ecf89a6:         String clientId = headers.get(Stomp.Headers.Connect.CLIENT_ID);
1:0885c60:         String heartBeat = headers.get(Stomp.Headers.Connect.HEART_BEAT);
1:dc98d96: 
1:0885c60:         if (heartBeat == null) {
1:33edc99:             heartBeat = defaultHeartBeat;
1:0885c60:         }
1:0885c60: 
1:a54fa4b:         this.version = StompCodec.detectVersion(headers);
1:0885c60: 
1:0f11d8c:         configureInactivityMonitor(heartBeat.trim());
1:dc98d96: 
1:dc98d96:         IntrospectionSupport.setProperties(connectionInfo, headers, "activemq.");
1:dc98d96:         connectionInfo.setConnectionId(connectionId);
1:fc00993:         if (clientId != null) {
1:dc98d96:             connectionInfo.setClientId(clientId);
1:0885c60:         } else {
1:f812e34:             connectionInfo.setClientId("" + connectionInfo.getConnectionId().toString());
1:0885c60:         }
1:dc98d96: 
1:dc98d96:         connectionInfo.setResponseRequired(true);
1:dc98d96:         connectionInfo.setUserName(login);
1:dc98d96:         connectionInfo.setPassword(passcode);
1:f8f24e8:         connectionInfo.setTransportContext(command.getTransportContext());
1:dc98d96: 
1:f812e34:         sendToActiveMQ(connectionInfo, new ResponseHandler() {
1:436f892:             @Override
1:f812e34:             public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:dc98d96: 
1:471ea33:                 if (response.isException()) {
1:471ea33:                     // If the connection attempt fails we close the socket.
1:471ea33:                     Throwable exception = ((ExceptionResponse)response).getException();
1:471ea33:                     handleException(exception, command);
1:ceed011:                     getStompTransport().onException(IOExceptionSupport.create(exception));
1:471ea33:                     return;
1:471ea33:                 }
1:471ea33: 
1:f812e34:                 final SessionInfo sessionInfo = new SessionInfo(sessionId);
1:f812e34:                 sendToActiveMQ(sessionInfo, null);
1:471ea33: 
1:f812e34:                 final ProducerInfo producerInfo = new ProducerInfo(producerId);
1:f812e34:                 sendToActiveMQ(producerInfo, new ResponseHandler() {
1:436f892:                     @Override
1:f812e34:                     public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:5ebfbf0: 
1:471ea33:                         if (response.isException()) {
1:471ea33:                             // If the connection attempt fails we close the socket.
1:471ea33:                             Throwable exception = ((ExceptionResponse)response).getException();
1:471ea33:                             handleException(exception, command);
1:ceed011:                             getStompTransport().onException(IOExceptionSupport.create(exception));
1:471ea33:                         }
1:5ebfbf0: 
1:f812e34:                         connected.set(true);
1:9abbe82:                         HashMap<String, String> responseHeaders = new HashMap<>();
1:471ea33: 
1:f812e34:                         responseHeaders.put(Stomp.Headers.Connected.SESSION, connectionInfo.getClientId());
1:ecf89a6:                         String requestId = headers.get(Stomp.Headers.Connect.REQUEST_ID);
1:1a33eb6:                         if (requestId == null) {
1:1a33eb6:                             // TODO legacy
1:ecf89a6:                             requestId = headers.get(Stomp.Headers.RECEIPT_REQUESTED);
1:fc00993:                         }
1:f812e34:                         if (requestId != null) {
1:1a33eb6:                             // TODO legacy
1:f812e34:                             responseHeaders.put(Stomp.Headers.Connected.RESPONSE_ID, requestId);
1:1a33eb6:                             responseHeaders.put(Stomp.Headers.Response.RECEIPT_ID, requestId);
1:f812e34:                         }
1:dc98d96: 
1:0885c60:                         responseHeaders.put(Stomp.Headers.Connected.VERSION, version);
1:0885c60:                         responseHeaders.put(Stomp.Headers.Connected.HEART_BEAT,
1:0885c60:                                             String.format("%d,%d", hbWriteInterval, hbReadInterval));
1:0885c60:                         responseHeaders.put(Stomp.Headers.Connected.SERVER, "ActiveMQ/"+BROKER_VERSION);
1:0885c60: 
1:f812e34:                         StompFrame sc = new StompFrame();
1:f812e34:                         sc.setAction(Stomp.Responses.CONNECTED);
1:f812e34:                         sc.setHeaders(responseHeaders);
1:f812e34:                         sendToStomp(sc);
1:0885c60: 
1:0885c60:                         StompWireFormat format = stompTransport.getWireFormat();
1:0885c60:                         if (format != null) {
1:a54fa4b:                             format.setStompVersion(version);
1:0885c60:                         }
1:0885c60:                     }
1:f812e34:                 });
1:f812e34:             }
1:f812e34:         });
1:f812e34:     }
1:dc98d96: 
1:f812e34:     protected void onStompDisconnect(StompFrame command) throws ProtocolException {
1:cc95295:         if (connected.get()) {
1:f33f32e:             sendToActiveMQ(connectionInfo.createRemoveCommand(), createResponseHandler(command));
1:f33f32e:             sendToActiveMQ(new ShutdownInfo(), createResponseHandler(command));
1:cc95295:             connected.set(false);
1:cc95295:         }
1:f812e34:     }
1:dc98d96: 
1:f812e34:     protected void checkConnected() throws ProtocolException {
1:f812e34:         if (!connected.get()) {
1:f812e34:             throw new ProtocolException("Not connected.");
1:f812e34:         }
1:f812e34:     }
1:dc98d96: 
1:f812e34:     /**
1:f8485e3:      * Dispatch a ActiveMQ command
1:5ebfbf0:      *
1:2b5608f:      * @param command
1:dc98d96:      * @throws IOException
1:2b5608f:      */
1:690b7bc:     public void onActiveMQCommand(Command command) throws IOException, JMSException {
1:f812e34:         if (command.isResponse()) {
1:f812e34:             Response response = (Response)command;
1:ecf89a6:             ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
1:f812e34:             if (rh != null) {
1:f812e34:                 rh.onResponse(this, response);
1:471ea33:             } else {
1:471ea33:                 // Pass down any unexpected errors. Should this close the connection?
1:471ea33:                 if (response.isException()) {
1:471ea33:                     Throwable exception = ((ExceptionResponse)response).getException();
1:471ea33:                     handleException(exception, null);
1:471ea33:                 }
1:f812e34:             }
1:f812e34:         } else if (command.isMessageDispatch()) {
1:f812e34:             MessageDispatch md = (MessageDispatch)command;
1:ecf89a6:             StompSubscription sub = subscriptionsByConsumerId.get(md.getConsumerId());
1:f812e34:             if (sub != null) {
1:6d08aca:                 String ackId = null;
1:fdc2551:                 if (version.equals(Stomp.V1_2) && sub.getAckMode() != Stomp.Headers.Subscribe.AckModeValues.AUTO && md.getMessage() != null) {
1:6d08aca:                     AckEntry pendingAck = new AckEntry(md.getMessage().getMessageId().toString(), sub);
1:6d08aca:                     ackId = this.ACK_ID_GENERATOR.generateId();
1:6d08aca:                     this.pedingAcks.put(ackId, pendingAck);
1:6d08aca:                 }
1:6d08aca:                 try {
1:6d08aca:                     sub.onMessageDispatch(md, ackId);
1:6d08aca:                 } catch (Exception ex) {
1:6d08aca:                     if (ackId != null) {
1:6d08aca:                         this.pedingAcks.remove(ackId);
1:6d08aca:                     }
1:6d08aca:                 }
1:f812e34:             }
1:0885c60:         } else if (command.getDataStructureType() == CommandTypes.KEEP_ALIVE_INFO) {
1:0885c60:             stompTransport.sendToStomp(ping);
1:471ea33:         } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
1:471ea33:             // Pass down any unexpected async errors. Should this close the connection?
1:471ea33:             Throwable exception = ((ConnectionError)command).getException();
1:471ea33:             handleException(exception, null);
1:f812e34:         }
1:f812e34:     }
1:dc98d96: 
1:f812e34:     public ActiveMQMessage convertMessage(StompFrame command) throws IOException, JMSException {
1:2b5608f:         ActiveMQMessage msg = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION)).convertFrame(this, command);
1:dc98d96:         return msg;
1:04a6379:     }
1:dc98d96: 
1:3910056:     public StompFrame convertMessage(ActiveMQMessage message, boolean ignoreTransformation) throws IOException, JMSException {
1:5ebfbf0:         if (ignoreTransformation == true) {
1:5ebfbf0:             return frameTranslator.convertMessage(this, message);
1:5ebfbf0:         } else {
1:533cedc:             FrameTranslator translator = findTranslator(
1:533cedc:                 message.getStringProperty(Stomp.Headers.TRANSFORMATION), message.getDestination(), message.isAdvisory());
1:533cedc:             return translator.convertMessage(this, message);
1:5ebfbf0:         }
1:5ebfbf0:     }
1:04a6379: 
1:ceed011:     public StompTransport getStompTransport() {
1:ceed011:         return stompTransport;
1:5ebfbf0:     }
1:04a6379: 
1:9ff3500:     public ActiveMQDestination createTempDestination(String name, boolean topic) {
2:04a6379:         ActiveMQDestination rc = tempDestinations.get(name);
2:04a6379:         if( rc == null ) {
1:9ff3500:             if (topic) {
1:9ff3500:                 rc = new ActiveMQTempTopic(connectionId, tempDestinationGenerator.getNextSequenceId());
1:9ff3500:             } else {
1:9ff3500:                 rc = new ActiveMQTempQueue(connectionId, tempDestinationGenerator.getNextSequenceId());
1:9ff3500:             }
1:f33f32e:             sendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
2:04a6379:             tempDestinations.put(name, rc);
1:04a6379:             tempDestinationAmqToStompMap.put(rc.getQualifiedName(), name);
1:5ebfbf0:         }
2:04a6379:         return rc;
1:5ebfbf0:     }
1:04a6379: 
1:5ebfbf0:     public String getCreatedTempDestinationName(ActiveMQDestination destination) {
1:5ebfbf0:         return tempDestinationAmqToStompMap.get(destination.getQualifiedName());
1:0885c60:     }
1:0885c60: 
1:33edc99:     public String getDefaultHeartBeat() {
1:33edc99:         return defaultHeartBeat;
1:0885c60:     }
1:0885c60: 
1:33edc99:     public void setDefaultHeartBeat(String defaultHeartBeat) {
1:33edc99:         this.defaultHeartBeat = defaultHeartBeat;
1:5ebfbf0:     }
1:0885c60: 
1:d0ab117:     /**
1:d0ab117:      * @return the hbGracePeriodMultiplier
1:d0ab117:      */
1:d0ab117:     public float getHbGracePeriodMultiplier() {
1:d0ab117:         return hbGracePeriodMultiplier;
1:d0ab117:     }
1:d0ab117: 
1:d0ab117:     /**
1:d0ab117:      * @param hbGracePeriodMultiplier the hbGracePeriodMultiplier to set
1:d0ab117:      */
1:d0ab117:     public void setHbGracePeriodMultiplier(float hbGracePeriodMultiplier) {
1:d0ab117:         this.hbGracePeriodMultiplier = hbGracePeriodMultiplier;
1:d0ab117:     }
1:d0ab117: 
1:0885c60:     protected void configureInactivityMonitor(String heartBeatConfig) throws ProtocolException {
1:0885c60: 
1:0885c60:         String[] keepAliveOpts = heartBeatConfig.split(Stomp.COMMA);
1:0885c60: 
1:0885c60:         if (keepAliveOpts == null || keepAliveOpts.length != 2) {
1:33edc99:             throw new ProtocolException("Invalid heart-beat header:" + heartBeatConfig, true);
1:0885c60:         } else {
1:0885c60: 
1:0885c60:             try {
1:53ec665:                 hbReadInterval = (Long.parseLong(keepAliveOpts[0]));
1:0885c60:                 hbWriteInterval = Long.parseLong(keepAliveOpts[1]);
1:0885c60:             } catch(NumberFormatException e) {
1:33edc99:                 throw new ProtocolException("Invalid heart-beat header:" + heartBeatConfig, true);
1:0885c60:             }
1:0885c60: 
1:0885c60:             try {
1:0885c60:                 StompInactivityMonitor monitor = this.stompTransport.getInactivityMonitor();
1:d0ab117:                 monitor.setReadCheckTime((long) (hbReadInterval * hbGracePeriodMultiplier));
1:33edc99:                 monitor.setInitialDelayTime(Math.min(hbReadInterval, hbWriteInterval));
1:0885c60:                 monitor.setWriteCheckTime(hbWriteInterval);
1:0885c60:                 monitor.startMonitoring();
1:0885c60:             } catch(Exception ex) {
1:0885c60:                 hbReadInterval = 0;
1:0885c60:                 hbWriteInterval = 0;
1:0885c60:             }
1:0885c60: 
1:0885c60:             if (LOG.isDebugEnabled()) {
1:b595b8b:                 LOG.debug("Stomp Connect heartbeat conf RW[{},{}]", hbReadInterval, hbWriteInterval);
1:0885c60:             }
1:0885c60:         }
1:0885c60:     }
1:0885c60: 
1:603b215:     protected void sendReceipt(StompFrame command) {
1:603b215:         final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:603b215:         if (receiptId != null) {
1:603b215:             StompFrame sc = new StompFrame();
1:603b215:             sc.setAction(Stomp.Responses.RECEIPT);
1:603b215:             sc.setHeaders(new HashMap<String, String>(1));
1:603b215:             sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:603b215:             try {
1:603b215:                 sendToStomp(sc);
1:603b215:             } catch (IOException e) {
1:b595b8b:                 LOG.warn("Could not send a receipt for {}", command, e);
1:603b215:             }
1:603b215:         }
1:603b215:     }
1:b595b8b: 
1:b595b8b:     /**
1:b595b8b:      * Retrieve the STOMP action value from a frame if the value is valid, otherwise
1:b595b8b:      * return an unknown string to allow for safe log output.
1:b595b8b:      *
1:b595b8b:      * @param command
1:b595b8b:      *      The STOMP command to fetch an action from.
1:b595b8b:      *
1:b595b8b:      * @return the command action or a safe string to use in logging.
1:b595b8b:      */
1:b595b8b:     protected Object safeGetAction(StompFrame command) {
1:b595b8b:         String result = "<Unknown>";
1:4e60075:         if (command != null && command.getAction() != null) {
1:b595b8b:             String action = command.getAction().trim();
1:b595b8b: 
1:b595b8b:             if (action != null) {
1:b595b8b:                 switch (action) {
1:b595b8b:                     case Stomp.Commands.SEND:
1:b595b8b:                     case Stomp.Commands.ACK:
1:b595b8b:                     case Stomp.Commands.NACK:
1:b595b8b:                     case Stomp.Commands.BEGIN:
1:b595b8b:                     case Stomp.Commands.COMMIT:
1:b595b8b:                     case Stomp.Commands.ABORT:
1:b595b8b:                     case Stomp.Commands.SUBSCRIBE:
1:b595b8b:                     case Stomp.Commands.UNSUBSCRIBE:
1:b595b8b:                     case Stomp.Commands.CONNECT:
1:b595b8b:                     case Stomp.Commands.STOMP:
1:b595b8b:                     case Stomp.Commands.DISCONNECT:
1:b595b8b:                         result = action;
1:b595b8b:                         break;
1:5fb4704:                     case Stomp.Commands.SUBSCRIBE_PREFIX:
1:5fb4704:                         result = Stomp.Commands.SUBSCRIBE;
1:5fb4704:                     case Stomp.Commands.UNSUBSCRIBE_PREFIX:
1:5fb4704:                         result = Stomp.Commands.UNSUBSCRIBE;
1:b595b8b:                     default:
1:b595b8b:                         break;
1:b595b8b:                 }
1:b595b8b:             }
1:b595b8b:         }
1:b595b8b: 
1:b595b8b:         return result;
1:b595b8b:     }
1:9abbe82: 
1:9abbe82:     /**
1:9abbe82:      * Remove all pending acknowledgement markers that are batched into the single
1:9abbe82:      * client acknowledge operation.
1:9abbe82:      *
1:9abbe82:      * @param subscription
1:9abbe82:      *      The STOMP Subscription that has performed a client acknowledge.
1:9abbe82:      * @param msgIdsToRemove
1:9abbe82:      *      List of message IDs that are bound to the subscription that has ack'd
1:9abbe82:      */
1:9abbe82:     protected void afterClientAck(StompSubscription subscription, ArrayList<String> msgIdsToRemove) {
1:9abbe82:         int count = 0;
1:9abbe82: 
1:9abbe82:         for (Map.Entry<String,AckEntry> entry : this.pedingAcks.entrySet()){
1:9abbe82:             AckEntry actEntry = entry.getValue();
1:9abbe82:             if (msgIdsToRemove.contains(actEntry.messageId)) {
1:9abbe82:                 this.pedingAcks.remove(entry.getKey());
1:9abbe82:                 count++;
1:9abbe82:             }
1:9abbe82:         }
1:9abbe82: 
1:9abbe82:         LOG.trace("Subscription:[{}] client acknowledged {} messages", subscription.getSubscriptionId(), count);
1:9abbe82:     }
1:3910056: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:5fb4704
/////////////////////////////////////////////////////////////////////////
1:             } else if (action.startsWith(Stomp.Commands.SUBSCRIBE_PREFIX)) {
1:             } else if (action.startsWith(Stomp.Commands.UNSUBSCRIBE_PREFIX)) {
/////////////////////////////////////////////////////////////////////////
1:                     case Stomp.Commands.SUBSCRIBE_PREFIX:
1:                         result = Stomp.Commands.SUBSCRIBE;
1:                     case Stomp.Commands.UNSUBSCRIBE_PREFIX:
1:                         result = Stomp.Commands.UNSUBSCRIBE;
commit:9abbe82
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<>();
1:     private final ConcurrentMap<ConsumerId, StompSubscription> subscriptionsByConsumerId = new ConcurrentHashMap<>();
1:     private final ConcurrentMap<String, StompSubscription> subscriptions = new ConcurrentHashMap<>();
1:     private final ConcurrentMap<String, ActiveMQDestination> tempDestinations = new ConcurrentHashMap<>();
1:     private final ConcurrentMap<String, String> tempDestinationAmqToStompMap = new ConcurrentHashMap<>();
1:     private final Map<String, LocalTransactionId> transactions = new ConcurrentHashMap<>();
1:     private final ConcurrentMap<String, AckEntry> pedingAcks = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String, String> headers = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1:                         HashMap<String, String> responseHeaders = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Remove all pending acknowledgement markers that are batched into the single
1:      * client acknowledge operation.
1:      *
1:      * @param subscription
1:      *      The STOMP Subscription that has performed a client acknowledge.
1:      * @param msgIdsToRemove
1:      *      List of message IDs that are bound to the subscription that has ack'd
1:      */
1:     protected void afterClientAck(StompSubscription subscription, ArrayList<String> msgIdsToRemove) {
1:         int count = 0;
1: 
1:         for (Map.Entry<String,AckEntry> entry : this.pedingAcks.entrySet()){
1:             AckEntry actEntry = entry.getValue();
1:             if (msgIdsToRemove.contains(actEntry.messageId)) {
1:                 this.pedingAcks.remove(entry.getKey());
1:                 count++;
1:             }
1:         }
1: 
1:         LOG.trace("Subscription:[{}] client acknowledged {} messages", subscription.getSubscriptionId(), count);
1:     }
commit:4e60075
/////////////////////////////////////////////////////////////////////////
1:         if (command != null && command.getAction() != null) {
commit:b595b8b
/////////////////////////////////////////////////////////////////////////
1:         if (command == null) {
1:             LOG.warn("Exception occurred while processing a command: {}", exception.toString());
1:         } else {
1:             LOG.warn("Exception occurred processing: {} -> {}", safeGetAction(command), exception.toString());
1:         }
1: 
1:         if (command != null && LOG.isTraceEnabled()) {
1:             LOG.trace("Command that caused the error: {}", command);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Stomp Connect heartbeat conf RW[{},{}]", hbReadInterval, hbWriteInterval);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Could not send a receipt for {}", command, e);
1: 
1:     /**
1:      * Retrieve the STOMP action value from a frame if the value is valid, otherwise
1:      * return an unknown string to allow for safe log output.
1:      *
1:      * @param command
1:      *      The STOMP command to fetch an action from.
1:      *
1:      * @return the command action or a safe string to use in logging.
1:      */
1:     protected Object safeGetAction(StompFrame command) {
1:         String result = "<Unknown>";
1:         if (command != null) {
1:             String action = command.getAction().trim();
1: 
1:             if (action != null) {
1:                 switch (action) {
1:                     case Stomp.Commands.SEND:
1:                     case Stomp.Commands.ACK:
1:                     case Stomp.Commands.NACK:
1:                     case Stomp.Commands.BEGIN:
1:                     case Stomp.Commands.COMMIT:
1:                     case Stomp.Commands.ABORT:
1:                     case Stomp.Commands.SUBSCRIBE:
1:                     case Stomp.Commands.UNSUBSCRIBE:
1:                     case Stomp.Commands.CONNECT:
1:                     case Stomp.Commands.STOMP:
1:                     case Stomp.Commands.DISCONNECT:
1:                         result = action;
1:                         break;
1:                     default:
1:                         break;
1:                 }
1:             }
1:         }
1: 
1:         return result;
1:     }
commit:adf70bc
/////////////////////////////////////////////////////////////////////////
1:                 throw new ProtocolException("Unknown STOMP action: " + action, true);
commit:c360c3e
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo.setDestination(actualDest);
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
0:     private final ConcurrentMap<ConsumerId, StompSubscription> subscriptionsByConsumerId = new ConcurrentHashMap<ConsumerId, StompSubscription>();
0:     private final ConcurrentMap<String, StompSubscription> subscriptions = new ConcurrentHashMap<String, StompSubscription>();
0:     private final ConcurrentMap<String, ActiveMQDestination> tempDestinations = new ConcurrentHashMap<String, ActiveMQDestination>();
0:     private final ConcurrentMap<String, String> tempDestinationAmqToStompMap = new ConcurrentHashMap<String, String>();
0:     private final ConcurrentMap<String, AckEntry> pedingAcks = new ConcurrentHashMap<String, AckEntry>();
commit:4fe2bd5
/////////////////////////////////////////////////////////////////////////
1:         if (!this.version.equals(Stomp.V1_0) && subscriptionId == null) {
/////////////////////////////////////////////////////////////////////////
1:         if (!this.version.equals(Stomp.V1_0) && subscriptionId == null) {
/////////////////////////////////////////////////////////////////////////
1:         if (!this.version.equals(Stomp.V1_0)) {
commit:52d95ee
/////////////////////////////////////////////////////////////////////////
1:             AckEntry pendingAck = this.pedingAcks.remove(ackId);
/////////////////////////////////////////////////////////////////////////
1:             AckEntry pendingAck = this.pedingAcks.remove(ackId);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         pedingAcks.clear();
1: 
/////////////////////////////////////////////////////////////////////////
1:         pedingAcks.clear();
1: 
commit:533cedc
/////////////////////////////////////////////////////////////////////////
1:         return findTranslator(header, null, false);
1:     protected FrameTranslator findTranslator(String header, ActiveMQDestination destination, boolean advisory) {
1:                 translator = (FrameTranslator) FRAME_TRANSLATOR_FINDER.newInstance(header);
1:                 if (destination != null && (advisory || AdvisorySupport.isAdvisoryTopic(destination))) {
/////////////////////////////////////////////////////////////////////////
1:      * Convert a STOMP command
/////////////////////////////////////////////////////////////////////////
1:             FrameTranslator translator = findTranslator(
1:                 message.getStringProperty(Stomp.Headers.TRANSFORMATION), message.getDestination(), message.isAdvisory());
1:             return translator.convertMessage(this, message);
commit:fdc2551
/////////////////////////////////////////////////////////////////////////
1:                 if (version.equals(Stomp.V1_2) && sub.getAckMode() != Stomp.Headers.Subscribe.AckModeValues.AUTO && md.getMessage() != null) {
commit:c3d8ca7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQTempQueue;
1: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.CommandTypes;
1: import org.apache.activemq.command.ConnectionError;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerControl;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.SessionInfo;
1: import org.apache.activemq.command.ShutdownInfo;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.TransactionInfo;
/////////////////////////////////////////////////////////////////////////
1:             throw new ProtocolException("The transaction was already started: " + stompTx);
/////////////////////////////////////////////////////////////////////////
1:             throw new ProtocolException("Already connected.");
author:jgoodyear
-------------------------------------------------------------------------------
commit:46160c7
/////////////////////////////////////////////////////////////////////////
1:         consumerInfo.setDispatchAsync(true);
author:gtully
-------------------------------------------------------------------------------
commit:57264bf
/////////////////////////////////////////////////////////////////////////
1:         message.beforeMarshall(null);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:12b26b6
/////////////////////////////////////////////////////////////////////////
1:         try(InputStream in = ProtocolConverter.class.getResourceAsStream("/org/apache/activemq/version.txt")) {
1:             if (in != null) {
1:                 try(InputStreamReader isr = new InputStreamReader(in);
1:                     BufferedReader reader = new BufferedReader(isr)) {
1:                     version = reader.readLine();
1:                 }
1:         }catch(Exception e) {
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:53ec665
/////////////////////////////////////////////////////////////////////////
1:                 hbReadInterval = (Long.parseLong(keepAliveOpts[0]));
commit:4e4d072
/////////////////////////////////////////////////////////////////////////
1:             if (this.version.equals(Stomp.V1_0)) {
1:                 throw new ProtocolException("Queue Browser feature only valid for Stomp v1.1+ clients!");
commit:d0ab117
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
1:     private float hbGracePeriodMultiplier = 1.0f;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the hbGracePeriodMultiplier
1:      */
1:     public float getHbGracePeriodMultiplier() {
1:         return hbGracePeriodMultiplier;
1:     }
1: 
1:     /**
1:      * @param hbGracePeriodMultiplier the hbGracePeriodMultiplier to set
1:      */
1:     public void setHbGracePeriodMultiplier(float hbGracePeriodMultiplier) {
1:         this.hbGracePeriodMultiplier = hbGracePeriodMultiplier;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 hbReadInterval = (long) (Long.parseLong(keepAliveOpts[0]) * hbGracePeriodMultiplier);
/////////////////////////////////////////////////////////////////////////
1:                 monitor.setReadCheckTime((long) (hbReadInterval * hbGracePeriodMultiplier));
commit:436f892
/////////////////////////////////////////////////////////////////////////
1:         private final String messageId;
1:         private final StompSubscription subscription;
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("unused")
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
commit:6d08aca
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<String, AckEntry> pedingAcks = new ConcurrentHashMap<String, AckEntry>();
1:     private final IdGenerator ACK_ID_GENERATOR = new IdGenerator();
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static class AckEntry {
1: 
0:         private String messageId;
0:         private StompSubscription subscription;
1: 
1:         public AckEntry(String messageId, StompSubscription subscription) {
1:             this.messageId = messageId;
1:             this.subscription = subscription;
1:         }
1: 
1:         public MessageAck onMessageAck(TransactionId transactionId) {
1:             return subscription.onStompMessageAck(messageId, transactionId);
1:         }
1: 
1:         public MessageAck onMessageNack(TransactionId transactionId) throws ProtocolException {
1:             return subscription.onStompMessageNack(messageId, transactionId);
1:         }
1: 
1:         public String getMessageId() {
1:             return this.messageId;
1:         }
1: 
1:         public StompSubscription getSubscription() {
1:             return this.subscription;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (subscriptionId == null && !this.version.equals(Stomp.V1_2)) {
1:         if (messageId == null && !this.version.equals(Stomp.V1_2)) {
1:         String ackId = headers.get(Stomp.Headers.Ack.ACK_ID);
1:         if (ackId == null && this.version.equals(Stomp.V1_2)) {
1:             throw new ProtocolException("NACK received without an ack header to acknowledge!");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         boolean nacked = false;
1: 
1:         if (ackId != null) {
0:             AckEntry pendingAck = this.pedingAcks.get(ackId);
1:             if (pendingAck != null) {
1:                 messageId = pendingAck.getMessageId();
1:                 MessageAck ack = pendingAck.onMessageNack(activemqTx);
1:                 if (ack != null) {
1:                     sendToActiveMQ(ack, createResponseHandler(command));
1:                     nacked = true;
1:                 }
1:             }
1:         } else if (subscriptionId != null) {
1:                     nacked = true;
1: 
1:         if (!nacked) {
1:             throw new ProtocolException("Unexpected NACK received for message-id [" + messageId + "]");
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (messageId == null && !(this.version.equals(Stomp.V1_2))) {
1:         if (subscriptionId == null && this.version.equals(Stomp.V1_1)) {
1:         String ackId = headers.get(Stomp.Headers.Ack.ACK_ID);
1:         if (ackId == null && this.version.equals(Stomp.V1_2)) {
1:             throw new ProtocolException("ACK received without a ack id for acknowledge!");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (ackId != null) {
1: 
0:             AckEntry pendingAck = this.pedingAcks.get(ackId);
1:             if (pendingAck != null) {
1:                 messageId = pendingAck.getMessageId();
1:                 MessageAck ack = pendingAck.onMessageAck(activemqTx);
1:                 if (ack != null) {
1:                     sendToActiveMQ(ack, createResponseHandler(command));
1:                     acked = true;
1:                 }
1:             }
1: 
1:         } else if (subscriptionId != null) {
/////////////////////////////////////////////////////////////////////////
1:             // STOMP v1.0: acking with just a message id is very bogus since the same message id
/////////////////////////////////////////////////////////////////////////
1:         if (selector != null) {
1:             consumerInfo.setSelector("convert_string_expressions:" + selector);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 String ackId = null;
0:                 if (version.equals(Stomp.V1_2) && sub.getAckMode() != Stomp.Headers.Subscribe.AckModeValues.AUTO) {
1:                     AckEntry pendingAck = new AckEntry(md.getMessage().getMessageId().toString(), sub);
1:                     ackId = this.ACK_ID_GENERATOR.generateId();
1:                     this.pedingAcks.put(ackId, pendingAck);
1:                 }
1:                 try {
1:                     sub.onMessageDispatch(md, ackId);
1:                 } catch (Exception ex) {
1:                     if (ackId != null) {
1:                         this.pedingAcks.remove(ackId);
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
commit:f8f24e8
/////////////////////////////////////////////////////////////////////////
1:         connectionInfo.setTransportContext(command.getTransportContext());
commit:27a74d3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         String clientId = durable;
0:         if (this.version.equals(Stomp.V1_1)) {
1:             clientId = connectionInfo.getClientId();
1:         }
1:             info.setClientId(clientId);
commit:0f11d8c
/////////////////////////////////////////////////////////////////////////
0:         HashSet<String> acceptsVersions = new HashSet<String>(Arrays.asList(accepts.trim().split(Stomp.COMMA)));
/////////////////////////////////////////////////////////////////////////
1:         configureInactivityMonitor(heartBeat.trim());
commit:bd31548
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQDestination actualDest = translator.convertDestination(this, destination, true);
1:         final ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
/////////////////////////////////////////////////////////////////////////
1:         final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:         if (receiptId != null && consumerInfo.getPrefetchSize() > 0) {
1: 
1:             final StompFrame cmd = command;
1:             final int prefetch = consumerInfo.getPrefetchSize();
1: 
1:             // Since dispatch could beat the receipt we set prefetch to zero to start and then
1:             // once we've sent our Receipt we are safe to turn on dispatch if the response isn't
1:             // an error message.
1:             consumerInfo.setPrefetchSize(0);
1: 
1:             final ResponseHandler handler = new ResponseHandler() {
1:                 public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:                     if (response.isException()) {
1:                         // Generally a command can fail.. but that does not invalidate the connection.
1:                         // We report back the failure but we don't close the connection.
1:                         Throwable exception = ((ExceptionResponse)response).getException();
1:                         handleException(exception, cmd);
1:                     } else {
1:                         StompFrame sc = new StompFrame();
1:                         sc.setAction(Stomp.Responses.RECEIPT);
1:                         sc.setHeaders(new HashMap<String, String>(1));
1:                         sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:                         stompTransport.sendToStomp(sc);
1: 
1:                         ConsumerControl control = new ConsumerControl();
1:                         control.setPrefetch(prefetch);
1:                         control.setDestination(actualDest);
1:                         control.setConsumerId(id);
1: 
1:                         sendToActiveMQ(control, null);
1:                     }
1:                 }
1:             };
1: 
1:             sendToActiveMQ(consumerInfo, handler);
1:         } else {
1:             sendToActiveMQ(consumerInfo, createResponseHandler(command));
1:         }
commit:4bba15a
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedReader;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.OutputStreamWriter;
1: import java.io.PrintWriter;
0: import java.util.Arrays;
0: import java.util.Collections;
1: import java.util.HashMap;
0: import java.util.HashSet;
1: import java.util.Iterator;
1: import java.util.Map;
1: import javax.jms.JMSException;
1: 
1: import org.apache.activemq.broker.BrokerContext;
1: import org.apache.activemq.broker.BrokerContextAware;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTempQueue;
0: import org.apache.activemq.command.ActiveMQTempTopic;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.CommandTypes;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.LocalTransactionId;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.command.TransactionInfo;
1: import org.apache.activemq.util.ByteArrayOutputStream;
1: import org.apache.activemq.util.FactoryFinder;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.LongSequenceGenerator;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (actualDest.isQueue() && consumerInfo.getSubscriptionName() != null) {
0:             throw new ProtocolException("Invliad Subscription: cannot durably subscribe to a Queue destination!");
1:         }
1: 
commit:9ff3500
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQDestination createTempDestination(String name, boolean topic) {
1:             if (topic) {
1:                 rc = new ActiveMQTempTopic(connectionId, tempDestinationGenerator.getNextSequenceId());
1:             } else {
1:                 rc = new ActiveMQTempQueue(connectionId, tempDestinationGenerator.getNextSequenceId());
1:             }
commit:f33f32e
/////////////////////////////////////////////////////////////////////////
1:         stompTransport.sendToActiveMQ(command);
/////////////////////////////////////////////////////////////////////////
1:         sendToActiveMQ(message, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:                     sendToActiveMQ(ack, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:                     sendToActiveMQ(ack, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:                     sendToActiveMQ(ack, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:         sendToActiveMQ(tx, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:         sendToActiveMQ(tx, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:         sendToActiveMQ(tx, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:         sendToActiveMQ(consumerInfo, null);
/////////////////////////////////////////////////////////////////////////
1:             sendToActiveMQ(info, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:                 sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:                     sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:         sendToActiveMQ(connectionInfo.createRemoveCommand(), createResponseHandler(command));
1:         sendToActiveMQ(new ShutdownInfo(), createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:             sendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
/////////////////////////////////////////////////////////////////////////
0:             sendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
commit:3b381e7
/////////////////////////////////////////////////////////////////////////
0:         stompTransport.asyncSendToActiveMQ(command);
1:     }
1: 
0:     protected void asyncSendToActiveMQ(Command command, ResponseHandler handler) {
1:         command.setCommandId(generateCommandId());
1:         if (handler != null) {
1:             command.setResponseRequired(true);
1:             resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
1:         }
0:         stompTransport.asyncSendToActiveMQ(command);
/////////////////////////////////////////////////////////////////////////
0:         asyncSendToActiveMQ(message, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:                     asyncSendToActiveMQ(ack, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:                     asyncSendToActiveMQ(ack, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:                     asyncSendToActiveMQ(ack, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:         asyncSendToActiveMQ(tx, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:         asyncSendToActiveMQ(tx, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:         asyncSendToActiveMQ(tx, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:         asyncSendToActiveMQ(consumerInfo, null);
/////////////////////////////////////////////////////////////////////////
0:             asyncSendToActiveMQ(info, createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:                 asyncSendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:                     asyncSendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:         asyncSendToActiveMQ(connectionInfo.createRemoveCommand(), createResponseHandler(command));
0:         asyncSendToActiveMQ(new ShutdownInfo(), createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
0:             asyncSendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
/////////////////////////////////////////////////////////////////////////
0:             asyncSendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
commit:0885c60
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedReader;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.util.Arrays;
0: import java.util.Collections;
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.CommandTypes;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final String BROKER_VERSION;
1:     private static final StompFrame ping = new StompFrame(Stomp.Commands.KEEPALIVE);
1: 
0:     private static final long DEFAULT_OUTBOUND_HEARTBEAT = 100;
0:     private static final long DEFAULT_INBOUND_HEARTBEAT = 1000;
0:     private static final long DEFAULT_INITIAL_HEARTBEAT_DELAY = 1000;
1: 
1:     static {
0:         InputStream in = null;
1:         String version = "5.6.0";
0:         if ((in = ProtocolConverter.class.getResourceAsStream("/org/apache/activemq/version.txt")) != null) {
0:             BufferedReader reader = new BufferedReader(new InputStreamReader(in));
1:             try {
0:                 version = reader.readLine();
0:             } catch(Exception e) {
1:             }
1:         }
1:         BROKER_VERSION = version;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<String, StompSubscription> subscriptions = new ConcurrentHashMap<String, StompSubscription>();
/////////////////////////////////////////////////////////////////////////
1:     private final FrameTranslator frameTranslator = new LegacyFrameTranslator();
1:     private String version = "1.0";
0:     private long hbReadInterval = DEFAULT_INBOUND_HEARTBEAT;
0:     private long hbWriteInterval = DEFAULT_OUTBOUND_HEARTBEAT;
1:     public ProtocolConverter(StompTransport stompTransport, BrokerContext brokerContext) {
/////////////////////////////////////////////////////////////////////////
1:             } else if (action.startsWith(Stomp.Commands.NACK)) {
1:                 onStompNack(command);
/////////////////////////////////////////////////////////////////////////
1:             } else if (action.startsWith(Stomp.Commands.CONNECT) ||
1:                        action.startsWith(Stomp.Commands.STOMP)) {
/////////////////////////////////////////////////////////////////////////
1:             if (e.isFatal()) {
/////////////////////////////////////////////////////////////////////////
1:         headers.put(Stomp.Headers.CONTENT_TYPE, "text/plain");
/////////////////////////////////////////////////////////////////////////
1:         String destination = headers.get(Stomp.Headers.Send.DESTINATION);
1:         if (destination == null) {
1:             throw new ProtocolException("SEND received without a Destination specified!");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1:     protected void onStompNack(StompFrame command) throws ProtocolException {
1: 
1:         checkConnected();
1: 
0:         if (this.version.equals(Stomp.V1_1)) {
1:             throw new ProtocolException("NACK received but connection is in v1.0 mode.");
1:         }
1: 
1:         Map<String, String> headers = command.getHeaders();
1: 
1:         String subscriptionId = headers.get(Stomp.Headers.Ack.SUBSCRIPTION);
0:         if (subscriptionId == null) {
1:             throw new ProtocolException("NACK received without a subscription id for acknowledge!");
1:         }
1: 
1:         String messageId = headers.get(Stomp.Headers.Ack.MESSAGE_ID);
0:         if (messageId == null) {
1:             throw new ProtocolException("NACK received without a message-id to acknowledge!");
1:         }
1: 
1:         TransactionId activemqTx = null;
1:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:         if (stompTx != null) {
1:             activemqTx = transactions.get(stompTx);
1:             if (activemqTx == null) {
1:                 throw new ProtocolException("Invalid transaction id: " + stompTx);
1:             }
1:         }
1: 
1:         if (subscriptionId != null) {
1:             StompSubscription sub = this.subscriptions.get(subscriptionId);
1:             if (sub != null) {
1:                 MessageAck ack = sub.onStompMessageNack(messageId, activemqTx);
1:                 if (ack != null) {
0:                     sendToActiveMQ(ack, createResponseHandler(command));
1:                 } else {
0:                     throw new ProtocolException("Unexpected NACK received for message-id [" + messageId + "]");
1:                 }
1:             }
1:         }
1:         String subscriptionId = headers.get(Stomp.Headers.Ack.SUBSCRIPTION);
0:         if (this.version.equals(Stomp.V1_1) && subscriptionId == null) {
1:             throw new ProtocolException("ACK received without a subscription id for acknowledge!");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (subscriptionId != null) {
1: 
1:             StompSubscription sub = this.subscriptions.get(subscriptionId);
1:             if (sub != null) {
1:                 MessageAck ack = sub.onStompMessageAck(messageId, activemqTx);
1:                 if (ack != null) {
0:                     sendToActiveMQ(ack, createResponseHandler(command));
1:                     acked = true;
1:                 }
1:             }
1: 
1:         } else {
1: 
0:             // TODO: acking with just a message id is very bogus since the same message id
1:             // could have been sent to 2 different subscriptions on the same Stomp connection.
1:             // For example, when 2 subs are created on the same topic.
1: 
1:             for (StompSubscription sub : subscriptionsByConsumerId.values()) {
1:                 MessageAck ack = sub.onStompMessageAck(messageId, activemqTx);
1:                 if (ack != null) {
0:                     sendToActiveMQ(ack, createResponseHandler(command));
1:                     acked = true;
1:                     break;
1:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (StompSubscription sub : subscriptionsByConsumerId.values()) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (StompSubscription sub : subscriptionsByConsumerId.values()) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (this.version.equals(Stomp.V1_1) && subscriptionId == null) {
1:             throw new ProtocolException("SUBSCRIBE received without a subscription id!");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         String browser = headers.get(Stomp.Headers.Subscribe.BROWSER);
1:         if (browser != null && browser.equals(Stomp.TRUE)) {
1: 
0:             if (!this.version.equals(Stomp.V1_1)) {
0:                 throw new ProtocolException("Queue Browser feature only valid for Stomp v1.1 clients!");
1:             }
1: 
1:             consumerInfo.setBrowser(true);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         StompSubscription stompSubscription;
1:         if (!consumerInfo.isBrowser()) {
1:             stompSubscription = new StompSubscription(this, subscriptionId, consumerInfo, headers.get(Stomp.Headers.TRANSFORMATION));
1:         } else {
1:             stompSubscription = new StompQueueBrowserSubscription(this, subscriptionId, consumerInfo, headers.get(Stomp.Headers.TRANSFORMATION));
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // Stomp v1.0 doesn't need to set this header so we avoid an NPE if not set.
0:         if (subscriptionId != null) {
1:             subscriptions.put(subscriptionId, stompSubscription);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (this.version.equals(Stomp.V1_1) && subscriptionId == null) {
1:             throw new ProtocolException("UNSUBSCRIBE received without a subscription id!");
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (subscriptionId != null) {
1: 
1:             StompSubscription sub = this.subscriptions.remove(subscriptionId);
1:             if (sub != null) {
1: 
1:         } else {
1: 
1:             // Unsubscribing using a destination is a bit weird if multiple subscriptions
1:             // are created with the same destination.
1:             for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
1:                 StompSubscription sub = iter.next();
1:                 if (destination != null && destination.equals(sub.getDestination())) {
0:                     sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
1:                     iter.remove();
1:                     return;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:         String heartBeat = headers.get(Stomp.Headers.Connect.HEART_BEAT);
0:         String accepts = headers.get(Stomp.Headers.Connect.ACCEPT_VERSION);
0:         if (accepts == null) {
0:             accepts = Stomp.DEFAULT_VERSION;
1:         }
1:         if (heartBeat == null) {
0:             heartBeat = Stomp.DEFAULT_HEART_BEAT;
1:         }
1: 
0:         HashSet<String> acceptsVersions = new HashSet<String>(Arrays.asList(accepts.split(Stomp.COMMA)));
0:         acceptsVersions.retainAll(Arrays.asList(Stomp.SUPPORTED_PROTOCOL_VERSIONS));
0:         if (acceptsVersions.isEmpty()) {
0:             throw new ProtocolException("Invlid Protocol version, supported versions are: " +
0:                                         Arrays.toString(Stomp.SUPPORTED_PROTOCOL_VERSIONS), true);
1:         } else {
0:             this.version = Collections.max(acceptsVersions);
1:         }
1: 
0:         configureInactivityMonitor(heartBeat);
/////////////////////////////////////////////////////////////////////////
1:                         responseHeaders.put(Stomp.Headers.Connected.VERSION, version);
1:                         responseHeaders.put(Stomp.Headers.Connected.HEART_BEAT,
1:                                             String.format("%d,%d", hbWriteInterval, hbReadInterval));
1:                         responseHeaders.put(Stomp.Headers.Connected.SERVER, "ActiveMQ/"+BROKER_VERSION);
1: 
1: 
0:                         if (version.equals(Stomp.V1_1)) {
1:                             StompWireFormat format = stompTransport.getWireFormat();
1:                             if (format != null) {
0:                                 format.setEncodingEnabled(true);
1:                             }
1:                         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } else if (command.getDataStructureType() == CommandTypes.KEEP_ALIVE_INFO) {
1:             stompTransport.sendToStomp(ping);
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void configureInactivityMonitor(String heartBeatConfig) throws ProtocolException {
1: 
1:         String[] keepAliveOpts = heartBeatConfig.split(Stomp.COMMA);
1: 
1:         if (keepAliveOpts == null || keepAliveOpts.length != 2) {
0:             throw new ProtocolException("Invlid heart-beat header:" + heartBeatConfig, true);
1:         } else {
1: 
1:             try {
0:                 hbReadInterval = Long.parseLong(keepAliveOpts[0]);
1:                 hbWriteInterval = Long.parseLong(keepAliveOpts[1]);
1:             } catch(NumberFormatException e) {
0:                 throw new ProtocolException("Invlid heart-beat header:" + heartBeatConfig, true);
1:             }
1: 
0:             if (hbReadInterval > 0) {
0:                 hbReadInterval = Math.max(DEFAULT_INBOUND_HEARTBEAT, hbReadInterval);
0:                 hbReadInterval += Math.min(hbReadInterval, 5000);
1:             }
1: 
0:             if (hbWriteInterval > 0) {
0:                 hbWriteInterval = Math.max(DEFAULT_OUTBOUND_HEARTBEAT, hbWriteInterval);
1:             }
1: 
1:             try {
1: 
1:                 StompInactivityMonitor monitor = this.stompTransport.getInactivityMonitor();
1: 
0:                 monitor.setReadCheckTime(hbReadInterval);
0:                 monitor.setInitialDelayTime(DEFAULT_INITIAL_HEARTBEAT_DELAY);
1:                 monitor.setWriteCheckTime(hbWriteInterval);
1: 
1:                 monitor.startMonitoring();
1: 
1:             } catch(Exception ex) {
1:                 hbReadInterval = 0;
1:                 hbWriteInterval = 0;
1:             }
1: 
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Stomp Connect heartbeat conf RW[" + hbReadInterval + "," + hbWriteInterval + "]");
1:             }
1:         }
1:     }
commit:5ebfbf0
/////////////////////////////////////////////////////////////////////////
1: 
1:         FrameTranslator translator = frameTranslator;
1:         try {
1:             if (header != null) {
0:                 translator = (FrameTranslator) FRAME_TRANSLATOR_FINDER
0:                         .newInstance(header);
0:                 if (translator instanceof ApplicationContextAware) {
0:                     ((ApplicationContextAware)translator).setApplicationContext(applicationContext);
1:                 }
1:             }
1:         } catch (Exception ignore) {
1:             // if anything goes wrong use the default translator
1:         }
1: 
1:         return translator;
1:     }
0:      * Convert a stomp command
1:      *
1:      * @param command
1:      */
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:             if (receiptId != null) {
1:                 headers.put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 sub.onStompAbort(activemqTx);
1:                 throw new ProtocolException("Transaction abort failed", false, e);
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (actualDest == null) {
0:             throw new ProtocolException("Invalid Destination.");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         String durable = command.getHeaders().get("activemq.subscriptionName");
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:         if (ignoreTransformation == true) {
1:             return frameTranslator.convertMessage(this, message);
1:         } else {
0:             return findTranslator(message.getStringProperty(Stomp.Headers.TRANSFORMATION)).convertMessage(this, message);
1:         }
0:     public ActiveMQDestination createTempQueue(String name) {
1:         }
1:     }
0:     public ActiveMQDestination createTempTopic(String name) {
1:         }
1:     }
1:     public String getCreatedTempDestinationName(ActiveMQDestination destination) {
1:         return tempDestinationAmqToStompMap.get(destination.getQualifiedName());
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:1fdcf59
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.advisory.AdvisorySupport;
/////////////////////////////////////////////////////////////////////////
0:         return findTranslator(header, null);
1:     }
1: 
0:     protected FrameTranslator findTranslator(String header, ActiveMQDestination destination) {
1:             } else {
0:                 if (destination != null && AdvisorySupport.isAdvisoryTopic(destination)) {
1:                     translator = new JmsFrameTranslator();
1:         if (translator instanceof BrokerContextAware) {
1:             ((BrokerContextAware)translator).setBrokerContext(brokerContext);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:             return findTranslator(message.getStringProperty(Stomp.Headers.TRANSFORMATION), message.getDestination()).convertMessage(this, message);
commit:cc95295
/////////////////////////////////////////////////////////////////////////
1:         if (connected.get()) {
0:             sendToActiveMQ(connectionInfo.createRemoveCommand(), createResponseHandler(command));
0:             sendToActiveMQ(new ShutdownInfo(), createResponseHandler(command));
1:             connected.set(false);
1:         }
commit:a54fa4b
/////////////////////////////////////////////////////////////////////////
1:         this.version = StompCodec.detectVersion(headers);
/////////////////////////////////////////////////////////////////////////
0:                         StompWireFormat format = stompTransport.getWireFormat();
0:                         if (format != null) {
1:                             format.setStompVersion(version);
commit:e3a1fc9
/////////////////////////////////////////////////////////////////////////
1:         if (this.version.equals(Stomp.V1_0)) {
commit:1c26408
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
0: import org.apache.activemq.util.*;
0: import javax.jms.JMSException;
0: import java.io.*;
0: import java.util.*;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination actualDest = translator.convertDestination(this, destination, true);
/////////////////////////////////////////////////////////////////////////
0:         consumerInfo.setDestination(translator.convertDestination(this, destination, true));
/////////////////////////////////////////////////////////////////////////
1:             destination = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION)).convertDestination(this, (String)o, true);
commit:603b215
/////////////////////////////////////////////////////////////////////////
1: 
0:         sendToActiveMQ(consumerInfo, null);
0:         sendReceipt(command);
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void sendReceipt(StompFrame command) {
1:         final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:         if (receiptId != null) {
1:             StompFrame sc = new StompFrame();
1:             sc.setAction(Stomp.Responses.RECEIPT);
1:             sc.setHeaders(new HashMap<String, String>(1));
1:             sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:             try {
1:                 sendToStomp(sc);
1:             } catch (IOException e) {
0:                 LOG.warn("Could not send a receipt for " + command, e);
1:             }
1:         }
1:     }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ProtocolConverter.class);
commit:8ed8dd4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(ProtocolConverter.class);
1:     
/////////////////////////////////////////////////////////////////////////
0:         LOG.warn("Exception occured processing: \n" + command, exception);
commit:11705e7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerContext;
0: import org.apache.activemq.broker.BrokerContextAware;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final BrokerContext brokerContext;
0:     public ProtocolConverter(StompTransport stompTransport, FrameTranslator translator, BrokerContext brokerContext) {
1:         this.brokerContext = brokerContext;
/////////////////////////////////////////////////////////////////////////
0:                 if (translator instanceof BrokerContextAware) {
0:                     ((BrokerContextAware)translator).setBrokerContext(brokerContext);
commit:ceed011
/////////////////////////////////////////////////////////////////////////
1:     private final StompTransport stompTransport;
/////////////////////////////////////////////////////////////////////////
0:     public ProtocolConverter(StompTransport stompTransport, FrameTranslator translator, ApplicationContext applicationContext) {
1:         this.stompTransport = stompTransport;
/////////////////////////////////////////////////////////////////////////
1:                         stompTransport.sendToStomp(sc);
/////////////////////////////////////////////////////////////////////////
0:         stompTransport.sendToActiveMQ(command);
1:         stompTransport.sendToStomp(command);
/////////////////////////////////////////////////////////////////////////
1:                getStompTransport().onException(e);
/////////////////////////////////////////////////////////////////////////
0:         connectionInfo.setTransportContext(stompTransport.getPeerCertificates());
/////////////////////////////////////////////////////////////////////////
1:                     getStompTransport().onException(IOExceptionSupport.create(exception));
/////////////////////////////////////////////////////////////////////////
1:                             getStompTransport().onException(IOExceptionSupport.create(exception));
/////////////////////////////////////////////////////////////////////////
1:     public StompTransport getStompTransport() {
1:         return stompTransport;
commit:b0f24f3
/////////////////////////////////////////////////////////////////////////
0:             sub.onStompAbort(activemqTx);
commit:690b7bc
/////////////////////////////////////////////////////////////////////////
1:     public void onStompCommand(StompFrame command) throws IOException, JMSException {
/////////////////////////////////////////////////////////////////////////
1:     ConnectionInfo connectionInfo = new ConnectionInfo();
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         sendToActiveMQ(connectionInfo.createRemoveCommand(), createResponseHandler(command));
/////////////////////////////////////////////////////////////////////////
1:     public void onActiveMQCommand(Command command) throws IOException, JMSException {
commit:f6ebeec
/////////////////////////////////////////////////////////////////////////
0:             MessageAck ack = sub.onStompMessageAck(messageId, activemqTx);
/////////////////////////////////////////////////////////////////////////
1:         
0:         for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
0:             StompSubscription sub = iter.next();
1:             sub.onStompCommit(activemqTx);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
0:             StompSubscription sub = iter.next();
1:             try {
0:             	sub.onStompAbort(activemqTx);
1:             } catch (Exception e) {
0:             	throw new ProtocolException("Transaction abort failed", false, e);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
commit:7aec12e
/////////////////////////////////////////////////////////////////////////
1:         headers.remove("transaction");
author:Gary Tully
-------------------------------------------------------------------------------
commit:bc45bf8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
/////////////////////////////////////////////////////////////////////////
1:             throw new ProtocolException("Invalid 'null' Destination.");
1:         consumerInfo.setPrefetchSize(actualDest.isQueue() ?
1:                 ActiveMQPrefetchPolicy.DEFAULT_QUEUE_PREFETCH :
1:                 headers.containsKey("activemq.subscriptionName") ?
1:                         ActiveMQPrefetchPolicy.DEFAULT_DURABLE_TOPIC_PREFETCH : ActiveMQPrefetchPolicy.DEFAULT_TOPIC_PREFETCH);
/////////////////////////////////////////////////////////////////////////
1:             consumerInfo.setPrefetchSize(ActiveMQPrefetchPolicy.DEFAULT_QUEUE_BROWSER_PREFETCH);
commit:93a379f
/////////////////////////////////////////////////////////////////////////
0:             throw new ProtocolException("Invalid Protocol version[" + accepts +"], supported versions are: " +
commit:33edc99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private long hbReadInterval;
1:     private long hbWriteInterval;
1:     private String defaultHeartBeat = Stomp.DEFAULT_HEART_BEAT;
/////////////////////////////////////////////////////////////////////////
1:             heartBeat = defaultHeartBeat;
/////////////////////////////////////////////////////////////////////////
1:     public String getDefaultHeartBeat() {
1:         return defaultHeartBeat;
1:     }
1: 
1:     public void setDefaultHeartBeat(String defaultHeartBeat) {
1:         this.defaultHeartBeat = defaultHeartBeat;
1:     }
1: 
1:             throw new ProtocolException("Invalid heart-beat header:" + heartBeatConfig, true);
1:                 throw new ProtocolException("Invalid heart-beat header:" + heartBeatConfig, true);
/////////////////////////////////////////////////////////////////////////
1:                 monitor.setInitialDelayTime(Math.min(hbReadInterval, hbWriteInterval));
commit:ba0c1e5
/////////////////////////////////////////////////////////////////////////
0:         // dispatch can beat the receipt so send it early
0:         sendToActiveMQ(consumerInfo, null);
commit:78f85ed
/////////////////////////////////////////////////////////////////////////
0:         LOG.warn("Exception occurred processing: \n" + command + ": " + exception.toString());
1:         if (LOG.isDebugEnabled()) {
1:             LOG.debug("Exception detail", exception);
1:         }
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:2f25870
/////////////////////////////////////////////////////////////////////////
0:         if( selector!=null ) {
0:             consumerInfo.setSelector("convert_string_expressions:"+selector);
1:         }
commit:3910056
/////////////////////////////////////////////////////////////////////////
0: import org.springframework.context.ApplicationContext;
0: import org.springframework.context.ApplicationContextAware;
/////////////////////////////////////////////////////////////////////////
0:     private final ApplicationContext applicationContext;
0:     public ProtocolConverter(StompTransportFilter stompTransportFilter, FrameTranslator translator, ApplicationContext applicationContext) {
0:         this.applicationContext = applicationContext;
/////////////////////////////////////////////////////////////////////////
0: 				if (translator instanceof ApplicationContextAware) {
0: 					((ApplicationContextAware)translator).setApplicationContext(applicationContext);
1: 				}
/////////////////////////////////////////////////////////////////////////
1:     public StompFrame convertMessage(ActiveMQMessage message, boolean ignoreTransformation) throws IOException, JMSException {
0:     	if (ignoreTransformation == true) {
0:     		return frameTranslator.convertMessage(this, message);
1:     	} else {
0:     		return findTranslator(message.getStringProperty(Stomp.Headers.TRANSFORMATION)).convertMessage(this, message);
1:     	}
commit:2b5608f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.FactoryFinder;
/////////////////////////////////////////////////////////////////////////
1:     private final FactoryFinder FRAME_TRANSLATOR_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/transport/frametranslator/");
/////////////////////////////////////////////////////////////////////////
1:     
1:     protected FrameTranslator findTranslator(String header) {
0: 		FrameTranslator translator = frameTranslator;
0: 		try {
0: 			if (header != null) {
0: 				translator = (FrameTranslator) FRAME_TRANSLATOR_FINDER
0: 						.newInstance(header);
1: 			}
0: 		} catch (Exception ignore) {
0: 			// if anything goes wrong use the default translator
1: 		}
1: 		
0: 		return translator;
1: 	}
0: 	 * Convert a stomp command
1: 	 * 
1: 	 * @param command
1: 	 */
/////////////////////////////////////////////////////////////////////////
1:         FrameTranslator translator = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION));
0:         ActiveMQDestination actualDest = translator.convertDestination(this, destination);
/////////////////////////////////////////////////////////////////////////
0:         consumerInfo.setDestination(translator.convertDestination(this, destination));
0:         StompSubscription stompSubscription = new StompSubscription(this, subscriptionId, consumerInfo, headers.get(Stomp.Headers.TRANSFORMATION));
/////////////////////////////////////////////////////////////////////////
0:             destination = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION)).convertDestination(this, (String)o);
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQMessage msg = findTranslator(command.getHeaders().get(Stomp.Headers.TRANSFORMATION)).convertFrame(this, command);
0:         return findTranslator(message.getStringProperty(Stomp.Headers.TRANSFORMATION)).convertMessage(this, message);
commit:471ea33
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ExceptionResponse;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IOExceptionSupport;
/////////////////////////////////////////////////////////////////////////
1:     protected ResponseHandler createResponseHandler(final StompFrame command) {
1:                     if (response.isException()) {
1:                         // Generally a command can fail.. but that does not invalidate the connection.
1:                         // We report back the failure but we don't close the connection.
1:                         Throwable exception = ((ExceptionResponse)response).getException();
1:                         handleException(exception, command);
1:                     } else {
1:                         StompFrame sc = new StompFrame();
1:                         sc.setAction(Stomp.Responses.RECEIPT);
1:                         sc.setHeaders(new HashMap<String, String>(1));
1:                         sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
0:                         transportFilter.sendToStomp(sc);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:             handleException(e, command);
1:             // Some protocol errors can cause the connection to get closed.
0:             if( e.isFatal() ) {
0:                getTransportFilter().onException(e);
1:     
1:     protected void handleException(Throwable exception, StompFrame command) throws IOException {
1:         // Let the stomp client know about any protocol errors.
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         PrintWriter stream = new PrintWriter(new OutputStreamWriter(baos, "UTF-8"));
1:         exception.printStackTrace(stream);
1:         stream.close();
1: 
0:         HashMap<String, String> headers = new HashMap<String, String>();
1:         headers.put(Stomp.Headers.Error.MESSAGE, exception.getMessage());
1: 
0:         if (command != null) {
1:         	final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
1:         	if (receiptId != null) {
0:         		headers.put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
1:         	}
1:         }
1: 
1:         StompFrame errorMessage = new StompFrame(Stomp.Responses.ERROR, headers, baos.toByteArray());
1:         sendToStomp(errorMessage);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     protected void onStompConnect(final StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
1:                 if (response.isException()) {
1:                     // If the connection attempt fails we close the socket.
1:                     Throwable exception = ((ExceptionResponse)response).getException();
1:                     handleException(exception, command);
0:                     getTransportFilter().onException(IOExceptionSupport.create(exception));
1:                     return;
1:                 }
1: 
1:                         
1:                         if (response.isException()) {
1:                             // If the connection attempt fails we close the socket.
1:                             Throwable exception = ((ExceptionResponse)response).getException();
1:                             handleException(exception, command);
0:                             getTransportFilter().onException(IOExceptionSupport.create(exception));
1:                         }
1:                         
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 // Pass down any unexpected errors. Should this close the connection?
1:                 if (response.isException()) {
1:                     Throwable exception = ((ExceptionResponse)response).getException();
1:                     handleException(exception, null);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
1:             // Pass down any unexpected async errors. Should this close the connection?
1:             Throwable exception = ((ConnectionError)command).getException();
1:             handleException(exception, null);
commit:04a6379
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Destination;
0: import org.apache.activemq.command.ActiveMQTempQueue;
0: import org.apache.activemq.command.ActiveMQTempTopic;
0: import org.apache.activemq.command.DestinationInfo;
/////////////////////////////////////////////////////////////////////////
1:     private final LongSequenceGenerator tempDestinationGenerator = new LongSequenceGenerator();
0:     private final ConcurrentHashMap<String, ActiveMQDestination> tempDestinations = new ConcurrentHashMap<String, ActiveMQDestination>();
0:     private final ConcurrentHashMap<String, String> tempDestinationAmqToStompMap = new ConcurrentHashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination actualDest = frameTranslator.convertDestination(this, destination);
/////////////////////////////////////////////////////////////////////////
0:         consumerInfo.setDestination(frameTranslator.convertDestination(this, destination));
/////////////////////////////////////////////////////////////////////////
0:             destination = frameTranslator.convertDestination(this, (String)o);
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQMessage msg = frameTranslator.convertFrame(this, command);
0:         return frameTranslator.convertMessage(this, message);
1: 
0: 	public ActiveMQDestination createTempQueue(String name) {
1:         ActiveMQDestination rc = tempDestinations.get(name);
1:         if( rc == null ) {
0:             rc = new ActiveMQTempQueue(connectionId, tempDestinationGenerator.getNextSequenceId());
0:             sendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
1:             tempDestinations.put(name, rc);
1:         }        
1:         return rc;
1: 	}
1: 
0: 	public ActiveMQDestination createTempTopic(String name) {
1:         ActiveMQDestination rc = tempDestinations.get(name);
1:         if( rc == null ) {
0:             rc = new ActiveMQTempTopic(connectionId, tempDestinationGenerator.getNextSequenceId());
0:             sendToActiveMQ(new DestinationInfo(connectionId, DestinationInfo.ADD_OPERATION_TYPE, rc), null);
1:             tempDestinations.put(name, rc);
1:             tempDestinationAmqToStompMap.put(rc.getQualifiedName(), name);
1:         }        
1:         return rc;
1: 	}
1: 
0: 	public String getCreatedTempDestinationName(ActiveMQDestination destination) {
0: 		return tempDestinationAmqToStompMap.get(destination.getQualifiedName());
1: 	}
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     private final ConcurrentHashMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
0:     private final ConcurrentHashMap<ConsumerId, StompSubscription> subscriptionsByConsumerId = new ConcurrentHashMap<ConsumerId, StompSubscription>();
0:     private final Map<String, LocalTransactionId> transactions = new ConcurrentHashMap<String, LocalTransactionId>();
/////////////////////////////////////////////////////////////////////////
0:         final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
0:                     sc.setHeaders(new HashMap<String, String>(1));
/////////////////////////////////////////////////////////////////////////
0:             HashMap<String, String> headers = new HashMap<String, String>();
0:             final String receiptId = command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = command.getHeaders();
1:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
/////////////////////////////////////////////////////////////////////////
1:             TransactionId activemqTx = transactions.get(stompTx);
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = command.getHeaders();
1:         String messageId = headers.get(Stomp.Headers.Ack.MESSAGE_ID);
1:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:             activemqTx = transactions.get(stompTx);
0:         for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
0:             StompSubscription sub = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = command.getHeaders();
1:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = command.getHeaders();
1:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:         TransactionId activemqTx = transactions.remove(stompTx);
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = command.getHeaders();
1:         String stompTx = headers.get(Stomp.Headers.TRANSACTION);
1:         TransactionId activemqTx = transactions.remove(stompTx);
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = command.getHeaders();
1:         String subscriptionId = headers.get(Stomp.Headers.Subscribe.ID);
1:         String destination = headers.get(Stomp.Headers.Subscribe.DESTINATION);
/////////////////////////////////////////////////////////////////////////
1:         String selector = headers.remove(Stomp.Headers.Subscribe.SELECTOR);
/////////////////////////////////////////////////////////////////////////
1:         String ackMode = headers.get(Stomp.Headers.Subscribe.ACK_MODE);
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> headers = command.getHeaders();
/////////////////////////////////////////////////////////////////////////
1:         String subscriptionId = headers.get(Stomp.Headers.Unsubscribe.ID);
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<StompSubscription> iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
0:             StompSubscription sub = iter.next();
/////////////////////////////////////////////////////////////////////////
1:         final Map<String, String> headers = command.getHeaders();
1:         String login = headers.get(Stomp.Headers.Connect.LOGIN);
1:         String passcode = headers.get(Stomp.Headers.Connect.PASSCODE);
1:         String clientId = headers.get(Stomp.Headers.Connect.CLIENT_ID);
/////////////////////////////////////////////////////////////////////////
0:                         HashMap<String, String> responseHeaders = new HashMap<String, String>();
1:                         String requestId = headers.get(Stomp.Headers.Connect.REQUEST_ID);
1:                             requestId = headers.get(Stomp.Headers.RECEIPT_REQUESTED);
/////////////////////////////////////////////////////////////////////////
1:             ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
/////////////////////////////////////////////////////////////////////////
1:             StompSubscription sub = subscriptionsByConsumerId.get(md.getConsumerId());
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
1: 
1:     private final ConnectionId connectionId = new ConnectionId(CONNECTION_ID_GENERATOR.generateId());
/////////////////////////////////////////////////////////////////////////
1:             if (action.startsWith(Stomp.Commands.SEND)) {
1:             } else if (action.startsWith(Stomp.Commands.ACK)) {
1:             } else if (action.startsWith(Stomp.Commands.BEGIN)) {
1:             } else if (action.startsWith(Stomp.Commands.COMMIT)) {
1:             } else if (action.startsWith(Stomp.Commands.ABORT)) {
0:             } else if (action.startsWith(Stomp.Commands.SUBSCRIBE)) {
0:             } else if (action.startsWith(Stomp.Commands.UNSUBSCRIBE)) {
0:             } else if (action.startsWith(Stomp.Commands.CONNECT)) {
1:             } else if (action.startsWith(Stomp.Commands.DISCONNECT)) {
0:             } else {
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (e.isFatal()) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (activemqTx == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if (messageId == null) {
1:         }
1:             if (activemqTx == null) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (!acked) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination actualDest = frameTranslator.convertDestination(destination);
/////////////////////////////////////////////////////////////////////////
1:         stompSubscription.setDestination(actualDest);
/////////////////////////////////////////////////////////////////////////
1:         if (o != null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (clientId != null) {
0:         } else {
1:         }
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final StompTransportFilter transportFilter;
1:     private final Object commnadIdMutex = new Object();
1:     private int lastCommandId;
0:     public ProtocolConverter(StompTransportFilter stompTransportFilter, FrameTranslator translator) {
1:         synchronized (commnadIdMutex) {
1:             return lastCommandId++;
1:         }
0:     protected ResponseHandler createResponseHandler(StompFrame command) {
0:         final String receiptId = (String)command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
0:         if (receiptId != null) {
1:             return new ResponseHandler() {
1:                 public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:                     StompFrame sc = new StompFrame();
0:                     sc.setAction(Stomp.Responses.RECEIPT);
0:                     sc.setHeaders(new HashMap(1));
0:                     sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
0:                     transportFilter.sendToStomp(sc);
1:                 }
1:             };
1:         }
1:         return null;
1:     protected void sendToActiveMQ(Command command, ResponseHandler handler) {
0:         command.setCommandId(generateCommandId());
0:         if (handler != null) {
0:             command.setResponseRequired(true);
0:             resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
1:         }
0:         transportFilter.sendToActiveMQ(command);
1:     }
1:     protected void sendToStomp(StompFrame command) throws IOException {
0:         transportFilter.sendToStomp(command);
1:     }
1:     /**
1:      * 
0:     public void onStompCommad(StompFrame command) throws IOException, JMSException {
0:         try {
1:             if (command.getClass() == StompFrameError.class) {
1:                 throw ((StompFrameError)command).getException();
1:             }
1:             String action = command.getAction();
0:             if (action.startsWith(Stomp.Commands.SEND))
1:                 onStompSend(command);
0:             else if (action.startsWith(Stomp.Commands.ACK))
1:                 onStompAck(command);
0:             else if (action.startsWith(Stomp.Commands.BEGIN))
1:                 onStompBegin(command);
0:             else if (action.startsWith(Stomp.Commands.COMMIT))
1:                 onStompCommit(command);
0:             else if (action.startsWith(Stomp.Commands.ABORT))
1:                 onStompAbort(command);
0:             else if (action.startsWith(Stomp.Commands.SUBSCRIBE))
1:                 onStompSubscribe(command);
0:             else if (action.startsWith(Stomp.Commands.UNSUBSCRIBE))
1:                 onStompUnsubscribe(command);
0:             else if (action.startsWith(Stomp.Commands.CONNECT))
1:                 onStompConnect(command);
0:             else if (action.startsWith(Stomp.Commands.DISCONNECT))
1:                 onStompDisconnect(command);
0:             else
0:                 throw new ProtocolException("Unknown STOMP action: " + action);
0:             // Let the stomp client know about any protocol errors.
0:             ByteArrayOutputStream baos = new ByteArrayOutputStream();
0:             PrintWriter stream = new PrintWriter(new OutputStreamWriter(baos, "UTF-8"));
0:             e.printStackTrace(stream);
0:             stream.close();
0:             HashMap headers = new HashMap();
0:             headers.put(Stomp.Headers.Error.MESSAGE, e.getMessage());
0:             final String receiptId = (String)command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
0:             if (receiptId != null) {
0:                 headers.put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
0:             StompFrame errorMessage = new StompFrame(Stomp.Responses.ERROR, headers, baos.toByteArray());
0:             sendToStomp(errorMessage);
0:             if (e.isFatal())
0:                 getTransportFilter().onException(e);
1:     }
1:     protected void onStompSend(StompFrame command) throws IOException, JMSException {
1:         checkConnected();
0:         Map headers = command.getHeaders();
0:         String stompTx = (String)headers.get(Stomp.Headers.TRANSACTION);
/////////////////////////////////////////////////////////////////////////
1:         if (stompTx != null) {
0:             TransactionId activemqTx = (TransactionId)transactions.get(stompTx);
1:                 throw new ProtocolException("Invalid transaction id: " + stompTx);
0:         sendToActiveMQ(message, createResponseHandler(command));
1:     }
1:         checkConnected();
0:         // TODO: acking with just a message id is very bogus
0:         // since the same message id could have been sent to 2 different
0:         // subscriptions
0:         // on the same stomp connection. For example, when 2 subs are created on
0:         // the same topic.
0:         Map headers = command.getHeaders();
0:         String messageId = (String)headers.get(Stomp.Headers.Ack.MESSAGE_ID);
1:         TransactionId activemqTx = null;
0:         String stompTx = (String)headers.get(Stomp.Headers.TRANSACTION);
1:         if (stompTx != null) {
0:             activemqTx = (TransactionId)transactions.get(stompTx);
1:                 throw new ProtocolException("Invalid transaction id: " + stompTx);
1:         boolean acked = false;
0:             StompSubscription sub = (StompSubscription)iter.next();
0:             MessageAck ack = sub.onStompMessageAck(messageId);
0:             if (ack != null) {
0:                 ack.setTransactionId(activemqTx);
0:                 sendToActiveMQ(ack, createResponseHandler(command));
0:                 acked = true;
0:                 break;
1:             }
1:         }
0:         if (!acked)
1:             throw new ProtocolException("Unexpected ACK received for message-id [" + messageId + "]");
1:     }
1:     protected void onStompBegin(StompFrame command) throws ProtocolException {
1:         checkConnected();
0:         Map headers = command.getHeaders();
/////////////////////////////////////////////////////////////////////////
1:         if (transactions.get(stompTx) != null) {
0:             throw new ProtocolException("The transaction was allready started: " + stompTx);
/////////////////////////////////////////////////////////////////////////
0:         sendToActiveMQ(tx, createResponseHandler(command));
1:     }
1:     protected void onStompCommit(StompFrame command) throws ProtocolException {
1:         checkConnected();
0:         Map headers = command.getHeaders();
0:         String stompTx = (String)headers.get(Stomp.Headers.TRANSACTION);
1:         if (stompTx == null) {
0:         TransactionId activemqTx = (TransactionId)transactions.remove(stompTx);
1:             throw new ProtocolException("Invalid transaction id: " + stompTx);
/////////////////////////////////////////////////////////////////////////
0:         sendToActiveMQ(tx, createResponseHandler(command));
1:     }
1:     protected void onStompAbort(StompFrame command) throws ProtocolException {
1:         checkConnected();
0:         Map headers = command.getHeaders();
0:         String stompTx = (String)headers.get(Stomp.Headers.TRANSACTION);
1:         if (stompTx == null) {
0:         TransactionId activemqTx = (TransactionId)transactions.remove(stompTx);
1:             throw new ProtocolException("Invalid transaction id: " + stompTx);
/////////////////////////////////////////////////////////////////////////
0:         sendToActiveMQ(tx, createResponseHandler(command));
1:     }
1:     protected void onStompSubscribe(StompFrame command) throws ProtocolException {
1:         checkConnected();
0:         Map headers = command.getHeaders();
/////////////////////////////////////////////////////////////////////////
0:         String selector = (String)headers.remove(Stomp.Headers.Subscribe.SELECTOR);
/////////////////////////////////////////////////////////////////////////
0:         sendToActiveMQ(consumerInfo, createResponseHandler(command));
1:     }
1:     protected void onStompUnsubscribe(StompFrame command) throws ProtocolException {
1:         checkConnected();
0:         Map headers = command.getHeaders();
1:         ActiveMQDestination destination = null;
0:         if (o != null)
0:             destination = frameTranslator.convertDestination((String)o);
1:         if (subscriptionId == null && destination == null) {
0:         // TODO: Unsubscribing using a destination is a bit wierd if multiple
0:         // subscriptions
0:         // are created with the same destination. Perhaps this should be
0:         // removed.
0:             StompSubscription sub = (StompSubscription)iter.next();
0:             if ((subscriptionId != null && subscriptionId.equals(sub.getSubscriptionId())) || (destination != null && destination.equals(sub.getDestination()))) {
0:                 sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
0:                 iter.remove();
1:             }
1:         }
1:     }
0:     protected void onStompConnect(StompFrame command) throws ProtocolException {
1:         if (connected.get()) {
0:             throw new ProtocolException("Allready connected.");
1:         }
0:         final Map headers = command.getHeaders();
/////////////////////////////////////////////////////////////////////////
0:         if (clientId != null)
1:             connectionInfo.setClientId("" + connectionInfo.getConnectionId().toString());
1:         sendToActiveMQ(connectionInfo, new ResponseHandler() {
1:             public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:                 final SessionInfo sessionInfo = new SessionInfo(sessionId);
1:                 sendToActiveMQ(sessionInfo, null);
1:                 final ProducerInfo producerInfo = new ProducerInfo(producerId);
1:                 sendToActiveMQ(producerInfo, new ResponseHandler() {
1:                     public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1:                         connected.set(true);
0:                         HashMap responseHeaders = new HashMap();
1:                         responseHeaders.put(Stomp.Headers.Connected.SESSION, connectionInfo.getClientId());
0:                         String requestId = (String)headers.get(Stomp.Headers.Connect.REQUEST_ID);
0:                             requestId = (String)headers.get(Stomp.Headers.RECEIPT_REQUESTED);
1:                         if (requestId != null) {
1:                             responseHeaders.put(Stomp.Headers.Connected.RESPONSE_ID, requestId);
1:                         }
0:                         StompFrame sc = new StompFrame();
1:                         sc.setAction(Stomp.Responses.CONNECTED);
1:                         sc.setHeaders(responseHeaders);
1:                         sendToStomp(sc);
1:                     }
1:                 });
1:             }
1:         });
1:     }
1:     protected void onStompDisconnect(StompFrame command) throws ProtocolException {
0:         checkConnected();
0:         sendToActiveMQ(new ShutdownInfo(), createResponseHandler(command));
0:         connected.set(false);
1:     }
1:     protected void checkConnected() throws ProtocolException {
1:         if (!connected.get()) {
1:             throw new ProtocolException("Not connected.");
1:         }
1:     }
1:     /**
0:      * 
0:     public void onActiveMQCommad(Command command) throws IOException, JMSException {
1:         if (command.isResponse()) {
1:             Response response = (Response)command;
0:             ResponseHandler rh = (ResponseHandler)resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
1:             if (rh != null) {
1:                 rh.onResponse(this, response);
1:             }
1:         } else if (command.isMessageDispatch()) {
1:             MessageDispatch md = (MessageDispatch)command;
0:             StompSubscription sub = (StompSubscription)subscriptionsByConsumerId.get(md.getConsumerId());
1:             if (sub != null) {
0:                 sub.onMessageDispatch(md);
1:     }
1:     public ActiveMQMessage convertMessage(StompFrame command) throws IOException, JMSException {
0:     public StompFrame convertMessage(ActiveMQMessage message) throws IOException, JMSException {
0:         return frameTranslator.convertMessage(message);
0:     public StompTransportFilter getTransportFilter() {
0:         return transportFilter;
1:     }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ByteArrayOutputStream;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:98b61e4
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.transport.stomp;
commit:1f6aa57
/////////////////////////////////////////////////////////////////////////
commit:be742f2
/////////////////////////////////////////////////////////////////////////
0: 	                sc.setAction(Stomp.Responses.RECEIPT);
0: 	                sc.setHeaders(new HashMap(1));
commit:530884a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected ResponseHandler createResponseHandler(StompFrame command){
0: 	                StompFrame sc = new StompFrame();
/////////////////////////////////////////////////////////////////////////
0: 	protected void sendToStomp(StompFrame command) throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 	public void onStompCommad( StompFrame command ) throws IOException, JMSException {
0: 			if( command.getClass() == StompFrameError.class ) {
0: 				throw ((StompFrameError)command).getException();
1: 			}
1: 			
/////////////////////////////////////////////////////////////////////////
0:         	StompFrame errorMessage = new StompFrame(Stomp.Responses.ERROR,headers,baos.toByteArray());
0: 			if( e.isFatal() )
0: 				getTransportFilter().onException(e);
0: 	protected void onStompSend(StompFrame command) throws IOException, JMSException {
/////////////////////////////////////////////////////////////////////////
1:     protected void onStompAck(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	protected void onStompBegin(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	protected void onStompCommit(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	protected void onStompAbort(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	protected void onStompSubscribe(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	protected void onStompUnsubscribe(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	protected void onStompConnect(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	                    StompFrame sc = new StompFrame();
/////////////////////////////////////////////////////////////////////////
0: 	protected void onStompDisconnect(StompFrame command) throws ProtocolException {
/////////////////////////////////////////////////////////////////////////
0: 	public  ActiveMQMessage convertMessage(StompFrame command) throws IOException, JMSException {
/////////////////////////////////////////////////////////////////////////
0: 				throw new ProtocolException("Text could not bet set: "+e, false, e);
/////////////////////////////////////////////////////////////////////////
0: 	public StompFrame convertMessage(ActiveMQMessage message) throws IOException, JMSException {
0: 		StompFrame command = new StompFrame();
/////////////////////////////////////////////////////////////////////////
commit:dc98d96
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.activemq.transport.stomp2;
1: 
0: import java.io.IOException;
0: import java.io.OutputStreamWriter;
0: import java.io.PrintWriter;
0: import java.net.ProtocolException;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.Map;
1: 
0: import javax.jms.Destination;
0: import javax.jms.JMSException;
1: 
0: import org.apache.activeio.util.ByteArrayOutputStream;
0: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.LocalTransactionId;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.command.TransactionInfo;
0: import org.apache.activemq.transport.stomp.Stomp;
0: import org.apache.activemq.util.IdGenerator;
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.activemq.util.LongSequenceGenerator;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
1: 
1: /**
0:  * 
1:  * @author <a href="http://hiramchirino.com">chirino</a> 
1:  */
1: public class ProtocolConverter {
1: 	
0:     private static final IdGenerator connectionIdGenerator = new IdGenerator();
0:     private final ConnectionId connectionId = new ConnectionId(connectionIdGenerator.generateId());
1:     private final SessionId sessionId = new SessionId(connectionId, -1);
1:     private final ProducerId producerId = new ProducerId(sessionId, 1);
1:     
1:     private final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
1:     private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
1:     private final LongSequenceGenerator transactionIdGenerator = new LongSequenceGenerator();
1: 	
0:     private final ConcurrentHashMap resposeHandlers = new ConcurrentHashMap();
0:     private final ConcurrentHashMap subscriptionsByConsumerId = new ConcurrentHashMap();
0:     private final Map transactions = new ConcurrentHashMap();
0: 	private StompTransportFilter transportFilter;
1: 	
0: 	private final Object commnadIdMutex = new Object();
0: 	private int lastCommandId;
1:     private final AtomicBoolean connected = new AtomicBoolean(false);
1: 
1:     protected int generateCommandId() {
0:     	synchronized(commnadIdMutex){
0:     		return lastCommandId++;
0:     	}
0:     }
1: 
0:     protected ResponseHandler createResponseHandler(StompCommand command){
0:         final String receiptId = (String) command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
0:         // A response may not be needed.
0:         if( receiptId != null ) {
0: 	        return new ResponseHandler() {
0: 	    		public void onResponse(ProtocolConverter converter, Response response) throws IOException {
0: 	                StompCommand sc = new StompCommand();
0: 	                sc.setHeaders(new HashMap(5));
0: 	                sc.getHeaders().put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
0: 	        		transportFilter.sendToStomp(sc);
0: 	    		}
0: 	        };
0: 	    }
0:     	return null;
0:     }
1:     
0: 	protected void sendToActiveMQ(Command command, ResponseHandler handler) {
0: 		command.setCommandId(generateCommandId());
0: 		if(handler!=null) {
0: 			command.setResponseRequired(true);
0: 			resposeHandlers.put(new Integer(command.getCommandId()), handler);
0: 		}
0: 		transportFilter.sendToActiveMQ(command);
0: 	}
1: 
0: 	protected void sendToStomp(StompCommand command) throws IOException {
0: 		transportFilter.sendToStomp(command);
0: 	}
1: 
1: 	/**
0:      * Convert a stomp command
0:      * @param command
1:      */
0: 	public void onStompCommad( StompCommand command ) throws IOException, JMSException {
0: 		try {
1: 			
0: 			String action = command.getAction();
0: 	        if (action.startsWith(Stomp.Commands.SEND))
0: 	            onStompSend(command);
0: 	        else if (action.startsWith(Stomp.Commands.ACK))
0: 	            onStompAck(command);
0: 	        else if (action.startsWith(Stomp.Commands.BEGIN))
0: 	            onStompBegin(command);
0: 	        else if (action.startsWith(Stomp.Commands.COMMIT))
0: 	            onStompCommit(command);
0: 	        else if (action.startsWith(Stomp.Commands.ABORT))
0: 	            onStompAbort(command);
0: 	        else if (action.startsWith(Stomp.Commands.SUBSCRIBE))
0: 	            onStompSubscribe(command);
0: 	        else if (action.startsWith(Stomp.Commands.UNSUBSCRIBE))
0: 	            onStompUnsubscribe(command);
0: 			else if (action.startsWith(Stomp.Commands.CONNECT))
0: 	            onStompConnect(command);
0: 	        else if (action.startsWith(Stomp.Commands.DISCONNECT))
0: 	            onStompDisconnect(command);
0: 	        else
0: 	        	throw new ProtocolException("Unknown STOMP action: "+action);
1: 	        
1:         } catch (ProtocolException e) {
1:         	
0:         	// Let the stomp client know about any protocol errors.
0:         	ByteArrayOutputStream baos = new ByteArrayOutputStream();
0:         	PrintWriter stream = new PrintWriter(new OutputStreamWriter(baos,"UTF-8"));
0:         	e.printStackTrace(stream);
0:         	stream.close();
1: 
0:         	HashMap headers = new HashMap();
0:         	headers.put(Stomp.Headers.Error.MESSAGE, e.getMessage());
1:         	
0:             final String receiptId = (String) command.getHeaders().get(Stomp.Headers.RECEIPT_REQUESTED);
0:             if( receiptId != null ) {            	
0:             	headers.put(Stomp.Headers.Response.RECEIPT_ID, receiptId);
0:             }
1:         	
0:         	StompCommand errorMessage = new StompCommand(Stomp.Responses.ERROR,headers,baos.toByteArray());
0: 			sendToStomp(errorMessage);
1: 			
0:         }
0: 	}
1: 	
0: 	protected void onStompSend(StompCommand command) throws IOException, JMSException {
0: 		checkConnected();
1: 
0:     	Map headers = command.getHeaders();
0:         String stompTx = (String) headers.get(Stomp.Headers.TRANSACTION);
1: 
1:         ActiveMQMessage message = convertMessage(command);
1: 
1:         message.setProducerId(producerId);
1:         MessageId id = new MessageId(producerId, messageIdGenerator.getNextSequenceId());
1:         message.setMessageId(id);
0:         message.setJMSTimestamp(System.currentTimeMillis());
1: 
0:         if (stompTx!=null) {
0:         	TransactionId activemqTx = (TransactionId) transactions.get(stompTx);
0:             if (activemqTx == null)
0:                 throw new ProtocolException("Invalid transaction id: "+stompTx);
1:             message.setTransactionId(activemqTx);
0:         }
1: 		
1:         message.onSend();
0: 		sendToActiveMQ(message, createResponseHandler(command));
1: 		
0: 	}
1: 	
1: 
0:     protected void onStompAck(StompCommand command) throws ProtocolException {
0: 		checkConnected();
1: 
0:     	// TODO: acking with just a message id is very bogus
0:     	// since the same message id could have been sent to 2 different subscriptions
0:     	// on the same stomp connection. For example, when 2 subs are created on the same topic.
1:     	
0:     	Map headers = command.getHeaders();
0:         String messageId = (String) headers.get(Stomp.Headers.Ack.MESSAGE_ID);
0:         if (messageId == null)
1:             throw new ProtocolException("ACK received without a message-id to acknowledge!");
1: 
0:         TransactionId activemqTx=null;
0:         String stompTx = (String) headers.get(Stomp.Headers.TRANSACTION);
0:         if (stompTx!=null) {
0:         	activemqTx = (TransactionId) transactions.get(stompTx);
0:             if (activemqTx == null)
0:                 throw new ProtocolException("Invalid transaction id: "+stompTx);
0:         }
1: 
0:         boolean acked=false;
0:         for (Iterator iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
0: 			StompSubscription sub = (StompSubscription) iter.next();
0: 			MessageAck ack = sub.onStompMessageAck(messageId);
0: 			if( ack!=null ) {
0: 		        ack.setTransactionId(activemqTx);
0: 		        sendToActiveMQ(ack,createResponseHandler(command));
0: 		        acked=true;
0: 		        break;
0: 			}
0: 		}
1:         
0:         if( !acked )
0:         	throw new ProtocolException("Unexpected ACK received for message-id [" + messageId + "]");
1: 
0: 	}
1:     
1: 
0: 	protected void onStompBegin(StompCommand command) throws ProtocolException {
0: 		checkConnected();
1: 
0: 		Map headers = command.getHeaders();
1: 		
0:         String stompTx = (String)headers.get(Stomp.Headers.TRANSACTION);
1:         
1:         if (!headers.containsKey(Stomp.Headers.TRANSACTION)) {
1:             throw new ProtocolException("Must specify the transaction you are beginning");
0:         }
1:         
0:         if( transactions.get(stompTx)!=null  ) {
0:             throw new ProtocolException("The transaction was allready started: "+stompTx);
0:         }
1:         
1:         LocalTransactionId activemqTx = new LocalTransactionId(connectionId, transactionIdGenerator.getNextSequenceId());
1:         transactions.put(stompTx, activemqTx);
1:         
1:         TransactionInfo tx = new TransactionInfo();
1:         tx.setConnectionId(connectionId);
1:         tx.setTransactionId(activemqTx);
1:         tx.setType(TransactionInfo.BEGIN);
1:         
0: 		sendToActiveMQ(tx, createResponseHandler(command));
1: 		
0: 	}
1: 	
0: 	protected void onStompCommit(StompCommand command) throws ProtocolException {
0: 		checkConnected();
1: 
0: 		Map headers = command.getHeaders();
1: 		
0:         String stompTx = (String) headers.get(Stomp.Headers.TRANSACTION);
0:         if (stompTx==null) {
1:             throw new ProtocolException("Must specify the transaction you are committing");
0:         }
1:         
0:         TransactionId activemqTx=null;
0:         if (stompTx!=null) {
0:         	activemqTx = (TransactionId) transactions.remove(stompTx);
0:             if (activemqTx == null)
0:                 throw new ProtocolException("Invalid transaction id: "+stompTx);
0:         }
1: 
1:         TransactionInfo tx = new TransactionInfo();
1:         tx.setConnectionId(connectionId);
1:         tx.setTransactionId(activemqTx);
1:         tx.setType(TransactionInfo.COMMIT_ONE_PHASE);
1: 		
0: 		sendToActiveMQ(tx, createResponseHandler(command));
0: 	}
1: 
0: 	protected void onStompAbort(StompCommand command) throws ProtocolException {
0: 		checkConnected();
0:     	Map headers = command.getHeaders();
1: 		
0:         String stompTx = (String) headers.get(Stomp.Headers.TRANSACTION);
0:         if (stompTx==null) {
1:             throw new ProtocolException("Must specify the transaction you are committing");
0:         }
1:         
0:         TransactionId activemqTx=null;
0:         if (stompTx!=null) {
0:         	activemqTx = (TransactionId) transactions.remove(stompTx);
0:             if (activemqTx == null)
0:                 throw new ProtocolException("Invalid transaction id: "+stompTx);
0:         }
1: 
1:         TransactionInfo tx = new TransactionInfo();
1:         tx.setConnectionId(connectionId);
1:         tx.setTransactionId(activemqTx);
1:         tx.setType(TransactionInfo.ROLLBACK);
1: 		
0: 		sendToActiveMQ(tx, createResponseHandler(command));
1: 		
0: 	}
1: 
0: 	protected void onStompSubscribe(StompCommand command) throws ProtocolException {
0: 		checkConnected();
0:     	Map headers = command.getHeaders();
1:         
0:         String subscriptionId = (String)headers.get(Stomp.Headers.Subscribe.ID);
0:         String destination = (String)headers.get(Stomp.Headers.Subscribe.DESTINATION);
1:         
0:         ActiveMQDestination actual_dest = convertDestination(destination);
0:         ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
1:         ConsumerInfo consumerInfo = new ConsumerInfo(id);
0:         consumerInfo.setPrefetchSize(1000);
1:         consumerInfo.setDispatchAsync(true);
1: 
0:         String selector = (String) headers.remove(Stomp.Headers.Subscribe.SELECTOR);
0:         consumerInfo.setSelector(selector);
1:         
1:         IntrospectionSupport.setProperties(consumerInfo, headers, "activemq.");
1:         
0:         consumerInfo.setDestination(convertDestination(destination));
1:                 
0:         StompSubscription stompSubscription = new StompSubscription(this, subscriptionId, consumerInfo);
0:         stompSubscription.setDestination(actual_dest);
1:         
0:         String ackMode = (String)headers.get(Stomp.Headers.Subscribe.ACK_MODE);
1:         if (Stomp.Headers.Subscribe.AckModeValues.CLIENT.equals(ackMode)) {
1:             stompSubscription.setAckMode(StompSubscription.CLIENT_ACK);
0:         } else {
1:             stompSubscription.setAckMode(StompSubscription.AUTO_ACK);
0:         }
1: 
1:         subscriptionsByConsumerId.put(id, stompSubscription);
0: 		sendToActiveMQ(consumerInfo, createResponseHandler(command));
1: 		
0: 	}
1: 
0: 	protected void onStompUnsubscribe(StompCommand command) throws ProtocolException {
0: 		checkConnected();
0:     	Map headers = command.getHeaders();
1: 
0:         ActiveMQDestination destination=null;
1:         Object o = headers.get(Stomp.Headers.Unsubscribe.DESTINATION);
0:         if( o!=null ) 
0:         	destination =convertDestination((String) o);
1:         
0:         String subscriptionId = (String)headers.get(Stomp.Headers.Unsubscribe.ID);
1:         
0:         if (subscriptionId==null && destination==null) {
1:             throw new ProtocolException("Must specify the subscriptionId or the destination you are unsubscribing from");
0:         }
1: 
0:         // TODO: Unsubscribing using a destination is a bit wierd if multiple subscriptions
0:         // are created with the same destination.  Perhaps this should be removed.
0:         //
0:         for (Iterator iter = subscriptionsByConsumerId.values().iterator(); iter.hasNext();) {
0: 			StompSubscription sub = (StompSubscription) iter.next();
0: 			if ( 
0: 				(subscriptionId!=null && subscriptionId.equals(sub.getSubscriptionId()) ) ||
0: 				(destination!=null && destination.equals(sub.getDestination()) )
0: 			) {
0: 		        sendToActiveMQ(sub.getConsumerInfo().createRemoveCommand(), createResponseHandler(command));
1: 				return;
0: 			}
0: 		}
1:         
1:         throw new ProtocolException("No subscription matched.");
0: 	}
1: 
0: 	protected void onStompConnect(StompCommand command) throws ProtocolException {
1: 
0: 		if(connected.get()) {
0: 			throw new ProtocolException("Allready connected.");
0: 		}
1: 
0:     	final Map headers = command.getHeaders();
1:         
1:         // allow anyone to login for now
0:         String login = (String)headers.get(Stomp.Headers.Connect.LOGIN);
0:         String passcode = (String)headers.get(Stomp.Headers.Connect.PASSCODE);
0:         String clientId = (String)headers.get(Stomp.Headers.Connect.CLIENT_ID);
1:         
0:         final ConnectionInfo connectionInfo = new ConnectionInfo();
1:         
1:         IntrospectionSupport.setProperties(connectionInfo, headers, "activemq.");
1:         
1:         connectionInfo.setConnectionId(connectionId);
0:         if( clientId!=null )
1:             connectionInfo.setClientId(clientId);
0:         else
0:             connectionInfo.setClientId(""+connectionInfo.getConnectionId().toString());
1:         
1:         connectionInfo.setResponseRequired(true);
1:         connectionInfo.setUserName(login);
1:         connectionInfo.setPassword(passcode);
1: 
0: 		sendToActiveMQ(connectionInfo, new ResponseHandler(){
0: 			public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1: 					            
0: 	            final SessionInfo sessionInfo = new SessionInfo(sessionId);
0: 	            sendToActiveMQ(sessionInfo,null);
1: 	            
1: 	            
0: 	            final ProducerInfo producerInfo = new ProducerInfo(producerId);
0: 	            sendToActiveMQ(producerInfo,new ResponseHandler(){
0: 					public void onResponse(ProtocolConverter converter, Response response) throws IOException {
1: 						
0: 						connected.set(true);
0: 	                    HashMap responseHeaders = new HashMap();
1: 	                    
0: 	                    responseHeaders.put(Stomp.Headers.Connected.SESSION, connectionInfo.getClientId());
0: 	                    String requestId = (String) headers.get(Stomp.Headers.Connect.REQUEST_ID);
0: 	                    if( requestId !=null ){
0: 		                    responseHeaders.put(Stomp.Headers.Connected.RESPONSE_ID, requestId);
0: 	            		}
1: 	                    
0: 	                    StompCommand sc = new StompCommand();
0: 	                    sc.setAction(Stomp.Responses.CONNECTED);
0: 	                    sc.setHeaders(responseHeaders);
0: 	                    sendToStomp(sc);
0: 					}
0: 				});
1: 	            
0: 			}
0: 		});
1: 		
0: 	}
1: 
0: 	protected void onStompDisconnect(StompCommand command) throws ProtocolException {
0: 		checkConnected();
0: 		sendToActiveMQ(new ShutdownInfo(), createResponseHandler(command));
0: 		connected.set(false);
0: 	}
1: 
1: 
0: 	protected void checkConnected() throws ProtocolException {
0: 		if(!connected.get()) {
0: 			throw new ProtocolException("Not connected.");
0: 		}
0: 	}
1: 
1: 	/**
0:      * Convert a ActiveMQ command
0:      * @param command
1:      * @throws IOException 
1:      */
0: 	public void onActiveMQCommad( Command command ) throws IOException, JMSException {
1: 		
0:     	if ( command.isResponse() ) {
1: 		    
0: 			Response response = (Response) command;
0: 		    ResponseHandler rh = (ResponseHandler) resposeHandlers.remove(new Integer(response.getCorrelationId()));
0: 		    if( rh !=null ) {
0: 		    	rh.onResponse(this, response);
0: 		    }
1: 		    
0: 		} else if( command.isMessageDispatch() ) {
1: 			
0: 		    MessageDispatch md = (MessageDispatch)command;
0: 		    StompSubscription sub = (StompSubscription) subscriptionsByConsumerId.get(md.getConsumerId());
0: 		    if (sub != null)
0: 		        sub.onMessageDispatch(md);
1: 		    
0: 		}
1: 		
0: 	}
1: 
0: 	public  ActiveMQMessage convertMessage(StompCommand command) throws IOException, JMSException {
0: 		Map headers = command.getHeaders();
1:         
0:         // now the body
0:         ActiveMQMessage msg;
0:         if (headers.containsKey(Stomp.Headers.CONTENT_LENGTH)) {
0:             headers.remove(Stomp.Headers.CONTENT_LENGTH);
0:             ActiveMQBytesMessage bm = new ActiveMQBytesMessage();
0:             bm.writeBytes(command.getContent());
0:             msg = bm;
0:         } else {
0:             ActiveMQTextMessage text = new ActiveMQTextMessage();
0:             try {
0: 				text.setText(new String(command.getContent(), "UTF-8"));
0: 			} catch (Throwable e) {
0: 				throw (ProtocolException)new ProtocolException("Text could not bet set: "+e).initCause(e);
0: 			}
0:             msg = text;
0:         }
1: 
0:         String destination = (String) headers.remove(Stomp.Headers.Send.DESTINATION);
0:         msg.setDestination(convertDestination(destination));
1: 
0:         // the standard JMS headers
0:         msg.setJMSCorrelationID((String) headers.remove(Stomp.Headers.Send.CORRELATION_ID));
1: 
0:         Object o = headers.remove(Stomp.Headers.Send.EXPIRATION_TIME);
0:         if (o != null) {
0:             msg.setJMSExpiration(Long.parseLong((String) o));
0:         }
1:         
0:         o = headers.remove(Stomp.Headers.Send.PRIORITY);
0:         if (o != null) {
0:             msg.setJMSPriority(Integer.parseInt((String)o));
0:         }
1:         
0:         o = headers.remove(Stomp.Headers.Send.TYPE);
0:         if (o != null) {
0:             msg.setJMSType((String) o);
0:         }
1:         
0:         o = headers.remove(Stomp.Headers.Send.REPLY_TO);
0:         if( o!=null ) {
0:         	msg.setJMSReplyTo(convertDestination((String)o));
0:         }
1: 
0:         o = headers.remove(Stomp.Headers.Send.PERSISTENT);
0:         if (o != null) {
0:             msg.setPersistent("true".equals(o));
0:         }
1:         
0:         // now the general headers
0:         msg.setProperties(headers);
1:         
1:         return msg;        
0: 	}
1: 	
0: 	public StompCommand convertMessage(ActiveMQMessage message) throws IOException, JMSException {
1: 
0: 		StompCommand command = new StompCommand();
0: 		command.setAction(Stomp.Responses.MESSAGE);
1: 		
0: 		HashMap headers = new HashMap();
0: 		command.setHeaders(headers);
1: 		
0:         headers.put(Stomp.Headers.Message.DESTINATION, convertDestination(message.getDestination()));
0:         headers.put(Stomp.Headers.Message.MESSAGE_ID, message.getJMSMessageID());
0:         headers.put(Stomp.Headers.Message.CORRELATION_ID, message.getJMSCorrelationID());
0:         headers.put(Stomp.Headers.Message.EXPIRATION_TIME, ""+message.getJMSExpiration());
0:         if (message.getJMSRedelivered()) {
0:             headers.put(Stomp.Headers.Message.REDELIVERED, "true");
0:         }
0:         headers.put(Stomp.Headers.Message.PRORITY, ""+message.getJMSPriority());
0:         headers.put(Stomp.Headers.Message.REPLY_TO, convertDestination(message.getJMSReplyTo()));
0:         headers.put(Stomp.Headers.Message.TIMESTAMP, ""+message.getJMSTimestamp());
0:         headers.put(Stomp.Headers.Message.TYPE, message.getJMSType());
1: 
0:         // now lets add all the message headers
0:         Map properties = message.getProperties();
0:         if (properties != null) {
0:             headers.putAll(properties);
0:         }
1:         
0:         if( message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE ) {
1:         	
0:             ActiveMQTextMessage msg = (ActiveMQTextMessage)message.copy();
0:             command.setContent(msg.getText().getBytes("UTF-8"));
1:             
0:         } else if( message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE ) {
1:             
0:         	ActiveMQBytesMessage msg = (ActiveMQBytesMessage)message.copy();
0:             byte[] data = new byte[(int)msg.getBodyLength()]; 
0:             msg.readBytes(data);
1: 
0:             headers.put(Stomp.Headers.CONTENT_LENGTH, ""+data.length);
0:             command.setContent(data);
1:             
0:         }
1: 
0:         return command;		
0: 	}
1: 	
0:     protected ActiveMQDestination convertDestination(String name) throws ProtocolException {
0:         if (name == null) {
0:             return null;
0:         }
0:         else if (name.startsWith("/queue/")) {
0:             String q_name = name.substring("/queue/".length(), name.length());
0:             return ActiveMQDestination.createDestination(q_name, ActiveMQDestination.QUEUE_TYPE);
0:         }
0:         else if (name.startsWith("/topic/")) {
0:             String t_name = name.substring("/topic/".length(), name.length());
0:             return ActiveMQDestination.createDestination(t_name, ActiveMQDestination.TOPIC_TYPE);
0:         }
0:         else {
0:             throw new ProtocolException("Illegal destination name: [" + name + "] -- ActiveMQ STOMP destinations " + "must begine with /queue/ or /topic/");
0:         }
1: 
0:     }
1: 
0:     protected String convertDestination(Destination d) {
0:         if (d == null) {
0:             return null;
0:         }
0:         ActiveMQDestination amq_d = (ActiveMQDestination) d;
0:         String p_name = amq_d.getPhysicalName();
1: 
0:         StringBuffer buffer = new StringBuffer();
0:         if (amq_d.isQueue()) {
0:             buffer.append("/queue/");
0:         }
0:         if (amq_d.isTopic()) {
0:             buffer.append("/topic/");
0:         }
0:         buffer.append(p_name);
1: 
0:         return buffer.toString();
0:     }
1: 
0: 	public StompTransportFilter getTransportFilter() {
0: 		return transportFilter;
0: 	}
1: 
0: 	public void setTransportFilter(StompTransportFilter transportFilter) {
0: 		this.transportFilter = transportFilter;
0: 	}
1: 	
0: 	public void onStompExcepton(IOException error) {
0: 		// TODO Auto-generated method stub
0: 	}
1: 
0: }
author:Robert Davies
-------------------------------------------------------------------------------
commit:556ee7b
/////////////////////////////////////////////////////////////////////////
1:             throw new ProtocolException("Invalid Subscription: cannot durably subscribe to a Queue destination!");
commit:f866f77
/////////////////////////////////////////////////////////////////////////
0:             try {
0:             	sub.onStompAbort(activemqTx);
0:             } catch (Exception e) {
0:             	throw new ProtocolException("Transaction abort failed", false, e);
0:             }
/////////////////////////////////////////////////////////////////////////
0:         connectionInfo.setTransportContext(transportFilter.getPeerCertificates());
commit:b1288f2
/////////////////////////////////////////////////////////////////////////
1:         } else if (Stomp.Headers.Subscribe.AckModeValues.INDIVIDUAL.equals(ackMode)) {
1:             stompSubscription.setAckMode(StompSubscription.INDIVIDUAL_ACK);
commit:4c92244
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
/////////////////////////////////////////////////////////////////////////
0:        
1:         // check if it is a durable subscription
0:         String durable = command.getHeaders().get("activemq.subscriptionName"); 
1:         if (durable != null) {
1:             RemoveSubscriptionInfo info = new RemoveSubscriptionInfo();
0:             info.setClientId(durable);
1:             info.setSubscriptionName(durable);
1:             info.setConnectionId(connectionId);
0:             sendToActiveMQ(info, createResponseHandler(command));
1:             return;
0:         }
/////////////////////////////////////////////////////////////////////////
0:        
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0: 			resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
/////////////////////////////////////////////////////////////////////////
0: 		    ResponseHandler rh = (ResponseHandler) resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
commit:1a448be
/////////////////////////////////////////////////////////////////////////
0: 				iter.remove();
0:                 return;
author:James Strachan
-------------------------------------------------------------------------------
commit:1a33eb6
/////////////////////////////////////////////////////////////////////////
1:                         if (requestId == null) {
1:                             // TODO legacy
0:                             requestId = (String) headers.get(Stomp.Headers.RECEIPT_REQUESTED);
0:                         }
1:                             // TODO legacy
1:                             responseHeaders.put(Stomp.Headers.Response.RECEIPT_ID, requestId);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Brian McCallister
-------------------------------------------------------------------------------
commit:f8485e3
/////////////////////////////////////////////////////////////////////////
0:  *
0:  * @author <a href="http://hiramchirino.com">chirino</a>
0: 
0: 
0: 
0: 	private final StompTransportFilter transportFilter;
0: 
0:     private final FrameTranslator frameTranslator;
0: 
0:     public ProtocolConverter(StompTransportFilter stompTransportFilter, FrameTranslator translator)
0:     {
0:         this.transportFilter = stompTransportFilter;
0:         this.frameTranslator = translator;
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:             if( receiptId != null ) {
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0:         TransactionId activemqTx = (TransactionId) transactions.remove(stompTx);
1:         if (activemqTx == null) {
0:             throw new ProtocolException("Invalid transaction id: "+stompTx);
0: 
0: 
0: 
0:         TransactionId activemqTx = (TransactionId) transactions.remove(stompTx);
1:         if (activemqTx == null) {
0:             throw new ProtocolException("Invalid transaction id: "+stompTx);
0: 
0: 
0: 
0: 
0:         ActiveMQDestination actual_dest = frameTranslator.convertDestination(destination);
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:         consumerInfo.setDestination(frameTranslator.convertDestination(destination));
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:         if( o!=null )
0:         	destination = frameTranslator.convertDestination((String) o);
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 			if (
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:      * Dispatch a ActiveMQ command
0:      * @throws IOException
0: 
0: 
0: 
0: 
0: 		    if (sub != null) {
0:             }
0:         }
0:     public  ActiveMQMessage convertMessage(StompFrame command) throws IOException, JMSException {
0:         ActiveMQMessage msg = frameTranslator.convertFrame(command);
0:         return msg;
0: 	public StompFrame convertMessage(ActiveMQMessage message) throws IOException, JMSException {
0: 		return frameTranslator.convertMessage(message);
commit:7d4cddd
/////////////////////////////////////////////////////////////////////////
0:         if (message.getJMSCorrelationID() != null) {
0:             headers.put(Stomp.Headers.Message.CORRELATION_ID, message.getJMSCorrelationID());
0:         }
0:         if (message.getJMSReplyTo() != null) {
0:             headers.put(Stomp.Headers.Message.REPLY_TO, convertDestination(message.getJMSReplyTo()));
0:         }
0:         if (message.getJMSType() != null) {
0:             headers.put(Stomp.Headers.Message.TYPE, message.getJMSType());
0:         }
============================================================================