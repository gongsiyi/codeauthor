1:162f9fc: /**
1:cdd5150:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:cdd5150:  * contributor license agreements.  See the NOTICE file distributed with
1:cdd5150:  * this work for additional information regarding copyright ownership.
1:cdd5150:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:cdd5150:  * (the "License"); you may not use this file except in compliance with
1:cdd5150:  * the License.  You may obtain a copy of the License at
1:162f9fc:  *
1:cdd5150:  *      http://www.apache.org/licenses/LICENSE-2.0
2:cdd5150:  *
1:cdd5150:  * Unless required by applicable law or agreed to in writing, software
1:cdd5150:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cdd5150:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cdd5150:  * See the License for the specific language governing permissions and
1:cdd5150:  * limitations under the License.
1:162f9fc:  */
1:cdd5150: package org.apache.activemq.transport.amqp;
1:ca456c4: 
1:b62648b: import java.io.IOException;
1:ca456c4: 
1:e3377ed: import org.apache.activemq.command.Command;
1:ca456c4: 
1:3306467: /**
1:3306467:  * Interface that defines the API for any AMQP protocol converter ised to
1:31c55f7:  * map AMQP mechanics to ActiveMQ and back.
1:3306467:  */
1:3306467: public interface AmqpProtocolConverter {
1:ca456c4: 
1:185213b:     /**
1:3306467:      * A new incoming data packet from the remote peer is handed off to the
1:31c55f7:      * protocol converter for processing.  The type can vary and be either an
1:3306467:      * AmqpHeader at the handshake phase or a byte buffer containing the next
1:3306467:      * incoming frame data from the remote.
1:185213b:      *
1:3306467:      * @param data
1:3306467:      *        the next incoming data object from the remote peer.
1:a090472:      *
1:3306467:      * @throws Exception if an error occurs processing the incoming data packet.
1:185213b:      */
1:3306467:     void onAMQPData(Object data) throws Exception;
1:6a6ef45: 
1:a090472:     /**
1:3306467:      * Called when the transport detects an exception that the converter
1:3306467:      * needs to respond to.
1:78cb112:      *
1:3306467:      * @param error
1:3306467:      *        the error that triggered this call.
1:a090472:      */
1:3306467:     void onAMQPException(IOException error);
1:6a6ef45: 
1:78cb112:     /**
1:3306467:      * Incoming Command object from ActiveMQ.
1:3306467:      *
1:3306467:      * @param command
1:3306467:      *        the next incoming command from the broker.
1:3306467:      *
1:3306467:      * @throws Exception if an error occurs processing the command.
1:78cb112:      */
1:3306467:     void onActiveMQCommand(Command command) throws Exception;
1:6a6ef45: 
1:3306467:     /**
1:3306467:      * On changes to the transport tracing options the Protocol Converter
1:3306467:      * should update its internal state so that the proper AMQP data is
1:3306467:      * logged.
1:3306467:      */
1:3306467:     void updateTracer();
1:6a6ef45: 
1:4b4cf7c:     /**
1:4b4cf7c:      * Perform any keep alive processing for the connection such as sending
1:4b4cf7c:      * empty frames or closing connections due to remote end being inactive
1:4b4cf7c:      * for to long.
1:4b4cf7c:      *
1:31c55f7:      * @returns the amount of milliseconds to wait before performing another check.
1:4b4cf7c:      *
1:31c55f7:      * @throws IOException if an error occurs on writing heart-beats to the wire.
1:4b4cf7c:      */
1:4b4cf7c:     long keepAlive() throws IOException;
1:4b4cf7c: 
1:ca456c4: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:31c55f7
/////////////////////////////////////////////////////////////////////////
1:  * map AMQP mechanics to ActiveMQ and back.
1:      * protocol converter for processing.  The type can vary and be either an
/////////////////////////////////////////////////////////////////////////
1:      * @returns the amount of milliseconds to wait before performing another check.
1:      * @throws IOException if an error occurs on writing heart-beats to the wire.
commit:4b4cf7c
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Perform any keep alive processing for the connection such as sending
1:      * empty frames or closing connections due to remote end being inactive
1:      * for to long.
1:      *
0:      * @returns the amount of milliseconds to wait before performaing another check.
1:      *
0:      * @throws IOException if an error occurs on writing heatbeats to the wire.
1:      */
1:     long keepAlive() throws IOException;
1: 
commit:3306467
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Interface that defines the API for any AMQP protocol converter ised to
0:  * map AMQP mechanincs to ActiveMQ and back.
1:  */
1: public interface AmqpProtocolConverter {
1:      * A new incoming data packet from the remote peer is handed off to the
0:      * protocol converter for porcessing.  The type can vary and be either an
1:      * AmqpHeader at the handshake phase or a byte buffer containing the next
1:      * incoming frame data from the remote.
1:      * @param data
1:      *        the next incoming data object from the remote peer.
1:      * @throws Exception if an error occurs processing the incoming data packet.
1:     void onAMQPData(Object data) throws Exception;
1:      * Called when the transport detects an exception that the converter
1:      * needs to respond to.
1:      * @param error
1:      *        the error that triggered this call.
1:     void onAMQPException(IOException error);
1:      * Incoming Command object from ActiveMQ.
1:      *
1:      * @param command
1:      *        the next incoming command from the broker.
1:      *
1:      * @throws Exception if an error occurs processing the command.
1:     void onActiveMQCommand(Command command) throws Exception;
1:     /**
1:      * On changes to the transport tracing options the Protocol Converter
1:      * should update its internal state so that the proper AMQP data is
1:      * logged.
1:      */
1:     void updateTracer();
commit:4228e3d
/////////////////////////////////////////////////////////////////////////
0:                     source.setDistributionMode(COPY);
commit:ca456c4
/////////////////////////////////////////////////////////////////////////
0:             final Map<Symbol, Object> supportedFilters = new HashMap<Symbol, Object>();
0:             boolean noLocal = false;
1: 
0:                 Map.Entry<Symbol, DescribedType> filter = findFilter(source.getFilter(), JMS_SELECTOR_FILTER_IDS);
0:                     selector = filter.getValue().getDescribed().toString();
/////////////////////////////////////////////////////////////////////////
1: 
0:                     supportedFilters.put(filter.getKey(), filter.getValue());
1:                 }
1: 
0:                 filter = findFilter(source.getFilter(), NO_LOCAL_FILTER_IDS);
0:                 if (filter != null) {
0:                     noLocal = true;
0:                     supportedFilters.put(filter.getKey(), filter.getValue());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             source.setFilter(supportedFilters.isEmpty() ? null : supportedFilters);
0:             sender.setSource(source);
1: 
/////////////////////////////////////////////////////////////////////////
0:             consumerInfo.setNoLocal(noLocal);
/////////////////////////////////////////////////////////////////////////
commit:6a6ef45
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (credit != consumerContext.credit) {
0:                 consumerContext.credit = credit >= 0 ? credit : 0;
0:                 control.setPrefetch(consumerContext.credit);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             int senderCredit = sender.getRemoteCredit();
1: 
0:             consumerInfo.setPrefetchSize(senderCredit >= 0 ? senderCredit : 0);
1: 
/////////////////////////////////////////////////////////////////////////
0:             consumerContext.info = consumerInfo;
0:             consumerContext.setDestination(destination);
0:             consumerContext.credit = senderCredit;
1: 
/////////////////////////////////////////////////////////////////////////
commit:72839b7
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.activemq.transport.amqp.AmqpSupport.ANONYMOUS_RELAY;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.CONNECTION_OPEN_FAILED;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.COPY;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.JMS_SELECTOR_FILTER_IDS;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.NO_LOCAL_FILTER_IDS;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.QUEUE_PREFIX;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.TEMP_QUEUE_CAPABILITY;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.TEMP_TOPIC_CAPABILITY;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.TOPIC_PREFIX;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.contains;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.findFilter;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.toBytes;
0: import static org.apache.activemq.transport.amqp.AmqpSupport.toLong;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             rejected.setError(new ErrorCondition(Symbol.valueOf("failed"), er.getException().getMessage()));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:185213b
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol CONNECTION_OPEN_FAILED = Symbol.valueOf("amqp:connection-establishment-failed");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Load and return a <code>Map<Symbol, Object></code> that contains the properties
0:      * that this connection supplies to incoming connections when the open has failed
0:      * and the remote should expect a close to follow.
1:      *
0:      * @return the properties that are offered to the incoming connection.
1:      */
0:     protected Map<Symbol, Object> getFailedConnetionProperties() {
0:         Map<Symbol, Object> properties = new HashMap<Symbol, Object>();
0: 
0:         properties.put(CONNECTION_OPEN_FAILED, true);
0: 
0:         return properties;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:                         protonConnection.setProperties(getFailedConnetionProperties());
0:                         protonConnection.open();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:                     } else {
0:                         protonConnection.setOfferedCapabilities(getConnectionCapabilitiesOffered());
0:                         protonConnection.setProperties(getConnetionProperties());
0:                         protonConnection.open();
commit:aea771f
/////////////////////////////////////////////////////////////////////////
0:     private static final UnsignedLong JMS_SELECTOR_CODE = UnsignedLong.valueOf(0x0000468C00000004L);
0:     private static final Symbol JMS_SELECTOR_NAME = Symbol.valueOf("apache.org:selector-filter:string");
0:     private static final Object[] JMS_SELECTOR_FILTER_IDS = new Object[] { JMS_SELECTOR_CODE, JMS_SELECTOR_NAME };
0:     private static final UnsignedLong NO_LOCAL_CODE = UnsignedLong.valueOf(0x0000468C00000003L);
0:     private static final Symbol NO_LOCAL_NAME = Symbol.valueOf("apache.org:selector-filter:string");
0:     private static final Object[] NO_LOCAL_FILTER_IDS = new Object[] { NO_LOCAL_CODE, NO_LOCAL_NAME };
/////////////////////////////////////////////////////////////////////////
0:                 DescribedType filter = findFilter(source.getFilter(), JMS_SELECTOR_FILTER_IDS);
/////////////////////////////////////////////////////////////////////////
0:             DescribedType filter = findFilter(source.getFilter(), NO_LOCAL_FILTER_IDS);
/////////////////////////////////////////////////////////////////////////
0:     private DescribedType findFilter(Map<Symbol, Object> filters, Object[] filterIds) {
0: 
0:         if (filterIds == null || filterIds.length == 0) {
0:             throw new IllegalArgumentException("Invliad Filter Ids array passed: " + filterIds);
0:         }
0: 
0:                 DescribedType describedType = ((DescribedType) value);
0:                 Object descriptor = ((DescribedType) value).getDescriptor();
0: 
0:                 for (Object filterId : filterIds) {
0:                     if (descriptor.equals(filterId)) {
0:                         return describedType;
0:                     }
commit:ace101a
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentMap;
0: import java.util.concurrent.atomic.AtomicInteger;
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.amqp.UnsignedLong;
/////////////////////////////////////////////////////////////////////////
0:     private static final UnsignedLong JMS_SELECTOR = UnsignedLong.valueOf(0x0000468C00000004L);
0:     private static final UnsignedLong NO_LOCAL = UnsignedLong.valueOf(0x0000468C00000003L);
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicLong nextTransactionId = new AtomicLong();
/////////////////////////////////////////////////////////////////////////
0:                 long txid = nextTransactionId.incrementAndGet();
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
0:                 DescribedType filter = findFilter(source.getFilter(), JMS_SELECTOR);
0:                     selector = filter.getDescribed().toString();
0:                     // Validate the Selector.
0:                     try {
0:                         SelectorParser.parse(selector);
0:                     } catch (InvalidSelectorException e) {
0:                         sender.setSource(null);
0:                         sender.setCondition(new ErrorCondition(AmqpError.INVALID_FIELD, e.getMessage()));
0:                         sender.close();
0:                         consumerContext.closed = true;
0:                         return;
/////////////////////////////////////////////////////////////////////////
0:             DescribedType filter = findFilter(source.getFilter(), NO_LOCAL);
0:                 consumerInfo.setNoLocal(true);
/////////////////////////////////////////////////////////////////////////
0:         if (symbols == null || symbols.length == 0) {
/////////////////////////////////////////////////////////////////////////
0:     private DescribedType findFilter(Map<Symbol, Object> filters, UnsignedLong filterId) {
0:         if (filters == null || filters.isEmpty()) {
0:             return null;
0:         }
0: 
0:         for (Object value : filters.values()) {
0:             if (value instanceof DescribedType) {
0:                 DescribedType describedType = (DescribedType) value;
0:                 if (describedType.getDescriptor().equals(filterId)) {
0:                     return describedType;
0:                 }
0:             }
0:         }
0: 
0:         return null;
0:     }
0: 
0:     private final AtomicInteger lastCommandId = new AtomicInteger();
0:     private final ConcurrentMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
0:         command.setCommandId(lastCommandId.incrementAndGet());
commit:67ccfca
/////////////////////////////////////////////////////////////////////////
0: import java.security.Principal;
0: import java.security.cert.X509Certificate;
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.security.AuthenticationBroker;
0: import org.apache.activemq.security.SecurityContext;
/////////////////////////////////////////////////////////////////////////
0:     private AuthenticationBroker authenticator;
/////////////////////////////////////////////////////////////////////////
0: 
0:                             if (tryAuthenticate(connectionInfo, amqpTransport.getPeerCertificates())) {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_OK);
0:                             } else {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_AUTH);
0:                             }
0: 
0:                             if (tryAuthenticate(connectionInfo, amqpTransport.getPeerCertificates())) {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_OK);
0:                             } else {
0:                                 sasl.done(Sasl.SaslOutcome.PN_SASL_AUTH);
0:                             }
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean tryAuthenticate(ConnectionInfo info, X509Certificate[] peerCertificates) {
0:         try {
0:             if (getAuthenticator().authenticate(info.getUserName(), info.getPassword(), peerCertificates) != null) {
0:                 return true;
0:             }
0: 
0:             return false;
0:         } catch (Throwable error) {
0:             return false;
0:         }
0:     }
0: 
0:     private AuthenticationBroker getAuthenticator() {
0:         if (authenticator == null) {
0:             try {
0:                 authenticator = (AuthenticationBroker) brokerService.getBroker().getAdaptor(AuthenticationBroker.class);
0:             } catch (Exception e) {
0:                 LOG.debug("Failed to lookup AuthenticationBroker from Broker, will use a default Noop version.");
0:             }
0: 
0:             if (authenticator == null) {
0:                 authenticator = new DefaultAuthenticationBroker();
0:             }
0:         }
0: 
0:         return authenticator;
0:     }
0: 
0:     private class DefaultAuthenticationBroker implements AuthenticationBroker {
0: 
0:         @Override
0:         public SecurityContext authenticate(String username, String password, X509Certificate[] peerCertificates) throws SecurityException {
0:             return new SecurityContext(username) {
0: 
0:                 @Override
0:                 public Set<Principal> getPrincipals() {
0:                     return null;
0:                 }
0:             };
0:         }
0:     }
commit:ad57cc6
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQTempDestination;
/////////////////////////////////////////////////////////////////////////
0:         protected ActiveMQDestination destination;
0:         protected List<Runnable> closeActions = new ArrayList<Runnable>();
0: 
0: 
0:             for (Runnable action : closeActions) {
0:                 action.run();
0:             }
0: 
0:             closeActions.clear();
/////////////////////////////////////////////////////////////////////////
0: 
0:         public void addCloseAction(Runnable action) {
0:             closeActions.add(action);
0:         }
0: 
0:         public ActiveMQDestination getDestination() {
0:             return destination;
0:         }
0: 
0:         public void setDestination(ActiveMQDestination destination) {
0:             this.destination = destination;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         private boolean anonymous;
0:         public ProducerContext(ProducerId producerId) {
/////////////////////////////////////////////////////////////////////////
0: 
0:             super.onClose();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 final ProducerContext producerContext = new ProducerContext(producerId);
0:                     producerContext.anonymous = true;
0:                     producerContext.addCloseAction(new Runnable() {
0: 
0:                         @Override
0:                         public void run() {
0:                             deleteTemporaryDestination((ActiveMQTempDestination) producerContext.getDestination());
0:                         }
0:                     });
0:                 producerContext.setDestination(destination);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 if (!closed) {
0:                     closed = true;
0:                     sender.setContext(null);
0:                     subscriptionsByConsumerId.remove(consumerId);
0:                     AmqpSessionContext session = (AmqpSessionContext) sender.getSession().getContext();
0:                     if (session != null) {
0:                         session.consumers.remove(info.getConsumerId());
0:                     }
0: 
0:                     RemoveInfo removeCommand = new RemoveInfo(consumerId);
0:                     removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
0:                     sendToActiveMQ(removeCommand, null);
0: 
0:                     if (info.isDurable()) {
0:                         RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
0:                         rsi.setConnectionId(connectionId);
0:                         rsi.setSubscriptionName(sender.getName());
0:                         rsi.setClientId(connectionInfo.getClientId());
0: 
0:                         sendToActiveMQ(rsi, null);
0:                     }
0:             } finally {
0:                 super.onClose();
/////////////////////////////////////////////////////////////////////////
0:                 consumerContext.addCloseAction(new Runnable() {
0: 
0:                     @Override
0:                     public void run() {
0:                         deleteTemporaryDestination((ActiveMQTempDestination) consumerContext.getDestination());
0:                     }
0:                 });
/////////////////////////////////////////////////////////////////////////
0:             consumerContext.setDestination(destination);
/////////////////////////////////////////////////////////////////////////
0:     private void deleteTemporaryDestination(ActiveMQTempDestination destination) {
0:         DestinationInfo info = new DestinationInfo();
0:         info.setConnectionId(connectionId);
0:         info.setOperationType(DestinationInfo.REMOVE_OPERATION_TYPE);
0:         info.setDestination(destination);
0: 
0:         sendToActiveMQ(info, new ResponseHandler() {
0: 
0:             @Override
0:             public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
0:                 if (response.isException()) {
0:                     Throwable exception = ((ExceptionResponse) response).getException();
0:                     LOG.debug("Error during temp destination removeal: {}", exception.getMessage());
0:                 }
0:             }
0:         });
0:     }
0: 
commit:2ec586f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.amqp.message.ActiveMQJMSVendor;
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol TEMP_QUEUE_CAPABILITY = Symbol.valueOf("temporary-queue");
0:     private static final Symbol TEMP_TOPIC_CAPABILITY = Symbol.valueOf("temporary-topic");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQDestination destination = null;
0:                     destination = createTemporaryDestination(receiver, target.getCapabilities());
0:                     actualTarget.setAddress(destination.getQualifiedName());
0:                     destination = createDestination(remoteTarget);
0:                 final ProducerContext producerContext = new ProducerContext(producerId, destination, anonymous);
0:                 producerInfo.setDestination(destination);
/////////////////////////////////////////////////////////////////////////
0:     private ActiveMQDestination createDestination(Object endpoint) throws AmqpProtocolException {
0:         if (endpoint == null) {
0:         } else if (endpoint instanceof Coordinator) {
0:         } else if (endpoint instanceof org.apache.qpid.proton.amqp.messaging.Terminus) {
0:             org.apache.qpid.proton.amqp.messaging.Terminus terminus = (org.apache.qpid.proton.amqp.messaging.Terminus) endpoint;
0:             if (terminus.getAddress() == null || terminus.getAddress().length() == 0) {
0:                 if (terminus instanceof org.apache.qpid.proton.amqp.messaging.Source) {
0:                     throw new AmqpProtocolException("amqp:invalid-field", "source address not set");
0:                 } else {
0:                     throw new AmqpProtocolException("amqp:invalid-field", "target address not set");
0:                 }
0:             }
0: 
0:             return ActiveMQDestination.createDestination(terminus.getAddress(), ActiveMQDestination.QUEUE_TYPE);
0:             throw new RuntimeException("Unexpected terminus type: " + endpoint);
/////////////////////////////////////////////////////////////////////////
0:                 destination = createTemporaryDestination(sender, source.getCapabilities());
/////////////////////////////////////////////////////////////////////////
0:     private ActiveMQDestination createTemporaryDestination(final Link link, Symbol[] capabilities) {
0:         ActiveMQDestination rc = null;
0:         if (contains(capabilities, TEMP_TOPIC_CAPABILITY)) {
0:             rc = new ActiveMQTempTopic(connectionId, nextTempDestinationId++);
0:         } else if (contains(capabilities, TEMP_QUEUE_CAPABILITY)) {
0:             rc = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
0:         } else {
0:             LOG.debug("Dynamic link request with no type capability, defaults to Temporary Queue");
0:             rc = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
0:         }
0: 
0: 
0:         sendToActiveMQ(info, new ResponseHandler() {
0: 
0:             @Override
0:             public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
0:                 if (response.isException()) {
0:                     link.setSource(null);
0: 
0:                     Throwable exception = ((ExceptionResponse) response).getException();
0:                     if (exception instanceof SecurityException) {
0:                         link.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
0:                     } else {
0:                         link.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
0:                     }
0: 
0:                     link.close();
0:                     link.free();
0:                 }
0:             }
0:         });
0: 
0:     private boolean contains(Symbol[] symbols, Symbol key) {
0:         if (symbols == null) {
0:             return false;
0:         }
0: 
0:         for (Symbol symbol : symbols) {
0:             if (symbol.equals(key)) {
0:                 return true;
0:             }
0:         }
0: 
0:         return false;
0:     }
0: 
commit:7af7c01
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.DurableTopicSubscription;
0: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.broker.region.TopicRegion;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             processLinkOpen(event.getLink());
0:                             break;
0:                             processLinkDetach(event.getLink());
0:                             break;
0:                         case LINK_REMOTE_CLOSE:
0:                             processLinkClose(event.getLink());
/////////////////////////////////////////////////////////////////////////
0:     protected void processLinkOpen(Link link) throws Exception {
0:         onLinkOpen(link);
0:     }
0: 
0:     protected void processLinkDetach(Link link) throws Exception {
0:         AmqpDeliveryListener context = (AmqpDeliveryListener) link.getContext();
0:         if (context != null) {
0:             context.onDetach();
0:         link.detach();
0:         link.free();
0:     }
0: 
0:     protected void processLinkClose(Link link) throws Exception {
0:         AmqpDeliveryListener context = (AmqpDeliveryListener) link.getContext();
0:         if (context != null) {
0:             context.onClose();
0:         }
0:         link.close();
0:         link.free();
/////////////////////////////////////////////////////////////////////////
0:         public void onDetach() throws Exception {
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:         public String toString() {
0:             return "ProducerContext { producerId = " + producerId + ", destination = " + destination + " }";
0:         }
0: 
0:         @Override
/////////////////////////////////////////////////////////////////////////
0:         public String toString() {
0:             return "ConsumerContext { " + info + " }";
0:         }
0: 
0:         @Override
0:         public void onDetach() throws Exception {
0:             if (!closed) {
0:                 closed = true;
0:                 sender.setContext(null);
0:                 subscriptionsByConsumerId.remove(consumerId);
0: 
0:                 AmqpSessionContext session = (AmqpSessionContext) sender.getSession().getContext();
0:                 if (session != null) {
0:                     session.consumers.remove(info.getConsumerId());
0:                 }
0: 
0:                 RemoveInfo removeCommand = new RemoveInfo(consumerId);
0:                 removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
0:                 sendToActiveMQ(removeCommand, null);
0:             }
0:         }
0: 
0:         @Override
/////////////////////////////////////////////////////////////////////////
0: 
0:                 if (info.isDurable()) {
0:                     RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
0:                     rsi.setConnectionId(connectionId);
0:                     rsi.setSubscriptionName(sender.getName());
0:                     rsi.setClientId(connectionInfo.getClientId());
0: 
0:                     sendToActiveMQ(rsi, null);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQDestination destination;
0:                 // Attempt to recover previous subscription
0:                 destination = lookupSubscription(sender.getName());
0:                 if (destination != null) {
0:                     source = new org.apache.qpid.proton.amqp.messaging.Source();
0:                     source.setAddress(destination.getQualifiedName());
0:                     source.setDurable(TerminusDurability.UNSETTLED_STATE);
0:                     source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
0:                     sender.setSource(source);
0:                 } else {
0:                     consumerContext.closed = true;
0:                     sender.setSource(null);
0:                     sender.setCondition(new ErrorCondition(AmqpError.NOT_FOUND, "Unknown subscription link: " + sender.getName()));
0:                     sender.close();
0:                     sender.free();
0:                     pumpProtonToSocket();
0:                     return;
0:                 }
0:                 destination = createTempQueue();
0:                 source.setAddress(destination.getQualifiedName());
0:                 destination = createDestination(source);
/////////////////////////////////////////////////////////////////////////
0:             consumerInfo.setDestination(destination);
0:             consumerContext.destination = destination;
/////////////////////////////////////////////////////////////////////////
0:             if (source.getDistributionMode() == COPY && destination.isQueue()) {
0:                  TerminusDurability.CONFIGURATION.equals(source.getDurable())) && destination.isTopic()) {
/////////////////////////////////////////////////////////////////////////
0:     private ActiveMQDestination lookupSubscription(String subscriptionName) throws AmqpProtocolException {
0:         ActiveMQDestination result = null;
0:         RegionBroker regionBroker;
0: 
0:         try {
0:             regionBroker = (RegionBroker) brokerService.getBroker().getAdaptor(RegionBroker.class);
0:         } catch (Exception e) {
0:             throw new AmqpProtocolException("Error finding subscription: " + subscriptionName + ": " + e.getMessage(), false, e);
0: 
0:         final TopicRegion topicRegion = (TopicRegion) regionBroker.getTopicRegion();
0:         DurableTopicSubscription subscription = topicRegion.lookupSubscription(subscriptionName, connectionInfo.getClientId());
0:         if (subscription != null) {
0:             result = subscription.getActiveMQDestination();
0:         }
0: 
0:         return result;
commit:f988ca6
/////////////////////////////////////////////////////////////////////////
0:                 Throwable exception = null;
0:                 try {
0:                     protonConnection.open();
0:                     if (response.isException()) {
0:                         exception = ((ExceptionResponse) response).getException();
0:                         if (exception instanceof SecurityException) {
0:                             protonConnection.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
0:                         } else if (exception instanceof InvalidClientIDException) {
0:                             protonConnection.setCondition(new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage()));
0:                         } else {
0:                             protonConnection.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, exception.getMessage()));
0:                         }
0:                         protonConnection.close();
0:                 } finally {
0:                     if (response.isException()) {
0:                         amqpTransport.onException(IOExceptionSupport.create(exception));
0:                     }
0:                 }
commit:6e69319
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.amqp.message.AMQPNativeInboundTransformer;
0: import org.apache.activemq.transport.amqp.message.AMQPRawInboundTransformer;
0: import org.apache.activemq.transport.amqp.message.AutoOutboundTransformer;
0: import org.apache.activemq.transport.amqp.message.EncodedMessage;
0: import org.apache.activemq.transport.amqp.message.InboundTransformer;
0: import org.apache.activemq.transport.amqp.message.JMSMappingInboundTransformer;
0: import org.apache.activemq.transport.amqp.message.OutboundTransformer;
/////////////////////////////////////////////////////////////////////////
commit:8b36701
/////////////////////////////////////////////////////////////////////////
0:         AmqpInactivityMonitor monitor = transport.getInactivityMonitor();
0:         if (monitor != null) {
0:             monitor.setProtocolConverter(this);
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:         configureInactivityMonitor();
/////////////////////////////////////////////////////////////////////////
0:     private void configureInactivityMonitor() {
0:         AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();
0:         if (monitor == null) {
0:             return;
0:         }
0: 
0:         monitor.stopConnectChecker();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:2a0be3b
/////////////////////////////////////////////////////////////////////////
0:                     if (amqpTransport.isTrace()) {
0:                         LOG.trace("Processing event: {}", event.getType());
0:                     }
/////////////////////////////////////////////////////////////////////////
0:         public void close() {
0:             closed = true;
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 final ProducerContext producerContext = new ProducerContext(producerId, dest, anonymous);
/////////////////////////////////////////////////////////////////////////
0:                             producerContext.closed = true;
0:                             receiver.free();
/////////////////////////////////////////////////////////////////////////
0:                         consumerContext.closed = true;
0:                         sender.free();
commit:a090472
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol QUEUE_PREFIX = Symbol.valueOf("queue-prefix");
0:     private static final Symbol TOPIC_PREFIX = Symbol.valueOf("topic-prefix");
/////////////////////////////////////////////////////////////////////////
0:         this.protonConnection.setProperties(getConnetionProperties());
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Load and return a <code>Map<Symbol, Object></code> that contains the properties
0:      * that this connection supplies to incoming connections.
1:      *
0:      * @return the properties that are offered to the incoming connection.
1:      */
0:     protected Map<Symbol, Object> getConnetionProperties() {
0:         Map<Symbol, Object> properties = new HashMap<Symbol, Object>();
0: 
0:         properties.put(QUEUE_PREFIX, "queue://");
0:         properties.put(TOPIC_PREFIX, "topic://");
0: 
0:         return properties;
0:     }
0: 
commit:9bd070a
/////////////////////////////////////////////////////////////////////////
0:                 sender.setContext(null);
0:                 subscriptionsByConsumerId.remove(consumerId);
0: 
commit:61a3eab
/////////////////////////////////////////////////////////////////////////
0:     private final AmqpWireFormat amqpWireFormat;
/////////////////////////////////////////////////////////////////////////
0:         this.amqpWireFormat = transport.getWireFormat();
/////////////////////////////////////////////////////////////////////////
0: 
0:             if (amqpWireFormat.isHeaderValid(header)) {
0:                 LOG.trace("Connection from an AMQP v1.0 client initiated. {}", header);
0:             } else {
0:                 LOG.warn("Connection attempt from non AMQP v1.0 client. {}", header);
0:                 AmqpHeader reply = amqpWireFormat.getMinimallySupportedHeader();
0:                 amqpTransport.sendToAmqp(reply.getBuffer());
0:                 handleException(new AmqpProtocolException(
0:                     "Connection from client using unsupported AMQP attempted", true));
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:                             amqpTransport.getWireFormat().resetMagicRead();
0:                             amqpTransport.getWireFormat().resetMagicRead();
commit:9edf907
/////////////////////////////////////////////////////////////////////////
0:                 for (MessageDispatch md : dispatchedInTx) {
0:                     MessageAck pendingTxAck = new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
0:                     pendingTxAck.setFirstMessageId(md.getMessage().getMessageId());
0:                     pendingTxAck.setTransactionId(md.getMessage().getTransactionId());
0:                     LOG.trace("Sending commit Ack to ActiveMQ: {}", pendingTxAck);
0:                     sendToActiveMQ(pendingTxAck, new ResponseHandler() {
0:                         @Override
0:                         public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
0:                             if (response.isException()) {
0:                                 if (response.isException()) {
0:                                     Throwable exception = ((ExceptionResponse) response).getException();
0:                                     exception.printStackTrace();
0:                                     sender.close();
0:                                 }
0:                             }
0:                             pumpProtonToSocket();
0:                         }
0:                     });
0:                 }
commit:9797d3b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.amqp.messaging.Accepted;
0: import org.apache.qpid.proton.amqp.messaging.AmqpValue;
0: import org.apache.qpid.proton.amqp.messaging.Modified;
0: import org.apache.qpid.proton.amqp.messaging.Outcome;
0: import org.apache.qpid.proton.amqp.messaging.Rejected;
0: import org.apache.qpid.proton.amqp.messaging.Released;
0: import org.apache.qpid.proton.amqp.messaging.Target;
0: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
/////////////////////////////////////////////////////////////////////////
0:             if ((TerminusDurability.UNSETTLED_STATE.equals(source.getDurable()) ||
0:                  TerminusDurability.CONFIGURATION.equals(source.getDurable())) && dest.isTopic()) {
commit:c5f1835
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.amqp.messaging.Outcome;
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("onDelivery: TX delivery state = {}", state);
0:                 if (txState.getOutcome() != null) {
0:                     Outcome outcome = txState.getOutcome();
0:                     if (outcome instanceof Accepted) {
0:                             TransactionalState txAccepted = new TransactionalState();
0:                             txAccepted.setOutcome(Accepted.getInstance());
0:                             txAccepted.setTxnId(((TransactionalState) state).getTxnId());
0: 
0:                             delivery.disposition(txAccepted);
commit:0b148ad
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:adafdfe
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.SubscriptionInfo;
0: import org.apache.activemq.store.PersistenceAdapterSupport;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final AmqpTransport amqpTransport;
0:     private final BrokerService brokerService;
0: 
/////////////////////////////////////////////////////////////////////////
0:     public AmqpProtocolConverter(AmqpTransport transport, BrokerService brokerService) {
0:         this.brokerService = brokerService;
/////////////////////////////////////////////////////////////////////////
0: 
0:     @SuppressWarnings("unused")
0:     private List<SubscriptionInfo> lookupSubscriptions() throws AmqpProtocolException {
0:         List<SubscriptionInfo> subscriptions = Collections.emptyList();
0:         try {
0:             subscriptions = PersistenceAdapterSupport.listSubscriptions(brokerService.getPersistenceAdapter(), connectionInfo.getClientId());
0:         } catch (IOException e) {
0:             throw new AmqpProtocolException("Error loading store subscriptions", true, e);
0:         }
0: 
0:         return subscriptions;
0:     }
commit:e3377ed
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTempQueue;
0: import org.apache.activemq.command.ActiveMQTempTopic;
1: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerControl;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.LocalTransactionId;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.TransactionInfo;
/////////////////////////////////////////////////////////////////////////
0:                             sender.free();
commit:4881a84
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol JMS_MAPPING_VERSION = Symbol.valueOf("x-opt-jms-mapping-version");
0:     protected boolean useByteDestinationTypeAnnotation;
/////////////////////////////////////////////////////////////////////////
0:         useByteDestinationTypeAnnotation = transport.getWireFormat().isUseByteDestinationTypeAnnotation();
0: 
/////////////////////////////////////////////////////////////////////////
0:         Map<Symbol, Object> props = protonConnection.getRemoteProperties();
0:         if (props != null) {
0:             if (props.containsKey(JMS_MAPPING_VERSION)) {
0:                 useByteDestinationTypeAnnotation = true;
0:             }
0:         }
0: 
0:         if (useByteDestinationTypeAnnotation) {
0:             outboundTransformer.setUseByteDestinationTypeAnnotations(true);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:             if (useByteDestinationTypeAnnotation) {
0:                 inboundTransformer.setUseByteDestinationTypeAnnotations(true);
0:             }
commit:5a6129b
/////////////////////////////////////////////////////////////////////////
0: 
commit:0045682
/////////////////////////////////////////////////////////////////////////
0:                             sender.close();
0:                         } else {
0:                             sender.open();
commit:e90f1de
/////////////////////////////////////////////////////////////////////////
0:                 // Pass down any unexpected errors. Should this close the connection?
/////////////////////////////////////////////////////////////////////////
0:             // Pass down any unexpected async errors. Should this close the connection?
/////////////////////////////////////////////////////////////////////////
0:                 // Always override the AMQP client's MessageId with our own.  Preserve
0:                 // the original in the TextView property for later Ack.
/////////////////////////////////////////////////////////////////////////
0:                 // Lets handle the case where the expiration was set, but the timestamp
0:                 // was not set by the client. Lets assign the timestamp now, and adjust
0:                 // the expiration.
/////////////////////////////////////////////////////////////////////////
0:                 String targetNodeName = target.getAddress();
0:                 if (targetNodeName != null && targetNodeName.equals(amqpTransport.getWireFormat().getAnonymousNodeName())) {
/////////////////////////////////////////////////////////////////////////
0:                         // Topics can dispatch the same Message to more than one consumer
0:                         // so we must copy to prevent concurrent read / write to the same
commit:78cb112
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Destination;
/////////////////////////////////////////////////////////////////////////
0:     private static final int CHANNEL_MAX = 32767;
0:     private static final Symbol ANONYMOUS_RELAY = Symbol.valueOf("x-opt-anonymous-relay");
/////////////////////////////////////////////////////////////////////////
0: 
0:         // NOTE: QPid JMS client has a bug where the channel max is stored as a
0:         //       short value in the Connection class which means that if we allow
0:         //       the default channel max of 65535 to be sent then no new sessions
0:         //       can be created because the value would be -1 when checked.
0:         this.protonTransport.setChannelMax(CHANNEL_MAX);
0: 
0:         this.protonConnection.setProperties(getConnectionProperties());
0: 
1:     /**
0:      * Load and return a <code>Map<Symbol, Object></code> that contains the connection
0:      * properties which will allow the client to better communicate with this broker.
1:      *
0:      * @return the properties that are sent to new clients on connect.
1:      */
0:     protected Map<Symbol, Object> getConnectionProperties() {
0:         Map<Symbol, Object> properties = new HashMap<Symbol, Object>();
0: 
0:         properties.put(ANONYMOUS_RELAY, amqpTransport.getWireFormat().getAnonymousNodeName());
0: 
0:         return properties;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         private final boolean anonymous;
0:         public ProducerContext(ProducerId producerId, ActiveMQDestination destination, boolean anonymous) {
0:             this.anonymous = anonymous;
/////////////////////////////////////////////////////////////////////////
0:                 } else if (isAnonymous()) {
0:                     Destination toDestination = message.getJMSDestination();
0:                     if (toDestination == null || !(toDestination instanceof ActiveMQDestination)) {
0:                         Rejected rejected = new Rejected();
0:                         ErrorCondition condition = new ErrorCondition();
0:                         condition.setCondition(Symbol.valueOf("failed"));
0:                         condition.setDescription("Missing to field for message sent to an anonymous producer");
0:                         rejected.setError(condition);
0:                         delivery.disposition(rejected);
0:                         return;
0:                     }
/////////////////////////////////////////////////////////////////////////
0: 
0:         public boolean isAnonymous() {
0:             return anonymous;
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 ActiveMQDestination dest = null;
0:                 boolean anonymous = false;
0: 
0:                 if (target.getAddress().equals(amqpTransport.getWireFormat().getAnonymousNodeName())) {
0:                     anonymous = true;
0:                 } else if (target.getDynamic()) {
/////////////////////////////////////////////////////////////////////////
0:                 ProducerContext producerContext = new ProducerContext(producerId, dest, anonymous);
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:2d9475c
/////////////////////////////////////////////////////////////////////////
0:                         case LINK_REMOTE_DETACH:
commit:c70d752
/////////////////////////////////////////////////////////////////////////
0:                 final DeliveryState remoteState = delivery.getRemoteState();
/////////////////////////////////////////////////////////////////////////
0:                                 if (remoteState != null && remoteState instanceof TransactionalState) {
0:                                     TransactionalState txAccepted = new TransactionalState();
0:                                     txAccepted.setOutcome(Accepted.getInstance());
0:                                     txAccepted.setTxnId(((TransactionalState) remoteState).getTxnId());
0: 
0:                                     delivery.disposition(txAccepted);
0:                                 } else {
0:                                     delivery.disposition(Accepted.getInstance());
0:                                 }
0: 
commit:b2e6a41
/////////////////////////////////////////////////////////////////////////
0:         int maxFrameSize = transport.getWireFormat().getMaxAmqpFrameSize();
0:         if (maxFrameSize > AmqpWireFormat.NO_AMQP_MAX_FRAME_SIZE) {
0:             this.protonTransport.setMaxFrameSize(maxFrameSize);
0:         }
commit:3afde7b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQTempTopic;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             link.free();
/////////////////////////////////////////////////////////////////////////
0:         session.free();
commit:644b96a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.Proton;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.engine.Event.Type.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected Transport protonTransport = Proton.transport();
0:     protected Connection protonConnection = Proton.connection();
/////////////////////////////////////////////////////////////////////////
0:                         case CONNECTION_REMOTE_OPEN:
0:                         case CONNECTION_REMOTE_CLOSE:
0:                         case SESSION_REMOTE_OPEN:
0:                         case SESSION_REMOTE_CLOSE:
0:                         case LINK_REMOTE_OPEN:
0:                         case LINK_REMOTE_CLOSE:
/////////////////////////////////////////////////////////////////////////
0:             Message msg = Proton.message();
commit:f2653e6
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger TRACE_FRAMES = AmqpTransportFilter.TRACE_FRAMES;
0:     private static final byte[] EMPTY_BYTE_ARRAY = new byte[] {};
0:     private static final ProtonFactoryLoader<MessageFactory> messageFactoryLoader = new ProtonFactoryLoader<MessageFactory>(MessageFactory.class);
0:     protected int prefetch = 100;
0:     protected EngineFactory engineFactory = new EngineFactoryImpl();
0:     protected Transport protonTransport = engineFactory.createTransport();
0:     protected Connection protonConnection = engineFactory.createConnection();
0:     protected MessageFactory messageFactory = messageFactoryLoader.loadFactory();
0:     protected Collector eventCollector = new CollectorImpl();
0:         // AMQ-4914 - Setting the max frame size to large stalls out the QPid
0:         // client on sends or
0:         // consume due to no session credit. Once fixed we should set this value
0:         // using
0:         // the configured maxFrameSize on the URI.
0:         // int maxFrameSize = transport.getWireFormat().getMaxFrameSize() >
0:         // Integer.MAX_VALUE ?
0:         // Integer.MAX_VALUE : (int)
0:         // transport.getWireFormat().getMaxFrameSize();
/////////////////////////////////////////////////////////////////////////
0:                             // We can't really auth at this point since we don't
0:                             // know the client id yet.. :(
/////////////////////////////////////////////////////////////////////////
0:                 // Pass down any unexpected errors. Should this close the
0:                 // connection?
/////////////////////////////////////////////////////////////////////////
0:             // Pass down any unexpected async errors. Should this close the
0:             // connection?
/////////////////////////////////////////////////////////////////////////
0:         public void onClose() throws Exception {
0:         }
0:         public void drainCheck() {
0:         }
/////////////////////////////////////////////////////////////////////////
0:         void doCommit() throws Exception {
0:         }
0:         void doRollback() throws Exception {
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 // Always override the AMQP client's MessageId with our own.
0:                 // Preserve the
/////////////////////////////////////////////////////////////////////////
0:                 // Lets handle the case where the expiration was set, but the
0:                 // timestamp
0:                 // was not set by the client. Lets assign the timestamp now, and
0:                 // adjust the
/////////////////////////////////////////////////////////////////////////
0:                                     LOG.trace("Sending more credit ({}) to producer: {}", prefetch - receiver.getCredit(), producerId);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.trace("Sending more credit ({}) to producer: {}", prefetch - receiver.getCredit(), producerId);
/////////////////////////////////////////////////////////////////////////
0:                         // Topics can dispatch the same Message to more than one
0:                         // consumer
0:                         // so we must copy to prevent concurrent read / write to
0:                         // the same
/////////////////////////////////////////////////////////////////////////
0:                 // we are going to settle, but redeliver.. we we won't yet ack
0:                 // to ActiveMQ
/////////////////////////////////////////////////////////////////////////
0:                     // Store the message sent in this TX we might need to
0:                     // re-send on rollback
/////////////////////////////////////////////////////////////////////////
0:             if (info.isBrowser() && !endOfBrowse)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ba519d8
/////////////////////////////////////////////////////////////////////////
0:         session.setIncomingCapacity(Integer.MAX_VALUE);
commit:9b6f419
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("Sending {} bytes out", toWrite.limit());
/////////////////////////////////////////////////////////////////////////
0:         session.setIncomingCapacity(AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE * prefetch);
/////////////////////////////////////////////////////////////////////////
0:                 if (!delivery.remotelySettled()) {
0:                     sendToActiveMQ(message, new ResponseHandler() {
0:                         @Override
0:                         public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                             } else {
0:                                 if (receiver.getCredit() <= (prefetch * .2)) {
0:                                     LOG.trace("Sending more credit ({}) to producer: {}",
0:                                               prefetch - receiver.getCredit(), producerId);
0:                                     receiver.flow(prefetch - receiver.getCredit());
0:                                 }
0: 
0:                                 delivery.disposition(Accepted.getInstance());
0:                                 delivery.settle();
0: 
0:                             pumpProtonToSocket();
0:                     });
0:                 } else {
0:                     if (receiver.getCredit() <= (prefetch * .2)) {
0:                         LOG.trace("Sending more credit ({}) to producer: {}",
0:                                   prefetch - receiver.getCredit(), producerId);
0:                         receiver.flow(prefetch - receiver.getCredit());
0:                     sendToActiveMQ(message, null);
0:                 }
commit:b9d51bf
/////////////////////////////////////////////////////////////////////////
0:         private final byte[] recvBuffer = new byte[1024 * 8];
0: 
/////////////////////////////////////////////////////////////////////////
0:             while ((count = receiver.recv(recvBuffer, 0, recvBuffer.length)) > 0) {
0:                 current.write(recvBuffer, 0, count);
commit:38a86b4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.engine.Collector;
0: import org.apache.qpid.proton.engine.Event;
0: import org.apache.qpid.proton.engine.impl.CollectorImpl;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     Collector eventCollector = new CollectorImpl();
/////////////////////////////////////////////////////////////////////////
0:         this.protonConnection.collect(eventCollector);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 Event event = null;
0:                 while ((event = eventCollector.peek()) != null) {
0:                     switch (event.getType()) {
0:                         case CONNECTION_REMOTE_STATE:
0:                             processConnectionEvent(event.getConnection());
0:                             break;
0:                         case SESSION_REMOTE_STATE:
0:                             processSessionEvent(event.getSession());
0:                             break;
0:                         case LINK_REMOTE_STATE:
0:                             processLinkEvent(event.getLink());
0:                             break;
0:                         case LINK_FLOW:
0:                             Link link = event.getLink();
0:                             ((AmqpDeliveryListener) link.getContext()).drainCheck();
0:                             break;
0:                         case DELIVERY:
0:                             processDelivery(event.getDelivery());
0:                             break;
0:                         default:
0:                             break;
0:                     eventCollector.pop();
/////////////////////////////////////////////////////////////////////////
0:     protected void processConnectionEvent(Connection connection) throws Exception {
0:         EndpointState remoteState = connection.getRemoteState();
0:         if (remoteState == EndpointState.ACTIVE) {
0:             onConnectionOpen();
0:         } else if (remoteState == EndpointState.CLOSED) {
0:             doClose();
0:         }
0:     }
0: 
0:     protected void processLinkEvent(Link link) throws Exception {
0:         EndpointState remoteState = link.getRemoteState();
0:         if (remoteState == EndpointState.ACTIVE) {
0:             onLinkOpen(link);
0:         } else if (remoteState == EndpointState.CLOSED) {
0:             ((AmqpDeliveryListener) link.getContext()).onClose();
0:             link.close();
0:         }
0:     }
0: 
0:     protected void processSessionEvent(Session session) throws Exception {
0:         EndpointState remoteState = session.getRemoteState();
0:         if (remoteState == EndpointState.ACTIVE) {
0:             onSessionOpen(session);
0:         } else if (remoteState == EndpointState.CLOSED) {
0:             // TODO - close links?
0:             onSessionClose(session);
0:         }
0:     }
0: 
0:     protected void processDelivery(Delivery delivery) throws Exception {
0:         if (!delivery.isPartial()) {
0:             AmqpDeliveryListener listener = (AmqpDeliveryListener) delivery.getLink().getContext();
0:             if (listener != null) {
0:                 listener.onDelivery(delivery);
0:             }
0:         }
0:     }
0: 
commit:da07a11
/////////////////////////////////////////////////////////////////////////
0:             // Always override the AMQP client's MessageId with our own.  Preserve the
0:             // original in the TextView property for later Ack.
0:             MessageId messageId = new MessageId(producerId, messageIdGenerator.getNextSequenceId());
0: 
0:             MessageId amqpMessageId = message.getMessageId();
0:             if (amqpMessageId != null) {
0:                 if (amqpMessageId.getTextView() != null) {
0:                     messageId.setTextView(amqpMessageId.getTextView());
0:                 } else {
0:                     messageId.setTextView(amqpMessageId.toString());
0:                 }
0:             message.setMessageId(messageId);
/////////////////////////////////////////////////////////////////////////
0:             // was not set by the client. Lets assign the timestamp now, and adjust the
0:             if (message.getExpiration() != 0) {
0:                 if (message.getTimestamp() == 0) {
0:                     message.setExpiration(message.getTimestamp() + message.getExpiration());
commit:13b33da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.ProtonFactoryLoader;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.message.Message;
0: import org.apache.qpid.proton.message.MessageFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final ProtonFactoryLoader<MessageFactory> messageFactoryLoader =
0:         new ProtonFactoryLoader<MessageFactory>(MessageFactory.class);
0: 
0:     MessageFactory messageFactory = messageFactoryLoader.loadFactory();
/////////////////////////////////////////////////////////////////////////
0:             Message msg = messageFactory.createMessage();
commit:e06e23b
/////////////////////////////////////////////////////////////////////////
0:                         } else {
0:                             delivery.disposition(Accepted.getInstance());
commit:1671523
/////////////////////////////////////////////////////////////////////////
0:                             if (exception instanceof SecurityException) {
0:                                 receiver.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
0:                             } else {
0:                                 receiver.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                             if (exception instanceof SecurityException) {
0:                                 sender.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
0:                             } else {
0:                                 sender.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                         if (exception instanceof SecurityException) {
0:                             sender.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
0:                         } else if (exception instanceof InvalidSelectorException) {
0:                             sender.setCondition(new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage()));
0:                         } else {
0:                             sender.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
commit:da5d0d8
/////////////////////////////////////////////////////////////////////////
commit:da72aa6
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidClientIDException;
/////////////////////////////////////////////////////////////////////////
0:                     if (exception instanceof SecurityException) {
0:                         protonConnection.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
0:                     } else if (exception instanceof InvalidClientIDException) {
0:                         protonConnection.setCondition(new ErrorCondition(AmqpError.INVALID_FIELD, exception.getMessage()));
0:                     } else {
0:                         protonConnection.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, exception.getMessage()));
0:                     }
commit:e102e64
/////////////////////////////////////////////////////////////////////////
0: import java.nio.ByteBuffer;
/////////////////////////////////////////////////////////////////////////
0:                 ByteBuffer toWrite = protonTransport.getOutputBuffer();
0:                 if (toWrite != null && toWrite.hasRemaining()) {
0: //                  // System.out.println("writing: " + buffer.toString().substring(5).replaceAll("(..)", "$1 "));
0:                     amqpTransport.sendToAmqp(toWrite);
0:                     protonTransport.outputConsumed();
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("SASL [PLAIN] Handshake complete.");
0:                             LOG.debug("SASL [ANONYMOUS] Handshake complete.");
commit:1934499
/////////////////////////////////////////////////////////////////////////
0:                 if (md.getMessage() != null) {
0:                     LOG.trace("Finished Dispatch of MessageId: {} to consumer", md.getMessage().getMessageId());
0:                 }
commit:efc51fa
/////////////////////////////////////////////////////////////////////////
0:                     delivery.disposition(Accepted.getInstance());
commit:283cdd0
/////////////////////////////////////////////////////////////////////////
0: 
0:         int maxFrameSize = AmqpWireFormat.DEFAULT_MAX_FRAME_SIZE;
0: 
0:         // AMQ-4914 - Setting the max frame size to large stalls out the QPid client on sends or
0:         //            consume due to no session credit.  Once fixed we should set this value using
0:         //            the configured maxFrameSize on the URI.
0:         //int maxFrameSize = transport.getWireFormat().getMaxFrameSize() > Integer.MAX_VALUE ?
0:         //    Integer.MAX_VALUE : (int) transport.getWireFormat().getMaxFrameSize();
0: 
0:         this.protonTransport.setMaxFrameSize(maxFrameSize);
commit:3af70ba
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ShutdownInfo;
/////////////////////////////////////////////////////////////////////////
0:             sendToActiveMQ(new ShutdownInfo(), null);
commit:c387e84
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0: 
0:                     ActiveMQMessage temp = null;
0: 
0:                         // Topics can dispatch the same Message to more than one consumer
0:                         // so we must copy to prevent concurrent read / write to the same
0:                         // message object.
0:                         if (md.getDestination().isTopic()) {
0:                             synchronized (md.getMessage()) {
0:                                 temp = (ActiveMQMessage) md.getMessage().copy();
0:                             }
0:                         } else {
0:                             temp = (ActiveMQMessage) md.getMessage();
0:                         }
0: 
0:                         if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {
0:                             temp.setProperty(MESSAGE_FORMAT_KEY, 0);
0: 
0:                     final ActiveMQMessage jms = temp;
commit:fba8e25
/////////////////////////////////////////////////////////////////////////
0:             if (tag != null && tag.length > 0 && delivery.remotelySettled()) {
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:                     TRACE_FRAMES.trace("{} | RECV: {}", AmqpProtocolConverter.this.amqpTransport.getRemoteAddress(), transportFrame.getBody());
0:                     TRACE_FRAMES.trace("{} | SENT: {}", AmqpProtocolConverter.this.amqpTransport.getRemoteAddress(), transportFrame.getBody());
/////////////////////////////////////////////////////////////////////////
0:                 if (md.getMessage() != null) {
0:                     LOG.trace("Dispatching MessageId: {} to consumer", md.getMessage().getMessageId());
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Do not know how to process ActiveMQ Command {}", command);
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("Session {} closed", sessionContext.sessionId);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Unknown transformer type {} using native one instead", transformer);
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("Inbound Message:{} from Producer:{}", message.getMessageId(), producerId + ":" + messageId.getProducerSequenceId());
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("COORDINATOR received: {}, [{}]", action, buffer);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("started transaction {}", txid);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("rollback transaction {}", txid);
0:                     LOG.trace("commit transaction {}", txid);
/////////////////////////////////////////////////////////////////////////
0:                         LOG.debug("TX: {} settling {}", operation, action);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("Sending Ack to ActiveMQ: {}", ack);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("onDelivery: TX delivery state = {}", state);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("onDelivery: accepted state = {}", state);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("onDelivery: Rejected state = {}, delivery count now {}", state, md.getRedeliveryCounter());
0:                     LOG.trace("onDelivery: Released state = {}", state);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace("onDelivery: Modified state = {}, delivery count now {}", state, md.getRedeliveryCounter());
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("Sending commit Ack to ActiveMQ: {}", pendingTxAck);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("Rolling back {} messages for redelivery. ", dispatchedInTx.size());
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Exception detail", exception);
commit:ebe54c4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.amqp.transport.AmqpError;
0: import org.apache.qpid.proton.engine.Connection;
0: import org.apache.qpid.proton.engine.EngineFactory;
0: import org.apache.qpid.proton.engine.Transport;
0: import org.apache.qpid.proton.engine.impl.EngineFactoryImpl;
/////////////////////////////////////////////////////////////////////////
0:     EngineFactory engineFactory = new EngineFactoryImpl();
0:     Transport protonTransport = engineFactory.createTransport();
0:     Connection protonConnection = engineFactory.createConnection();
/////////////////////////////////////////////////////////////////////////
0:             ((TransportImpl) protonTransport).setProtocolTracer(new ProtocolTracer() {
/////////////////////////////////////////////////////////////////////////
0:                     protonConnection.setCondition(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:                             receiver.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:             receiver.setCondition(new ErrorCondition(Symbol.getSymbol(exception.getSymbolicName()), exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:         final String MESSAGE_FORMAT_KEY = outboundTransformer.getPrefixVendor() + "MESSAGE_FORMAT";
/////////////////////////////////////////////////////////////////////////
0:                     if (md.getMessage() != null) {
0:                         org.apache.activemq.command.Message message = md.getMessage();
0:                         if (!message.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {
0:                             message.setProperty(MESSAGE_FORMAT_KEY, 0);
0:                         }
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                             sender.setCondition(new ErrorCondition(AmqpError.INVALID_FIELD, e.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:                             sender.setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:                         Symbol condition = AmqpError.INTERNAL_ERROR;
0:                             condition = AmqpError.INVALID_FIELD;
0:                         sender.setCondition(new ErrorCondition(condition, exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:             sender.setCondition(new ErrorCondition(Symbol.getSymbol(e.getSymbolicName()), e.getMessage()));
commit:d2f4d76
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (TerminusDurability.UNSETTLED_STATE.equals(source.getDurable()) && dest.isTopic()) {
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:84c7c3c
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalArgumentException("Invalid Filter Ids array passed: " + filterIds);
/////////////////////////////////////////////////////////////////////////
0:                 Object descriptor = describedType.getDescriptor();
commit:6466ae2
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidDestinationException;
/////////////////////////////////////////////////////////////////////////
0:                             } else if (exception instanceof InvalidDestinationException){
0:                                 sender.setCondition(new ErrorCondition(AmqpError.NOT_FOUND, exception.getMessage()));
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:5d77b39
/////////////////////////////////////////////////////////////////////////
0:         int credit = link.getCredit();
/////////////////////////////////////////////////////////////////////////
0:                     // set zero value for now and change to the consumer's preference
0:                     consumerInfo.setPrefetchSize(0);
commit:0ca376d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.amqp.messaging.*;
/////////////////////////////////////////////////////////////////////////
0:         if (context instanceof ConsumerContext) {
0:             // change consumer prefetch if it's not been already set using
0:             // transport connector property or consumer preference
0:             if (consumerContext.consumerPrefetch == 0 && credit > 0) {
/////////////////////////////////////////////////////////////////////////
0:         private MessageId lastDispatched;
/////////////////////////////////////////////////////////////////////////
0:                                 if (receiver.getCredit() <= (producerCredit * .2)) {
0:                                     LOG.trace("Sending more credit ({}) to producer: {}", producerCredit - receiver.getCredit(), producerId);
0:                                     receiver.flow(producerCredit - receiver.getCredit());
/////////////////////////////////////////////////////////////////////////
0:                     if (receiver.getCredit() <= (producerCredit * .2)) {
0:                         LOG.trace("Sending more credit ({}) to producer: {}", producerCredit - receiver.getCredit(), producerId);
0:                         receiver.flow(producerCredit - receiver.getCredit());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         public int consumerPrefetch = 0;
0:         private long lastDeliveredSequenceId;
/////////////////////////////////////////////////////////////////////////
0:                 RemoveInfo removeCommand = new RemoveInfo(consumerId);
0:                 removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
0:                 sendToActiveMQ(removeCommand, null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 lastDeliveredSequenceId = md.getMessage().getMessageId().getBrokerSequenceId();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             int senderCredit = sender.getRemoteCredit();
0:             if (prefetch != 0) {
0:                 // use the value configured on the transport connector
0:                 // this value will not be changed to the consumer's preference
0:                 consumerInfo.setPrefetchSize(prefetch);
0:                 consumerContext.consumerPrefetch = prefetch;
0:             } else {
0:                 if (senderCredit != 0) {
0:                     // set the prefetch to the value of the remote credit
0:                     // and ignore the later changes
0:                     consumerInfo.setPrefetchSize(senderCredit);
0:                     consumerContext.consumerPrefetch = senderCredit;
0:                 } else {
0:                     // set default value for now and change to the consumer's preference
0:                     // on the first flow packet
0:                     consumerInfo.setPrefetchSize(AMQPProtocolDiscriminator.DEFAULT_PREFETCH);
0:                 }
0:             }
0:             consumerContext.credit = senderCredit;
commit:5cd56e7
/////////////////////////////////////////////////////////////////////////
0:             AmqpDeliveryListener context = (AmqpDeliveryListener) link.getContext();
0:             if (context != null) {
0:                 context.onClose();
0:             }
commit:162f9fc
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol ANONYMOUS_RELAY = Symbol.valueOf("ANONYMOUS-RELAY");
/////////////////////////////////////////////////////////////////////////
0:         this.protonConnection.setOfferedCapabilities(getConnectionCapabilitiesOffered());
1:     /**
0:      * Load and return a <code>[]Symbol</code> that contains the connection capabilities
0:      * offered to new connections
1:      *
0:      * @return the capabilities that are offered to new clients on connect.
1:      */
0:     protected Symbol[] getConnectionCapabilitiesOffered() {
0:         return new Symbol[]{ ANONYMOUS_RELAY };
0:     }
0: 
commit:741b739
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if ((targetNodeName == null || targetNodeName.length() == 0) && !target.getDynamic()) {
commit:ab3de0c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
0:     protected int producerCredit;
/////////////////////////////////////////////////////////////////////////
0:                             processLinkFlow(event.getLink());
/////////////////////////////////////////////////////////////////////////
0:     protected void processLinkFlow(Link link) throws Exception {
0:         Object context = link.getContext();
0:         int credit = link.getRemoteCredit();
0:         if (context != null && context instanceof ConsumerContext) {
0:             ConsumerContext consumerContext = (ConsumerContext)context;
0:             // change ActiveMQ consumer prefetch if needed
0:             if (consumerContext.credit == 0 && consumerContext.consumerPrefetch != credit && credit > 0) {
0:                 ConsumerControl control = new ConsumerControl();
0:                 control.setConsumerId(consumerContext.consumerId);
0:                 control.setDestination(consumerContext.destination);
0:                 control.setPrefetch(credit);
0:                 consumerContext.consumerPrefetch = credit;
0:                 sendToActiveMQ(control, null);
0:             }
0:             consumerContext.credit = credit;
0:         }
0:         ((AmqpDeliveryListener) link.getContext()).drainCheck();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         int flow = producerCredit;
/////////////////////////////////////////////////////////////////////////
0:         public ActiveMQDestination destination;
0:         public int credit;
0:         public int consumerPrefetch;
/////////////////////////////////////////////////////////////////////////
0:             consumerContext.destination = dest;
0:             consumerInfo.setPrefetchSize(sender.getRemoteCredit());
0:             consumerContext.credit = sender.getRemoteCredit();
0:             consumerContext.consumerPrefetch = consumerInfo.getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
0: 
0:     @Override
0:     public void setProducerCredit(int producerCredit) {
0:         this.producerCredit = producerCredit;
0:     }
commit:838bbeb
/////////////////////////////////////////////////////////////////////////
0:     protected int prefetch;
/////////////////////////////////////////////////////////////////////////
0:         int flow = prefetch;
0:         // use client's preference if set
0:         if (receiver.getRemoteCredit() != 0) {
0:             flow = receiver.getRemoteCredit();
0:         }
0:                 receiver.flow(flow);
/////////////////////////////////////////////////////////////////////////
0:                 receiver.flow(flow);
/////////////////////////////////////////////////////////////////////////
0:             // use client's preference if set
0:             if (sender.getRemoteCredit() != 0) {
0:                 consumerInfo.setPrefetchSize(sender.getRemoteCredit());
0:             } else {
0:                 consumerInfo.setPrefetchSize(prefetch);
0:             }
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void setPrefetch(int prefetch) {
0:         this.prefetch = prefetch;
0:     }
commit:e9126f3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQTempTopic;
/////////////////////////////////////////////////////////////////////////
0: 
0:                 // TODO - we need to cast TempTopic to TempQueue as we internally are using temp queues for all dynamic destinations
0:                 // we need to figure out how to support both queues and topics
0:                 if (message.getJMSReplyTo() != null && message.getJMSReplyTo() instanceof ActiveMQTempTopic) {
0:                     ActiveMQTempTopic tempTopic = (ActiveMQTempTopic)message.getJMSReplyTo();
0:                     message.setJMSReplyTo(new ActiveMQTempQueue(tempTopic.getPhysicalName()));
0:                 }
commit:ff64b14
/////////////////////////////////////////////////////////////////////////
0:         private boolean closed;
/////////////////////////////////////////////////////////////////////////
0:             if (!closed) {
0:                 EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), buffer.data, buffer.offset, buffer.length);
0:                 final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);
0:                 current = null;
0:                 if (destination != null) {
0:                     message.setJMSDestination(destination);
0:                 message.setProducerId(producerId);
0:                 // Always override the AMQP client's MessageId with our own.  Preserve the
0:                 // original in the TextView property for later Ack.
0:                 MessageId messageId = new MessageId(producerId, messageIdGenerator.getNextSequenceId());
0:                 MessageId amqpMessageId = message.getMessageId();
0:                 if (amqpMessageId != null) {
0:                     if (amqpMessageId.getTextView() != null) {
0:                         messageId.setTextView(amqpMessageId.getTextView());
0:                     } else {
0:                         messageId.setTextView(amqpMessageId.toString());
0: 
0:                 message.setMessageId(messageId);
0: 
0:                 LOG.trace("Inbound Message:{} from Producer:{}", message.getMessageId(), producerId + ":" + messageId.getProducerSequenceId());
0: 
0:                 DeliveryState remoteState = delivery.getRemoteState();
0:                 if (remoteState != null && remoteState instanceof TransactionalState) {
0:                     TransactionalState s = (TransactionalState) remoteState;
0:                     long txid = toLong(s.getTxnId());
0:                     message.setTransactionId(new LocalTransactionId(connectionId, txid));
0:                 }
0: 
0:                 // Lets handle the case where the expiration was set, but the timestamp
0:                 // was not set by the client. Lets assign the timestamp now, and adjust the
0:                 // expiration.
0:                 if (message.getExpiration() != 0) {
0:                     if (message.getTimestamp() == 0) {
0:                         message.setTimestamp(System.currentTimeMillis());
0:                         message.setExpiration(message.getTimestamp() + message.getExpiration());
0:                     }
0:                 }
0: 
0:                 message.onSend();
0:                 sendToActiveMQ(message, new ResponseHandler() {
0:                     @Override
0:                     public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
0:                         if (!delivery.remotelySettled()) {
0:                             if (response.isException()) {
0:                                 ExceptionResponse er = (ExceptionResponse) response;
0:                                 Rejected rejected = new Rejected();
0:                                 ErrorCondition condition = new ErrorCondition();
0:                                 condition.setCondition(Symbol.valueOf("failed"));
0:                                 condition.setDescription(er.getException().getMessage());
0:                                 rejected.setError(condition);
0:                                 delivery.disposition(rejected);
0:                             }
0:                         }
0:                         receiver.flow(1);
0:                         delivery.disposition(Accepted.getInstance());
0:                         delivery.settle();
0:                         pumpProtonToSocket();
0:                     }
0:                 });
0:             }
0:         }
0: 
0:         @Override
0:         public void onClose() throws Exception {
0:             if (!closed) {
0:                 sendToActiveMQ(new RemoveInfo(producerId), null);
0:             }
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:875822d
/////////////////////////////////////////////////////////////////////////
0:             // Lets handle the case where the expiration was set, but the timestamp
0:             // was not set by the client.  Lets assign the timestamp now, and adjust the
0:             // expiration.
0:             if( message.getExpiration()!= 0 ) {
0:                 if( message.getTimestamp()==0 ) {
0:                     message.setTimestamp(System.currentTimeMillis());
0:                     message.setExpiration(message.getTimestamp()+message.getExpiration());
0:                 }
0:             }
0: 
commit:8d5b9a5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: class AmqpProtocolConverter implements IAmqpProtocolConverter {
/////////////////////////////////////////////////////////////////////////
0:     public AmqpProtocolConverter(AmqpTransport transport) {
0:     public void updateTracer() {
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:                 public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:             public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                 public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                     public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                     public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                     public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                     public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                     public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                 public void onResponse(IAmqpProtocolConverter converter, Response response) throws IOException {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:0f6561b
/////////////////////////////////////////////////////////////////////////
0:         final Map<ConsumerId, ConsumerContext> consumers = new HashMap<ConsumerId, ConsumerContext>();
/////////////////////////////////////////////////////////////////////////
0:                 for (ConsumerContext consumer : context.consumers.values()) {
/////////////////////////////////////////////////////////////////////////
0:                 for (ConsumerContext consumer : context.consumers.values()) {
/////////////////////////////////////////////////////////////////////////
0: 
0:                 AmqpSessionContext session = (AmqpSessionContext) sender.getSession().getContext();
0:                 if (session != null) {
0:                     session.consumers.remove(info.getConsumerId());
0:                 }
0: 
/////////////////////////////////////////////////////////////////////////
0:                         sessionContext.consumers.put(id, consumerContext);
commit:ed5d841
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final LinkedList<ConsumerContext> consumers = new LinkedList<ConsumerContext>();
0: 
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Do not know how to process ActiveMQ Command " + command);
0:             }
/////////////////////////////////////////////////////////////////////////
0: 
0:         public void onClose() throws Exception {}
0:         public void drainCheck() {}
0: 
0:         abstract void doCommit() throws Exception;
0: 
0:         abstract void doRollback() throws Exception;
/////////////////////////////////////////////////////////////////////////
0:         @Override
0:         void doCommit() throws Exception {}
0: 
0:         @Override
0:         void doRollback() throws Exception {}
0: 
/////////////////////////////////////////////////////////////////////////
0:     long nextTransactionId = 1;
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             final Object action = ((AmqpValue) msg.getBody()).getValue();
/////////////////////////////////////////////////////////////////////////
0:                 final byte operation;
/////////////////////////////////////////////////////////////////////////
0: 
0:                 AmqpSessionContext context = (AmqpSessionContext) receiver.getSession().getContext();
0:                 for (ConsumerContext consumer : context.consumers) {
0:                     if (operation == TransactionInfo.ROLLBACK) {
0:                         consumer.doRollback();
0:                     } else {
0:                         consumer.doCommit();
0:                     }
0:                 }
0: 
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("TX: {} settling {}", operation, action);
0:                         }
0: 
0:                 for (ConsumerContext consumer : context.consumers) {
0:                     if (operation == TransactionInfo.ROLLBACK) {
0:                         consumer.pumpOutbound();
0:                     }
0:                 }
0: 
/////////////////////////////////////////////////////////////////////////
0:         protected LinkedList<MessageDispatch> dispatchedInTx = new LinkedList<MessageDispatch>();
/////////////////////////////////////////////////////////////////////////
0:                 // Lock to prevent stepping on TX redelivery
0:                 synchronized (outbound) {
0:                     outbound.addLast(md);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:         private void settle(final Delivery delivery, final int ackType) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                     LocalTransactionId localTxId = new LocalTransactionId(connectionId, txid);
0:                     ack.setTransactionId(localTxId);
0: 
0:                     // Store the message sent in this TX we might need to re-send on rollback
0:                     md.getMessage().setTransactionId(localTxId);
0:                     dispatchedInTx.addFirst(md);
0:                     LOG.trace("Sending Ack to ActiveMQ: {}", ack);
/////////////////////////////////////////////////////////////////////////
0:             DeliveryState state = delivery.getRemoteState();
0: 
0:             if (state instanceof TransactionalState) {
0:                 TransactionalState txState = (TransactionalState) state;
0:                 if (txState.getOutcome() instanceof DeliveryState) {
0: 
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("onDelivery: TX delivery state = {}", state);
0:                     }
0: 
0:                     state = (DeliveryState) txState.getOutcome();
0: 
0:                     if (state instanceof Accepted) {
0:                         if (!delivery.remotelySettled()) {
0:                             delivery.disposition(new Accepted());
0:                         }
0:                         settle(delivery, MessageAck.DELIVERED_ACK_TYPE);
0:                     }
0:             } else {
0:                 if (state instanceof Accepted) {
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("onDelivery: accepted state = {}", state);
0:                     }
0: 
0:                     if (!delivery.remotelySettled()) {
0:                         delivery.disposition(new Accepted());
0:                     }
0:                     settle(delivery, MessageAck.INDIVIDUAL_ACK_TYPE);
0:                 } else if (state instanceof Rejected) {
0:                     // re-deliver /w incremented delivery counter.
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("onDelivery: Rejected state = {}, delivery count now {}", state, md.getRedeliveryCounter());
0:                     }
0:                     settle(delivery, -1);
0:                 } else if (state instanceof Released) {
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("onDelivery: Released state = {}", state);
0:                     }
0:                     // re-deliver && don't increment the counter.
0:                     settle(delivery, -1);
0:                 } else if (state instanceof Modified) {
0:                     Modified modified = (Modified) state;
0:                     if (modified.getDeliveryFailed()) {
0:                         // increment delivery counter..
0:                         md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
0:                     }
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("onDelivery: Modified state = {}, delivery count now {}", state, md.getRedeliveryCounter());
0:                     }
0:                     byte ackType = -1;
0:                     Boolean undeliverableHere = modified.getUndeliverableHere();
0:                     if (undeliverableHere != null && undeliverableHere) {
0:                         // receiver does not want the message..
0:                         // perhaps we should DLQ it?
0:                         ackType = MessageAck.POSION_ACK_TYPE;
0:                     }
0:                     settle(delivery, ackType);
0: 
0:         @Override
0:         void doCommit() throws Exception {
0:             if (!dispatchedInTx.isEmpty()) {
0: 
0:                 MessageDispatch md = dispatchedInTx.getFirst();
0:                 MessageAck pendingTxAck = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, dispatchedInTx.size());
0:                 pendingTxAck.setTransactionId(md.getMessage().getTransactionId());
0:                 pendingTxAck.setFirstMessageId(dispatchedInTx.getLast().getMessage().getMessageId());
0: 
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace("Sending commit Ack to ActiveMQ: {}", pendingTxAck);
0:                 }
0: 
0:                 dispatchedInTx.clear();
0: 
0:                 sendToActiveMQ(pendingTxAck, new ResponseHandler() {
0:                     @Override
0:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                         if (response.isException()) {
0:                             if (response.isException()) {
0:                                 Throwable exception = ((ExceptionResponse) response).getException();
0:                                 exception.printStackTrace();
0:                                 sender.close();
0:                             }
0:                         }
0:                         pumpProtonToSocket();
0:                     }
0:                 });
0:             }
0:         }
0: 
0:         @Override
0:         void doRollback() throws Exception {
0:             synchronized (outbound) {
0: 
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace("Rolling back {} messages for redelivery. ", dispatchedInTx.size());
0:                 }
0: 
0:                 for (MessageDispatch md : dispatchedInTx) {
0:                     md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
0:                     md.getMessage().setTransactionId(null);
0:                     outbound.addFirst(md);
0:                 }
0: 
0:                 dispatchedInTx.clear();
0:             }
0:         }
0:     @SuppressWarnings("rawtypes")
0:     void onSenderOpen(final Sender sender, final AmqpSessionContext sessionContext) {
0:             final ConsumerContext consumerContext = new ConsumerContext(id, sender);
/////////////////////////////////////////////////////////////////////////
0:                         sessionContext.consumers.add(consumerContext);
commit:bbab23e
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("Inbound Message:{} from Producer:{}", message.getMessageId(),
0:                     producerId + ":" + messageId.getProducerSequenceId());
commit:205c6be
/////////////////////////////////////////////////////////////////////////
0:                 // End of Queue Browse will have no Message object.
0:                 if (LOG.isTraceEnabled() && md.getMessage() != null) {
0:                 } else {
0:                     LOG.trace("Dispatching End of Browse Command to consumer {}", md.getConsumerId());
commit:44e3c22
/////////////////////////////////////////////////////////////////////////
0:                 message.setMessageId(messageId);
commit:3513728
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug(String.format("%s | RECV: %s",
0:                             amqpTransport.getRemoteAddress(), transportFrame.getBody()));
0:                     }
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug(String.format("%s | SENT: %s",
0:                             amqpTransport.getRemoteAddress(), transportFrame.getBody()));
0:                     }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("Session {} closed", sessionContext.sessionId);
0:             }
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Delivery was not readable!");
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("COORDINATOR received: " + action + ", [" + buffer + "]");
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace("started transaction " + txid);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("rollback transaction " + txid);
0:                     }
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("commit transaction " + txid);
0:                     }
commit:d338d8a
/////////////////////////////////////////////////////////////////////////
0:             if (messageId == null) {
0:                 messageId = new MessageId();
0:             }
0: 
commit:059258b
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("Inbound Message:{} from Producer:{}", message.getMessageId(), producerId);
0:             }
0: 
commit:03a2c5e
/////////////////////////////////////////////////////////////////////////
0:     static final public byte[] EMPTY_BYTE_ARRAY = new byte[] {};
/////////////////////////////////////////////////////////////////////////
0:         if (transport.isTrace()) {
/////////////////////////////////////////////////////////////////////////
0:                     // System.out.println("writing: " + buffer.toString().substring(5).replaceAll("(..)", "$1 "));
0:             // System.out.println("write done");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (command.getClass() == AmqpHeader.class) {
0:             AmqpHeader header = (AmqpHeader) command;
0:             switch (header.getProtocolId()) {
0:                     sasl.setMechanisms(new String[] { "ANONYMOUS", "PLAIN" });
0:             frame = (Buffer) command;
0:         // System.out.println("read: " + frame.toString().substring(5).replaceAll("(..)", "$1 "));
0:         while (frame.length > 0) {
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 if (sasl != null) {
0:                     if (sasl.getRemoteMechanisms().length > 0) {
0:                         if ("PLAIN".equals(sasl.getRemoteMechanisms()[0])) {
0:                             if (parts.length > 0) {
0:                             if (parts.length > 1) {
0:                         } else if ("ANONYMOUS".equals(sasl.getRemoteMechanisms()[0])) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     ((AmqpDeliveryListener) link.getContext()).onClose();
0:                     ((AmqpDeliveryListener) link.getContext()).drainCheck();
0:                     // TODO - close links?
/////////////////////////////////////////////////////////////////////////
0:         if (!closing) {
0:                     if (!closedSocket) {
/////////////////////////////////////////////////////////////////////////
0:         if (!closing) {
/////////////////////////////////////////////////////////////////////////
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace("Dispatching MessageId:{} to consumer", md.getMessage().getMessageId());
0:                 }
/////////////////////////////////////////////////////////////////////////
0:             // ignore
/////////////////////////////////////////////////////////////////////////
0: 
0:         public void onClose() throws Exception {
0:         }
0: 
0:         public void drainCheck() {
0:         }
0:         // configureInactivityMonitor(connect.keepAlive());
/////////////////////////////////////////////////////////////////////////
0:                     // TODO: figure out how to close /w an error.
0:                     // protonConnection.setLocalError(new EndpointError(exception.getClass().getName(),
0:                     // exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:         AmqpSessionContext sessionContext = (AmqpSessionContext) session.getContext();
0:         if (sessionContext != null) {
/////////////////////////////////////////////////////////////////////////
0:     protected InboundTransformer getInboundTransformer() {
/////////////////////////////////////////////////////////////////////////
0:             Receiver receiver = ((Receiver) delivery.getLink());
0:             if (!delivery.isReadable()) {
0:             if (current == null) {
0:             byte data[] = new byte[1024 * 4];
0:             while ((count = receiver.recv(data, 0, data.length)) > 0) {
0:             if (count == 0) {
/////////////////////////////////////////////////////////////////////////
0:             if (destination != null) {
0:             if (message.getMessageId() == null) {
0:             if (remoteState != null && remoteState instanceof TransactionalState) {
/////////////////////////////////////////////////////////////////////////
0:                     if (!delivery.remotelySettled()) {
0:                         if (response.isException()) {
0:                             ExceptionResponse er = (ExceptionResponse) response;
/////////////////////////////////////////////////////////////////////////
0:     class Transaction {
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             while (len > 0) {
0:                 assert decoded > 0 : "Make progress decoding the message";
0:             Object action = ((AmqpValue) msg.getBody()).getValue();
0:             System.out.println("COORDINATOR received: " + action + ", [" + buffer + "]");
0:             if (action instanceof Declare) {
0:                 if (declare.getGlobalId() != null) {
0:                 System.out.println("started transaction " + txid);
0:             } else if (action instanceof Discharge) {
0:                 if (discharge.getFail()) {
0:                     System.out.println("rollback transaction " + txid);
0:                     operation = TransactionInfo.ROLLBACK;
0:                     System.out.println("commit transaction " + txid);
0:                         if (response.isException()) {
0:                             ExceptionResponse er = (ExceptionResponse) response;
/////////////////////////////////////////////////////////////////////////
0:                 throw new Exception("Expected coordinator message type: " + action.getClass());
0:             if (remoteTarget instanceof Coordinator) {
/////////////////////////////////////////////////////////////////////////
0:                 if (target.getDynamic()) {
/////////////////////////////////////////////////////////////////////////
0:                             ((LinkImpl) receiver).setLocalError(new EndpointError(exception.getClass().getName(), exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:             ((LinkImpl) receiver).setLocalError(new EndpointError(exception.getSymbolicName(), exception.getMessage()));
0:         if (terminus == null) {
0:         } else if (terminus instanceof org.apache.qpid.proton.amqp.messaging.Source) {
0:             org.apache.qpid.proton.amqp.messaging.Source source = (org.apache.qpid.proton.amqp.messaging.Source) terminus;
0:             if (source.getAddress() == null || source.getAddress().length() == 0) {
0:         } else if (terminus instanceof org.apache.qpid.proton.amqp.messaging.Target) {
0:             org.apache.qpid.proton.amqp.messaging.Target target = (org.apache.qpid.proton.amqp.messaging.Target) terminus;
0:             if (target.getAddress() == null || target.getAddress().length() == 0) {
0:         } else if (terminus instanceof Coordinator) {
0:             throw new RuntimeException("Unexpected terminus type: " + terminus);
/////////////////////////////////////////////////////////////////////////
0:             if (tagCache.size() < 1024) {
0:             if (!closed) {
/////////////////////////////////////////////////////////////////////////
0:             if (!closed) {
/////////////////////////////////////////////////////////////////////////
0:             while (!closed) {
0:                 while (currentBuffer != null) {
0:                     if (sent > 0) {
0:                         if (currentBuffer.length == 0) {
0:                             if (presettle) {
/////////////////////////////////////////////////////////////////////////
0:                 if (outbound.isEmpty()) {
0:                     if (jms == null) {
0:                         if (amqp != null && amqp.getLength() > 0) {
0:                             if (presettle) {
/////////////////////////////////////////////////////////////////////////
0:             if (tag != null && tag.length > 0) {
0:             if (ackType == -1) {
/////////////////////////////////////////////////////////////////////////
0:                 ack.setAckType((byte) ackType);
0:                 if (remoteState != null && remoteState instanceof TransactionalState) {
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace("Sending Ack for MessageId:{} to ActiveMQ", ack.getLastMessageId());
0:                 }
0: 
0:                         if (response.isException()) {
/////////////////////////////////////////////////////////////////////////
0:             if (outbound.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
0:             if (state instanceof Accepted) {
0:                 if (!delivery.remotelySettled()) {
0:             } else if (state instanceof Rejected) {
0:             } else if (state instanceof Released) {
0:             } else if (state instanceof Modified) {
0:                 if (modified.getDeliveryFailed()) {
0:                     // increment delivery counter..
0:                     md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
0:                 if (undeliverableHere != null && undeliverableHere) {
/////////////////////////////////////////////////////////////////////////
0:         org.apache.qpid.proton.amqp.messaging.Source source = (org.apache.qpid.proton.amqp.messaging.Source) sender.getRemoteSource();
/////////////////////////////////////////////////////////////////////////
0:             if (source != null) {
0:                     DescribedType value = (DescribedType) filter.get(JMS_SELECTOR);
0:                     if (value != null) {
0:                             ((LinkImpl) sender).setLocalError(new EndpointError("amqp:invalid-field", e.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:             if (source == null) {
/////////////////////////////////////////////////////////////////////////
0:                 consumerContext.closed = true;
/////////////////////////////////////////////////////////////////////////
0:                             ((LinkImpl) sender).setLocalError(new EndpointError(name, exception.getMessage()));
0:             } else if (contains(source.getCapabilities(), DURABLE_SUBSCRIPTION_ENDED)) {
0:                 consumerContext.closed = true;
0:             } else if (source.getDynamic()) {
/////////////////////////////////////////////////////////////////////////
0:             if (source.getDistributionMode() == COPY && dest.isQueue()) {
0:             if (DURABLE.equals(source.getDurable()) && dest.isTopic()) {
0:                 DescribedType value = (DescribedType) filter.get(NO_LOCAL);
0:                 if (value != null) {
/////////////////////////////////////////////////////////////////////////
0:                         if (exception instanceof InvalidSelectorException) {
0:                         ((LinkImpl) sender).setLocalError(new EndpointError(name, exception.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:             ((LinkImpl) sender).setLocalError(new EndpointError(e.getSymbolicName(), e.getMessage()));
0:         if (haystack != null) {
0:                 if (capability == needle) {
/////////////////////////////////////////////////////////////////////////
0:     // //////////////////////////////////////////////////////////////////////////
0:     // //////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b62648b
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
0: import java.io.UnsupportedEncodingException;
0: import java.util.EnumSet;
0: import java.util.HashMap;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.Map;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.locks.ReentrantLock;
0: 
0: import javax.jms.InvalidSelectorException;
0: 
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ActiveMQTempQueue;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.LocalTransactionId;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.TransactionInfo;
0: import org.apache.qpid.proton.amqp.Binary;
0: import org.apache.qpid.proton.amqp.DescribedType;
0: import org.apache.qpid.proton.amqp.Symbol;
0: import org.apache.qpid.proton.amqp.UnsignedInteger;
0: import org.apache.qpid.proton.amqp.messaging.Accepted;
0: import org.apache.qpid.proton.amqp.messaging.AmqpValue;
0: import org.apache.qpid.proton.amqp.transaction.Coordinator;
0: import org.apache.qpid.proton.amqp.transaction.Declare;
0: import org.apache.qpid.proton.amqp.transaction.Declared;
0: import org.apache.qpid.proton.amqp.transaction.Discharge;
0: import org.apache.qpid.proton.amqp.transaction.TransactionalState;
0: import org.apache.qpid.proton.amqp.transport.DeliveryState;
0: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
0: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
0: import org.apache.qpid.proton.engine.Delivery;
0: import org.apache.qpid.proton.engine.EndpointError;
0: import org.apache.qpid.proton.engine.EndpointState;
0: import org.apache.qpid.proton.engine.Link;
0: import org.apache.qpid.proton.engine.Receiver;
0: import org.apache.qpid.proton.engine.Sasl;
0: import org.apache.qpid.proton.engine.Sender;
0: import org.apache.qpid.proton.engine.Session;
0: import org.apache.qpid.proton.jms.AMQPNativeInboundTransformer;
0: import org.apache.qpid.proton.jms.AMQPRawInboundTransformer;
0: import org.apache.qpid.proton.jms.AutoOutboundTransformer;
0: import org.apache.qpid.proton.jms.EncodedMessage;
0: import org.apache.qpid.proton.jms.InboundTransformer;
0: import org.apache.qpid.proton.jms.JMSMappingInboundTransformer;
0: import org.apache.qpid.proton.jms.OutboundTransformer;
/////////////////////////////////////////////////////////////////////////
0:     private final ConnectionInfo connectionInfo = new ConnectionInfo();
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:                     @Override
/////////////////////////////////////////////////////////////////////////
0:         private final boolean presettle;
/////////////////////////////////////////////////////////////////////////
0:                         jms.setReadOnlyBody(true);
/////////////////////////////////////////////////////////////////////////
0:                     @Override
/////////////////////////////////////////////////////////////////////////
0:                 @Override
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:7938cc6
/////////////////////////////////////////////////////////////////////////
0:                                 AmqpProtocolConverter.this.amqpTransport.getRemoteAddress(), transportFrame.getBody()));
/////////////////////////////////////////////////////////////////////////
0:                                 AmqpProtocolConverter.this.amqpTransport.getRemoteAddress(), transportFrame.getBody()));
/////////////////////////////////////////////////////////////////////////
0:         public ConsumerInfo info;
0:         private boolean endOfBrowse = false;
0: 
/////////////////////////////////////////////////////////////////////////
0:                         endOfBrowse = true;
0:                         drainCheck();
/////////////////////////////////////////////////////////////////////////
0:             // If we are a browser.. lets not say we are drained until
0:             // we hit the end of browse message.
0:             if( info.isBrowser() && !endOfBrowse)
0:                 return;
0: 
/////////////////////////////////////////////////////////////////////////
0:             consumerContext.info = consumerInfo;
commit:e8eb58a
/////////////////////////////////////////////////////////////////////////
0:     static final Logger TRACE_FRAMES = AmqpTransportFilter.TRACE_FRAMES;
/////////////////////////////////////////////////////////////////////////
0:         updateTracer();
0:     }
0: 
0:     void updateTracer() {
0:         if (amqpTransport.isTrace()) {
0:                     if (TRACE_FRAMES.isTraceEnabled()) {
0:                         TRACE_FRAMES.trace(String.format("%s | RECV: %s",
0:                             AmqpProtocolConverter.this.amqpTransport.getRemoteAddress(), transportFrame.getBody()));
0:                     if (TRACE_FRAMES.isTraceEnabled()) {
0:                         TRACE_FRAMES.trace(String.format("%s | SENT: %s",
0:                             AmqpProtocolConverter.this.amqpTransport.getRemoteAddress(), transportFrame.getBody()));
0: 
commit:b2b4fc8
/////////////////////////////////////////////////////////////////////////
0: 
0:             MessageId messageId = message.getMessageId();
0:             messageId.setProducerId(producerId);
0:             messageId.setProducerSequenceId(messageIdGenerator.getNextSequenceId());
commit:15298cb
/////////////////////////////////////////////////////////////////////////
0:             if( source.getAddress() == null || source.getAddress().length()==0) {
0:             if( target.getAddress() == null || target.getAddress().length()==0) {
commit:37423d6
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             if( remoteTarget instanceof Coordinator ) {
0:                 pumpProtonToSocket();
0:                 receiver.setContext(coordinatorContext);
0:                 receiver.flow(prefetch);
0:                 receiver.open();
0:                 pumpProtonToSocket();
0:                 Target target = (Target) remoteTarget;
0:                 ProducerId producerId = new ProducerId(sessionContext.sessionId, sessionContext.nextProducerId++);
0:                 ActiveMQDestination dest;
0:                 if( target.getDynamic() ) {
0:                     dest = createTempQueue();
0:                     Target actualTarget = new Target();
0:                     actualTarget.setAddress(dest.getQualifiedName());
0:                     actualTarget.setDynamic(true);
0:                     receiver.setTarget(actualTarget);
0:                 } else {
0:                     dest = createDestination(remoteTarget);
0: 
0:                 ProducerContext producerContext = new ProducerContext(producerId, dest);
0: 
0:                 receiver.setContext(producerContext);
0:                 receiver.flow(prefetch);
0:                 ProducerInfo producerInfo = new ProducerInfo(producerId);
0:                 producerInfo.setDestination(dest);
0:                 sendToActiveMQ(producerInfo, new ResponseHandler() {
0:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                         if (response.isException()) {
0:                             receiver.setTarget(null);
0:                             Throwable exception = ((ExceptionResponse) response).getException();
0:                             ((LinkImpl)receiver).setLocalError(new EndpointError(exception.getClass().getName(), exception.getMessage()));
0:                             receiver.close();
0:                         } else {
0:                             receiver.open();
0:                         }
0:                         pumpProtonToSocket();
0:                     }
0:                 });
0:             }
0:         } catch (AmqpProtocolException exception) {
0:             receiver.setTarget(null);
0:             ((LinkImpl)receiver).setLocalError(new EndpointError(exception.getSymbolicName(), exception.getMessage()));
0:             receiver.close();
0:     private ActiveMQDestination createDestination(Object terminus) throws AmqpProtocolException {
0:             if( source.getAddress() == null ) {
0:                 throw new AmqpProtocolException("amqp:invalid-field", "source address not set");
0:             }
0:             if( target.getAddress() == null ) {
0:                 throw new AmqpProtocolException("amqp:invalid-field", "target address not set");
0:             }
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             final ConsumerId id = new ConsumerId(sessionContext.sessionId, sessionContext.nextConsumerId++);
0:             ConsumerContext consumerContext = new ConsumerContext(id, sender);
0:             sender.setContext(consumerContext);
0:             String selector = null;
0:             if( source!=null ) {
0:                 Map filter = source.getFilter();
0:                 if (filter != null) {
0:                     DescribedType value = (DescribedType)filter.get(JMS_SELECTOR);
0:                     if( value!=null ) {
0:                         selector = value.getDescribed().toString();
0:                         // Validate the Selector.
0:                         try {
0:                             SelectorParser.parse(selector);
0:                         } catch (InvalidSelectorException e) {
0:                             sender.setSource(null);
0:                             ((LinkImpl)sender).setLocalError(new EndpointError("amqp:invalid-field", e.getMessage()));
0:                             sender.close();
0:                             consumerContext.closed = true;
0:                             return;
0:                         }
0:             ActiveMQDestination dest;
0:             if( source == null ) {
0:                 source = new org.apache.qpid.proton.amqp.messaging.Source();
0:                 source.setAddress("");
0:                 source.setCapabilities(DURABLE_SUBSCRIPTION_ENDED);
0:                 sender.setSource(source);
0:                 // Looks like durable sub removal.
0:                 RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
0:                 rsi.setConnectionId(connectionId);
0:                 rsi.setSubscriptionName(sender.getName());
0:                 rsi.setClientId(connectionInfo.getClientId());
0:                 consumerContext.closed=true;
0:                 sendToActiveMQ(rsi, new ResponseHandler() {
0:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                         if (response.isException()) {
0:                             sender.setSource(null);
0:                             Throwable exception = ((ExceptionResponse) response).getException();
0:                             String name = exception.getClass().getName();
0:                             ((LinkImpl)sender).setLocalError(new EndpointError(name, exception.getMessage()));
0:                         }
0:                         sender.open();
0:                         pumpProtonToSocket();
0:                     }
0:                 });
0:                 return;
0:             } else if( contains(source.getCapabilities(), DURABLE_SUBSCRIPTION_ENDED) ) {
0:                 consumerContext.closed=true;
0:                 sender.close();
0:                 pumpProtonToSocket();
0:                 return;
0:             } else if( source.getDynamic() ) {
0:                 // lets create a temp dest.
0:                 dest = createTempQueue();
0:                 source = new org.apache.qpid.proton.amqp.messaging.Source();
0:                 source.setAddress(dest.getQualifiedName());
0:                 source.setDynamic(true);
0:                 sender.setSource(source);
0:             } else {
0:                 dest = createDestination(source);
0:             }
0: 
0:             subscriptionsByConsumerId.put(id, consumerContext);
0:             ConsumerInfo consumerInfo = new ConsumerInfo(id);
0:             consumerInfo.setSelector(selector);
0:             consumerInfo.setNoRangeAcks(true);
0:             consumerInfo.setDestination(dest);
0:             consumerInfo.setPrefetchSize(100);
0:             consumerInfo.setDispatchAsync(true);
0:             if( source.getDistributionMode() == COPY && dest.isQueue() ) {
0:                 consumerInfo.setBrowser(true);
0:             }
0:             if( DURABLE.equals(source.getDurable()) && dest.isTopic() ) {
0:                 consumerInfo.setSubscriptionName(sender.getName());
0:             }
0: 
0:             Map filter = source.getFilter();
0:             if (filter != null) {
0:                 DescribedType value = (DescribedType)filter.get(NO_LOCAL);
0:                 if( value!=null ) {
0:                     consumerInfo.setNoLocal(true);
0:                 }
0:             }
0: 
0:             sendToActiveMQ(consumerInfo, new ResponseHandler() {
0:                         if( exception instanceof InvalidSelectorException ) {
0:                             name = "amqp:invalid-field";
0:                         }
0:                         subscriptionsByConsumerId.remove(id);
0:                         sender.close();
0:                     } else {
0:                         sender.open();
0:         } catch (AmqpProtocolException e) {
0:             sender.setSource(null);
0:             ((LinkImpl)sender).setLocalError(new EndpointError(e.getSymbolicName(), e.getMessage()));
commit:0dfa5f4
/////////////////////////////////////////////////////////////////////////
0:         if( !closing ) {
0:             amqpTransport.sendToActiveMQ(error);
0:             try {
0:                 amqpTransport.stop();
0:             } catch (Exception ignore) {
0:             }
commit:77312e5
/////////////////////////////////////////////////////////////////////////
0:                 return;
commit:ebaacfd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.qpid.proton.amqp.*;
0: import org.apache.qpid.proton.amqp.messaging.*;
0: import org.apache.qpid.proton.amqp.messaging.Modified;
0: import org.apache.qpid.proton.amqp.messaging.Rejected;
0: import org.apache.qpid.proton.amqp.messaging.Released;
0: import org.apache.qpid.proton.amqp.messaging.Target;
0: import org.apache.qpid.proton.amqp.transaction.*;
0: import org.apache.qpid.proton.amqp.transport.*;
0: import org.apache.qpid.proton.engine.impl.ConnectionImpl;
0: import org.apache.qpid.proton.engine.impl.LinkImpl;
0: import org.apache.qpid.proton.engine.impl.ProtocolTracer;
0: import org.apache.qpid.proton.engine.impl.TransportImpl;
0: import org.apache.qpid.proton.message.impl.MessageImpl;
/////////////////////////////////////////////////////////////////////////
0:                             ErrorCondition condition = new ErrorCondition();
0:                             condition.setCondition(Symbol.valueOf("failed"));
0:                             condition.setDescription(er.getException().getMessage());
0:                             rejected.setError(condition);
/////////////////////////////////////////////////////////////////////////
0:             MessageImpl msg = new MessageImpl();
/////////////////////////////////////////////////////////////////////////
0:                             rejected.setError(createErrorCondition("failed", er.getException().getMessage()));
/////////////////////////////////////////////////////////////////////////
0:         org.apache.qpid.proton.amqp.transport.Target remoteTarget = receiver.getRemoteTarget();
/////////////////////////////////////////////////////////////////////////
0:             org.apache.qpid.proton.amqp.messaging.Target target = (Target) remoteTarget;
0:                 org.apache.qpid.proton.amqp.messaging.Target actualTarget = new org.apache.qpid.proton.amqp.messaging.Target();
/////////////////////////////////////////////////////////////////////////
0:         } else if( terminus instanceof org.apache.qpid.proton.amqp.messaging.Source) {
0:             org.apache.qpid.proton.amqp.messaging.Source source = (org.apache.qpid.proton.amqp.messaging.Source)terminus;
0:         } else if( terminus instanceof org.apache.qpid.proton.amqp.messaging.Target) {
0:             org.apache.qpid.proton.amqp.messaging.Target target = (org.apache.qpid.proton.amqp.messaging.Target)terminus;
/////////////////////////////////////////////////////////////////////////
0:         org.apache.qpid.proton.amqp.messaging.Source source = (org.apache.qpid.proton.amqp.messaging.Source)sender.getRemoteSource();
/////////////////////////////////////////////////////////////////////////
0:             source = new org.apache.qpid.proton.amqp.messaging.Source();
/////////////////////////////////////////////////////////////////////////
0:             source = new org.apache.qpid.proton.amqp.messaging.Source();
/////////////////////////////////////////////////////////////////////////
0:     ErrorCondition createErrorCondition(String name) {
0:         return createErrorCondition(name, "");
0:     }
0: 
0:     ErrorCondition createErrorCondition(String name, String description) {
0:         ErrorCondition condition = new ErrorCondition();
0:         condition.setCondition(Symbol.valueOf(name));
0:         condition.setDescription(description);
0:         return condition;
0:     }
0: 
commit:8c5c33b
/////////////////////////////////////////////////////////////////////////
0:     int prefetch = 100;
0:     public AmqpProtocolConverter(AmqpTransport transport, BrokerContext brokerContext) {
0:         this.amqpTransport = transport;
0:         if( transport.isTrace() ) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3016b39
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.selector.SelectorParser;
0: import org.apache.qpid.proton.jms.*;
0: import org.apache.qpid.proton.type.UnsignedInteger;
/////////////////////////////////////////////////////////////////////////
0:     private static final UnsignedInteger DURABLE = new UnsignedInteger(2);
0:     private static final Symbol DURABLE_SUBSCRIPTION_ENDED = Symbol.getSymbol("DURABLE_SUBSCRIPTION_ENDED");
/////////////////////////////////////////////////////////////////////////
0:     boolean trace = true;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         private boolean closed;
/////////////////////////////////////////////////////////////////////////
0:             if( !closed ) {
0:                 closed = true;
0:                 sendToActiveMQ(new RemoveInfo(consumerId), null);
0:             }
0:             if( !closed ) {
0:                 outbound.addLast(md);
0:                 pumpOutbound();
0:                 pumpProtonToSocket();
0:             }
0:             while(!closed) {
/////////////////////////////////////////////////////////////////////////
0:         org.apache.qpid.proton.type.messaging.Source source = (org.apache.qpid.proton.type.messaging.Source)sender.getRemoteSource();
0:         final ConsumerId id = new ConsumerId(sessionContext.sessionId, sessionContext.nextConsumerId++);
0:         ConsumerContext consumerContext = new ConsumerContext(id, sender);
0:         sender.setContext(consumerContext);
0: 
0:         String selector = null;
0:         if( source!=null ) {
0:             Map filter = source.getFilter();
0:             if (filter != null) {
0:                 DescribedType value = (DescribedType)filter.get(JMS_SELECTOR);
0:                 if( value!=null ) {
0:                     selector = value.getDescribed().toString();
0:                     // Validate the Selector.
0:                     try {
0:                         SelectorParser.parse(selector);
0:                     } catch (InvalidSelectorException e) {
0:                         sender.setSource(null);
0:                         ((LinkImpl)sender).setLocalError(new EndpointError("amqp:invalid-field", e.getMessage()));
0:                         sender.close();
0:                         consumerContext.closed = true;
0:                         return;
0:                     }
0:                 }
0:             }
0:         }
0:         if( source == null ) {
0: 
0:             source = new org.apache.qpid.proton.type.messaging.Source();
0:             source.setAddress("");
0:             source.setCapabilities(DURABLE_SUBSCRIPTION_ENDED);
0:             sender.setSource(source);
0: 
0:             // Looks like durable sub removal.
0:             RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
0:             rsi.setConnectionId(connectionId);
0:             rsi.setSubscriptionName(sender.getName());
0:             rsi.setClientId(connectionInfo.getClientId());
0: 
0:             consumerContext.closed=true;
0:             sendToActiveMQ(rsi, new ResponseHandler() {
0:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                     if (response.isException()) {
0:                         sender.setSource(null);
0:                         Throwable exception = ((ExceptionResponse) response).getException();
0:                         String name = exception.getClass().getName();
0:                         ((LinkImpl)sender).setLocalError(new EndpointError(name, exception.getMessage()));
0:                     }
0:                     sender.open();
0:                     pumpProtonToSocket();
0:                 }
0:             });
0:             return;
0:         } else if( contains(source.getCapabilities(), DURABLE_SUBSCRIPTION_ENDED) ) {
0:             consumerContext.closed=true;
0:             sender.close();
0:             pumpProtonToSocket();
0:             return;
0:         } else if( source.getDynamic() ) {
0:         } else {
0:             dest = createDestination(source);
0:         subscriptionsByConsumerId.put(id, consumerContext);
0:         consumerInfo.setSelector(selector);
0:         consumerInfo.setNoRangeAcks(true);
0:         if( DURABLE.equals(source.getDurable()) && dest.isTopic() ) {
0:             consumerInfo.setSubscriptionName(sender.getName());
0:         }
0:             DescribedType value = (DescribedType)filter.get(NO_LOCAL);
/////////////////////////////////////////////////////////////////////////
0:                     subscriptionsByConsumerId.remove(id);
/////////////////////////////////////////////////////////////////////////
0:     static private boolean contains(Symbol[] haystack, Symbol needle) {
0:         if( haystack!=null ) {
0:             for (Symbol capability : haystack) {
0:                 if( capability == needle) {
0:                     return true;
0:                 }
0:             }
0:         }
0:         return false;
0:     }
0: 
commit:2727496
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol NO_LOCAL = Symbol.valueOf("no-local");
/////////////////////////////////////////////////////////////////////////
0:             value = (DescribedType)filter.get(NO_LOCAL);
0:             if( value!=null ) {
0:                 consumerInfo.setNoLocal(true);
0:             }
commit:cf70ce9
/////////////////////////////////////////////////////////////////////////
0:     boolean trace = false;
0:         if( trace ) {
0:             this.protonTransport.setProtocolTracer(new ProtocolTracer() {
0:                 @Override
0:                 public void receivedFrame(TransportFrame transportFrame) {
0:                     System.out.println(String.format("%s | RECV: %s", amqpTransport.getRemoteAddress(), transportFrame.getBody()));
0:                 }
0:                 @Override
0:                 public void sentFrame(TransportFrame transportFrame) {
0:                     System.out.println(String.format("%s | SENT: %s", amqpTransport.getRemoteAddress(), transportFrame.getBody()));
0:                 }
0:             });
0:         }
commit:7a0c1f8
/////////////////////////////////////////////////////////////////////////
0:                 System.out.println(String.format("%s | RECV: %s", amqpTransport.getRemoteAddress(), transportFrame.getBody()));
0:                 System.out.println(String.format("%s | SENT: %s", amqpTransport.getRemoteAddress(), transportFrame.getBody()));
/////////////////////////////////////////////////////////////////////////
0:         protected void onMessage(final Receiver receiver, final Delivery delivery, Buffer buffer) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             message.onSend();
0:             sendToActiveMQ(message, new ResponseHandler() {
0:                 @Override
0:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                     if( !delivery.remotelySettled()  ) {
/////////////////////////////////////////////////////////////////////////
0:                     receiver.flow(1);
0:                     delivery.settle();
0:                     pumpProtonToSocket();
0:                 }
0:             });
commit:914e177
/////////////////////////////////////////////////////////////////////////
0:     int prefetch = 100;
/////////////////////////////////////////////////////////////////////////
0:             receiver.flow(prefetch);
/////////////////////////////////////////////////////////////////////////
0:             receiver.flow(prefetch);
commit:11e0df8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         protected void onMessage(Receiver receiver, final Delivery delivery, Buffer buffer) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             ResponseHandler handler = null;
0:             if( delivery.remotelySettled() ) {
0:                 delivery.settle();
0:             } else {
0:                 handler = new ResponseHandler() {
0:                     @Override
0:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                         if( response.isException() ) {
0:                             ExceptionResponse er = (ExceptionResponse)response;
0:                             Rejected rejected = new Rejected();
0:                             ArrayList errors = new ArrayList();
0:                             errors.add(er.getException().getMessage());
0:                             rejected.setError(errors);
0:                             delivery.disposition(rejected);
0:                         }
0:                         delivery.settle();
0:                         pumpProtonToSocket();
0:                     }
0:                 };
0:             }
0: 
0:             sendToActiveMQ(message, handler);
/////////////////////////////////////////////////////////////////////////
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
commit:ba01018
/////////////////////////////////////////////////////////////////////////
0:         if( source.getDistributionMode() == COPY && dest.isQueue() ) {
commit:ae24f5f
/////////////////////////////////////////////////////////////////////////
0:                     link = link.next(ACTIVE_STATE, ALL_STATES);
commit:9a6a83f
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidSelectorException;
/////////////////////////////////////////////////////////////////////////
0:                         receiver.setTarget(null);
0:                         ((LinkImpl)receiver).setLocalError(new EndpointError(exception.getClass().getName(), exception.getMessage()));
0:                     } else {
0:                         receiver.open();
/////////////////////////////////////////////////////////////////////////
0:                     sender.setSource(null);
0:                     String name = exception.getClass().getName();
0:                     if( exception instanceof InvalidSelectorException ) {
0:                         name = "amqp:invalid-field";
0:                     }
0:                     ((LinkImpl)sender).setLocalError(new EndpointError(name, exception.getMessage()));
0:                 } else {
0:                     sender.open();
commit:822c4f3
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol JMS_SELECTOR = Symbol.valueOf("jms-selector");
/////////////////////////////////////////////////////////////////////////
0: 
0:         Map filter = source.getFilter();
0:             DescribedType value = (DescribedType)filter.get(JMS_SELECTOR);
0:             if( value!=null ) {
0:                 consumerInfo.setSelector(value.getDescribed().toString());
0:             }
commit:8835535
/////////////////////////////////////////////////////////////////////////
0:     private static final Symbol COPY = Symbol.getSymbol("copy");
/////////////////////////////////////////////////////////////////////////
0:         if( source.getDistributionMode() == COPY) {
0:             consumerInfo.setBrowser(true);
0:         }
0:         Map filter = ((org.apache.qpid.proton.type.messaging.Source)source).getFilter();
commit:3b0b1fa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             org.apache.qpid.proton.type.messaging.Target target = (Target) remoteTarget;
0:             ActiveMQDestination dest;
0:             if( target.getDynamic() ) {
0:                 dest = createTempQueue();
0:                 org.apache.qpid.proton.type.messaging.Target actualTarget = new org.apache.qpid.proton.type.messaging.Target();
0:                 actualTarget.setAddress(dest.getQualifiedName());
0:                 actualTarget.setDynamic(true);
0:                 receiver.setTarget(actualTarget);
0:             } else {
0:                 dest = createDestination(remoteTarget);
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     if( jms==null ) {
0:                         // It's the end of browse signal.
0:                         sender.drained();
0:                         jms.setRedeliveryCounter(md.getRedeliveryCounter());
0:                         final EncodedMessage amqp = outboundTransformer.transform(jms);
0:                         if( amqp!=null && amqp.getLength() > 0 ) {
0:                             currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());
0:                             if( presettle ) {
0:                                 currentDelivery = sender.delivery(EMPTY_BYTE_ARRAY, 0, 0);
0:                             } else {
0:                                 final byte[] tag = nextTag();
0:                                 currentDelivery = sender.delivery(tag, 0, tag.length);
0:                             }
0:                             currentDelivery.setContext(md);
0: 
0:                         } else {
0:                             // TODO: message could not be generated what now?
0: 
0:                         }
/////////////////////////////////////////////////////////////////////////
0:         org.apache.qpid.proton.type.messaging.Source source = (org.apache.qpid.proton.type.messaging.Source)sender.getRemoteSource();
0:         if( source != null && !source.getDynamic() ) {
0:             dest = createDestination(source);
0:             dest = createTempQueue();
0:             source = new org.apache.qpid.proton.type.messaging.Source();
0:             source.setAddress(dest.getQualifiedName());
0:             source.setDynamic(true);
0:             sender.setSource(source);
/////////////////////////////////////////////////////////////////////////
0:     private ActiveMQDestination createTempQueue() {
0:         ActiveMQDestination rc;
0:         rc = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
0:         DestinationInfo info = new DestinationInfo();
0:         info.setConnectionId(connectionId);
0:         info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
0:         info.setDestination(rc);
0:         sendToActiveMQ(info, null);
0:         return rc;
0:     }
0: 
commit:7806807
/////////////////////////////////////////////////////////////////////////
0:             if( destination!=null ) {
/////////////////////////////////////////////////////////////////////////
0:                 ack.setDestination(md.getDestination());
/////////////////////////////////////////////////////////////////////////
0:                         if( response.isException() ) {
0:                             if (response.isException()) {
0:                                 Throwable exception = ((ExceptionResponse) response).getException();
0:                                 exception.printStackTrace();
0:                                 sender.close();
0:                             }
0:                         } else {
0:                             delivery.settle();
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                     exception.printStackTrace();
commit:dc4ceb4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.engine.impl.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     Sasl sasl;
0: 
0:     public void onAMQPData(Object command) throws Exception {
0:         Buffer frame;
0:         if( command.getClass() == AmqpHeader.class ) {
0:             AmqpHeader header = (AmqpHeader)command;
0:             switch( header.getProtocolId() ) {
0:                 case 0:
0:                     // amqpTransport.sendToAmqp(new AmqpHeader());
0:                     break; // nothing to do..
0:                 case 3: // Client will be using SASL for auth..
0:                     sasl = protonTransport.sasl();
0:                     sasl.setMechanisms(new String[]{"ANONYMOUS", "PLAIN"});
0:                     sasl.server();
0:                     break;
0:                 default:
0:             }
0:             frame = header.getBuffer();
0:         } else {
0:             frame = (Buffer)command;
0:         onFrame(frame);
0:     }
0:     public void onFrame(Buffer frame) throws Exception {
0: //        System.out.println("read: " + frame.toString().substring(5).replaceAll("(..)", "$1 "));
0:         while( frame.length > 0 ) {
0:             try {
0:                 int count = protonTransport.input(frame.data, frame.offset, frame.length);
0:                 frame.moveHead(count);
0:             } catch (Throwable e) {
0:                 handleException(new AmqpProtocolException("Could not decode AMQP frame: " + frame, true, e));
0:             try {
0:                 if( sasl!=null ) {
0:                     // Lets try to complete the sasl handshake.
0:                     if( sasl.getRemoteMechanisms().length > 0 ) {
0:                         if( "PLAIN".equals(sasl.getRemoteMechanisms()[0]) ) {
0:                             byte[] data = new byte[sasl.pending()];
0:                             sasl.recv(data, 0, data.length);
0:                             Buffer[] parts = new Buffer(data).split((byte) 0);
0:                             if( parts.length > 0 ) {
0:                                 connectionInfo.setUserName(parts[0].utf8().toString());
0:                             }
0:                             if( parts.length > 1 ) {
0:                                 connectionInfo.setPassword(parts[1].utf8().toString());
0:                             }
0:                             // We can't really auth at this point since we don't know the client id yet.. :(
0:                             sasl.done(Sasl.SaslOutcome.PN_SASL_OK);
0:                             amqpTransport.getWireFormat().magicRead = false;
0:                             sasl = null;
0:                         } else if( "ANONYMOUS".equals(sasl.getRemoteMechanisms()[0]) ) {
0:                             sasl.done(Sasl.SaslOutcome.PN_SASL_OK);
0:                             amqpTransport.getWireFormat().magicRead = false;
0:                             sasl = null;
0:                         }
0:                     }
0:                 // Handle the amqp open..
0:                 if (protonConnection.getLocalState() == EndpointState.UNINITIALIZED && protonConnection.getRemoteState() != EndpointState.UNINITIALIZED) {
0:                     onConnectionOpen();
0:                 }
0:                 // Lets map amqp sessions to openwire sessions..
0:                 Session session = protonConnection.sessionHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:                 while (session != null) {
0: 
0:                     onSessionOpen(session);
0:                     session = protonConnection.sessionHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:                 }
0:                 Link link = protonConnection.linkHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:                 while (link != null) {
0:                     onLinkOpen(link);
0:                     link = protonConnection.linkHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:                 }
0: 
0:                 Delivery delivery = protonConnection.getWorkHead();
0:                 while (delivery != null) {
0:                     AmqpDeliveryListener listener = (AmqpDeliveryListener) delivery.getLink().getContext();
0:                     if (listener != null) {
0:                         listener.onDelivery(delivery);
0:                     }
0:                     delivery = delivery.getWorkNext();
0:                 }
0: 
0:                 link = protonConnection.linkHead(ACTIVE_STATE, CLOSED_STATE);
0:                 while (link != null) {
0:                     ((AmqpDeliveryListener)link.getContext()).onClose();
0:                     link.close();
0:                     link = link.next(ACTIVE_STATE, CLOSED_STATE);
0:                 }
0: 
0:                 link = protonConnection.linkHead(ACTIVE_STATE, ALL_STATES);
0:                 while (link != null) {
0:                     ((AmqpDeliveryListener)link.getContext()).drainCheck();
0:                     link = link.next(ACTIVE_STATE, CLOSED_STATE);
0:                 }
0: 
0: 
0:                 session = protonConnection.sessionHead(ACTIVE_STATE, CLOSED_STATE);
0:                 while (session != null) {
0:                     //TODO - close links?
0:                     onSessionClose(session);
0:                     session = session.next(ACTIVE_STATE, CLOSED_STATE);
0:                 }
0:                 if (protonConnection.getLocalState() == EndpointState.ACTIVE && protonConnection.getRemoteState() == EndpointState.CLOSED) {
0:                     doClose();
0:                 }
0: 
0:             } catch (Throwable e) {
0:                 handleException(new AmqpProtocolException("Could not process AMQP commands", true, e));
0:             pumpProtonToSocket();
commit:2db73e2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.engine.impl.ProtocolTracer;
0: import org.apache.qpid.proton.framing.TransportFrame;
0: import org.apache.qpid.proton.type.Binary;
0: import org.apache.qpid.proton.type.messaging.*;
0: import org.apache.qpid.proton.type.messaging.Modified;
0: import org.apache.qpid.proton.type.messaging.Rejected;
0: import org.apache.qpid.proton.type.messaging.Released;
0: import org.apache.qpid.proton.type.transaction.*;
0: import org.apache.qpid.proton.type.transport.DeliveryState;
0: import org.apache.qpid.proton.type.transport.SenderSettleMode;
0: import org.apache.qpid.proton.type.transport.Source;
/////////////////////////////////////////////////////////////////////////
0:     public static final EnumSet<EndpointState> ALL_STATES = EnumSet.of(EndpointState.CLOSED, EndpointState.ACTIVE, EndpointState.UNINITIALIZED);
0:     static final public byte[] EMPTY_BYTE_ARRAY = new byte[]{};
/////////////////////////////////////////////////////////////////////////
0:         this.protonTransport.setProtocolTracer(new ProtocolTracer() {
0:             @Override
0:             public void receivedFrame(TransportFrame transportFrame) {
0:                 System.out.println(String.format("RECV: %05d | %s", transportFrame.getChannel(), transportFrame.getBody()));
0:             }
0: 
0:             @Override
0:             public void sentFrame(TransportFrame transportFrame) {
0:                 System.out.println(String.format("SENT: %05d | %s", transportFrame.getChannel(), transportFrame.getBody()));
0:             }
0:         });
0: 
/////////////////////////////////////////////////////////////////////////
0:                     final Buffer buffer;
0:                     buffer = new Buffer(data, 0, count);
/////////////////////////////////////////////////////////////////////////
0:             sessionId = new SessionId(connectionId, id);
/////////////////////////////////////////////////////////////////////////
0:             link = protonConnection.linkHead(ACTIVE_STATE, ALL_STATES);
0:             while (link != null) {
0:                 ((AmqpDeliveryListener)link.getContext()).drainCheck();
0:                 link = link.next(ACTIVE_STATE, CLOSED_STATE);
0:             }
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:                 doClose();
/////////////////////////////////////////////////////////////////////////
0:     boolean closing = false;
0:     boolean closedSocket = false;
0: 
0:     private void doClose() {
0:         if( !closing ) {
0:             closing = true;
0:             sendToActiveMQ(new RemoveInfo(connectionId), new ResponseHandler() {
0:                 @Override
0:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                     protonConnection.close();
0:                     if( !closedSocket) {
0:                         pumpProtonToSocket();
0:                     }
0:                 }
0:             });
0:         }
0:     }
0: 
0: 
0:     public void onAMQPException(IOException error) {
0:         closedSocket = true;
0:         if( !closing) {
0:             System.out.println("AMQP client disconnected");
0:             error.printStackTrace();
0:         } else {
0:             doClose();
0:         }
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         public void drainCheck() {}
/////////////////////////////////////////////////////////////////////////
0:         if( sessionContext!=null ) {
0:             System.out.println(sessionContext.sessionId);
0:             sendToActiveMQ(new RemoveInfo(sessionContext.sessionId), null);
0:             session.setContext(null);
0:         }
0:         link.setSource(link.getRemoteSource());
0:         link.setTarget(link.getRemoteTarget());
/////////////////////////////////////////////////////////////////////////
0:     abstract class BaseProducerContext extends AmqpDeliveryListener {
0: 
/////////////////////////////////////////////////////////////////////////
0:             Buffer buffer = current.toBuffer();
0:             current = null;
0:             onMessage(receiver, delivery, buffer);
0:         }
0: 
0:         abstract protected void onMessage(Receiver receiver, Delivery delivery, Buffer buffer) throws Exception;
0:     }
0: 
0:     class ProducerContext extends BaseProducerContext {
0:         private final ProducerId producerId;
0:         private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
0:         private final ActiveMQDestination destination;
0: 
0:         public ProducerContext(ProducerId producerId, ActiveMQDestination destination) {
0:             this.producerId = producerId;
0:             this.destination = destination;
0:         }
0: 
0:         @Override
0:         protected void onMessage(Receiver receiver, Delivery delivery, Buffer buffer) throws Exception {
/////////////////////////////////////////////////////////////////////////
0: 
0:             DeliveryState remoteState = delivery.getRemoteState();
0:             if( remoteState!=null && remoteState instanceof TransactionalState) {
0:                 TransactionalState s = (TransactionalState) remoteState;
0:                 long txid = toLong(s.getTxnId());
0:                 message.setTransactionId(new LocalTransactionId(connectionId, txid));
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:     long nextTransactionId = 0;
0:     class Transaction {
0: 
0:     }
0:     HashMap<Long, Transaction> transactions = new HashMap<Long, Transaction>();
0: 
0:     public byte[] toBytes(long value) {
0:         Buffer buffer = new Buffer(8);
0:         buffer.bigEndianEditor().writeLong(value);
0:         return buffer.data;
0:     }
0: 
0:     private long toLong(Binary value) {
0:         Buffer buffer = new Buffer(value.getArray(), value.getArrayOffset(), value.getLength());
0:         return buffer.bigEndianEditor().readLong();
0:     }
0: 
0: 
0:     AmqpDeliveryListener coordinatorContext = new BaseProducerContext() {
0:         @Override
0:         protected void onMessage(Receiver receiver, final Delivery delivery, Buffer buffer) throws Exception {
0: 
0:             org.apache.qpid.proton.message.Message msg = new org.apache.qpid.proton.message.Message();
0: 
0:             int offset = buffer.offset;
0:             int len = buffer.length;
0:             while( len > 0 ) {
0:                 final int decoded = msg.decode(buffer.data, offset, len);
0:                 assert decoded > 0: "Make progress decoding the message";
0:                 offset += decoded;
0:                 len -= decoded;
0:             }
0: 
0:             Object action = ((AmqpValue)msg.getBody()).getValue();
0:             System.out.println("COORDINATOR received: "+action+", ["+buffer+"]");
0:             if( action instanceof Declare ) {
0:                 Declare declare = (Declare) action;
0:                 if( declare.getGlobalId()!=null ) {
0:                     throw new Exception("don't know how to handle a declare /w a set GlobalId");
0:                 }
0: 
0:                 long txid = nextTransactionId++;
0:                 TransactionInfo txinfo = new TransactionInfo(connectionId, new LocalTransactionId(connectionId, txid), TransactionInfo.BEGIN);
0:                 sendToActiveMQ(txinfo, null);
0:                 System.out.println("started transaction "+txid);
0: 
0:                 Declared declared = new Declared();
0:                 declared.setTxnId(new Binary(toBytes(txid)));
0:                 delivery.disposition(declared);
0:                 delivery.settle();
0: 
0:             } else if( action instanceof Discharge) {
0:                 Discharge discharge = (Discharge) action;
0:                 long txid = toLong(discharge.getTxnId());
0: 
0:                 byte operation;
0:                 if( discharge.getFail() ) {
0:                     System.out.println("rollback transaction "+txid);
0:                     operation = TransactionInfo.ROLLBACK ;
0:                 } else {
0:                     System.out.println("commit transaction "+txid);
0:                     operation = TransactionInfo.COMMIT_ONE_PHASE;
0:                 }
0:                 TransactionInfo txinfo = new TransactionInfo(connectionId, new LocalTransactionId(connectionId, txid), operation);
0:                 sendToActiveMQ(txinfo, new ResponseHandler() {
0:                     @Override
0:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                         if( response.isException() ) {
0:                             ExceptionResponse er = (ExceptionResponse)response;
0:                             Rejected rejected = new Rejected();
0:                             ArrayList errors = new ArrayList();
0:                             errors.add(er.getException().getMessage());
0:                             rejected.setError(errors);
0:                             delivery.disposition(rejected);
0:                         }
0:                         delivery.settle();
0:                         pumpProtonToSocket();
0:                     }
0:                 });
0:                 receiver.advance();
0: 
0:             } else {
0:                 throw new Exception("Expected coordinator message type: "+action.getClass());
0:             }
0: 
0:         }
0: 
0:     };
0: 
0:         org.apache.qpid.proton.type.transport.Target remoteTarget = receiver.getRemoteTarget();
0:         if( remoteTarget instanceof Coordinator ) {
0:             pumpProtonToSocket();
0:             receiver.setContext(coordinatorContext);
0:             receiver.flow(1024 * 64);
0:             receiver.open();
0:             pumpProtonToSocket();
0:         } else {
0:             ProducerId producerId = new ProducerId(sessionContext.sessionId, sessionContext.nextProducerId++);
0:             ActiveMQDestination dest = createDestination(remoteTarget);
0:             ProducerContext producerContext = new ProducerContext(producerId, dest);
0:             receiver.setContext(producerContext);
0:             receiver.flow(1024 * 64);
0:             ProducerInfo producerInfo = new ProducerInfo(producerId);
0:             producerInfo.setDestination(dest);
0:             sendToActiveMQ(producerInfo, new ResponseHandler() {
0:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                     receiver.open();
0:                     if (response.isException()) {
0:                         // If the connection attempt fails we close the socket.
0:                         Throwable exception = ((ExceptionResponse) response).getException();
0:                         receiver.close();
0:                     }
0:                     pumpProtonToSocket();
0:             });
0:         }
0: 
0:     }
0: 
0:     private ActiveMQDestination createDestination(Object terminus) {
0:         if( terminus == null ) {
0:             return null;
0:         } else if( terminus instanceof org.apache.qpid.proton.type.messaging.Source) {
0:             org.apache.qpid.proton.type.messaging.Source source = (org.apache.qpid.proton.type.messaging.Source)terminus;
0:             return ActiveMQDestination.createDestination(source.getAddress(), ActiveMQDestination.QUEUE_TYPE);
0:         } else if( terminus instanceof org.apache.qpid.proton.type.messaging.Target) {
0:             org.apache.qpid.proton.type.messaging.Target target = (org.apache.qpid.proton.type.messaging.Target)terminus;
0:             return ActiveMQDestination.createDestination(target.getAddress(), ActiveMQDestination.QUEUE_TYPE);
0:         } else if( terminus instanceof Coordinator ) {
0:             Coordinator target = (Coordinator)terminus;
0:             return null;
0:         } else {
0:             throw new RuntimeException("Unexpected terminus type: "+terminus);
0:         }
0:     }
0: 
0:     private Source createSource(ActiveMQDestination dest) {
0:         org.apache.qpid.proton.type.messaging.Source rc = new org.apache.qpid.proton.type.messaging.Source();
0:         rc.setAddress(inboundTransformer.getVendor().toAddress(dest));
0:         return rc;
0: 
0:         private boolean presettle;
0: 
0:         public ConsumerContext(ConsumerId consumerId, Sender sender) {
0:             this.consumerId = consumerId;
0:             this.sender = sender;
0:             this.presettle = sender.getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
0:         }
/////////////////////////////////////////////////////////////////////////
0:         void checkinTag(byte[] data) {
0:             if( tagCache.size() < 1024 ) {
0:                 tagCache.add(data);
0:             }
0: 
/////////////////////////////////////////////////////////////////////////
0:         public void pumpOutbound() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                             if( presettle ) {
0:                                 settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);
0:                             } else {
0:                                 sender.advance();
0:                             }
/////////////////////////////////////////////////////////////////////////
0:                     jms.setRedeliveryCounter(md.getRedeliveryCounter());
0:                         if( presettle ) {
0:                             currentDelivery = sender.delivery(EMPTY_BYTE_ARRAY, 0, 0);
0:                         } else {
0:                             final byte[] tag = nextTag();
0:                             currentDelivery = sender.delivery(tag, 0, tag.length);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:         private void settle(final Delivery delivery, int ackType) throws Exception {
0:             byte[] tag = delivery.getTag();
0:             if( tag !=null && tag.length>0 ) {
0:                 checkinTag(tag);
0: 
0:             if( ackType == -1) {
0:                 // we are going to settle, but redeliver.. we we won't yet ack to ActiveMQ
0:                 delivery.settle();
0:                 onMessageDispatch((MessageDispatch) delivery.getContext());
0:             } else {
0:                 MessageDispatch md = (MessageDispatch) delivery.getContext();
0:                 MessageAck ack = new MessageAck();
0:                 ack.setConsumerId(consumerId);
0:                 ack.setFirstMessageId(md.getMessage().getMessageId());
0:                 ack.setLastMessageId(md.getMessage().getMessageId());
0:                 ack.setMessageCount(1);
0:                 ack.setAckType((byte)ackType);
0: 
0:                 DeliveryState remoteState = delivery.getRemoteState();
0:                 if( remoteState!=null && remoteState instanceof TransactionalState) {
0:                     TransactionalState s = (TransactionalState) remoteState;
0:                     long txid = toLong(s.getTxnId());
0:                     ack.setTransactionId(new LocalTransactionId(connectionId, txid));
0:                 }
0: 
0:                 sendToActiveMQ(ack, new ResponseHandler() {
0:                     @Override
0:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                         delivery.settle();
0:                         pumpProtonToSocket();
0:                     }
0:                 });
0:             }
0:         }
0: 
0:         @Override
0:         public void drainCheck() {
0:             if( outbound.isEmpty() ) {
0:                 sender.drained();
0:             }
0:         }
0: 
0:         @Override
0:         public void onDelivery(Delivery delivery) throws Exception {
0:             MessageDispatch md = (MessageDispatch) delivery.getContext();
0:             final DeliveryState state = delivery.getRemoteState();
0:             if( state instanceof Accepted ) {
0:                 if( !delivery.remotelySettled() ) {
0:                     delivery.disposition(new Accepted());
0:                 }
0:                 settle(delivery, MessageAck.INDIVIDUAL_ACK_TYPE);
0:             } else if( state instanceof Rejected) {
0:                 // re-deliver /w incremented delivery counter.
0:                 md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
0:                 settle(delivery, -1);
0:             } else if( state instanceof Released) {
0:                 // re-deliver && don't increment the counter.
0:                 settle(delivery, -1);
0:             } else if( state instanceof Modified) {
0:                 Modified modified = (Modified) state;
0:                 if ( modified.getDeliveryFailed() ) {
0:                   // increment delivery counter..
0:                   md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
0:                 }
0:                 byte ackType = -1;
0:                 Boolean undeliverableHere = modified.getUndeliverableHere();
0:                 if( undeliverableHere !=null && undeliverableHere ) {
0:                     // receiver does not want the message..
0:                     // perhaps we should DLQ it?
0:                     ackType = MessageAck.POSION_ACK_TYPE;
0:                 }
0:                 settle(delivery, ackType);
0:             }
0:             pumpOutbound();
/////////////////////////////////////////////////////////////////////////
0:         // sender.get
0:         final Source remoteSource = sender.getRemoteSource();
0:         if( remoteSource != null ) {
0:             dest = createDestination(remoteSource);
/////////////////////////////////////////////////////////////////////////
0:             sender.setSource(createSource(dest));
commit:6baed7a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.activemq.util.IdGenerator;
0: import org.apache.activemq.util.LongSequenceGenerator;
0: import org.fusesource.hawtbuf.Buffer;
0: import org.fusesource.hawtbuf.ByteArrayOutputStream;
0: import javax.jms.JMSException;
0: import java.util.concurrent.locks.ReentrantLock;
/////////////////////////////////////////////////////////////////////////
0:     ReentrantLock lock = new ReentrantLock();
0: 
/////////////////////////////////////////////////////////////////////////
0:     private long nextTempDestinationId = 0;
0:     HashMap<Sender, ActiveMQDestination> tempDestinations = new HashMap<Sender, ActiveMQDestination>();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     InboundTransformer inboundTransformer = new AMQPNativeInboundTransformer(ActiveMQJMSVendor.INSTANCE);
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination dest = ActiveMQDestination.createDestination(receiver.getRemoteTargetAddress(), ActiveMQDestination.QUEUE_TYPE);
0:         ProducerContext producerContext = new ProducerContext(producerId, dest);
0:         producerInfo.setDestination(dest);
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination dest;
0:         if( sender.getRemoteSourceAddress() != null ) {
0:             dest = ActiveMQDestination.createDestination(sender.getRemoteSourceAddress(), ActiveMQDestination.QUEUE_TYPE);
0:         } else {
0:             // lets create a temp dest.
0: //            if (topic) {
0: //                dest = new ActiveMQTempTopic(info.getConnectionId(), tempDestinationIdGenerator.getNextSequenceId());
0: //            } else {
0:                 dest = new ActiveMQTempQueue(connectionId, nextTempDestinationId++);
0: //            }
0: 
0:             DestinationInfo info = new DestinationInfo();
0:             info.setConnectionId(connectionId);
0:             info.setOperationType(DestinationInfo.ADD_OPERATION_TYPE);
0:             info.setDestination(dest);
0:             sendToActiveMQ(info, null);
0:             tempDestinations.put(sender, dest);
0:             sender.setLocalSourceAddress(inboundTransformer.getVendor().toAddress(dest));
0:         }
0: 
0:         consumerInfo.setDestination(dest);
commit:72d72ab
/////////////////////////////////////////////////////////////////////////
0:             Receiver receiver = ((Receiver)delivery.getLink());
0:             if( !delivery.isReadable() ) {
0:                 System.out.println("it was not readable!");
0: //                delivery.settle();
0: //                receiver.advance();
0:                 return;
0:             }
0: 
0:             if( current==null ) {
/////////////////////////////////////////////////////////////////////////
0:             receiver.advance();
0:             delivery.settle();
0: 
/////////////////////////////////////////////////////////////////////////
0:         Buffer currentBuffer;
0:         Delivery currentDelivery;
0:                 while( currentBuffer !=null ) {
0:                     int sent = sender.send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);
0:                         currentBuffer.moveHead(sent);
0:                         if( currentBuffer.length == 0 ) {
0:                             currentDelivery.settle();
0:                             currentBuffer = null;
0:                             currentDelivery = null;
/////////////////////////////////////////////////////////////////////////
0:                         currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());
0:                         currentDelivery = sender.delivery(tag, 0, tag.length);
0:                         currentDelivery.setContext(md);
commit:cac8c9c
/////////////////////////////////////////////////////////////////////////
0:     InboundTransformer inboundTransformer = new JMSMappingInboundTransformer(ActiveMQJMSVendor.INSTANCE);
/////////////////////////////////////////////////////////////////////////
0:             EncodedMessage em = new EncodedMessage(delivery.getMessageFormat(), buffer.data, buffer.offset, buffer.length);
0:             final ActiveMQMessage message = (ActiveMQMessage) inboundTransformer.transform(em);
/////////////////////////////////////////////////////////////////////////
0:     OutboundTransformer outboundTransformer = new AutoOutboundTransformer(ActiveMQJMSVendor.INSTANCE);
/////////////////////////////////////////////////////////////////////////
0:                     final EncodedMessage amqp = outboundTransformer.transform(jms);
0:                     if( amqp!=null && amqp.getLength() > 0 ) {
0: 
0:                         current = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());
0:                         final byte[] tag = nextTag();
0:                         final Delivery delivery = sender.delivery(tag, 0, tag.length);
0:                         delivery.setContext(md);
0: 
0: 
commit:e7137b7
/////////////////////////////////////////////////////////////////////////
0: //                    System.out.println("writing: " + buffer.toString().substring(5).replaceAll("(..)", "$1 "));
/////////////////////////////////////////////////////////////////////////
0: //            System.out.println("reading: " + frame.toString().substring(5).replaceAll("(..)", "$1 "));
commit:7fe30bc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.amqp.transform.*;
0: import org.fusesource.hawtbuf.*;
0: import java.util.*;
0: 
0: import org.fusesource.hawtbuf.ByteArrayOutputStream;
/////////////////////////////////////////////////////////////////////////
0:     void pumpProtonToSocket() {
/////////////////////////////////////////////////////////////////////////
0:                 ((AmqpDeliveryListener)link.getContext()).onClose();
/////////////////////////////////////////////////////////////////////////
0:                 onSessionClose(session);
/////////////////////////////////////////////////////////////////////////
0:         pumpProtonToSocket();
/////////////////////////////////////////////////////////////////////////
0:         public void onClose() throws Exception {}
/////////////////////////////////////////////////////////////////////////
0:                 pumpProtonToSocket();
0:                     pumpProtonToSocket();
/////////////////////////////////////////////////////////////////////////
0:     private void onSessionClose(Session session) {
0:         AmqpSessionContext sessionContext = (AmqpSessionContext)session.getContext();
0:         sendToActiveMQ(new RemoveInfo(sessionContext.sessionId), null);
0:         session.close();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     InboundTransformer inboundTransformer = new AMQPNativeInboundTransformer(ActiveMQJMSVendor.INSTANCE);
0: 
0:         ByteArrayOutputStream current = new ByteArrayOutputStream();
0: 
0:         public void onDelivery(Delivery delivery) throws Exception {
0:             if( current ==null ) {
0:                 current = new ByteArrayOutputStream();
0:             }
0: 
0:             Receiver receiver = ((Receiver)delivery.getLink());
0:             int count;
0:             byte data[] = new byte[1024*4];
0:             while( (count = receiver.recv(data, 0, data.length)) > 0 ) {
0:                 current.write(data, 0, count);
0:             }
0: 
0:             // Expecting more deliveries..
0:             if( count == 0 ) {
0:                 return;
0:             }
0: 
0:             final Buffer buffer = current.toBuffer();
0:             final ActiveMQMessage message = (ActiveMQMessage) inboundTransformer.transform(delivery.getMessageFormat(), buffer.data, buffer.offset, buffer.length);
0:             current = null;
0: 
0:             if( message.getDestination()==null ) {
0:                 message.setJMSDestination(destination);
0:             }
0:             if( message.getMessageId()==null ) {
0:                 message.setMessageId(new MessageId(producerId, messageIdGenerator.getNextSequenceId()));
0:             }
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQDestination destination = ActiveMQDestination.createDestination(receiver.getRemoteTargetAddress(), ActiveMQDestination.QUEUE_TYPE);
/////////////////////////////////////////////////////////////////////////
0:                 pumpProtonToSocket();
0:     OutboundTransformer outboundTransformer = new AMQPNativeOutboundTransformer(ActiveMQJMSVendor.INSTANCE);
/////////////////////////////////////////////////////////////////////////
0:         @Override
0:         public void onClose() throws Exception {
0:             sendToActiveMQ(new RemoveInfo(consumerId), null);
0:         }
0: 
0:         LinkedList<MessageDispatch> outbound = new LinkedList<MessageDispatch>();
0: 
0:             outbound.addLast(md);
0:             pumpOutbound();
0:             pumpProtonToSocket();
0:         Buffer current;
0:         public void pumpOutbound() {
0:             while(true) {
0: 
0:                 while( current!=null ) {
0:                     int sent = sender.send(current.data, current.offset, current.length);
0:                     if( sent > 0 ) {
0:                         current.moveHead(sent);
0:                         if( current.length == 0 ) {
0:                             sender.advance();
0:                             current = null;
0:                     } else {
0:                         return;
0:                 }
0: 
0:                 if( outbound.isEmpty() ) {
0:                     return;
0:                 }
0: 
0:                 final MessageDispatch md = outbound.removeFirst();
0:                 final byte[] tag = nextTag();
0:                 final Delivery delivery = sender.delivery(tag, 0, tag.length);
0:                 delivery.setContext(md);
0: 
0:                 try {
0:                     final ActiveMQMessage jms = (ActiveMQMessage) md.getMessage();
0:                     final byte[] amqpMessage = outboundTransformer.transform(jms);
0:                     if( amqpMessage!=null && amqpMessage.length > 0 ) {
0:                         current = new Buffer(amqpMessage);
0:                     } else {
0:                         // TODO: message could not be generated what now?
0:                     }
0:                 } catch (Exception e) {
0:                     e.printStackTrace();
0:                 pumpOutbound();
/////////////////////////////////////////////////////////////////////////
0:                 pumpProtonToSocket();
commit:cdd5150
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.transport.amqp;
0: 
0: import org.apache.activemq.broker.BrokerContext;
0: import org.apache.activemq.command.*;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.util.*;
0: import org.apache.qpid.proton.engine.*;
0: import org.apache.qpid.proton.engine.Session;
0: import org.apache.qpid.proton.engine.impl.ConnectionImpl;
0: import org.apache.qpid.proton.engine.impl.DeliveryImpl;
0: import org.apache.qpid.proton.engine.impl.TransportImpl;
0: import org.fusesource.hawtbuf.Buffer;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0: 
0: import javax.jms.*;
0: import java.io.IOException;
0: import java.io.UnsupportedEncodingException;
0: import java.util.EnumSet;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.Map;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.zip.Inflater;
0: 
0: class AmqpProtocolConverter {
0: 
0:     public static final EnumSet<EndpointState> UNINITIALIZED_SET = EnumSet.of(EndpointState.UNINITIALIZED);
0:     public static final EnumSet<EndpointState> INITIALIZED_SET = EnumSet.complementOf(UNINITIALIZED_SET);
0:     public static final EnumSet<EndpointState> ACTIVE_STATE = EnumSet.of(EndpointState.ACTIVE);
0:     public static final EnumSet<EndpointState> CLOSED_STATE = EnumSet.of(EndpointState.CLOSED);
0:     private static final Logger LOG = LoggerFactory.getLogger(AmqpProtocolConverter.class);
0: 
0:     private final AmqpTransport amqpTransport;
0: 
0:     public AmqpProtocolConverter(AmqpTransport amqpTransport, BrokerContext brokerContext) {
0:         this.amqpTransport = amqpTransport;
0:     }
0: 
0: //
0: //    private static final Buffer PING_RESP_FRAME = new PINGRESP().encode();
0: //
0: //
0: //    private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
0: //    private final LongSequenceGenerator consumerIdGenerator = new LongSequenceGenerator();
0: //
0: //    private final ConcurrentHashMap<ConsumerId, AmqpSubscription> subscriptionsByConsumerId = new ConcurrentHashMap<ConsumerId, AmqpSubscription>();
0: //    private final ConcurrentHashMap<UTF8Buffer, AmqpSubscription> amqpSubscriptionByTopic = new ConcurrentHashMap<UTF8Buffer, AmqpSubscription>();
0: //    private final Map<UTF8Buffer, ActiveMQTopic> activeMQTopicMap = new LRUCache<UTF8Buffer, ActiveMQTopic>();
0: //    private final Map<Destination, UTF8Buffer> amqpTopicMap = new LRUCache<Destination, UTF8Buffer>();
0: //    private final Map<Short, MessageAck> consumerAcks = new LRUCache<Short, MessageAck>();
0: //    private final Map<Short, PUBREC> publisherRecs = new LRUCache<Short, PUBREC>();
0: //
0: //    private final AtomicBoolean connected = new AtomicBoolean(false);
0: //    private CONNECT connect;
0: //    private String clientId;
0: //    private final String QOS_PROPERTY_NAME = "QoSPropertyName";
0: 
0: 
0:     TransportImpl protonTransport = new TransportImpl();
0:     ConnectionImpl protonConnection = new ConnectionImpl();
0: 
0:     {
0:         this.protonTransport.bind(this.protonConnection);
0:     }
0: 
0:     void pumpOut() {
0:         try {
0:             int size = 1024 * 64;
0:             byte data[] = new byte[size];
0:             boolean done = false;
0:             while (!done) {
0:                 int count = protonTransport.output(data, 0, size);
0:                 if (count > 0) {
0:                     final Buffer buffer = new Buffer(data, 0, count);
0:                     System.out.println("writing: " + buffer.toString().substring(5).replaceAll("(..)", "$1 "));
0:                     amqpTransport.sendToAmqp(buffer);
0:                 } else {
0:                     done = true;
0:                 }
0:             }
0: //            System.out.println("write done");
0:         } catch (IOException e) {
0:             amqpTransport.onException(e);
0:         }
0:     }
0: 
0:     static class AmqpSessionContext {
0:         private final SessionId sessionId;
0:         long nextProducerId = 0;
0:         long nextConsumerId = 0;
0: 
0:         public AmqpSessionContext(ConnectionId connectionId, long id) {
0:             sessionId = new SessionId(connectionId, -1);
0: 
0:         }
0:     }
0: 
0:     /**
0:      * Convert a AMQP command
0:      */
0:     public void onAMQPData(Buffer frame) throws IOException, JMSException {
0: 
0: 
0:         try {
0:             System.out.println("reading: " + frame.toString().substring(5).replaceAll("(..)", "$1 "));
0:             protonTransport.input(frame.data, frame.offset, frame.length);
0:         } catch (Throwable e) {
0:             handleException(new AmqpProtocolException("Could not decode AMQP frame: " + frame, true, e));
0:         }
0: 
0:         try {
0: 
0:             // Handle the amqp open..
0:             if (protonConnection.getLocalState() == EndpointState.UNINITIALIZED && protonConnection.getRemoteState() != EndpointState.UNINITIALIZED) {
0:                 onConnectionOpen();
0:             }
0: 
0:             // Lets map amqp sessions to openwire sessions..
0:             Session session = protonConnection.sessionHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:             while (session != null) {
0: 
0:                 onSessionOpen(session);
0:                 session = protonConnection.sessionHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:             }
0: 
0: 
0:             Link link = protonConnection.linkHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:             while (link != null) {
0:                 onLinkOpen(link);
0:                 link = protonConnection.linkHead(UNINITIALIZED_SET, INITIALIZED_SET);
0:             }
0: 
0:             Delivery delivery = protonConnection.getWorkHead();
0:             while (delivery != null) {
0:                 AmqpDeliveryListener listener = (AmqpDeliveryListener) delivery.getLink().getContext();
0:                 if (listener != null) {
0:                     listener.onDelivery(delivery);
0:                 }
0:                 delivery = delivery.getWorkNext();
0:             }
0: 
0:             link = protonConnection.linkHead(ACTIVE_STATE, CLOSED_STATE);
0:             while (link != null) {
0:                 if (link instanceof Receiver) {
0: //                    listener.onReceiverClose((Receiver) link);
0:                 } else {
0: //                    listener.onSenderClose((Sender) link);
0:                 }
0:                 link.close();
0:                 link = link.next(ACTIVE_STATE, CLOSED_STATE);
0:             }
0: 
0:             session = protonConnection.sessionHead(ACTIVE_STATE, CLOSED_STATE);
0:             while (session != null) {
0:                 //TODO - close links?
0: //                listener.onSessionClose(session);
0:                 session.close();
0:                 session = session.next(ACTIVE_STATE, CLOSED_STATE);
0:             }
0:             if (protonConnection.getLocalState() == EndpointState.ACTIVE && protonConnection.getRemoteState() == EndpointState.CLOSED) {
0: //                listener.onConnectionClose(protonConnection);
0:                 protonConnection.close();
0:             }
0: 
0:         } catch (Throwable e) {
0:             handleException(new AmqpProtocolException("Could not process AMQP commands", true, e));
0:         }
0: 
0:         pumpOut();
0:     }
0: 
0:     public void onActiveMQCommand(Command command) throws Exception {
0:         if (command.isResponse()) {
0:             Response response = (Response) command;
0:             ResponseHandler rh = resposeHandlers.remove(Integer.valueOf(response.getCorrelationId()));
0:             if (rh != null) {
0:                 rh.onResponse(this, response);
0:             } else {
0:                 // Pass down any unexpected errors. Should this close the connection?
0:                 if (response.isException()) {
0:                     Throwable exception = ((ExceptionResponse) response).getException();
0:                     handleException(exception);
0:                 }
0:             }
0:         } else if (command.isMessageDispatch()) {
0:             MessageDispatch md = (MessageDispatch) command;
0:             ConsumerContext consumerContext = subscriptionsByConsumerId.get(md.getConsumerId());
0:             if (consumerContext != null) {
0:                 consumerContext.onMessageDispatch(md);
0:             }
0:         } else if (command.getDataStructureType() == ConnectionError.DATA_STRUCTURE_TYPE) {
0:             // Pass down any unexpected async errors. Should this close the connection?
0:             Throwable exception = ((ConnectionError) command).getException();
0:             handleException(exception);
0:         } else if (command.isBrokerInfo()) {
0:             //ignore
0:         } else {
0:             LOG.debug("Do not know how to process ActiveMQ Command " + command);
0:         }
0:     }
0: 
0:     private static final IdGenerator CONNECTION_ID_GENERATOR = new IdGenerator();
0:     private final ConnectionId connectionId = new ConnectionId(CONNECTION_ID_GENERATOR.generateId());
0:     private ConnectionInfo connectionInfo = new ConnectionInfo();
0:     private long nextSessionId = 0;
0: 
0:     static abstract class AmqpDeliveryListener {
0:         abstract public void onDelivery(Delivery delivery) throws Exception;
0:     }
0: 
0:     private void onConnectionOpen() throws AmqpProtocolException {
0:         connectionInfo.setResponseRequired(true);
0:         connectionInfo.setConnectionId(connectionId);
0: //        configureInactivityMonitor(connect.keepAlive());
0: 
0:         String clientId = protonConnection.getRemoteContainer();
0:         if (clientId != null && !clientId.isEmpty()) {
0:             connectionInfo.setClientId(clientId);
0:         } else {
0:             connectionInfo.setClientId("" + connectionInfo.getConnectionId().toString());
0:         }
0: 
0: 
0: //        String userName = "";
0: //        if (connect.userName() != null) {
0: //            userName = connect.userName().toString();
0: //        }
0: //        String passswd = "";
0: //        if (connect.password() != null) {
0: //            passswd = connect.password().toString();
0: //        }
0: //        connectionInfo.setUserName(userName);
0: //        connectionInfo.setPassword(passswd);
0: 
0:         connectionInfo.setTransportContext(amqpTransport.getPeerCertificates());
0: 
0:         sendToActiveMQ(connectionInfo, new ResponseHandler() {
0:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0: 
0:                 protonConnection.open();
0:                 pumpOut();
0: 
0:                 if (response.isException()) {
0:                     Throwable exception = ((ExceptionResponse) response).getException();
0: // TODO: figure out how to close /w an error.
0: //                    protonConnection.setLocalError(new EndpointError(exception.getClass().getName(), exception.getMessage()));
0:                     protonConnection.close();
0:                     pumpOut();
0:                     amqpTransport.onException(IOExceptionSupport.create(exception));
0:                     return;
0:                 }
0: 
0:             }
0:         });
0:     }
0: 
0:     private void onSessionOpen(Session session) {
0:         AmqpSessionContext sessionContext = new AmqpSessionContext(connectionId, nextSessionId++);
0:         session.setContext(sessionContext);
0:         sendToActiveMQ(new SessionInfo(sessionContext.sessionId), null);
0:         session.open();
0:     }
0: 
0:     private void onLinkOpen(Link link) {
0:         link.setLocalSourceAddress(link.getRemoteSourceAddress());
0:         link.setLocalTargetAddress(link.getRemoteTargetAddress());
0: 
0:         AmqpSessionContext sessionContext = (AmqpSessionContext) link.getSession().getContext();
0:         if (link instanceof Receiver) {
0:             onReceiverOpen((Receiver) link, sessionContext);
0:         } else {
0:             onSenderOpen((Sender) link, sessionContext);
0:         }
0:     }
0: 
0:     class ProducerContext extends AmqpDeliveryListener {
0:         private final ProducerId producerId;
0:         private final LongSequenceGenerator messageIdGenerator = new LongSequenceGenerator();
0:         private final ActiveMQDestination destination;
0: 
0:         public ProducerContext(ProducerId producerId, ActiveMQDestination destination) {
0:             this.producerId = producerId;
0:             this.destination = destination;
0:         }
0: 
0:         @Override
0:         public void onDelivery(Delivery delivery) throws JMSException {
0: //            delivery.
0:             ActiveMQMessage message = convertMessage((DeliveryImpl) delivery);
0:             message.setProducerId(producerId);
0:             message.onSend();
0: //            sendToActiveMQ(message, createResponseHandler(command));
0:             sendToActiveMQ(message, null);
0:         }
0: 
0:         ActiveMQMessage convertMessage(DeliveryImpl delivery) throws JMSException {
0:             ActiveMQBytesMessage msg = nextMessage(delivery);
0:             final Receiver receiver = (Receiver) delivery.getLink();
0:             byte buff[] = new byte[1024 * 4];
0:             int count = 0;
0:             while ((count = receiver.recv(buff, 0, buff.length)) >= 0) {
0:                 msg.writeBytes(buff, 0, count);
0:             }
0:             return msg;
0:         }
0: 
0:         ActiveMQBytesMessage current;
0: 
0:         private ActiveMQBytesMessage nextMessage(DeliveryImpl delivery) throws JMSException {
0:             if (current == null) {
0:                 current = new ActiveMQBytesMessage();
0:                 current.setJMSDestination(destination);
0:                 current.setProducerId(producerId);
0:                 current.setMessageId(new MessageId(producerId, messageIdGenerator.getNextSequenceId()));
0:                 current.setTimestamp(System.currentTimeMillis());
0:                 current.setPriority((byte) javax.jms.Message.DEFAULT_PRIORITY);
0: //            msg.setPersistent(command.qos() != QoS.AT_MOST_ONCE);
0: //            msg.setIntProperty(QOS_PROPERTY_NAME, command.qos().ordinal());
0:                 System.out.println(delivery.getLocalState() + "/" + delivery.getRemoteState());
0:             }
0:             return current;
0:         }
0: 
0:     }
0: 
0: 
0:     void onReceiverOpen(final Receiver receiver, AmqpSessionContext sessionContext) {
0:         // Client is producing to this receiver object
0: 
0:         ProducerId producerId = new ProducerId(sessionContext.sessionId, sessionContext.nextProducerId++);
0:         ActiveMQDestination destination = ActiveMQDestination.createDestination(receiver.getRemoteSourceAddress(), ActiveMQDestination.QUEUE_TYPE);
0:         ProducerContext producerContext = new ProducerContext(producerId, destination);
0: 
0:         receiver.setContext(producerContext);
0:         receiver.flow(1024 * 64);
0:         ProducerInfo producerInfo = new ProducerInfo(producerId);
0:         producerInfo.setDestination(destination);
0:         sendToActiveMQ(producerInfo, new ResponseHandler() {
0:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                 receiver.open();
0:                 if (response.isException()) {
0:                     // If the connection attempt fails we close the socket.
0:                     Throwable exception = ((ExceptionResponse) response).getException();
0:                     receiver.close();
0:                 }
0:                 pumpOut();
0:             }
0:         });
0: 
0:     }
0: 
0: 
0:     class ConsumerContext extends AmqpDeliveryListener {
0:         private final ConsumerId consumerId;
0:         private final Sender sender;
0: 
0:         long nextTagId = 0;
0:         HashSet<byte[]> tagCache = new HashSet<byte[]>();
0: 
0:         byte[] nextTag() {
0:             byte[] rc;
0:             if (tagCache != null && !tagCache.isEmpty()) {
0:                 final Iterator<byte[]> iterator = tagCache.iterator();
0:                 rc = iterator.next();
0:                 iterator.remove();
0:             } else {
0:                 try {
0:                     rc = Long.toHexString(nextTagId++).getBytes("UTF-8");
0:                 } catch (UnsupportedEncodingException e) {
0:                     throw new RuntimeException(e);
0:                 }
0:             }
0:             return rc;
0:         }
0: 
0:         public ConsumerContext(ConsumerId consumerId, Sender sender) {
0:             this.consumerId = consumerId;
0:             this.sender = sender;
0:         }
0: 
0:         // called when the connection receives a JMS message from ActiveMQ
0:         public void onMessageDispatch(MessageDispatch md) throws Exception {
0:             final byte[] tag = nextTag();
0:             final Delivery delivery = sender.delivery(tag, 0, tag.length);
0:             delivery.setContext(md);
0: 
0:             // Covert to an AMQP messages.
0:             org.apache.qpid.proton.message.Message msg = convertMessage(md.getMessage());
0:             byte buffer[] = new byte[1024*4];
0:             int c=0;
0: 
0:             // And send the AMQP message over the link.
0:             while( (c=msg.encode(buffer, 0 , 0)) >= 0 ) {
0:                 sender.send(buffer, 0, c);
0:             }
0:             sender.advance();
0: 
0:         }
0: 
0:         public org.apache.qpid.proton.message.Message convertMessage(Message message) throws Exception {
0: //            result.setContentEncoding();
0: //            QoS qoS;
0: //            if (message.propertyExists(QOS_PROPERTY_NAME)) {
0: //                int ordinal = message.getIntProperty(QOS_PROPERTY_NAME);
0: //                qoS = QoS.values()[ordinal];
0: //
0: //            } else {
0: //                qoS = message.isPersistent() ? QoS.AT_MOST_ONCE : QoS.AT_LEAST_ONCE;
0: //            }
0: //            result.qos(qoS);
0: 
0:             Buffer content = null;
0:             if (message.getDataStructureType() == ActiveMQTextMessage.DATA_STRUCTURE_TYPE) {
0:                 ActiveMQTextMessage msg = (ActiveMQTextMessage) message.copy();
0:                 msg.setReadOnlyBody(true);
0:                 String messageText = msg.getText();
0:                 content = new Buffer(messageText.getBytes("UTF-8"));
0:             } else if (message.getDataStructureType() == ActiveMQBytesMessage.DATA_STRUCTURE_TYPE) {
0:                 ActiveMQBytesMessage msg = (ActiveMQBytesMessage) message.copy();
0:                 msg.setReadOnlyBody(true);
0:                 byte[] data = new byte[(int) msg.getBodyLength()];
0:                 msg.readBytes(data);
0:                 content = new Buffer(data);
0:             } else if (message.getDataStructureType() == ActiveMQMapMessage.DATA_STRUCTURE_TYPE) {
0:                 ActiveMQMapMessage msg = (ActiveMQMapMessage) message.copy();
0:                 msg.setReadOnlyBody(true);
0:                 Map map = msg.getContentMap();
0:                 content = new Buffer(map.toString().getBytes("UTF-8"));
0:             } else {
0:                 ByteSequence byteSequence = message.getContent();
0:                 if (byteSequence != null && byteSequence.getLength() > 0) {
0:                     if (message.isCompressed()) {
0:                         Inflater inflater = new Inflater();
0:                         inflater.setInput(byteSequence.data, byteSequence.offset, byteSequence.length);
0:                         byte[] data = new byte[4096];
0:                         int read;
0:                         ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
0:                         while ((read = inflater.inflate(data)) != 0) {
0:                             bytesOut.write(data, 0, read);
0:                         }
0:                         byteSequence = bytesOut.toByteSequence();
0:                     }
0:                     content = new Buffer(byteSequence.data, byteSequence.offset, byteSequence.length);
0:                 } else {
0:                     content = new Buffer(0);
0:                 }
0:             }
0: 
0:             org.apache.qpid.proton.message.Message result = new org.apache.qpid.proton.message.Message();
0:             return result;
0:         }
0: 
0: 
0:         @Override
0:         public void onDelivery(Delivery delivery) throws JMSException {
0:             if( delivery.remotelySettled() ) {
0:                 MessageDispatch md = (MessageDispatch) delivery.getContext();
0:             }
0:         }
0: 
0:     }
0: 
0:     private final ConcurrentHashMap<ConsumerId, ConsumerContext> subscriptionsByConsumerId = new ConcurrentHashMap<ConsumerId, ConsumerContext>();
0: 
0:     void onSenderOpen(final Sender sender, AmqpSessionContext sessionContext) {
0: 
0:         ConsumerId id = new ConsumerId(sessionContext.sessionId, sessionContext.nextConsumerId++);
0:         ConsumerContext consumerContext = new ConsumerContext(id, sender);
0: 
0:         subscriptionsByConsumerId.put(id, consumerContext);
0: 
0:         ActiveMQDestination destination = ActiveMQDestination.createDestination(sender.getRemoteSourceAddress(), ActiveMQDestination.QUEUE_TYPE);
0: 
0:         sender.setContext(consumerContext);
0:         ConsumerInfo consumerInfo = new ConsumerInfo(id);
0:         consumerInfo.setDestination(destination);
0:         consumerInfo.setPrefetchSize(100);
0:         consumerInfo.setDispatchAsync(true);
0: 
0:         sendToActiveMQ(consumerInfo, new ResponseHandler() {
0:             public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0:                 sender.open();
0:                 if (response.isException()) {
0:                     Throwable exception = ((ExceptionResponse) response).getException();
0:                     sender.close();
0:                 }
0:                 pumpOut();
0:             }
0:         });
0: 
0:     }
0: 
0: //
0: //    QoS onSubscribe(SUBSCRIBE command, Topic topic) throws AmqpProtocolException {
0: //        ActiveMQDestination destination = new ActiveMQTopic(convertAMQPToActiveMQ(topic.name().toString()));
0: //        if (destination == null) {
0: //            throw new AmqpProtocolException("Invalid Destination.");
0: //        }
0: //
0: //        ConsumerId id = new ConsumerId(sessionId, consumerIdGenerator.getNextSequenceId());
0: //        ConsumerInfo consumerInfo = new ConsumerInfo(id);
0: //        consumerInfo.setDestination(destination);
0: //        consumerInfo.setPrefetchSize(1000);
0: //        consumerInfo.setDispatchAsync(true);
0: //        if (!connect.cleanSession() && (connect.clientId() != null)) {
0: //            //by default subscribers are persistent
0: //            consumerInfo.setSubscriptionName(connect.clientId().toString());
0: //        }
0: //
0: //        AmqpSubscription amqpSubscription = new AmqpSubscription(this, topic.qos(), consumerInfo);
0: //
0: //
0: //        amqpSubscriptionByTopic.put(topic.name(), amqpSubscription);
0: //
0: //        sendToActiveMQ(consumerInfo, null);
0: //        return topic.qos();
0: //    }
0: //
0: //    void onUnSubscribe(UNSUBSCRIBE command) {
0: //        UTF8Buffer[] topics = command.topics();
0: //        if (topics != null) {
0: //            for (int i = 0; i < topics.length; i++) {
0: //                onUnSubscribe(topics[i]);
0: //            }
0: //        }
0: //        UNSUBACK ack = new UNSUBACK();
0: //        ack.messageId(command.messageId());
0: //        pumpOut(ack.encode());
0: //
0: //    }
0: //
0: //    void onUnSubscribe(UTF8Buffer topicName) {
0: //        AmqpSubscription subs = amqpSubscriptionByTopic.remove(topicName);
0: //        if (subs != null) {
0: //            ConsumerInfo info = subs.getConsumerInfo();
0: //            if (info != null) {
0: //                subscriptionsByConsumerId.remove(info.getConsumerId());
0: //            }
0: //            RemoveInfo removeInfo = info.createRemoveCommand();
0: //            sendToActiveMQ(removeInfo, null);
0: //        }
0: //    }
0: //
0: //
0: //    /**
0: //     * Dispatch a ActiveMQ command
0: //     */
0: //
0: //
0: //
0: //    void onAMQPPublish(PUBLISH command) throws IOException, JMSException {
0: //        checkConnected();
0: //    }
0: //
0: //    void onAMQPPubAck(PUBACK command) {
0: //        short messageId = command.messageId();
0: //        MessageAck ack;
0: //        synchronized (consumerAcks) {
0: //            ack = consumerAcks.remove(messageId);
0: //        }
0: //        if (ack != null) {
0: //            amqpTransport.sendToActiveMQ(ack);
0: //        }
0: //    }
0: //
0: //    void onAMQPPubRec(PUBREC commnand) {
0: //        //from a subscriber - send a PUBREL in response
0: //        PUBREL pubrel = new PUBREL();
0: //        pubrel.messageId(commnand.messageId());
0: //        pumpOut(pubrel.encode());
0: //    }
0: //
0: //    void onAMQPPubRel(PUBREL command) {
0: //        PUBREC ack;
0: //        synchronized (publisherRecs) {
0: //            ack = publisherRecs.remove(command.messageId());
0: //        }
0: //        if (ack == null) {
0: //            LOG.warn("Unknown PUBREL: " + command.messageId() + " received");
0: //        }
0: //        PUBCOMP pubcomp = new PUBCOMP();
0: //        pubcomp.messageId(command.messageId());
0: //        pumpOut(pubcomp.encode());
0: //    }
0: //
0: //    void onAMQPPubComp(PUBCOMP command) {
0: //        short messageId = command.messageId();
0: //        MessageAck ack;
0: //        synchronized (consumerAcks) {
0: //            ack = consumerAcks.remove(messageId);
0: //        }
0: //        if (ack != null) {
0: //            amqpTransport.sendToActiveMQ(ack);
0: //        }
0: //    }
0: //
0: //
0: //
0: //
0: //    public AmqpTransport amqpTransport {
0: //        return amqpTransport;
0: //    }
0: //
0: //
0: //
0: //    void configureInactivityMonitor(short heartBeat) {
0: //        try {
0: //
0: //            int heartBeatMS = heartBeat * 1000;
0: //            AmqpInactivityMonitor monitor = amqpTransport.getInactivityMonitor();
0: //            monitor.setProtocolConverter(this);
0: //            monitor.setReadCheckTime(heartBeatMS);
0: //            monitor.setInitialDelayTime(heartBeatMS);
0: //            monitor.startMonitorThread();
0: //
0: //        } catch (Exception ex) {
0: //            LOG.warn("Failed to start AMQP InactivityMonitor ", ex);
0: //        }
0: //
0: //        LOG.debug(getClientId() + " AMQP Connection using heart beat of  " + heartBeat + " secs");
0: //    }
0: //
0: //
0: //
0: //    void checkConnected() throws AmqpProtocolException {
0: //        if (!connected.get()) {
0: //            throw new AmqpProtocolException("Not connected.");
0: //        }
0: //    }
0: //
0: //    private String getClientId() {
0: //        if (clientId == null) {
0: //            if (connect != null && connect.clientId() != null) {
0: //                clientId = connect.clientId().toString();
0: //            }
0: //        } else {
0: //            clientId = "";
0: //        }
0: //        return clientId;
0: //    }
0: //
0: //    private void stopTransport() {
0: //        try {
0: //            amqpTransport.stop();
0: //        } catch (Throwable e) {
0: //            LOG.debug("Failed to stop AMQP transport ", e);
0: //        }
0: //    }
0: //
0: //    ResponseHandler createResponseHandler(final PUBLISH command) {
0: //
0: //        if (command != null) {
0: //            switch (command.qos()) {
0: //                case AT_LEAST_ONCE:
0: //                    return new ResponseHandler() {
0: //                        public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0: //                            if (response.isException()) {
0: //                                LOG.warn("Failed to send AMQP Publish: ", command, ((ExceptionResponse) response).getException());
0: //                            } else {
0: //                                PUBACK ack = new PUBACK();
0: //                                ack.messageId(command.messageId());
0: //                                converter.amqpTransport.sendToAmqp(ack.encode());
0: //                            }
0: //                        }
0: //                    };
0: //                case EXACTLY_ONCE:
0: //                    return new ResponseHandler() {
0: //                        public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
0: //                            if (response.isException()) {
0: //                                LOG.warn("Failed to send AMQP Publish: ", command, ((ExceptionResponse) response).getException());
0: //                            } else {
0: //                                PUBREC ack = new PUBREC();
0: //                                ack.messageId(command.messageId());
0: //                                synchronized (publisherRecs) {
0: //                                    publisherRecs.put(command.messageId(), ack);
0: //                                }
0: //                                converter.amqpTransport.sendToAmqp(ack.encode());
0: //                            }
0: //                        }
0: //                    };
0: //                case AT_MOST_ONCE:
0: //                    break;
0: //            }
0: //        }
0: //        return null;
0: //    }
0: //
0: //    private String convertAMQPToActiveMQ(String name) {
0: //        String result = name.replace('#', '>');
0: //        result = result.replace('+', '*');
0: //        result = result.replace('/', '.');
0: //        return result;
0: //    }
0: 
0:     ////////////////////////////////////////////////////////////////////////////
0:     //
0:     // Implementation methods
0:     //
0:     ////////////////////////////////////////////////////////////////////////////
0: 
0:     private final Object commnadIdMutex = new Object();
0:     private int lastCommandId;
0: 
0:     int generateCommandId() {
0:         synchronized (commnadIdMutex) {
0:             return lastCommandId++;
0:         }
0:     }
0: 
0:     private final ConcurrentHashMap<Integer, ResponseHandler> resposeHandlers = new ConcurrentHashMap<Integer, ResponseHandler>();
0: 
0:     void sendToActiveMQ(Command command, ResponseHandler handler) {
0:         command.setCommandId(generateCommandId());
0:         if (handler != null) {
0:             command.setResponseRequired(true);
0:             resposeHandlers.put(Integer.valueOf(command.getCommandId()), handler);
0:         }
0:         amqpTransport.sendToActiveMQ(command);
0:     }
0: 
0:     void handleException(Throwable exception) {
0:         exception.printStackTrace();
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Exception detail", exception);
0:         }
0:         try {
0:             amqpTransport.stop();
0:         } catch (Throwable e) {
0:             LOG.error("Failed to stop AMQP Transport ", e);
0:         }
0:     }
0: 
0: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:b8a6e5a
/////////////////////////////////////////////////////////////////////////
0:     InboundTransformer inboundTransformer;
0: 
0:     protected InboundTransformer getInboundTransformer()  {
0:         if (inboundTransformer == null) {
0:             String transformer = amqpTransport.getTransformer();
0:             if (transformer.equals(InboundTransformer.TRANSFORMER_JMS)) {
0:                 inboundTransformer = new JMSMappingInboundTransformer(ActiveMQJMSVendor.INSTANCE);
0:             } else if (transformer.equals(InboundTransformer.TRANSFORMER_NATIVE)) {
0:                 inboundTransformer = new AMQPNativeInboundTransformer(ActiveMQJMSVendor.INSTANCE);
0:             } else if (transformer.equals(InboundTransformer.TRANSFORMER_RAW)) {
0:                 inboundTransformer = new AMQPRawInboundTransformer(ActiveMQJMSVendor.INSTANCE);
0:             } else {
0:                 LOG.warn("Unknown transformer type " + transformer + ", using native one instead");
0:                 inboundTransformer = new AMQPNativeInboundTransformer(ActiveMQJMSVendor.INSTANCE);
0:             }
0:         }
0:         return inboundTransformer;
0:     }
/////////////////////////////////////////////////////////////////////////
0:             final ActiveMQMessage message = (ActiveMQMessage) getInboundTransformer().transform(em);
/////////////////////////////////////////////////////////////////////////
0:         rc.setAddress(getInboundTransformer().getVendor().toAddress(dest));
commit:2a0a0b6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.qpid.proton.codec.Decoder;
0: import org.apache.qpid.proton.codec.DecoderImpl;
0: import org.apache.qpid.proton.type.DescribedType;
0: import org.apache.qpid.proton.type.Symbol;
/////////////////////////////////////////////////////////////////////////
0:     //InboundTransformer inboundTransformer = new AMQPNativeInboundTransformer(ActiveMQJMSVendor.INSTANCE);
0:     InboundTransformer inboundTransformer = new JMSMappingInboundTransformer(ActiveMQJMSVendor.INSTANCE);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Map filter = ((org.apache.qpid.proton.type.messaging.Source)remoteSource).getFilter();
0:         if (filter != null) {
0:             DescribedType type = (DescribedType)filter.get(Symbol.valueOf("jms-selector"));
0:             consumerInfo.setSelector(type.getDescribed().toString());
0:         }
============================================================================