1:03f38ae: /**
1:03f38ae:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:03f38ae:  * contributor license agreements.  See the NOTICE file distributed with
1:03f38ae:  * this work for additional information regarding copyright ownership.
1:03f38ae:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:03f38ae:  * (the "License"); you may not use this file except in compliance with
1:03f38ae:  * the License.  You may obtain a copy of the License at
1:03f38ae:  *
1:03f38ae:  *      http://www.apache.org/licenses/LICENSE-2.0
1:03f38ae:  *
1:03f38ae:  * Unless required by applicable law or agreed to in writing, software
1:03f38ae:  * distributed under the License is distributed on an "AS IS" BASIS,
1:03f38ae:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:03f38ae:  * See the License for the specific language governing permissions and
1:03f38ae:  * limitations under the License.
1:03f38ae:  */
1:4743a20: 
1:03f38ae: package org.apache.activemq.store;
1:9705671: 
1:3985e72: import java.util.concurrent.TimeUnit;
1:a2697b8: import java.util.concurrent.atomic.AtomicInteger;
1:03f38ae: import javax.jms.Connection;
1:3557361: import javax.jms.DeliveryMode;
1:c4425ca: import javax.jms.Message;
1:c4425ca: import javax.jms.MessageConsumer;
1:a2697b8: import javax.jms.MessageListener;
1:03f38ae: import javax.jms.MessageProducer;
1:03f38ae: import javax.jms.Queue;
1:03f38ae: import javax.jms.Session;
1:03f38ae: import javax.jms.Topic;
1:c4425ca: import javax.jms.TopicSubscriber;
1:c4425ca: 
1:03f38ae: import org.apache.activemq.ActiveMQConnectionFactory;
1:9705671: import org.apache.activemq.ActiveMQPrefetchPolicy;
1:c4425ca: import org.apache.activemq.CombinationTestSupport;
1:03f38ae: import org.apache.activemq.broker.BrokerService;
1:eece28a: import org.apache.activemq.broker.region.DestinationStatistics;
1:eece28a: import org.apache.activemq.broker.region.RegionBroker;
1:03f38ae: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:03f38ae: import org.apache.activemq.broker.region.policy.PolicyMap;
1:fe31092: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
1:7d54942: import org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy;
1:c4425ca: import org.apache.activemq.command.ActiveMQDestination;
1:c4425ca: import org.apache.activemq.command.ActiveMQQueue;
1:c4425ca: import org.apache.activemq.command.ActiveMQTopic;
1:d2f8ede: import org.apache.activemq.util.Wait;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:c4425ca: 
1:c4425ca: abstract public class MessagePriorityTest extends CombinationTestSupport {
1:4743a20: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(MessagePriorityTest.class);
1:c4425ca: 
1:03f38ae:     BrokerService broker;
1:03f38ae:     PersistenceAdapter adapter;
1:4743a20: 
1:69dc0d4:     protected ActiveMQConnectionFactory factory;
1:69dc0d4:     protected Connection conn;
1:3432a75:     protected Session sess;
1:4743a20: 
1:06cbebc:     public boolean useCache = true;
1:3557361:     public int deliveryMode = Message.DEFAULT_DELIVERY_MODE;
1:06cbebc:     public boolean dispatchAsync = true;
1:06cbebc:     public boolean prioritizeMessages = true;
1:3ddb71c:     public boolean immediatePriorityDispatch = true;
1:9705671:     public int prefetchVal = 500;
1:f79f7ad:     public int expireMessagePeriod = 30000;
1:9705671: 
1:3432a75:     public int MSG_NUM = 600;
1:3432a75:     public int HIGH_PRI = 7;
1:3432a75:     public int LOW_PRI = 3;
1:eece28a:     public int MED_PRI = 4;
1:4743a20: 
1:03f38ae:     abstract protected PersistenceAdapter createPersistenceAdapter(boolean delete) throws Exception;
1:4743a20: 
1:4743a20:     @Override
1:03f38ae:     protected void setUp() throws Exception {
1:03f38ae:         broker = new BrokerService();
1:03f38ae:         broker.setBrokerName("priorityTest");
1:9705671:         broker.setAdvisorySupport(false);
1:03f38ae:         adapter = createPersistenceAdapter(true);
1:03f38ae:         broker.setPersistenceAdapter(adapter);
1:03f38ae:         PolicyEntry policy = new PolicyEntry();
1:06cbebc:         policy.setPrioritizedMessages(prioritizeMessages);
1:c4425ca:         policy.setUseCache(useCache);
1:f79f7ad:         policy.setExpireMessagesPeriod(expireMessagePeriod);
1:7d54942:         StorePendingDurableSubscriberMessageStoragePolicy durableSubPending =
1:7d54942:                 new StorePendingDurableSubscriberMessageStoragePolicy();
1:3ddb71c:         durableSubPending.setImmediatePriorityDispatch(immediatePriorityDispatch);
1:fe31092:         durableSubPending.setUseCache(useCache);
1:7d54942:         policy.setPendingDurableSubscriberPolicy(durableSubPending);
1:03f38ae:         PolicyMap policyMap = new PolicyMap();
1:4679c8a:         policyMap.put(new ActiveMQQueue("TEST"), policy);
1:4679c8a:         policyMap.put(new ActiveMQTopic("TEST"), policy);
1:fe31092: 
1:fe31092:         // do not process expired for one test
1:fe31092:         PolicyEntry ignoreExpired = new PolicyEntry();
1:fe31092:         SharedDeadLetterStrategy ignoreExpiredStrategy = new SharedDeadLetterStrategy();
1:fe31092:         ignoreExpiredStrategy.setProcessExpired(false);
1:fe31092:         ignoreExpired.setDeadLetterStrategy(ignoreExpiredStrategy);
1:fe31092:         policyMap.put(new ActiveMQTopic("TEST_CLEANUP_NO_PRIORITY"), ignoreExpired);
1:fe31092: 
1:f2a335c:         PolicyEntry noCachePolicy = new PolicyEntry();
1:f2a335c:         noCachePolicy.setUseCache(false);
1:f2a335c:         noCachePolicy.setPrioritizedMessages(true);
1:f2a335c:         policyMap.put(new ActiveMQQueue("TEST_LOW_THEN_HIGH_10"), noCachePolicy);
1:f2a335c: 
1:03f38ae:         broker.setDestinationPolicy(policyMap);
1:03f38ae:         broker.start();
1:03f38ae:         broker.waitUntilStarted();
1:4743a20: 
1:03f38ae:         factory = new ActiveMQConnectionFactory("vm://priorityTest");
1:5af5b59:         factory.setMessagePrioritySupported(true);
1:9705671:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:9705671:         prefetch.setAll(prefetchVal);
1:9705671:         factory.setPrefetchPolicy(prefetch);
1:9705671:         factory.setWatchTopicAdvisories(false);
1:3432a75:         factory.setDispatchAsync(dispatchAsync);
1:03f38ae:         conn = factory.createConnection();
1:c4425ca:         conn.setClientID("priority");
1:c4425ca:         conn.start();
1:03f38ae:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:03f38ae:     }
1:a2697b8: 
1:4743a20:     @Override
1:03f38ae:     protected void tearDown() throws Exception {
1:06cbebc:         try {
1:06cbebc:             sess.close();
1:06cbebc:             conn.close();
1:06cbebc:         } catch (Exception ignored) {
1:06cbebc:         } finally {
1:06cbebc:             broker.stop();
1:06cbebc:             broker.waitUntilStopped();
1:06cbebc:         }
1:03f38ae:     }
1:4743a20: 
1:03f38ae:     public void testStoreConfigured() throws Exception {
1:d2f8ede:         final Queue queue = sess.createQueue("TEST");
1:d2f8ede:         final Topic topic = sess.createTopic("TEST");
1:4743a20: 
1:03f38ae:         MessageProducer queueProducer = sess.createProducer(queue);
1:03f38ae:         MessageProducer topicProducer = sess.createProducer(topic);
1:d2f8ede: 
1:d2f8ede:         Wait.waitFor(new Wait.Condition() {
1:d2f8ede:             @Override
1:d2f8ede:             public boolean isSatisified() throws Exception {
1:d2f8ede:                 return broker.getRegionBroker().getDestinationMap().get(queue) != null;
1:d2f8ede:             }
1:d2f8ede:         });
1:03f38ae:         assertTrue(broker.getRegionBroker().getDestinationMap().get(queue).getMessageStore().isPrioritizedMessages());
1:d2f8ede: 
1:d2f8ede:         Wait.waitFor(new Wait.Condition(){
1:d2f8ede:             @Override
1:d2f8ede:             public boolean isSatisified() throws Exception {
1:d2f8ede:                 return broker.getRegionBroker().getDestinationMap().get(topic) != null;
1:d2f8ede:             }
1:d2f8ede:         });
1:03f38ae:         assertTrue(broker.getRegionBroker().getDestinationMap().get(topic).getMessageStore().isPrioritizedMessages());
1:4743a20: 
1:03f38ae:         queueProducer.close();
1:03f38ae:         topicProducer.close();
1:4743a20: 
1:03f38ae:     }
1:4743a20: 
1:3432a75:     protected class ProducerThread extends Thread {
1:7d54942: 
1:c4425ca:         int priority;
1:c4425ca:         int messageCount;
1:c4425ca:         ActiveMQDestination dest;
1:4743a20: 
1:c4425ca:         public ProducerThread(ActiveMQDestination dest, int messageCount, int priority) {
1:7d54942:             this.messageCount = messageCount;
1:c4425ca:             this.priority = priority;
1:c4425ca:             this.dest = dest;
1:c4425ca:         }
1:4743a20: 
1:4743a20:         @Override
1:c4425ca:         public void run() {
1:c4425ca:             try {
1:c4425ca:                 MessageProducer producer = sess.createProducer(dest);
1:c4425ca:                 producer.setPriority(priority);
1:3557361:                 producer.setDeliveryMode(deliveryMode);
1:c4425ca:                 for (int i = 0; i < messageCount; i++) {
1:c4425ca:                     producer.send(sess.createTextMessage("message priority: " + priority));
1:c4425ca:                 }
1:c4425ca:             } catch (Exception e) {
1:c4425ca:                 e.printStackTrace();
1:c4425ca:             }
1:c4425ca:         }
1:7d54942: 
1:7d54942:         public void setMessagePriority(int priority) {
1:7d54942:             this.priority = priority;
1:7d54942:         }
1:7d54942: 
1:7d54942:         public void setMessageCount(int messageCount) {
1:4743a20:             this.messageCount = messageCount;
1:7d54942:         }
1:4743a20: 
1:c4425ca:     }
1:4743a20: 
1:c4425ca:     public void initCombosForTestQueues() {
1:c4425ca:         addCombinationValues("useCache", new Object[] {new Boolean(true), new Boolean(false)});
1:3557361:         addCombinationValues("deliveryMode", new Object[] {new Integer(DeliveryMode.NON_PERSISTENT), new Integer(DeliveryMode.PERSISTENT)});
1:c4425ca:     }
1:4743a20: 
1:c4425ca:     public void testQueues() throws Exception {
1:c4425ca:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST");
1:7d54942: 
1:c4425ca:         ProducerThread lowPri = new ProducerThread(queue, MSG_NUM, LOW_PRI);
1:c4425ca:         ProducerThread highPri = new ProducerThread(queue, MSG_NUM, HIGH_PRI);
1:4743a20: 
1:c4425ca:         lowPri.start();
1:c4425ca:         highPri.start();
1:4743a20: 
1:c4425ca:         lowPri.join();
1:c4425ca:         highPri.join();
1:4743a20: 
1:c4425ca:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:c4425ca:         for (int i = 0; i < MSG_NUM * 2; i++) {
1:f79f7ad:             Message msg = queueConsumer.receive(5000);
1:3432a75:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
1:12f0195:             assertNotNull("Message " + i + " was null", msg);
1:c4425ca:             assertEquals("Message " + i + " has wrong priority", i < MSG_NUM ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:c4425ca:         }
1:c4425ca:     }
1:f79f7ad: 
1:c4425ca:     protected Message createMessage(int priority) throws Exception {
1:06cbebc:         final String text = "priority " + priority;
1:c4425ca:         Message msg = sess.createTextMessage(text);
1:c4425ca:         LOG.info("Sending  " + text);
1:c4425ca:         return msg;
1:c4425ca:     }
1:4679c8a: 
1:9705671:     public void initCombosForTestDurableSubs() {
1:9705671:         addCombinationValues("prefetchVal", new Object[] {new Integer(1000), new Integer(MSG_NUM/4)});
1:9705671:     }
1:4743a20: 
1:c4425ca:     public void testDurableSubs() throws Exception {
1:c4425ca:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:c4425ca:         TopicSubscriber sub = sess.createDurableSubscriber(topic, "priority");
1:c4425ca:         sub.close();
1:4743a20: 
1:c4425ca:         ProducerThread lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:c4425ca:         ProducerThread highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
1:4743a20: 
1:c4425ca:         lowPri.start();
1:c4425ca:         highPri.start();
1:4743a20: 
1:c4425ca:         lowPri.join();
1:c4425ca:         highPri.join();
1:4743a20: 
1:c4425ca:         sub = sess.createDurableSubscriber(topic, "priority");
1:c4425ca:         for (int i = 0; i < MSG_NUM * 2; i++) {
2:9705671:             Message msg = sub.receive(5000);
1:4f5e620:             assertNotNull("Message " + i + " was null", msg);
1:c4425ca:             assertEquals("Message " + i + " has wrong priority", i < MSG_NUM ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:c4425ca:         }
1:4679c8a: 
1:9705671: 
1:4679c8a:         // verify that same broker/store can deal with non priority dest also
1:4679c8a:         topic = (ActiveMQTopic)sess.createTopic("HAS_NO_PRIORITY");
1:4679c8a:         sub = sess.createDurableSubscriber(topic, "no_priority");
1:4679c8a:         sub.close();
1:4679c8a: 
1:4679c8a:         lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:4679c8a:         highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
1:4679c8a: 
1:4679c8a:         lowPri.start();
1:4679c8a:         highPri.start();
1:4679c8a: 
1:4679c8a:         lowPri.join();
1:4679c8a:         highPri.join();
1:4679c8a: 
1:4679c8a:         sub = sess.createDurableSubscriber(topic, "no_priority");
1:4679c8a:         // verify we got them all
1:4679c8a:         for (int i = 0; i < MSG_NUM * 2; i++) {
1:4679c8a:             Message msg = sub.receive(5000);
1:4679c8a:             assertNotNull("Message " + i + " was null", msg);
1:4679c8a:         }
1:4679c8a: 
1:c4425ca:     }
1:9705671: 
1:9705671:     public void initCombosForTestDurableSubsReconnect() {
1:9705671:         addCombinationValues("prefetchVal", new Object[] {new Integer(1000), new Integer(MSG_NUM/2)});
1:06cbebc:         // REVISIT = is dispatchAsync = true a problem or is it just the test?
1:06cbebc:         addCombinationValues("dispatchAsync", new Object[] {Boolean.FALSE});
1:06cbebc:         addCombinationValues("useCache", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:9705671:     }
1:4743a20: 
1:9705671:     public void testDurableSubsReconnect() throws Exception {
1:9705671:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:9705671:         final String subName = "priorityDisconnect";
1:9705671:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:9705671:         sub.close();
1:9705671: 
1:9705671:         ProducerThread lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:9705671:         ProducerThread highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
1:9705671: 
1:9705671:         lowPri.start();
1:9705671:         highPri.start();
1:9705671: 
1:9705671:         lowPri.join();
1:9705671:         highPri.join();
1:9705671: 
1:9705671: 
1:9705671:         final int closeFrequency = MSG_NUM/4;
1:9705671:         sub = sess.createDurableSubscriber(topic, subName);
1:9705671:         for (int i = 0; i < MSG_NUM * 2; i++) {
1:7d54942:             Message msg = sub.receive(15000);
1:3432a75:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
1:9705671:             assertNotNull("Message " + i + " was null", msg);
1:9705671:             assertEquals("Message " + i + " has wrong priority", i < MSG_NUM ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:9705671:             if (i>0 && i%closeFrequency==0) {
1:9705671:                 LOG.info("Closing durable sub.. on: " + i);
1:9705671:                 sub.close();
1:9705671:                 sub = sess.createDurableSubscriber(topic, subName);
1:9705671:             }
1:9705671:         }
1:9705671:     }
1:7d54942: 
1:7d54942:     public void testHighPriorityDelivery() throws Exception {
1:7d54942: 
1:7d54942:         // get zero prefetch
1:7d54942:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:7d54942:         prefetch.setAll(0);
1:7d54942:         factory.setPrefetchPolicy(prefetch);
1:7d54942:         conn.close();
1:7d54942:         conn = factory.createConnection();
1:7d54942:         conn.setClientID("priority");
1:7d54942:         conn.start();
1:7d54942:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:7d54942: 
1:7d54942:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:7d54942:         final String subName = "priorityDisconnect";
1:7d54942:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:7d54942:         sub.close();
1:7d54942: 
1:6519c3e:         final int numToProduce = 2000;
1:6519c3e:         final int[] dups = new int[numToProduce*2];
1:6519c3e:         ProducerThread producerThread = new ProducerThread(topic, numToProduce, LOW_PRI+1);
2:7d54942:         producerThread.run();
1:7d54942:         LOG.info("Low priority messages sent");
1:6519c3e: 
1:7d54942:         sub = sess.createDurableSubscriber(topic, subName);
1:6519c3e:         final int batchSize = 250;
1:6519c3e:         int lowLowCount = 0;
1:6519c3e:         for (int i=0; i<numToProduce; i++) {
1:6519c3e:             Message msg = sub.receive(15000);
1:fe31092:             LOG.info("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() + ", priority:" + msg.getJMSPriority() : null));
1:6519c3e:             assertNotNull("Message " + i + " was null", msg);
1:6519c3e:             assertEquals("Message " + i + " has wrong priority", LOW_PRI+1, msg.getJMSPriority());
1:6519c3e:             assertTrue("not duplicate ", dups[i] == 0);
1:6519c3e:             dups[i] = 1;
1:6519c3e: 
1:6519c3e:             if (i % batchSize == 0) {
1:6519c3e:                 producerThread.setMessagePriority(HIGH_PRI);
1:6519c3e:                 producerThread.setMessageCount(1);
1:6519c3e:                 producerThread.run();
1:6519c3e:                 LOG.info("High priority message sent, should be able to receive immediately");
1:6519c3e: 
1:6519c3e:                 if (i % batchSize*2 == 0) {
1:6519c3e:                     producerThread.setMessagePriority(HIGH_PRI -1);
1:6519c3e:                     producerThread.setMessageCount(1);
1:6519c3e:                     producerThread.run();
1:6519c3e:                     LOG.info("High -1 priority message sent, should be able to receive immediately");
1:6519c3e:                 }
1:6519c3e: 
1:6519c3e:                 if (i % batchSize*4 == 0) {
1:6519c3e:                     producerThread.setMessagePriority(LOW_PRI);
1:6519c3e:                     producerThread.setMessageCount(1);
1:6519c3e:                     producerThread.run();
1:6519c3e:                     lowLowCount++;
1:6519c3e:                     LOG.info("Low low priority message sent, should not be able to receive immediately");
1:6519c3e:                 }
1:fe31092: 
1:6519c3e:                 msg = sub.receive(15000);
1:6519c3e:                 assertNotNull("Message was null", msg);
1:6519c3e:                 LOG.info("received hi? : " + msg);
1:6519c3e:                 assertEquals("high priority", HIGH_PRI, msg.getJMSPriority());
1:4743a20: 
1:6519c3e:                 if (i % batchSize*2 == 0) {
1:6519c3e:                     msg = sub.receive(15000);
1:6519c3e:                     assertNotNull("Message was null", msg);
1:6519c3e:                     LOG.info("received hi -1 ? i=" + i + ", " + msg);
1:6519c3e:                     assertEquals("high priority", HIGH_PRI -1, msg.getJMSPriority());
1:6519c3e:                 }
1:6519c3e:             }
1:6519c3e:         }
1:6519c3e:         for (int i=0; i<lowLowCount; i++) {
1:7d54942:             Message msg = sub.receive(15000);
1:7d54942:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
1:7d54942:             assertNotNull("Message " + i + " was null", msg);
1:7d54942:             assertEquals("Message " + i + " has wrong priority", LOW_PRI, msg.getJMSPriority());
1:fe31092:         }
1:7d54942:     }
1:fe31092: 
1:fe31092: 
1:fe31092:     public void initCombosForTestHighPriorityDeliveryInterleaved() {
1:fe31092:         addCombinationValues("useCache", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:fe31092:     }
1:fe31092: 
1:fe31092:     public void testHighPriorityDeliveryInterleaved() throws Exception {
1:fe31092: 
1:fe31092:         // get zero prefetch
1:fe31092:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:fe31092:         prefetch.setAll(0);
1:fe31092:         factory.setPrefetchPolicy(prefetch);
1:fe31092:         conn.close();
1:fe31092:         conn = factory.createConnection();
1:fe31092:         conn.setClientID("priority");
1:fe31092:         conn.start();
1:fe31092:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:fe31092: 
1:fe31092:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:fe31092:         final String subName = "priorityDisconnect";
1:fe31092:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:fe31092:         sub.close();
1:fe31092: 
1:fe31092:         ProducerThread producerThread = new ProducerThread(topic, 1, HIGH_PRI);
1:fe31092:         producerThread.run();
1:fe31092: 
1:fe31092:         producerThread.setMessagePriority(HIGH_PRI -1);
1:fe31092:         producerThread.setMessageCount(1);
1:fe31092:         producerThread.run();
1:fe31092: 
1:fe31092:         producerThread.setMessagePriority(LOW_PRI);
1:fe31092:         producerThread.setMessageCount(1);
1:fe31092:         producerThread.run();
1:fe31092:         LOG.info("Ordered priority messages sent");
1:fe31092: 
1:fe31092:         sub = sess.createDurableSubscriber(topic, subName);
1:fe31092: 
1:fe31092:         Message msg = sub.receive(15000);
1:fe31092:         assertNotNull("Message was null", msg);
1:fe31092:         LOG.info("received " + msg.getJMSMessageID() + ", priority:" + msg.getJMSPriority());
1:fe31092:         assertEquals("Message has wrong priority", HIGH_PRI, msg.getJMSPriority());
1:fe31092: 
1:fe31092:         producerThread.setMessagePriority(LOW_PRI+1);
1:fe31092:         producerThread.setMessageCount(1);
1:fe31092:         producerThread.run();
1:fe31092: 
1:fe31092:         msg = sub.receive(15000);
1:fe31092:         assertNotNull("Message was null", msg);
1:fe31092:         LOG.info("received " + msg.getJMSMessageID() + ", priority:" + msg.getJMSPriority());
1:fe31092:         assertEquals("high priority", HIGH_PRI -1, msg.getJMSPriority());
1:fe31092: 
1:fe31092:         msg = sub.receive(15000);
1:fe31092:         assertNotNull("Message was null", msg);
1:fe31092:         LOG.info("received hi? : " + msg);
1:fe31092:         assertEquals("high priority", LOW_PRI +1, msg.getJMSPriority());
1:fe31092: 
1:fe31092:         msg = sub.receive(15000);
1:fe31092:         assertNotNull("Message was null", msg);
1:fe31092:         LOG.info("received hi? : " + msg);
1:fe31092:         assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:fe31092: 
1:fe31092:         msg = sub.receive(4000);
1:fe31092:         assertNull("Message was null", msg);
1:fe31092:     }
1:fe31092: 
1:fe31092:     // immediatePriorityDispatch is only relevant when cache is exhausted
1:fe31092:     public void initCombosForTestHighPriorityDeliveryThroughBackLog() {
1:fe31092:         addCombinationValues("useCache", new Object[] {Boolean.FALSE});
1:fe31092:         addCombinationValues("immediatePriorityDispatch", new Object[] {Boolean.TRUE});
1:fe31092:     }
1:fe31092: 
1:fe31092:     public void testHighPriorityDeliveryThroughBackLog() throws Exception {
1:fe31092: 
1:fe31092:         // get zero prefetch
1:fe31092:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:fe31092:         prefetch.setAll(0);
1:fe31092:         factory.setPrefetchPolicy(prefetch);
1:fe31092:         conn.close();
1:fe31092:         conn = factory.createConnection();
1:fe31092:         conn.setClientID("priority");
1:fe31092:         conn.start();
1:fe31092:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:fe31092: 
1:fe31092:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:fe31092:         final String subName = "priorityDisconnect";
1:fe31092:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:fe31092:         sub.close();
1:fe31092: 
1:fe31092:         ProducerThread producerThread = new ProducerThread(topic, 600, LOW_PRI);
1:fe31092:         producerThread.run();
1:fe31092: 
1:fe31092: 
1:fe31092:         sub = sess.createDurableSubscriber(topic, subName);
2:fe31092:         int count = 0;
1:fe31092: 
1:fe31092:         for (;count < 300; count++) {
1:fe31092:             Message msg = sub.receive(15000);
1:fe31092:             assertNotNull("Message was null", msg);
1:fe31092:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:fe31092:         }
1:fe31092: 
1:fe31092:         producerThread.setMessagePriority(HIGH_PRI);
1:fe31092:         producerThread.setMessageCount(1);
1:fe31092:         producerThread.run();
1:fe31092: 
1:fe31092:         Message msg = sub.receive(15000);
1:fe31092:         assertNotNull("Message was null", msg);
1:fe31092:         assertEquals("high priority", HIGH_PRI, msg.getJMSPriority());
1:fe31092: 
1:fe31092:         for (;count < 600; count++) {
1:fe31092:             msg = sub.receive(15000);
1:fe31092:             assertNotNull("Message was null", msg);
1:fe31092:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:fe31092:         }
1:fe31092:     }
1:fe31092: 
1:fe31092: 
1:fe31092:     public void initCombosForTestHighPriorityNonDeliveryThroughBackLog() {
1:fe31092:         addCombinationValues("useCache", new Object[] {Boolean.FALSE});
1:fe31092:         addCombinationValues("immediatePriorityDispatch", new Object[] {Boolean.FALSE});
1:fe31092:     }
1:fe31092: 
1:fe31092:     public void testHighPriorityNonDeliveryThroughBackLog() throws Exception {
1:fe31092: 
1:fe31092:         // get zero prefetch
1:fe31092:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:fe31092:         prefetch.setAll(0);
1:fe31092:         factory.setPrefetchPolicy(prefetch);
1:fe31092:         conn.close();
1:fe31092:         conn = factory.createConnection();
1:fe31092:         conn.setClientID("priority");
1:fe31092:         conn.start();
1:fe31092:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:fe31092: 
1:fe31092:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:fe31092:         final String subName = "priorityDisconnect";
1:fe31092:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:fe31092:         sub.close();
1:fe31092: 
1:fe31092:         ProducerThread producerThread = new ProducerThread(topic, 600, LOW_PRI);
1:fe31092:         producerThread.run();
1:fe31092: 
1:fe31092: 
1:fe31092:         sub = sess.createDurableSubscriber(topic, subName);
1:fe31092:         int count = 0;
1:fe31092: 
1:fe31092:         for (;count < 300; count++) {
1:fe31092:             Message msg = sub.receive(15000);
1:fe31092:             assertNotNull("Message was null", msg);
1:fe31092:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:fe31092:         }
1:fe31092: 
1:fe31092:         producerThread.setMessagePriority(HIGH_PRI);
1:fe31092:         producerThread.setMessageCount(1);
1:fe31092:         producerThread.run();
1:fe31092: 
1:fe31092:         for (;count < 400; count++) {
1:fe31092:             Message msg = sub.receive(15000);
1:fe31092:             assertNotNull("Message was null", msg);
1:fe31092:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:fe31092:         }
1:fe31092: 
1:fe31092:         Message msg = sub.receive(15000);
1:fe31092:         assertNotNull("Message was null", msg);
1:fe31092:         assertEquals("high priority", HIGH_PRI, msg.getJMSPriority());
1:fe31092: 
1:fe31092:         for (;count < 600; count++) {
1:fe31092:             msg = sub.receive(15000);
1:fe31092:             assertNotNull("Message was null", msg);
1:fe31092:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:fe31092:         }
1:7d54942:     }
1:6519c3e: 
1:f79f7ad:     public void initCombosForTestQueueBacklog() {
1:a2697b8:         // the cache limits the priority ordering to available memory
1:a2697b8:         addCombinationValues("useCache", new Object[] {new Boolean(false)});
1:f79f7ad:         // expiry processing can fill the cursor with a snapshot of the producer
1:f79f7ad:         // priority, before producers are complete
1:f79f7ad:         addCombinationValues("expireMessagePeriod", new Object[] {new Integer(0)});
1:f79f7ad:     }
1:f79f7ad: 
1:f79f7ad:     public void testQueueBacklog() throws Exception {
1:eece28a:         final int backlog = 1800;
1:f79f7ad:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST");
1:f79f7ad: 
1:f79f7ad:         ProducerThread lowPri = new ProducerThread(queue, backlog, LOW_PRI);
1:f79f7ad:         ProducerThread highPri = new ProducerThread(queue, 10, HIGH_PRI);
1:f79f7ad: 
1:f79f7ad:         lowPri.start();
1:f79f7ad:         lowPri.join();
1:f79f7ad:         highPri.start();
1:f79f7ad:         highPri.join();
1:f79f7ad: 
1:f79f7ad:         LOG.info("Starting consumer...");
1:f79f7ad:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:f79f7ad:         for (int i = 0; i < 500; i++) {
1:7d2ac2d:             Message msg = queueConsumer.receive(20000);
1:f79f7ad:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
1:7d2ac2d:             if (msg == null) dumpAllThreads("backlog");
1:f79f7ad:             assertNotNull("Message " + i + " was null", msg);
1:f79f7ad:             assertEquals("Message " + i + " has wrong priority", i < 10 ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:f79f7ad:         }
1:eece28a: 
1:eece28a:         final DestinationStatistics destinationStatistics = ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics();
1:eece28a:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:eece28a:             @Override
1:eece28a:             public boolean isSatisified() throws Exception {
1:eece28a:                 LOG.info("Enqueues: " + destinationStatistics.getEnqueues().getCount() + ", Dequeues: " + destinationStatistics.getDequeues().getCount());
1:eece28a:                 return destinationStatistics.getEnqueues().getCount() == backlog + 10 && destinationStatistics.getDequeues().getCount() == 500;
1:eece28a:             }
1:eece28a:         }, 10000));
1:eece28a:     }
1:eece28a: 
1:b78ef95:     public void initCombosForTestLowThenHighBatch() {
1:eece28a:         // the cache limits the priority ordering to available memory
1:eece28a:         addCombinationValues("useCache", new Object[] {new Boolean(false)});
1:eece28a:         // expiry processing can fill the cursor with a snapshot of the producer
1:eece28a:         // priority, before producers are complete
1:eece28a:         addCombinationValues("expireMessagePeriod", new Object[] {new Integer(0)});
1:f79f7ad:     }
1:f2a335c: 
1:f2a335c:     public void testLowThenHighBatch() throws Exception {
1:a2697b8:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST_LOW_THEN_HIGH_10");
1:f2a335c: 
1:f2a335c:         ProducerThread producerThread = new ProducerThread(queue, 10, LOW_PRI);
1:f2a335c:         producerThread.run();
1:f2a335c: 
1:f2a335c:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:f2a335c:         for (int i = 0; i < 10; i++) {
1:f2a335c:             Message message = queueConsumer.receive(10000);
1:f2a335c:             assertNotNull("expect #" + i, message);
1:f2a335c:             assertEquals("correct priority", LOW_PRI, message.getJMSPriority());
1:f2a335c:         }
1:f2a335c:         queueConsumer.close();
1:f2a335c: 
1:f2a335c:         producerThread.priority = HIGH_PRI;
1:f2a335c:         producerThread.run();
1:f2a335c: 
1:f2a335c:         queueConsumer = sess.createConsumer(queue);
1:f2a335c:         for (int i = 0; i < 10; i++) {
1:f2a335c:             Message message = queueConsumer.receive(10000);
1:eece28a:             assertNotNull("expect #" + i, message);
1:f2a335c:             assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:eece28a:         }
1:f2a335c:         queueConsumer.close();
1:eece28a: 
1:eece28a:         producerThread.priority = LOW_PRI;
1:eece28a:         producerThread.run();
1:eece28a:         producerThread.priority = MED_PRI;
1:eece28a:         producerThread.run();
1:eece28a: 
1:eece28a:         queueConsumer = sess.createConsumer(queue);
1:eece28a:         for (int i = 0; i < 10; i++) {
1:eece28a:             Message message = queueConsumer.receive(10000);
1:eece28a:             assertNotNull("expect #" + i, message);
1:eece28a:             assertEquals("correct priority", MED_PRI, message.getJMSPriority());
1:eece28a:         }
1:eece28a:         for (int i = 0; i < 10; i++) {
1:eece28a:             Message message = queueConsumer.receive(10000);
1:eece28a:             assertNotNull("expect #" + i, message);
1:eece28a:             assertEquals("correct priority", LOW_PRI, message.getJMSPriority());
1:eece28a:         }
1:eece28a:         queueConsumer.close();
1:eece28a: 
1:eece28a:         producerThread.priority = HIGH_PRI;
1:eece28a:         producerThread.run();
1:eece28a: 
1:eece28a:         queueConsumer = sess.createConsumer(queue);
1:eece28a:         for (int i = 0; i < 10; i++) {
1:eece28a:             Message message = queueConsumer.receive(10000);
1:f2a335c:             assertNotNull("expect #" + i, message);
1:eece28a:             assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:f2a335c:         }
1:eece28a:         queueConsumer.close();
1:f2a335c:     }
1:7d54942: 
1:5af5b59:     public void testInterleaveHiNewConsumerGetsHi() throws Exception {
1:5af5b59:         ActiveMQQueue queue = (ActiveMQQueue) sess.createQueue("TEST");
1:5af5b59:         doTestInterleaveHiNewConsumerGetsHi(queue);
1:5af5b59:     }
1:5af5b59: 
1:5af5b59:     public void testInterleaveHiNewConsumerGetsHiPull() throws Exception {
1:5af5b59:         ActiveMQQueue queue = (ActiveMQQueue) sess.createQueue("TEST?consumer.prefetchSize=0");
1:5af5b59:         doTestInterleaveHiNewConsumerGetsHi(queue);
1:5af5b59:     }
1:5af5b59: 
1:5af5b59:     public void doTestInterleaveHiNewConsumerGetsHi(ActiveMQQueue queue) throws Exception {
1:5af5b59: 
1:5af5b59:         // one hi sandwich
1:5af5b59:         ProducerThread producerThread = new ProducerThread(queue, 3, LOW_PRI);
1:5af5b59:         producerThread.run();
1:5af5b59:         producerThread = new ProducerThread(queue, 1, HIGH_PRI);
1:5af5b59:         producerThread.run();
1:5af5b59:         producerThread = new ProducerThread(queue, 3, LOW_PRI);
1:5af5b59:         producerThread.run();
1:5af5b59: 
1:5af5b59:         // consume hi
1:5af5b59:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:5af5b59:         Message message = queueConsumer.receive(10000);
1:5af5b59:         assertNotNull("expect #", message);
1:5af5b59:         assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:5af5b59:         queueConsumer.close();
1:5af5b59: 
1:5af5b59:         // last hi
1:5af5b59:         producerThread = new ProducerThread(queue, 3, LOW_PRI);
1:5af5b59:         producerThread.run();
1:5af5b59:         producerThread = new ProducerThread(queue, 1, HIGH_PRI);
1:5af5b59:         producerThread.run();
1:5af5b59: 
1:5af5b59:         // consume hi
1:5af5b59:         queueConsumer = sess.createConsumer(queue);
1:5af5b59:         message = queueConsumer.receive(10000);
1:5af5b59:         assertNotNull("expect #", message);
1:5af5b59:         assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:5af5b59:         queueConsumer.close();
1:5af5b59: 
1:5af5b59:         // consume the rest
1:5af5b59:         queueConsumer = sess.createConsumer(queue);
1:5af5b59:         for (int i = 0; i < 9; i++) {
1:5af5b59:             message = queueConsumer.receive(10000);
1:5af5b59:             assertNotNull("expect #" + i, message);
1:5af5b59:             assertEquals("correct priority", LOW_PRI, message.getJMSPriority());
1:5af5b59:         }
1:5af5b59:         queueConsumer.close();
1:5af5b59:     }
1:5af5b59: 
1:a2697b8:     public void initCombosForTestEveryXHi() {
1:f79f7ad:         // the cache limits the priority ordering to available memory
1:3985e72:         addCombinationValues("useCache", new Object[] {Boolean.FALSE, Boolean.TRUE});
1:a2697b8:         // expiry processing can fill the cursor with a snapshot of the producer
1:a2697b8:         // priority, before producers are complete
1:a2697b8:         addCombinationValues("expireMessagePeriod", new Object[] {new Integer(0)});
1:a2697b8:     }
1:a2697b8: 
1:a2697b8:     public void testEveryXHi() throws Exception {
1:3985e72: 
1:3985e72:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST");
1:3985e72: 
1:3985e72:         // ensure we hit the limit to disable the cache
1:3985e72:         broker.getDestinationPolicy().getEntryFor(queue).setMemoryLimit(50*1024);
1:3985e72:         final String payload = new String(new byte[1024]);
1:3985e72:         final int numMessages = 500;
1:a2697b8: 
1:a2697b8:         final AtomicInteger received = new AtomicInteger(0);
1:a2697b8:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:a2697b8:         queueConsumer.setMessageListener(new MessageListener() {
1:a2697b8:             @Override
1:a2697b8:             public void onMessage(Message message) {
1:a2697b8:                 received.incrementAndGet();
1:3985e72: 
1:3985e72:                 if (received.get() < 20) {
1:3985e72:                     try {
1:3985e72:                         TimeUnit.MILLISECONDS.sleep(100);
1:3985e72:                     } catch (InterruptedException e) {
1:3985e72:                         e.printStackTrace();
1:3985e72:                     }
1:3985e72:                 }
1:a2697b8:             }
1:a2697b8:         });
1:a2697b8: 
1:a2697b8:         MessageProducer producer = sess.createProducer(queue);
1:a2697b8:         for (int i = 0; i < numMessages; i++) {
1:a2697b8:             Message message = sess.createMessage();
1:3985e72:             message.setStringProperty("payload", payload);
1:a2697b8:             if (i % 5 == 0) {
1:a2697b8:                 message.setJMSPriority(9);
1:a2697b8:             } else {
1:a2697b8:                 message.setJMSPriority(4);
1:a2697b8:             }
1:a2697b8:             producer.send(message, Message.DEFAULT_DELIVERY_MODE, message.getJMSPriority(), Message.DEFAULT_TIME_TO_LIVE);
1:3985e72:         }
1:a2697b8: 
1:a2697b8:         assertTrue("Got all", Wait.waitFor(new Wait.Condition() {
1:a2697b8:             @Override
1:a2697b8:             public boolean isSatisified() throws Exception {
1:a2697b8:                 return numMessages == received.get();
1:a2697b8:             }
1:a2697b8:         }));
1:3985e72: 
1:a2697b8: 
1:a2697b8:         final DestinationStatistics destinationStatistics = ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics();
1:a2697b8:         assertTrue("Nothing else Like dlq involved", Wait.waitFor(new Wait.Condition() {
1:a2697b8:             @Override
1:a2697b8:             public boolean isSatisified() throws Exception {
1:a2697b8:                 LOG.info("Enqueues: " + destinationStatistics.getEnqueues().getCount() + ", Dequeues: " + destinationStatistics.getDequeues().getCount());
1:a2697b8:                 return destinationStatistics.getEnqueues().getCount() == numMessages && destinationStatistics.getDequeues().getCount() == numMessages;
1:a2697b8:             }
1:a2697b8:         }, 10000));
1:a2697b8: 
1:3985e72:         // do it again!
1:3985e72:         received.set(0);
1:3985e72:         destinationStatistics.reset();
1:3985e72:         for (int i = 0; i < numMessages; i++) {
1:3985e72:             Message message = sess.createMessage();
1:3985e72:             message.setStringProperty("payload", payload);
1:3985e72:             if (i % 5 == 0) {
1:3985e72:                 message.setJMSPriority(9);
1:3985e72:             } else {
1:3985e72:                 message.setJMSPriority(4);
1:3985e72:             }
1:3985e72:             producer.send(message, Message.DEFAULT_DELIVERY_MODE, message.getJMSPriority(), Message.DEFAULT_TIME_TO_LIVE);
1:3985e72:         }
1:3985e72: 
1:3985e72:         assertTrue("Got all", Wait.waitFor(new Wait.Condition() {
1:3985e72:             @Override
1:3985e72:             public boolean isSatisified() throws Exception {
1:3985e72:                 return numMessages == received.get();
1:3985e72:             }
1:3985e72:         }));
1:3985e72: 
1:3985e72: 
1:3985e72:         assertTrue("Nothing else Like dlq involved", Wait.waitFor(new Wait.Condition() {
1:3985e72:             @Override
1:3985e72:             public boolean isSatisified() throws Exception {
1:3985e72:                 LOG.info("Enqueues: " + destinationStatistics.getEnqueues().getCount() + ", Dequeues: " + destinationStatistics.getDequeues().getCount());
1:3985e72:                 return destinationStatistics.getEnqueues().getCount() == numMessages && destinationStatistics.getDequeues().getCount() == numMessages;
1:a2697b8:             }
1:3985e72:         }, 10000));
1:a2697b8: 
1:a2697b8:         queueConsumer.close();
1:a2697b8:     }
1:03f38ae: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:5af5b59
/////////////////////////////////////////////////////////////////////////
1:         factory.setMessagePrioritySupported(true);
/////////////////////////////////////////////////////////////////////////
1:     public void testInterleaveHiNewConsumerGetsHi() throws Exception {
1:         ActiveMQQueue queue = (ActiveMQQueue) sess.createQueue("TEST");
1:         doTestInterleaveHiNewConsumerGetsHi(queue);
1:     }
1: 
1:     public void testInterleaveHiNewConsumerGetsHiPull() throws Exception {
1:         ActiveMQQueue queue = (ActiveMQQueue) sess.createQueue("TEST?consumer.prefetchSize=0");
1:         doTestInterleaveHiNewConsumerGetsHi(queue);
1:     }
1: 
1:     public void doTestInterleaveHiNewConsumerGetsHi(ActiveMQQueue queue) throws Exception {
1: 
1:         // one hi sandwich
1:         ProducerThread producerThread = new ProducerThread(queue, 3, LOW_PRI);
1:         producerThread.run();
1:         producerThread = new ProducerThread(queue, 1, HIGH_PRI);
1:         producerThread.run();
1:         producerThread = new ProducerThread(queue, 3, LOW_PRI);
1:         producerThread.run();
1: 
1:         // consume hi
1:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:         Message message = queueConsumer.receive(10000);
1:         assertNotNull("expect #", message);
1:         assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:         queueConsumer.close();
1: 
1:         // last hi
1:         producerThread = new ProducerThread(queue, 3, LOW_PRI);
1:         producerThread.run();
1:         producerThread = new ProducerThread(queue, 1, HIGH_PRI);
1:         producerThread.run();
1: 
1:         // consume hi
1:         queueConsumer = sess.createConsumer(queue);
1:         message = queueConsumer.receive(10000);
1:         assertNotNull("expect #", message);
1:         assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:         queueConsumer.close();
1: 
1:         // consume the rest
1:         queueConsumer = sess.createConsumer(queue);
1:         for (int i = 0; i < 9; i++) {
1:             message = queueConsumer.receive(10000);
1:             assertNotNull("expect #" + i, message);
1:             assertEquals("correct priority", LOW_PRI, message.getJMSPriority());
1:         }
1:         queueConsumer.close();
1:     }
1: 
commit:3985e72
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("useCache", new Object[] {Boolean.FALSE, Boolean.TRUE});
1: 
1:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST");
1: 
1:         // ensure we hit the limit to disable the cache
1:         broker.getDestinationPolicy().getEntryFor(queue).setMemoryLimit(50*1024);
1:         final String payload = new String(new byte[1024]);
1:         final int numMessages = 500;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if (received.get() < 20) {
1:                     try {
1:                         TimeUnit.MILLISECONDS.sleep(100);
1:                     } catch (InterruptedException e) {
1:                         e.printStackTrace();
1:                     }
1:                 }
1:             message.setStringProperty("payload", payload);
/////////////////////////////////////////////////////////////////////////
1:         // do it again!
1:         received.set(0);
1:         destinationStatistics.reset();
1:         for (int i = 0; i < numMessages; i++) {
1:             Message message = sess.createMessage();
1:             message.setStringProperty("payload", payload);
1:             if (i % 5 == 0) {
1:                 message.setJMSPriority(9);
1:             } else {
1:                 message.setJMSPriority(4);
1:             }
1:             producer.send(message, Message.DEFAULT_DELIVERY_MODE, message.getJMSPriority(), Message.DEFAULT_TIME_TO_LIVE);
1:         }
1: 
1:         assertTrue("Got all", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return numMessages == received.get();
1:             }
1:         }));
1: 
1: 
1:         assertTrue("Nothing else Like dlq involved", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("Enqueues: " + destinationStatistics.getEnqueues().getCount() + ", Dequeues: " + destinationStatistics.getDequeues().getCount());
1:                 return destinationStatistics.getEnqueues().getCount() == numMessages && destinationStatistics.getDequeues().getCount() == numMessages;
1:             }
1:         }, 10000));
1: 
commit:a2697b8
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
1: import javax.jms.MessageListener;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void initCombosForTestEveryXHi() {
1:         // the cache limits the priority ordering to available memory
1:         addCombinationValues("useCache", new Object[] {new Boolean(false)});
1:         // expiry processing can fill the cursor with a snapshot of the producer
1:         // priority, before producers are complete
1:         addCombinationValues("expireMessagePeriod", new Object[] {new Integer(0)});
1:     }
1: 
1:     public void testEveryXHi() throws Exception {
0:         final int numMessages = 50;
1:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST_LOW_THEN_HIGH_10");
1: 
1:         final AtomicInteger received = new AtomicInteger(0);
1:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:         queueConsumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 received.incrementAndGet();
1:             }
1:         });
1: 
1:         MessageProducer producer = sess.createProducer(queue);
1:         for (int i = 0; i < numMessages; i++) {
1:             Message message = sess.createMessage();
1:             if (i % 5 == 0) {
1:                 message.setJMSPriority(9);
1:             } else {
1:                 message.setJMSPriority(4);
1:             }
1:             producer.send(message, Message.DEFAULT_DELIVERY_MODE, message.getJMSPriority(), Message.DEFAULT_TIME_TO_LIVE);
1:         }
1: 
1:         assertTrue("Got all", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return numMessages == received.get();
1:             }
1:         }));
1: 
1: 
1:         final DestinationStatistics destinationStatistics = ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics();
1:         assertTrue("Nothing else Like dlq involved", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("Enqueues: " + destinationStatistics.getEnqueues().getCount() + ", Dequeues: " + destinationStatistics.getDequeues().getCount());
1:                 return destinationStatistics.getEnqueues().getCount() == numMessages && destinationStatistics.getDequeues().getCount() == numMessages;
1:             }
1:         }, 10000));
1: 
1:         queueConsumer.close();
1:     }
commit:b78ef95
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestLowThenHighBatch() {
commit:eece28a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.DestinationStatistics;
1: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
1:     public int MED_PRI = 4;
/////////////////////////////////////////////////////////////////////////
1:         final int backlog = 1800;
/////////////////////////////////////////////////////////////////////////
1: 
1:         final DestinationStatistics destinationStatistics = ((RegionBroker)broker.getRegionBroker()).getDestinationStatistics();
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("Enqueues: " + destinationStatistics.getEnqueues().getCount() + ", Dequeues: " + destinationStatistics.getDequeues().getCount());
1:                 return destinationStatistics.getEnqueues().getCount() == backlog + 10 && destinationStatistics.getDequeues().getCount() == 500;
1:             }
1:         }, 10000));
1:     }
1: 
0:     public void initCombosForTestLowThenHighBatc() {
1:         // the cache limits the priority ordering to available memory
1:         addCombinationValues("useCache", new Object[] {new Boolean(false)});
1:         // expiry processing can fill the cursor with a snapshot of the producer
1:         // priority, before producers are complete
1:         addCombinationValues("expireMessagePeriod", new Object[] {new Integer(0)});
/////////////////////////////////////////////////////////////////////////
1: 
1:         producerThread.priority = LOW_PRI;
1:         producerThread.run();
1:         producerThread.priority = MED_PRI;
1:         producerThread.run();
1: 
1:         queueConsumer = sess.createConsumer(queue);
1:         for (int i = 0; i < 10; i++) {
1:             Message message = queueConsumer.receive(10000);
1:             assertNotNull("expect #" + i, message);
1:             assertEquals("correct priority", MED_PRI, message.getJMSPriority());
1:         }
1:         for (int i = 0; i < 10; i++) {
1:             Message message = queueConsumer.receive(10000);
1:             assertNotNull("expect #" + i, message);
1:             assertEquals("correct priority", LOW_PRI, message.getJMSPriority());
1:         }
1:         queueConsumer.close();
1: 
1:         producerThread.priority = HIGH_PRI;
1:         producerThread.run();
1: 
1:         queueConsumer = sess.createConsumer(queue);
1:         for (int i = 0; i < 10; i++) {
1:             Message message = queueConsumer.receive(10000);
1:             assertNotNull("expect #" + i, message);
1:             assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:         }
1:         queueConsumer.close();
commit:f2a335c
/////////////////////////////////////////////////////////////////////////
1:         PolicyEntry noCachePolicy = new PolicyEntry();
1:         noCachePolicy.setUseCache(false);
1:         noCachePolicy.setPrioritizedMessages(true);
1:         policyMap.put(new ActiveMQQueue("TEST_LOW_THEN_HIGH_10"), noCachePolicy);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testLowThenHighBatch() throws Exception {
0:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST_LOW_THEN_HIGH_10");
1: 
1:         ProducerThread producerThread = new ProducerThread(queue, 10, LOW_PRI);
1:         producerThread.run();
1: 
1:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:         for (int i = 0; i < 10; i++) {
1:             Message message = queueConsumer.receive(10000);
1:             assertNotNull("expect #" + i, message);
1:             assertEquals("correct priority", LOW_PRI, message.getJMSPriority());
1:         }
1:         queueConsumer.close();
1: 
1:         producerThread.priority = HIGH_PRI;
1:         producerThread.run();
1: 
1:         queueConsumer = sess.createConsumer(queue);
1:         for (int i = 0; i < 10; i++) {
1:             Message message = queueConsumer.receive(10000);
1:             assertNotNull("expect #" + i, message);
1:             assertEquals("correct priority", HIGH_PRI, message.getJMSPriority());
1:         }
1:         queueConsumer.close();
1:     }
commit:165959e
/////////////////////////////////////////////////////////////////////////
0:         final int backlog = 18000;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:             this.messageCount = messageCount;
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:7d2ac2d
/////////////////////////////////////////////////////////////////////////
1:             Message msg = queueConsumer.receive(20000);
1:             if (msg == null) dumpAllThreads("backlog");
commit:f79f7ad
/////////////////////////////////////////////////////////////////////////
1:     public int expireMessagePeriod = 30000;
/////////////////////////////////////////////////////////////////////////
1:         policy.setExpireMessagesPeriod(expireMessagePeriod);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestQueueBacklog() {
1:         // the cache limits the priority ordering to available memory
0:         addCombinationValues("useCache", new Object[] {new Boolean(false)});
1:         // expiry processing can fill the cursor with a snapshot of the producer
1:         // priority, before producers are complete
1:         addCombinationValues("expireMessagePeriod", new Object[] {new Integer(0)});
1:     }
1: 
1:     public void testQueueBacklog() throws Exception {
0:         final int backlog = 180000;
1:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST");
1: 
1:         ProducerThread lowPri = new ProducerThread(queue, backlog, LOW_PRI);
1:         ProducerThread highPri = new ProducerThread(queue, 10, HIGH_PRI);
1: 
1:         lowPri.start();
1:         lowPri.join();
1:         highPri.start();
1:         highPri.join();
1: 
1:         LOG.info("Starting consumer...");
1:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:         for (int i = 0; i < 500; i++) {
1:             Message msg = queueConsumer.receive(5000);
1:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
1:             assertNotNull("Message " + i + " was null", msg);
1:             assertEquals("Message " + i + " has wrong priority", i < 10 ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:         }
1:     }
commit:d2f8ede
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:         final Queue queue = sess.createQueue("TEST");
1:         final Topic topic = sess.createTopic("TEST");
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return broker.getRegionBroker().getDestinationMap().get(queue) != null;
1:             }
1:         });
1: 
1:         Wait.waitFor(new Wait.Condition(){
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return broker.getRegionBroker().getDestinationMap().get(topic) != null;
1:             }
1:         });
commit:3557361
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.DeliveryMode;
/////////////////////////////////////////////////////////////////////////
1:     public int deliveryMode = Message.DEFAULT_DELIVERY_MODE;
/////////////////////////////////////////////////////////////////////////
1:                 producer.setDeliveryMode(deliveryMode);
/////////////////////////////////////////////////////////////////////////
1:         addCombinationValues("deliveryMode", new Object[] {new Integer(DeliveryMode.NON_PERSISTENT), new Integer(DeliveryMode.PERSISTENT)});
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
1:         durableSubPending.setUseCache(useCache);
1: 
1:         // do not process expired for one test
1:         PolicyEntry ignoreExpired = new PolicyEntry();
1:         SharedDeadLetterStrategy ignoreExpiredStrategy = new SharedDeadLetterStrategy();
1:         ignoreExpiredStrategy.setProcessExpired(false);
1:         ignoreExpired.setDeadLetterStrategy(ignoreExpiredStrategy);
1:         policyMap.put(new ActiveMQTopic("TEST_CLEANUP_NO_PRIORITY"), ignoreExpired);
1: 
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() + ", priority:" + msg.getJMSPriority() : null));
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public void initCombosForTestHighPriorityDeliveryInterleaved() {
1:         addCombinationValues("useCache", new Object[] {Boolean.TRUE, Boolean.FALSE});
1:     }
1: 
1:     public void testHighPriorityDeliveryInterleaved() throws Exception {
1: 
1:         // get zero prefetch
1:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:         prefetch.setAll(0);
1:         factory.setPrefetchPolicy(prefetch);
1:         conn.close();
1:         conn = factory.createConnection();
1:         conn.setClientID("priority");
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:         final String subName = "priorityDisconnect";
1:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         ProducerThread producerThread = new ProducerThread(topic, 1, HIGH_PRI);
1:         producerThread.run();
1: 
1:         producerThread.setMessagePriority(HIGH_PRI -1);
1:         producerThread.setMessageCount(1);
1:         producerThread.run();
1: 
1:         producerThread.setMessagePriority(LOW_PRI);
1:         producerThread.setMessageCount(1);
1:         producerThread.run();
1:         LOG.info("Ordered priority messages sent");
1: 
1:         sub = sess.createDurableSubscriber(topic, subName);
1:         int count = 0;
1: 
1:         Message msg = sub.receive(15000);
1:         assertNotNull("Message was null", msg);
1:         LOG.info("received " + msg.getJMSMessageID() + ", priority:" + msg.getJMSPriority());
1:         assertEquals("Message has wrong priority", HIGH_PRI, msg.getJMSPriority());
1: 
1:         producerThread.setMessagePriority(LOW_PRI+1);
1:         producerThread.setMessageCount(1);
1:         producerThread.run();
1: 
1:         msg = sub.receive(15000);
1:         assertNotNull("Message was null", msg);
1:         LOG.info("received " + msg.getJMSMessageID() + ", priority:" + msg.getJMSPriority());
1:         assertEquals("high priority", HIGH_PRI -1, msg.getJMSPriority());
1: 
1:         msg = sub.receive(15000);
1:         assertNotNull("Message was null", msg);
1:         LOG.info("received hi? : " + msg);
1:         assertEquals("high priority", LOW_PRI +1, msg.getJMSPriority());
1: 
1:         msg = sub.receive(15000);
1:         assertNotNull("Message was null", msg);
1:         LOG.info("received hi? : " + msg);
1:         assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1: 
1:         msg = sub.receive(4000);
1:         assertNull("Message was null", msg);
1:     }
1: 
1:     // immediatePriorityDispatch is only relevant when cache is exhausted
1:     public void initCombosForTestHighPriorityDeliveryThroughBackLog() {
1:         addCombinationValues("useCache", new Object[] {Boolean.FALSE});
1:         addCombinationValues("immediatePriorityDispatch", new Object[] {Boolean.TRUE});
1:     }
1: 
1:     public void testHighPriorityDeliveryThroughBackLog() throws Exception {
1: 
1:         // get zero prefetch
1:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:         prefetch.setAll(0);
1:         factory.setPrefetchPolicy(prefetch);
1:         conn.close();
1:         conn = factory.createConnection();
1:         conn.setClientID("priority");
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:         final String subName = "priorityDisconnect";
1:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         ProducerThread producerThread = new ProducerThread(topic, 600, LOW_PRI);
1:         producerThread.run();
1: 
1: 
1:         sub = sess.createDurableSubscriber(topic, subName);
1:         int count = 0;
1: 
1:         for (;count < 300; count++) {
1:             Message msg = sub.receive(15000);
1:             assertNotNull("Message was null", msg);
1:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:         }
1: 
1:         producerThread.setMessagePriority(HIGH_PRI);
1:         producerThread.setMessageCount(1);
1:         producerThread.run();
1: 
1:         Message msg = sub.receive(15000);
1:         assertNotNull("Message was null", msg);
1:         assertEquals("high priority", HIGH_PRI, msg.getJMSPriority());
1: 
1:         for (;count < 600; count++) {
1:             msg = sub.receive(15000);
1:             assertNotNull("Message was null", msg);
1:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:         }
1:     }
1: 
1: 
1:     public void initCombosForTestHighPriorityNonDeliveryThroughBackLog() {
1:         addCombinationValues("useCache", new Object[] {Boolean.FALSE});
1:         addCombinationValues("immediatePriorityDispatch", new Object[] {Boolean.FALSE});
1:     }
1: 
1:     public void testHighPriorityNonDeliveryThroughBackLog() throws Exception {
1: 
1:         // get zero prefetch
1:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:         prefetch.setAll(0);
1:         factory.setPrefetchPolicy(prefetch);
1:         conn.close();
1:         conn = factory.createConnection();
1:         conn.setClientID("priority");
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:         final String subName = "priorityDisconnect";
1:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         ProducerThread producerThread = new ProducerThread(topic, 600, LOW_PRI);
1:         producerThread.run();
1: 
1: 
1:         sub = sess.createDurableSubscriber(topic, subName);
1:         int count = 0;
1: 
1:         for (;count < 300; count++) {
1:             Message msg = sub.receive(15000);
1:             assertNotNull("Message was null", msg);
1:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:         }
1: 
1:         producerThread.setMessagePriority(HIGH_PRI);
1:         producerThread.setMessageCount(1);
1:         producerThread.run();
1: 
1:         for (;count < 400; count++) {
1:             Message msg = sub.receive(15000);
1:             assertNotNull("Message was null", msg);
1:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:         }
1: 
1:         Message msg = sub.receive(15000);
1:         assertNotNull("Message was null", msg);
1:         assertEquals("high priority", HIGH_PRI, msg.getJMSPriority());
1: 
1:         for (;count < 600; count++) {
1:             msg = sub.receive(15000);
1:             assertNotNull("Message was null", msg);
1:             assertEquals("high priority", LOW_PRI, msg.getJMSPriority());
1:         }
1:     }
1: 
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1:     public boolean immediatePriorityDispatch = true;
/////////////////////////////////////////////////////////////////////////
1:         durableSubPending.setImmediatePriorityDispatch(immediatePriorityDispatch);
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
1:         final int numToProduce = 2000;
1:         final int[] dups = new int[numToProduce*2];
1:         ProducerThread producerThread = new ProducerThread(topic, numToProduce, LOW_PRI+1);
1:         final int batchSize = 250;
1:         int lowLowCount = 0;
1:         for (int i=0; i<numToProduce; i++) {
1:             Message msg = sub.receive(15000);
0:             LOG.info("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() + "-" + msg.getJMSPriority() : null));
1:             assertNotNull("Message " + i + " was null", msg);
1:             assertEquals("Message " + i + " has wrong priority", LOW_PRI+1, msg.getJMSPriority());
1:             assertTrue("not duplicate ", dups[i] == 0);
1:             dups[i] = 1;
1: 
1:             if (i % batchSize == 0) {
1:                 producerThread.setMessagePriority(HIGH_PRI);
1:                 producerThread.setMessageCount(1);
1:                 producerThread.run();
1:                 LOG.info("High priority message sent, should be able to receive immediately");
1: 
1:                 if (i % batchSize*2 == 0) {
1:                     producerThread.setMessagePriority(HIGH_PRI -1);
1:                     producerThread.setMessageCount(1);
1:                     producerThread.run();
1:                     LOG.info("High -1 priority message sent, should be able to receive immediately");
1:                 }
1: 
1:                 if (i % batchSize*4 == 0) {
1:                     producerThread.setMessagePriority(LOW_PRI);
1:                     producerThread.setMessageCount(1);
1:                     producerThread.run();
1:                     lowLowCount++;
1:                     LOG.info("Low low priority message sent, should not be able to receive immediately");
1:                 }
1: 
1:                 msg = sub.receive(15000);
1:                 assertNotNull("Message was null", msg);
1:                 LOG.info("received hi? : " + msg);
1:                 assertEquals("high priority", HIGH_PRI, msg.getJMSPriority());
1:                             
1:                 if (i % batchSize*2 == 0) {
1:                     msg = sub.receive(15000);
1:                     assertNotNull("Message was null", msg);
1:                     LOG.info("received hi -1 ? i=" + i + ", " + msg);
1:                     assertEquals("high priority", HIGH_PRI -1, msg.getJMSPriority());
1:                 }
1:             }
1:         }
1:         for (int i=0; i<lowLowCount; i++) {
commit:7d54942
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy;
1: import org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
1:         StorePendingDurableSubscriberMessageStoragePolicy durableSubPending =
1:                 new StorePendingDurableSubscriberMessageStoragePolicy();
0:         durableSubPending.setImmediatePriorityDispatch(true);
1:         policy.setPendingDurableSubscriberPolicy(durableSubPending);
/////////////////////////////////////////////////////////////////////////
1: 
1:         public void setMessagePriority(int priority) {
1:             this.priority = priority;
1:         }
1: 
1:         public void setMessageCount(int messageCount) {
1:             this.messageCount = messageCount;    
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testHighPriorityDelivery() throws Exception {
1: 
1:         // get zero prefetch
1:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:         prefetch.setAll(0);
1:         factory.setPrefetchPolicy(prefetch);
1:         conn.close();
1:         conn = factory.createConnection();
1:         conn.setClientID("priority");
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:         final String subName = "priorityDisconnect";
1:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
0:         ProducerThread producerThread = new ProducerThread(topic, 5000, LOW_PRI);
1:         producerThread.run();
1:         LOG.info("Low priority messages sent");
1: 
1:         sub = sess.createDurableSubscriber(topic, subName);
0:         for (int i=0; i<200;i++) {
1:             Message msg = sub.receive(15000);
1:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
1:             assertNotNull("Message " + i + " was null", msg);
1:             assertEquals("Message " + i + " has wrong priority", LOW_PRI, msg.getJMSPriority());
1:         }
1: 
0:         producerThread.setMessagePriority(HIGH_PRI);
0:         producerThread.setMessageCount(1);
1:         producerThread.run();
0:         LOG.info("High priority message sent");
1: 
0:         // try and get the high priority message
1:         Message msg = sub.receive(15000);
0:         assertNotNull("Message was null", msg);
0:         LOG.info("received: " + msg);
0:         assertEquals("high priority", HIGH_PRI, msg.getJMSPriority());
1:     }
commit:4679c8a
/////////////////////////////////////////////////////////////////////////
1:         policyMap.put(new ActiveMQQueue("TEST"), policy);
1:         policyMap.put(new ActiveMQTopic("TEST"), policy);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         // verify that same broker/store can deal with non priority dest also
1:         topic = (ActiveMQTopic)sess.createTopic("HAS_NO_PRIORITY");
1:         sub = sess.createDurableSubscriber(topic, "no_priority");
1:         sub.close();
1: 
1:         lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:         highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
1: 
1:         lowPri.start();
1:         highPri.start();
1: 
1:         lowPri.join();
1:         highPri.join();
1: 
1:         sub = sess.createDurableSubscriber(topic, "no_priority");
1:         // verify we got them all
1:         for (int i = 0; i < MSG_NUM * 2; i++) {
1:             Message msg = sub.receive(5000);
1:             assertNotNull("Message " + i + " was null", msg);
1:         }
1: 
commit:06cbebc
/////////////////////////////////////////////////////////////////////////
1:     public boolean useCache = true;
1:     public boolean dispatchAsync = true;
1:     public boolean prioritizeMessages = true;
/////////////////////////////////////////////////////////////////////////
1:         policy.setPrioritizedMessages(prioritizeMessages);
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             sess.close();
1:             conn.close();
1:         } catch (Exception ignored) {
1:         } finally {
1:             broker.stop();
1:             broker.waitUntilStopped();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         final String text = "priority " + priority;
/////////////////////////////////////////////////////////////////////////
1:         // REVISIT = is dispatchAsync = true a problem or is it just the test?
1:         addCombinationValues("dispatchAsync", new Object[] {Boolean.FALSE});
1:         addCombinationValues("useCache", new Object[] {Boolean.TRUE, Boolean.FALSE});
/////////////////////////////////////////////////////////////////////////
0:             Message msg = sub.receive(15000);
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1:     protected Session sess;
0:     public boolean dispatchAsync = false;
1:     public int MSG_NUM = 600;
1:     public int HIGH_PRI = 7;
1:     public int LOW_PRI = 3;
/////////////////////////////////////////////////////////////////////////
1:         factory.setDispatchAsync(dispatchAsync);
/////////////////////////////////////////////////////////////////////////
1:     protected class ProducerThread extends Thread {
/////////////////////////////////////////////////////////////////////////
0:             Message msg = queueConsumer.receive(5000);
1:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
/////////////////////////////////////////////////////////////////////////
0:         addCombinationValues("dispatchAsync", new Object[] {Boolean.TRUE, Boolean.FALSE});
/////////////////////////////////////////////////////////////////////////
0:             Message msg = sub.receive(30000);
1:             LOG.debug("received i=" + i + ", " + (msg!=null? msg.getJMSMessageID() : null));
commit:9705671
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQPrefetchPolicy;
/////////////////////////////////////////////////////////////////////////
1:     public int prefetchVal = 500;
1: 
/////////////////////////////////////////////////////////////////////////
1:         broker.setAdvisorySupport(false);
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQPrefetchPolicy prefetch = new ActiveMQPrefetchPolicy();
1:         prefetch.setAll(prefetchVal);
1:         factory.setPrefetchPolicy(prefetch);
1:         factory.setWatchTopicAdvisories(false);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void initCombosForTestDurableSubs() {
1:         addCombinationValues("prefetchVal", new Object[] {new Integer(1000), new Integer(MSG_NUM/4)});
1:     }
/////////////////////////////////////////////////////////////////////////
1:             Message msg = sub.receive(5000);
1: 
1:     public void initCombosForTestDurableSubsReconnect() {
1:         addCombinationValues("prefetchVal", new Object[] {new Integer(1000), new Integer(MSG_NUM/2)});
1:     }
1:     
1:     public void testDurableSubsReconnect() throws Exception {
1:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:         final String subName = "priorityDisconnect";
1:         TopicSubscriber sub = sess.createDurableSubscriber(topic, subName);
1:         sub.close();
1: 
1:         ProducerThread lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:         ProducerThread highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
1: 
1:         lowPri.start();
1:         highPri.start();
1: 
1:         lowPri.join();
1:         highPri.join();
1: 
1: 
1:         final int closeFrequency = MSG_NUM/4;
1:         sub = sess.createDurableSubscriber(topic, subName);
1:         for (int i = 0; i < MSG_NUM * 2; i++) {
1:             Message msg = sub.receive(5000);
1:             assertNotNull("Message " + i + " was null", msg);
1:             assertEquals("Message " + i + " has wrong priority", i < MSG_NUM ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:             if (i>0 && i%closeFrequency==0) {
1:                 LOG.info("Closing durable sub.. on: " + i);
1:                 sub.close();
1:                 sub = sess.createDurableSubscriber(topic, subName);
1:             }
1:         }
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:bfbe90b
/////////////////////////////////////////////////////////////////////////
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(MessagePriorityTest.class);
commit:69dc0d4
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQConnectionFactory factory;
1:     protected Connection conn;
commit:4f5e620
/////////////////////////////////////////////////////////////////////////
1:             assertNotNull("Message " + i + " was null", msg);
commit:12f0195
/////////////////////////////////////////////////////////////////////////
1:             assertNotNull("Message " + i + " was null", msg);
commit:c4425ca
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.TopicSubscriber;
1: import org.apache.activemq.CombinationTestSupport;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: abstract public class MessagePriorityTest extends CombinationTestSupport {
1:     
0:     private static final Log LOG = LogFactory.getLog(MessagePriorityTest.class);
/////////////////////////////////////////////////////////////////////////
0:     public boolean useCache;
1:     
0:     int MSG_NUM = 1000;
0:     int HIGH_PRI = 7;
0:     int LOW_PRI = 3;
1:     
/////////////////////////////////////////////////////////////////////////
1:         policy.setUseCache(useCache);
/////////////////////////////////////////////////////////////////////////
1:         conn.setClientID("priority");
1:         conn.start();
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(500); // get it all propagated
/////////////////////////////////////////////////////////////////////////
0:     class ProducerThread extends Thread {
0: 
1:         int priority;
1:         int messageCount;
1:         ActiveMQDestination dest;
0:         
1:         public ProducerThread(ActiveMQDestination dest, int messageCount, int priority) {
0:             this.messageCount = messageCount;
1:             this.priority = priority;
1:             this.dest = dest;
1:         }
0:         
1:         public void run() {
1:             try {
1:                 MessageProducer producer = sess.createProducer(dest);
1:                 producer.setPriority(priority);
1:                 for (int i = 0; i < messageCount; i++) {
1:                     producer.send(sess.createTextMessage("message priority: " + priority));
1:                 }
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:             }
1:         }
0:         
1:     }
0:     
1:     public void initCombosForTestQueues() {
1:         addCombinationValues("useCache", new Object[] {new Boolean(true), new Boolean(false)});
1:     }
0:     
1:     public void testQueues() throws Exception {
1:         ActiveMQQueue queue = (ActiveMQQueue)sess.createQueue("TEST");
0: 
1:         ProducerThread lowPri = new ProducerThread(queue, MSG_NUM, LOW_PRI);
1:         ProducerThread highPri = new ProducerThread(queue, MSG_NUM, HIGH_PRI);
0:         
1:         lowPri.start();
1:         highPri.start();
0:         
1:         lowPri.join();
1:         highPri.join();
0:         
1:         MessageConsumer queueConsumer = sess.createConsumer(queue);
1:         for (int i = 0; i < MSG_NUM * 2; i++) {
0:             Message msg = queueConsumer.receive(1000);
0:             assertNotNull(msg);
1:             assertEquals("Message " + i + " has wrong priority", i < MSG_NUM ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:         }
1:     }
0:     
1:     protected Message createMessage(int priority) throws Exception {
0:         final String text = "Message with priority " + priority;
1:         Message msg = sess.createTextMessage(text);
1:         LOG.info("Sending  " + text);
1:         return msg;
1:     }
0:     
1:     public void testDurableSubs() throws Exception {
1:         ActiveMQTopic topic = (ActiveMQTopic)sess.createTopic("TEST");
1:         TopicSubscriber sub = sess.createDurableSubscriber(topic, "priority");
1:         sub.close();
0:         
1:         ProducerThread lowPri = new ProducerThread(topic, MSG_NUM, LOW_PRI);
1:         ProducerThread highPri = new ProducerThread(topic, MSG_NUM, HIGH_PRI);
0:         
1:         lowPri.start();
1:         highPri.start();
0:         
1:         lowPri.join();
1:         highPri.join();
0:         
1:         sub = sess.createDurableSubscriber(topic, "priority");
1:         for (int i = 0; i < MSG_NUM * 2; i++) {
0:             Message msg = sub.receive(1000);
0:             assertNotNull(msg);
1:             assertEquals("Message " + i + " has wrong priority", i < MSG_NUM ? HIGH_PRI : LOW_PRI, msg.getJMSPriority());
1:         }
0:         
1:     }
0:     
commit:03f38ae
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: 
1: package org.apache.activemq.store;
0: 
1: import javax.jms.Connection;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.Topic;
0: 
0: import junit.framework.TestCase;
0: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: 
0: abstract public class MessagePriorityTest extends TestCase {
0: 
1:     BrokerService broker;
1:     PersistenceAdapter adapter;
0:     
0:     ActiveMQConnectionFactory factory;
0:     Connection conn;
0:     Session sess;
0:     
1:     abstract protected PersistenceAdapter createPersistenceAdapter(boolean delete) throws Exception;
0:     
1:     protected void setUp() throws Exception {
1:         broker = new BrokerService();
1:         broker.setBrokerName("priorityTest");
1:         adapter = createPersistenceAdapter(true);
1:         broker.setPersistenceAdapter(adapter);
1:         PolicyEntry policy = new PolicyEntry();
0:         policy.setPrioritizedMessages(true);
1:         PolicyMap policyMap = new PolicyMap();
0:         policyMap.setDefaultEntry(policy);
1:         broker.setDestinationPolicy(policyMap);
1:         broker.start();
1:         broker.waitUntilStarted();
0:         
1:         factory = new ActiveMQConnectionFactory("vm://priorityTest");
1:         conn = factory.createConnection();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:     }
0:     
1:     protected void tearDown() throws Exception {
0:         sess.close();
0:         conn.close();
0:         
0:         broker.stop();
0:         broker.waitUntilStopped();
1:     }
0:     
1:     public void testStoreConfigured() throws Exception {
0:         Queue queue = sess.createQueue("TEST");
0:         Topic topic = sess.createTopic("TEST");
0:         
1:         MessageProducer queueProducer = sess.createProducer(queue);
1:         MessageProducer topicProducer = sess.createProducer(topic);
0:         
0:         
0:         Thread.sleep(100); // get it all propagated
0:         
1:         assertTrue(broker.getRegionBroker().getDestinationMap().get(queue).getMessageStore().isPrioritizedMessages());
1:         assertTrue(broker.getRegionBroker().getDestinationMap().get(topic).getMessageStore().isPrioritizedMessages());
0:         
1:         queueProducer.close();
1:         topicProducer.close();
0:         
1:     }
0:     
1: }
============================================================================