1:dc98d96: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
4:dc98d96:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:dc98d96:  *
1:dc98d96:  * Unless required by applicable law or agreed to in writing, software
1:dc98d96:  * distributed under the License is distributed on an "AS IS" BASIS,
1:dc98d96:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:dc98d96:  * See the License for the specific language governing permissions and
1:dc98d96:  * limitations under the License.
1:dc98d96:  */
1:98b61e4: package org.apache.activemq.transport.stomp;
13:dc98d96: 
1:dc98d96: import java.io.IOException;
1:9abbe82: import java.util.ArrayList;
1:dc98d96: import java.util.Iterator;
1:dc98d96: import java.util.LinkedHashMap;
1:f6ebeec: import java.util.LinkedList;
1:76efc33: import java.util.Map;
1:76efc33: import java.util.Map.Entry;
1:76efc33: 
1:dc98d96: import javax.jms.JMSException;
1:dc98d96: 
1:6d08aca: import org.apache.activemq.command.ActiveMQBytesMessage;
1:dc98d96: import org.apache.activemq.command.ActiveMQDestination;
1:dc98d96: import org.apache.activemq.command.ActiveMQMessage;
1:dc98d96: import org.apache.activemq.command.ConsumerInfo;
1:dc98d96: import org.apache.activemq.command.MessageAck;
1:dc98d96: import org.apache.activemq.command.MessageDispatch;
1:dc98d96: import org.apache.activemq.command.MessageId;
1:6d08aca: import org.apache.activemq.command.TransactionId;
1:dc98d96: 
1:dc98d96: /**
1:f6ebeec:  * Keeps track of the STOMP subscription so that acking is correctly done.
1:f812e34:  *
1:f812e34:  * @author <a href="http://hiramchirino.com">chirino</a>
1:dc98d96:  */
1:dc98d96: public class StompSubscription {
1:f812e34: 
1:dc98d96:     public static final String AUTO_ACK = Stomp.Headers.Subscribe.AckModeValues.AUTO;
1:dc98d96:     public static final String CLIENT_ACK = Stomp.Headers.Subscribe.AckModeValues.CLIENT;
1:b1288f2:     public static final String INDIVIDUAL_ACK = Stomp.Headers.Subscribe.AckModeValues.INDIVIDUAL;
1:f812e34: 
1:0885c60:     protected final ProtocolConverter protocolConverter;
1:0885c60:     protected final String subscriptionId;
1:0885c60:     protected final ConsumerInfo consumerInfo;
1:f812e34: 
1:e83bb6d:     protected final LinkedHashMap<MessageId, MessageDispatch> dispatchedMessage = new LinkedHashMap<>();
1:e83bb6d:     protected final LinkedList<MessageDispatch> unconsumedMessage = new LinkedList<>();
1:dc98d96: 
1:0885c60:     protected String ackMode = AUTO_ACK;
1:0885c60:     protected ActiveMQDestination destination;
1:0885c60:     protected String transformation;
1:dc98d96: 
1:2b5608f:     public StompSubscription(ProtocolConverter stompTransport, String subscriptionId, ConsumerInfo consumerInfo, String transformation) {
1:dc98d96:         this.protocolConverter = stompTransport;
1:f812e34:         this.subscriptionId = subscriptionId;
1:dc98d96:         this.consumerInfo = consumerInfo;
1:2b5608f:         this.transformation = transformation;
1:fc00993:     }
1:f812e34: 
1:6d08aca:     void onMessageDispatch(MessageDispatch md, String ackId) throws IOException, JMSException {
1:f812e34:         ActiveMQMessage message = (ActiveMQMessage)md.getMessage();
1:e83bb6d:         if (ackMode.equals(CLIENT_ACK) || ackMode.equals(INDIVIDUAL_ACK)) {
1:dc98d96:             synchronized (this) {
2:f6ebeec:                 dispatchedMessage.put(message.getMessageId(), md);
1:dc98d96:             }
1:e83bb6d:         } else if (ackMode.equals(AUTO_ACK)) {
1:dc98d96:             MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1);
1:f33f32e:             protocolConverter.getStompTransport().sendToActiveMQ(ack);
1:dc98d96:         }
1:3910056: 
1:3910056:         boolean ignoreTransformation = false;
1:3910056: 
1:9807ee3:         if (transformation != null && !( message instanceof ActiveMQBytesMessage ) ) {
1:2b5608f:             message.setReadOnlyProperties(false);
1:2b5608f:             message.setStringProperty(Stomp.Headers.TRANSFORMATION, transformation);
1:3910056:         } else {
1:3910056:             if (message.getStringProperty(Stomp.Headers.TRANSFORMATION) != null) {
1:3910056:                 ignoreTransformation = true;
1:3910056:             }
1:2b5608f:         }
1:f812e34: 
1:3910056:         StompFrame command = protocolConverter.convertMessage(message, ignoreTransformation);
1:f812e34: 
1:f812e34:         command.setAction(Stomp.Responses.MESSAGE);
1:f812e34:         if (subscriptionId != null) {
1:dc98d96:             command.getHeaders().put(Stomp.Headers.Message.SUBSCRIPTION, subscriptionId);
1:dc98d96:         }
1:f812e34: 
1:6d08aca:         if (ackId != null) {
1:6d08aca:             command.getHeaders().put(Stomp.Headers.Message.ACK_ID, ackId);
1:dc98d96:         }
1:f812e34: 
1:ceed011:         protocolConverter.getStompTransport().sendToStomp(command);
1:dc98d96:     }
1:f812e34: 
1:b0f24f3:     synchronized void onStompAbort(TransactionId transactionId) {
1:3060a64:         unconsumedMessage.clear();
1:6d08aca:     }
1:dc98d96: 
1:37ad85e:     void onStompCommit(TransactionId transactionId) {
1:37ad85e:         MessageAck ack = null;
1:37ad85e:         synchronized (this) {
1:37ad85e:             for (Iterator<?> iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
1:37ad85e:                 @SuppressWarnings("rawtypes")
1:37ad85e:                 Map.Entry entry = (Entry)iter.next();
1:37ad85e:                 MessageDispatch msg = (MessageDispatch)entry.getValue();
1:37ad85e:                 if (unconsumedMessage.contains(msg)) {
1:37ad85e:                     iter.remove();
1:37ad85e:                 }
1:37ad85e:             }
1:37ad85e: 
1:4c986d1:             // For individual Ack we already sent an Ack that will be applied on commit
1:4c986d1:             // we don't send a second standard Ack as that would produce an error.
1:4c986d1:             if (!unconsumedMessage.isEmpty() && ackMode == CLIENT_ACK) {
1:37ad85e:                 ack = new MessageAck(unconsumedMessage.getLast(), MessageAck.STANDARD_ACK_TYPE, unconsumedMessage.size());
1:4c986d1:                 ack.setTransactionId(transactionId);
1:37ad85e:                 unconsumedMessage.clear();
1:3060a64:             }
1:0885c60:         }
1:37ad85e:         // avoid contention with onMessageDispatch
1:37ad85e:         if (ack != null) {
1:f33f32e:             protocolConverter.getStompTransport().sendToActiveMQ(ack);
1:0885c60:         }
3:0885c60:     }
1:76efc33: 
1:f6ebeec:     synchronized MessageAck onStompMessageAck(String messageId, TransactionId transactionId) {
1:dc98d96: 
1:0885c60:         MessageId msgId = new MessageId(messageId);
1:dc98d96: 
1:f6ebeec:         if (!dispatchedMessage.containsKey(msgId)) {
1:f812e34:             return null;
1:f812e34:         }
1:f812e34: 
1:dc98d96:         MessageAck ack = new MessageAck();
1:dc98d96:         ack.setDestination(consumerInfo.getDestination());
1:dc98d96:         ack.setConsumerId(consumerInfo.getConsumerId());
1:f812e34: 
1:9abbe82:         final ArrayList<String> acknowledgedMessages = new ArrayList<>();
1:9abbe82: 
1:dc98d96:         if (ackMode == CLIENT_ACK) {
1:3060a64:             if (transactionId == null) {
1:dc98d96:                 ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
1:3060a64:             } else {
1:3060a64:                 ack.setAckType(MessageAck.DELIVERED_ACK_TYPE);
1:dc98d96:             }
1:f812e34:             int count = 0;
1:0885c60:             for (Iterator<?> iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
1:f812e34: 
1:0885c60:                 @SuppressWarnings("rawtypes")
1:f812e34:                 Map.Entry entry = (Entry)iter.next();
1:b0f24f3:                 MessageId id = (MessageId)entry.getKey();
1:b0f24f3:                 MessageDispatch msg = (MessageDispatch)entry.getValue();
1:f812e34: 
2:f6ebeec:                 if (transactionId != null) {
1:0885c60:                     if (!unconsumedMessage.contains(msg)) {
1:0885c60:                         unconsumedMessage.add(msg);
1:dc98d96:                         count++;
1:3060a64:                     }
1:b0f24f3:                 } else {
1:9abbe82:                     acknowledgedMessages.add(id.toString());
1:dc98d96:                     iter.remove();
2:3060a64:                     count++;
1:0885c60:                 }
1:f812e34: 
1:f6ebeec:                 if (id.equals(msgId)) {
1:f6ebeec:                     ack.setLastMessageId(id);
1:dc98d96:                     break;
1:dc98d96:                 }
1:dc98d96:             }
1:dc98d96:             ack.setMessageCount(count);
1:f6ebeec:             if (transactionId != null) {
1:0885c60:                 ack.setTransactionId(transactionId);
1:dc98d96:             }
1:f812e34: 
1:9abbe82:             this.protocolConverter.afterClientAck(this, acknowledgedMessages);
1:0885c60:         } else if (ackMode == INDIVIDUAL_ACK) {
1:b1288f2:             ack.setAckType(MessageAck.INDIVIDUAL_ACK_TYPE);
1:f6ebeec:             ack.setMessageID(msgId);
1:e83bb6d:             ack.setMessageCount(1);
1:f6ebeec:             if (transactionId != null) {
1:0885c60:                 unconsumedMessage.add(dispatchedMessage.get(msgId));
1:0885c60:                 ack.setTransactionId(transactionId);
1:e83bb6d:             } else {
1:e83bb6d:                 dispatchedMessage.remove(msgId);
1:dc98d96:             }
1:dc98d96:         }
1:9abbe82: 
1:dc98d96:         return ack;
1:dc98d96:     }
1:76efc33: 
1:0885c60:     public MessageAck onStompMessageNack(String messageId, TransactionId transactionId) throws ProtocolException {
1:dc98d96: 
1:0885c60:         MessageId msgId = new MessageId(messageId);
1:dc98d96: 
1:0885c60:         if (!dispatchedMessage.containsKey(msgId)) {
1:dc98d96:             return null;
1:dc98d96:         }
1:dc98d96: 
1:0885c60:         MessageAck ack = new MessageAck();
1:0885c60:         ack.setDestination(consumerInfo.getDestination());
1:0885c60:         ack.setConsumerId(consumerInfo.getConsumerId());
1:0885c60:         ack.setAckType(MessageAck.POSION_ACK_TYPE);
1:0885c60:         ack.setMessageID(msgId);
1:0885c60:         if (transactionId != null) {
1:0885c60:             unconsumedMessage.add(dispatchedMessage.get(msgId));
1:0885c60:             ack.setTransactionId(transactionId);
1:dc98d96:         }
1:0885c60:         dispatchedMessage.remove(msgId);
1:dc98d96: 
1:e3a1fc9:         return ack;
1:dc98d96:     }
1:dc98d96: 
1:f812e34:     public String getAckMode() {
1:f812e34:         return ackMode;
1:f812e34:     }
1:dc98d96: 
1:f812e34:     public void setAckMode(String ackMode) {
1:f812e34:         this.ackMode = ackMode;
1:f812e34:     }
1:dc98d96: 
1:f812e34:     public String getSubscriptionId() {
1:f812e34:         return subscriptionId;
1:f812e34:     }
1:dc98d96: 
1:f812e34:     public void setDestination(ActiveMQDestination destination) {
1:f812e34:         this.destination = destination;
1:f812e34:     }
1:dc98d96: 
1:f812e34:     public ActiveMQDestination getDestination() {
1:f812e34:         return destination;
1:f812e34:     }
1:dc98d96: 
1:f812e34:     public ConsumerInfo getConsumerInfo() {
1:f812e34:         return consumerInfo;
1:f812e34:     }
1:dc98d96: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9abbe82
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:         final ArrayList<String> acknowledgedMessages = new ArrayList<>();
1: 
/////////////////////////////////////////////////////////////////////////
1:                     acknowledgedMessages.add(id.toString());
/////////////////////////////////////////////////////////////////////////
1:             this.protocolConverter.afterClientAck(this, acknowledgedMessages);
/////////////////////////////////////////////////////////////////////////
1: 
commit:4c986d1
/////////////////////////////////////////////////////////////////////////
1:             // For individual Ack we already sent an Ack that will be applied on commit
1:             // we don't send a second standard Ack as that would produce an error.
1:             if (!unconsumedMessage.isEmpty() && ackMode == CLIENT_ACK) {
1:                 ack.setTransactionId(transactionId);
commit:e83bb6d
/////////////////////////////////////////////////////////////////////////
1:     protected final LinkedHashMap<MessageId, MessageDispatch> dispatchedMessage = new LinkedHashMap<>();
1:     protected final LinkedList<MessageDispatch> unconsumedMessage = new LinkedList<>();
/////////////////////////////////////////////////////////////////////////
1:         if (ackMode.equals(CLIENT_ACK) || ackMode.equals(INDIVIDUAL_ACK)) {
1:         } else if (ackMode.equals(AUTO_ACK)) {
/////////////////////////////////////////////////////////////////////////
1:             ack.setMessageCount(1);
1:             } else {
1:                 dispatchedMessage.remove(msgId);
author:Gary Tully
-------------------------------------------------------------------------------
commit:37ad85e
/////////////////////////////////////////////////////////////////////////
1:     void onStompCommit(TransactionId transactionId) {
1:         MessageAck ack = null;
1:         synchronized (this) {
1:             for (Iterator<?> iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
1:                 @SuppressWarnings("rawtypes")
1:                 Map.Entry entry = (Entry)iter.next();
1:                 MessageDispatch msg = (MessageDispatch)entry.getValue();
1:                 if (unconsumedMessage.contains(msg)) {
1:                     iter.remove();
1:                 }
1:             }
1: 
0:             if (!unconsumedMessage.isEmpty()) {
1:                 ack = new MessageAck(unconsumedMessage.getLast(), MessageAck.STANDARD_ACK_TYPE, unconsumedMessage.size());
1:                 unconsumedMessage.clear();
1:         // avoid contention with onMessageDispatch
1:         if (ack != null) {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:3910056
/////////////////////////////////////////////////////////////////////////
1: 
1:         boolean ignoreTransformation = false;
1:         
1:         } else {
1:         	if (message.getStringProperty(Stomp.Headers.TRANSFORMATION) != null) {
1:         		ignoreTransformation = true;
1:         	}
1:         StompFrame command = protocolConverter.convertMessage(message, ignoreTransformation);
commit:2b5608f
/////////////////////////////////////////////////////////////////////////
0:     private String transformation;
1:     public StompSubscription(ProtocolConverter stompTransport, String subscriptionId, ConsumerInfo consumerInfo, String transformation) {
1:         this.transformation = transformation;
/////////////////////////////////////////////////////////////////////////
0:         if (transformation != null) {
1:        		message.setReadOnlyProperties(false);
1:         	message.setStringProperty(Stomp.Headers.TRANSFORMATION, transformation);
1:         }
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedHashMap<String, MessageId> dispatchedMessage = new LinkedHashMap<String, MessageId>();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:             if (ack.getFirstMessageId() == null) {
1:             }
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * @author <a href="http://hiramchirino.com">chirino</a>
1: 
0:     private final ProtocolConverter protocolConverter;
0:     private final LinkedHashMap dispatchedMessage = new LinkedHashMap();
1: 
0:     private String ackMode = AUTO_ACK;
0:     private ActiveMQDestination destination;
1: 
1:         this.subscriptionId = subscriptionId;
1:         ActiveMQMessage message = (ActiveMQMessage)md.getMessage();
1: 
0:                 dispatchedMessage.put(message.getJMSMessageID(), message.getMessageId());
1: 
1: 
1:         command.setAction(Stomp.Responses.MESSAGE);
1:         if (subscriptionId != null) {
1: 
1: 
1: 
0:         if (!dispatchedMessage.containsKey(messageId)) {
1:             return null;
1:         }
1: 
1: 
1:         int count = 0;
1: 
1:             Map.Entry entry = (Entry)iter.next();
0:             String id = (String)entry.getKey();
0:             MessageId msgid = (MessageId)entry.getValue();
1: 
0:             if (ack.getFirstMessageId() == null)
0:             if (id.equals(messageId)) {
1: 
1: 
1:     public String getAckMode() {
1:         return ackMode;
1:     }
1:     public void setAckMode(String ackMode) {
1:         this.ackMode = ackMode;
1:     }
1:     public String getSubscriptionId() {
1:         return subscriptionId;
1:     }
1:     public void setDestination(ActiveMQDestination destination) {
1:         this.destination = destination;
1:     }
1:     public ActiveMQDestination getDestination() {
1:         return destination;
1:     }
1:     public ConsumerInfo getConsumerInfo() {
1:         return consumerInfo;
1:     }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:76efc33
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
0:         	Map.Entry entry = (Entry) iter.next();
0:             String id = (String) entry.getKey();
0:             MessageId msgid = (MessageId) entry.getValue();
1:             
0:                 ack.setFirstMessageId(msgid);
1: 
0:                 ack.setLastMessageId(msgid);
1:             
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:98b61e4
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.transport.stomp;
commit:1f6aa57
/////////////////////////////////////////////////////////////////////////
commit:530884a
/////////////////////////////////////////////////////////////////////////
0:         StompFrame command = protocolConverter.convertMessage(message);
commit:dc98d96
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.activemq.transport.stomp2;
1: 
1: import java.io.IOException;
1: import java.util.Iterator;
1: import java.util.LinkedHashMap;
1: 
1: import javax.jms.JMSException;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
0: import org.apache.activemq.transport.stomp.Stomp;
1: 
1: /**
0:  * Keeps track of the STOMP susbscription so that acking is correctly done.
1:  *  
0:  * @author <a href="http://hiramchirino.com">chirino</a> 
1:  */
1: public class StompSubscription {
1:     
1:     public static final String AUTO_ACK = Stomp.Headers.Subscribe.AckModeValues.AUTO;
1:     public static final String CLIENT_ACK = Stomp.Headers.Subscribe.AckModeValues.CLIENT;
1: 
0: 	private final ProtocolConverter protocolConverter;
0:     private final String subscriptionId;
0:     private final ConsumerInfo consumerInfo;
1:     
0:     private final LinkedHashMap dispatchedMessage = new LinkedHashMap();
1:     
0:     private String ackMode = AUTO_ACK;
0: 	private ActiveMQDestination destination;
1: 
1:     
0:     public StompSubscription(ProtocolConverter stompTransport, String subscriptionId, ConsumerInfo consumerInfo) {
1:         this.protocolConverter = stompTransport;
0: 		this.subscriptionId = subscriptionId;
1:         this.consumerInfo = consumerInfo;
1:     }
1: 
0:     void onMessageDispatch(MessageDispatch md) throws IOException, JMSException {
1: 
0:     	ActiveMQMessage message = (ActiveMQMessage) md.getMessage();
1:     	
1:         if (ackMode == CLIENT_ACK) {
1:             synchronized (this) {
0:             	dispatchedMessage.put(message.getJMSMessageID(), message.getMessageId());
1:             }
0:         } else if (ackMode == AUTO_ACK) {
1:             MessageAck ack = new MessageAck(md, MessageAck.STANDARD_ACK_TYPE, 1);
0:             protocolConverter.getTransportFilter().sendToActiveMQ(ack);
1:         }
1:         
0:         StompCommand command = protocolConverter.convertMessage(message);
1:         
0:         command.setAction(Stomp.Responses.MESSAGE);        
0:         if (subscriptionId!=null) {
1:             command.getHeaders().put(Stomp.Headers.Message.SUBSCRIPTION, subscriptionId);
1:         }
1:         
0:         protocolConverter.getTransportFilter().sendToStomp(command);
1:     }
1:     
0:     synchronized MessageAck onStompMessageAck(String messageId) {
1:     	
0: 		if( !dispatchedMessage.containsKey(messageId) ) {
1: 			return null;
1: 		}
1:     	
1:         MessageAck ack = new MessageAck();
1:         ack.setDestination(consumerInfo.getDestination());
1:         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
1:         ack.setConsumerId(consumerInfo.getConsumerId());
1:         
0:         int count=0;
0:         for (Iterator iter = dispatchedMessage.keySet().iterator(); iter.hasNext();) {
1:             
0:             String id = (String) iter.next();
0:             if( ack.getFirstMessageId()==null )
0:                 ack.setFirstMessageId((MessageId) dispatchedMessage.get(id));
1: 
1:             iter.remove();
1:             count++;
0:             if( id.equals(messageId)  ) {
0:                 ack.setLastMessageId((MessageId) dispatchedMessage.get(id));
1:                 break;
1:             }
1:         }
1:         
1:         ack.setMessageCount(count);
1:         return ack;
1:     }
1: 
0: 	public String getAckMode() {
0: 		return ackMode;
1: 	}
1: 
0: 	public void setAckMode(String ackMode) {
0: 		this.ackMode = ackMode;
1: 	}
1: 
0: 	public String getSubscriptionId() {
0: 		return subscriptionId;
1: 	}
1: 
0: 	public void setDestination(ActiveMQDestination destination) {
0: 		this.destination = destination;
1: 	}
1: 
0: 	public ActiveMQDestination getDestination() {
0: 		return destination;
1: 	}
1: 
0: 	public ConsumerInfo getConsumerInfo() {
0: 		return consumerInfo;
1: 	}
1: 
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:6d08aca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.JMSException;
0: 
1: import org.apache.activemq.command.ActiveMQBytesMessage;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.TransactionId;
0: 
/////////////////////////////////////////////////////////////////////////
1:     void onMessageDispatch(MessageDispatch md, String ackId) throws IOException, JMSException {
/////////////////////////////////////////////////////////////////////////
0:             message.setReadOnlyProperties(false);
/////////////////////////////////////////////////////////////////////////
1:         if (ackId != null) {
1:             command.getHeaders().put(Stomp.Headers.Message.ACK_ID, ackId);
1:         }
0: 
commit:f33f32e
/////////////////////////////////////////////////////////////////////////
1:             protocolConverter.getStompTransport().sendToActiveMQ(ack);
/////////////////////////////////////////////////////////////////////////
1:             protocolConverter.getStompTransport().sendToActiveMQ(ack);
commit:3b381e7
/////////////////////////////////////////////////////////////////////////
0:             protocolConverter.getStompTransport().asyncSendToActiveMQ(ack);
commit:8cf3187
/////////////////////////////////////////////////////////////////////////
0:             protocolConverter.getStompTransport().asyncSendToActiveMQ(ack);
commit:3060a64
/////////////////////////////////////////////////////////////////////////
0:         if (!unconsumedMessage.isEmpty()) {
0:             MessageAck ack = new MessageAck(unconsumedMessage.getLast(), MessageAck.STANDARD_ACK_TYPE, unconsumedMessage.size());
0:             protocolConverter.getStompTransport().sendToActiveMQ(ack);
1:             unconsumedMessage.clear();
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (transactionId == null) {
0:                 ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
1:             } else {
1:                 ack.setAckType(MessageAck.DELIVERED_ACK_TYPE);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                         count++;
1:                     count++;
commit:0885c60
/////////////////////////////////////////////////////////////////////////
1:     protected final ProtocolConverter protocolConverter;
1:     protected final String subscriptionId;
1:     protected final ConsumerInfo consumerInfo;
0:     protected final LinkedHashMap<MessageId, MessageDispatch> dispatchedMessage = new LinkedHashMap<MessageId, MessageDispatch>();
0:     protected final LinkedList<MessageDispatch> unconsumedMessage = new LinkedList<MessageDispatch>();
1:     protected String ackMode = AUTO_ACK;
1:     protected ActiveMQDestination destination;
1:     protected String transformation;
/////////////////////////////////////////////////////////////////////////
0:                message.setReadOnlyProperties(false);
0:             message.setStringProperty(Stomp.Headers.TRANSFORMATION, transformation);
0:             if (message.getStringProperty(Stomp.Headers.TRANSFORMATION) != null) {
0:                 ignoreTransformation = true;
1:             }
/////////////////////////////////////////////////////////////////////////
0:         unconsumedMessage.clear();
1:         for (Iterator<?> iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
1:             @SuppressWarnings("rawtypes")
0:                 iter.remove();
1:         }
0: 
0:         unconsumedMessage.clear();
1:         MessageId msgId = new MessageId(messageId);
/////////////////////////////////////////////////////////////////////////
0:             ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:             for (Iterator<?> iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
0:                 @SuppressWarnings("rawtypes")
/////////////////////////////////////////////////////////////////////////
1:                     if (!unconsumedMessage.contains(msg)) {
1:                         unconsumedMessage.add(msg);
1:                     }
0:                     iter.remove();
1:                 ack.setTransactionId(transactionId);
0: 
1:         } else if (ackMode == INDIVIDUAL_ACK) {
1:                 unconsumedMessage.add(dispatchedMessage.get(msgId));
1:                 ack.setTransactionId(transactionId);
1:     public MessageAck onStompMessageNack(String messageId, TransactionId transactionId) throws ProtocolException {
0: 
1:         MessageId msgId = new MessageId(messageId);
0: 
1:         if (!dispatchedMessage.containsKey(msgId)) {
0:             return null;
1:         }
0: 
1:         MessageAck ack = new MessageAck();
1:         ack.setDestination(consumerInfo.getDestination());
1:         ack.setConsumerId(consumerInfo.getConsumerId());
1:         ack.setAckType(MessageAck.POSION_ACK_TYPE);
1:         ack.setMessageID(msgId);
1:         if (transactionId != null) {
1:             unconsumedMessage.add(dispatchedMessage.get(msgId));
1:             ack.setTransactionId(transactionId);
1:         }
1:         dispatchedMessage.remove(msgId);
0: 
0:         return null;
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:9807ee3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQBytesMessage;
/////////////////////////////////////////////////////////////////////////
1:         if (transformation != null && !( message instanceof ActiveMQBytesMessage ) ) {
commit:87cdbbe
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:             }
0:             dispatchedMessage.remove(msgId);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e3a1fc9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
0: 
0: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return ack;
commit:ceed011
/////////////////////////////////////////////////////////////////////////
0:             protocolConverter.getStompTransport().sendToActiveMQ(ack);
/////////////////////////////////////////////////////////////////////////
1:         protocolConverter.getStompTransport().sendToStomp(command);
commit:b0f24f3
/////////////////////////////////////////////////////////////////////////
1:     synchronized void onStompAbort(TransactionId transactionId) {
0:     	unconsumedMessage.clear();
0:     	for (Iterator iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
0:             Map.Entry entry = (Entry)iter.next();
1:             MessageId id = (MessageId)entry.getKey();
1:             MessageDispatch msg = (MessageDispatch)entry.getValue();
0:             if (unconsumedMessage.contains(msg)) {
0:             	iter.remove();
0:             }
0:     	unconsumedMessage.clear();
/////////////////////////////////////////////////////////////////////////
0:         	ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
/////////////////////////////////////////////////////////////////////////
0:                 	if (!unconsumedMessage.contains(msg)) {
0:                 	}
1:                 } else {
0:                 	iter.remove();
commit:1a6279e
/////////////////////////////////////////////////////////////////////////
0:     	if (!unconsumedMessage.isEmpty()) {
0:     		MessageAck ack = new MessageAck();
0:     		ack.setDestination(consumerInfo.getDestination());
0:     		ack.setConsumerId(consumerInfo.getConsumerId());
0:     		ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:     		ack.setFirstMessageId(unconsumedMessage.getFirst().getMessage().getMessageId());
0:     		ack.setLastMessageId(unconsumedMessage.getLast().getMessage().getMessageId());
0:     		ack.setMessageCount(unconsumedMessage.size());
0:     		ack.setTransactionId(transactionId);
0:     		protocolConverter.getTransportFilter().sendToActiveMQ(ack);
0:     		// clear lists
0:     		unconsumedMessage.clear();
0:     	}
/////////////////////////////////////////////////////////////////////////
0:                 iter.remove();
commit:f6ebeec
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.TransactionId;
1:  * Keeps track of the STOMP subscription so that acking is correctly done.
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedHashMap<MessageId, MessageDispatch> dispatchedMessage = new LinkedHashMap<MessageId, MessageDispatch>();
0:     private final LinkedList<MessageDispatch> unconsumedMessage = new LinkedList<MessageDispatch>();
0:     
/////////////////////////////////////////////////////////////////////////
1:                 dispatchedMessage.put(message.getMessageId(), md);
1:                 dispatchedMessage.put(message.getMessageId(), md);
/////////////////////////////////////////////////////////////////////////
0:         
0:         
0:     
0:     synchronized void onStompAbort(TransactionId transactionId) throws IOException, JMSException {
0:     	//ack all unacked messages
0:     	for (MessageDispatch md : dispatchedMessage.values()) {
0:     		if (!unconsumedMessage.contains(md)) {
0:     	        MessageAck ack = new MessageAck();
0:     	        ack.setDestination(consumerInfo.getDestination());
0:     	        ack.setConsumerId(consumerInfo.getConsumerId());
0:     	        ack.setAckType(MessageAck.DELIVERED_ACK_TYPE);
0:     	        ack.setFirstMessageId(md.getMessage().getMessageId());
0:     	        ack.setLastMessageId(md.getMessage().getMessageId());
0:     	        ack.setMessageCount(1);
0:     	        ack.setTransactionId(transactionId);
0:     	        protocolConverter.getTransportFilter().sendToActiveMQ(ack);
0:     	        unconsumedMessage.add(md);
0:     		}
0:     	}
0:     	// redeliver all unconsumed messages
0:     	for (MessageDispatch md : unconsumedMessage) {
0:     		onMessageDispatch(md);
0:     	}
0:     }
0:     
0:     synchronized void onStompCommit(TransactionId transactionId) {
0:     	// ack all messages
0:         MessageAck ack = new MessageAck();
0:         ack.setDestination(consumerInfo.getDestination());
0:         ack.setConsumerId(consumerInfo.getConsumerId());
0:         ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:         ack.setFirstMessageId(unconsumedMessage.getFirst().getMessage().getMessageId());
0:         ack.setLastMessageId(unconsumedMessage.getLast().getMessage().getMessageId());
0:         ack.setMessageCount(unconsumedMessage.size());
0:         ack.setTransactionId(transactionId);
0:         protocolConverter.getTransportFilter().sendToActiveMQ(ack);
0:         // clear lists
0:     	unconsumedMessage.clear();
0:     	dispatchedMessage.clear();
0:     }
1:     synchronized MessageAck onStompMessageAck(String messageId, TransactionId transactionId) {
0:     	
0:     	MessageId msgId = new MessageId(messageId);
0:     	
1:         if (!dispatchedMessage.containsKey(msgId)) {
/////////////////////////////////////////////////////////////////////////
1:         	if (transactionId != null) {
0:         		ack.setAckType(MessageAck.DELIVERED_ACK_TYPE);
0:         	} else {
0:         		ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:         	}
0:                 MessageId id = (MessageId)entry.getKey();
0:                 MessageDispatch msg = (MessageDispatch)entry.getValue();
0:                     ack.setFirstMessageId(id);
0:                 
1:                 if (transactionId != null) {
0:                 	if (!unconsumedMessage.contains(msg))
0:                 		unconsumedMessage.add(msg);
0:                 } else {
0:                 	iter.remove();
0:                 }
0:                 
0:                 
1:                 if (id.equals(msgId)) {
1:                     ack.setLastMessageId(id);
1:             if (transactionId != null) {
0:             	ack.setTransactionId(transactionId);
0:             }
1:             ack.setMessageID(msgId);
1:             if (transactionId != null) {
0:             	unconsumedMessage.add(dispatchedMessage.get(msgId));
0:             	ack.setTransactionId(transactionId);
0:             } 
author:Robert Davies
-------------------------------------------------------------------------------
commit:b1288f2
/////////////////////////////////////////////////////////////////////////
1:     public static final String INDIVIDUAL_ACK = Stomp.Headers.Subscribe.AckModeValues.INDIVIDUAL;
/////////////////////////////////////////////////////////////////////////
0:         } else if (ackMode == INDIVIDUAL_ACK) {
0:             synchronized (this) {
0:                 dispatchedMessage.put(message.getJMSMessageID(), message.getMessageId());
0:             }
/////////////////////////////////////////////////////////////////////////
0:         if (ackMode == CLIENT_ACK) {
0:             ack.setAckType(MessageAck.STANDARD_ACK_TYPE);
0:             int count = 0;
0:             for (Iterator iter = dispatchedMessage.entrySet().iterator(); iter.hasNext();) {
0:                 Map.Entry entry = (Entry)iter.next();
0:                 String id = (String)entry.getKey();
0:                 MessageId msgid = (MessageId)entry.getValue();
0:                 if (ack.getFirstMessageId() == null) {
0:                     ack.setFirstMessageId(msgid);
0:                 }
0: 
0:                 iter.remove();
0:                 count++;
0: 
0:                 if (id.equals(messageId)) {
0:                     ack.setLastMessageId(msgid);
0:                     break;
0:                 }
0: 
0:             ack.setMessageCount(count);
0:         else if (ackMode == INDIVIDUAL_ACK) {
1:             ack.setAckType(MessageAck.INDIVIDUAL_ACK_TYPE);
0:             MessageId msgid = (MessageId)dispatchedMessage.get(messageId);
0:             ack.setMessageID(msgid);
0:             dispatchedMessage.remove(messageId);
0:         }
============================================================================