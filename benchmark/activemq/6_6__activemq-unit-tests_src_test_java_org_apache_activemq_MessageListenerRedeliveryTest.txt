1:4a27b72: /*
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:03de4c2:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:03de4c2:  *
1:03de4c2:  * Unless required by applicable law or agreed to in writing, software
1:03de4c2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:03de4c2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:03de4c2:  * See the License for the specific language governing permissions and
1:03de4c2:  * limitations under the License.
2:03de4c2:  */
1:03de4c2: package org.apache.activemq;
1:0826fdc: 
1:4a27b72: import static org.junit.Assert.assertEquals;
1:4a27b72: import static org.junit.Assert.assertNotNull;
1:4a27b72: import static org.junit.Assert.assertTrue;
1:4a27b72: import static org.junit.Assert.fail;
1:4a27b72: 
1:7f8c822: import java.util.ArrayList;
1:7f8c822: import java.util.concurrent.CountDownLatch;
1:7f8c822: import java.util.concurrent.TimeUnit;
1:7f8c822: import java.util.concurrent.atomic.AtomicInteger;
1:7f8c822: 
1:03de4c2: import javax.jms.Connection;
1:03de4c2: import javax.jms.DeliveryMode;
1:03de4c2: import javax.jms.Destination;
1:03de4c2: import javax.jms.JMSException;
1:03de4c2: import javax.jms.Message;
1:03de4c2: import javax.jms.MessageConsumer;
1:03de4c2: import javax.jms.MessageListener;
1:03de4c2: import javax.jms.MessageProducer;
1:03de4c2: import javax.jms.Queue;
1:03de4c2: import javax.jms.Session;
1:03de4c2: import javax.jms.TextMessage;
1:7f8c822: 
1:7f8c822: import org.apache.activemq.command.ActiveMQDestination;
1:e10f75c: import org.apache.activemq.command.ActiveMQMessage;
1:7f8c822: import org.apache.activemq.command.ActiveMQQueue;
1:4a27b72: import org.junit.After;
1:4a27b72: import org.junit.Before;
1:4a27b72: import org.junit.Rule;
1:4a27b72: import org.junit.Test;
1:4a27b72: import org.junit.rules.TestName;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:f25e2ca: 
1:4a27b72: public class MessageListenerRedeliveryTest {
24:03de4c2: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(MessageListenerRedeliveryTest.class);
1:03de4c2: 
1:4a27b72:     @Rule
1:4a27b72:     public TestName name = new TestName();
1:4a27b72: 
1:03de4c2:     private Connection connection;
1:03de4c2: 
1:4a27b72:     @Before
1:4a27b72:     public void setUp() throws Exception {
1:03de4c2:         connection = createConnection();
7:03de4c2:     }
1:0826fdc: 
1:4a27b72:     @After
1:4a27b72:     public void tearDown() throws Exception {
1:03de4c2:         if (connection != null) {
1:03de4c2:             connection.close();
1:03de4c2:             connection = null;
1:03de4c2:         }
1:03de4c2:     }
1:230a86c: 
1:4a27b72:     protected String getTestName() {
1:4a27b72:         return name.getMethodName();
1:4a27b72:     }
1:4a27b72: 
1:03de4c2:     protected RedeliveryPolicy getRedeliveryPolicy() {
1:03de4c2:         RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
1:c23f9e6:         redeliveryPolicy.setInitialRedeliveryDelay(0);
1:c23f9e6:         redeliveryPolicy.setRedeliveryDelay(1000);
1:da5139c:         redeliveryPolicy.setMaximumRedeliveries(3);
1:4a27b72:         redeliveryPolicy.setBackOffMultiplier((short) 2);
1:03de4c2:         redeliveryPolicy.setUseExponentialBackOff(true);
1:03de4c2:         return redeliveryPolicy;
1:03de4c2:     }
1:da5139c: 
1:03de4c2:     protected Connection createConnection() throws Exception {
1:e10f75c:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm://localhost?broker.persistent=false&marshal=true");
1:03de4c2:         factory.setRedeliveryPolicy(getRedeliveryPolicy());
1:03de4c2:         return factory.createConnection();
1:03de4c2:     }
1:f25e2ca: 
1:f25e2ca:     private class TestMessageListener implements MessageListener {
1:f25e2ca: 
1:230a86c:         public int counter;
1:0826fdc:         private final Session session;
1:03de4c2: 
1:f25e2ca:         public TestMessageListener(Session session) {
1:03de4c2:             this.session = session;
1:03de4c2:         }
1:03de4c2: 
1:0826fdc:         @Override
2:03de4c2:         public void onMessage(Message message) {
2:03de4c2:             try {
1:933eb2f:                 LOG.info("Message Received: " + message);
2:03de4c2:                 counter++;
1:da5139c:                 if (counter <= 4) {
1:933eb2f:                     LOG.info("Message Rollback.");
1:03de4c2:                     session.rollback();
2:03de4c2:                 } else {
1:933eb2f:                     LOG.info("Message Commit.");
2:03de4c2:                     message.acknowledge();
2:03de4c2:                     session.commit();
1:03de4c2:                 }
2:03de4c2:             } catch (JMSException e) {
1:933eb2f:                 LOG.error("Error when rolling back transaction");
1:03de4c2:             }
1:03de4c2:         }
1:03de4c2:     }
1:f25e2ca: 
1:4a27b72:     @Test(timeout = 60000)
1:f25e2ca:     public void testQueueRollbackConsumerListener() throws JMSException {
1:03de4c2:         connection.start();
1:0826fdc: 
1:03de4c2:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:4a27b72:         Queue queue = session.createQueue("queue-" + getTestName());
1:03de4c2:         MessageProducer producer = createProducer(session, queue);
1:03de4c2:         Message message = createTextMessage(session);
1:03de4c2:         producer.send(message);
1:03de4c2:         session.commit();
1:0826fdc: 
1:03de4c2:         MessageConsumer consumer = session.createConsumer(queue);
1:0826fdc: 
1:4a27b72:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer) consumer;
1:03de4c2:         mc.setRedeliveryPolicy(getRedeliveryPolicy());
1:0826fdc: 
1:f25e2ca:         TestMessageListener listener = new TestMessageListener(session);
1:03de4c2:         consumer.setMessageListener(listener);
1:0826fdc: 
1:03de4c2:         try {
1:f25e2ca:             Thread.sleep(500);
1:03de4c2:         } catch (InterruptedException e) {
1:03de4c2:         }
1:0826fdc: 
1:230a86c:         // first try.. should get 2 since there is no delay on the
1:da5139c:         // first redeliver..
1:da5139c:         assertEquals(2, listener.counter);
1:0826fdc: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(1000);
1:f25e2ca:         } catch (InterruptedException e) {
1:f25e2ca:         }
1:da5139c:         // 2nd redeliver (redelivery after 1 sec)
1:da5139c:         assertEquals(3, listener.counter);
1:f25e2ca: 
1:03de4c2:         try {
1:03de4c2:             Thread.sleep(2000);
1:03de4c2:         } catch (InterruptedException e) {
1:f25e2ca:         }
1:230a86c:         // 3rd redeliver (redelivery after 2 seconds) - it should give up after
1:230a86c:         // that
1:da5139c:         assertEquals(4, listener.counter);
1:f25e2ca: 
1:f25e2ca:         // create new message
1:f25e2ca:         producer.send(createTextMessage(session));
1:f25e2ca:         session.commit();
1:f25e2ca: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(500);
1:f25e2ca:         } catch (InterruptedException e) {
1:03de4c2:         }
1:f25e2ca:         // it should be committed, so no redelivery
1:da5139c:         assertEquals(5, listener.counter);
1:f25e2ca: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(1500);
1:f25e2ca:         } catch (InterruptedException e) {
1:f25e2ca:         }
1:f25e2ca:         // no redelivery, counter should still be 4
1:da5139c:         assertEquals(5, listener.counter);
1:f25e2ca: 
1:f25e2ca:         session.close();
1:f25e2ca:     }
1:7f8c822: 
1:4a27b72:     @Test(timeout = 60000)
1:f25e2ca:     public void testQueueRollbackSessionListener() throws JMSException {
1:7f8c822:         connection.start();
1:7f8c822: 
1:f25e2ca:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
1:4a27b72:         Queue queue = session.createQueue("queue-" + getTestName());
1:f25e2ca:         MessageProducer producer = createProducer(session, queue);
1:f25e2ca:         Message message = createTextMessage(session);
1:f25e2ca:         producer.send(message);
1:f25e2ca:         session.commit();
1:7f8c822: 
1:f25e2ca:         MessageConsumer consumer = session.createConsumer(queue);
1:0826fdc: 
1:4a27b72:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer) consumer;
1:f25e2ca:         mc.setRedeliveryPolicy(getRedeliveryPolicy());
1:f25e2ca: 
1:f25e2ca:         TestMessageListener listener = new TestMessageListener(session);
1:f25e2ca:         consumer.setMessageListener(listener);
1:f25e2ca: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(500);
1:f25e2ca:         } catch (InterruptedException e) {
1:f25e2ca: 
1:f25e2ca:         }
1:230a86c:         // first try
1:da5139c:         assertEquals(2, listener.counter);
1:f25e2ca: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(1000);
1:f25e2ca:         } catch (InterruptedException e) {
1:f25e2ca: 
1:f25e2ca:         }
2:f25e2ca:         // second try (redelivery after 1 sec)
1:da5139c:         assertEquals(3, listener.counter);
1:f25e2ca: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(2000);
1:f25e2ca:         } catch (InterruptedException e) {
1:f25e2ca: 
1:f25e2ca:         }
2:f25e2ca:         // third try (redelivery after 2 seconds) - it should give up after that
1:da5139c:         assertEquals(4, listener.counter);
1:f25e2ca: 
1:f25e2ca:         // create new message
1:f25e2ca:         producer.send(createTextMessage(session));
1:f25e2ca:         session.commit();
1:f25e2ca: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(500);
1:f25e2ca:         } catch (InterruptedException e) {
2:f25e2ca:             // ignore
1:f25e2ca:         }
1:f25e2ca:         // it should be committed, so no redelivery
1:da5139c:         assertEquals(5, listener.counter);
1:f25e2ca: 
1:f25e2ca:         try {
1:f25e2ca:             Thread.sleep(1500);
1:f25e2ca:         } catch (InterruptedException e) {
1:f25e2ca:             // ignore
1:f25e2ca:         }
1:f25e2ca:         // no redelivery, counter should still be 4
1:da5139c:         assertEquals(5, listener.counter);
1:f25e2ca: 
1:03de4c2:         session.close();
1:03de4c2:     }
1:f25e2ca: 
1:4a27b72:     @Test(timeout = 60000)
1:4a27b72:     public void testQueueSessionListenerExceptionRetry() throws Exception {
1:f25e2ca:         connection.start();
1:f25e2ca: 
1:7f8c822:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4a27b72:         Queue queue = session.createQueue("queue-" + getTestName());
1:7f8c822:         MessageProducer producer = createProducer(session, queue);
1:7f8c822:         Message message = createTextMessage(session, "1");
1:7f8c822:         producer.send(message);
1:7f8c822:         message = createTextMessage(session, "2");
1:7f8c822:         producer.send(message);
1:7f8c822: 
1:7f8c822:         MessageConsumer consumer = session.createConsumer(queue);
1:7f8c822: 
1:7f8c822:         final CountDownLatch gotMessage = new CountDownLatch(2);
1:4a27b72:         final AtomicInteger count = new AtomicInteger(0);
1:7f8c822:         final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();
1:7f8c822:         final ArrayList<String> received = new ArrayList<String>();
1:7f8c822:         consumer.setMessageListener(new MessageListener() {
1:0826fdc:             @Override
1:7f8c822:             public void onMessage(Message message) {
1:7f8c822:                 LOG.info("Message Received: " + message);
1:7f8c822:                 try {
1:7f8c822:                     received.add(((TextMessage) message).getText());
1:7f8c822:                 } catch (JMSException e) {
1:7f8c822:                     e.printStackTrace();
1:7f8c822:                     fail(e.toString());
1:7f8c822:                 }
1:7f8c822:                 if (count.incrementAndGet() < maxDeliveries) {
1:4a27b72:                     throw new RuntimeException(getTestName() + " force a redelivery");
1:7f8c822:                 }
1:7f8c822:                 // new blood
1:7f8c822:                 count.set(0);
1:7f8c822:                 gotMessage.countDown();
1:7f8c822:             }
1:7f8c822:         });
1:7f8c822: 
1:7f8c822:         assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));
1:7f8c822: 
1:4a27b72:         for (int i = 0; i < maxDeliveries; i++) {
1:7f8c822:             assertEquals("got first redelivered: " + i, "1", received.get(i));
1:7f8c822:         }
1:4a27b72:         for (int i = maxDeliveries; i < maxDeliveries * 2; i++) {
1:7f8c822:             assertEquals("got first redelivered: " + i, "2", received.get(i));
1:7f8c822:         }
1:7f8c822:         session.close();
1:7f8c822:     }
1:7f8c822: 
1:4a27b72:     @Test(timeout = 60000)
1:4a27b72:     public void testQueueSessionListenerExceptionDlq() throws Exception {
1:7f8c822:         connection.start();
1:7f8c822: 
1:7f8c822:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:4a27b72:         Queue queue = session.createQueue("queue-" + getTestName());
1:7f8c822:         MessageProducer producer = createProducer(session, queue);
1:7f8c822:         Message message = createTextMessage(session);
1:7f8c822:         producer.send(message);
1:7f8c822: 
1:e10f75c:         final Message[] dlqMessage = new Message[1];
1:7f8c822:         ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
1:7f8c822:         MessageConsumer dlqConsumer = session.createConsumer(dlqDestination);
1:7f8c822:         final CountDownLatch gotDlqMessage = new CountDownLatch(1);
1:7f8c822:         dlqConsumer.setMessageListener(new MessageListener() {
1:4a27b72:             @Override
1:7f8c822:             public void onMessage(Message message) {
1:e10f75c:                 LOG.info("DLQ Message Received: " + message);
1:e10f75c:                 dlqMessage[0] = message;
1:7f8c822:                 gotDlqMessage.countDown();
1:4a27b72:             }
1:4a27b72:         });
1:4a27b72: 
1:7f8c822:         MessageConsumer consumer = session.createConsumer(queue);
1:7f8c822: 
1:7f8c822:         final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();
1:7f8c822:         final CountDownLatch gotMessage = new CountDownLatch(maxDeliveries);
1:4a27b72: 
1:7f8c822:         consumer.setMessageListener(new MessageListener() {
1:0826fdc:             @Override
1:7f8c822:             public void onMessage(Message message) {
1:7f8c822:                 LOG.info("Message Received: " + message);
1:7f8c822:                 gotMessage.countDown();
1:4a27b72:                 throw new RuntimeException(getTestName() + " force a redelivery");
1:7f8c822:             }
1:7f8c822:         });
1:7f8c822: 
1:7f8c822:         assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));
1:7f8c822: 
1:7f8c822:         // check DLQ
1:7f8c822:         assertTrue("got dlq message", gotDlqMessage.await(20, TimeUnit.SECONDS));
1:e10f75c: 
1:e10f75c:         // check DLQ message cause is captured
1:e10f75c:         message = dlqMessage[0];
1:e10f75c:         assertNotNull("dlq message captured", message);
1:e10f75c:         String cause = message.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:20f384c: 
1:0826fdc:         LOG.info("DLQ'd message cause reported as: {}", cause);
1:4a27b72: 
1:20f384c:         assertTrue("cause 'cause' exception is remembered", cause.contains("RuntimeException"));
1:4a27b72:         assertTrue("is correct exception", cause.contains(getTestName()));
1:4a27b72:         assertTrue("cause exception is remembered", cause.contains("Throwable"));
1:4a27b72:         assertTrue("cause policy is remembered", cause.contains("RedeliveryPolicy"));
1:b6bca39:         assertTrue("cause redelivered count is remembered", cause.contains("[" + (maxDeliveries+1) +"]"));
1:4a27b72: 
1:4a27b72:         session.close();
1:4a27b72:     }
1:4a27b72: 
1:4a27b72:     @Test(timeout = 60000)
1:4a27b72:     public void testTransactedQueueSessionListenerExceptionDlq() throws Exception {
1:4a27b72:         connection.start();
1:4a27b72: 
1:4a27b72:         final Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:4a27b72:         Queue queue = session.createQueue("queue-" + getTestName());
1:4a27b72:         MessageProducer producer = createProducer(session, queue);
1:4a27b72:         Message message = createTextMessage(session);
1:4a27b72:         producer.send(message);
1:4a27b72:         session.commit();
1:4a27b72: 
1:4a27b72:         final Message[] dlqMessage = new Message[1];
1:4a27b72:         ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
1:4a27b72:         MessageConsumer dlqConsumer = session.createConsumer(dlqDestination);
1:4a27b72:         final CountDownLatch gotDlqMessage = new CountDownLatch(1);
1:4a27b72:         dlqConsumer.setMessageListener(new MessageListener() {
1:4a27b72:             @Override
1:4a27b72:             public void onMessage(Message message) {
1:4a27b72:                 LOG.info("DLQ Message Received: " + message);
1:4a27b72:                 dlqMessage[0] = message;
1:4a27b72:                 gotDlqMessage.countDown();
1:4a27b72:             }
1:4a27b72:         });
1:4a27b72: 
1:4a27b72:         MessageConsumer consumer = session.createConsumer(queue);
1:4a27b72: 
1:4a27b72:         final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();
1:4a27b72:         final CountDownLatch gotMessage = new CountDownLatch(maxDeliveries);
1:4a27b72: 
1:4a27b72:         consumer.setMessageListener(new MessageListener() {
1:0826fdc:             @Override
1:4a27b72:             public void onMessage(Message message) {
1:4a27b72:                 LOG.info("Message Received: " + message);
1:4a27b72:                 gotMessage.countDown();
1:4a27b72:                 try {
1:4a27b72:                     session.rollback();
1:4a27b72:                 } catch (JMSException e) {
1:4a27b72:                     e.printStackTrace();
1:4a27b72:                 }
1:4a27b72:                 throw new RuntimeException(getTestName() + " force a redelivery");
1:7f8c822:             }
1:7f8c822:         });
1:4a27b72: 
1:4a27b72:         assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));
1:4a27b72: 
1:4a27b72:         // check DLQ
1:4a27b72:         assertTrue("got dlq message", gotDlqMessage.await(20, TimeUnit.SECONDS));
1:20f384c: 
1:4a27b72:         // check DLQ message cause is captured
1:4a27b72:         message = dlqMessage[0];
1:4a27b72:         assertNotNull("dlq message captured", message);
1:4a27b72:         String cause = message.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1:7f8c822: 
1:4a27b72:         LOG.info("DLQ'd message cause reported as: {}", cause);
1:7f8c822: 
1:4a27b72:         assertTrue("cause 'cause' exception is remembered", cause.contains("RuntimeException"));
1:4a27b72:         assertTrue("is correct exception", cause.contains(getTestName()));
1:0826fdc:         assertTrue("cause exception is remembered", cause.contains("Throwable"));
1:20f384c:         assertTrue("cause policy is remembered", cause.contains("RedeliveryPolicy"));
1:7f8c822: 
1:7f8c822:         session.close();
1:7f8c822:     }
1:7f8c822: 
1:7f8c822:     private TextMessage createTextMessage(Session session, String text) throws JMSException {
1:7f8c822:         return session.createTextMessage(text);
1:7f8c822:     }
1:4a27b72: 
1:03de4c2:     private TextMessage createTextMessage(Session session) throws JMSException {
1:03de4c2:         return session.createTextMessage("Hello");
1:03de4c2:     }
1:7f8c822: 
1:03de4c2:     private MessageProducer createProducer(Session session, Destination queue) throws JMSException {
1:03de4c2:         MessageProducer producer = session.createProducer(queue);
1:03de4c2:         producer.setDeliveryMode(getDeliveryMode());
1:03de4c2:         return producer;
1:03de4c2:     }
1:0826fdc: 
1:03de4c2:     protected int getDeliveryMode() {
1:03de4c2:         return DeliveryMode.PERSISTENT;
1:86cbdfd:     }
1:03de4c2: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:b6bca39
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("cause redelivered count is remembered", cause.contains("[" + (maxDeliveries+1) +"]"));
author:Timothy Bish
-------------------------------------------------------------------------------
commit:4a27b72
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Rule;
1: import org.junit.Test;
1: import org.junit.rules.TestName;
1: public class MessageListenerRedeliveryTest {
1:     @Rule
1:     public TestName name = new TestName();
1: 
1:     @Before
1:     public void setUp() throws Exception {
1:     @After
1:     public void tearDown() throws Exception {
1:     protected String getTestName() {
1:         return name.getMethodName();
1:     }
1: 
1:         redeliveryPolicy.setBackOffMultiplier((short) 2);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:         Queue queue = session.createQueue("queue-" + getTestName());
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer) consumer;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:         Queue queue = session.createQueue("queue-" + getTestName());
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer) consumer;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60000)
1:     public void testQueueSessionListenerExceptionRetry() throws Exception {
1:         Queue queue = session.createQueue("queue-" + getTestName());
/////////////////////////////////////////////////////////////////////////
1:         final AtomicInteger count = new AtomicInteger(0);
/////////////////////////////////////////////////////////////////////////
1:                     throw new RuntimeException(getTestName() + " force a redelivery");
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < maxDeliveries; i++) {
1:         for (int i = maxDeliveries; i < maxDeliveries * 2; i++) {
1:     @Test(timeout = 60000)
1:     public void testQueueSessionListenerExceptionDlq() throws Exception {
1:         Queue queue = session.createQueue("queue-" + getTestName());
/////////////////////////////////////////////////////////////////////////
1:                 throw new RuntimeException(getTestName() + " force a redelivery");
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("is correct exception", cause.contains(getTestName()));
1:         assertTrue("cause exception is remembered", cause.contains("Throwable"));
1:         assertTrue("cause policy is remembered", cause.contains("RedeliveryPolicy"));
1: 
1:         session.close();
1:     }
1: 
1:     @Test(timeout = 60000)
1:     public void testTransactedQueueSessionListenerExceptionDlq() throws Exception {
1:         connection.start();
1: 
1:         final Session session = connection.createSession(true, Session.SESSION_TRANSACTED);
1:         Queue queue = session.createQueue("queue-" + getTestName());
1:         MessageProducer producer = createProducer(session, queue);
1:         Message message = createTextMessage(session);
1:         producer.send(message);
1:         session.commit();
1: 
1:         final Message[] dlqMessage = new Message[1];
1:         ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
1:         MessageConsumer dlqConsumer = session.createConsumer(dlqDestination);
1:         final CountDownLatch gotDlqMessage = new CountDownLatch(1);
1:         dlqConsumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 LOG.info("DLQ Message Received: " + message);
1:                 dlqMessage[0] = message;
1:                 gotDlqMessage.countDown();
1:             }
1:         });
1: 
1:         MessageConsumer consumer = session.createConsumer(queue);
1: 
1:         final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();
1:         final CountDownLatch gotMessage = new CountDownLatch(maxDeliveries);
1: 
1:         consumer.setMessageListener(new MessageListener() {
1:             @Override
1:             public void onMessage(Message message) {
1:                 LOG.info("Message Received: " + message);
1:                 gotMessage.countDown();
1:                 try {
1:                     session.rollback();
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                 }
1:                 throw new RuntimeException(getTestName() + " force a redelivery");
1:             }
1:         });
1: 
1:         assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));
1: 
1:         // check DLQ
1:         assertTrue("got dlq message", gotDlqMessage.await(20, TimeUnit.SECONDS));
1: 
1:         // check DLQ message cause is captured
1:         message = dlqMessage[0];
1:         assertNotNull("dlq message captured", message);
1:         String cause = message.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
1: 
1:         LOG.info("DLQ'd message cause reported as: {}", cause);
1: 
1:         assertTrue("cause 'cause' exception is remembered", cause.contains("RuntimeException"));
1:         assertTrue("is correct exception", cause.contains(getTestName()));
/////////////////////////////////////////////////////////////////////////
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:20f384c
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         assertTrue("cause 'cause' exception is remembered", cause.contains("RuntimeException"));
0:         assertTrue("is correct exception", cause.contains(getName()));
1:         assertTrue("cause policy is remembered", cause.contains("RedeliveryPolicy"));
commit:e10f75c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm://localhost?broker.persistent=false&marshal=true");
/////////////////////////////////////////////////////////////////////////
1:         final Message[] dlqMessage = new Message[1];
1:                 LOG.info("DLQ Message Received: " + message);
1:                 dlqMessage[0] = message;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // check DLQ message cause is captured
1:         message = dlqMessage[0];
1:         assertNotNull("dlq message captured", message);
1:         String cause = message.getStringProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY);
0:         assertTrue("cause exception is remembered", cause.contains("RuntimeException"));
0:         assertTrue("is correct exception", cause.contains(getName()));
commit:c23f9e6
/////////////////////////////////////////////////////////////////////////
1:         redeliveryPolicy.setInitialRedeliveryDelay(0);
1:         redeliveryPolicy.setRedeliveryDelay(1000);
commit:7f8c822
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
/////////////////////////////////////////////////////////////////////////
0:     public void testQueueSessionListenerExceptionRetry() throws  Exception {
1:         connection.start();
1:             
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue("queue-" + getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         Message message = createTextMessage(session, "1");
1:         producer.send(message);
1:         message = createTextMessage(session, "2");
1:         producer.send(message);
1:             
1:         
1:         MessageConsumer consumer = session.createConsumer(queue);
1:             
1:         final CountDownLatch gotMessage = new CountDownLatch(2);
0:         final AtomicInteger count  = new AtomicInteger(0);
1:         final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();
1:         final ArrayList<String> received = new ArrayList<String>();
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 LOG.info("Message Received: " + message);
1:                 try {
1:                     received.add(((TextMessage) message).getText());
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                     fail(e.toString());
1:                 }
1:                 if (count.incrementAndGet() < maxDeliveries) {
0:                     throw new RuntimeException(getName() + " force a redelivery");
1:                 }
1:                 // new blood
1:                 count.set(0);
1:                 gotMessage.countDown();
1:             }
1:         });
1:             
1:         assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));
1:         
0:         for (int i=0; i<maxDeliveries; i++) {
1:             assertEquals("got first redelivered: " + i, "1", received.get(i));
1:         }
0:         for (int i=maxDeliveries; i<maxDeliveries*2; i++) {
1:             assertEquals("got first redelivered: " + i, "2", received.get(i));
1:         }
1:         session.close();
1:     }
1:         
1: 
0:     public void testQueueSessionListenerExceptionDlq() throws  Exception {
1:         connection.start();
1:             
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Queue queue = session.createQueue("queue-" + getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         Message message = createTextMessage(session);
1:         producer.send(message);
1: 
1:         ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
1:         MessageConsumer dlqConsumer = session.createConsumer(dlqDestination);
1:         final CountDownLatch gotDlqMessage = new CountDownLatch(1);
1:         dlqConsumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 gotDlqMessage.countDown();
1:             }
1:         });
1: 
1:         MessageConsumer consumer = session.createConsumer(queue);
1:             
1:         final int maxDeliveries = getRedeliveryPolicy().getMaximumRedeliveries();
1:         final CountDownLatch gotMessage = new CountDownLatch(maxDeliveries);
1:         
1:         consumer.setMessageListener(new MessageListener() {
1:             public void onMessage(Message message) {
1:                 LOG.info("Message Received: " + message);
1:                 gotMessage.countDown();
0:                 throw new RuntimeException(getName() + " force a redelivery");
1:             }
1:         });
1:             
1:         assertTrue("got message before retry expiry", gotMessage.await(20, TimeUnit.SECONDS));
1:         
1:         // check DLQ
1:         assertTrue("got dlq message", gotDlqMessage.await(20, TimeUnit.SECONDS));
1:         
1:         session.close();
1:     }
1:     
1: 
1:     private TextMessage createTextMessage(Session session, String text) throws JMSException {
1:         return session.createTextMessage(text);
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:0826fdc
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         private final Session session;
1:         @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:             @Override
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("DLQ'd message cause reported as: {}", cause);
1:         assertTrue("cause exception is remembered", cause.contains("Throwable"));
1: 
commit:ef24cc9
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(MessageListenerRedeliveryTest.class);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(MessageListenerRedeliveryTest.class);
/////////////////////////////////////////////////////////////////////////
0:         private Session session;
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Message Received: " + message);
1:                     LOG.info("Message Rollback.");
1:                     LOG.info("Message Commit.");
1:                 LOG.error("Error when rolling back transaction");
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         redeliveryPolicy.setBackOffMultiplier((short)2);
/////////////////////////////////////////////////////////////////////////
1:         public int counter;
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer)consumer;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // first try.. should get 2 since there is no delay on the
/////////////////////////////////////////////////////////////////////////
1:         // 3rd redeliver (redelivery after 2 seconds) - it should give up after
1:         // that
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer)consumer;
/////////////////////////////////////////////////////////////////////////
1:         // first try
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: }
commit:da5139c
/////////////////////////////////////////////////////////////////////////
1:         redeliveryPolicy.setMaximumRedeliveries(3);
/////////////////////////////////////////////////////////////////////////
1:                 if (counter <= 4) {
/////////////////////////////////////////////////////////////////////////
1:         
0:         // first try.. should get 2 since there is no delay on the 
1:         // first redeliver..
1:         assertEquals(2, listener.counter);
1:         // 2nd redeliver (redelivery after 1 sec)
1:         assertEquals(3, listener.counter);
0:         // 3rd redeliver (redelivery after 2 seconds) - it should give up after that
1:         assertEquals(4, listener.counter);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(5, listener.counter);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(5, listener.counter);
/////////////////////////////////////////////////////////////////////////
0:         // first try 
1:         assertEquals(2, listener.counter);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(3, listener.counter);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(4, listener.counter);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(5, listener.counter);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(5, listener.counter);
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f25e2ca
/////////////////////////////////////////////////////////////////////////
0:     private Log log = LogFactory.getLog(getClass());
1: 
/////////////////////////////////////////////////////////////////////////
0:         redeliveryPolicy.setMaximumRedeliveries(2);
0:         redeliveryPolicy.setBackOffMultiplier((short) 2);
/////////////////////////////////////////////////////////////////////////
1:     private class TestMessageListener implements MessageListener {
1: 
1:         public TestMessageListener(Session session) {
0:                 log.info("Message Received: " + message);
0:                 if (counter <= 3) {
0:                     log.info("Message Rollback.");
0:                     log.info("Message Commit.");
0:                 log.error("Error when rolling back transaction");
1:     public void testQueueRollbackConsumerListener() throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:         TestMessageListener listener = new TestMessageListener(session);
1:             Thread.sleep(500);
0:         // first try
0:         assertEquals(1, listener.counter);
1:         try {
1:             Thread.sleep(1000);
1:         } catch (InterruptedException e) {
1: 
1:         }
1:         // second try (redelivery after 1 sec)
0:         assertEquals(2, listener.counter);
1: 
1:         }
1:         // third try (redelivery after 2 seconds) - it should give up after that
0:         assertEquals(3, listener.counter);
1: 
1:         // create new message
1:         producer.send(createTextMessage(session));
1:         session.commit();
1: 
1:         try {
1:             Thread.sleep(500);
1:         } catch (InterruptedException e) {
1:         // it should be committed, so no redelivery
0:         assertEquals(4, listener.counter);
1: 
1:         try {
1:             Thread.sleep(1500);
1:         } catch (InterruptedException e) {
1:             // ignore
1:         }
1:         // no redelivery, counter should still be 4
0:         assertEquals(4, listener.counter);
1: 
1:         session.close();
1:     }
1: 
1:     public void testQueueRollbackSessionListener() throws JMSException {
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
0:         Queue queue = session.createQueue("queue-" + getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         Message message = createTextMessage(session);
1:         producer.send(message);
1:         session.commit();
1: 
1:         MessageConsumer consumer = session.createConsumer(queue);
1: 
0:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer) consumer;
1:         mc.setRedeliveryPolicy(getRedeliveryPolicy());
1: 
1:         TestMessageListener listener = new TestMessageListener(session);
1:         consumer.setMessageListener(listener);
1: 
1:         try {
1:             Thread.sleep(500);
1:         } catch (InterruptedException e) {
1: 
1:         }
0:         // first try
0:         assertEquals(1, listener.counter);
1: 
1:         try {
1:             Thread.sleep(1000);
1:         } catch (InterruptedException e) {
1: 
1:         }
1:         // second try (redelivery after 1 sec)
0:         assertEquals(2, listener.counter);
1: 
1:         try {
1:             Thread.sleep(2000);
1:         } catch (InterruptedException e) {
1: 
1:         }
1:         // third try (redelivery after 2 seconds) - it should give up after that
1:         // create new message
1:         producer.send(createTextMessage(session));
1:         session.commit();
1: 
1:         try {
1:             Thread.sleep(500);
1:         } catch (InterruptedException e) {
1:             // ignore
1:         }
1:         // it should be committed, so no redelivery
0:         assertEquals(4, listener.counter);
1: 
1:         try {
1:             Thread.sleep(1500);
1:         } catch (InterruptedException e) {
1:             // ignore
1:         }
1:         // no redelivery, counter should still be 4
0:         assertEquals(4, listener.counter);
1: 
commit:03de4c2
/////////////////////////////////////////////////////////////////////////
0: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
0: import junit.framework.TestCase;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: public class MessageListenerRedeliveryTest extends TestCase {
1: 
0:     private static final Log log = LogFactory.getLog(MessageListenerRedeliveryTest.class);
1:     private Connection connection;
1: 
0:     protected void setUp() throws Exception {
1:         connection = createConnection();
1:     }
1: 
0:     /**
0:      * @see junit.framework.TestCase#tearDown()
1:      */
0:     protected void tearDown() throws Exception {
1:         if (connection != null) {
1:             connection.close();
1:             connection = null;
1:         }
1:     }
1: 
1:     protected RedeliveryPolicy getRedeliveryPolicy() {
1:         RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
0:         redeliveryPolicy.setInitialRedeliveryDelay(1000);
0:         redeliveryPolicy.setBackOffMultiplier((short) 5);
0:         redeliveryPolicy.setMaximumRedeliveries(10);
1:         redeliveryPolicy.setUseExponentialBackOff(true);
1:         return redeliveryPolicy;
1:     }
1: 
1:     protected Connection createConnection() throws Exception {
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("vm://localhost?broker.persistent=false");
1:         factory.setRedeliveryPolicy(getRedeliveryPolicy());
1:         return factory.createConnection();
1:     }
1: 
0:     private class ConsumerMessageListenerTest implements MessageListener {
0:         private ActiveMQMessageConsumer consumer;
0:         public int counter = 0;
1: 
0:         public ConsumerMessageListenerTest(ActiveMQMessageConsumer consumer) {
0:             this.consumer = consumer;
1:         }
1: 
1:         public void onMessage(Message message) {
1:             try {
0:                 log.info("Message: " + message);
1:                 counter++;
0:                 if (counter <= 2) {
0:                     log.info("ROLLBACK");
0:                     consumer.rollback();
1:                 } else {
0:                     log.info("COMMIT");
1:                     message.acknowledge();
0:                     consumer.commit();
1:                 }
1:             } catch (JMSException e) {
0:                 System.err.println("Error when rolling back transaction");
1:             }
1:         }
1:     }
1: 
0:     private class SessionMessageListenerTest implements MessageListener {
0:         private Session session;
0:         public int counter = 0;
1: 
0:         public SessionMessageListenerTest(Session session) {
1:             this.session = session;
1:         }
1: 
1:         public void onMessage(Message message) {
1:             try {
0:                 log.info("Message: " + message);
1:                 counter++;
0:                 if (counter < 2) {
0:                     log.info("ROLLBACK");
1:                     session.rollback();
1:                 } else {
0:                     log.info("COMMIT");
1:                     message.acknowledge();
1:                     session.commit();
1:                 }
1:             } catch (JMSException e) {
0:                 System.err.println("Error when rolling back transaction");
1:             }
1:         }
1:     }
1: 
0:     public void testQueueRollbackMessageListener() throws JMSException {
1:         connection.start();
1: 
1:         Session session = connection.createSession(true, Session.CLIENT_ACKNOWLEDGE);
0:         Queue queue = session.createQueue("queue-" + getName());
1:         MessageProducer producer = createProducer(session, queue);
1:         Message message = createTextMessage(session);
1:         producer.send(message);
1:         session.commit();
1: 
1:         MessageConsumer consumer = session.createConsumer(queue);
1: 
0:         ActiveMQMessageConsumer mc = (ActiveMQMessageConsumer) consumer;
1:         mc.setRedeliveryPolicy(getRedeliveryPolicy());
1: 
0:         SessionMessageListenerTest listener = new SessionMessageListenerTest(session);
1:         consumer.setMessageListener(listener);
1: 
1:         try {
0:             Thread.sleep(7000);
1:         } catch (InterruptedException e) {
1: 
1:         }
0:         assertEquals(2, listener.counter);
1: 
0:         producer.send(createTextMessage(session));
1:         session.commit();
1: 
1:         try {
1:             Thread.sleep(2000);
1:         } catch (InterruptedException e) {
0:             // ignore
1:         }
0:         assertEquals(3, listener.counter);
1: 
1:         session.close();
1:     }
1: 
1:     private TextMessage createTextMessage(Session session) throws JMSException {
1:         return session.createTextMessage("Hello");
1:     }
1: 
1:     private MessageProducer createProducer(Session session, Destination queue) throws JMSException {
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(getDeliveryMode());
1:         return producer;
1:     }
1: 
1:     protected int getDeliveryMode() {
1:         return DeliveryMode.PERSISTENT;
1:     }
1: }
============================================================================