1:16c487a: /*
1:72839b7:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:72839b7:  * contributor license agreements.  See the NOTICE file distributed with
1:72839b7:  * this work for additional information regarding copyright ownership.
1:72839b7:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:72839b7:  * (the "License"); you may not use this file except in compliance with
1:72839b7:  * the License.  You may obtain a copy of the License at
4:72839b7:  *
1:72839b7:  *      http://www.apache.org/licenses/LICENSE-2.0
1:72839b7:  *
1:72839b7:  * Unless required by applicable law or agreed to in writing, software
1:72839b7:  * distributed under the License is distributed on an "AS IS" BASIS,
1:72839b7:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:72839b7:  * See the License for the specific language governing permissions and
1:72839b7:  * limitations under the License.
3:72839b7:  */
1:72839b7: package org.apache.activemq.transport.amqp.client;
3:72839b7: 
1:f56ea45: import java.util.HashMap;
1:f56ea45: import java.util.Map;
1:13b915a: import java.util.NoSuchElementException;
1:f56ea45: 
1:fddbac2: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
1:72839b7: import org.apache.qpid.proton.Proton;
1:7c41ebc: import org.apache.qpid.proton.amqp.Binary;
1:13b915a: import org.apache.qpid.proton.amqp.DescribedType;
1:f56ea45: import org.apache.qpid.proton.amqp.Symbol;
1:72839b7: import org.apache.qpid.proton.amqp.messaging.AmqpValue;
1:f56ea45: import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
1:7c41ebc: import org.apache.qpid.proton.amqp.messaging.Data;
1:f05ff94: import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;
1:11da37b: import org.apache.qpid.proton.amqp.messaging.Header;
1:f56ea45: import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;
1:f56ea45: import org.apache.qpid.proton.amqp.messaging.Properties;
1:72839b7: import org.apache.qpid.proton.engine.Delivery;
1:72839b7: import org.apache.qpid.proton.message.Message;
1:72839b7: 
1:72839b7: public class AmqpMessage {
1:72839b7: 
1:72839b7:     private final AmqpReceiver receiver;
1:72839b7:     private final Message message;
1:72839b7:     private final Delivery delivery;
1:72839b7: 
1:f05ff94:     private Map<Symbol, Object> deliveryAnnotationsMap;
1:f56ea45:     private Map<Symbol, Object> messageAnnotationsMap;
1:f56ea45:     private Map<String, Object> applicationPropertiesMap;
1:f56ea45: 
4:72839b7:     /**
1:72839b7:      * Creates a new AmqpMessage that wraps the information necessary to handle
1:72839b7:      * an outgoing message.
1:72839b7:      */
1:72839b7:     public AmqpMessage() {
1:72839b7:         receiver = null;
1:72839b7:         delivery = null;
1:72839b7: 
1:72839b7:         message = Proton.message();
3:72839b7:     }
1:72839b7: 
1:7c41ebc:     /**
1:72839b7:      * Creates a new AmqpMessage that wraps the information necessary to handle
1:72839b7:      * an outgoing message.
1:72839b7:      *
1:72839b7:      * @param message
1:72839b7:      *        the Proton message that is to be sent.
1:72839b7:      */
1:72839b7:     public AmqpMessage(Message message) {
1:72839b7:         this(null, message, null);
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Creates a new AmqpMessage that wraps the information necessary to handle
1:72839b7:      * an incoming delivery.
1:72839b7:      *
1:72839b7:      * @param receiver
1:72839b7:      *        the AmqpReceiver that received this message.
1:72839b7:      * @param message
1:72839b7:      *        the Proton message that was received.
1:72839b7:      * @param delivery
1:72839b7:      *        the Delivery instance that produced this message.
1:72839b7:      */
1:f56ea45:     @SuppressWarnings("unchecked")
1:72839b7:     public AmqpMessage(AmqpReceiver receiver, Message message, Delivery delivery) {
1:72839b7:         this.receiver = receiver;
1:72839b7:         this.message = message;
1:72839b7:         this.delivery = delivery;
1:f56ea45: 
1:f56ea45:         if (message.getMessageAnnotations() != null) {
1:f56ea45:             messageAnnotationsMap = message.getMessageAnnotations().getValue();
1:f56ea45:         }
1:f56ea45: 
1:f56ea45:         if (message.getApplicationProperties() != null) {
1:f56ea45:             applicationPropertiesMap = message.getApplicationProperties().getValue();
1:f56ea45:         }
1:f05ff94: 
1:f05ff94:         if (message.getDeliveryAnnotations() != null) {
1:f05ff94:             deliveryAnnotationsMap = message.getDeliveryAnnotations().getValue();
1:f05ff94:         }
1:72839b7:     }
1:72839b7: 
1:f56ea45:     //----- Access to interal client resources -------------------------------//
1:f56ea45: 
1:f56ea45:     /**
1:f56ea45:      * @return the AMQP Delivery object linked to a received message.
1:f56ea45:      */
1:f56ea45:     public Delivery getWrappedDelivery() {
1:f56ea45:         if (delivery != null) {
1:fddbac2:             return UnmodifiableProxy.deliveryProxy(delivery);
1:f56ea45:         }
1:f56ea45: 
1:f56ea45:         return null;
1:f56ea45:     }
1:f56ea45: 
1:f56ea45:     /**
1:f56ea45:      * @return the AMQP Message that is wrapped by this object.
1:f56ea45:      */
1:f56ea45:     public Message getWrappedMessage() {
1:f56ea45:         return message;
1:f56ea45:     }
1:f56ea45: 
1:f56ea45:     /**
1:f56ea45:      * @return the AmqpReceiver that consumed this message.
1:f56ea45:      */
1:f56ea45:     public AmqpReceiver getAmqpReceiver() {
1:f56ea45:         return receiver;
1:f56ea45:     }
1:f56ea45: 
1:f56ea45:     //----- Message disposition control --------------------------------------//
1:f56ea45: 
1:72839b7:     /**
1:b4ab0e1:      * Accepts the message marking it as consumed on the remote peer.
1:b4ab0e1:      *
1:72839b7:      * @throws Exception if an error occurs during the accept.
1:72839b7:      */
1:72839b7:     public void accept() throws Exception {
1:5d53aa2:         accept(true);
1:5d53aa2:     }
1:5d53aa2: 
1:5d53aa2:     /**
1:5d53aa2:      * Accepts the message marking it as consumed on the remote peer.
1:5d53aa2:      *
1:5d53aa2:      * @param settle
1:5d53aa2:      *      true if the client should also settle the delivery when sending the accept.
1:5d53aa2:      *
1:5d53aa2:      * @throws Exception if an error occurs during the accept.
1:5d53aa2:      */
1:5d53aa2:     public void accept(boolean settle) throws Exception {
1:72839b7:         if (receiver == null) {
1:72839b7:             throw new IllegalStateException("Can't accept non-received message.");
1:72839b7:         }
1:72839b7: 
1:5d53aa2:         receiver.accept(delivery, settle);
1:5d53aa2:     }
1:5d53aa2: 
1:5d53aa2:     /**
1:5d53aa2:      * Accepts the message marking it as consumed on the remote peer.  This method
1:5d53aa2:      * will automatically settle the accepted delivery.
1:5d53aa2:      *
1:5d53aa2:      * @param session
1:5d53aa2:      *      The session that is used to manage acceptance of the message.
1:5d53aa2:      *
1:5d53aa2:      * @throws Exception if an error occurs during the accept.
1:5d53aa2:      */
1:5d53aa2:     public void accept(AmqpSession txnSession) throws Exception {
1:5d53aa2:         accept(txnSession, true);
1:b4ab0e1:     }
1:b4ab0e1: 
1:b4ab0e1:     /**
1:72839b7:      * Accepts the message marking it as consumed on the remote peer.
1:b4ab0e1:      *
1:b4ab0e1:      * @param session
1:b4ab0e1:      *      The session that is used to manage acceptance of the message.
1:72839b7:      *
1:b4ab0e1:      * @throws Exception if an error occurs during the accept.
1:b4ab0e1:      */
1:5d53aa2:     public void accept(AmqpSession txnSession, boolean settle) throws Exception {
1:b4ab0e1:         if (receiver == null) {
1:b4ab0e1:             throw new IllegalStateException("Can't accept non-received message.");
1:b4ab0e1:         }
1:b4ab0e1: 
1:5d53aa2:         receiver.accept(delivery, txnSession, settle);
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:0cfd225:      * Marks the message as Modified, indicating whether it failed to deliver and is not deliverable here.
1:72839b7:      *
1:72839b7:      * @param deliveryFailed
1:72839b7:      *        indicates that the delivery failed for some reason.
2:72839b7:      * @param undeliverableHere
2:72839b7:      *        marks the delivery as not being able to be process by link it was sent to.
1:72839b7:      *
1:0cfd225:      * @throws Exception if an error occurs during the process.
1:72839b7:      */
1:0cfd225:     public void modified(Boolean deliveryFailed, Boolean undeliverableHere) throws Exception {
1:72839b7:         if (receiver == null) {
1:0cfd225:             throw new IllegalStateException("Can't modify non-received message.");
1:72839b7:         }
1:72839b7: 
1:0cfd225:         receiver.modified(delivery, deliveryFailed, undeliverableHere);
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:72839b7:      * Release the message, remote can redeliver it elsewhere.
1:72839b7:      *
1:f71e0ee:      * @throws Exception if an error occurs during the release.
1:72839b7:      */
1:72839b7:     public void release() throws Exception {
1:72839b7:         if (receiver == null) {
1:72839b7:             throw new IllegalStateException("Can't release non-received message.");
1:72839b7:         }
1:72839b7: 
1:72839b7:         receiver.release(delivery);
1:72839b7:     }
1:72839b7: 
1:f71e0ee:     /**
1:f71e0ee:      * Reject the message, remote can redeliver it elsewhere.
1:f71e0ee:      *
1:f71e0ee:      * @throws Exception if an error occurs during the reject.
1:f71e0ee:      */
1:f71e0ee:     public void reject() throws Exception {
1:f71e0ee:         if (receiver == null) {
1:f71e0ee:             throw new IllegalStateException("Can't release non-received message.");
1:f71e0ee:         }
1:f71e0ee: 
1:f71e0ee:         receiver.reject(delivery);
1:f71e0ee:     }
1:f71e0ee: 
1:f56ea45:     //----- Convenience methods for constructing outbound messages -----------//
1:f56ea45: 
1:72839b7:     /**
1:0050f22:      * Sets the address which is applied to the AMQP message To field in the message properties
1:0050f22:      *
1:0050f22:      * @param address
1:0050f22:      *      The address that should be applied in the Message To field.
1:0050f22:      */
1:0050f22:     public void setAddress(String address) {
1:0050f22:         checkReadOnly();
1:0050f22:         lazyCreateProperties();
1:0050f22:         getWrappedMessage().setAddress(address);
1:0050f22:     }
1:0050f22: 
1:0050f22:     /**
1:0050f22:      * Return the set address that was set in the Message To field.
1:0050f22:      *
1:0050f22:      * @return the set address String form or null if not set.
1:0050f22:      */
1:0050f22:     public String getAddress() {
1:0050f22:         if (message.getProperties() == null) {
1:0050f22:             return null;
1:0050f22:         }
1:0050f22: 
1:0050f22:         return message.getProperties().getTo();
1:0050f22:     }
1:0050f22: 
1:0050f22:     /**
1:1316b57:      * Sets the address which is applied to the AMQP message ReplyTo field in the message properties
1:1316b57:      *
1:1316b57:      * @param replyTo
1:1316b57:      *      The address that should be applied in the Message ReplyTo field.
1:1316b57:      */
1:1316b57:     public void setReplyTo(String replyTo) {
1:1316b57:         checkReadOnly();
1:1316b57:         lazyCreateProperties();
1:1316b57:         getWrappedMessage().setReplyTo(replyTo);
1:1316b57:     }
1:1316b57: 
1:1316b57:     /**
1:1316b57:      * Return the set address that was set in the Message ReplyTo field.
1:1316b57:      *
1:1316b57:      * @return the set address String form or null if not set.
1:1316b57:      */
1:1316b57:     public String getReplyTo() {
1:1316b57:         if (message.getProperties() == null) {
1:1316b57:             return null;
1:1316b57:         }
1:1316b57: 
1:1316b57:         return message.getProperties().getReplyTo();
1:1316b57:     }
1:1316b57: 
1:1316b57:     /**
1:f56ea45:      * Sets the MessageId property on an outbound message using the provided String
1:f56ea45:      *
1:f56ea45:      * @param messageId
1:f56ea45:      *        the String message ID value to set.
1:72839b7:      */
1:f56ea45:     public void setMessageId(String messageId) {
1:f56ea45:         checkReadOnly();
1:f56ea45:         lazyCreateProperties();
1:f56ea45:         getWrappedMessage().setMessageId(messageId);
1:f56ea45:     }
1:f56ea45: 
1:f56ea45:     /**
1:f56ea45:      * Return the set MessageId value in String form, if there are no properties
1:f56ea45:      * in the given message return null.
1:f56ea45:      *
1:f56ea45:      * @return the set message ID in String form or null if not set.
1:f56ea45:      */
1:f56ea45:     public String getMessageId() {
1:63d62a7:         if (message.getProperties() == null || message.getProperties().getMessageId() == null) {
1:f56ea45:             return null;
1:72839b7:         }
1:72839b7: 
1:f56ea45:         return message.getProperties().getMessageId().toString();
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:4d6f4d7:      * Return the set MessageId value in the original form, if there are no properties
1:4d6f4d7:      * in the given message return null.
1:4d6f4d7:      *
1:4d6f4d7:      * @return the set message ID in its original form or null if not set.
1:4d6f4d7:      */
1:4d6f4d7:     public Object getRawMessageId() {
1:16c487a:         if (message.getProperties() == null) {
1:4d6f4d7:             return null;
1:4d6f4d7:         }
1:4d6f4d7: 
1:4d6f4d7:         return message.getProperties().getMessageId();
1:4d6f4d7:     }
1:4d6f4d7: 
1:4d6f4d7:     /**
1:4d6f4d7:      * Sets the MessageId property on an outbound message using the provided value
1:4d6f4d7:      *
1:4d6f4d7:      * @param messageId
1:4d6f4d7:      *        the message ID value to set.
1:4d6f4d7:      */
1:4d6f4d7:     public void setRawMessageId(Object messageId) {
1:4d6f4d7:         checkReadOnly();
1:4d6f4d7:         lazyCreateProperties();
1:4d6f4d7:         getWrappedMessage().setMessageId(messageId);
1:4d6f4d7:     }
1:4d6f4d7: 
1:4d6f4d7:     /**
1:16c487a:      * Sets the CorrelationId property on an outbound message using the provided String
1:16c487a:      *
1:16c487a:      * @param correlationId
1:16c487a:      *        the String Correlation ID value to set.
1:16c487a:      */
1:16c487a:     public void setCorrelationId(String correlationId) {
1:16c487a:         checkReadOnly();
1:16c487a:         lazyCreateProperties();
1:16c487a:         getWrappedMessage().setCorrelationId(correlationId);
1:16c487a:     }
1:16c487a: 
1:16c487a:     /**
1:16c487a:      * Return the set CorrelationId value in String form, if there are no properties
1:16c487a:      * in the given message return null.
1:16c487a:      *
1:16c487a:      * @return the set correlation ID in String form or null if not set.
1:16c487a:      */
1:16c487a:     public String getCorrelationId() {
1:63d62a7:         if (message.getProperties() == null || message.getProperties().getCorrelationId() == null) {
1:16c487a:             return null;
1:16c487a:         }
1:16c487a: 
1:16c487a:         return message.getProperties().getCorrelationId().toString();
1:16c487a:     }
1:16c487a: 
1:16c487a:     /**
1:16c487a:      * Return the set CorrelationId value in the original form, if there are no properties
1:16c487a:      * in the given message return null.
1:16c487a:      *
1:16c487a:      * @return the set message ID in its original form or null if not set.
1:16c487a:      */
1:16c487a:     public Object getRawCorrelationId() {
1:16c487a:         if (message.getProperties() == null) {
1:16c487a:             return null;
1:16c487a:         }
1:16c487a: 
1:16c487a:         return message.getProperties().getCorrelationId();
1:16c487a:     }
1:16c487a: 
1:16c487a:     /**
1:16c487a:      * Sets the CorrelationId property on an outbound message using the provided value
1:16c487a:      *
1:16c487a:      * @param correlationId
1:16c487a:      *        the correlation ID value to set.
1:16c487a:      */
1:16c487a:     public void setRawCorrelationId(Object correlationId) {
1:16c487a:         checkReadOnly();
1:16c487a:         lazyCreateProperties();
1:16c487a:         getWrappedMessage().setCorrelationId(correlationId);
1:16c487a:     }
1:16c487a: 
1:16c487a:     /**
1:351d4b9:      * Sets the GroupId property on an outbound message using the provided String
1:351d4b9:      *
1:351d4b9:      * @param messageId
1:351d4b9:      *        the String Group ID value to set.
1:351d4b9:      */
1:351d4b9:     public void setGroupId(String groupId) {
1:351d4b9:         checkReadOnly();
1:351d4b9:         lazyCreateProperties();
1:351d4b9:         getWrappedMessage().setGroupId(groupId);
1:351d4b9:     }
1:351d4b9: 
1:351d4b9:     /**
1:351d4b9:      * Return the set GroupId value in String form, if there are no properties
1:351d4b9:      * in the given message return null.
1:351d4b9:      *
1:351d4b9:      * @return the set GroupID in String form or null if not set.
1:351d4b9:      */
1:351d4b9:     public String getGroupId() {
1:4d6f4d7:         if (message.getProperties() == null) {
1:351d4b9:             return null;
1:351d4b9:         }
1:351d4b9: 
1:351d4b9:         return message.getProperties().getGroupId();
1:351d4b9:     }
1:351d4b9: 
1:351d4b9:     /**
1:11da37b:      * Sets the durable header on the outgoing message.
1:11da37b:      *
1:11da37b:      * @param durable
1:11da37b:      *        the boolean durable value to set.
1:11da37b:      */
1:11da37b:     public void setDurable(boolean durable) {
1:11da37b:         checkReadOnly();
1:11da37b:         lazyCreateHeader();
1:11da37b:         getWrappedMessage().setDurable(durable);
1:11da37b:     }
1:11da37b: 
1:11da37b:     /**
1:11da37b:      * Checks the durable value in the Message Headers to determine if
1:11da37b:      * the message was sent as a durable Message.
1:11da37b:      *
1:11da37b:      * @return true if the message is marked as being durable.
1:11da37b:      */
1:11da37b:     public boolean isDurable() {
1:63d62a7:         if (message.getHeader() == null || message.getHeader().getDurable() == null) {
1:11da37b:             return false;
1:11da37b:         }
1:11da37b: 
1:11da37b:         return message.getHeader().getDurable();
1:11da37b:     }
1:11da37b: 
1:11da37b:     /**
1:0752d84:      * Sets the priority header on the outgoing message.
1:0752d84:      *
1:0752d84:      * @param priority the priority value to set.
1:0752d84:      */
1:0752d84:     public void setPriority(short priority) {
1:0752d84:        checkReadOnly();
1:0752d84:        lazyCreateHeader();
1:0752d84:        getWrappedMessage().setPriority(priority);
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:0752d84:      * Gets the priority header on the message.
1:0752d84:      */
1:0752d84:     public short getPriority() {
1:0752d84:        return getWrappedMessage().getPriority();
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:0752d84:      * Sets the ttl header on the outgoing message.
1:0752d84:      *
1:0752d84:      * @param timeToLive the ttl value to set.
1:0752d84:      */
1:0752d84:     public void setTimeToLive(long timeToLive) {
1:0752d84:        checkReadOnly();
1:0752d84:        lazyCreateHeader();
1:0752d84:        getWrappedMessage().setTtl(timeToLive);
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:0752d84:      * Sets the ttl header on the outgoing message.
1:0752d84:      */
1:0752d84:     public long getTimeToLive() {
1:0752d84:        return getWrappedMessage().getTtl();
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:0752d84:      * Sets the absolute expiration time property on the message.
1:0752d84:      *
1:0752d84:      * @param absoluteExpiryTime the expiration time value to set.
1:0752d84:      */
1:0752d84:     public void setAbsoluteExpiryTime(long absoluteExpiryTime) {
1:0752d84:        checkReadOnly();
1:0752d84:        lazyCreateProperties();
1:0752d84:        getWrappedMessage().setExpiryTime(absoluteExpiryTime);
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:0752d84:      * Gets the absolute expiration time property on the message.
1:0752d84:      */
1:0752d84:     public long getAbsoluteExpiryTime() {
1:0752d84:        return getWrappedMessage().getExpiryTime();
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:0752d84:      * Sets the creation time property on the message.
1:0752d84:      *
1:0752d84:      * @param creationTime the time value to set.
1:0752d84:      */
1:0752d84:     public void setCreationTime(long creationTime) {
1:0752d84:        checkReadOnly();
1:0752d84:        lazyCreateProperties();
1:0752d84:        getWrappedMessage().setCreationTime(creationTime);
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:0752d84:      * Gets the absolute expiration time property on the message.
1:0752d84:      */
1:0752d84:     public long getCreationTime() {
1:0752d84:        return getWrappedMessage().getCreationTime();
1:0752d84:     }
1:0752d84: 
1:0752d84:     /**
1:f56ea45:      * Sets a given application property on an outbound message.
1:f56ea45:      *
1:f56ea45:      * @param key
1:f56ea45:      *        the name to assign the new property.
1:f56ea45:      * @param value
1:f56ea45:      *        the value to set for the named property.
1:72839b7:      */
1:f56ea45:     public void setApplicationProperty(String key, Object value) {
1:f56ea45:         checkReadOnly();
1:f56ea45:         lazyCreateApplicationProperties();
1:f56ea45:         applicationPropertiesMap.put(key, value);
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:f56ea45:      * Gets the application property that is mapped to the given name or null
1:f56ea45:      * if no property has been set with that name.
1:f56ea45:      *
1:f56ea45:      * @param key
1:f56ea45:      *        the name used to lookup the property in the application properties.
1:f56ea45:      *
1:b4ab0e1:      * @return the property value or null if not set.
1:72839b7:      */
1:f56ea45:     public Object getApplicationProperty(String key) {
1:f56ea45:         if (applicationPropertiesMap == null) {
1:f56ea45:             return null;
1:f56ea45:         }
1:f56ea45: 
1:f56ea45:         return applicationPropertiesMap.get(key);
1:f56ea45:     }
1:f56ea45: 
1:f56ea45:     /**
1:f56ea45:      * Perform a proper annotation set on the AMQP Message based on a Symbol key and
1:f56ea45:      * the target value to append to the current annotations.
1:f56ea45:      *
1:f56ea45:      * @param key
1:f56ea45:      *        The name of the Symbol whose value is being set.
1:f56ea45:      * @param value
1:f56ea45:      *        The new value to set in the annotations of this message.
1:f56ea45:      */
1:f56ea45:     public void setMessageAnnotation(String key, Object value) {
1:f56ea45:         checkReadOnly();
1:f56ea45:         lazyCreateMessageAnnotations();
1:f56ea45:         messageAnnotationsMap.put(Symbol.valueOf(key), value);
1:f56ea45:     }
1:f56ea45: 
1:f56ea45:     /**
1:f56ea45:      * Given a message annotation name, lookup and return the value associated with
1:f56ea45:      * that annotation name.  If the message annotations have not been created yet
1:f56ea45:      * then this method will always return null.
1:f56ea45:      *
1:f56ea45:      * @param key
1:f56ea45:      *        the Symbol name that should be looked up in the message annotations.
1:f56ea45:      *
1:f56ea45:      * @return the value of the annotation if it exists, or null if not set or not accessible.
1:f56ea45:      */
1:f56ea45:     public Object getMessageAnnotation(String key) {
1:f56ea45:         if (messageAnnotationsMap == null) {
1:f56ea45:             return null;
1:f56ea45:         }
1:f56ea45: 
1:f56ea45:         return messageAnnotationsMap.get(Symbol.valueOf(key));
1:72839b7:     }
1:72839b7: 
1:72839b7:     /**
1:f05ff94:      * Perform a proper delivery annotation set on the AMQP Message based on a Symbol
1:f05ff94:      * key and the target value to append to the current delivery annotations.
1:f05ff94:      *
1:f05ff94:      * @param key
1:f05ff94:      *        The name of the Symbol whose value is being set.
1:f05ff94:      * @param value
1:f05ff94:      *        The new value to set in the delivery annotations of this message.
1:f05ff94:      */
1:f05ff94:     public void setDeliveryAnnotation(String key, Object value) {
1:f05ff94:         checkReadOnly();
1:f05ff94:         lazyCreateDeliveryAnnotations();
1:f05ff94:         deliveryAnnotationsMap.put(Symbol.valueOf(key), value);
1:f05ff94:     }
1:f05ff94: 
1:f05ff94:     /**
1:f05ff94:      * Given a message annotation name, lookup and return the value associated with
1:f05ff94:      * that annotation name.  If the message annotations have not been created yet
1:f05ff94:      * then this method will always return null.
1:f05ff94:      *
1:f05ff94:      * @param key
1:f05ff94:      *        the Symbol name that should be looked up in the message annotations.
1:f05ff94:      *
1:f05ff94:      * @return the value of the annotation if it exists, or null if not set or not accessible.
1:f05ff94:      */
1:f05ff94:     public Object getDeliveryAnnotation(String key) {
1:f05ff94:         if (deliveryAnnotationsMap == null) {
1:f05ff94:             return null;
1:f05ff94:         }
1:f05ff94: 
1:f05ff94:         return deliveryAnnotationsMap.get(Symbol.valueOf(key));
1:f05ff94:     }
1:f05ff94: 
1:13b915a:     //----- Methods for manipulating the Message body ------------------------//
1:13b915a: 
1:f05ff94:     /**
1:72839b7:      * Sets a String value into the body of an outgoing Message, throws
1:7c41ebc:      * an exception if this is an incoming message instance.
1:7c41ebc:      *
1:7c41ebc:      * @param value
1:72839b7:      *        the String value to store in the Message body.
1:72839b7:      *
1:72839b7:      * @throws IllegalStateException if the message is read only.
1:72839b7:      */
1:72839b7:     public void setText(String value) throws IllegalStateException {
1:f56ea45:         checkReadOnly();
1:f56ea45:         AmqpValue body = new AmqpValue(value);
1:f56ea45:         getWrappedMessage().setBody(body);
1:f56ea45:     }
1:f56ea45: 
1:13b915a:     /**
1:13b915a:      * Sets a byte array value into the body of an outgoing Message, throws
1:13b915a:      * an exception if this is an incoming message instance.
1:13b915a:      *
1:13b915a:      * @param value
1:13b915a:      *        the byte array value to store in the Message body.
1:13b915a:      *
1:13b915a:      * @throws IllegalStateException if the message is read only.
1:13b915a:      */
1:7c41ebc:     public void setBytes(byte[] bytes) throws IllegalStateException {
1:7c41ebc:         checkReadOnly();
1:7c41ebc:         Data body = new Data(new Binary(bytes));
1:7c41ebc:         getWrappedMessage().setBody(body);
1:7c41ebc:     }
1:7c41ebc: 
1:72839b7:     /**
1:7c41ebc:      * Sets a byte array value into the body of an outgoing Message, throws
1:72839b7:      * an exception if this is an incoming message instance.
1:7c41ebc:      *
1:72839b7:      * @param value
1:7c41ebc:      *        the byte array value to store in the Message body.
1:72839b7:      *
1:7c41ebc:      * @throws IllegalStateException if the message is read only.
1:7c41ebc:      */
1:13b915a:     public void setDescribedType(DescribedType described) throws IllegalStateException {
1:13b915a:         checkReadOnly();
1:13b915a:         AmqpValue body = new AmqpValue(described);
1:13b915a:         getWrappedMessage().setBody(body);
1:13b915a:     }
1:13b915a: 
1:13b915a:     /**
1:13b915a:      * Attempts to retrieve the message body as an DescribedType instance.
1:13b915a:      *
1:13b915a:      * @return an DescribedType instance if one is stored in the message body.
1:13b915a:      *
1:13b915a:      * @throws NoSuchElementException if the body does not contain a DescribedType.
1:13b915a:      */
1:13b915a:     public DescribedType getDescribedType() throws NoSuchElementException {
1:13b915a:         DescribedType result = null;
1:13b915a: 
1:13b915a:         if (getWrappedMessage().getBody() == null) {
1:13b915a:             return null;
1:13b915a:         } else {
1:13b915a:             if (getWrappedMessage().getBody() instanceof AmqpValue) {
1:13b915a:                 AmqpValue value = (AmqpValue) getWrappedMessage().getBody();
1:13b915a: 
1:13b915a:                 if (value.getValue() == null) {
1:13b915a:                     result = null;
1:13b915a:                 } else if (value.getValue() instanceof DescribedType) {
1:13b915a:                     result = (DescribedType) value.getValue();
1:13b915a:                 } else {
1:13b915a:                     throw new NoSuchElementException("Message does not contain a DescribedType body");
1:13b915a:                 }
1:13b915a:             }
1:13b915a:         }
1:13b915a: 
1:13b915a:         return result;
1:13b915a:     }
1:13b915a: 
1:f56ea45:     //----- Internal implementation ------------------------------------------//
1:f56ea45: 
1:f56ea45:     private void checkReadOnly() throws IllegalStateException {
2:72839b7:         if (delivery != null) {
1:72839b7:             throw new IllegalStateException("Message is read only.");
1:f56ea45:         }
1:72839b7:     }
1:72839b7: 
1:f56ea45:     private void lazyCreateMessageAnnotations() {
1:f56ea45:         if (messageAnnotationsMap == null) {
1:0752d84:             messageAnnotationsMap = new HashMap<>();
1:f56ea45:             message.setMessageAnnotations(new MessageAnnotations(messageAnnotationsMap));
1:f56ea45:         }
1:f56ea45:     }
1:f56ea45: 
1:f05ff94:     private void lazyCreateDeliveryAnnotations() {
1:f05ff94:         if (deliveryAnnotationsMap == null) {
1:0752d84:             deliveryAnnotationsMap = new HashMap<>();
1:f05ff94:             message.setDeliveryAnnotations(new DeliveryAnnotations(deliveryAnnotationsMap));
1:f05ff94:         }
1:f05ff94:     }
1:f05ff94: 
1:f56ea45:     private void lazyCreateApplicationProperties() {
1:f56ea45:         if (applicationPropertiesMap == null) {
1:0752d84:             applicationPropertiesMap = new HashMap<>();
1:f56ea45:             message.setApplicationProperties(new ApplicationProperties(applicationPropertiesMap));
1:f56ea45:         }
1:f56ea45:     }
1:f56ea45: 
1:11da37b:     private void lazyCreateHeader() {
1:11da37b:         if (message.getHeader() == null) {
1:11da37b:             message.setHeader(new Header());
1:11da37b:         }
1:11da37b:     }
1:b4ab0e1: 
1:f56ea45:     private void lazyCreateProperties() {
1:351d4b9:         if (message.getProperties() == null) {
1:f56ea45:             message.setProperties(new Properties());
1:f56ea45:         }
1:72839b7:     }
1:72839b7: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:fddbac2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.amqp.client.util.UnmodifiableProxy;
/////////////////////////////////////////////////////////////////////////
1:             return UnmodifiableProxy.deliveryProxy(delivery);
commit:0752d84
/////////////////////////////////////////////////////////////////////////
1:      * Sets the priority header on the outgoing message.
1:      *
1:      * @param priority the priority value to set.
1:      */
1:     public void setPriority(short priority) {
1:        checkReadOnly();
1:        lazyCreateHeader();
1:        getWrappedMessage().setPriority(priority);
1:     }
1: 
1:     /**
1:      * Gets the priority header on the message.
1:      */
1:     public short getPriority() {
1:        return getWrappedMessage().getPriority();
1:     }
1: 
1:     /**
1:      * Sets the ttl header on the outgoing message.
1:      *
1:      * @param timeToLive the ttl value to set.
1:      */
1:     public void setTimeToLive(long timeToLive) {
1:        checkReadOnly();
1:        lazyCreateHeader();
1:        getWrappedMessage().setTtl(timeToLive);
1:     }
1: 
1:     /**
1:      * Sets the ttl header on the outgoing message.
1:      */
1:     public long getTimeToLive() {
1:        return getWrappedMessage().getTtl();
1:     }
1: 
1:     /**
1:      * Sets the absolute expiration time property on the message.
1:      *
1:      * @param absoluteExpiryTime the expiration time value to set.
1:      */
1:     public void setAbsoluteExpiryTime(long absoluteExpiryTime) {
1:        checkReadOnly();
1:        lazyCreateProperties();
1:        getWrappedMessage().setExpiryTime(absoluteExpiryTime);
1:     }
1: 
1:     /**
1:      * Gets the absolute expiration time property on the message.
1:      */
1:     public long getAbsoluteExpiryTime() {
1:        return getWrappedMessage().getExpiryTime();
1:     }
1: 
1:     /**
1:      * Sets the creation time property on the message.
1:      *
1:      * @param creationTime the time value to set.
1:      */
1:     public void setCreationTime(long creationTime) {
1:        checkReadOnly();
1:        lazyCreateProperties();
1:        getWrappedMessage().setCreationTime(creationTime);
1:     }
1: 
1:     /**
1:      * Gets the absolute expiration time property on the message.
1:      */
1:     public long getCreationTime() {
1:        return getWrappedMessage().getCreationTime();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:             messageAnnotationsMap = new HashMap<>();
1:             deliveryAnnotationsMap = new HashMap<>();
1:             applicationPropertiesMap = new HashMap<>();
commit:f71e0ee
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception if an error occurs during the release.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reject the message, remote can redeliver it elsewhere.
1:      *
1:      * @throws Exception if an error occurs during the reject.
1:      */
1:     public void reject() throws Exception {
1:         if (receiver == null) {
1:             throw new IllegalStateException("Can't release non-received message.");
1:         }
1: 
1:         receiver.reject(delivery);
1:     }
1: 
commit:1316b57
/////////////////////////////////////////////////////////////////////////
1:      * Sets the address which is applied to the AMQP message ReplyTo field in the message properties
1:      *
1:      * @param replyTo
1:      *      The address that should be applied in the Message ReplyTo field.
1:      */
1:     public void setReplyTo(String replyTo) {
1:         checkReadOnly();
1:         lazyCreateProperties();
1:         getWrappedMessage().setReplyTo(replyTo);
1:     }
1: 
1:     /**
1:      * Return the set address that was set in the Message ReplyTo field.
1:      *
1:      * @return the set address String form or null if not set.
1:      */
1:     public String getReplyTo() {
1:         if (message.getProperties() == null) {
1:             return null;
1:         }
1: 
1:         return message.getProperties().getReplyTo();
1:     }
1: 
1:     /**
commit:63d62a7
/////////////////////////////////////////////////////////////////////////
1:         if (message.getProperties() == null || message.getProperties().getMessageId() == null) {
/////////////////////////////////////////////////////////////////////////
1:         if (message.getProperties() == null || message.getProperties().getCorrelationId() == null) {
/////////////////////////////////////////////////////////////////////////
1:         if (message.getHeader() == null || message.getHeader().getDurable() == null) {
commit:5d53aa2
/////////////////////////////////////////////////////////////////////////
1:         accept(true);
1:     }
1: 
1:     /**
1:      * Accepts the message marking it as consumed on the remote peer.
1:      *
1:      * @param settle
1:      *      true if the client should also settle the delivery when sending the accept.
1:      *
1:      * @throws Exception if an error occurs during the accept.
1:      */
1:     public void accept(boolean settle) throws Exception {
1:         receiver.accept(delivery, settle);
1:     }
1: 
1:     /**
1:      * Accepts the message marking it as consumed on the remote peer.  This method
1:      * will automatically settle the accepted delivery.
1:      *
1:      * @param session
1:      *      The session that is used to manage acceptance of the message.
1:      *
1:      * @throws Exception if an error occurs during the accept.
1:      */
1:     public void accept(AmqpSession txnSession) throws Exception {
1:         accept(txnSession, true);
/////////////////////////////////////////////////////////////////////////
1:     public void accept(AmqpSession txnSession, boolean settle) throws Exception {
1:         receiver.accept(delivery, txnSession, settle);
commit:b4ab0e1
/////////////////////////////////////////////////////////////////////////
1:      * Accepts the message marking it as consumed on the remote peer.
1:      *
1:      * @param session
1:      *      The session that is used to manage acceptance of the message.
1:      *
1:      * @throws Exception if an error occurs during the accept.
1:      */
0:     public void accept(AmqpSession txnSession) throws Exception {
1:         if (receiver == null) {
1:             throw new IllegalStateException("Can't accept non-received message.");
1:         }
1: 
0:         receiver.accept(delivery, txnSession);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * @return the property value or null if not set.
/////////////////////////////////////////////////////////////////////////
1: 
commit:0050f22
/////////////////////////////////////////////////////////////////////////
1:      * Sets the address which is applied to the AMQP message To field in the message properties
1:      *
1:      * @param address
1:      *      The address that should be applied in the Message To field.
1:      */
1:     public void setAddress(String address) {
1:         checkReadOnly();
1:         lazyCreateProperties();
1:         getWrappedMessage().setAddress(address);
1:     }
1: 
1:     /**
1:      * Return the set address that was set in the Message To field.
1:      *
1:      * @return the set address String form or null if not set.
1:      */
1:     public String getAddress() {
1:         if (message.getProperties() == null) {
1:             return null;
1:         }
1: 
1:         return message.getProperties().getTo();
1:     }
1: 
1:     /**
commit:16c487a
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:      * Sets the CorrelationId property on an outbound message using the provided String
1:      *
1:      * @param correlationId
1:      *        the String Correlation ID value to set.
1:      */
1:     public void setCorrelationId(String correlationId) {
1:         checkReadOnly();
1:         lazyCreateProperties();
1:         getWrappedMessage().setCorrelationId(correlationId);
1:     }
1: 
1:     /**
1:      * Return the set CorrelationId value in String form, if there are no properties
1:      * in the given message return null.
1:      *
1:      * @return the set correlation ID in String form or null if not set.
1:      */
1:     public String getCorrelationId() {
1:         if (message.getProperties() == null) {
1:             return null;
1:         }
1: 
1:         return message.getProperties().getCorrelationId().toString();
1:     }
1: 
1:     /**
1:      * Return the set CorrelationId value in the original form, if there are no properties
1:      * in the given message return null.
1:      *
1:      * @return the set message ID in its original form or null if not set.
1:      */
1:     public Object getRawCorrelationId() {
1:         if (message.getProperties() == null) {
1:             return null;
1:         }
1: 
1:         return message.getProperties().getCorrelationId();
1:     }
1: 
1:     /**
1:      * Sets the CorrelationId property on an outbound message using the provided value
1:      *
1:      * @param correlationId
1:      *        the correlation ID value to set.
1:      */
1:     public void setRawCorrelationId(Object correlationId) {
1:         checkReadOnly();
1:         lazyCreateProperties();
1:         getWrappedMessage().setCorrelationId(correlationId);
1:     }
1: 
1:     /**
commit:4d6f4d7
/////////////////////////////////////////////////////////////////////////
1:      * Return the set MessageId value in the original form, if there are no properties
1:      * in the given message return null.
1:      *
1:      * @return the set message ID in its original form or null if not set.
1:      */
1:     public Object getRawMessageId() {
1:         if (message.getProperties() == null) {
1:             return null;
1:         }
1: 
1:         return message.getProperties().getMessageId();
1:     }
1: 
1:     /**
1:      * Sets the MessageId property on an outbound message using the provided value
1:      *
1:      * @param messageId
1:      *        the message ID value to set.
1:      */
1:     public void setRawMessageId(Object messageId) {
1:         checkReadOnly();
1:         lazyCreateProperties();
1:         getWrappedMessage().setMessageId(messageId);
1:     }
1: 
1:     /**
commit:11da37b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.messaging.Header;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Sets the durable header on the outgoing message.
1:      *
1:      * @param durable
1:      *        the boolean durable value to set.
1:      */
1:     public void setDurable(boolean durable) {
1:         checkReadOnly();
1:         lazyCreateHeader();
1:         getWrappedMessage().setDurable(durable);
1:     }
1: 
1:     /**
1:      * Checks the durable value in the Message Headers to determine if
1:      * the message was sent as a durable Message.
1:      *
1:      * @return true if the message is marked as being durable.
1:      */
1:     public boolean isDurable() {
1:         if (message.getHeader() == null) {
1:             return false;
1:         }
1: 
1:         return message.getHeader().getDurable();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     private void lazyCreateHeader() {
0:         if (message.getHeader() == null) {
1:             message.setHeader(new Header());
1:         }
1:     }
commit:13b915a
/////////////////////////////////////////////////////////////////////////
1: import java.util.NoSuchElementException;
1: import org.apache.qpid.proton.amqp.DescribedType;
/////////////////////////////////////////////////////////////////////////
1:     //----- Methods for manipulating the Message body ------------------------//
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets a byte array value into the body of an outgoing Message, throws
1:      * an exception if this is an incoming message instance.
1:      *
1:      * @param value
1:      *        the byte array value to store in the Message body.
1:      *
1:      * @throws IllegalStateException if the message is read only.
1:      */
1:     public void setDescribedType(DescribedType described) throws IllegalStateException {
1:         checkReadOnly();
1:         AmqpValue body = new AmqpValue(described);
1:         getWrappedMessage().setBody(body);
1:     }
1: 
1:     /**
1:      * Attempts to retrieve the message body as an DescribedType instance.
1:      *
1:      * @return an DescribedType instance if one is stored in the message body.
1:      *
1:      * @throws NoSuchElementException if the body does not contain a DescribedType.
1:      */
1:     public DescribedType getDescribedType() throws NoSuchElementException {
1:         DescribedType result = null;
1: 
1:         if (getWrappedMessage().getBody() == null) {
1:             return null;
1:         } else {
1:             if (getWrappedMessage().getBody() instanceof AmqpValue) {
1:                 AmqpValue value = (AmqpValue) getWrappedMessage().getBody();
1: 
1:                 if (value.getValue() == null) {
1:                     result = null;
1:                 } else if (value.getValue() instanceof DescribedType) {
1:                     result = (DescribedType) value.getValue();
1:                 } else {
1:                     throw new NoSuchElementException("Message does not contain a DescribedType body");
1:                 }
1:             }
1:         }
1: 
1:         return result;
1:     }
1: 
commit:f05ff94
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;
/////////////////////////////////////////////////////////////////////////
1:     private Map<Symbol, Object> deliveryAnnotationsMap;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (message.getDeliveryAnnotations() != null) {
1:             deliveryAnnotationsMap = message.getDeliveryAnnotations().getValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:      * Perform a proper delivery annotation set on the AMQP Message based on a Symbol
1:      * key and the target value to append to the current delivery annotations.
1:      *
1:      * @param key
1:      *        The name of the Symbol whose value is being set.
1:      * @param value
1:      *        The new value to set in the delivery annotations of this message.
1:      */
1:     public void setDeliveryAnnotation(String key, Object value) {
1:         checkReadOnly();
1:         lazyCreateDeliveryAnnotations();
1:         deliveryAnnotationsMap.put(Symbol.valueOf(key), value);
1:     }
1: 
1:     /**
1:      * Given a message annotation name, lookup and return the value associated with
1:      * that annotation name.  If the message annotations have not been created yet
1:      * then this method will always return null.
1:      *
1:      * @param key
1:      *        the Symbol name that should be looked up in the message annotations.
1:      *
1:      * @return the value of the annotation if it exists, or null if not set or not accessible.
1:      */
1:     public Object getDeliveryAnnotation(String key) {
1:         if (deliveryAnnotationsMap == null) {
1:             return null;
1:         }
1: 
1:         return deliveryAnnotationsMap.get(Symbol.valueOf(key));
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     private void lazyCreateDeliveryAnnotations() {
1:         if (deliveryAnnotationsMap == null) {
0:             deliveryAnnotationsMap = new HashMap<Symbol,Object>();
1:             message.setDeliveryAnnotations(new DeliveryAnnotations(deliveryAnnotationsMap));
1:         }
1:     }
1: 
commit:7c41ebc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.Binary;
1: import org.apache.qpid.proton.amqp.messaging.Data;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets a byte array value into the body of an outgoing Message, throws
1:      * an exception if this is an incoming message instance.
1:      *
1:      * @param value
1:      *        the byte array value to store in the Message body.
1:      *
1:      * @throws IllegalStateException if the message is read only.
1:      */
1:     public void setBytes(byte[] bytes) throws IllegalStateException {
1:         checkReadOnly();
1:         Data body = new Data(new Binary(bytes));
1:         getWrappedMessage().setBody(body);
1:     }
1: 
commit:351d4b9
/////////////////////////////////////////////////////////////////////////
1:      * Sets the GroupId property on an outbound message using the provided String
1:      *
1:      * @param messageId
1:      *        the String Group ID value to set.
1:      */
1:     public void setGroupId(String groupId) {
1:         checkReadOnly();
1:         lazyCreateProperties();
1:         getWrappedMessage().setGroupId(groupId);
1:     }
1: 
1:     /**
1:      * Return the set GroupId value in String form, if there are no properties
1:      * in the given message return null.
1:      *
1:      * @return the set GroupID in String form or null if not set.
1:      */
1:     public String getGroupId() {
1:         if (message.getProperties() == null) {
1:             return null;
1:         }
1: 
1:         return message.getProperties().getGroupId();
1:     }
1: 
1:     /**
commit:f56ea45
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
1: 
1: import org.apache.qpid.proton.amqp.Symbol;
1: import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
1: import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;
1: import org.apache.qpid.proton.amqp.messaging.Properties;
/////////////////////////////////////////////////////////////////////////
1:     private Map<Symbol, Object> messageAnnotationsMap;
1:     private Map<String, Object> applicationPropertiesMap;
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("unchecked")
1: 
1:         if (message.getMessageAnnotations() != null) {
1:             messageAnnotationsMap = message.getMessageAnnotations().getValue();
1:         }
1: 
1:         if (message.getApplicationProperties() != null) {
1:             applicationPropertiesMap = message.getApplicationProperties().getValue();
1:         }
1:     //----- Access to interal client resources -------------------------------//
1: 
1:     /**
1:      * @return the AMQP Delivery object linked to a received message.
1:      */
1:     public Delivery getWrappedDelivery() {
1:         if (delivery != null) {
0:             return new UnmodifiableDelivery(delivery);
1:         }
1: 
1:         return null;
1:     }
1: 
1:     /**
1:      * @return the AMQP Message that is wrapped by this object.
1:      */
1:     public Message getWrappedMessage() {
1:         return message;
1:     }
1: 
1:     /**
1:      * @return the AmqpReceiver that consumed this message.
1:      */
1:     public AmqpReceiver getAmqpReceiver() {
1:         return receiver;
1:     }
1: 
1:     //----- Message disposition control --------------------------------------//
1: 
/////////////////////////////////////////////////////////////////////////
1:     //----- Convenience methods for constructing outbound messages -----------//
1: 
1:      * Sets the MessageId property on an outbound message using the provided String
1:      *
1:      * @param messageId
1:      *        the String message ID value to set.
1:     public void setMessageId(String messageId) {
1:         checkReadOnly();
1:         lazyCreateProperties();
1:         getWrappedMessage().setMessageId(messageId);
1:     }
1: 
1:     /**
1:      * Return the set MessageId value in String form, if there are no properties
1:      * in the given message return null.
1:      *
1:      * @return the set message ID in String form or null if not set.
1:      */
1:     public String getMessageId() {
0:         if (message.getProperties() == null) {
1:             return null;
1:         return message.getProperties().getMessageId().toString();
1:      * Sets a given application property on an outbound message.
1:      *
1:      * @param key
1:      *        the name to assign the new property.
1:      * @param value
1:      *        the value to set for the named property.
1:     public void setApplicationProperty(String key, Object value) {
1:         checkReadOnly();
1:         lazyCreateApplicationProperties();
1:         applicationPropertiesMap.put(key, value);
1:      * Gets the application property that is mapped to the given name or null
1:      * if no property has been set with that name.
1:      *
1:      * @param key
1:      *        the name used to lookup the property in the application properties.
1:      *
0:      * @return the propety value or null if not set.
1:     public Object getApplicationProperty(String key) {
1:         if (applicationPropertiesMap == null) {
1:             return null;
1:         }
1: 
1:         return applicationPropertiesMap.get(key);
1:     }
1: 
1:     /**
1:      * Perform a proper annotation set on the AMQP Message based on a Symbol key and
1:      * the target value to append to the current annotations.
1:      *
1:      * @param key
1:      *        The name of the Symbol whose value is being set.
1:      * @param value
1:      *        The new value to set in the annotations of this message.
1:      */
1:     public void setMessageAnnotation(String key, Object value) {
1:         checkReadOnly();
1:         lazyCreateMessageAnnotations();
1:         messageAnnotationsMap.put(Symbol.valueOf(key), value);
1:     }
1: 
1:     /**
1:      * Given a message annotation name, lookup and return the value associated with
1:      * that annotation name.  If the message annotations have not been created yet
1:      * then this method will always return null.
1:      *
1:      * @param key
1:      *        the Symbol name that should be looked up in the message annotations.
1:      *
1:      * @return the value of the annotation if it exists, or null if not set or not accessible.
1:      */
1:     public Object getMessageAnnotation(String key) {
1:         if (messageAnnotationsMap == null) {
1:             return null;
1:         }
1: 
1:         return messageAnnotationsMap.get(Symbol.valueOf(key));
/////////////////////////////////////////////////////////////////////////
1:         checkReadOnly();
1:         AmqpValue body = new AmqpValue(value);
1:         getWrappedMessage().setBody(body);
1:     }
1: 
1:     //----- Internal implementation ------------------------------------------//
1: 
1:     private void checkReadOnly() throws IllegalStateException {
1:     }
1:     private void lazyCreateMessageAnnotations() {
1:         if (messageAnnotationsMap == null) {
0:             messageAnnotationsMap = new HashMap<Symbol,Object>();
1:             message.setMessageAnnotations(new MessageAnnotations(messageAnnotationsMap));
1:         }
1:     }
1: 
1:     private void lazyCreateApplicationProperties() {
1:         if (applicationPropertiesMap == null) {
0:             applicationPropertiesMap = new HashMap<String, Object>();
1:             message.setApplicationProperties(new ApplicationProperties(applicationPropertiesMap));
1:         }
1:     }
1: 
1:     private void lazyCreateProperties() {
0:         if (message.getProperties() == null) {
1:             message.setProperties(new Properties());
1:         }
commit:72839b7
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.client;
1: 
0: import org.apache.activemq.transport.amqp.client.util.UnmodifiableDelivery;
1: import org.apache.qpid.proton.Proton;
1: import org.apache.qpid.proton.amqp.messaging.AmqpValue;
1: import org.apache.qpid.proton.engine.Delivery;
1: import org.apache.qpid.proton.message.Message;
1: 
1: public class AmqpMessage {
1: 
1:     private final AmqpReceiver receiver;
1:     private final Message message;
1:     private final Delivery delivery;
1: 
1:     /**
1:      * Creates a new AmqpMessage that wraps the information necessary to handle
1:      * an outgoing message.
1:      */
1:     public AmqpMessage() {
1:         receiver = null;
1:         delivery = null;
1: 
1:         message = Proton.message();
0:         message.setDurable(true);
1:     }
1: 
1:     /**
1:      * Creates a new AmqpMessage that wraps the information necessary to handle
1:      * an outgoing message.
1:      *
1:      * @param message
1:      *        the Proton message that is to be sent.
1:      */
1:     public AmqpMessage(Message message) {
1:         this(null, message, null);
1:     }
1: 
1:     /**
1:      * Creates a new AmqpMessage that wraps the information necessary to handle
1:      * an incoming delivery.
1:      *
1:      * @param receiver
1:      *        the AmqpReceiver that received this message.
1:      * @param message
1:      *        the Proton message that was received.
1:      * @param delivery
1:      *        the Delivery instance that produced this message.
1:      */
1:     public AmqpMessage(AmqpReceiver receiver, Message message, Delivery delivery) {
1:         this.receiver = receiver;
1:         this.message = message;
1:         this.delivery = delivery;
1:     }
1: 
1:     /**
1:      * Accepts the message marking it as consumed on the remote peer.
1:      *
1:      * @throws Exception if an error occurs during the accept.
1:      */
1:     public void accept() throws Exception {
1:         if (receiver == null) {
1:             throw new IllegalStateException("Can't accept non-received message.");
1:         }
1: 
0:         receiver.accept(delivery);
1:     }
1: 
1:     /**
0:      * Rejects the message, marking it as not deliverable here and failed to deliver.
1:      *
0:      * @throws Exception if an error occurs during the reject.
1:      */
0:     public void reject() throws Exception {
0:         reject(true, true);
1:     }
1: 
1:     /**
0:      * Rejects the message, marking it as failed to deliver and applying the given value
0:      * to the undeliverable here tag.
1:      *
1:      * @param undeliverableHere
1:      *        marks the delivery as not being able to be process by link it was sent to.
1:      *
0:      * @throws Exception if an error occurs during the reject.
1:      */
0:     public void reject(boolean undeliverableHere) throws Exception {
0:         reject(undeliverableHere, true);
1:     }
1: 
1:     /**
0:      * Rejects the message, marking it as not deliverable here and failed to deliver.
1:      *
1:      * @param undeliverableHere
1:      *        marks the delivery as not being able to be process by link it was sent to.
1:      * @param deliveryFailed
1:      *        indicates that the delivery failed for some reason.
1:      *
0:      * @throws Exception if an error occurs during the reject.
1:      */
0:     public void reject(boolean undeliverableHere, boolean deliveryFailed) throws Exception {
1:         if (receiver == null) {
0:             throw new IllegalStateException("Can't reject non-received message.");
1:         }
1: 
0:         receiver.reject(delivery, undeliverableHere, deliveryFailed);
1:     }
1: 
1:     /**
1:      * Release the message, remote can redeliver it elsewhere.
1:      *
0:      * @throws Exception if an error occurs during the reject.
1:      */
1:     public void release() throws Exception {
1:         if (receiver == null) {
1:             throw new IllegalStateException("Can't release non-received message.");
1:         }
1: 
1:         receiver.release(delivery);
1:     }
1: 
1:     /**
0:      * @return the AMQP Delivery object linked to a received message.
1:      */
0:     public Delivery getWrappedDelivery() {
1:         if (delivery != null) {
0:             return new UnmodifiableDelivery(delivery);
1:         }
1: 
0:         return null;
1:     }
1: 
1:     /**
0:      * @return the AMQP Message that is wrapped by this object.
1:      */
0:     public Message getWrappedMessage() {
0:         return message;
1:     }
1: 
1:     /**
0:      * @return the AmqpReceiver that consumed this message.
1:      */
0:     public AmqpReceiver getAmqpReceiver() {
0:         return receiver;
1:     }
1: 
1:     /**
1:      * Sets a String value into the body of an outgoing Message, throws
1:      * an exception if this is an incoming message instance.
1:      *
1:      * @param value
1:      *        the String value to store in the Message body.
1:      *
1:      * @throws IllegalStateException if the message is read only.
1:      */
1:     public void setText(String value) throws IllegalStateException {
1:         if (delivery != null) {
1:             throw new IllegalStateException("Message is read only.");
1:         }
1: 
0:         AmqpValue body = new AmqpValue(value);
0:         getWrappedMessage().setBody(body);
1:     }
1: }
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:0cfd225
/////////////////////////////////////////////////////////////////////////
1:      * Marks the message as Modified, indicating whether it failed to deliver and is not deliverable here.
0:      * @param undeliverableHere
0:      *        marks the delivery as not being able to be process by link it was sent to.
1:      * @throws Exception if an error occurs during the process.
1:     public void modified(Boolean deliveryFailed, Boolean undeliverableHere) throws Exception {
1:             throw new IllegalStateException("Can't modify non-received message.");
1:         receiver.modified(delivery, deliveryFailed, undeliverableHere);
============================================================================