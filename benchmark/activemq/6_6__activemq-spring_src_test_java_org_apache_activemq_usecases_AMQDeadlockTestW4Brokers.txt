1:985b4ce: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
3:985b4ce:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:985b4ce:  *
1:985b4ce:  * Unless required by applicable law or agreed to in writing, software
1:985b4ce:  * distributed under the License is distributed on an "AS IS" BASIS,
1:985b4ce:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985b4ce:  * See the License for the specific language governing permissions and
1:985b4ce:  * limitations under the License.
1:985b4ce:  */
1:985b4ce: package org.apache.activemq.usecases;
30:985b4ce: 
1:230a86c: import java.net.URI;
1:230a86c: import java.util.ArrayList;
1:ecf89a6: import java.util.List;
1:230a86c: import java.util.Random;
1:230a86c: import java.util.concurrent.CountDownLatch;
1:230a86c: import java.util.concurrent.ExecutorService;
1:230a86c: import java.util.concurrent.Executors;
1:230a86c: import java.util.concurrent.TimeUnit;
1:230a86c: import java.util.concurrent.atomic.AtomicInteger;
1:230a86c: 
1:230a86c: import javax.jms.BytesMessage;
1:230a86c: import javax.jms.ConnectionFactory;
1:230a86c: import javax.jms.DeliveryMode;
1:230a86c: import javax.jms.JMSException;
1:230a86c: import javax.jms.Message;
1:230a86c: import javax.jms.MessageListener;
1:230a86c: import javax.jms.Session;
1:230a86c: 
1:985b4ce: import org.apache.activemq.ActiveMQConnectionFactory;
1:985b4ce: import org.apache.activemq.broker.BrokerService;
1:985b4ce: import org.apache.activemq.broker.TransportConnector;
1:985b4ce: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:985b4ce: import org.apache.activemq.broker.region.policy.PolicyMap;
1:985b4ce: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:985b4ce: import org.apache.activemq.network.NetworkConnector;
1:985b4ce: import org.apache.activemq.pool.PooledConnectionFactory;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:985b4ce: import org.springframework.jms.core.JmsTemplate;
1:985b4ce: import org.springframework.jms.core.MessageCreator;
1:985b4ce: import org.springframework.jms.listener.DefaultMessageListenerContainer;
1:230a86c: 
1:2e57fb5: public class AMQDeadlockTestW4Brokers extends org.apache.activemq.test.TestSupport {
1:2e57fb5: 
1:8bf987b:     private static final transient Logger LOG = LoggerFactory.getLogger(AMQDeadlockTestW4Brokers.class);
1:985b4ce: 
1:985b4ce:     private static final String BROKER_URL1 = "tcp://localhost:61616";
1:985b4ce:     private static final String BROKER_URL2 = "tcp://localhost:61617";
1:985b4ce:     private static final String BROKER_URL3 = "tcp://localhost:61618";
1:985b4ce:     private static final String BROKER_URL4 = "tcp://localhost:61619";
1:230a86c:     private static final String URL1 = "tcp://localhost:61616?wireFormat.cacheEnabled=false"
1:230a86c:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1:230a86c:     private static final String URL2 = "tcp://localhost:61617?wireFormat.cacheEnabled=false"
1:230a86c:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1:230a86c:     private static final String URL3 = "tcp://localhost:61618?wireFormat.cacheEnabled=false"
1:230a86c:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1:230a86c:     private static final String URL4 = "tcp://localhost:61619?wireFormat.cacheEnabled=false"
1:230a86c:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1:985b4ce:     private static final String QUEUE1_NAME = "test.queue.1";
1:985b4ce:     private static final int MAX_CONSUMERS = 5;
1:985b4ce:     private static final int NUM_MESSAGE_TO_SEND = 10000;
1:fc00993:     private static final CountDownLatch LATCH = new CountDownLatch(MAX_CONSUMERS * NUM_MESSAGE_TO_SEND);
1:985b4ce: 
1:985b4ce:     @Override
1:985b4ce:     public void setUp() throws Exception {
1:985b4ce: 
1:985b4ce:     }
1:985b4ce: 
1:985b4ce:     @Override
1:985b4ce:     public void tearDown() throws Exception {
1:985b4ce: 
1:985b4ce:     }
1:985b4ce: 
1:985b4ce:     public void test4BrokerWithOutLingo() throws Exception {
1:985b4ce: 
1:985b4ce:         BrokerService brokerService1 = null;
1:985b4ce:         BrokerService brokerService2 = null;
1:985b4ce:         BrokerService brokerService3 = null;
1:985b4ce:         BrokerService brokerService4 = null;
1:985b4ce:         ActiveMQConnectionFactory acf1 = null;
1:985b4ce:         ActiveMQConnectionFactory acf2 = null;
1:985b4ce:         PooledConnectionFactory pcf1 = null;
1:985b4ce:         PooledConnectionFactory pcf2 = null;
1:985b4ce:         ActiveMQConnectionFactory acf3 = null;
1:985b4ce:         ActiveMQConnectionFactory acf4 = null;
1:985b4ce:         PooledConnectionFactory pcf3 = null;
1:985b4ce:         PooledConnectionFactory pcf4 = null;
1:985b4ce:         DefaultMessageListenerContainer container1 = null;
1:985b4ce: 
1:985b4ce:         try {
1:985b4ce: 
1:230a86c:             // Test with and without queue limits.
1:230a86c:             brokerService1 = createBrokerService("broker1", BROKER_URL1, BROKER_URL2, BROKER_URL3, BROKER_URL4, 0 /* 10000000 */);
1:985b4ce:             brokerService1.start();
1:230a86c:             brokerService2 = createBrokerService("broker2", BROKER_URL2, BROKER_URL1, BROKER_URL3, BROKER_URL4, 0/* 40000000 */);
1:985b4ce:             brokerService2.start();
1:230a86c:             brokerService3 = createBrokerService("broker3", BROKER_URL3, BROKER_URL2, BROKER_URL1, BROKER_URL4, 0/* 10000000 */);
1:985b4ce:             brokerService3.start();
1:230a86c:             brokerService4 = createBrokerService("broker4", BROKER_URL4, BROKER_URL1, BROKER_URL3, BROKER_URL2, 0/* 10000000 */);
1:985b4ce:             brokerService4.start();
1:985b4ce: 
1:230a86c:             final String failover1 = "failover:(" + URL1
1:230a86c:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1:230a86c:             final String failover2 = "failover:(" + URL2
1:230a86c:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1:985b4ce: 
1:230a86c:             final String failover3 = "failover:(" + URL3
1:230a86c:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1:985b4ce: 
1:230a86c:             final String failover4 = "failover:(" + URL4
1:230a86c:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1:985b4ce: 
1:985b4ce:             acf1 = createConnectionFactory(failover1);
1:985b4ce:             acf2 = createConnectionFactory(failover2);
1:985b4ce:             acf3 = createConnectionFactory(failover3);
1:985b4ce:             acf4 = createConnectionFactory(failover4);
1:985b4ce: 
1:985b4ce:             pcf1 = new PooledConnectionFactory(acf1);
1:985b4ce:             pcf2 = new PooledConnectionFactory(acf2);
1:985b4ce:             pcf3 = new PooledConnectionFactory(acf3);
1:985b4ce:             pcf4 = new PooledConnectionFactory(acf4);
1:985b4ce: 
1:230a86c:             container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(0), QUEUE1_NAME);
1:985b4ce:             container1.afterPropertiesSet();
1:985b4ce: 
1:985b4ce:             final PooledProducerTask[] task = new PooledProducerTask[4];
1:985b4ce:             task[0] = new PooledProducerTask(pcf1, QUEUE1_NAME, "producer1");
1:985b4ce:             task[1] = new PooledProducerTask(pcf2, QUEUE1_NAME, "producer2");
1:985b4ce:             task[2] = new PooledProducerTask(pcf3, QUEUE1_NAME, "producer3");
1:985b4ce:             task[3] = new PooledProducerTask(pcf4, QUEUE1_NAME, "producer4");
1:985b4ce: 
1:985b4ce:             final ExecutorService executor = Executors.newCachedThreadPool();
1:985b4ce: 
1:985b4ce:             for (int i = 0; i < 4; i++) {
1:985b4ce:                 executor.submit(task[i]);
1:985b4ce:             }
1:985b4ce: 
1:fc00993:             LATCH.await(15, TimeUnit.SECONDS);
1:fc00993:             assertTrue(LATCH.getCount() == MAX_CONSUMERS * NUM_MESSAGE_TO_SEND);
1:230a86c:         } catch (Exception e) {
2:985b4ce:             e.printStackTrace();
1:230a86c:         } finally {
1:985b4ce: 
1:985b4ce:             container1.stop();
1:985b4ce:             container1.destroy();
1:985b4ce:             container1 = null;
1:985b4ce: 
1:985b4ce:             brokerService1.stop();
1:985b4ce:             brokerService1 = null;
1:985b4ce:             brokerService2.stop();
1:985b4ce:             brokerService2 = null;
1:985b4ce:             brokerService3.stop();
1:985b4ce:             brokerService3 = null;
1:985b4ce:             brokerService4.stop();
1:985b4ce:             brokerService4 = null;
1:985b4ce:         }
1:985b4ce:     }
1:985b4ce: 
1:230a86c:     private BrokerService createBrokerService(final String brokerName, final String uri1, final String uri2, final String uri3, final String uri4, final int queueLimit)
1:230a86c:         throws Exception {
1:985b4ce:         final BrokerService brokerService = new BrokerService();
1:985b4ce: 
1:985b4ce:         brokerService.setBrokerName(brokerName);
1:985b4ce:         brokerService.setPersistent(false);
1:985b4ce:         brokerService.setUseJmx(true);
1:985b4ce: 
1:6d8e2c5:         final SystemUsage memoryManager = new SystemUsage();
1:6d8e2c5:         memoryManager.getMemoryUsage().setLimit(100000000);
1:2b0024c:         brokerService.setSystemUsage(memoryManager);
1:985b4ce: 
1:ecf89a6:         final List<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
1:985b4ce: 
1:985b4ce:         final PolicyEntry entry = new PolicyEntry();
1:985b4ce:         entry.setQueue(">");
1:985b4ce:         entry.setMemoryLimit(queueLimit);
1:985b4ce:         policyEntries.add(entry);
1:985b4ce: 
1:985b4ce:         final PolicyMap policyMap = new PolicyMap();
1:985b4ce:         policyMap.setPolicyEntries(policyEntries);
1:985b4ce:         brokerService.setDestinationPolicy(policyMap);
1:985b4ce: 
1:985b4ce:         final TransportConnector tConnector = new TransportConnector();
1:985b4ce:         tConnector.setUri(new URI(uri1));
1:985b4ce:         tConnector.setName(brokerName + ".transportConnector");
1:985b4ce:         brokerService.addConnector(tConnector);
1:985b4ce: 
1:985b4ce:         if (uri2 != null) {
1:230a86c:             final NetworkConnector nc = new DiscoveryNetworkConnector(new URI("static:" + uri2 + "," + uri3 + "," + uri4));
1:985b4ce:             nc.setBridgeTempDestinations(true);
1:985b4ce:             nc.setBrokerName(brokerName);
1:54114cc: 
1:985b4ce:             // When using queue limits set this to 1
1:985b4ce:             nc.setPrefetchSize(1000);
1:985b4ce:             nc.setNetworkTTL(1);
1:985b4ce:             brokerService.addNetworkConnector(nc);
1:985b4ce:         }
1:985b4ce: 
1:985b4ce:         return brokerService;
1:985b4ce:     }
1:985b4ce: 
1:230a86c:     public DefaultMessageListenerContainer createDefaultMessageListenerContainer(final ConnectionFactory acf, final MessageListener listener, final String queue) {
1:985b4ce:         final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();
1:985b4ce:         container.setConnectionFactory(acf);
1:985b4ce:         container.setDestinationName(queue);
1:985b4ce:         container.setMessageListener(listener);
1:985b4ce:         container.setSessionTransacted(false);
1:985b4ce:         container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
1:985b4ce:         container.setConcurrentConsumers(MAX_CONSUMERS);
1:985b4ce:         return container;
1:985b4ce:     }
1:985b4ce: 
1:985b4ce:     public ActiveMQConnectionFactory createConnectionFactory(final String url) {
1:985b4ce:         final ActiveMQConnectionFactory acf = new ActiveMQConnectionFactory(url);
1:985b4ce:         acf.setCopyMessageOnSend(false);
1:985b4ce:         acf.setUseAsyncSend(false);
1:985b4ce:         acf.setDispatchAsync(true);
1:985b4ce:         acf.setUseCompression(false);
1:985b4ce:         acf.setOptimizeAcknowledge(false);
1:985b4ce:         acf.setOptimizedMessageDispatch(true);
1:985b4ce:         acf.setUseAsyncSend(false);
1:985b4ce: 
1:985b4ce:         return acf;
1:985b4ce:     }
1:985b4ce: 
1:d36c0d4:     private static class TestMessageListener1 implements MessageListener {
1:985b4ce:         final AtomicInteger count = new AtomicInteger(0);
1:ecf89a6:         private final long waitTime;
1:985b4ce: 
1:985b4ce:         public TestMessageListener1(long waitTime) {
1:985b4ce:             this.waitTime = waitTime;
1:985b4ce:         }
1:985b4ce: 
1:1b38caa:         @Override
1:985b4ce:         public void onMessage(Message msg) {
1:985b4ce: 
1:985b4ce:             try {
1:230a86c:                 /*
1:230a86c:                  * log.info("Listener1 Consumed message " +
1:230a86c:                  * msg.getIntProperty("count") + " from " +
1:230a86c:                  * msg.getStringProperty("producerName"));
1:230a86c:                  */
1:985b4ce:                 int value = count.incrementAndGet();
1:aa1aa58:                 if (value % 1000 == 0) {
1:fc00993:                     LOG.info("Consumed message: " + value);
1:985b4ce:                 }
1:985b4ce: 
1:985b4ce:                 Thread.sleep(waitTime);
1:fc00993:                 LATCH.countDown();
1:230a86c:                 /*
1:230a86c:                  * } catch (JMSException e) { e.printStackTrace();
1:230a86c:                  */
1:230a86c:             } catch (InterruptedException e) {
1:985b4ce:                 e.printStackTrace();
1:985b4ce:             }
1:985b4ce:         }
1:985b4ce:     }
1:985b4ce: 
1:985b4ce:     private class PooledProducerTask implements Runnable {
1:985b4ce:         private final String queueName;
1:985b4ce:         private final PooledConnectionFactory pcf;
1:985b4ce:         private final String producerName;
1:985b4ce: 
1:230a86c:         public PooledProducerTask(final PooledConnectionFactory pcf, final String queueName, final String producerName) {
1:985b4ce:             this.pcf = pcf;
1:985b4ce:             this.queueName = queueName;
1:985b4ce:             this.producerName = producerName;
1:985b4ce:         }
1:985b4ce: 
1:1b38caa:         @Override
1:985b4ce:         public void run() {
1:985b4ce: 
1:985b4ce:             try {
1:985b4ce: 
1:985b4ce:                 final JmsTemplate jmsTemplate = new JmsTemplate(pcf);
1:985b4ce:                 jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:985b4ce:                 jmsTemplate.setExplicitQosEnabled(true);
1:985b4ce:                 jmsTemplate.setMessageIdEnabled(false);
1:985b4ce:                 jmsTemplate.setMessageTimestampEnabled(false);
1:985b4ce:                 jmsTemplate.afterPropertiesSet();
1:985b4ce: 
1:985b4ce:                 final byte[] bytes = new byte[2048];
1:985b4ce:                 final Random r = new Random();
1:985b4ce:                 r.nextBytes(bytes);
1:985b4ce: 
1:985b4ce:                 for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
1:985b4ce:                     final int count = i;
1:985b4ce:                     jmsTemplate.send(queueName, new MessageCreator() {
1:1b38caa:                         @Override
1:230a86c:                         public Message createMessage(Session session) throws JMSException {
1:985b4ce: 
1:230a86c:                             final BytesMessage message = session.createBytesMessage();
1:985b4ce: 
1:985b4ce:                             message.writeBytes(bytes);
1:985b4ce:                             message.setIntProperty("count", count);
1:230a86c:                             message.setStringProperty("producerName", producerName);
1:985b4ce:                             return message;
1:985b4ce:                         }
1:985b4ce:                     });
1:985b4ce: 
1:230a86c:                     // log.info("PooledProducer " + producerName + " sent
1:230a86c:                     // message: " + count);
1:985b4ce: 
1:985b4ce:                     // Thread.sleep(1000);
1:985b4ce:                 }
1:230a86c:             } catch (final Throwable e) {
1:fc00993:                 LOG.error("Producer 1 is exiting", e);
1:985b4ce:             }
1:985b4ce:         }
1:985b4ce:     }
1:985b4ce: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:1b38caa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final transient Logger LOG = LoggerFactory.getLogger(AMQDeadlockTestW4Brokers.class);
commit:76de7c0
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:2e57fb5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.test.*;
/////////////////////////////////////////////////////////////////////////
1: public class AMQDeadlockTestW4Brokers extends org.apache.activemq.test.TestSupport {
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:5d99c99
/////////////////////////////////////////////////////////////////////////
commit:2b0024c
/////////////////////////////////////////////////////////////////////////
1:         brokerService.setSystemUsage(memoryManager);
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:         final List<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
/////////////////////////////////////////////////////////////////////////
1:         private final long waitTime;
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:     private static final transient Log LOG = LogFactory.getLog(AMQDeadlockTestW4Brokers.class);
/////////////////////////////////////////////////////////////////////////
1:     private static final CountDownLatch LATCH = new CountDownLatch(MAX_CONSUMERS * NUM_MESSAGE_TO_SEND);
/////////////////////////////////////////////////////////////////////////
1:             LATCH.await(15, TimeUnit.SECONDS);
1:             assertTrue(LATCH.getCount() == MAX_CONSUMERS * NUM_MESSAGE_TO_SEND);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Consumed message: " + value);
1:                 LATCH.countDown();
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("Producer 1 is exiting", e);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Random;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import javax.jms.BytesMessage;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.Session;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final String URL1 = "tcp://localhost:61616?wireFormat.cacheEnabled=false"
1:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1:     private static final String URL2 = "tcp://localhost:61617?wireFormat.cacheEnabled=false"
1:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1:     private static final String URL3 = "tcp://localhost:61618?wireFormat.cacheEnabled=false"
1:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1:     private static final String URL4 = "tcp://localhost:61619?wireFormat.cacheEnabled=false"
1:                                        + "&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
/////////////////////////////////////////////////////////////////////////
1:             // Test with and without queue limits.
1:             brokerService1 = createBrokerService("broker1", BROKER_URL1, BROKER_URL2, BROKER_URL3, BROKER_URL4, 0 /* 10000000 */);
1:             brokerService2 = createBrokerService("broker2", BROKER_URL2, BROKER_URL1, BROKER_URL3, BROKER_URL4, 0/* 40000000 */);
1:             brokerService3 = createBrokerService("broker3", BROKER_URL3, BROKER_URL2, BROKER_URL1, BROKER_URL4, 0/* 10000000 */);
1:             brokerService4 = createBrokerService("broker4", BROKER_URL4, BROKER_URL1, BROKER_URL3, BROKER_URL2, 0/* 10000000 */);
1:             final String failover1 = "failover:(" + URL1
1:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1:             final String failover2 = "failover:(" + URL2
1:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1:             final String failover3 = "failover:(" + URL3
1:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1:             final String failover4 = "failover:(" + URL4
1:                                      + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
/////////////////////////////////////////////////////////////////////////
1:             container1 = createDefaultMessageListenerContainer(acf2, new TestMessageListener1(0), QUEUE1_NAME);
/////////////////////////////////////////////////////////////////////////
1:         } catch (Exception e) {
1:         } finally {
/////////////////////////////////////////////////////////////////////////
1:     private BrokerService createBrokerService(final String brokerName, final String uri1, final String uri2, final String uri3, final String uri4, final int queueLimit)
1:         throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             final NetworkConnector nc = new DiscoveryNetworkConnector(new URI("static:" + uri2 + "," + uri3 + "," + uri4));
/////////////////////////////////////////////////////////////////////////
1:     public DefaultMessageListenerContainer createDefaultMessageListenerContainer(final ConnectionFactory acf, final MessageListener listener, final String queue) {
/////////////////////////////////////////////////////////////////////////
1:                 /*
1:                  * log.info("Listener1 Consumed message " +
1:                  * msg.getIntProperty("count") + " from " +
1:                  * msg.getStringProperty("producerName"));
1:                  */
/////////////////////////////////////////////////////////////////////////
1:                 /*
1:                  * } catch (JMSException e) { e.printStackTrace();
1:                  */
1:             } catch (InterruptedException e) {
/////////////////////////////////////////////////////////////////////////
1:         public PooledProducerTask(final PooledConnectionFactory pcf, final String queueName, final String producerName) {
/////////////////////////////////////////////////////////////////////////
1:                         public Message createMessage(Session session) throws JMSException {
1:                             final BytesMessage message = session.createBytesMessage();
1:                             message.setStringProperty("producerName", producerName);
1:                     // log.info("PooledProducer " + producerName + " sent
1:                     // message: " + count);
1:             } catch (final Throwable e) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:         final SystemUsage memoryManager = new SystemUsage();
1:         memoryManager.getMemoryUsage().setLimit(100000000);
0:         brokerService.setUsageManager(memoryManager);
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
1:     private static class TestMessageListener1 implements MessageListener {
commit:54114cc
/////////////////////////////////////////////////////////////////////////
1: 						
commit:985b4ce
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.usecases;
1: 
0: import java.net.URI;
0: import java.util.ArrayList;
0: import java.util.Random;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicInteger;
1: 
0: import javax.jms.BytesMessage;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.DeliveryMode;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageListener;
0: import javax.jms.Session;
1: 
0: import junit.framework.Assert;
0: import junit.framework.TestCase;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.memory.UsageManager;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.pool.PooledConnectionFactory;
1: import org.springframework.jms.core.JmsTemplate;
1: import org.springframework.jms.core.MessageCreator;
1: import org.springframework.jms.listener.DefaultMessageListenerContainer;
1: 
0: public class AMQDeadlockTestW4Brokers extends TestCase {
1: 
1: 	private static final String BROKER_URL1 = "tcp://localhost:61616";
1: 
1: 	private static final String BROKER_URL2 = "tcp://localhost:61617";
1: 
1: 	private static final String BROKER_URL3 = "tcp://localhost:61618";
1: 
1: 	private static final String BROKER_URL4 = "tcp://localhost:61619";
1: 
0: 	private static final String URL1 = "tcp://localhost:61616?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1: 
0: 	private static final String URL2 = "tcp://localhost:61617?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1: 
0: 	private static final String URL3 = "tcp://localhost:61618?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1: 
0: 	private static final String URL4 = "tcp://localhost:61619?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
1: 
1: 	private static final String QUEUE1_NAME = "test.queue.1";
1: 
1: 	private static final int MAX_CONSUMERS = 5;
1: 
1: 	private static final int NUM_MESSAGE_TO_SEND = 10000;
0:     private static final CountDownLatch latch = new CountDownLatch(MAX_CONSUMERS*NUM_MESSAGE_TO_SEND);
1: 
1: 	@Override
1: 	public void setUp() throws Exception {
1: 
1: 	}
1: 
1: 	@Override
1: 	public void tearDown() throws Exception {
1: 
1: 	}
1: 
1: 	public void test4BrokerWithOutLingo() throws Exception {
1: 
1: 		BrokerService brokerService1 = null;
1: 		BrokerService brokerService2 = null;
1: 		BrokerService brokerService3 = null;
1: 		BrokerService brokerService4 = null;
1: 		ActiveMQConnectionFactory acf1 = null;
1: 		ActiveMQConnectionFactory acf2 = null;
1: 		PooledConnectionFactory pcf1 = null;
1: 		PooledConnectionFactory pcf2 = null;
1: 		ActiveMQConnectionFactory acf3 = null;
1: 		ActiveMQConnectionFactory acf4 = null;
1: 		PooledConnectionFactory pcf3 = null;
1: 		PooledConnectionFactory pcf4 = null;
1: 		DefaultMessageListenerContainer container1 = null;
1: 
1: 		try {
1: 
0: 			//Test with and without queue limits. 
0: 			brokerService1 = createBrokerService("broker1", BROKER_URL1,
0: 					BROKER_URL2, BROKER_URL3, BROKER_URL4, 0 /* 10000000 */);
1: 			brokerService1.start();
0: 			brokerService2 = createBrokerService("broker2", BROKER_URL2,
0: 					BROKER_URL1, BROKER_URL3, BROKER_URL4, 0/* 40000000 */);
1: 			brokerService2.start();
0: 			brokerService3 = createBrokerService("broker3", BROKER_URL3,
0: 					BROKER_URL2, BROKER_URL1, BROKER_URL4, 0/* 10000000 */);
1: 			brokerService3.start();
0: 			brokerService4 = createBrokerService("broker4", BROKER_URL4,
0: 					BROKER_URL1, BROKER_URL3, BROKER_URL2, 0/* 10000000 */);
1: 			brokerService4.start();
1: 
0: 			final String failover1 = "failover:("
0: 					+ URL1
0: 					+ ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
0: 			final String failover2 = "failover:("
0: 					+ URL2
0: 					+ ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1: 
0: 			final String failover3 = "failover:("
0: 					+ URL3
0: 					+ ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1: 
0: 			final String failover4 = "failover:("
0: 					+ URL4
0: 					+ ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
1: 
1: 			acf1 = createConnectionFactory(failover1);
1: 			acf2 = createConnectionFactory(failover2);
1: 			acf3 = createConnectionFactory(failover3);
1: 			acf4 = createConnectionFactory(failover4);
1: 
1: 			pcf1 = new PooledConnectionFactory(acf1);
1: 			pcf2 = new PooledConnectionFactory(acf2);
1: 			pcf3 = new PooledConnectionFactory(acf3);
1: 			pcf4 = new PooledConnectionFactory(acf4);
1: 
1: 
0: 			container1 = createDefaultMessageListenerContainer(acf2,
0: 					new TestMessageListener1(0), QUEUE1_NAME);
1: 			container1.afterPropertiesSet();
1: 
1: 			final PooledProducerTask[] task = new PooledProducerTask[4];
1: 			task[0] = new PooledProducerTask(pcf1, QUEUE1_NAME, "producer1");
1: 			task[1] = new PooledProducerTask(pcf2, QUEUE1_NAME, "producer2");
1: 			task[2] = new PooledProducerTask(pcf3, QUEUE1_NAME, "producer3");
1: 			task[3] = new PooledProducerTask(pcf4, QUEUE1_NAME, "producer4");
1: 
1: 			final ExecutorService executor = Executors.newCachedThreadPool();
1: 
1: 			for (int i = 0; i < 4; i++) {
1: 				executor.submit(task[i]);
1: 			}
1: 
0: 			latch.await(15,TimeUnit.SECONDS);
0:             assertTrue(latch.getCount()==MAX_CONSUMERS*NUM_MESSAGE_TO_SEND);
1: 
0: 		} catch (Exception e) {
1: 			e.printStackTrace();
0: 		} finally {
1: 
1: 			container1.stop();
1: 			container1.destroy();
1: 			container1 = null;
1: 
1: 			brokerService1.stop();
1: 			brokerService1 = null;
1: 			brokerService2.stop();
1: 			brokerService2 = null;
1: 			brokerService3.stop();
1: 			brokerService3 = null;
1: 			brokerService4.stop();
1: 			brokerService4 = null;
1: 		}
1: 
1: 	}
1: 
0: 	private BrokerService createBrokerService(final String brokerName,
0: 			final String uri1, final String uri2, final String uri3,
0: 			final String uri4, final int queueLimit) throws Exception {
1: 		final BrokerService brokerService = new BrokerService();
1: 
1: 		brokerService.setBrokerName(brokerName);
1: 		brokerService.setPersistent(false);
1: 		brokerService.setUseJmx(true);
1: 
0: 		final UsageManager memoryManager = new UsageManager();
0: 		memoryManager.setLimit(100000000);
0: 		brokerService.setMemoryManager(memoryManager);
1: 
0: 		final ArrayList<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
1: 
1: 		final PolicyEntry entry = new PolicyEntry();
1: 		entry.setQueue(">");
1: 		entry.setMemoryLimit(queueLimit);
1: 		policyEntries.add(entry);
1: 
1: 		final PolicyMap policyMap = new PolicyMap();
1: 		policyMap.setPolicyEntries(policyEntries);
1: 		brokerService.setDestinationPolicy(policyMap);
1: 
1: 		final TransportConnector tConnector = new TransportConnector();
1: 		tConnector.setUri(new URI(uri1));
0: 		tConnector.setBrokerName(brokerName);
1: 		tConnector.setName(brokerName + ".transportConnector");
1: 		brokerService.addConnector(tConnector);
1: 
1: 		if (uri2 != null) {
0: 			final NetworkConnector nc = new DiscoveryNetworkConnector(new URI(
0: 					"static:" + uri2 + "," + uri3 + "," + uri4));
1: 			nc.setBridgeTempDestinations(true);
1: 			nc.setBrokerName(brokerName);
0: 			nc.setName(brokerName + ".nc");
1: 			
1: 			// When using queue limits set this to 1
1: 			nc.setPrefetchSize(1000);
1: 			nc.setNetworkTTL(1);
1: 			brokerService.addNetworkConnector(nc);
1: 		}
1: 
1: 		return brokerService;
1: 
1: 	}
1: 
0: 	public DefaultMessageListenerContainer createDefaultMessageListenerContainer(
0: 			final ConnectionFactory acf, final MessageListener listener,
0: 			final String queue) {
1: 		final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();
1: 		container.setConnectionFactory(acf);
1: 		container.setDestinationName(queue);
1: 		container.setMessageListener(listener);
1: 		container.setSessionTransacted(false);
1: 		container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
1: 		container.setConcurrentConsumers(MAX_CONSUMERS);
1: 		return container;
1: 	}
1: 
1: 	public ActiveMQConnectionFactory createConnectionFactory(final String url) {
1: 		final ActiveMQConnectionFactory acf = new ActiveMQConnectionFactory(url);
1: 		acf.setCopyMessageOnSend(false);
1: 		acf.setUseAsyncSend(false);
1: 		acf.setDispatchAsync(true);
1: 		acf.setUseCompression(false);
1: 		acf.setOptimizeAcknowledge(false);
1: 		acf.setOptimizedMessageDispatch(true);
1: 		acf.setUseAsyncSend(false);
1: 		
1: 		return acf;
1: 	}
1: 
0: 	private class TestMessageListener1 implements MessageListener {
1: 
0: 		private final long waitTime;
1: 
1: 		final AtomicInteger count = new AtomicInteger(0);
1: 		public TestMessageListener1(long waitTime) {
1: 			this.waitTime = waitTime;
1: 
1: 		}
1: 
1: 		public void onMessage(Message msg) {
1: 
1: 			try {
0: 				/*System.out.println("Listener1 Consumed message "
0: 						+ msg.getIntProperty("count") + " from "
0: 						+ msg.getStringProperty("producerName"));*/
1: 				int value = count.incrementAndGet();
0: 				if (value%1000==0){
0: 				System.out.println("Consumed message: " + value);
1: 				}
1:              
1: 				Thread.sleep(waitTime);
0:                 latch.countDown();
0: 			/*} catch (JMSException e) {
0: 				e.printStackTrace();*/
0: 			} catch (InterruptedException e) {
1: 				e.printStackTrace();
1: 			}
1: 
1: 		}
1: 	}
1: 
1: 	private class PooledProducerTask implements Runnable {
1: 
1: 		private final String queueName;
1: 
1: 		private final PooledConnectionFactory pcf;
1: 
1: 		private final String producerName;
1: 
0: 		public PooledProducerTask(final PooledConnectionFactory pcf,
0: 				final String queueName, final String producerName) {
1: 			this.pcf = pcf;
1: 			this.queueName = queueName;
1: 			this.producerName = producerName;
1: 		}
1: 
1: 		public void run() {
1: 
1: 			try {
1: 
1: 				final JmsTemplate jmsTemplate = new JmsTemplate(pcf);
1: 				jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1: 				jmsTemplate.setExplicitQosEnabled(true);
1: 				jmsTemplate.setMessageIdEnabled(false);
1: 				jmsTemplate.setMessageTimestampEnabled(false);
1: 				jmsTemplate.afterPropertiesSet();
1: 
1: 				final byte[] bytes = new byte[2048];
1: 				final Random r = new Random();
1: 				r.nextBytes(bytes);
1: 
1: 				for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
1: 					final int count = i;
1: 					jmsTemplate.send(queueName, new MessageCreator() {
1: 
0: 						public Message createMessage(Session session)
0: 								throws JMSException {
1: 
0: 							final BytesMessage message = session
0: 									.createBytesMessage();
1: 
1: 							message.writeBytes(bytes);
1: 							message.setIntProperty("count", count);
0: 							message.setStringProperty("producerName",
0: 									producerName);
1: 							return message;
1: 						}
1: 					});
1: 
0: 				//	System.out.println("PooledProducer " + producerName + " sent message: " + count);
1: 
1: 					// Thread.sleep(1000);
1: 				}
1: 
0: 			} catch (final Throwable e) {
0: 				System.err.println("Producer 1 is exiting.");
1: 				e.printStackTrace();
1: 			}
1: 		}
1: 	}
1: 
1: }
author:James Strachan
-------------------------------------------------------------------------------
commit:b19f17c
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:                 log.error("Producer 1 is exiting", e);
commit:aa1aa58
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import javax.jms.BytesMessage;
0: import javax.jms.ConnectionFactory;
0: import javax.jms.DeliveryMode;
0: import javax.jms.JMSException;
0: import javax.jms.Message;
0: import javax.jms.MessageListener;
0: import javax.jms.Session;
0: import java.net.URI;
0: import java.util.ArrayList;
0: import java.util.Random;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicInteger;
0: 
0:     private static final transient Log log = LogFactory.getLog(AMQDeadlockTestW4Brokers.class);
0:     private static final String BROKER_URL1 = "tcp://localhost:61616";
0:     private static final String BROKER_URL2 = "tcp://localhost:61617";
0:     private static final String BROKER_URL3 = "tcp://localhost:61618";
0:     private static final String BROKER_URL4 = "tcp://localhost:61619";
0:     private static final String URL1 = "tcp://localhost:61616?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
0:     private static final String URL2 = "tcp://localhost:61617?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
0:     private static final String URL3 = "tcp://localhost:61618?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
0:     private static final String URL4 = "tcp://localhost:61619?wireFormat.cacheEnabled=false&wireFormat.tightEncodingEnabled=false&wireFormat.maxInactivityDuration=30000&wireFormat.tcpNoDelayEnabled=false";
0:     private static final String QUEUE1_NAME = "test.queue.1";
0:     private static final int MAX_CONSUMERS = 5;
0:     private static final int NUM_MESSAGE_TO_SEND = 10000;
0:     private static final CountDownLatch latch = new CountDownLatch(MAX_CONSUMERS * NUM_MESSAGE_TO_SEND);
0:     @Override
0:     public void setUp() throws Exception {
0:     }
0:     @Override
0:     public void tearDown() throws Exception {
0:     }
0:     public void test4BrokerWithOutLingo() throws Exception {
0:         BrokerService brokerService1 = null;
0:         BrokerService brokerService2 = null;
0:         BrokerService brokerService3 = null;
0:         BrokerService brokerService4 = null;
0:         ActiveMQConnectionFactory acf1 = null;
0:         ActiveMQConnectionFactory acf2 = null;
0:         PooledConnectionFactory pcf1 = null;
0:         PooledConnectionFactory pcf2 = null;
0:         ActiveMQConnectionFactory acf3 = null;
0:         ActiveMQConnectionFactory acf4 = null;
0:         PooledConnectionFactory pcf3 = null;
0:         PooledConnectionFactory pcf4 = null;
0:         DefaultMessageListenerContainer container1 = null;
0:         try {
0:             //Test with and without queue limits.
0:             brokerService1 = createBrokerService("broker1", BROKER_URL1,
0:                     BROKER_URL2, BROKER_URL3, BROKER_URL4, 0 /* 10000000 */);
0:             brokerService1.start();
0:             brokerService2 = createBrokerService("broker2", BROKER_URL2,
0:                     BROKER_URL1, BROKER_URL3, BROKER_URL4, 0/* 40000000 */);
0:             brokerService2.start();
0:             brokerService3 = createBrokerService("broker3", BROKER_URL3,
0:                     BROKER_URL2, BROKER_URL1, BROKER_URL4, 0/* 10000000 */);
0:             brokerService3.start();
0:             brokerService4 = createBrokerService("broker4", BROKER_URL4,
0:                     BROKER_URL1, BROKER_URL3, BROKER_URL2, 0/* 10000000 */);
0:             brokerService4.start();
0:             final String failover1 = "failover:("
0:                     + URL1
0:                     + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
0:             final String failover2 = "failover:("
0:                     + URL2
0:                     + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
0:             final String failover3 = "failover:("
0:                     + URL3
0:                     + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
0:             final String failover4 = "failover:("
0:                     + URL4
0:                     + ")?initialReconnectDelay=10&maxReconnectDelay=30000&useExponentialBackOff=true&backOffMultiplier=2&maxReconnectAttempts=0&randomize=false";
0:             acf1 = createConnectionFactory(failover1);
0:             acf2 = createConnectionFactory(failover2);
0:             acf3 = createConnectionFactory(failover3);
0:             acf4 = createConnectionFactory(failover4);
0:             pcf1 = new PooledConnectionFactory(acf1);
0:             pcf2 = new PooledConnectionFactory(acf2);
0:             pcf3 = new PooledConnectionFactory(acf3);
0:             pcf4 = new PooledConnectionFactory(acf4);
0:             container1 = createDefaultMessageListenerContainer(acf2,
0:                     new TestMessageListener1(0), QUEUE1_NAME);
0:             container1.afterPropertiesSet();
0:             final PooledProducerTask[] task = new PooledProducerTask[4];
0:             task[0] = new PooledProducerTask(pcf1, QUEUE1_NAME, "producer1");
0:             task[1] = new PooledProducerTask(pcf2, QUEUE1_NAME, "producer2");
0:             task[2] = new PooledProducerTask(pcf3, QUEUE1_NAME, "producer3");
0:             task[3] = new PooledProducerTask(pcf4, QUEUE1_NAME, "producer4");
0:             final ExecutorService executor = Executors.newCachedThreadPool();
0:             for (int i = 0; i < 4; i++) {
0:                 executor.submit(task[i]);
0:             }
0:             latch.await(15, TimeUnit.SECONDS);
0:             assertTrue(latch.getCount() == MAX_CONSUMERS * NUM_MESSAGE_TO_SEND);
0:         }
0:         catch (Exception e) {
0:             e.printStackTrace();
0:         }
0:         finally {
0:             container1.stop();
0:             container1.destroy();
0:             container1 = null;
0:             brokerService1.stop();
0:             brokerService1 = null;
0:             brokerService2.stop();
0:             brokerService2 = null;
0:             brokerService3.stop();
0:             brokerService3 = null;
0:             brokerService4.stop();
0:             brokerService4 = null;
0:         }
0:     }
0:     private BrokerService createBrokerService(final String brokerName,
0:             final String uri1, final String uri2, final String uri3,
0:             final String uri4, final int queueLimit) throws Exception {
0:         final BrokerService brokerService = new BrokerService();
0:         brokerService.setBrokerName(brokerName);
0:         brokerService.setPersistent(false);
0:         brokerService.setUseJmx(true);
0:         final UsageManager memoryManager = new UsageManager();
0:         memoryManager.setLimit(100000000);
0:         brokerService.setMemoryManager(memoryManager);
0:         final ArrayList<PolicyEntry> policyEntries = new ArrayList<PolicyEntry>();
0:         final PolicyEntry entry = new PolicyEntry();
0:         entry.setQueue(">");
0:         entry.setMemoryLimit(queueLimit);
0:         policyEntries.add(entry);
0:         final PolicyMap policyMap = new PolicyMap();
0:         policyMap.setPolicyEntries(policyEntries);
0:         brokerService.setDestinationPolicy(policyMap);
0:         final TransportConnector tConnector = new TransportConnector();
0:         tConnector.setUri(new URI(uri1));
0:         tConnector.setBrokerName(brokerName);
0:         tConnector.setName(brokerName + ".transportConnector");
0:         brokerService.addConnector(tConnector);
0:         if (uri2 != null) {
0:             final NetworkConnector nc = new DiscoveryNetworkConnector(new URI(
0:                     "static:" + uri2 + "," + uri3 + "," + uri4));
0:             nc.setBridgeTempDestinations(true);
0:             nc.setBrokerName(brokerName);
0:             // When using queue limits set this to 1
0:             nc.setPrefetchSize(1000);
0:             nc.setNetworkTTL(1);
0:             brokerService.addNetworkConnector(nc);
0:         }
0:         return brokerService;
0:     }
0:     public DefaultMessageListenerContainer createDefaultMessageListenerContainer(
0:             final ConnectionFactory acf, final MessageListener listener,
0:             final String queue) {
0:         final DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();
0:         container.setConnectionFactory(acf);
0:         container.setDestinationName(queue);
0:         container.setMessageListener(listener);
0:         container.setSessionTransacted(false);
0:         container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
0:         container.setConcurrentConsumers(MAX_CONSUMERS);
0:         return container;
0:     }
0:     public ActiveMQConnectionFactory createConnectionFactory(final String url) {
0:         final ActiveMQConnectionFactory acf = new ActiveMQConnectionFactory(url);
0:         acf.setCopyMessageOnSend(false);
0:         acf.setUseAsyncSend(false);
0:         acf.setDispatchAsync(true);
0:         acf.setUseCompression(false);
0:         acf.setOptimizeAcknowledge(false);
0:         acf.setOptimizedMessageDispatch(true);
0:         acf.setUseAsyncSend(false);
0:         return acf;
0:     }
0:     private class TestMessageListener1 implements MessageListener {
0:         private final long waitTime;
0:         final AtomicInteger count = new AtomicInteger(0);
0:         public TestMessageListener1(long waitTime) {
0:             this.waitTime = waitTime;
0:         }
0:         public void onMessage(Message msg) {
0:             try {
0:                 /*log.info("Listener1 Consumed message "
0:                             + msg.getIntProperty("count") + " from "
0:                             + msg.getStringProperty("producerName"));*/
0:                 int value = count.incrementAndGet();
1:                 if (value % 1000 == 0) {
0:                     log.info("Consumed message: " + value);
0:                 }
0:                 Thread.sleep(waitTime);
0:                 /*} catch (JMSException e) {
0:                     e.printStackTrace();*/
0:             }
0:             catch (InterruptedException e) {
0:                 e.printStackTrace();
0:             }
0:         }
0:     }
0:     private class PooledProducerTask implements Runnable {
0:         private final String queueName;
0:         private final PooledConnectionFactory pcf;
0:         private final String producerName;
0:         public PooledProducerTask(final PooledConnectionFactory pcf,
0:                 final String queueName, final String producerName) {
0:             this.pcf = pcf;
0:             this.queueName = queueName;
0:             this.producerName = producerName;
0:         }
0:         public void run() {
0:             try {
0:                 final JmsTemplate jmsTemplate = new JmsTemplate(pcf);
0:                 jmsTemplate.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:                 jmsTemplate.setExplicitQosEnabled(true);
0:                 jmsTemplate.setMessageIdEnabled(false);
0:                 jmsTemplate.setMessageTimestampEnabled(false);
0:                 jmsTemplate.afterPropertiesSet();
0:                 final byte[] bytes = new byte[2048];
0:                 final Random r = new Random();
0:                 r.nextBytes(bytes);
0:                 for (int i = 0; i < NUM_MESSAGE_TO_SEND; i++) {
0:                     final int count = i;
0:                     jmsTemplate.send(queueName, new MessageCreator() {
0:                         public Message createMessage(Session session)
0:                                 throws JMSException {
0:                             final BytesMessage message = session
0:                                     .createBytesMessage();
0:                             message.writeBytes(bytes);
0:                             message.setIntProperty("count", count);
0:                             message.setStringProperty("producerName",
0:                                     producerName);
0:                             return message;
0:                         }
0:                     });
0:                     //	log.info("PooledProducer " + producerName + " sent message: " + count);
0:                     // Thread.sleep(1000);
0:                 }
0:             }
0:             catch (final Throwable e) {
0:                 System.err.println("Producer 1 is exiting.");
0:                 e.printStackTrace();
0:             }
0:         }
0:     }
============================================================================