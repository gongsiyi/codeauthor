1:63d62a7: /*
1:3306467:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3306467:  * contributor license agreements.  See the NOTICE file distributed with
1:3306467:  * this work for additional information regarding copyright ownership.
1:3306467:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3306467:  * (the "License"); you may not use this file except in compliance with
1:3306467:  * the License.  You may obtain a copy of the License at
1:3306467:  *
1:3306467:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3306467:  *
1:3306467:  * Unless required by applicable law or agreed to in writing, software
1:3306467:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3306467:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3306467:  * See the License for the specific language governing permissions and
1:3306467:  * limitations under the License.
1:3306467:  */
1:3306467: package org.apache.activemq.transport.amqp.protocol;
1:6ae169e: 
1:3306467: import static org.apache.activemq.transport.amqp.AmqpSupport.toLong;
1:6ae169e: 
1:3306467: import java.io.IOException;
1:3306467: import java.util.LinkedList;
1:ffee8b4: import java.util.concurrent.atomic.AtomicInteger;
1:6ae169e: 
1:ffee8b4: import org.apache.activemq.broker.region.AbstractSubscription;
1:3306467: import org.apache.activemq.command.ActiveMQDestination;
1:3306467: import org.apache.activemq.command.ActiveMQMessage;
1:3306467: import org.apache.activemq.command.ConsumerControl;
1:3306467: import org.apache.activemq.command.ConsumerId;
1:3306467: import org.apache.activemq.command.ConsumerInfo;
1:3306467: import org.apache.activemq.command.ExceptionResponse;
1:3306467: import org.apache.activemq.command.LocalTransactionId;
1:3306467: import org.apache.activemq.command.MessageAck;
1:3306467: import org.apache.activemq.command.MessageDispatch;
1:05ff52d: import org.apache.activemq.command.MessagePull;
1:3306467: import org.apache.activemq.command.RemoveInfo;
1:3306467: import org.apache.activemq.command.RemoveSubscriptionInfo;
1:3306467: import org.apache.activemq.command.Response;
1:ed26683: import org.apache.activemq.command.TransactionId;
1:3306467: import org.apache.activemq.transport.amqp.AmqpProtocolConverter;
1:3306467: import org.apache.activemq.transport.amqp.ResponseHandler;
1:3306467: import org.apache.activemq.transport.amqp.message.AutoOutboundTransformer;
1:3306467: import org.apache.activemq.transport.amqp.message.EncodedMessage;
1:3306467: import org.apache.activemq.transport.amqp.message.OutboundTransformer;
1:3306467: import org.apache.qpid.proton.amqp.messaging.Accepted;
1:3306467: import org.apache.qpid.proton.amqp.messaging.Modified;
1:3306467: import org.apache.qpid.proton.amqp.messaging.Outcome;
1:3306467: import org.apache.qpid.proton.amqp.messaging.Rejected;
1:3306467: import org.apache.qpid.proton.amqp.messaging.Released;
1:3306467: import org.apache.qpid.proton.amqp.transaction.TransactionalState;
1:25c99a6: import org.apache.qpid.proton.amqp.transport.AmqpError;
1:3306467: import org.apache.qpid.proton.amqp.transport.DeliveryState;
1:25c99a6: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
1:381a1ae: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
1:3306467: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1:3306467: import org.apache.qpid.proton.engine.Delivery;
1:88daeec: import org.apache.qpid.proton.engine.Link;
1:3306467: import org.apache.qpid.proton.engine.Sender;
1:3306467: import org.fusesource.hawtbuf.Buffer;
1:3306467: import org.slf4j.Logger;
1:3306467: import org.slf4j.LoggerFactory;
1:6ae169e: 
2:3306467: /**
1:3306467:  * An AmqpSender wraps the AMQP Sender end of a link from the remote peer
1:3306467:  * which holds the corresponding Receiver which receives messages transfered
1:3306467:  * across the link from the Broker.
1:3306467:  *
1:3306467:  * An AmqpSender is in turn a message consumer subscribed to some destination
1:3306467:  * on the broker.  As messages are dispatched to this sender that are sent on
1:3306467:  * to the remote Receiver end of the lin.
1:3306467:  */
1:3306467: public class AmqpSender extends AmqpAbstractLink<Sender> {
1:05ff52d: 
1:3306467:     private static final Logger LOG = LoggerFactory.getLogger(AmqpSender.class);
21:3306467: 
1:3306467:     private static final byte[] EMPTY_BYTE_ARRAY = new byte[] {};
1:3306467: 
1:63d62a7:     private final OutboundTransformer outboundTransformer = new AutoOutboundTransformer();
1:3306467:     private final AmqpTransferTagGenerator tagCache = new AmqpTransferTagGenerator();
1:381a1ae:     private final LinkedList<MessageDispatch> outbound = new LinkedList<>();
1:381a1ae:     private final LinkedList<Delivery> dispatchedInTx = new LinkedList<>();
1:3306467: 
1:3306467:     private final ConsumerInfo consumerInfo;
1:ffee8b4:     private AbstractSubscription subscription;
1:ffee8b4:     private AtomicInteger prefetchExtension;
1:ffee8b4:     private int currentCreditRequest;
1:ffee8b4:     private int logicalDeliveryCount; // echoes prefetch extension but from protons perspective
1:3306467:     private final boolean presettle;
1:3306467: 
1:05ff52d:     private boolean draining;
1:3306467:     private long lastDeliveredSequenceId;
1:3306467: 
1:3306467:     private Buffer currentBuffer;
1:3306467:     private Delivery currentDelivery;
1:3306467: 
1:3306467:     /**
1:3306467:      * Creates a new AmqpSender instance that manages the given Sender
1:3306467:      *
1:3306467:      * @param session
1:3306467:      *        the AmqpSession object that is the parent of this instance.
1:3306467:      * @param endpoint
1:3306467:      *        the AMQP Sender instance that this class manages.
1:3306467:      * @param consumerInfo
1:3306467:      *        the ConsumerInfo instance that holds configuration for this sender.
1:3306467:      */
1:3306467:     public AmqpSender(AmqpSession session, Sender endpoint, ConsumerInfo consumerInfo) {
1:3306467:         super(session, endpoint);
1:3306467: 
1:381a1ae:         // We don't support second so enforce it as First and let remote decide what to do
1:381a1ae:         this.endpoint.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1:381a1ae: 
1:381a1ae:         // Match what the sender mode is
1:381a1ae:         this.endpoint.setSenderSettleMode(endpoint.getRemoteSenderSettleMode());
1:381a1ae: 
1:3306467:         this.consumerInfo = consumerInfo;
1:381a1ae:         this.presettle = getEndpoint().getSenderSettleMode() == SenderSettleMode.SETTLED;
7:3306467:     }
1:db71b43: 
1:3306467:     @Override
1:3306467:     public void open() {
1:3a5f127:         if (!isClosed()) {
1:3a5f127:             session.registerSender(getConsumerId(), this);
1:ffee8b4:             subscription = (AbstractSubscription)session.getConnection().lookupPrefetchSubscription(consumerInfo);
1:ffee8b4:             prefetchExtension = subscription.getPrefetchExtension();
1:3306467:         }
1:db71b43: 
1:3306467:         super.open();
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public void detach() {
1:3306467:         if (!isClosed() && isOpened()) {
1:3306467:             RemoveInfo removeCommand = new RemoveInfo(getConsumerId());
1:3306467:             removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:3306467: 
1:83827f2:             sendToActiveMQ(removeCommand, new ResponseHandler() {
1:83827f2: 
1:83827f2:                 @Override
1:83827f2:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:83827f2:                     session.unregisterSender(getConsumerId());
1:83827f2:                     AmqpSender.super.detach();
1:83827f2:                 }
1:83827f2:             });
1:83827f2:         } else {
1:83827f2:             super.detach();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:83827f2:     @Override
1:3306467:     public void close() {
1:3306467:         if (!isClosed() && isOpened()) {
1:3306467:             RemoveInfo removeCommand = new RemoveInfo(getConsumerId());
1:3306467:             removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:3306467: 
1:83827f2:             sendToActiveMQ(removeCommand, new ResponseHandler() {
1:3306467: 
1:3306467:                 @Override
1:83827f2:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:83827f2:                     if (consumerInfo.isDurable()) {
1:83827f2:                         RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
1:83827f2:                         rsi.setConnectionId(session.getConnection().getConnectionId());
1:83827f2:                         rsi.setSubscriptionName(getEndpoint().getName());
1:83827f2:                         rsi.setClientId(session.getConnection().getClientId());
1:3306467: 
1:83827f2:                         sendToActiveMQ(rsi);
1:83827f2:                     }
1:83827f2: 
1:83827f2:                     session.unregisterSender(getConsumerId());
1:83827f2:                     AmqpSender.super.close();
1:83827f2:                 }
1:83827f2:             });
1:83827f2:         } else {
1:83827f2:             super.close();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public void flow() throws Exception {
1:88daeec:         Link endpoint = getEndpoint();
1:6ae169e:         if (LOG.isTraceEnabled()) {
1:ffee8b4:             LOG.trace("Flow: draining={}, drain={} credit={}, currentCredit={}, senderDeliveryCount={} - Sub={}",
1:88daeec:                     draining, endpoint.getDrain(),
1:ffee8b4:                     endpoint.getCredit(), currentCreditRequest, logicalDeliveryCount, subscription);
1:6ae169e:         }
1:6ae169e: 
1:ffee8b4:         final int endpointCredit = endpoint.getCredit();
1:88daeec:         if (endpoint.getDrain() && !draining) {
1:05ff52d: 
1:ffee8b4:             if (endpointCredit > 0) {
1:8448cf1:                 draining = true;
1:05ff52d: 
1:8448cf1:                 // Now request dispatch of the drain amount, we request immediate
1:8448cf1:                 // timeout and an completion message regardless so that we can know
1:8448cf1:                 // when we should marked the link as drained.
1:8448cf1:                 MessagePull pullRequest = new MessagePull();
1:8448cf1:                 pullRequest.setConsumerId(getConsumerId());
1:8448cf1:                 pullRequest.setDestination(getDestination());
1:8448cf1:                 pullRequest.setTimeout(-1);
1:8448cf1:                 pullRequest.setAlwaysSignalDone(true);
1:ffee8b4:                 pullRequest.setQuantity(endpointCredit);
1:8448cf1: 
1:ffee8b4:                 LOG.trace("Pull case -> consumer pull request quantity = {}", endpointCredit);
1:6ae169e: 
1:8448cf1:                 sendToActiveMQ(pullRequest);
1:8448cf1:             } else {
1:8448cf1:                 LOG.trace("Pull case -> sending any Queued messages and marking drained");
1:8448cf1: 
1:8448cf1:                 pumpOutbound();
1:8448cf1:                 getEndpoint().drained();
1:8448cf1:                 session.pumpProtonToSocket();
1:ffee8b4:                 currentCreditRequest = 0;
1:ffee8b4:                 logicalDeliveryCount = 0;
1:8448cf1:             }
1:ffee8b4:         } else if (endpointCredit >= 0) {
1:6ae169e: 
1:ffee8b4:             if (endpointCredit == 0 && currentCreditRequest != 0) {
1:ffee8b4:                 prefetchExtension.set(0);
1:ffee8b4:                 currentCreditRequest = 0;
1:ffee8b4:                 logicalDeliveryCount = 0;
1:ffee8b4:                 LOG.trace("Flow: credit 0 for sub:" + subscription);
1:8448cf1:             } else {
1:ffee8b4:                 int deltaToAdd = endpointCredit;
1:ffee8b4:                 int logicalCredit = currentCreditRequest - logicalDeliveryCount;
1:ffee8b4:                 if (logicalCredit > 0) {
1:ffee8b4:                     deltaToAdd -= logicalCredit;
1:6ae169e:                 } else {
1:0dd806f:                     // reset delivery counter - dispatch from broker concurrent with credit=0
1:0dd806f:                     // flow can go negative
1:ffee8b4:                     logicalDeliveryCount = 0;
1:3306467:                 }
1:0dd806f: 
1:ffee8b4:                 if (deltaToAdd > 0) {
1:ffee8b4:                     currentCreditRequest = prefetchExtension.addAndGet(deltaToAdd);
1:ffee8b4:                     subscription.wakeupDestinationsForDispatch();
1:0dd806f:                     // force dispatch of matched/pending for topics (pending messages accumulate
1:0dd806f:                     // in the sub and are dispatched on update of prefetch)
1:ffee8b4:                     subscription.setPrefetchSize(0);
1:ffee8b4:                     LOG.trace("Flow: credit addition of {} for sub {}", deltaToAdd, subscription);
1:3306467:                 }
1:3306467:             }
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public void delivery(Delivery delivery) throws Exception {
1:3306467:         MessageDispatch md = (MessageDispatch) delivery.getContext();
1:3306467:         DeliveryState state = delivery.getRemoteState();
1:3306467: 
1:3306467:         if (state instanceof TransactionalState) {
1:3306467:             TransactionalState txState = (TransactionalState) state;
1:3306467:             LOG.trace("onDelivery: TX delivery state = {}", state);
1:3306467:             if (txState.getOutcome() != null) {
1:3306467:                 Outcome outcome = txState.getOutcome();
1:3306467:                 if (outcome instanceof Accepted) {
1:0dd806f:                     TransactionId txId = new LocalTransactionId(session.getConnection().getConnectionId(), toLong(txState.getTxnId()));
1:0dd806f: 
1:0dd806f:                     // Store the message sent in this TX we might need to re-send on rollback
1:0dd806f:                     // and we need to ACK it on commit.
1:0dd806f:                     session.enlist(txId);
1:0dd806f:                     dispatchedInTx.addFirst(delivery);
1:0dd806f: 
1:3306467:                     if (!delivery.remotelySettled()) {
1:3306467:                         TransactionalState txAccepted = new TransactionalState();
1:3306467:                         txAccepted.setOutcome(Accepted.getInstance());
1:0dd806f:                         txAccepted.setTxnId(txState.getTxnId());
1:3306467: 
1:3306467:                         delivery.disposition(txAccepted);
1:3306467:                     }
1:3306467:                 }
1:3306467:             }
3:3306467:         } else {
1:3306467:             if (state instanceof Accepted) {
1:3306467:                 LOG.trace("onDelivery: accepted state = {}", state);
1:3306467:                 if (!delivery.remotelySettled()) {
1:3306467:                     delivery.disposition(new Accepted());
1:3306467:                 }
1:3306467:                 settle(delivery, MessageAck.INDIVIDUAL_ACK_TYPE);
1:3306467:             } else if (state instanceof Rejected) {
1:a9f9d4a:                 // Rejection is a terminal outcome, we poison the message for dispatch to
1:a9f9d4a:                 // the DLQ.  If a custom redelivery policy is used on the broker the message
1:a9f9d4a:                 // can still be redelivered based on the configation of that policy.
1:a9f9d4a:                 LOG.trace("onDelivery: Rejected state = {}, message poisoned.", state, md.getRedeliveryCounter());
1:a9f9d4a:                 settle(delivery, MessageAck.POSION_ACK_TYPE);
1:3306467:             } else if (state instanceof Released) {
1:3306467:                 LOG.trace("onDelivery: Released state = {}", state);
1:3306467:                 // re-deliver && don't increment the counter.
2:3306467:                 settle(delivery, -1);
1:3306467:             } else if (state instanceof Modified) {
1:3306467:                 Modified modified = (Modified) state;
1:0cfd225:                 if (Boolean.TRUE.equals(modified.getDeliveryFailed())) {
1:3306467:                     // increment delivery counter..
2:3306467:                     md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
1:3306467:                 }
1:3306467:                 LOG.trace("onDelivery: Modified state = {}, delivery count now {}", state, md.getRedeliveryCounter());
1:3306467:                 byte ackType = -1;
1:3306467:                 Boolean undeliverableHere = modified.getUndeliverableHere();
1:3306467:                 if (undeliverableHere != null && undeliverableHere) {
1:3306467:                     // receiver does not want the message..
1:3306467:                     // perhaps we should DLQ it?
1:3306467:                     ackType = MessageAck.POSION_ACK_TYPE;
1:3306467:                 }
1:3306467:                 settle(delivery, ackType);
1:3306467:             }
1:3306467:         }
1:3306467: 
1:3306467:         pumpOutbound();
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:0dd806f:     public void commit(LocalTransactionId txnId) throws Exception {
1:3306467:         if (!dispatchedInTx.isEmpty()) {
1:0dd806f:             for (final Delivery delivery : dispatchedInTx) {
1:0dd806f:                 MessageDispatch dispatch = (MessageDispatch) delivery.getContext();
1:0dd806f: 
1:0dd806f:                 MessageAck pendingTxAck = new MessageAck(dispatch, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
1:0dd806f:                 pendingTxAck.setFirstMessageId(dispatch.getMessage().getMessageId());
1:0dd806f:                 pendingTxAck.setTransactionId(txnId);
1:3306467: 
1:3306467:                 LOG.trace("Sending commit Ack to ActiveMQ: {}", pendingTxAck);
1:3306467: 
1:3306467:                 sendToActiveMQ(pendingTxAck, new ResponseHandler() {
1:3306467:                     @Override
1:3306467:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
2:3306467:                         if (response.isException()) {
1:28e7cb0:                             Throwable exception = ((ExceptionResponse) response).getException();
1:28e7cb0:                             exception.printStackTrace();
1:28e7cb0:                             getEndpoint().close();
1:0dd806f:                         } else {
1:0dd806f:                             delivery.settle();
1:3306467:                         }
1:3306467:                         session.pumpProtonToSocket();
1:3306467:                     }
1:3306467:                 });
1:3306467:             }
1:3306467: 
1:3306467:             dispatchedInTx.clear();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:0dd806f:     public void rollback(LocalTransactionId txnId) throws Exception {
1:3306467:         synchronized (outbound) {
1:3306467: 
1:3306467:             LOG.trace("Rolling back {} messages for redelivery. ", dispatchedInTx.size());
1:3306467: 
1:0dd806f:             for (Delivery delivery : dispatchedInTx) {
1:0dd806f:                 // Only settled deliveries should be re-dispatched, unsettled deliveries
1:0dd806f:                 // remain acquired on the remote end and can be accepted again in a new
1:0dd806f:                 // TX or released or rejected etc.
1:0dd806f:                 MessageDispatch dispatch = (MessageDispatch) delivery.getContext();
1:3306467:                 dispatch.getMessage().setTransactionId(null);
1:0dd806f: 
1:0dd806f:                 if (delivery.remotelySettled()) {
1:0dd806f:                     dispatch.setRedeliveryCounter(dispatch.getRedeliveryCounter() + 1);
1:0dd806f:                     outbound.addFirst(dispatch);
1:0dd806f:                 }
1:3306467:             }
1:3306467: 
1:3306467:             dispatchedInTx.clear();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:25c99a6:     /**
1:3306467:      * Event point for incoming message from ActiveMQ on this Sender's
1:3306467:      * corresponding subscription.
1:3306467:      *
1:3306467:      * @param dispatch
1:3306467:      *        the MessageDispatch to process and send across the link.
1:3306467:      *
1:3306467:      * @throws Exception if an error occurs while encoding the message for send.
1:3306467:      */
1:3306467:     public void onMessageDispatch(MessageDispatch dispatch) throws Exception {
1:3306467:         if (!isClosed()) {
1:3306467:             // Lock to prevent stepping on TX redelivery
1:3306467:             synchronized (outbound) {
1:3306467:                 outbound.addLast(dispatch);
1:3306467:             }
1:3306467:             pumpOutbound();
1:3306467:             session.pumpProtonToSocket();
1:3306467:         }
1:3306467:     }
1:3306467: 
1:3306467:     /**
1:25c99a6:      * Called when the Broker sends a ConsumerControl command to the Consumer that
1:25c99a6:      * this sender creates to obtain messages to dispatch via the sender for this
1:25c99a6:      * end of the open link.
1:25c99a6:      *
1:25c99a6:      * @param control
1:25c99a6:      *        The ConsumerControl command to process.
1:25c99a6:      */
1:25c99a6:     public void onConsumerControl(ConsumerControl control) {
1:25c99a6:         if (control.isClose()) {
1:25c99a6:             close(new ErrorCondition(AmqpError.INTERNAL_ERROR, "Receiver forcably closed"));
1:25c99a6:             session.pumpProtonToSocket();
1:25c99a6:         }
1:25c99a6:     }
1:25c99a6: 
1:3306467:     @Override
1:3306467:     public String toString() {
1:3306467:         return "AmqpSender {" + getConsumerId() + "}";
1:3306467:     }
1:3306467: 
1:3306467:     //----- Property getters and setters -------------------------------------//
1:3306467: 
1:3306467:     public ConsumerId getConsumerId() {
1:3306467:         return consumerInfo.getConsumerId();
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public ActiveMQDestination getDestination() {
1:3306467:         return consumerInfo.getDestination();
1:3306467:     }
1:3306467: 
1:3306467:     @Override
1:3306467:     public void setDestination(ActiveMQDestination destination) {
1:3306467:         consumerInfo.setDestination(destination);
1:3306467:     }
1:3306467: 
1:3306467:     //----- Internal Implementation ------------------------------------------//
1:3306467: 
1:3306467:     public void pumpOutbound() throws Exception {
1:3a5f127:         while (!isClosed()) {
1:3306467:             while (currentBuffer != null) {
1:3306467:                 int sent = getEndpoint().send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);
1:3306467:                 if (sent > 0) {
1:3306467:                     currentBuffer.moveHead(sent);
1:3306467:                     if (currentBuffer.length == 0) {
1:3306467:                         if (presettle) {
1:3306467:                             settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);
1:3306467:                         } else {
1:3306467:                             getEndpoint().advance();
1:3306467:                         }
1:3306467:                         currentBuffer = null;
1:3306467:                         currentDelivery = null;
1:6c01b64:                         logicalDeliveryCount++;
1:3306467:                     }
1:3306467:                 } else {
2:3306467:                     return;
1:3306467:                 }
1:3306467:             }
1:3306467: 
2:3306467:             if (outbound.isEmpty()) {
1:3306467:                 return;
1:3306467:             }
1:3306467: 
1:3306467:             final MessageDispatch md = outbound.removeFirst();
1:3306467:             try {
1:3306467: 
1:3306467:                 ActiveMQMessage temp = null;
1:3306467:                 if (md.getMessage() != null) {
1:9ec6ee4:                     temp = (ActiveMQMessage) md.getMessage().copy();
1:3306467:                 }
1:3306467: 
1:3306467:                 final ActiveMQMessage jms = temp;
1:3306467:                 if (jms == null) {
1:2013c6a:                     LOG.trace("Sender:[{}] browse done.", getEndpoint().getName());
1:05ff52d:                     // It's the end of browse signal in response to a MessagePull
1:05ff52d:                     getEndpoint().drained();
1:05ff52d:                     draining = false;
1:ffee8b4:                     currentCreditRequest = 0;
1:ffee8b4:                     logicalDeliveryCount = 0;
1:3306467:                 } else {
1:6ae169e:                     if (LOG.isTraceEnabled()) {
1:8448cf1:                         LOG.trace("Sender:[{}] msgId={} draining={}, drain={}, credit={}, remoteCredit={}, queued={}",
1:8448cf1:                                   getEndpoint().getName(), jms.getJMSMessageID(), draining, getEndpoint().getDrain(),
1:6ae169e:                                   getEndpoint().getCredit(), getEndpoint().getRemoteCredit(), getEndpoint().getQueued());
1:6ae169e:                     }
1:8448cf1: 
1:8448cf1:                     if (draining && getEndpoint().getCredit() == 0) {
1:8448cf1:                         LOG.trace("Sender:[{}] browse complete.", getEndpoint().getName());
1:8448cf1:                         getEndpoint().drained();
1:8448cf1:                         draining = false;
1:ffee8b4:                         currentCreditRequest = 0;
1:ffee8b4:                         logicalDeliveryCount = 0;
1:8448cf1:                     }
1:8448cf1: 
1:3306467:                     jms.setRedeliveryCounter(md.getRedeliveryCounter());
1:3306467:                     jms.setReadOnlyBody(true);
1:3306467:                     final EncodedMessage amqp = outboundTransformer.transform(jms);
1:3306467:                     if (amqp != null && amqp.getLength() > 0) {
1:3306467:                         currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());
1:3306467:                         if (presettle) {
1:3306467:                             currentDelivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);
1:8448cf1:                         } else {
1:3306467:                             final byte[] tag = tagCache.getNextTag();
1:3306467:                             currentDelivery = getEndpoint().delivery(tag, 0, tag.length);
1:3306467:                         }
1:3306467:                         currentDelivery.setContext(md);
1:63d62a7:                         currentDelivery.setMessageFormat((int) amqp.getMessageFormat());
1:3306467:                     } else {
1:3306467:                         // TODO: message could not be generated what now?
1:3306467:                     }
1:3306467:                 }
1:3306467:             } catch (Exception e) {
1:3306467:                 LOG.warn("Error detected while flushing outbound messages: {}", e.getMessage());
1:3306467:             }
1:3306467:         }
1:3306467:     }
1:8448cf1: 
1:3306467:     private void settle(final Delivery delivery, final int ackType) throws Exception {
1:3306467:         byte[] tag = delivery.getTag();
1:3306467:         if (tag != null && tag.length > 0 && delivery.remotelySettled()) {
1:3306467:             tagCache.returnTag(tag);
1:3306467:         }
1:db71b43: 
1:3306467:         if (ackType == -1) {
1:3306467:             // we are going to settle, but redeliver.. we we won't yet ack to ActiveMQ
1:3306467:             delivery.settle();
1:3306467:             onMessageDispatch((MessageDispatch) delivery.getContext());
1:3306467:         } else {
1:3306467:             MessageDispatch md = (MessageDispatch) delivery.getContext();
1:3306467:             lastDeliveredSequenceId = md.getMessage().getMessageId().getBrokerSequenceId();
1:3306467:             MessageAck ack = new MessageAck();
1:3306467:             ack.setConsumerId(getConsumerId());
1:3306467:             ack.setFirstMessageId(md.getMessage().getMessageId());
1:3306467:             ack.setLastMessageId(md.getMessage().getMessageId());
1:3306467:             ack.setMessageCount(1);
1:3306467:             ack.setAckType((byte) ackType);
1:3306467:             ack.setDestination(md.getDestination());
1:3306467:             LOG.trace("Sending Ack to ActiveMQ: {}", ack);
1:3306467: 
1:3306467:             sendToActiveMQ(ack, new ResponseHandler() {
1:3306467:                 @Override
1:3306467:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:3306467:                     if (response.isException()) {
1:3306467:                         if (response.isException()) {
2:3306467:                             Throwable exception = ((ExceptionResponse) response).getException();
2:3306467:                             exception.printStackTrace();
2:3306467:                             getEndpoint().close();
1:3306467:                         }
1:3306467:                     } else {
1:3306467:                         delivery.settle();
1:3306467:                     }
1:3306467:                     session.pumpProtonToSocket();
1:3306467:                 }
1:3306467:             });
1:3306467:         }
1:3306467:     }
1:3306467: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ec6ee4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     temp = (ActiveMQMessage) md.getMessage().copy();
commit:381a1ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
/////////////////////////////////////////////////////////////////////////
1:     private final LinkedList<MessageDispatch> outbound = new LinkedList<>();
1:     private final LinkedList<Delivery> dispatchedInTx = new LinkedList<>();
/////////////////////////////////////////////////////////////////////////
1:         // We don't support second so enforce it as First and let remote decide what to do
1:         this.endpoint.setReceiverSettleMode(ReceiverSettleMode.FIRST);
1: 
1:         // Match what the sender mode is
1:         this.endpoint.setSenderSettleMode(endpoint.getRemoteSenderSettleMode());
1: 
1:         this.presettle = getEndpoint().getSenderSettleMode() == SenderSettleMode.SETTLED;
commit:a9f9d4a
/////////////////////////////////////////////////////////////////////////
1:                 // Rejection is a terminal outcome, we poison the message for dispatch to
1:                 // the DLQ.  If a custom redelivery policy is used on the broker the message
1:                 // can still be redelivered based on the configation of that policy.
1:                 LOG.trace("onDelivery: Rejected state = {}, message poisoned.", state, md.getRedeliveryCounter());
1:                 settle(delivery, MessageAck.POSION_ACK_TYPE);
commit:0dd806f
/////////////////////////////////////////////////////////////////////////
0:     private final LinkedList<Delivery> dispatchedInTx = new LinkedList<Delivery>();
/////////////////////////////////////////////////////////////////////////
1:                     // reset delivery counter - dispatch from broker concurrent with credit=0
1:                     // flow can go negative
1: 
1:                     // force dispatch of matched/pending for topics (pending messages accumulate
1:                     // in the sub and are dispatched on update of prefetch)
/////////////////////////////////////////////////////////////////////////
1:                     TransactionId txId = new LocalTransactionId(session.getConnection().getConnectionId(), toLong(txState.getTxnId()));
1: 
1:                     // Store the message sent in this TX we might need to re-send on rollback
1:                     // and we need to ACK it on commit.
1:                     session.enlist(txId);
1:                     dispatchedInTx.addFirst(delivery);
1: 
1:                         txAccepted.setTxnId(txState.getTxnId());
/////////////////////////////////////////////////////////////////////////
1:     public void commit(LocalTransactionId txnId) throws Exception {
1:             for (final Delivery delivery : dispatchedInTx) {
1:                 MessageDispatch dispatch = (MessageDispatch) delivery.getContext();
1: 
1:                 MessageAck pendingTxAck = new MessageAck(dispatch, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
1:                 pendingTxAck.setFirstMessageId(dispatch.getMessage().getMessageId());
1:                 pendingTxAck.setTransactionId(txnId);
/////////////////////////////////////////////////////////////////////////
1:                         } else {
1:                             delivery.settle();
/////////////////////////////////////////////////////////////////////////
1:     public void rollback(LocalTransactionId txnId) throws Exception {
1:             for (Delivery delivery : dispatchedInTx) {
1:                 // Only settled deliveries should be re-dispatched, unsettled deliveries
1:                 // remain acquired on the remote end and can be accepted again in a new
1:                 // TX or released or rejected etc.
1:                 MessageDispatch dispatch = (MessageDispatch) delivery.getContext();
1: 
1:                 if (delivery.remotelySettled()) {
1:                     dispatch.setRedeliveryCounter(dispatch.getRedeliveryCounter() + 1);
1:                     outbound.addFirst(dispatch);
1:                 }
/////////////////////////////////////////////////////////////////////////
commit:63d62a7
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.activemq.transport.amqp.message.AmqpMessageSupport.JMS_AMQP_MESSAGE_FORMAT;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final OutboundTransformer outboundTransformer = new AutoOutboundTransformer();
/////////////////////////////////////////////////////////////////////////
0:                     if (!temp.getProperties().containsKey(JMS_AMQP_MESSAGE_FORMAT)) {
0:                         temp.setProperty(JMS_AMQP_MESSAGE_FORMAT, 0);
/////////////////////////////////////////////////////////////////////////
1:                         currentDelivery.setMessageFormat((int) amqp.getMessageFormat());
commit:83827f2
/////////////////////////////////////////////////////////////////////////
1:             sendToActiveMQ(removeCommand, new ResponseHandler() {
1: 
1:                 @Override
1:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                     session.unregisterSender(getConsumerId());
1:                     AmqpSender.super.detach();
1:                 }
1:             });
1:         } else {
1:             super.detach();
/////////////////////////////////////////////////////////////////////////
1:             sendToActiveMQ(removeCommand, new ResponseHandler() {
1:                 @Override
1:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                     if (consumerInfo.isDurable()) {
1:                         RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
1:                         rsi.setConnectionId(session.getConnection().getConnectionId());
1:                         rsi.setSubscriptionName(getEndpoint().getName());
1:                         rsi.setClientId(session.getConnection().getClientId());
1:                         sendToActiveMQ(rsi);
1:                     }
1: 
1:                     session.unregisterSender(getConsumerId());
1:                     AmqpSender.super.close();
1:                 }
1:             });
1:         } else {
1:             super.close();
commit:28e7cb0
/////////////////////////////////////////////////////////////////////////
1:                             Throwable exception = ((ExceptionResponse) response).getException();
1:                             exception.printStackTrace();
1:                             getEndpoint().close();
commit:db71b43
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         int newCredit = Math.max(0, getEndpoint().getCredit() - 1);
0:         LOG.trace("Sender:[{}] updating conumser prefetch:{} after delivery settled.",
0:                   getEndpoint().getName(), newCredit);
1: 
0:         ConsumerControl control = new ConsumerControl();
0:         control.setConsumerId(getConsumerId());
0:         control.setDestination(getDestination());
0:         control.setPrefetch(newCredit);
1: 
0:         sendToActiveMQ(control);
1: 
commit:8448cf1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             sendToActiveMQ(removeCommand);
/////////////////////////////////////////////////////////////////////////
0:             sendToActiveMQ(removeCommand);
/////////////////////////////////////////////////////////////////////////
0:                 sendToActiveMQ(rsi);
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("Flow: draining={}, drain={} credit={}, remoteCredit={}, queued={}",
0:                       draining, getEndpoint().getDrain(),
0:         if (getEndpoint().getDrain() && !draining) {
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("Flow: Pull case -> consumer control with prefetch (0) to control output");
0:             sendToActiveMQ(control);
0:             if (endpoint.getCredit() > 0) {
1:                 draining = true;
1:                 // Now request dispatch of the drain amount, we request immediate
1:                 // timeout and an completion message regardless so that we can know
1:                 // when we should marked the link as drained.
1:                 MessagePull pullRequest = new MessagePull();
1:                 pullRequest.setConsumerId(getConsumerId());
1:                 pullRequest.setDestination(getDestination());
1:                 pullRequest.setTimeout(-1);
1:                 pullRequest.setAlwaysSignalDone(true);
0:                 pullRequest.setQuantity(endpoint.getCredit());
0:                 LOG.trace("Pull case -> consumer pull request quantity = {}", endpoint.getCredit());
1: 
1:                 sendToActiveMQ(pullRequest);
1:             } else {
1:                 LOG.trace("Pull case -> sending any Queued messages and marking drained");
1: 
1:                 pumpOutbound();
1:                 getEndpoint().drained();
1:                 session.pumpProtonToSocket();
1:             }
1:         } else {
0:             control.setPrefetch(getEndpoint().getCredit());
0:             LOG.trace("Flow: update -> consumer control with prefetch {}", control.getPrefetch());
0:             sendToActiveMQ(control);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.trace("Sender:[{}] msgId={} draining={}, drain={}, credit={}, remoteCredit={}, queued={}",
1:                                   getEndpoint().getName(), jms.getJMSMessageID(), draining, getEndpoint().getDrain(),
1:                     if (draining && getEndpoint().getCredit() == 0) {
1:                         LOG.trace("Sender:[{}] browse complete.", getEndpoint().getName());
1:                         getEndpoint().drained();
1:                         draining = false;
1:                     } else {
0:                         LOG.trace("Sender:[{}] updating conumser prefetch:{} after dispatch.",
0:                                   getEndpoint().getName(), getEndpoint().getCredit());
1: 
0:                         ConsumerControl control = new ConsumerControl();
0:                         control.setConsumerId(getConsumerId());
0:                         control.setDestination(getDestination());
0:                         control.setPrefetch(Math.max(0, getEndpoint().getCredit() - 1));
1: 
0:                         sendToActiveMQ(control);
1:                     }
1: 
commit:6ae169e
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isTraceEnabled()) {
0:             LOG.trace("Flow: currentCredit={}, draining={}, drain={} credit={}, remoteCredit={}, queued={}",
0:                       currentCredit, draining, getEndpoint().getDrain(),
1:                       getEndpoint().getCredit(), getEndpoint().getRemoteCredit(), getEndpoint().getQueued());
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
0:             LOG.trace("Flow: Pull case -> consumer control with prefetch (0)");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:             LOG.trace("Pull case -> consumer pull request quantity = {}", currentCredit);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:             LOG.trace("Flow: update -> consumer control with prefetch (0)");
1: 
1:         } else {
0:             LOG.trace("Flow: no credit change -> no broker updates needed");
/////////////////////////////////////////////////////////////////////////
1:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("Sender:[{}] msgId={} currentCredit={}, draining={}, drain={} credit={}, remoteCredit={}, queued={}",
0:                                   getEndpoint().getName(), jms.getJMSMessageID(), currentCredit, draining, getEndpoint().getDrain(),
0:                                   getEndpoint().getCredit(), getEndpoint().getRemoteCredit(), getEndpoint().getQueued());
1:                     }
1: 
commit:ed26683
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
0:                 TransactionalState txState = (TransactionalState) remoteState;
0:                 TransactionId txId = new LocalTransactionId(session.getConnection().getConnectionId(), toLong(txState.getTxnId()));
0:                 ack.setTransactionId(txId);
0:                 // Store the message sent in this TX we might need to re-send on rollback
0:                 session.enlist(txId);
0:                 md.getMessage().setTransactionId(txId);
commit:5e7b70f
/////////////////////////////////////////////////////////////////////////
0:                     currentCredit = 0;
commit:2013c6a
/////////////////////////////////////////////////////////////////////////
1:                     LOG.trace("Sender:[{}] browse done.", getEndpoint().getName());
commit:25c99a6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.amqp.transport.AmqpError;
1: import org.apache.qpid.proton.amqp.transport.ErrorCondition;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Called when the Broker sends a ConsumerControl command to the Consumer that
1:      * this sender creates to obtain messages to dispatch via the sender for this
1:      * end of the open link.
1:      *
1:      * @param control
1:      *        The ConsumerControl command to process.
1:      */
1:     public void onConsumerControl(ConsumerControl control) {
1:         if (control.isClose()) {
1:             close(new ErrorCondition(AmqpError.INTERNAL_ERROR, "Receiver forcably closed"));
1:             session.pumpProtonToSocket();
1:         }
1:     }
1: 
commit:05ff52d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessagePull;
/////////////////////////////////////////////////////////////////////////
1:     private boolean draining;
/////////////////////////////////////////////////////////////////////////
0:         LOG.trace("Flow: drain={} credit={}, remoteCredit={}",
0:                   getEndpoint().getDrain(), getEndpoint().getCredit(), getEndpoint().getRemoteCredit());
1: 
0:         if (getEndpoint().getDrain() && (updatedCredit != currentCredit || !draining)) {
0:             currentCredit = updatedCredit >= 0 ? updatedCredit : 0;
0:             draining = true;
1: 
0:             // Revert to a pull consumer.
0:             ConsumerControl control = new ConsumerControl();
0:             control.setConsumerId(getConsumerId());
0:             control.setDestination(getDestination());
0:             control.setPrefetch(0);
0:             sendToActiveMQ(control, null);
1: 
0:             // Now request dispatch of the drain amount, we request immediate
0:             // timeout and an completion message regardless so that we can know
0:             // when we should marked the link as drained.
0:             MessagePull pullRequest = new MessagePull();
0:             pullRequest.setConsumerId(getConsumerId());
0:             pullRequest.setDestination(getDestination());
0:             pullRequest.setTimeout(-1);
0:             pullRequest.setAlwaysSignalDone(true);
0:             pullRequest.setQuantity(currentCredit);
0:             sendToActiveMQ(pullRequest, null);
0:         } else if (updatedCredit != currentCredit) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("End of browse signals endpoint drained.");
1:                     // It's the end of browse signal in response to a MessagePull
1:                     getEndpoint().drained();
1:                     draining = false;
/////////////////////////////////////////////////////////////////////////
commit:3306467
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.amqp.protocol;
1: 
1: import static org.apache.activemq.transport.amqp.AmqpSupport.toLong;
1: 
1: import java.io.IOException;
1: import java.util.LinkedList;
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ConsumerControl;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.LocalTransactionId;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.transport.amqp.AmqpProtocolConverter;
1: import org.apache.activemq.transport.amqp.ResponseHandler;
0: import org.apache.activemq.transport.amqp.message.ActiveMQJMSVendor;
1: import org.apache.activemq.transport.amqp.message.AutoOutboundTransformer;
1: import org.apache.activemq.transport.amqp.message.EncodedMessage;
1: import org.apache.activemq.transport.amqp.message.OutboundTransformer;
1: import org.apache.qpid.proton.amqp.messaging.Accepted;
1: import org.apache.qpid.proton.amqp.messaging.Modified;
1: import org.apache.qpid.proton.amqp.messaging.Outcome;
1: import org.apache.qpid.proton.amqp.messaging.Rejected;
1: import org.apache.qpid.proton.amqp.messaging.Released;
1: import org.apache.qpid.proton.amqp.transaction.TransactionalState;
1: import org.apache.qpid.proton.amqp.transport.DeliveryState;
1: import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
1: import org.apache.qpid.proton.engine.Delivery;
1: import org.apache.qpid.proton.engine.Sender;
1: import org.fusesource.hawtbuf.Buffer;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * An AmqpSender wraps the AMQP Sender end of a link from the remote peer
1:  * which holds the corresponding Receiver which receives messages transfered
1:  * across the link from the Broker.
1:  *
1:  * An AmqpSender is in turn a message consumer subscribed to some destination
1:  * on the broker.  As messages are dispatched to this sender that are sent on
1:  * to the remote Receiver end of the lin.
1:  */
1: public class AmqpSender extends AmqpAbstractLink<Sender> {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AmqpSender.class);
1: 
1:     private static final byte[] EMPTY_BYTE_ARRAY = new byte[] {};
1: 
0:     private final OutboundTransformer outboundTransformer = new AutoOutboundTransformer(ActiveMQJMSVendor.INSTANCE);
1:     private final AmqpTransferTagGenerator tagCache = new AmqpTransferTagGenerator();
0:     private final LinkedList<MessageDispatch> outbound = new LinkedList<MessageDispatch>();
0:     private final LinkedList<MessageDispatch> dispatchedInTx = new LinkedList<MessageDispatch>();
0:     private final String MESSAGE_FORMAT_KEY = outboundTransformer.getPrefixVendor() + "MESSAGE_FORMAT";
1: 
1:     private final ConsumerInfo consumerInfo;
1:     private final boolean presettle;
1: 
0:     private boolean closed;
0:     private boolean endOfBrowse;
0:     private int currentCredit;
1:     private long lastDeliveredSequenceId;
1: 
1:     private Buffer currentBuffer;
1:     private Delivery currentDelivery;
1: 
1:     /**
1:      * Creates a new AmqpSender instance that manages the given Sender
1:      *
1:      * @param session
1:      *        the AmqpSession object that is the parent of this instance.
1:      * @param endpoint
1:      *        the AMQP Sender instance that this class manages.
1:      * @param consumerInfo
1:      *        the ConsumerInfo instance that holds configuration for this sender.
1:      */
1:     public AmqpSender(AmqpSession session, Sender endpoint, ConsumerInfo consumerInfo) {
1:         super(session, endpoint);
1: 
0:         this.currentCredit = endpoint.getRemoteCredit();
1:         this.consumerInfo = consumerInfo;
0:         this.presettle = getEndpoint().getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
1:     }
1: 
1:     @Override
1:     public void open() {
0:         if (!closed) {
0:             session.regosterSender(getConsumerId(), this);
1:         }
1: 
1:         super.open();
1:     }
1: 
1:     @Override
1:     public void detach() {
1:         if (!isClosed() && isOpened()) {
1:             RemoveInfo removeCommand = new RemoveInfo(getConsumerId());
1:             removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
0:             sendToActiveMQ(removeCommand, null);
1: 
0:             session.unregisterSender(getConsumerId());
1:         }
1: 
0:         super.detach();
1:     }
1: 
1:     @Override
1:     public void close() {
1:         if (!isClosed() && isOpened()) {
1:             RemoveInfo removeCommand = new RemoveInfo(getConsumerId());
1:             removeCommand.setLastDeliveredSequenceId(lastDeliveredSequenceId);
0:             sendToActiveMQ(removeCommand, null);
1: 
0:             if (consumerInfo.isDurable()) {
0:                 RemoveSubscriptionInfo rsi = new RemoveSubscriptionInfo();
0:                 rsi.setConnectionId(session.getConnection().getConnectionId());
0:                 rsi.setSubscriptionName(getEndpoint().getName());
0:                 rsi.setClientId(session.getConnection().getClientId());
1: 
0:                 sendToActiveMQ(rsi, null);
1: 
0:                 session.unregisterSender(getConsumerId());
1:             }
1:         }
1: 
0:         super.close();
1:     }
1: 
1:     @Override
1:     public void flow() throws Exception {
0:         int updatedCredit = getEndpoint().getCredit();
1: 
0:         if (updatedCredit != currentCredit) {
0:             currentCredit = updatedCredit >= 0 ? updatedCredit : 0;
0:             ConsumerControl control = new ConsumerControl();
0:             control.setConsumerId(getConsumerId());
0:             control.setDestination(getDestination());
0:             control.setPrefetch(currentCredit);
0:             sendToActiveMQ(control, null);
1:         }
1: 
0:         drainCheck();
1:     }
1: 
1:     @Override
1:     public void delivery(Delivery delivery) throws Exception {
1:         MessageDispatch md = (MessageDispatch) delivery.getContext();
1:         DeliveryState state = delivery.getRemoteState();
1: 
1:         if (state instanceof TransactionalState) {
1:             TransactionalState txState = (TransactionalState) state;
1:             LOG.trace("onDelivery: TX delivery state = {}", state);
1:             if (txState.getOutcome() != null) {
1:                 Outcome outcome = txState.getOutcome();
1:                 if (outcome instanceof Accepted) {
1:                     if (!delivery.remotelySettled()) {
1:                         TransactionalState txAccepted = new TransactionalState();
1:                         txAccepted.setOutcome(Accepted.getInstance());
0:                         txAccepted.setTxnId(((TransactionalState) state).getTxnId());
1: 
1:                         delivery.disposition(txAccepted);
1:                     }
0:                     settle(delivery, MessageAck.DELIVERED_ACK_TYPE);
1:                 }
1:             }
1:         } else {
1:             if (state instanceof Accepted) {
1:                 LOG.trace("onDelivery: accepted state = {}", state);
1:                 if (!delivery.remotelySettled()) {
1:                     delivery.disposition(new Accepted());
1:                 }
1:                 settle(delivery, MessageAck.INDIVIDUAL_ACK_TYPE);
1:             } else if (state instanceof Rejected) {
0:                 // re-deliver /w incremented delivery counter.
1:                 md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
0:                 LOG.trace("onDelivery: Rejected state = {}, delivery count now {}", state, md.getRedeliveryCounter());
1:                 settle(delivery, -1);
1:             } else if (state instanceof Released) {
1:                 LOG.trace("onDelivery: Released state = {}", state);
1:                 // re-deliver && don't increment the counter.
1:                 settle(delivery, -1);
1:             } else if (state instanceof Modified) {
1:                 Modified modified = (Modified) state;
0:                 if (modified.getDeliveryFailed()) {
1:                     // increment delivery counter..
1:                     md.setRedeliveryCounter(md.getRedeliveryCounter() + 1);
1:                 }
1:                 LOG.trace("onDelivery: Modified state = {}, delivery count now {}", state, md.getRedeliveryCounter());
1:                 byte ackType = -1;
1:                 Boolean undeliverableHere = modified.getUndeliverableHere();
1:                 if (undeliverableHere != null && undeliverableHere) {
1:                     // receiver does not want the message..
1:                     // perhaps we should DLQ it?
1:                     ackType = MessageAck.POSION_ACK_TYPE;
1:                 }
1:                 settle(delivery, ackType);
1:             }
1:         }
1: 
1:         pumpOutbound();
1:     }
1: 
1:     @Override
0:     public void commit() throws Exception {
1:         if (!dispatchedInTx.isEmpty()) {
0:             for (MessageDispatch md : dispatchedInTx) {
0:                 MessageAck pendingTxAck = new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1);
0:                 pendingTxAck.setFirstMessageId(md.getMessage().getMessageId());
0:                 pendingTxAck.setTransactionId(md.getMessage().getTransactionId());
1: 
1:                 LOG.trace("Sending commit Ack to ActiveMQ: {}", pendingTxAck);
1: 
1:                 sendToActiveMQ(pendingTxAck, new ResponseHandler() {
1:                     @Override
1:                     public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                         if (response.isException()) {
1:                             if (response.isException()) {
1:                                 Throwable exception = ((ExceptionResponse) response).getException();
1:                                 exception.printStackTrace();
1:                                 getEndpoint().close();
1:                             }
1:                         }
1:                         session.pumpProtonToSocket();
1:                     }
1:                 });
1:             }
1: 
1:             dispatchedInTx.clear();
1:         }
1:     }
1: 
1:     @Override
0:     public void rollback() throws Exception {
1:         synchronized (outbound) {
1: 
1:             LOG.trace("Rolling back {} messages for redelivery. ", dispatchedInTx.size());
1: 
0:             for (MessageDispatch dispatch : dispatchedInTx) {
0:                 dispatch.setRedeliveryCounter(dispatch.getRedeliveryCounter() + 1);
1:                 dispatch.getMessage().setTransactionId(null);
0:                 outbound.addFirst(dispatch);
1:             }
1: 
1:             dispatchedInTx.clear();
1:         }
1:     }
1: 
1:     /**
1:      * Event point for incoming message from ActiveMQ on this Sender's
1:      * corresponding subscription.
1:      *
1:      * @param dispatch
1:      *        the MessageDispatch to process and send across the link.
1:      *
1:      * @throws Exception if an error occurs while encoding the message for send.
1:      */
1:     public void onMessageDispatch(MessageDispatch dispatch) throws Exception {
1:         if (!isClosed()) {
1:             // Lock to prevent stepping on TX redelivery
1:             synchronized (outbound) {
1:                 outbound.addLast(dispatch);
1:             }
1:             pumpOutbound();
1:             session.pumpProtonToSocket();
1:         }
1:     }
1: 
1:     @Override
1:     public String toString() {
1:         return "AmqpSender {" + getConsumerId() + "}";
1:     }
1: 
1:     //----- Property getters and setters -------------------------------------//
1: 
1:     public ConsumerId getConsumerId() {
1:         return consumerInfo.getConsumerId();
1:     }
1: 
1:     @Override
1:     public ActiveMQDestination getDestination() {
1:         return consumerInfo.getDestination();
1:     }
1: 
1:     @Override
1:     public void setDestination(ActiveMQDestination destination) {
1:         consumerInfo.setDestination(destination);
1:     }
1: 
1:     //----- Internal Implementation ------------------------------------------//
1: 
1:     public void pumpOutbound() throws Exception {
0:         while (!closed) {
1:             while (currentBuffer != null) {
1:                 int sent = getEndpoint().send(currentBuffer.data, currentBuffer.offset, currentBuffer.length);
1:                 if (sent > 0) {
1:                     currentBuffer.moveHead(sent);
1:                     if (currentBuffer.length == 0) {
1:                         if (presettle) {
1:                             settle(currentDelivery, MessageAck.INDIVIDUAL_ACK_TYPE);
1:                         } else {
1:                             getEndpoint().advance();
1:                         }
1:                         currentBuffer = null;
1:                         currentDelivery = null;
1:                     }
1:                 } else {
1:                     return;
1:                 }
1:             }
1: 
1:             if (outbound.isEmpty()) {
1:                 return;
1:             }
1: 
1:             final MessageDispatch md = outbound.removeFirst();
1:             try {
1: 
1:                 ActiveMQMessage temp = null;
1:                 if (md.getMessage() != null) {
1: 
0:                     // Topics can dispatch the same Message to more than one consumer
0:                     // so we must copy to prevent concurrent read / write to the same
0:                     // message object.
0:                     if (md.getDestination().isTopic()) {
0:                         synchronized (md.getMessage()) {
0:                             temp = (ActiveMQMessage) md.getMessage().copy();
1:                         }
1:                     } else {
0:                         temp = (ActiveMQMessage) md.getMessage();
1:                     }
1: 
0:                     if (!temp.getProperties().containsKey(MESSAGE_FORMAT_KEY)) {
0:                         temp.setProperty(MESSAGE_FORMAT_KEY, 0);
1:                     }
1:                 }
1: 
1:                 final ActiveMQMessage jms = temp;
1:                 if (jms == null) {
0:                     // It's the end of browse signal.
0:                     endOfBrowse = true;
0:                     drainCheck();
1:                 } else {
1:                     jms.setRedeliveryCounter(md.getRedeliveryCounter());
1:                     jms.setReadOnlyBody(true);
1:                     final EncodedMessage amqp = outboundTransformer.transform(jms);
1:                     if (amqp != null && amqp.getLength() > 0) {
1:                         currentBuffer = new Buffer(amqp.getArray(), amqp.getArrayOffset(), amqp.getLength());
1:                         if (presettle) {
1:                             currentDelivery = getEndpoint().delivery(EMPTY_BYTE_ARRAY, 0, 0);
1:                         } else {
1:                             final byte[] tag = tagCache.getNextTag();
1:                             currentDelivery = getEndpoint().delivery(tag, 0, tag.length);
1:                         }
1:                         currentDelivery.setContext(md);
1:                     } else {
1:                         // TODO: message could not be generated what now?
1:                     }
1:                 }
1:             } catch (Exception e) {
1:                 LOG.warn("Error detected while flushing outbound messages: {}", e.getMessage());
1:             }
1:         }
1:     }
1: 
1:     private void settle(final Delivery delivery, final int ackType) throws Exception {
1:         byte[] tag = delivery.getTag();
1:         if (tag != null && tag.length > 0 && delivery.remotelySettled()) {
1:             tagCache.returnTag(tag);
1:         }
1: 
1:         if (ackType == -1) {
1:             // we are going to settle, but redeliver.. we we won't yet ack to ActiveMQ
1:             delivery.settle();
1:             onMessageDispatch((MessageDispatch) delivery.getContext());
1:         } else {
1:             MessageDispatch md = (MessageDispatch) delivery.getContext();
1:             lastDeliveredSequenceId = md.getMessage().getMessageId().getBrokerSequenceId();
1:             MessageAck ack = new MessageAck();
1:             ack.setConsumerId(getConsumerId());
1:             ack.setFirstMessageId(md.getMessage().getMessageId());
1:             ack.setLastMessageId(md.getMessage().getMessageId());
1:             ack.setMessageCount(1);
1:             ack.setAckType((byte) ackType);
1:             ack.setDestination(md.getDestination());
1: 
0:             DeliveryState remoteState = delivery.getRemoteState();
0:             if (remoteState != null && remoteState instanceof TransactionalState) {
0:                 TransactionalState s = (TransactionalState) remoteState;
0:                 long txid = toLong(s.getTxnId());
0:                 LocalTransactionId localTxId = new LocalTransactionId(session.getConnection().getConnectionId(), txid);
0:                 ack.setTransactionId(localTxId);
1: 
0:                 // Store the message sent in this TX we might need to
0:                 // re-send on rollback
0:                 md.getMessage().setTransactionId(localTxId);
0:                 dispatchedInTx.addFirst(md);
1:             }
1: 
1:             LOG.trace("Sending Ack to ActiveMQ: {}", ack);
1: 
1:             sendToActiveMQ(ack, new ResponseHandler() {
1:                 @Override
1:                 public void onResponse(AmqpProtocolConverter converter, Response response) throws IOException {
1:                     if (response.isException()) {
1:                         if (response.isException()) {
1:                             Throwable exception = ((ExceptionResponse) response).getException();
1:                             exception.printStackTrace();
1:                             getEndpoint().close();
1:                         }
1:                     } else {
1:                         delivery.settle();
1:                     }
1:                     session.pumpProtonToSocket();
1:                 }
1:             });
1:         }
1:     }
1: 
0:     private void drainCheck() {
0:         // If we are a browser.. lets not say we are drained until
0:         // we hit the end of browse message.
0:         if (consumerInfo.isBrowser() && !endOfBrowse) {
1:             return;
1:         }
1: 
1:         if (outbound.isEmpty()) {
0:             getEndpoint().drained();
1:         }
1:     }
1: }
author:gtully
-------------------------------------------------------------------------------
commit:ed88600
/////////////////////////////////////////////////////////////////////////
0:                     temp = (ActiveMQMessage) md.getMessage();
0:                         temp = (ActiveMQMessage) md.getMessage().copy();
commit:6c01b64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         logicalDeliveryCount++;
commit:ffee8b4
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
1: import org.apache.activemq.broker.region.AbstractSubscription;
/////////////////////////////////////////////////////////////////////////
1:     private AbstractSubscription subscription;
1:     private AtomicInteger prefetchExtension;
1:     private int currentCreditRequest;
1:     private int logicalDeliveryCount; // echoes prefetch extension but from protons perspective
/////////////////////////////////////////////////////////////////////////
1:             subscription = (AbstractSubscription)session.getConnection().lookupPrefetchSubscription(consumerInfo);
1:             prefetchExtension = subscription.getPrefetchExtension();
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("Flow: draining={}, drain={} credit={}, currentCredit={}, senderDeliveryCount={} - Sub={}",
1:                     endpoint.getCredit(), currentCreditRequest, logicalDeliveryCount, subscription);
1:         final int endpointCredit = endpoint.getCredit();
1:             if (endpointCredit > 0) {
/////////////////////////////////////////////////////////////////////////
1:                 pullRequest.setQuantity(endpointCredit);
1:                 LOG.trace("Pull case -> consumer pull request quantity = {}", endpointCredit);
/////////////////////////////////////////////////////////////////////////
1:                 currentCreditRequest = 0;
1:                 logicalDeliveryCount = 0;
1:         } else if (endpointCredit >= 0) {
1:             if (endpointCredit == 0 && currentCreditRequest != 0) {
0: 
1:                 prefetchExtension.set(0);
1:                 currentCreditRequest = 0;
1:                 logicalDeliveryCount = 0;
1:                 LOG.trace("Flow: credit 0 for sub:" + subscription);
0: 
0:             } else {
0: 
1:                 int deltaToAdd = endpointCredit;
1:                 int logicalCredit = currentCreditRequest - logicalDeliveryCount;
1:                 if (logicalCredit > 0) {
1:                     deltaToAdd -= logicalCredit;
0:                 } else {
0:                     // reset delivery counter - dispatch from broker concurrent with credit=0 flow can go negative
1:                     logicalDeliveryCount = 0;
0:                 }
1:                 if (deltaToAdd > 0) {
1:                     currentCreditRequest = prefetchExtension.addAndGet(deltaToAdd);
1:                     subscription.wakeupDestinationsForDispatch();
0:                     // force dispatch of matched/pending for topics (pending messages accumulate in the sub and are dispatched on update of prefetch)
1:                     subscription.setPrefetchSize(0);
1:                     LOG.trace("Flow: credit addition of {} for sub {}", deltaToAdd, subscription);
/////////////////////////////////////////////////////////////////////////
0:         logicalDeliveryCount++;
/////////////////////////////////////////////////////////////////////////
1:                     currentCreditRequest = 0;
1:                     logicalDeliveryCount = 0;
/////////////////////////////////////////////////////////////////////////
1:                         currentCreditRequest = 0;
1:                         logicalDeliveryCount = 0;
/////////////////////////////////////////////////////////////////////////
commit:88daeec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.qpid.proton.engine.Link;
/////////////////////////////////////////////////////////////////////////
0:     private Subscription subscription;
/////////////////////////////////////////////////////////////////////////
0:             subscription = session.getConnection().lookupPrefetchSubscription(consumerInfo);
/////////////////////////////////////////////////////////////////////////
1:         Link endpoint = getEndpoint();
0:             LOG.trace("Flow: draining={}, drain={} credit={}, remoteCredit={}, queued={}, unsettled={}",
1:                     draining, endpoint.getDrain(),
0:                     endpoint.getCredit(), endpoint.getRemoteCredit(), endpoint.getQueued(), endpoint.getUnsettled());
1:         if (endpoint.getDrain() && !draining) {
/////////////////////////////////////////////////////////////////////////
0: 
0:             int remoteCredit = endpoint.getRemoteCredit();
0:             if (remoteCredit > 0 && subscription != null) {
0:                 // ensure prefetch exceeds credit + inflight
0:                 if (remoteCredit + endpoint.getUnsettled() + endpoint.getQueued() > subscription.getPrefetchSize()) {
0:                     LOG.trace("Adding dispatched size to credit for sub: " + subscription);
0:                     remoteCredit += subscription.getDispatchedQueueSize();
0:                 }
0:             }
0:             control.setPrefetch(remoteCredit);
author:Robert Gemmell
-------------------------------------------------------------------------------
commit:0cfd225
/////////////////////////////////////////////////////////////////////////
1:                 if (Boolean.TRUE.equals(modified.getDeliveryFailed())) {
commit:3a5f127
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (!isClosed()) {
1:             session.registerSender(getConsumerId(), this);
/////////////////////////////////////////////////////////////////////////
0: 
0:             session.unregisterSender(getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:         while (!isClosed()) {
============================================================================