2:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b0c2a40:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
5:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
2:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.store.jdbc;
1:d29ca2a: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.sql.SQLException;
1:cb96783: import java.util.Arrays;
1:64f3492: import java.util.HashSet;
1:cb96783: import java.util.Iterator;
1:1f816d4: import java.util.LinkedHashMap;
1:629bc81: import java.util.Map;
1:64f3492: import java.util.Set;
1:629bc81: import java.util.concurrent.ConcurrentHashMap;
1:1f816d4: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:f812e34: 
1:c3801c4: import org.apache.activemq.ActiveMQMessageAudit;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:1f816d4: import org.apache.activemq.command.ActiveMQDestination;
1:d29ca2a: import org.apache.activemq.command.ActiveMQTopic;
1:d29ca2a: import org.apache.activemq.command.Message;
1:3432a75: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:d29ca2a: import org.apache.activemq.command.SubscriptionInfo;
1:d29ca2a: import org.apache.activemq.store.MessageRecoveryListener;
1:cf3d419: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
1:d29ca2a: import org.apache.activemq.store.TopicMessageStore;
1:88acb0e: import org.apache.activemq.util.ByteSequence;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:88acb0e: import org.apache.activemq.wireformat.WireFormat;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: /**
1:734fb7d:  *
1:d29ca2a:  */
1:d29ca2a: public class JDBCTopicMessageStore extends JDBCMessageStore implements TopicMessageStore {
1:f812e34: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JDBCTopicMessageStore.class);
1:8191f19:     private Map<String, LastRecovered> subscriberLastRecoveredMap = new ConcurrentHashMap<String, LastRecovered>();
1:64f3492:     private Set<String> pendingCompletion = new HashSet<String>();
1:d29ca2a: 
1:1f816d4:     public static final String PROPERTY_SEQUENCE_ID_CACHE_SIZE = "org.apache.activemq.store.jdbc.SEQUENCE_ID_CACHE_SIZE";
1:1f816d4:     private static final int SEQUENCE_ID_CACHE_SIZE = Integer.parseInt(System.getProperty(
1:1f816d4:                PROPERTY_SEQUENCE_ID_CACHE_SIZE, "1000"), 10);
1:1f816d4:     private final ReentrantReadWriteLock sequenceIdCacheSizeLock = new ReentrantReadWriteLock();
1:1f816d4:     private Map<MessageId, long[]> sequenceIdCache = new LinkedHashMap<MessageId, long[]>() {
1:734fb7d:          @Override
1:734fb7d:         protected boolean removeEldestEntry(Map.Entry<MessageId, long[]> eldest) {
1:1f816d4:            return size() > SEQUENCE_ID_CACHE_SIZE;
1:d29ca2a:         }
1:1f816d4:     };
1:d29ca2a: 
1:d29ca2a: 
1:b6f63b0:     public JDBCTopicMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQTopic topic, ActiveMQMessageAudit audit) throws IOException {
1:c3801c4:         super(persistenceAdapter, adapter, wireFormat, topic, audit);
1:1f816d4:     }
1:1f816d4: 
1:734fb7d:     @Override
1:3432a75:     public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId, MessageAck ack) throws IOException {
1:3432a75:         if (ack != null && ack.isUnmatchedAck()) {
1:3ddb71c:             if (LOG.isTraceEnabled()) {
1:3432a75:                 LOG.trace("ignoring unmatched selector ack for: " + messageId + ", cleanup will get to this message after subsequent acks.");
1:cb96783:             }
1:3432a75:             return;
1:cb96783:         }
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:d29ca2a:         try {
1:1f816d4:             long[] res = getCachedStoreSequenceId(c, destination, messageId);
1:fa4481c:             if (this.isPrioritizedMessages()) {
1:64f3492:                 adapter.doSetLastAckWithPriority(c, destination, context != null ? context.getXid() : null, clientId, subscriptionName, res[0], res[1]);
1:fa4481c:             } else {
1:64f3492:                 adapter.doSetLastAck(c, destination, context != null ? context.getXid() : null, clientId, subscriptionName, res[0], res[1]);
1:cb96783:             }
1:3432a75:             if (LOG.isTraceEnabled()) {
1:6519c3e:                 LOG.trace(clientId + ":" + subscriptionName + " ack, seq: " + res[0] + ", priority: " + res[1] + " mid:" + messageId);
1:3ddb71c:             }
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:f812e34:             throw IOExceptionSupport.create("Failed to store acknowledgment for: " + clientId + " on message " + messageId + " in container: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:64f3492:     public long[] getCachedStoreSequenceId(TransactionContext transactionContext, ActiveMQDestination destination, MessageId messageId) throws SQLException, IOException {
1:1f816d4:         long[] val = null;
1:1f816d4:         sequenceIdCacheSizeLock.readLock().lock();
1:1f816d4:         try {
1:1f816d4:             val = sequenceIdCache.get(messageId);
1:1f816d4:         } finally {
1:1f816d4:             sequenceIdCacheSizeLock.readLock().unlock();
1:d29ca2a:         }
1:1f816d4:         if (val == null) {
1:1f816d4:             val = adapter.getStoreSequenceId(transactionContext, destination, messageId);
1:d29ca2a:         }
1:1f816d4:         return val;
1:1f816d4:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:7f5213b:      * @throws Exception
1:d29ca2a:      */
1:734fb7d:     @Override
1:f812e34:     public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener) throws Exception {
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:d29ca2a:         try {
1:f812e34:             adapter.doRecoverSubscription(c, destination, clientId, subscriptionName, new JDBCMessageRecoveryListener() {
1:734fb7d:                 @Override
1:f812e34:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
2:f812e34:                     Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:f812e34:                     msg.getMessageId().setBrokerSequenceId(sequenceId);
1:f812e34:                     return listener.recoverMessage(msg);
1:f812e34:                 }
1:f812e34: 
1:734fb7d:                 @Override
1:f812e34:                 public boolean recoverMessageReference(String reference) throws Exception {
2:f812e34:                     return listener.recoverMessageReference(new MessageId(reference));
1:d8cf54b:                 }
1:d8cf54b: 
2:f812e34:             });
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to recover subscription: " + clientId + ". Reason: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:f812e34:         }
1:d29ca2a:     }
1:f812e34: 
1:cb96783:     private class LastRecovered implements Iterable<LastRecoveredEntry> {
1:cb96783:         LastRecoveredEntry[] perPriority = new LastRecoveredEntry[10];
1:cb96783:         LastRecovered() {
1:cb96783:             for (int i=0; i<perPriority.length; i++) {
1:cb96783:                 perPriority[i] = new LastRecoveredEntry(i);
1:d29ca2a:             }
1:1f816d4:         }
1:d29ca2a: 
1:cb96783:         public void updateStored(long sequence, int priority) {
1:cb96783:             perPriority[priority].stored = sequence;
1:1f816d4:         }
1:1f816d4: 
1:cb96783:         public LastRecoveredEntry defaultPriority() {
1:ea70e82:             return perPriority[0];
1:cb96783:         }
1:1f816d4: 
1:734fb7d:         @Override
1:8191f19:         public String toString() {
1:cb96783:             return Arrays.deepToString(perPriority);
1:cb96783:         }
1:cb96783: 
1:734fb7d:         @Override
1:cb96783:         public Iterator<LastRecoveredEntry> iterator() {
1:cb96783:             return new PriorityIterator();
1:cb96783:         }
1:cb96783: 
1:cb96783:         class PriorityIterator implements Iterator<LastRecoveredEntry> {
1:cb96783:             int current = 9;
1:734fb7d:             @Override
1:cb96783:             public boolean hasNext() {
1:cb96783:                 for (int i=current; i>=0; i--) {
1:cb96783:                     if (perPriority[i].hasMessages()) {
1:cb96783:                         current = i;
1:f812e34:                         return true;
1:f812e34:                     }
1:cb96783:                 }
1:f812e34:                 return false;
1:d8cf54b:             }
1:d8cf54b: 
1:734fb7d:             @Override
1:cb96783:             public LastRecoveredEntry next() {
1:cb96783:                 return perPriority[current];
1:cb96783:             }
1:cb96783: 
1:734fb7d:             @Override
1:cb96783:             public void remove() {
1:cb96783:                 throw new RuntimeException("not implemented");
1:cb96783:             }
1:cb96783:         }
1:cb96783:     }
1:cb96783: 
1:cb96783:     private class LastRecoveredEntry {
1:cb96783:         final int priority;
1:cb96783:         long recovered = 0;
1:cb96783:         long stored = Integer.MAX_VALUE;
1:cb96783: 
1:cb96783:         public LastRecoveredEntry(int priority) {
1:cb96783:             this.priority = priority;
1:cb96783:         }
1:cb96783: 
1:734fb7d:         @Override
1:cb96783:         public String toString() {
1:cb96783:             return priority + "-" + stored + ":" + recovered;
1:cb96783:         }
1:cb96783: 
1:cb96783:         public void exhausted() {
1:cb96783:             stored = recovered;
1:cb96783:         }
1:cb96783: 
1:cb96783:         public boolean hasMessages() {
1:cb96783:             return stored > recovered;
1:cb96783:         }
1:cb96783:     }
1:cb96783: 
1:cb96783:     class LastRecoveredAwareListener implements JDBCMessageRecoveryListener {
1:cb96783:         final MessageRecoveryListener delegate;
1:cb96783:         final int maxMessages;
1:cb96783:         LastRecoveredEntry lastRecovered;
1:cb96783:         int recoveredCount;
1:cb96783:         int recoveredMarker;
1:cb96783: 
1:cb96783:         public LastRecoveredAwareListener(MessageRecoveryListener delegate, int maxMessages) {
1:cb96783:             this.delegate = delegate;
1:cb96783:             this.maxMessages = maxMessages;
1:cb96783:         }
1:cb96783: 
1:734fb7d:         @Override
1:f812e34:         public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
1:fe31092:             if (delegate.hasSpace() && recoveredCount < maxMessages) {
1:88acb0e:                 Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
1:f812e34:                 msg.getMessageId().setBrokerSequenceId(sequenceId);
1:fe31092:                 lastRecovered.recovered = sequenceId;
1:cb96783:                 if (delegate.recoverMessage(msg)) {
1:cb96783:                     recoveredCount++;
2:cb96783:                     return true;
1:cb96783:                 }
1:cb96783:             }
2:cb96783:             return false;
1:cb96783:         }
1:cb96783: 
1:734fb7d:         @Override
1:f812e34:         public boolean recoverMessageReference(String reference) throws Exception {
1:cb96783:             return delegate.recoverMessageReference(new MessageId(reference));
1:cb96783:         }
1:cb96783: 
1:cb96783:         public void setLastRecovered(LastRecoveredEntry lastRecovered) {
1:cb96783:             this.lastRecovered = lastRecovered;
1:cb96783:             recoveredMarker = recoveredCount;
1:cb96783:         }
1:cb96783: 
1:cb96783:         public boolean complete() {
1:cb96783:             return  !delegate.hasSpace() || recoveredCount == maxMessages;
1:cb96783:         }
1:cb96783: 
1:cb96783:         public boolean stalled() {
1:cb96783:             return recoveredMarker == recoveredCount;
1:cb96783:         }
1:8191f19:     }
1:cb96783: 
1:734fb7d:     @Override
1:f812e34:     public synchronized void recoverNextMessages(final String clientId, final String subscriptionName, final int maxReturned, final MessageRecoveryListener listener)
1:f812e34:             throws Exception {
1:cb96783:         //Duration duration = new Duration("recoverNextMessages");
1:f812e34:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:f812e34: 
1:8191f19:         String key = getSubscriptionKey(clientId, subscriptionName);
1:8191f19:         if (!subscriberLastRecoveredMap.containsKey(key)) {
1:8191f19:            subscriberLastRecoveredMap.put(key, new LastRecovered());
1:f812e34:         }
1:734fb7d:         final LastRecovered lastRecovered = subscriberLastRecoveredMap.get(key);
1:cb96783:         LastRecoveredAwareListener recoveredAwareListener = new LastRecoveredAwareListener(listener, maxReturned);
1:f812e34:         try {
1:3432a75:             if (LOG.isTraceEnabled()) {
1:64f3492:                 LOG.trace(this + ", " + key + " existing last recovered: " + lastRecovered);
1:f812e34:             }
1:4679c8a:             if (isPrioritizedMessages()) {
1:cb96783:                 Iterator<LastRecoveredEntry> it = lastRecovered.iterator();
1:cb96783:                 for ( ; it.hasNext() && !recoveredAwareListener.complete(); ) {
1:cb96783:                     LastRecoveredEntry entry = it.next();
1:cb96783:                     recoveredAwareListener.setLastRecovered(entry);
1:cb96783:                     //Duration microDuration = new Duration("recoverNextMessages:loop");
1:cb96783:                     adapter.doRecoverNextMessagesWithPriority(c, destination, clientId, subscriptionName,
1:cb96783:                         entry.recovered, entry.priority, maxReturned, recoveredAwareListener);
1:fe31092:                     //microDuration.end(new String(entry + " recoveredCount:" + recoveredAwareListener.recoveredCount));
1:cb96783:                     if (recoveredAwareListener.stalled()) {
1:cb96783:                         if (recoveredAwareListener.complete()) {
1:cb96783:                             break;
1:cb96783:                         } else {
1:cb96783:                             entry.exhausted();
1:cb96783:                         }
1:cb96783:                     }
1:cb96783:                 }
1:4679c8a:             } else {
1:cb96783:                 LastRecoveredEntry last = lastRecovered.defaultPriority();
1:cb96783:                 recoveredAwareListener.setLastRecovered(last);
1:4679c8a:                 adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName,
1:cb96783:                         last.recovered, 0, maxReturned, recoveredAwareListener);
1:8191f19:             }
1:6519c3e:             if (LOG.isTraceEnabled()) {
1:6519c3e:                 LOG.trace(key + " last recovered: " + lastRecovered);
1:6519c3e:             }
1:cb96783:             //duration.end();
1:f812e34:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:f812e34:         } finally {
1:b6ba20b:             c.close();
1:8191f19:         }
1:8191f19:     }
1:64f3492: 
1:734fb7d:     @Override
1:f812e34:     public void resetBatching(String clientId, String subscriptionName) {
1:64f3492:         String key = getSubscriptionKey(clientId, subscriptionName);
1:64f3492:         if (!pendingCompletion.contains(key))  {
1:64f3492:             subscriberLastRecoveredMap.remove(key);
1:64f3492:         } else {
1:64f3492:             LOG.trace(this +  ", skip resetBatch during pending completion for: " + key);
1:64f3492:         }
1:64f3492:     }
1:f812e34: 
1:64f3492:     public void pendingCompletion(String clientId, String subscriptionName, long sequenceId, byte priority) {
1:64f3492:         final String key = getSubscriptionKey(clientId, subscriptionName);
1:64f3492:         LastRecovered recovered = new LastRecovered();
1:ea70e82:         recovered.perPriority[priority].recovered = sequenceId;
1:64f3492:         subscriberLastRecoveredMap.put(key, recovered);
1:64f3492:         pendingCompletion.add(key);
1:64f3492:         LOG.trace(this + ", pending completion: " + key + ", last: " + recovered);
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void complete(String clientId, String subscriptionName) {
1:64f3492:         pendingCompletion.remove(getSubscriptionKey(clientId, subscriptionName));
1:64f3492:         LOG.trace(this + ", completion for: " + getSubscriptionKey(clientId, subscriptionName));
1:4679c8a:     }
1:cb96783: 
1:3155c62:     @Override
1:6348d11:     protected void onAdd(Message message, long sequenceId, byte priority) {
1:cb96783:         // update last recovered state
1:cb96783:         for (LastRecovered last : subscriberLastRecoveredMap.values()) {
1:cb96783:             last.updateStored(sequenceId, priority);
1:cb96783:         }
1:1f816d4:         sequenceIdCacheSizeLock.writeLock().lock();
1:d29ca2a:         try {
1:6348d11:             sequenceIdCache.put(message.getMessageId(), new long[]{sequenceId, priority});
1:1f816d4:         } finally {
1:1f816d4:             sequenceIdCacheSizeLock.writeLock().unlock();
1:1f816d4:         }
1:cb96783:     }
2:cb96783: 
1:734fb7d:     @Override
1:c0090f6:     public void addSubscription(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:1f816d4:         try {
1:d29ca2a:             c = persistenceAdapter.getTransactionContext();
1:4679c8a:             adapter.doSetSubscriberEntry(c, subscriptionInfo, retroactive, isPrioritizedMessages());
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:f812e34:             throw IOExceptionSupport.create("Failed to lookup subscription for info: " + subscriptionInfo.getClientId() + ". Reason: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @see org.apache.activemq.store.TopicMessageStore#lookupSubscription(String,
1:d29ca2a:      *      String)
1:d29ca2a:      */
1:734fb7d:     @Override
1:d29ca2a:     public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:d29ca2a:         try {
1:d29ca2a:             return adapter.doGetSubscriberEntry(c, destination, clientId, subscriptionName);
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to lookup subscription for: " + clientId + ". Reason: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:734fb7d:     @Override
1:d29ca2a:     public void deleteSubscription(String clientId, String subscriptionName) throws IOException {
1:d29ca2a:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:d29ca2a:         try {
1:d29ca2a:             adapter.doDeleteSubscription(c, destination, clientId, subscriptionName);
1:d29ca2a:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:d29ca2a:             throw IOExceptionSupport.create("Failed to remove subscription for: " + clientId + ". Reason: " + e, e);
1:d29ca2a:         } finally {
1:d29ca2a:             c.close();
1:f812e34:             resetBatching(clientId, subscriptionName);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:734fb7d:     @Override
1:9b64c37:     public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:9b64c37:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:9b64c37:         try {
1:9b64c37:             return adapter.doGetAllSubscriptions(c, destination);
1:9b64c37:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:9b64c37:             throw IOExceptionSupport.create("Failed to lookup subscriptions. Reason: " + e, e);
1:9b64c37:         } finally {
1:9b64c37:             c.close();
1:9b64c37:         }
1:9b64c37:     }
1:f812e34: 
1:734fb7d:     @Override
1:f812e34:     public int getMessageCount(String clientId, String subscriberName) throws IOException {
1:cb96783:         //Duration duration = new Duration("getMessageCount");
1:4eef609:         int result = 0;
1:8191f19:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:8191f19:         try {
1:3ddb71c:             result = adapter.doGetDurableSubscriberMessageCount(c, destination, clientId, subscriberName, isPrioritizedMessages());
1:b6ba20b:         } catch (SQLException e) {
1:f812e34:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:b6ba20b:             throw IOExceptionSupport.create("Failed to get Message Count: " + clientId + ". Reason: " + e, e);
1:b6ba20b:         } finally {
1:4eef609:             c.close();
1:d29ca2a:         }
1:3432a75:         if (LOG.isTraceEnabled()) {
1:3432a75:             LOG.trace(clientId + ":" + subscriberName + ", messageCount: " + result);
1:fa4481c:         }
1:cb96783:         //duration.end();
2:4eef609:         return result;
1:3432a75:     }
1:f812e34: 
1:734fb7d:     @Override
1:734fb7d:     public long getMessageSize(String clientId, String subscriberName) throws IOException {
1:734fb7d:         return 0;
1:734fb7d:     }
1:734fb7d: 
1:f812e34:     protected String getSubscriptionKey(String clientId, String subscriberName) {
1:f812e34:         String result = clientId + ":";
1:f812e34:         result += subscriberName != null ? subscriberName : "NOT_SET";
1:629bc81:         return result;
1:3432a75:     }
1:9b64c37: 
1:cf3d419:     private final MessageStoreSubscriptionStatistics stats = new MessageStoreSubscriptionStatistics(false);
1:cf3d419: 
1:cf3d419:     @Override
1:cf3d419:     public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:cf3d419:         return stats;
1:cf3d419:     }
1:cf3d419: 
1:3432a75: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1:             return perPriority[0];
/////////////////////////////////////////////////////////////////////////
1:         recovered.perPriority[priority].recovered = sequenceId;
commit:13ec994
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d8cf54b
/////////////////////////////////////////////////////////////////////////
0:                 public boolean hasSpace() {
0:                     return listener.hasSpace();
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:         public boolean hasSpace() {
0:             return delegate.hasSpace();
1:         }
1: 
commit:3155c62
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
commit:6348d11
/////////////////////////////////////////////////////////////////////////
1:     protected void onAdd(Message message, long sequenceId, byte priority) {
1:             sequenceIdCache.put(message.getMessageId(), new long[]{sequenceId, priority});
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:cf3d419
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.MessageStoreSubscriptionStatistics;
/////////////////////////////////////////////////////////////////////////
1:     private final MessageStoreSubscriptionStatistics stats = new MessageStoreSubscriptionStatistics(false);
1: 
1:     @Override
1:     public MessageStoreSubscriptionStatistics getMessageStoreSubStatistics() {
1:         return stats;
1:     }
1: 
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:          @Override
1:         protected boolean removeEldestEntry(Map.Entry<MessageId, long[]> eldest) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:                 @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         final LastRecovered lastRecovered = subscriberLastRecoveredMap.get(key);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public long getMessageSize(String clientId, String subscriberName) throws IOException {
1:         return 0;
1:     }
1: 
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:c0090f6
/////////////////////////////////////////////////////////////////////////
1:     public void addSubscription(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     private Map<String, AtomicLong> subscriberLastMessageMap = new ConcurrentHashMap<String, AtomicLong>();
/////////////////////////////////////////////////////////////////////////
0:         AtomicLong last = subscriberLastMessageMap.get(subcriberId);
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     private Map subscriberLastMessageMap = new ConcurrentHashMap();
1: 
0:     public JDBCTopicMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQTopic topic) {
0:     public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId) throws IOException {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to store acknowledgment for: " + clientId + " on message " + messageId + " in container: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:     public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener) throws Exception {
1:             adapter.doRecoverSubscription(c, destination, clientId, subscriptionName, new JDBCMessageRecoveryListener() {
1:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
1:                     Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:                     msg.getMessageId().setBrokerSequenceId(sequenceId);
1:                     return listener.recoverMessage(msg);
1:                 }
1: 
1:                 public boolean recoverMessageReference(String reference) throws Exception {
1:                     return listener.recoverMessageReference(new MessageId(reference));
1:                 }
1: 
1:             });
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:     public synchronized void recoverNextMessages(final String clientId, final String subscriptionName, final int maxReturned, final MessageRecoveryListener listener)
1:         throws Exception {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
0:         String subcriberId = getSubscriptionKey(clientId, subscriptionName);
0:         AtomicLong last = (AtomicLong)subscriberLastMessageMap.get(subcriberId);
0:         if (last == null) {
0:             long lastAcked = adapter.doGetLastAckedDurableSubscriberMessageId(c, destination, clientId, subscriptionName);
0:             last = new AtomicLong(lastAcked);
0:             subscriberLastMessageMap.put(subcriberId, last);
0:         final AtomicLong finalLast = last;
1:         try {
0:             adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName, last.get(), maxReturned, new JDBCMessageRecoveryListener() {
1:                 public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                     if (listener.hasSpace()) {
1:                         Message msg = (Message)wireFormat.unmarshal(new ByteSequence(data));
1:                         msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                         listener.recoverMessage(msg);
0:                         finalLast.set(sequenceId);
1:                         return true;
1:                     }
1:                     return false;
1:                 }
1:                 public boolean recoverMessageReference(String reference) throws Exception {
1:                     return listener.recoverMessageReference(new MessageId(reference));
1:                 }
1:             });
1:         } catch (SQLException e) {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:         } finally {
1: 
1:     public void resetBatching(String clientId, String subscriptionName) {
0:         String subcriberId = getSubscriptionKey(clientId, subscriptionName);
1: 
0:     public void addSubsciption(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             throw IOExceptionSupport.create("Failed to lookup subscription for info: " + subscriptionInfo.getClientId() + ". Reason: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:             resetBatching(clientId, subscriptionName);
/////////////////////////////////////////////////////////////////////////
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1:     public int getMessageCount(String clientId, String subscriberName) throws IOException {
1: 
1:             JDBCPersistenceAdapter.log("JDBC Failure: ", e);
1: 
1:     protected String getSubscriptionKey(String clientId, String subscriberName) {
1:         String result = clientId + ":";
1:         result += subscriberName != null ? subscriberName : "NOT_SET";
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:2728ccb
/////////////////////////////////////////////////////////////////////////
0:     public void addSubsciption(SubscriptionInfo subscriptionInfo, boolean retroactive)
0:             adapter.doSetSubscriberEntry(c, subscriptionInfo, retroactive);
0:                     .create("Failed to lookup subscription for info: " + subscriptionInfo.getClientId() + ". Reason: " + e, e);
commit:0afb7f9
/////////////////////////////////////////////////////////////////////////
0:                             listener.recoverMessageReference(new MessageId(reference));
/////////////////////////////////////////////////////////////////////////
0:                             listener.recoverMessageReference(new MessageId(reference));
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
1:                             Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activeio.packet.ByteArrayPacket;
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:      * @throws Exception
0:             throws Exception {
0:                         public void recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                         public void recoverMessageReference(String reference) throws Exception {
commit:911177e
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
/////////////////////////////////////////////////////////////////////////
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
commit:9b64c37
/////////////////////////////////////////////////////////////////////////
1:     public SubscriptionInfo[] getAllSubscriptions() throws IOException {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
1:             return adapter.doGetAllSubscriptions(c, destination);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to lookup subscriptions. Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.jdbc;
1: 
1: import java.io.IOException;
1: import java.sql.SQLException;
1: 
0: import org.activeio.command.WireFormat;
0: import org.activeio.packet.ByteArrayPacket;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.command.SubscriptionInfo;
1: import org.apache.activemq.store.MessageRecoveryListener;
1: import org.apache.activemq.store.TopicMessageStore;
1: import org.apache.activemq.util.IOExceptionSupport;
1: 
1: /**
0:  * @version $Revision: 1.6 $
1:  */
1: public class JDBCTopicMessageStore extends JDBCMessageStore implements TopicMessageStore {
1: 
0:     public JDBCTopicMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat,
0:             ActiveMQTopic topic) {
0:         super(persistenceAdapter, adapter, wireFormat, topic);
1:     }
1: 
0:     public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId)
0:             throws IOException {
0:         long seq = messageId.getBrokerSequenceId();
0:         // Get a connection and insert the message into the DB.
1:         TransactionContext c = persistenceAdapter.getTransactionContext(context);
1:         try {
0:             adapter.doSetLastAck(c, destination, clientId, subscriptionName, seq);
1:         } catch (SQLException e) {
0:             throw IOExceptionSupport.create("Failed to store acknowledgment for: " + clientId + " on message "
0:                     + messageId + " in container: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     /**
0:      * @throws Throwable
1:      * 
1:      */
0:     public void recoverSubscription(String clientId, String subscriptionName, final MessageRecoveryListener listener)
0:             throws Throwable {
1: 
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
0:             adapter.doRecoverSubscription(c, destination, clientId, subscriptionName,
0:                     new JDBCMessageRecoveryListener() {
0:                         public void recoverMessage(long sequenceId, byte[] data) throws Throwable {
0:                             Message msg = (Message) wireFormat.unmarshal(new ByteArrayPacket(data));
0:                             msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                             listener.recoverMessage(msg);
1:                         }
0:                         public void recoverMessageReference(String reference) throws IOException, Throwable {
0:                             listener.recoverMessageReference(reference);
1:                         }
0:                     });
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to recover subscription: " + clientId + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     /**
0:      * @see org.apache.activemq.store.TopicMessageStore#storeSubsciption(org.apache.activemq.service.SubscriptionInfo,
0:      *      boolean)
1:      */
0:     public void addSubsciption(String clientId, String subscriptionName, String selector, boolean retroactive)
0:             throws IOException {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
1:             c = persistenceAdapter.getTransactionContext();
0:             adapter.doSetSubscriberEntry(c, destination, clientId, subscriptionName, selector, retroactive);
1:         } catch (SQLException e) {
0:             throw IOExceptionSupport
0:                     .create("Failed to lookup subscription for info: " + clientId + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     /**
1:      * @see org.apache.activemq.store.TopicMessageStore#lookupSubscription(String,
1:      *      String)
1:      */
1:     public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
1:             return adapter.doGetSubscriberEntry(c, destination, clientId, subscriptionName);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to lookup subscription for: " + clientId + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1:     public void deleteSubscription(String clientId, String subscriptionName) throws IOException {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
1:         try {
1:             adapter.doDeleteSubscription(c, destination, clientId, subscriptionName);
1:         } catch (SQLException e) {
1:             throw IOExceptionSupport.create("Failed to remove subscription for: " + clientId + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
1:         }
1:     }
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:64f3492
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     private Set<String> pendingCompletion = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
1:                 adapter.doSetLastAckWithPriority(c, destination, context != null ? context.getXid() : null, clientId, subscriptionName, res[0], res[1]);
1:                 adapter.doSetLastAck(c, destination, context != null ? context.getXid() : null, clientId, subscriptionName, res[0], res[1]);
/////////////////////////////////////////////////////////////////////////
1:     public long[] getCachedStoreSequenceId(TransactionContext transactionContext, ActiveMQDestination destination, MessageId messageId) throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace(this + ", " + key + " existing last recovered: " + lastRecovered);
/////////////////////////////////////////////////////////////////////////
1:         String key = getSubscriptionKey(clientId, subscriptionName);
1:         if (!pendingCompletion.contains(key))  {
1:             subscriberLastRecoveredMap.remove(key);
1:         } else {
1:             LOG.trace(this +  ", skip resetBatch during pending completion for: " + key);
1:         }
1:     }
1: 
1:     public void pendingCompletion(String clientId, String subscriptionName, long sequenceId, byte priority) {
1:         final String key = getSubscriptionKey(clientId, subscriptionName);
1:         LastRecovered recovered = new LastRecovered();
0:         recovered.perPriority[isPrioritizedMessages() ? priority : javax.jms.Message.DEFAULT_PRIORITY].recovered = sequenceId;
1:         subscriberLastRecoveredMap.put(key, recovered);
1:         pendingCompletion.add(key);
1:         LOG.trace(this + ", pending completion: " + key + ", last: " + recovered);
1:     }
1: 
1:     public void complete(String clientId, String subscriptionName) {
1:         pendingCompletion.remove(getSubscriptionKey(clientId, subscriptionName));
1:         LOG.trace(this + ", completion for: " + getSubscriptionKey(clientId, subscriptionName));
commit:b6f63b0
/////////////////////////////////////////////////////////////////////////
1:     public JDBCTopicMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQTopic topic, ActiveMQMessageAudit audit) throws IOException {
commit:1f816d4
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashMap;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: import org.apache.activemq.command.ActiveMQDestination;
/////////////////////////////////////////////////////////////////////////
1:     public static final String PROPERTY_SEQUENCE_ID_CACHE_SIZE = "org.apache.activemq.store.jdbc.SEQUENCE_ID_CACHE_SIZE";
1:     private static final int SEQUENCE_ID_CACHE_SIZE = Integer.parseInt(System.getProperty(
1:                PROPERTY_SEQUENCE_ID_CACHE_SIZE, "1000"), 10);
1:     private final ReentrantReadWriteLock sequenceIdCacheSizeLock = new ReentrantReadWriteLock();
1:     private Map<MessageId, long[]> sequenceIdCache = new LinkedHashMap<MessageId, long[]>() {
0:          protected boolean removeEldestEntry(Map.Entry<MessageId, long[]> eldest) {
1:            return size() > SEQUENCE_ID_CACHE_SIZE;
1:         }
1:     };
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             long[] res = getCachedStoreSequenceId(c, destination, messageId);
/////////////////////////////////////////////////////////////////////////
0:     private long[] getCachedStoreSequenceId(TransactionContext transactionContext, ActiveMQDestination destination, MessageId messageId) throws SQLException, IOException {
1:         long[] val = null;
1:         sequenceIdCacheSizeLock.readLock().lock();
1:         try {
1:             val = sequenceIdCache.get(messageId);
1:         } finally {
1:             sequenceIdCacheSizeLock.readLock().unlock();
1:         }
1:         if (val == null) {
1:             val = adapter.getStoreSequenceId(transactionContext, destination, messageId);
1:         }
1:         return val;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected void onAdd(MessageId messageId, long sequenceId, byte priority) {
1:         sequenceIdCacheSizeLock.writeLock().lock();
1:         try {
0:             sequenceIdCache.put(messageId, new long[]{sequenceId, priority});
1:         } finally {
1:             sequenceIdCacheSizeLock.writeLock().unlock();
1:         }
commit:fe31092
/////////////////////////////////////////////////////////////////////////
1:             if (delegate.hasSpace() && recoveredCount < maxMessages) {
1:                 lastRecovered.recovered = sequenceId;
/////////////////////////////////////////////////////////////////////////
1:                     //microDuration.end(new String(entry + " recoveredCount:" + recoveredAwareListener.recoveredCount));
commit:cb96783
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     private class LastRecovered implements Iterable<LastRecoveredEntry> {
1:         LastRecoveredEntry[] perPriority = new LastRecoveredEntry[10];
1:         LastRecovered() {
1:             for (int i=0; i<perPriority.length; i++) {
1:                 perPriority[i] = new LastRecoveredEntry(i);
1:             }
1:         }
1:         public void updateStored(long sequence, int priority) {
1:             perPriority[priority].stored = sequence;
1:         }
1: 
1:         public LastRecoveredEntry defaultPriority() {
0:             return perPriority[javax.jms.Message.DEFAULT_PRIORITY];
1:             return Arrays.deepToString(perPriority);
1:         }
1: 
1:         public Iterator<LastRecoveredEntry> iterator() {
1:             return new PriorityIterator();
1:         }
1: 
1:         class PriorityIterator implements Iterator<LastRecoveredEntry> {
1:             int current = 9;
1:             public boolean hasNext() {
1:                 for (int i=current; i>=0; i--) {
1:                     if (perPriority[i].hasMessages()) {
1:                         current = i;
1:                         return true;
1:                     }
1:                 }
1:                 return false;
1:             }
1: 
1:             public LastRecoveredEntry next() {
1:                 return perPriority[current];
1:             }
1: 
1:             public void remove() {
1:                 throw new RuntimeException("not implemented");
1:             }
1:         }
1:     }
1: 
1:     private class LastRecoveredEntry {
1:         final int priority;
1:         long recovered = 0;
1:         long stored = Integer.MAX_VALUE;
1: 
1:         public LastRecoveredEntry(int priority) {
1:             this.priority = priority;
1:         }
1: 
1:         public String toString() {
1:             return priority + "-" + stored + ":" + recovered;
1:         }
1: 
1:         public void exhausted() {
1:             stored = recovered;
1:         }
1: 
1:         public boolean hasMessages() {
1:             return stored > recovered;
1:         }
1:     }
1: 
1:     class LastRecoveredAwareListener implements JDBCMessageRecoveryListener {
1:         final MessageRecoveryListener delegate;
1:         final int maxMessages;
1:         LastRecoveredEntry lastRecovered;
1:         int recoveredCount;
1:         int recoveredMarker;
1: 
1:         public LastRecoveredAwareListener(MessageRecoveryListener delegate, int maxMessages) {
1:             this.delegate = delegate;
1:             this.maxMessages = maxMessages;
1:         }
1: 
0:         public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
0:             if (delegate.hasSpace()) {
0:                 Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
0:                 msg.getMessageId().setBrokerSequenceId(sequenceId);
1:                 if (delegate.recoverMessage(msg)) {
0:                     lastRecovered.recovered = sequenceId;
1:                     recoveredCount++;
1:                     return true;
1:                 }
1:             }
1:             return false;
1:         }
1: 
0:         public boolean recoverMessageReference(String reference) throws Exception {
1:             return delegate.recoverMessageReference(new MessageId(reference));
1:         }
1: 
1:         public void setLastRecovered(LastRecoveredEntry lastRecovered) {
1:             this.lastRecovered = lastRecovered;
1:             recoveredMarker = recoveredCount;
1:         }
1: 
1:         public boolean complete() {
1:             return  !delegate.hasSpace() || recoveredCount == maxMessages;
1:         }
1: 
1:         public boolean stalled() {
1:             return recoveredMarker == recoveredCount;
1:         //Duration duration = new Duration("recoverNextMessages");
/////////////////////////////////////////////////////////////////////////
1:         LastRecoveredAwareListener recoveredAwareListener = new LastRecoveredAwareListener(listener, maxReturned);
1:                 Iterator<LastRecoveredEntry> it = lastRecovered.iterator();
1:                 for ( ; it.hasNext() && !recoveredAwareListener.complete(); ) {
1:                     LastRecoveredEntry entry = it.next();
1:                     recoveredAwareListener.setLastRecovered(entry);
1:                     //Duration microDuration = new Duration("recoverNextMessages:loop");
1:                     adapter.doRecoverNextMessagesWithPriority(c, destination, clientId, subscriptionName,
1:                         entry.recovered, entry.priority, maxReturned, recoveredAwareListener);
0:                     //microDuration.end(entry);
1:                     if (recoveredAwareListener.stalled()) {
1:                         if (recoveredAwareListener.complete()) {
1:                             break;
1:                         } else {
1:                             entry.exhausted();
1:                         }
1:                     }
1:                 }
1:                 LastRecoveredEntry last = lastRecovered.defaultPriority();
1:                 recoveredAwareListener.setLastRecovered(last);
1:                         last.recovered, 0, maxReturned, recoveredAwareListener);
1:             //duration.end();
/////////////////////////////////////////////////////////////////////////
0:     protected void onAdd(long sequenceId, byte priority) {
1:         // update last recovered state
1:         for (LastRecovered last : subscriberLastRecoveredMap.values()) {
1:             last.updateStored(sequenceId, priority);
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         //Duration duration = new Duration("getMessageCount");
/////////////////////////////////////////////////////////////////////////
1:         //duration.end();
commit:3ddb71c
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(key + " existing last recovered: " + lastRecovered);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             result = adapter.doGetDurableSubscriberMessageCount(c, destination, clientId, subscriberName, isPrioritizedMessages());
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace(clientId + ":" + subscriptionName + " ack, seq: " + res[0] + ", priority: " + res[1] + " mid:" + messageId);
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace(key + " last recovered: " + lastRecovered);
1:             }
commit:8191f19
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
1:     private Map<String, LastRecovered> subscriberLastRecoveredMap = new ConcurrentHashMap<String, LastRecovered>();
/////////////////////////////////////////////////////////////////////////
0:     private class LastRecovered {
0:         long sequence = 0;
0:         byte priority = 9;
0:         public void update(long sequence, Message msg) {
0:             this.sequence = sequence;
0:             this.priority = msg.getPriority();
1:         }
0: 
1:         public String toString() {
0:             return "" + sequence + ":" + priority;
1:         }
1:     }
0: 
0:     public synchronized void recoverNextMessages(final String clientId, final String subscriptionName, final int maxReturned, final MessageRecoveryListener listener)
0:             throws Exception {
1:         TransactionContext c = persistenceAdapter.getTransactionContext();
0: 
1:         String key = getSubscriptionKey(clientId, subscriptionName);
1:         if (!subscriberLastRecoveredMap.containsKey(key)) {
1:            subscriberLastRecoveredMap.put(key, new LastRecovered());
1:         }
0:         final LastRecovered lastRecovered = subscriberLastRecoveredMap.get(key);        
1:         try {
0:             JDBCMessageRecoveryListener jdbcListener = new JDBCMessageRecoveryListener() {
0:                         Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
0:                             lastRecovered.update(sequenceId, msg);
/////////////////////////////////////////////////////////////////////////
0:                         lastRecovered.sequence, lastRecovered.priority, maxReturned, jdbcListener);
0:                         lastRecovered.sequence, 0, maxReturned, jdbcListener);
/////////////////////////////////////////////////////////////////////////
0:         subscriberLastRecoveredMap.remove(getSubscriptionKey(clientId, subscriptionName));
commit:4679c8a
/////////////////////////////////////////////////////////////////////////
0:              JDBCMessageRecoveryListener jdbcListener = new JDBCMessageRecoveryListener() {
/////////////////////////////////////////////////////////////////////////
0:             };
1:             if (isPrioritizedMessages()) {
0:                 adapter.doRecoverNextMessagesWithPriority(c, destination, clientId, subscriptionName,
0:                     0, 0, maxReturned, jdbcListener);
1:             } else {
1:                 adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName,
0:                     0, 0, maxReturned, jdbcListener);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             adapter.doSetSubscriberEntry(c, subscriptionInfo, retroactive, isPrioritizedMessages());
/////////////////////////////////////////////////////////////////////////
0:                 result = adapter.doGetDurableSubscriberMessageCount(c, destination, clientId, subscriberName, isPrioritizedMessages());
commit:fa4481c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             long[] res = adapter.getStoreSequenceId(c, destination, messageId);
1:             if (this.isPrioritizedMessages()) {
0:                 adapter.doSetLastAckWithPriority(c, destination, clientId, subscriptionName, res[0], res[1]);
1:             } else {
0:                 adapter.doSetLastAck(c, destination, clientId, subscriptionName, res[0], res[1]);
1:             }
0:                 LOG.trace(clientId + ":" + subscriptionName + " ack, seq: " + res[0] + ", priority: " + res[1]);
/////////////////////////////////////////////////////////////////////////
0:             adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName,
0:                     0, 0, maxReturned, new JDBCMessageRecoveryListener() {
/////////////////////////////////////////////////////////////////////////
0:         // DB always recovers from last ack
commit:3432a75
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageAck;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(JDBCTopicMessageStore.class);
/////////////////////////////////////////////////////////////////////////
1:     public void acknowledge(ConnectionContext context, String clientId, String subscriptionName, MessageId messageId, MessageAck ack) throws IOException {
1:         if (ack != null && ack.isUnmatchedAck()) {
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("ignoring unmatched selector ack for: " + messageId + ", cleanup will get to this message after subsequent acks.");
1:             }
1:             return;
1:         }
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("ack - seq: " + res[0] + ", priority: " + res[1]);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             long[] lastAcked = adapter.doGetLastAckedDurableSubscriberMessageId(c, destination, clientId, subscriptionName);
0:             last = new AtomicLong(lastAcked[0]);
0:             priority = new AtomicLong(lastAcked[1]);
1:         if (LOG.isTraceEnabled()) {
0:             LOG.trace("recoverNextMessage - last: " + last.get() + ", priority: " + priority);
0:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
1:             LOG.trace(clientId + ":" + subscriberName + ", messageCount: " + result);
0:         }
commit:f206a1b
/////////////////////////////////////////////////////////////////////////
0:                         if (listener.recoverMessage(msg)) {
0:                             finalLast.set(sequenceId);
0:                             finalPriority.set(msg.getPriority());
0:                             return true;
0:                         }
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
0:         	long seq = adapter.getStoreSequenceId(c, destination, messageId);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JDBCTopicMessageStore.class);
commit:4f5e620
/////////////////////////////////////////////////////////////////////////
0:     private Map<String, AtomicLong> subscriberLastPriorityMap = new ConcurrentHashMap<String, AtomicLong>();
/////////////////////////////////////////////////////////////////////////
0:         	long[] res = adapter.getStoreSequenceId(c, destination, messageId);
0:             adapter.doSetLastAck(c, destination, clientId, subscriptionName, res[0], res[1]);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         AtomicLong priority = subscriberLastPriorityMap.get(subcriberId);
0:             priority = new AtomicLong(Byte.MAX_VALUE - 1);
0:             subscriberLastMessageMap.put(subcriberId, priority);
0:         final AtomicLong finalPriority = priority;
0:             adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName, last.get(), priority.get(), maxReturned, new JDBCMessageRecoveryListener() {
/////////////////////////////////////////////////////////////////////////
0:                         finalPriority.set(msg.getPriority());
/////////////////////////////////////////////////////////////////////////
0:             subscriberLastMessageMap.put(subcriberId, finalLast);
0:             subscriberLastPriorityMap.put(subcriberId, finalPriority);
0:         subscriberLastPriorityMap.remove(subcriberId);
commit:24a7626
/////////////////////////////////////////////////////////////////////////
0:         	long seq = adapter.getStoreSequenceId(c, messageId);
commit:c3801c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
0:     public JDBCTopicMessageStore(JDBCPersistenceAdapter persistenceAdapter, JDBCAdapter adapter, WireFormat wireFormat, ActiveMQTopic topic, ActiveMQMessageAudit audit) {
1:         super(persistenceAdapter, adapter, wireFormat, topic, audit);
author:Robert Davies
-------------------------------------------------------------------------------
commit:3a5f48d
/////////////////////////////////////////////////////////////////////////
0:                         public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                             return listener.recoverMessage(msg);
0:                         public boolean  recoverMessageReference(String reference) throws Exception {
0:                             return listener.recoverMessageReference(new MessageId(reference));
/////////////////////////////////////////////////////////////////////////
0:                         public boolean recoverMessage(long sequenceId,byte[] data) throws Exception{
0:                                 return true;
0:                             return false;
0:                         public boolean recoverMessageReference(String reference) throws Exception{
0:                             return listener.recoverMessageReference(new MessageId(reference));
commit:4597ddd
/////////////////////////////////////////////////////////////////////////
0:             long lastAcked = adapter.doGetLastAckedDurableSubscriberMessageId(c,destination,clientId,subscriptionName);
0:             last=new AtomicLong(lastAcked);
commit:3bf0245
/////////////////////////////////////////////////////////////////////////
0:                             if(listener.hasSpace()){
0:                                 Message msg=(Message)wireFormat.unmarshal(new ByteSequence(data));
0:                                 msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                                 listener.recoverMessage(msg);
0:                                 finalLast.set(sequenceId);
0:                             }
commit:629bc81
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
0: 
0:     private Map subscriberLastMessageMap=new ConcurrentHashMap();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void recoverNextMessages(final String clientId,final String subscriptionName,
0:             final int maxReturned,final MessageRecoveryListener listener) throws Exception{
0:         TransactionContext c=persistenceAdapter.getTransactionContext();
0:         String subcriberId=getSubscriptionKey(clientId,subscriptionName);
0:         AtomicLong last=(AtomicLong)subscriberLastMessageMap.get(subcriberId);
0:         if(last==null){
0:             last=new AtomicLong(-1);
0:             subscriberLastMessageMap.put(subcriberId,last);
0:         }
0:         final AtomicLong finalLast=last;
0:         try{
0:             adapter.doRecoverNextMessages(c,destination,clientId,subscriptionName,last.get(),maxReturned,
0:                     new JDBCMessageRecoveryListener(){
0: 
0:                         public void recoverMessage(long sequenceId,byte[] data) throws Exception{
0:                             Message msg=(Message)wireFormat.unmarshal(new ByteSequence(data));
0:                             finalLast.set(sequenceId);
0: 
0:                         public void recoverMessageReference(String reference) throws Exception{
0: 
0:         }catch(SQLException e){
0:         }finally{
0:             last.set(finalLast.get());
0:     public void resetBatching(String clientId,String subscriptionName) {
0:         String subcriberId=getSubscriptionKey(clientId,subscriptionName);
0:         subscriberLastMessageMap.remove(subcriberId);
/////////////////////////////////////////////////////////////////////////
0:             resetBatching(clientId,subscriptionName);
/////////////////////////////////////////////////////////////////////////
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected String getSubscriptionKey(String clientId,String subscriberName){
0:         String result=clientId+":";
0:         result+=subscriberName!=null?subscriberName:"NOT_SET";
1:         return result;
0:     }
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0: 
0:     
0:     public void resetBatching(String clientId,String subscriptionName,MessageId id) {
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     public MessageId getNextMessageIdToDeliver(String clientId,String subscriptionName,MessageId id) throws Exception{
0:         
0:         final MessageId result = new MessageId();
0:         final AtomicBoolean initalized = new AtomicBoolean();
0:             long sequence = id != null ? id.getBrokerSequenceId() : -1;
0:            adapter.doGetNextDurableSubscriberMessageIdStatement(c, destination, clientId, subscriptionName,sequence,new JDBCMessageRecoveryListener() {
0:                public void recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                    Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
0:                    msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                    result.setBrokerSequenceId(msg.getMessageId().getBrokerSequenceId());
0:                    initalized.set(true);
0:                    
0:                }
0:                public void recoverMessageReference(String reference) throws Exception {
0:                    result.setValue(reference);
0:                    initalized.set(true);
0:                    
0:                }
0:                
0:                public void finished(){          
0:                }
0:            });
0:            
0:             throw IOExceptionSupport.create("Failed to get next MessageId to deliver: " + clientId + ". Reason: " + e, e);
0:         return initalized.get () ? result : null;
0:     }
0:     
0:     public MessageId getPreviousMessageIdToDeliver(String clientId,String subscriptionName,MessageId id) throws Exception{
0:         final MessageId result = new MessageId();
0:         final AtomicBoolean initalized = new AtomicBoolean();
0:         TransactionContext c = persistenceAdapter.getTransactionContext();
0:         try {
0:             long sequence = id != null ? id.getBrokerSequenceId() : -1;
0:            adapter.doGetPrevDurableSubscriberMessageIdStatement(c, destination, clientId, subscriptionName,sequence,new JDBCMessageRecoveryListener() {
0:                public void recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                    Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
0:                    msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                    result.setProducerId(msg.getMessageId().getProducerId());
0:                    result.setProducerSequenceId(msg.getMessageId().getProducerSequenceId());
0:                    result.setBrokerSequenceId(msg.getMessageId().getBrokerSequenceId());
0:                    initalized.set(true);
0:                    
0:                }
0:                public void recoverMessageReference(String reference) throws Exception {
0:                    result.setValue(reference);
0:                    initalized.set(true);
0:                    
0:                }
0:                
0:                public void finished(){          
0:                }
0:            });
0:            
0:                
1:         } catch (SQLException e) {
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
0:             throw IOExceptionSupport.create("Failed to get next MessageId to deliver: " + clientId + ". Reason: " + e, e);
1:         } finally {
1:             c.close();
0:         }
0:         return initalized.get () ? result : null;
/////////////////////////////////////////////////////////////////////////
1:             throw IOExceptionSupport.create("Failed to get Message Count: " + clientId + ". Reason: " + e, e);
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0:     public void recoverNextMessages(final String clientId,final String subscriptionName, final MessageId lastMessageId,final int maxReturned,final MessageRecoveryListener listener) throws Exception{
0:         TransactionContext c = persistenceAdapter.getTransactionContext();
0:         try {
0:             long lastSequence = lastMessageId != null ? lastMessageId.getBrokerSequenceId() : -1;
0:             adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName,lastSequence,maxReturned,
0:                     new JDBCMessageRecoveryListener() {
0:                         public void recoverMessage(long sequenceId, byte[] data) throws Exception {
0:                             Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));
0:                             msg.getMessageId().setBrokerSequenceId(sequenceId);
0:                             listener.recoverMessage(msg);
0:                         }
0:                         public void recoverMessageReference(String reference) throws Exception {
0:                             listener.recoverMessageReference(reference);
0:                         }
0:                         
0:                         public void finished(){
0:                             listener.finished();
0:                         }
0:                     });
0:         } catch (SQLException e) {
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
0:             throw IOExceptionSupport.create("Failed to recover subscription: " + clientId + ". Reason: " + e, e);
0:         } finally {
1:             c.close();
0:         }
0:         
0:     }
/////////////////////////////////////////////////////////////////////////
0:     public Message getNextMessageToDeliver(String clientId,String subscriptionName) throws IOException{
0:         Message result = null;
0:     
0:         TransactionContext c = persistenceAdapter.getTransactionContext();
0:         try {
0:             byte[] data = adapter.doGetNextDurableSubscriberMessageStatement(c, destination, clientId, subscriptionName);
0:             result = (Message) wireFormat.unmarshal(new ByteSequence(data));
0:                
0:         } catch (SQLException e) {
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
0:             throw IOExceptionSupport.create("Failed to recover subscription: " + clientId + ". Reason: " + e, e);
0:         } finally {
0:             c.close();
0:         }
1:         return result;
0:     }
0: 
0:     public int getMessageCount(String clientId,String subscriberName) throws IOException{
1:         int result = 0;
0:         TransactionContext c = persistenceAdapter.getTransactionContext();
0:         try {
0:             result = adapter.doGetDurableSubscriberMessageCount(c, destination, clientId, subscriberName);
0:                
0:         } catch (SQLException e) {
0:             JDBCPersistenceAdapter.log("JDBC Failure: ",e);
0:             throw IOExceptionSupport.create("Failed to recover subscription: " + clientId + ". Reason: " + e, e);
0:         } finally {
0:             c.close();
0:         }
1:         return result;
0:     }
0: 
0:     
0: 
0:     
0: 
commit:2748ae1
/////////////////////////////////////////////////////////////////////////
0:                         
0:                         public void finished(){
0:                             listener.finished();
0:                         }
============================================================================