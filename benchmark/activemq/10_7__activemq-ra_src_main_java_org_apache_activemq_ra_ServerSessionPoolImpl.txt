2:40a7d3b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
4:40a7d3b:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:40a7d3b:  *
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:40a7d3b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:40a7d3b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:40a7d3b:  * See the License for the specific language governing permissions and
1:40a7d3b:  * limitations under the License.
1:40a7d3b:  */
1:fd4bb60: package org.apache.activemq.ra;
14:40a7d3b: 
1:bbd2e47: import java.util.ArrayList;
1:40a7d3b: import java.util.Iterator;
1:40a7d3b: import java.util.List;
1:540dd5c: import java.util.concurrent.atomic.AtomicBoolean;
1:8d28bbf: import java.util.concurrent.locks.Lock;
1:8d28bbf: import java.util.concurrent.locks.ReentrantLock;
1:40a7d3b: 
1:40a7d3b: import javax.jms.JMSException;
1:40a7d3b: import javax.jms.ServerSession;
1:40a7d3b: import javax.jms.ServerSessionPool;
1:40a7d3b: import javax.jms.Session;
1:40a7d3b: import javax.resource.spi.UnavailableException;
1:40a7d3b: import javax.resource.spi.endpoint.MessageEndpoint;
1:40a7d3b: 
1:f42d56c: import org.apache.activemq.ActiveMQConnection;
1:fd4bb60: import org.apache.activemq.ActiveMQSession;
1:fd4bb60: import org.apache.activemq.command.MessageDispatch;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:40a7d3b: 
1:40a7d3b: /**
1:b0c2a40:  *  $Date$
1:40a7d3b:  */
1:40a7d3b: public class ServerSessionPoolImpl implements ServerSessionPool {
1:540dd5c: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ServerSessionPoolImpl.class);
1:40a7d3b: 
1:40a7d3b:     private final ActiveMQEndpointWorker activeMQAsfEndpointWorker;
1:40a7d3b:     private final int maxSessions;
1:40a7d3b: 
1:8d28bbf:     private final List<ServerSessionImpl> idleSessions = new ArrayList<ServerSessionImpl>();
1:8d28bbf:     private final List<ServerSessionImpl> activeSessions = new ArrayList<ServerSessionImpl>();
1:8d28bbf:     private final Lock sessionLock = new ReentrantLock();
1:8d28bbf:     private final AtomicBoolean closing = new AtomicBoolean(false);
1:40a7d3b: 
1:40a7d3b:     public ServerSessionPoolImpl(ActiveMQEndpointWorker activeMQAsfEndpointWorker, int maxSessions) {
1:40a7d3b:         this.activeMQAsfEndpointWorker = activeMQAsfEndpointWorker;
1:540dd5c:         this.maxSessions = maxSessions;
3:8d28bbf:     }
1:bbd2e47: 
1:40a7d3b:     private ServerSessionImpl createServerSessionImpl() throws JMSException {
1:d7355e7:         MessageActivationSpec activationSpec = activeMQAsfEndpointWorker.endpointActivationKey.getActivationSpec();
1:40a7d3b:         int acknowledge = (activeMQAsfEndpointWorker.transacted) ? Session.SESSION_TRANSACTED : activationSpec.getAcknowledgeModeForSession();
1:f42d56c:         final ActiveMQConnection connection = activeMQAsfEndpointWorker.getConnection();
1:f42d56c:         if (connection == null) {
1:f42d56c:             // redispatch of pending prefetched messages after disconnect can have a null connection
1:f42d56c:             return null;
1:f42d56c:         }
1:f42d56c:         final ActiveMQSession session = (ActiveMQSession)connection.createSession(activeMQAsfEndpointWorker.transacted, acknowledge);
1:40a7d3b:         MessageEndpoint endpoint;
1:540dd5c:         try {
1:40a7d3b:             int batchSize = 0;
1:40a7d3b:             if (activationSpec.getEnableBatchBooleanValue()) {
1:40a7d3b:                 batchSize = activationSpec.getMaxMessagesPerBatchIntValue();
1:d8bdbe7:             }
1:540dd5c:             if (activationSpec.isUseRAManagedTransactionEnabled()) {
1:40a7d3b:                 // The RA will manage the transaction commit.
1:540dd5c:                 endpoint = createEndpoint(null);
1:161730f:                 return new ServerSessionImpl(this, session, activeMQAsfEndpointWorker.workManager, endpoint, true, batchSize);
3:40a7d3b:             } else {
1:40a7d3b:                 // Give the container an object to manage to transaction with.
1:540dd5c:                 endpoint = createEndpoint(new LocalAndXATransaction(session.getTransactionContext()));
1:161730f:                 return new ServerSessionImpl(this, session, activeMQAsfEndpointWorker.workManager, endpoint, false, batchSize);
1:d8bdbe7:             }
1:40a7d3b:         } catch (UnavailableException e) {
1:40a7d3b:             // The container could be limiting us on the number of endpoints
1:40a7d3b:             // that are being created.
1:bbd2e47:             if (LOG.isDebugEnabled()) {
1:540dd5c:                 LOG.debug("Could not create an endpoint.", e);
1:bbd2e47:             }
1:40a7d3b:             session.close();
1:40a7d3b:             return null;
1:8d28bbf:         }
1:8d28bbf:     }
1:d8bdbe7: 
1:40a7d3b:     private MessageEndpoint createEndpoint(LocalAndXATransaction txResourceProxy) throws UnavailableException {
1:40a7d3b:         MessageEndpoint endpoint;
1:40a7d3b:         endpoint = activeMQAsfEndpointWorker.endpointFactory.createEndpoint(txResourceProxy);
1:40a7d3b:         MessageEndpointProxy endpointProxy = new MessageEndpointProxy(endpoint);
1:40a7d3b:         return endpointProxy;
1:8d28bbf:     }
1:d8bdbe7: 
1:d8bdbe7:     /**
1:40a7d3b:      */
1:161730f:     @Override
1:d0da99a:     public ServerSession getServerSession() throws JMSException {
1:bbd2e47:         if (LOG.isDebugEnabled()) {
1:540dd5c:             LOG.debug("ServerSession requested.");
1:bbd2e47:         }
1:d0da99a:         if (closing.get()) {
1:40a7d3b:             throw new JMSException("Session Pool Shutting Down.");
1:8d28bbf:         }
1:bbd2e47:         ServerSessionImpl ss = null;
1:8d28bbf:         sessionLock.lock();
1:8d28bbf:         try {
1:8d28bbf:             ss = getExistingServerSession(false);
1:8d28bbf:         } finally {
1:8d28bbf:             sessionLock.unlock();
1:bbd2e47:         }
1:8d28bbf:         if (ss != null) {
3:40a7d3b:             return ss;
1:bbd2e47:         }
1:bbd2e47:         ss = createServerSessionImpl();
1:8d28bbf:         sessionLock.lock();
1:8d28bbf:         try {
1:202b3ef:             // We may not be able to create a session due to the container
1:bbd2e47:             // restricting us.
1:bbd2e47:             if (ss == null) {
1:8d28bbf:                 if (activeSessions.isEmpty() && idleSessions.isEmpty()) {
1:8d28bbf:                     throw new JMSException("Endpoint factory did not allow creation of any endpoints.");
1:bbd2e47:                 }
1:bbd2e47: 
1:8d28bbf:                 ss = getExistingServerSession(true);
1:8d28bbf:             } else {
1:bbd2e47:                 activeSessions.add(ss);
1:bbd2e47:             }
1:8d28bbf:         } finally {
1:8d28bbf:             sessionLock.unlock();
1:bbd2e47:         }
1:bbd2e47:         if (LOG.isDebugEnabled()) {
1:540dd5c:             LOG.debug("Created a new session: " + ss);
1:bbd2e47:         }
1:8d28bbf:         return ss;
1:bbd2e47: 
1:bbd2e47:     }
1:8d28bbf: 
1:40a7d3b:     /**
1:8d28bbf:      * Must be called with sessionLock held.
1:8d28bbf:      * Returns an idle session if one exists or an active session if no more
1:8d28bbf:      * sessions can be created.  Sessions can not be created if force is true
1:8d28bbf:      * or activeSessions >= maxSessions.
1:8d28bbf:      * @param force do not check activeSessions >= maxSessions, return an active connection anyway.
1:8d28bbf:      * @return an already existing session.
1:8d28bbf:      */
1:8d28bbf:     private ServerSessionImpl getExistingServerSession(boolean force) {
2:8d28bbf:         ServerSessionImpl ss = null;
1:bbd2e47:         if (idleSessions.size() > 0) {
1:bbd2e47:             ss = idleSessions.remove(idleSessions.size() - 1);
1:bbd2e47:         }
1:bbd2e47:         if (ss != null) {
1:bbd2e47:             activeSessions.add(ss);
1:bbd2e47:             if (LOG.isDebugEnabled()) {
1:540dd5c:                 LOG.debug("Using idle session: " + ss);
1:bbd2e47:             }
1:8d28bbf:         } else if (force || activeSessions.size() >= maxSessions) {
1:8d28bbf:             // If we are at the upper limit
1:202b3ef:             // then reuse the already created sessions..
1:8d28bbf:             // This is going to queue up messages into a session for
1:8d28bbf:             // processing.
1:8d28bbf:             ss = getExistingActiveServerSession();
1:202b3ef:         }
1:bbd2e47:         return ss;
1:bbd2e47:     }
1:202b3ef: 
1:8d28bbf:     /**
1:8d28bbf:      * Must be called with sessionLock held.
1:8d28bbf:      * Returns the first session from activeSessions, shifting it to last.
1:bbd2e47:      * @return session
1:8d28bbf:      */
1:8d28bbf:     private ServerSessionImpl getExistingActiveServerSession() {
1:bbd2e47:         ServerSessionImpl ss = null;
1:bbd2e47:         if (!activeSessions.isEmpty()) {
1:bbd2e47:             if (activeSessions.size() > 1) {
1:bbd2e47:                 // round robin
1:bbd2e47:                 ss = activeSessions.remove(0);
1:bbd2e47:                 activeSessions.add(ss);
1:8d28bbf:             } else {
1:bbd2e47:                 ss = activeSessions.get(0);
1:8d28bbf:             }
1:8d28bbf:         }
1:bbd2e47:         if (LOG.isDebugEnabled()) {
1:540dd5c:             LOG.debug("Reusing an active session: " + ss);
1:8d28bbf:         }
1:8d28bbf:         return ss;
1:8d28bbf:     }
1:bbd2e47: 
1:d0da99a:     public void returnToPool(ServerSessionImpl ss) {
1:8d28bbf:         sessionLock.lock();
1:5ebee0a:         activeSessions.remove(ss);
1:58e5b9a:         try {
1:58e5b9a:             // make sure we only return non-stale sessions to the pool
1:58e5b9a:             if ( ss.isStale() ) {
1:58e5b9a:                 if ( LOG.isDebugEnabled() ) {
1:58e5b9a:                     LOG.debug("Discarding stale ServerSession to be returned to pool: " + ss);
1:58e5b9a:                 }
1:58e5b9a:                 ss.close();
1:58e5b9a:             } else {
1:58e5b9a:                 if (LOG.isDebugEnabled()) {
1:58e5b9a:                     LOG.debug("ServerSession returned to pool: " + ss);
1:58e5b9a:                 }
1:bbd2e47:             idleSessions.add(ss);
1:58e5b9a:             }
1:8d28bbf:         } finally {
1:8d28bbf:             sessionLock.unlock();
1:8d28bbf:         }
1:540dd5c:         synchronized (closing) {
1:d0da99a:             closing.notify();
1:d0da99a:         }
1:d0da99a:     }
1:8d28bbf: 
1:540dd5c:     public void removeFromPool(ServerSessionImpl ss) {
1:8d28bbf:         sessionLock.lock();
1:8d28bbf:         try {
2:bbd2e47:             activeSessions.remove(ss);
1:8d28bbf:         } finally {
1:8d28bbf:             sessionLock.unlock();
1:8d28bbf:         }
1:8d28bbf:         try {
1:540dd5c:             ActiveMQSession session = (ActiveMQSession)ss.getSession();
1:161730f:             List<MessageDispatch> l = session.getUnconsumedMessages();
1:5ebee0a:             if (!isClosing() && !l.isEmpty()) {
1:e8818fa:                 ActiveMQConnection connection = activeMQAsfEndpointWorker.getConnection();
1:e8818fa:                 if (connection != null) {
1:161730f:                     for (Iterator<MessageDispatch> i = l.iterator(); i.hasNext();) {
1:161730f:                         MessageDispatch md = i.next();
1:e8818fa:                         if (connection.hasDispatcher(md.getConsumerId())) {
1:e8818fa:                             dispatchToSession(md);
1:e8818fa:                             LOG.trace("on remove of {} redispatch of {}", session, md);
1:e8818fa:                         } else {
1:e8818fa:                             LOG.trace("on remove not redispatching {}, dispatcher no longer present on {}", md, session.getConnection());
1:e8818fa:                         }
1:e8818fa:                     }
1:e8818fa:                 } else {
1:e8818fa:                     LOG.trace("on remove of {} not redispatching while disconnected", session);
1:e8818fa:                 }
1:8d28bbf:             }
1:8d28bbf:         } catch (Throwable t) {
1:e8818fa:             LOG.error("Error redispatching unconsumed messages from stale server session {}", ss, t);
1:8d28bbf:         }
1:8d28bbf:         ss.close();
1:bbd2e47:         synchronized (closing) {
1:d0da99a:             closing.notify();
1:8d28bbf:         }
1:8d28bbf:     }
1:8d28bbf: 
1:8d28bbf:     /**
1:bbd2e47:      * @param messageDispatch
1:bbd2e47:      *            the message to dispatch
1:40a7d3b:      * @throws JMSException
1:40a7d3b:      */
1:bbd2e47:     private void dispatchToSession(MessageDispatch messageDispatch)
1:bbd2e47:             throws JMSException {
1:8d28bbf: 
1:40a7d3b:         ServerSession serverSession = getServerSession();
1:40a7d3b:         Session s = serverSession.getSession();
1:40a7d3b:         ActiveMQSession session = null;
1:540dd5c:         if (s instanceof ActiveMQSession) {
3:bbd2e47:             session = (ActiveMQSession) s;
1:bbd2e47:         } else {
1:58e5b9a:             activeMQAsfEndpointWorker.getConnection()
1:bbd2e47:                     .onAsyncException(new JMSException(
1:bbd2e47:                             "Session pool provided an invalid session type: "
1:bbd2e47:                                     + s.getClass()));
1:8d28bbf:         }
1:40a7d3b:         session.dispatch(messageDispatch);
1:40a7d3b:         serverSession.start();
1:bbd2e47:     }
1:8d28bbf: 
1:40a7d3b:     public void close() {
1:bbd2e47:         closing.set(true);
1:5ebee0a:         LOG.debug("{} close", this);
1:519d8f7:         int activeCount = closeSessions();
1:bbd2e47:         // we may have to wait erroneously 250ms if an
1:bbd2e47:         // active session is removed during our wait and we
1:bbd2e47:         // are not notified
1:8d28bbf:         while (activeCount > 0) {
1:bbd2e47:             if (LOG.isDebugEnabled()) {
1:8d28bbf:                 LOG.debug("Active Sessions = " + activeCount);
1:bbd2e47:             }
1:bbd2e47:             try {
1:540dd5c:                 synchronized (closing) {
1:bbd2e47:                     closing.wait(250);
1:bbd2e47:                 }
1:bbd2e47:             } catch (InterruptedException e) {
1:bbd2e47:                 Thread.currentThread().interrupt();
1:bbd2e47:                 return;
1:bbd2e47:             }
1:519d8f7:             activeCount = closeSessions();
1:bbd2e47:         }
1:bbd2e47:     }
1:bbd2e47: 
1:8d28bbf: 
1:519d8f7:     protected int closeSessions() {
1:8d28bbf:         sessionLock.lock();
1:8d28bbf:         try {
1:5ebee0a:             List<ServerSessionImpl> alreadyClosedServerSessions = new ArrayList<>(activeSessions.size());
1:519d8f7:             for (ServerSessionImpl ss : activeSessions) {
1:519d8f7:                 try {
1:519d8f7:                     ActiveMQSession session = (ActiveMQSession) ss.getSession();
1:519d8f7:                     if (!session.isClosed()) {
1:519d8f7:                         session.close();
1:5ebee0a:                     } else {
1:5ebee0a:                         LOG.debug("Session {} already closed", session);
1:5ebee0a:                         alreadyClosedServerSessions.add(ss);
1:5ebee0a: 
1:519d8f7:                     }
1:519d8f7:                 } catch (JMSException ignored) {
1:519d8f7:                     if (LOG.isDebugEnabled()) {
1:519d8f7:                         LOG.debug("Failed to close active running server session {}, reason:{}", ss, ignored.toString(), ignored);
1:519d8f7:                     }
1:519d8f7:                 }
1:519d8f7:             }
1:5ebee0a:             for (ServerSessionImpl ss : alreadyClosedServerSessions) {
1:5ebee0a:                 removeFromPool(ss);
1:5ebee0a:             }
1:5ebee0a:             alreadyClosedServerSessions.clear();
1:5ebee0a: 
1:8d28bbf:             for (ServerSessionImpl ss : idleSessions) {
1:bbd2e47:                 ss.close();
1:bbd2e47:             }
1:bbd2e47:             idleSessions.clear();
1:bbd2e47:             return activeSessions.size();
1:8d28bbf:         } finally {
1:8d28bbf:             sessionLock.unlock();
1:bbd2e47:         }
1:bbd2e47:     }
1:40a7d3b: 
1:40a7d3b:     /**
1:d8bdbe7:      * @return Returns the closing.
1:d8bdbe7:      */
1:540dd5c:     public boolean isClosing() {
1:d0da99a:         return closing.get();
1:bbd2e47:     }
1:bbd2e47: 
1:d8bdbe7:     /**
1:d8bdbe7:      * @param closing The closing to set.
1:d8bdbe7:      */
1:540dd5c:     public void setClosing(boolean closing) {
1:d0da99a:         this.closing.set(closing);
1:bbd2e47:     }
1:bbd2e47: 
1:bbd2e47: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:5ebee0a
/////////////////////////////////////////////////////////////////////////
1:         activeSessions.remove(ss);
/////////////////////////////////////////////////////////////////////////
1:             if (!isClosing() && !l.isEmpty()) {
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("{} close", this);
/////////////////////////////////////////////////////////////////////////
1:             List<ServerSessionImpl> alreadyClosedServerSessions = new ArrayList<>(activeSessions.size());
1:                     } else {
1:                         LOG.debug("Session {} already closed", session);
1:                         alreadyClosedServerSessions.add(ss);
1: 
/////////////////////////////////////////////////////////////////////////
1:             for (ServerSessionImpl ss : alreadyClosedServerSessions) {
1:                 removeFromPool(ss);
1:             }
1:             alreadyClosedServerSessions.clear();
1: 
commit:e8818fa
/////////////////////////////////////////////////////////////////////////
0:             if (!l.isEmpty()) {
1:                 ActiveMQConnection connection = activeMQAsfEndpointWorker.getConnection();
1:                 if (connection != null) {
0:                     for (Iterator i = l.iterator(); i.hasNext();) {
0:                         MessageDispatch md = (MessageDispatch)i.next();
1:                         if (connection.hasDispatcher(md.getConsumerId())) {
1:                             dispatchToSession(md);
1:                             LOG.trace("on remove of {} redispatch of {}", session, md);
1:                         } else {
1:                             LOG.trace("on remove not redispatching {}, dispatcher no longer present on {}", md, session.getConnection());
1:                         }
1:                     }
1:                 } else {
1:                     LOG.trace("on remove of {} not redispatching while disconnected", session);
1:                 }
1:             LOG.error("Error redispatching unconsumed messages from stale server session {}", ss, t);
commit:f42d56c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
/////////////////////////////////////////////////////////////////////////
1:         final ActiveMQConnection connection = activeMQAsfEndpointWorker.getConnection();
1:         if (connection == null) {
1:             // redispatch of pending prefetched messages after disconnect can have a null connection
1:             return null;
1:         }
1:         final ActiveMQSession session = (ActiveMQSession)connection.createSession(activeMQAsfEndpointWorker.transacted, acknowledge);
commit:519d8f7
/////////////////////////////////////////////////////////////////////////
1:         int activeCount = closeSessions();
/////////////////////////////////////////////////////////////////////////
1:             activeCount = closeSessions();
1:     protected int closeSessions() {
1:             for (ServerSessionImpl ss : activeSessions) {
1:                 try {
1:                     ActiveMQSession session = (ActiveMQSession) ss.getSession();
1:                     if (!session.isClosed()) {
1:                         session.close();
1:                     }
1:                 } catch (JMSException ignored) {
1:                     if (LOG.isDebugEnabled()) {
1:                         LOG.debug("Failed to close active running server session {}, reason:{}", ss, ignored.toString(), ignored);
1:                     }
1:                 }
1:             }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:161730f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 return new ServerSessionImpl(this, session, activeMQAsfEndpointWorker.workManager, endpoint, true, batchSize);
1:                 return new ServerSessionImpl(this, session, activeMQAsfEndpointWorker.workManager, endpoint, false, batchSize);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             List<MessageDispatch> l = session.getUnconsumedMessages();
1:                     for (Iterator<MessageDispatch> i = l.iterator(); i.hasNext();) {
1:                         MessageDispatch md = i.next();
author:Marc Breslow
-------------------------------------------------------------------------------
commit:4a937de
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  *  $Date$
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: 
0:     private static final Log LOG = LogFactory.getLog(ServerSessionPoolImpl.class);
0:     private List<ServerSessionImpl> idleSessions = new CopyOnWriteArrayList<ServerSessionImpl>();
0:     private List<ServerSessionImpl> activeSessions = new CopyOnWriteArrayList<ServerSessionImpl>();
1:         this.maxSessions = maxSessions;
0:         final ActiveMQSession session = (ActiveMQSession)activeMQAsfEndpointWorker.connection.createSession(activeMQAsfEndpointWorker.transacted, acknowledge);
1:         try {
1:             if (activationSpec.isUseRAManagedTransactionEnabled()) {
1:                 endpoint = createEndpoint(null);
1:                 endpoint = createEndpoint(new LocalAndXATransaction(session.getTransactionContext()));
1:             LOG.debug("Could not create an endpoint.", e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("ServerSession requested.");
0:             ServerSessionImpl ss = idleSessions.remove(idleSessions.size() - 1);
1:             LOG.debug("Using idle session: " + ss);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Created a new session: " + ss);
/////////////////////////////////////////////////////////////////////////
1:         if (s instanceof ActiveMQSession) {
0:             session = (ActiveMQSession)s;
0:         } else if (s instanceof ActiveMQQueueSession) {
0:             session = (ActiveMQSession)s;
0:         } else if (s instanceof ActiveMQTopicSession) {
0:             session = (ActiveMQSession)s;
0:             activeMQAsfEndpointWorker.connection.onAsyncException(new JMSException("Session pool provided an invalid session type: " + s.getClass()));
0:         ServerSessionImpl ss = activeSessions.remove(0);
1:         LOG.debug("Reusing an active session: " + ss);
0:         LOG.debug("Session returned to pool: " + ss);
1:         synchronized (closing) {
1:     public void removeFromPool(ServerSessionImpl ss) {
1:             ActiveMQSession session = (ActiveMQSession)ss.getSession();
0:                 dispatchToSession((MessageDispatch)i.next());
0:             LOG.error("Error redispatching unconsumed messages from stale session", t);
1:         synchronized (closing) {
/////////////////////////////////////////////////////////////////////////
0:             while (activeSessions.size() > 0) {
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator<ServerSessionImpl> iter = idleSessions.iterator(); iter.hasNext();) {
0:             ServerSessionImpl ss = iter.next();
/////////////////////////////////////////////////////////////////////////
1:     public boolean isClosing() {
1:     public void setClosing(boolean closing) {
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:202b3ef
/////////////////////////////////////////////////////////////////////////
0:             log.debug("Could not create an endpoint.", e);
/////////////////////////////////////////////////////////////////////////
1:                 // then reuse the already created sessions..
1:             // We may not be able to create a session due to the container
0:                 if (idleSessions.size() == 0) {
0:                     throw new JMSException("Endpoint factory did not allows to any endpoints.");
1:                 }
1: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:fd4bb60
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.ra;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQQueueSession;
1: import org.apache.activemq.ActiveMQSession;
0: import org.apache.activemq.ActiveMQTopicSession;
1: import org.apache.activemq.command.MessageDispatch;
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(ServerSessionPoolImpl.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:58e5b9a
/////////////////////////////////////////////////////////////////////////
0:         final ActiveMQSession session = (ActiveMQSession)activeMQAsfEndpointWorker.getConnection().createSession(activeMQAsfEndpointWorker.transacted, acknowledge);
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             // make sure we only return non-stale sessions to the pool
1:             if ( ss.isStale() ) {
1:                 if ( LOG.isDebugEnabled() ) {
1:                     LOG.debug("Discarding stale ServerSession to be returned to pool: " + ss);
1:                 }
1:                 ss.close();
1:             } else {
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("ServerSession returned to pool: " + ss);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:             activeMQAsfEndpointWorker.getConnection()
/////////////////////////////////////////////////////////////////////////
0:     protected int closeIdleSessions() {
commit:bbd2e47
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0:     private List<ServerSessionImpl> idleSessions = new ArrayList<ServerSessionImpl>();
0:     private List<ServerSessionImpl> activeSessions = new ArrayList<ServerSessionImpl>();
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Could not create an endpoint.", e);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("ServerSession requested.");
1:         }
1:         ServerSessionImpl ss = null;
0:         synchronized (idleSessions) {
1:             if (idleSessions.size() > 0) {
1:                 ss = idleSessions.remove(idleSessions.size() - 1);
1:             }
1:         }
1:         if (ss != null) {
0:             synchronized (activeSessions) {
1:                 activeSessions.add(ss);
1:             }
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Using idle session: " + ss);
1:             }
1:         }
1: 
0:         synchronized (activeSessions) {
/////////////////////////////////////////////////////////////////////////
1: 
1:         ss = createServerSessionImpl();
0:         // We may not be able to create a session due to the container
1:         // restricting us.
1:         if (ss == null) {
0:             synchronized (activeSessions) {
0:                 if (activeSessions.isEmpty()) {
0:                     throw new JMSException(
0:                             "Endpoint factory did not allow creation any endpoints.");
1:                 }
1:             }
1: 
0:             return getExistingServerSession();
1:         }
0:         synchronized (activeSessions) {
1:             activeSessions.add(ss);
1:         }
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Created a new session: " + ss);
1:         }
1:         return ss;
1: 
1:      * @param messageDispatch
1:      *            the message to dispatch
1:     private void dispatchToSession(MessageDispatch messageDispatch)
1:             throws JMSException {
1:             session = (ActiveMQSession) s;
1:             session = (ActiveMQSession) s;
1:             session = (ActiveMQSession) s;
0:             activeMQAsfEndpointWorker.connection
1:                     .onAsyncException(new JMSException(
1:                             "Session pool provided an invalid session type: "
1:                                     + s.getClass()));
1:      * @return session
1:         ServerSessionImpl ss = null;
1:         if (!activeSessions.isEmpty()) {
1:             if (activeSessions.size() > 1) {
1:                 // round robin
1:                 ss = activeSessions.remove(0);
1:                 activeSessions.add(ss);
1:             } else {
1:                 ss = activeSessions.get(0);
1:             }
1:         }
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Reusing an active session: " + ss);
1:         }
1:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Session returned to pool: " + ss);
1:         }
0:         synchronized(activeSessions) {
1:             activeSessions.remove(ss);
1:         }
0:         synchronized(idleSessions) {
1:             idleSessions.add(ss);
1:         }
0:         synchronized(activeSessions) {
1:             activeSessions.remove(ss);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         closing.set(true);
0:         closeIdleSessions();
1:         // we may have to wait erroneously 250ms if an
1:         // active session is removed during our wait and we
1:         // are not notified
0:         while (getActiveSessionSize() > 0) {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Active Sessions = " + getActiveSessionSize());
1:             try {
1:                 synchronized (closing) {
1:                     closing.wait(250);
1:                 }
1:             } catch (InterruptedException e) {
1:                 Thread.currentThread().interrupt();
1:                 return;
1:             }
0:             closeIdleSessions();
1:     
0:         synchronized(idleSessions) {
0:             for (Iterator<ServerSessionImpl> iter = idleSessions.iterator(); iter.hasNext();) {
0:                 ServerSessionImpl ss = iter.next();
1:                 ss.close();
1:             }
1:             idleSessions.clear();
/////////////////////////////////////////////////////////////////////////
1:     
1:     
0:     private int getActiveSessionSize() {
0:         synchronized(activeSessions) {
1:             return activeSessions.size();
1:         }
1:     }
commit:91a0542
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Active Sessions = " + activeSessions.size());
commit:d0da99a
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     private List idleSessions = new CopyOnWriteArrayList();
0:     private List activeSessions = new CopyOnWriteArrayList();
0:     private AtomicBoolean closing = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:     public ServerSession getServerSession() throws JMSException {
1:         if (closing.get()) {
0:             activeSessions.add(ss);
/////////////////////////////////////////////////////////////////////////
0:             activeSessions.add(ss);
/////////////////////////////////////////////////////////////////////////
0:         ServerSessionImpl ss = (ServerSessionImpl) activeSessions.remove(0);
0:         activeSessions.add(ss);
1:     public void returnToPool(ServerSessionImpl ss) {
0:         synchronized(closing){
1:             closing.notify();
1:         }
0:      public void removeFromPool(ServerSessionImpl ss) {
/////////////////////////////////////////////////////////////////////////
0:         synchronized(closing){
1:             closing.notify();
1:         }
0:         synchronized (closing) {
0:             closing.set(true);
0:                 System.out.println("ACtive Sessions = " + activeSessions.size());
0:                     closing.wait(1000);
/////////////////////////////////////////////////////////////////////////
1:         return closing.get();
1:         this.closing.set(closing);
commit:d8bdbe7
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return Returns the closing.
1:      */
0:     public boolean isClosing(){
0:         return closing;
1:     }
1: 
1:     /**
1:      * @param closing The closing to set.
1:      */
0:     public void setClosing(boolean closing){
0:         this.closing=closing;
1:     }
1: 
author:David Jencks
-------------------------------------------------------------------------------
commit:8d28bbf
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.Lock;
1: import java.util.concurrent.locks.ReentrantLock;
/////////////////////////////////////////////////////////////////////////
1:     private final List<ServerSessionImpl> idleSessions = new ArrayList<ServerSessionImpl>();
1:     private final List<ServerSessionImpl> activeSessions = new ArrayList<ServerSessionImpl>();
1:     private final Lock sessionLock = new ReentrantLock();
1:     private final AtomicBoolean closing = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
1:         sessionLock.lock();
1:         try {
1:             ss = getExistingServerSession(false);
1:         } finally {
1:             sessionLock.unlock();
1:         sessionLock.lock();
1:         try {
0:             // We may not be able to create a session due to the container
0:             // restricting us.
0:             if (ss == null) {
1:                 if (activeSessions.isEmpty() && idleSessions.isEmpty()) {
1:                     throw new JMSException("Endpoint factory did not allow creation of any endpoints.");
1:                 ss = getExistingServerSession(true);
1:             } else {
0:                 activeSessions.add(ss);
1:             }
1:         } finally {
1:             sessionLock.unlock();
/////////////////////////////////////////////////////////////////////////
1:      * Must be called with sessionLock held.
1:      * Returns an idle session if one exists or an active session if no more
1:      * sessions can be created.  Sessions can not be created if force is true
1:      * or activeSessions >= maxSessions.
1:      * @param force do not check activeSessions >= maxSessions, return an active connection anyway.
1:      * @return an already existing session.
1:      */
1:     private ServerSessionImpl getExistingServerSession(boolean force) {
1:         ServerSessionImpl ss = null;
0:         if (idleSessions.size() > 0) {
0:             ss = idleSessions.remove(idleSessions.size() - 1);
1:         }
1:         if (ss != null) {
0:             activeSessions.add(ss);
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Using idle session: " + ss);
1:             }
1:         } else if (force || activeSessions.size() >= maxSessions) {
1:             // If we are at the upper limit
0:             // then reuse the already created sessions..
1:             // This is going to queue up messages into a session for
1:             // processing.
1:             ss = getExistingActiveServerSession();
1:         }
1:         return ss;
1:     }
1: 
1:     /**
1:      * Must be called with sessionLock held.
1:      * Returns the first session from activeSessions, shifting it to last.
0:      * @return session
1:      */
1:     private ServerSessionImpl getExistingActiveServerSession() {
1:         ServerSessionImpl ss = null;
0:         if (!activeSessions.isEmpty()) {
0:             if (activeSessions.size() > 1) {
0:                 // round robin
0:                 ss = activeSessions.remove(0);
0:                 activeSessions.add(ss);
1:             } else {
0:                 ss = activeSessions.get(0);
1:             }
1:         }
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Reusing an active session: " + ss);
1:         }
1:         return ss;
1:     }
1: 
0:     public void returnToPool(ServerSessionImpl ss) {
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Session returned to pool: " + ss);
1:         }
1:         sessionLock.lock();
1:         try {
0:             activeSessions.remove(ss);
0:             idleSessions.add(ss);
1:         } finally {
1:             sessionLock.unlock();
1:         }
0:         synchronized (closing) {
0:             closing.notify();
1:         }
1:     }
1: 
0:     public void removeFromPool(ServerSessionImpl ss) {
1:         sessionLock.lock();
1:         try {
0:             activeSessions.remove(ss);
1:         } finally {
1:             sessionLock.unlock();
1:         }
1:         try {
0:             ActiveMQSession session = (ActiveMQSession)ss.getSession();
0:             List l = session.getUnconsumedMessages();
0:             for (Iterator i = l.iterator(); i.hasNext();) {
0:                 dispatchToSession((MessageDispatch)i.next());
1:             }
1:         } catch (Throwable t) {
0:             LOG.error("Error redispatching unconsumed messages from stale session", t);
1:         }
1:         ss.close();
0:         synchronized (closing) {
0:             closing.notify();
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:         int activeCount = closeIdleSessions();
1:         while (activeCount > 0) {
1:                 LOG.debug("Active Sessions = " + activeCount);
/////////////////////////////////////////////////////////////////////////
0:             activeCount = closeIdleSessions();
1: 
0:     private int closeIdleSessions() {
1:         sessionLock.lock();
0:         try {
1:             for (ServerSessionImpl ss : idleSessions) {
0:             return activeSessions.size();
1:         } finally {
1:             sessionLock.unlock();
/////////////////////////////////////////////////////////////////////////
1: 
commit:c57bad8
/////////////////////////////////////////////////////////////////////////
0:                 if (activeSessions.size() == 0) {
0:                     //no idle sessions, no active sessions, and we can't create a new session....
0:                     throw new JMSException("Endpoint factory did not allow creation of any endpoints.");
author:James Strachan
-------------------------------------------------------------------------------
commit:d7355e7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         MessageActivationSpec activationSpec = activeMQAsfEndpointWorker.endpointActivationKey.getActivationSpec();
/////////////////////////////////////////////////////////////////////////
0:      * @param messageDispatch the message to dispatch
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 Hiram Chirino
0:  * Copyright 2005 LogicBlaze Inc.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  *
0:  **/
0: package org.activemq.ra;
1: 
0: import java.util.ArrayList;
1: import java.util.Iterator;
0: import java.util.LinkedList;
1: import java.util.List;
1: 
1: import javax.jms.JMSException;
1: import javax.jms.ServerSession;
1: import javax.jms.ServerSessionPool;
1: import javax.jms.Session;
1: import javax.resource.spi.UnavailableException;
1: import javax.resource.spi.endpoint.MessageEndpoint;
1: 
0: import org.activemq.ActiveMQQueueSession;
0: import org.activemq.ActiveMQSession;
0: import org.activemq.ActiveMQTopicSession;
0: import org.activemq.command.MessageDispatch;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
0:  * @version $Revision$ $Date$
1:  */
1: public class ServerSessionPoolImpl implements ServerSessionPool {
1:     
0:     private static final Log log = LogFactory.getLog(ServerSessionPoolImpl.class);
1: 
1:     private final ActiveMQEndpointWorker activeMQAsfEndpointWorker;
1:     private final int maxSessions;
1: 
0:     private ArrayList idleSessions = new ArrayList();
0:     private LinkedList activeSessions = new LinkedList();
0:     private boolean closing = false;
1: 
1:     public ServerSessionPoolImpl(ActiveMQEndpointWorker activeMQAsfEndpointWorker, int maxSessions) {
1:         this.activeMQAsfEndpointWorker = activeMQAsfEndpointWorker;
0:         this.maxSessions=maxSessions;
0:     }
1: 
1:     private ServerSessionImpl createServerSessionImpl() throws JMSException {
0:         ActiveMQActivationSpec activationSpec = activeMQAsfEndpointWorker.endpointActivationKey.getActivationSpec();
1:         int acknowledge = (activeMQAsfEndpointWorker.transacted) ? Session.SESSION_TRANSACTED : activationSpec.getAcknowledgeModeForSession();
0:         final ActiveMQSession session = (ActiveMQSession) activeMQAsfEndpointWorker.connection.createSession(activeMQAsfEndpointWorker.transacted,acknowledge);            
1:         MessageEndpoint endpoint;
0:         try {                
1:             int batchSize = 0;
1:             if (activationSpec.getEnableBatchBooleanValue()) {
1:                 batchSize = activationSpec.getMaxMessagesPerBatchIntValue();
0:             }
0:             if( activationSpec.isUseRAManagedTransactionEnabled() ) {
1:                 // The RA will manage the transaction commit.
0:                 endpoint = createEndpoint(null);   
0:                 return new ServerSessionImpl(this, (ActiveMQSession)session, activeMQAsfEndpointWorker.workManager, endpoint, true, batchSize);
1:             } else {
1:                 // Give the container an object to manage to transaction with.
0:                 endpoint = createEndpoint(new LocalAndXATransaction(session.getTransactionContext()));                
0:                 return new ServerSessionImpl(this, (ActiveMQSession)session, activeMQAsfEndpointWorker.workManager, endpoint, false, batchSize);
0:             }
1:         } catch (UnavailableException e) {
1:             // The container could be limiting us on the number of endpoints
1:             // that are being created.
1:             session.close();
1:             return null;
0:         }
0:     }
1: 
1:     private MessageEndpoint createEndpoint(LocalAndXATransaction txResourceProxy) throws UnavailableException {
1:         MessageEndpoint endpoint;
1:         endpoint = activeMQAsfEndpointWorker.endpointFactory.createEndpoint(txResourceProxy);
1:         MessageEndpointProxy endpointProxy = new MessageEndpointProxy(endpoint);
1:         return endpointProxy;
0:     }
1: 
1:     /**
1:      */
0:     synchronized public ServerSession getServerSession() throws JMSException {
0:         log.debug("ServerSession requested.");
0:         if (closing) {
1:             throw new JMSException("Session Pool Shutting Down.");
0:         }
1: 
0:         if (idleSessions.size() > 0) {
0:             ServerSessionImpl ss = (ServerSessionImpl) idleSessions.remove(idleSessions.size() - 1);
0:             activeSessions.addLast(ss);
0:             log.debug("Using idle session: " + ss);
1:             return ss;
1:         } else {
0:             // Are we at the upper limit?
0:             if (activeSessions.size() >= maxSessions) {
0:                 // then reuse the allready created sessions..
0:                 // This is going to queue up messages into a session for
0:                 // processing.
0:                 return getExistingServerSession();
0:             }
0:             ServerSessionImpl ss = createServerSessionImpl();
0:             // We may not be able to create a session due to the conatiner
0:             // restricting us.
0:             if (ss == null) {
0:                 return getExistingServerSession();
0:             }
0:             activeSessions.addLast(ss);
0:             log.debug("Created a new session: " + ss);
1:             return ss;
0:         }
0:     }
1: 
1:     /**
0:      * @param message
1:      * @throws JMSException
1:      */
0:     private void dispatchToSession(MessageDispatch messageDispatch) throws JMSException {
1: 
1:         ServerSession serverSession = getServerSession();
1:         Session s = serverSession.getSession();
1:         ActiveMQSession session = null;
0:         if( s instanceof ActiveMQSession ) {
0:             session = (ActiveMQSession) s;
0:         } else if(s instanceof ActiveMQQueueSession) {
0:             session = (ActiveMQSession) s;
0:         } else if(s instanceof ActiveMQTopicSession) {
0:             session = (ActiveMQSession) s;
1:         } else {
0:         	activeMQAsfEndpointWorker.connection.onAsyncException(new JMSException("Session pool provided an invalid session type: "+s.getClass()));
0:         }
1:         session.dispatch(messageDispatch);
1:         serverSession.start();
0:     }
1: 
1:     
1:     /**
0:      * @return
1:      */
0:     private ServerSession getExistingServerSession() {
0:         ServerSessionImpl ss = (ServerSessionImpl) activeSessions.removeFirst();
0:         activeSessions.addLast(ss);
0:         log.debug("Reusing an active session: " + ss);
1:         return ss;
0:     }
1: 
0:     synchronized public void returnToPool(ServerSessionImpl ss) {
0:         log.debug("Session returned to pool: " + ss);
0:         activeSessions.remove(ss);
0:         idleSessions.add(ss);
0:         notify();
0:     }
1: 
0:     synchronized public void removeFromPool(ServerSessionImpl ss) {
0:         activeSessions.remove(ss);
0:         try {
0:             ActiveMQSession session = (ActiveMQSession) ss.getSession();
0:             List l = session.getUnconsumedMessages();
0:             for (Iterator i = l.iterator(); i.hasNext();) {
0:                 dispatchToSession((MessageDispatch) i.next());        			
0:             }
0:         } catch (Throwable t) {
0:             log.error("Error redispatching unconsumed messages from stale session", t);    	
0:         }
0:         ss.close();
0:         notify();
0:     }
1: 
1:     public void close() {
0:         synchronized (this) {
0:             closing = true;
0:             closeIdleSessions();
0:             while( activeSessions.size() > 0 ) {
0:                 try {
0:                     wait();
0:                 } catch (InterruptedException e) {
0:                     Thread.currentThread().interrupt();
0:                     return;
0:                 }
0:                 closeIdleSessions();
0:             }
0:         }
0:     }
1: 
0:     private void closeIdleSessions() {
0:         for (Iterator iter = idleSessions.iterator(); iter.hasNext();) {
0:             ServerSessionImpl ss = (ServerSessionImpl) iter.next();
0:             ss.close();
0:         }
0:     }
1: 
0: }
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:92a698f
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2004 The Apache Software Foundation
/////////////////////////////////////////////////////////////////////////
0:  */
============================================================================