1:651a5fe: /**
1:651a5fe:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:651a5fe:  * contributor license agreements.  See the NOTICE file distributed with
1:651a5fe:  * this work for additional information regarding copyright ownership.
1:651a5fe:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:651a5fe:  * (the "License"); you may not use this file except in compliance with
1:651a5fe:  * the License.  You may obtain a copy of the License at
1:651a5fe:  *
1:651a5fe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:651a5fe:  *
1:651a5fe:  * Unless required by applicable law or agreed to in writing, software
1:651a5fe:  * distributed under the License is distributed on an "AS IS" BASIS,
1:651a5fe:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:651a5fe:  * See the License for the specific language governing permissions and
1:651a5fe:  * limitations under the License.
1:651a5fe:  */
1:3c8df79: package org.apache.bugs;
1:600f209: 
1:3c8df79: import static org.junit.Assert.assertTrue;
1:3c8df79: import static org.junit.Assert.fail;
1:600f209: 
1:3c8df79: import java.util.concurrent.Callable;
1:3c8df79: import java.util.concurrent.CountDownLatch;
1:3c8df79: import java.util.concurrent.ExecutorService;
1:3c8df79: import java.util.concurrent.Executors;
1:3c8df79: import java.util.concurrent.TimeUnit;
1:3c8df79: import java.util.concurrent.atomic.AtomicInteger;
10:3c8df79: 
1:3c8df79: import javax.jms.JMSException;
1:3c8df79: import javax.jms.Message;
1:3c8df79: import javax.jms.MessageListener;
1:3c8df79: import javax.jms.Session;
1:3c8df79: import javax.jms.TextMessage;
1:3c8df79: 
1:3c8df79: import org.apache.activemq.ActiveMQConnectionFactory;
1:3c8df79: import org.apache.activemq.broker.BrokerRegistry;
1:3c8df79: import org.apache.activemq.broker.BrokerService;
1:3c8df79: import org.apache.activemq.command.ActiveMQQueue;
1:3c8df79: import org.apache.activemq.network.NetworkConnector;
1:3c8df79: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
1:14dcc2a: import org.junit.Ignore;
1:600f209: import org.junit.Test;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:3c8df79: import org.springframework.jms.connection.CachingConnectionFactory;
1:3c8df79: import org.springframework.jms.connection.SingleConnectionFactory;
1:3c8df79: import org.springframework.jms.core.JmsTemplate;
1:3c8df79: import org.springframework.jms.core.MessageCreator;
1:3c8df79: import org.springframework.jms.listener.DefaultMessageListenerContainer;
1:3c8df79: 
1:3c8df79: public class LoadBalanceTest {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(LoadBalanceTest.class);
1:3c8df79:     private static final String TESTING_QUEUE = "testingqueue";
1:3c8df79:     private static int networkBridgePrefetch = 1000;
1:3c8df79: 
1:091ee37:     @Test(timeout=120000)
1:3c8df79:     public void does_load_balance_between_consumers() throws Exception {
1:3c8df79:         BrokerService brokerService1 = null;
1:3c8df79:         BrokerService brokerService2 = null;
1:3c8df79:         final int total = 100;
1:3c8df79:         final AtomicInteger broker1Count = new AtomicInteger(0);
1:3c8df79:         final AtomicInteger broker2Count = new AtomicInteger(0);
1:b6672d1:         final CountDownLatch startProducer = new CountDownLatch(1);
1:091ee37:         final CountDownLatch consumer1Started = new CountDownLatch(1);
1:091ee37:         final CountDownLatch consumer2Started = new CountDownLatch(1);
1:600f209: 
1:600f209:         String broker1Uri;
1:600f209:         String broker2Uri;
1:600f209: 
1:3c8df79:         try {
1:600f209:             brokerService1 = new BrokerService();
1:600f209:             brokerService1.setBrokerName("one");
1:600f209:             brokerService1.setUseJmx(false);
1:600f209:             brokerService1.setPersistenceAdapter(new MemoryPersistenceAdapter());
1:600f209:             broker1Uri = brokerService1.addConnector("nio://0.0.0.0:0").getPublishableConnectString();
1:600f209: 
1:600f209:             brokerService2 = new BrokerService();
1:600f209:             brokerService2.setBrokerName("two");
1:600f209:             brokerService2.setUseJmx(false);
1:600f209:             brokerService2.setPersistenceAdapter(new MemoryPersistenceAdapter());
1:600f209:             broker2Uri = brokerService2.addConnector("nio://0.0.0.0:0").getPublishableConnectString();
1:600f209: 
1:600f209:             final NetworkConnector network1 = brokerService1.addNetworkConnector("static:("+broker2Uri+")");
1:600f209:             network1.setName("network1");
1:600f209:             network1.setDynamicOnly(true);
1:600f209:             network1.setNetworkTTL(3);
1:600f209:             network1.setPrefetchSize(networkBridgePrefetch);
1:600f209:             network1.setConduitSubscriptions(false);
1:600f209:             network1.setDecreaseNetworkConsumerPriority(false);
1:600f209:             network1.setDispatchAsync(false);
1:600f209: 
1:600f209:             final NetworkConnector network2 = brokerService2.addNetworkConnector("static:("+broker1Uri+")");
1:600f209:             network2.setName("network1");
1:600f209:             network2.setDynamicOnly(true);
1:600f209:             network2.setNetworkTTL(3);
1:600f209:             network2.setPrefetchSize(networkBridgePrefetch);
1:600f209:             network2.setConduitSubscriptions(false);
1:600f209:             network2.setDecreaseNetworkConsumerPriority(false);
1:600f209:             network2.setDispatchAsync(false);
1:600f209: 
1:600f209:             brokerService1.start();
1:600f209:             brokerService2.start();
1:600f209: 
1:3c8df79:             final ExecutorService pool = Executors.newSingleThreadExecutor();
1:600f209:             final ActiveMQConnectionFactory connectionFactory1 = new ActiveMQConnectionFactory("vm://one");
1:600f209:             final SingleConnectionFactory singleConnectionFactory1 = new SingleConnectionFactory(connectionFactory1);
1:3c8df79:             singleConnectionFactory1.setReconnectOnException(true);
1:3c8df79:             final DefaultMessageListenerContainer container1 = new DefaultMessageListenerContainer();
1:3c8df79:             container1.setConnectionFactory(singleConnectionFactory1);
1:3c8df79:             container1.setMaxConcurrentConsumers(1);
1:3c8df79:             container1.setDestination(new ActiveMQQueue("testingqueue"));
1:3c8df79:             container1.setMessageListener(new MessageListener() {
1:3c8df79: 
1:600f209:                 @Override
1:3c8df79:                 public void onMessage(final Message message) {
1:3c8df79:                     broker1Count.incrementAndGet();
4:3c8df79:                 }
1:3c8df79:             });
1:3c8df79:             container1.afterPropertiesSet();
1:3c8df79:             container1.start();
1:091ee37:             consumer1Started.countDown();
1:3c8df79:             pool.submit(new Callable<Object>() {
1:3c8df79: 
1:600f209:                 @Override
1:3c8df79:                 public Object call() throws Exception {
1:3c8df79:                     try {
1:3c8df79:                         final ActiveMQConnectionFactory connectionFactory2 = new ActiveMQConnectionFactory(
1:3c8df79:                                 "vm://two");
1:3c8df79:                         final SingleConnectionFactory singleConnectionFactory2 = new SingleConnectionFactory(
1:3c8df79:                                 connectionFactory2);
1:3c8df79:                         singleConnectionFactory2.setReconnectOnException(true);
1:3c8df79:                         final DefaultMessageListenerContainer container2 = new DefaultMessageListenerContainer();
1:3c8df79:                         container2
1:3c8df79:                                 .setConnectionFactory(singleConnectionFactory2);
1:3c8df79:                         container2.setMaxConcurrentConsumers(1);
1:3c8df79:                         container2.setDestination(new ActiveMQQueue(
1:3c8df79:                                 "testingqueue"));
1:3c8df79:                         container2.setMessageListener(new MessageListener() {
1:3c8df79: 
1:600f209:                             @Override
1:3c8df79:                             public void onMessage(final Message message) {
1:3c8df79:                                 broker2Count.incrementAndGet();
1:3c8df79:                             }
1:3c8df79:                         });
1:3c8df79:                         container2.afterPropertiesSet();
1:3c8df79:                         container2.start();
1:091ee37:                         consumer2Started.countDown();
1:b6672d1: 
1:b6672d1:                         assertTrue("wait for start signal", startProducer.await(20, TimeUnit.SECONDS));
1:b6672d1: 
1:3c8df79:                         final CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory(
1:3c8df79:                                 singleConnectionFactory2);
1:3c8df79:                         final JmsTemplate template = new JmsTemplate(
1:3c8df79:                                 cachingConnectionFactory);
1:3c8df79:                         final ActiveMQQueue queue = new ActiveMQQueue(
1:3c8df79:                                 "testingqueue");
1:3c8df79:                         for (int i = 0; i < total; i++) {
1:3c8df79:                             template.send(queue, new MessageCreator() {
1:3c8df79: 
1:600f209:                                 @Override
1:3c8df79:                                 public Message createMessage(
1:3c8df79:                                         final Session session)
1:3c8df79:                                         throws JMSException {
1:3c8df79:                                     final TextMessage message = session
1:3c8df79:                                             .createTextMessage();
1:3c8df79:                                     message.setText("Hello World!");
1:3c8df79:                                     return message;
1:3c8df79:                                 }
1:3c8df79:                             });
1:3c8df79:                         }
1:3c8df79:                         // give spring time to scale back again
1:3c8df79:                         while (container2.getActiveConsumerCount() > 1) {
1:3c8df79:                             System.out.println("active consumer count: "
1:3c8df79:                                     + container2.getActiveConsumerCount());
1:3c8df79:                             System.out.println("concurrent consumer count: "
1:3c8df79:                                     + container2.getConcurrentConsumers());
1:3c8df79:                             Thread.sleep(1000);
1:3c8df79:                         }
1:3c8df79:                         cachingConnectionFactory.destroy();
1:3c8df79:                         container2.destroy();
1:3c8df79:                     } catch (final Throwable t) {
1:3c8df79:                         t.printStackTrace();
1:3c8df79:                     }
1:3c8df79:                     return null;
1:3c8df79:                 }
1:3c8df79:             });
1:600f209: 
1:d04c108:             waitForBridgeFormation();
1:3c8df79:             startProducer.countDown();
1:091ee37:             consumer1Started.await();
1:091ee37:             consumer2Started.await();
1:3c8df79: 
1:6f5b224:             pool.shutdown();
1:091ee37:             pool.awaitTermination(20, TimeUnit.SECONDS);
1:3c8df79:             LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1:b6672d1: 
1:3c8df79:             int count = 0;
1:3c8df79:             // give it 10 seconds
1:3c8df79:             while (count++ < 10
1:3c8df79:                     && broker1Count.get() + broker2Count.get() != total) {
1:3c8df79:                 LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1:3c8df79:                 Thread.sleep(1000);
1:3c8df79:             }
1:3c8df79:             container1.destroy();
1:3c8df79:         } finally {
1:3c8df79:             try {
1:3c8df79:                 if (brokerService1 != null) {
1:3c8df79:                     brokerService1.stop();
1:600f209:                     brokerService1.waitUntilStopped();
1:3c8df79:                 }
1:3c8df79:             } catch (final Throwable t) {
1:3c8df79:                 t.printStackTrace();
1:3c8df79:             }
1:3c8df79:             try {
1:3c8df79:                 if (brokerService2 != null) {
1:3c8df79:                     brokerService2.stop();
1:600f209:                     brokerService2.waitUntilStopped();
1:3c8df79:                 }
1:3c8df79:             } catch (final Throwable t) {
1:3c8df79:                 t.printStackTrace();
1:3c8df79:             }
1:3c8df79:         }
1:600f209: 
1:3c8df79:         if (broker1Count.get() < 25 || broker2Count.get() < 25) {
1:3c8df79:             fail("Each broker should have gotten at least 25 messages but instead broker1 got "
1:3c8df79:                     + broker1Count.get()
1:3c8df79:                     + " and broker2 got "
1:3c8df79:                     + broker2Count.get());
1:3c8df79:         }
1:3c8df79:     }
1:cd7fb69: 
2:3c8df79:     @Test
1:14dcc2a:     @Ignore("Does not work")
1:3c8df79:     public void does_xml_multicast_load_balance_between_consumers() throws Exception {
1:3c8df79:         final int total = 100;
1:3c8df79:         final AtomicInteger broker1Count = new AtomicInteger(0);
1:3c8df79:         final AtomicInteger broker2Count = new AtomicInteger(0);
1:3c8df79:         final ExecutorService pool = Executors.newSingleThreadExecutor();
1:3c8df79:         final CountDownLatch startProducer = new CountDownLatch(1);
1:3c8df79:         final String xmlConfig = getClass().getPackage().getName().replace('.','/') + "/loadbalancetest.xml";
1:3c8df79:         System.setProperty("lbt.networkBridgePrefetch", String.valueOf(networkBridgePrefetch));
1:3c8df79:         System.setProperty("lbt.brokerName", "one");
2:3c8df79:         final ActiveMQConnectionFactory connectionFactory1 = new ActiveMQConnectionFactory(
1:3c8df79:                 "vm://one?brokerConfig=xbean:" + xmlConfig);
2:3c8df79:         final SingleConnectionFactory singleConnectionFactory1 = new SingleConnectionFactory(
2:3c8df79:                 connectionFactory1);
1:3c8df79:         singleConnectionFactory1.setReconnectOnException(true);
1:3c8df79:         final DefaultMessageListenerContainer container1 = new DefaultMessageListenerContainer();
1:3c8df79:         container1.setConnectionFactory(singleConnectionFactory1);
1:3c8df79:         container1.setMaxConcurrentConsumers(1);
1:3c8df79:         container1.setDestination(new ActiveMQQueue(TESTING_QUEUE));
1:3c8df79:         container1.setMessageListener(new MessageListener() {
1:cd7fb69: 
1:600f209:             @Override
1:3c8df79:             public void onMessage(final Message message) {
1:3c8df79:                 broker1Count.incrementAndGet();
1:3c8df79:             }
1:3c8df79:         });
1:3c8df79:         container1.afterPropertiesSet();
1:3c8df79:         container1.start();
1:3c8df79:         pool.submit(new Callable<Object>() {
1:b6672d1: 
1:600f209:             @Override
1:3c8df79:             public Object call() throws Exception {
1:3c8df79:                 System.setProperty("lbt.brokerName", "two");
1:3c8df79:                 final ActiveMQConnectionFactory connectionFactory2 = new ActiveMQConnectionFactory(
1:3c8df79:                         "vm://two?brokerConfig=xbean:" + xmlConfig);
1:3c8df79:                 final SingleConnectionFactory singleConnectionFactory2 = new SingleConnectionFactory(
1:3c8df79:                         connectionFactory2);
1:3c8df79:                 singleConnectionFactory2.setReconnectOnException(true);
1:3c8df79:                 final DefaultMessageListenerContainer container2 = new DefaultMessageListenerContainer();
1:3c8df79:                 container2.setConnectionFactory(singleConnectionFactory2);
1:3c8df79:                 container2.setMaxConcurrentConsumers(1);
1:3c8df79:                 container2.setDestination(new ActiveMQQueue(TESTING_QUEUE));
1:3c8df79:                 container2.setMessageListener(new MessageListener() {
1:600f209: 
1:600f209:                     @Override
1:3c8df79:                     public void onMessage(final Message message) {
1:3c8df79:                         broker2Count.incrementAndGet();
1:3c8df79:                     }
1:3c8df79:                 });
1:3c8df79:                 container2.afterPropertiesSet();
1:3c8df79:                 container2.start();
1:600f209: 
1:600f209: 
1:3c8df79:                 assertTrue("wait for start signal", startProducer.await(20, TimeUnit.SECONDS));
1:3c8df79: 
1:3c8df79:                 final CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory(
1:3c8df79:                         singleConnectionFactory2);
1:3c8df79:                 final JmsTemplate template = new JmsTemplate(
1:3c8df79:                         cachingConnectionFactory);
1:3c8df79:                 final ActiveMQQueue queue = new ActiveMQQueue(TESTING_QUEUE);
1:3c8df79:                 for (int i = 0; i < total; i++) {
1:3c8df79:                     template.send(queue, new MessageCreator() {
1:3c8df79: 
1:600f209:                         @Override
1:3c8df79:                         public Message createMessage(final Session session)
1:3c8df79:                                 throws JMSException {
1:3c8df79:                             final TextMessage message = session
1:3c8df79:                                     .createTextMessage();
1:3c8df79:                             message.setText("Hello World!");
1:3c8df79:                             return message;
1:3c8df79:                         }
1:3c8df79:                     });
1:3c8df79:                 }
1:3c8df79:                 return null;
1:3c8df79:             }
1:3c8df79:         });
1:3c8df79: 
1:3c8df79:         // give network a chance to build, needs advisories
1:d04c108:         waitForBridgeFormation();
1:b6672d1:         startProducer.countDown();
1:600f209: 
2:3c8df79:         pool.shutdown();
2:3c8df79:         pool.awaitTermination(10, TimeUnit.SECONDS);
1:600f209: 
1:3c8df79:         LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1:3c8df79: 
1:3c8df79:         int count = 0;
1:3c8df79:         // give it 10 seconds
1:3c8df79:         while (count++ < 10 && broker1Count.get() + broker2Count.get() != total) {
1:3c8df79:             LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1:3c8df79:             Thread.sleep(1000);
1:3c8df79:         }
1:3c8df79:         if (broker1Count.get() < 25 || broker2Count.get() < 25) {
1:3c8df79:             fail("Each broker should have gotten at least 25 messages but instead broker1 got "
1:3c8df79:                     + broker1Count.get()
1:3c8df79:                     + " and broker2 got "
1:3c8df79:                     + broker2Count.get());
1:3c8df79:         }
1:3c8df79: 
1:3c8df79: 
1:cd7fb69:         BrokerService broker = BrokerRegistry.getInstance().lookup("one");
1:cd7fb69:         broker.stop();
1:cd7fb69:         broker = BrokerRegistry.getInstance().lookup("two");
1:cd7fb69:         broker.stop();
1:3c8df79:     }
1:3c8df79: 
1:3c8df79:     // need to ensure broker bridge is alive before starting the consumer
1:3c8df79:     // peeking at the internals will give us this info
1:d04c108:     private void waitForBridgeFormation() throws Exception {
1:d04c108:         long done = System.currentTimeMillis() + 30000;
1:3c8df79:         while (done > System.currentTimeMillis()) {
1:d04c108:             if (hasBridge("one") && hasBridge("two")) {
1:d04c108:                 return;
1:3c8df79:             }
1:3c8df79:             Thread.sleep(1000);
1:3c8df79:         }
1:3c8df79:     }
1:d04c108: 
1:d04c108:     private boolean hasBridge(String name) {
1:d04c108:         boolean result = false;
1:d04c108:         BrokerService broker = BrokerRegistry.getInstance().lookup(name);
1:d04c108:             if (broker != null && !broker.getNetworkConnectors().isEmpty()) {
1:d04c108:                  if (!broker.getNetworkConnectors().get(0).activeBridges().isEmpty()) {
1:d04c108:                     result = true;
1:d04c108:                  }
1:d04c108:             }
1:d04c108:         return result;
1:d04c108:     }
1:3c8df79: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:091ee37
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout=120000)
/////////////////////////////////////////////////////////////////////////
1:         final CountDownLatch consumer1Started = new CountDownLatch(1);
1:         final CountDownLatch consumer2Started = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1:             consumer1Started.countDown();
/////////////////////////////////////////////////////////////////////////
1:                         consumer2Started.countDown();
/////////////////////////////////////////////////////////////////////////
1:             consumer1Started.await();
1:             consumer2Started.await();
1:             pool.awaitTermination(20, TimeUnit.SECONDS);
commit:600f209
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Test;
/////////////////////////////////////////////////////////////////////////
1: 
1:         String broker1Uri;
1:         String broker2Uri;
1: 
1: 
1: 
1:             brokerService1 = new BrokerService();
1:             brokerService1.setBrokerName("one");
1:             brokerService1.setUseJmx(false);
1:             brokerService1.setPersistenceAdapter(new MemoryPersistenceAdapter());
1:             broker1Uri = brokerService1.addConnector("nio://0.0.0.0:0").getPublishableConnectString();
1: 
1:             brokerService2 = new BrokerService();
1:             brokerService2.setBrokerName("two");
1:             brokerService2.setUseJmx(false);
1:             brokerService2.setPersistenceAdapter(new MemoryPersistenceAdapter());
1:             broker2Uri = brokerService2.addConnector("nio://0.0.0.0:0").getPublishableConnectString();
1: 
1:             final NetworkConnector network1 = brokerService1.addNetworkConnector("static:("+broker2Uri+")");
1:             network1.setName("network1");
1:             network1.setDynamicOnly(true);
1:             network1.setNetworkTTL(3);
1:             network1.setPrefetchSize(networkBridgePrefetch);
1:             network1.setConduitSubscriptions(false);
1:             network1.setDecreaseNetworkConsumerPriority(false);
1:             network1.setDispatchAsync(false);
1: 
1:             final NetworkConnector network2 = brokerService2.addNetworkConnector("static:("+broker1Uri+")");
1:             network2.setName("network1");
1:             network2.setDynamicOnly(true);
1:             network2.setNetworkTTL(3);
1:             network2.setPrefetchSize(networkBridgePrefetch);
1:             network2.setConduitSubscriptions(false);
1:             network2.setDecreaseNetworkConsumerPriority(false);
1:             network2.setDispatchAsync(false);
1: 
1:             brokerService1.start();
1:             brokerService2.start();
1: 
1:             final ActiveMQConnectionFactory connectionFactory1 = new ActiveMQConnectionFactory("vm://one");
1:             final SingleConnectionFactory singleConnectionFactory1 = new SingleConnectionFactory(connectionFactory1);
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                             @Override
/////////////////////////////////////////////////////////////////////////
1:                                 @Override
/////////////////////////////////////////////////////////////////////////
1:                     brokerService1.waitUntilStopped();
/////////////////////////////////////////////////////////////////////////
1:                     brokerService2.waitUntilStopped();
1: 
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:14dcc2a
/////////////////////////////////////////////////////////////////////////
1: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
1:     @Ignore("Does not work")
author:Gary Tully
-------------------------------------------------------------------------------
commit:d04c108
/////////////////////////////////////////////////////////////////////////
1:             waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:         waitForBridgeFormation();
/////////////////////////////////////////////////////////////////////////
1:     private void waitForBridgeFormation() throws Exception {
1:         long done = System.currentTimeMillis() + 30000;
1:             if (hasBridge("one") && hasBridge("two")) {
1:                 return;
1: 
1:     private boolean hasBridge(String name) {
1:         boolean result = false;
1:         BrokerService broker = BrokerRegistry.getInstance().lookup(name);
1:             if (broker != null && !broker.getNetworkConnectors().isEmpty()) {
1:                  if (!broker.getNetworkConnectors().get(0).activeBridges().isEmpty()) {
1:                     result = true;
1:                  }
1:             }
1:         return result;
1:     }
commit:cd7fb69
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         BrokerService broker = BrokerRegistry.getInstance().lookup("one");
1:         broker.stop();
1:         broker = BrokerRegistry.getInstance().lookup("two");
1:         broker.stop();
commit:6f5b224
/////////////////////////////////////////////////////////////////////////
1:             pool.shutdown();
commit:b6672d1
/////////////////////////////////////////////////////////////////////////
1:         final CountDownLatch startProducer = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1: 
1:                         assertTrue("wait for start signal", startProducer.await(20, TimeUnit.SECONDS));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:             waitForBridgeFormation(10000);
1:             startProducer.countDown();
1: 
commit:6ebedcc
/////////////////////////////////////////////////////////////////////////
0:                 network1.setDispatchAsync(false);
/////////////////////////////////////////////////////////////////////////
0:                 network2.setDispatchAsync(false);
commit:651a5fe
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
commit:3c8df79
/////////////////////////////////////////////////////////////////////////
1: package org.apache.bugs;
1: 
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
1: import java.util.concurrent.Callable;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerRegistry;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.junit.Test;
1: import org.springframework.jms.connection.CachingConnectionFactory;
1: import org.springframework.jms.connection.SingleConnectionFactory;
1: import org.springframework.jms.core.JmsTemplate;
1: import org.springframework.jms.core.MessageCreator;
1: import org.springframework.jms.listener.DefaultMessageListenerContainer;
1: 
1: public class LoadBalanceTest {
0:     private static final Log LOG = LogFactory.getLog(LoadBalanceTest.class);
1:     private static final String TESTING_QUEUE = "testingqueue";
1:     private static int networkBridgePrefetch = 1000;
1: 
1:     @Test
1:     public void does_load_balance_between_consumers() throws Exception {
1:         BrokerService brokerService1 = null;
1:         BrokerService brokerService2 = null;
1:         final int total = 100;
1:         final AtomicInteger broker1Count = new AtomicInteger(0);
1:         final AtomicInteger broker2Count = new AtomicInteger(0);
1:         try {
0:             {
0:                 brokerService1 = new BrokerService();
0:                 brokerService1.setBrokerName("one");
0:                 brokerService1.setUseJmx(false);
0:                 brokerService1
0:                         .setPersistenceAdapter(new MemoryPersistenceAdapter());
0:                 brokerService1.addConnector("nio://0.0.0.0:61616");
0:                 final NetworkConnector network1 = brokerService1
0:                         .addNetworkConnector("static:(tcp://localhost:51515)");
0:                 network1.setName("network1");
0:                 network1.setDynamicOnly(true);
0:                 network1.setNetworkTTL(3);
0:                 network1.setPrefetchSize(networkBridgePrefetch);
0:                 network1.setConduitSubscriptions(false);
0:                 network1.setDecreaseNetworkConsumerPriority(false);
0:                 brokerService1.start();
1:             }
0:             {
0:                 brokerService2 = new BrokerService();
0:                 brokerService2.setBrokerName("two");
0:                 brokerService2.setUseJmx(false);
0:                 brokerService2
0:                         .setPersistenceAdapter(new MemoryPersistenceAdapter());
0:                 brokerService2.addConnector("nio://0.0.0.0:51515");
0:                 final NetworkConnector network2 = brokerService2
0:                         .addNetworkConnector("static:(tcp://localhost:61616)");
0:                 network2.setName("network1");
0:                 network2.setDynamicOnly(true);
0:                 network2.setNetworkTTL(3);
0:                 network2.setPrefetchSize(networkBridgePrefetch);
0:                 network2.setConduitSubscriptions(false);
0:                 network2.setDecreaseNetworkConsumerPriority(false);
0:                 brokerService2.start();
1:             }
1:             final ExecutorService pool = Executors.newSingleThreadExecutor();
1:             final ActiveMQConnectionFactory connectionFactory1 = new ActiveMQConnectionFactory(
0:                     "vm://one");
1:             final SingleConnectionFactory singleConnectionFactory1 = new SingleConnectionFactory(
1:                     connectionFactory1);
1:             singleConnectionFactory1.setReconnectOnException(true);
1:             final DefaultMessageListenerContainer container1 = new DefaultMessageListenerContainer();
1:             container1.setConnectionFactory(singleConnectionFactory1);
1:             container1.setMaxConcurrentConsumers(1);
1:             container1.setDestination(new ActiveMQQueue("testingqueue"));
1:             container1.setMessageListener(new MessageListener() {
1: 
1:                 public void onMessage(final Message message) {
1:                     broker1Count.incrementAndGet();
1:                 }
1:             });
1:             container1.afterPropertiesSet();
1:             container1.start();
1:             pool.submit(new Callable<Object>() {
1: 
1:                 public Object call() throws Exception {
1:                     try {
1:                         final ActiveMQConnectionFactory connectionFactory2 = new ActiveMQConnectionFactory(
1:                                 "vm://two");
1:                         final SingleConnectionFactory singleConnectionFactory2 = new SingleConnectionFactory(
1:                                 connectionFactory2);
1:                         singleConnectionFactory2.setReconnectOnException(true);
1:                         final DefaultMessageListenerContainer container2 = new DefaultMessageListenerContainer();
1:                         container2
1:                                 .setConnectionFactory(singleConnectionFactory2);
1:                         container2.setMaxConcurrentConsumers(1);
1:                         container2.setDestination(new ActiveMQQueue(
1:                                 "testingqueue"));
1:                         container2.setMessageListener(new MessageListener() {
1: 
1:                             public void onMessage(final Message message) {
1:                                 broker2Count.incrementAndGet();
1:                             }
1:                         });
1:                         container2.afterPropertiesSet();
1:                         container2.start();
1:                         final CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory(
1:                                 singleConnectionFactory2);
1:                         final JmsTemplate template = new JmsTemplate(
1:                                 cachingConnectionFactory);
1:                         final ActiveMQQueue queue = new ActiveMQQueue(
1:                                 "testingqueue");
1:                         for (int i = 0; i < total; i++) {
1:                             template.send(queue, new MessageCreator() {
1: 
1:                                 public Message createMessage(
1:                                         final Session session)
1:                                         throws JMSException {
1:                                     final TextMessage message = session
1:                                             .createTextMessage();
1:                                     message.setText("Hello World!");
1:                                     return message;
1:                                 }
1:                             });
1:                         }
1:                         // give spring time to scale back again
1:                         while (container2.getActiveConsumerCount() > 1) {
1:                             System.out.println("active consumer count: "
1:                                     + container2.getActiveConsumerCount());
1:                             System.out.println("concurrent consumer count: "
1:                                     + container2.getConcurrentConsumers());
1:                             Thread.sleep(1000);
1:                         }
1:                         cachingConnectionFactory.destroy();
1:                         container2.destroy();
1:                     } catch (final Throwable t) {
1:                         t.printStackTrace();
1:                     }
1:                     return null;
1:                 }
1:             });
1:             pool.shutdown();
1:             pool.awaitTermination(10, TimeUnit.SECONDS);
1:             LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1: 
1:             int count = 0;
1:             // give it 10 seconds
1:             while (count++ < 10
1:                     && broker1Count.get() + broker2Count.get() != total) {
1:                 LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1:                 Thread.sleep(1000);
1:             }
1:             container1.destroy();
1:         } finally {
1:             try {
1:                 if (brokerService1 != null) {
1:                     brokerService1.stop();
1:                 }
1:             } catch (final Throwable t) {
1:                 t.printStackTrace();
1:             }
1:             try {
1:                 if (brokerService2 != null) {
1:                     brokerService2.stop();
1:                 }
1:             } catch (final Throwable t) {
1:                 t.printStackTrace();
1:             }
1:         }
1:         
1:         if (broker1Count.get() < 25 || broker2Count.get() < 25) {
1:             fail("Each broker should have gotten at least 25 messages but instead broker1 got "
1:                     + broker1Count.get()
1:                     + " and broker2 got "
1:                     + broker2Count.get());
1:         }
1:     }
1: 
1:     @Test
1:     public void does_xml_multicast_load_balance_between_consumers() throws Exception {
1:         final int total = 100;
1:         final AtomicInteger broker1Count = new AtomicInteger(0);
1:         final AtomicInteger broker2Count = new AtomicInteger(0);
1:         final ExecutorService pool = Executors.newSingleThreadExecutor();
1:         final CountDownLatch startProducer = new CountDownLatch(1);
1:         final String xmlConfig = getClass().getPackage().getName().replace('.','/') + "/loadbalancetest.xml";
1:         System.setProperty("lbt.networkBridgePrefetch", String.valueOf(networkBridgePrefetch));
1:         System.setProperty("lbt.brokerName", "one");
1:         final ActiveMQConnectionFactory connectionFactory1 = new ActiveMQConnectionFactory(
1:                 "vm://one?brokerConfig=xbean:" + xmlConfig);
1:         final SingleConnectionFactory singleConnectionFactory1 = new SingleConnectionFactory(
1:                 connectionFactory1);
1:         singleConnectionFactory1.setReconnectOnException(true);
1:         final DefaultMessageListenerContainer container1 = new DefaultMessageListenerContainer();
1:         container1.setConnectionFactory(singleConnectionFactory1);
1:         container1.setMaxConcurrentConsumers(1);
1:         container1.setDestination(new ActiveMQQueue(TESTING_QUEUE));
1:         container1.setMessageListener(new MessageListener() {
1: 
1:             public void onMessage(final Message message) {
1:                 broker1Count.incrementAndGet();
1:             }
1:         });
1:         container1.afterPropertiesSet();
1:         container1.start();
1:         pool.submit(new Callable<Object>() {
1: 
1:             public Object call() throws Exception {
1:                 System.setProperty("lbt.brokerName", "two");
1:                 final ActiveMQConnectionFactory connectionFactory2 = new ActiveMQConnectionFactory(
1:                         "vm://two?brokerConfig=xbean:" + xmlConfig);
1:                 final SingleConnectionFactory singleConnectionFactory2 = new SingleConnectionFactory(
1:                         connectionFactory2);
1:                 singleConnectionFactory2.setReconnectOnException(true);
1:                 final DefaultMessageListenerContainer container2 = new DefaultMessageListenerContainer();
1:                 container2.setConnectionFactory(singleConnectionFactory2);
1:                 container2.setMaxConcurrentConsumers(1);
1:                 container2.setDestination(new ActiveMQQueue(TESTING_QUEUE));
1:                 container2.setMessageListener(new MessageListener() {
1: 
1:                     public void onMessage(final Message message) {
1:                         broker2Count.incrementAndGet();
1:                     }
1:                 });
1:                 container2.afterPropertiesSet();
1:                 container2.start();
1:                 
1:                 
1:                 assertTrue("wait for start signal", startProducer.await(20, TimeUnit.SECONDS));
1:                 
1:                 final CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory(
1:                         singleConnectionFactory2);
1:                 final JmsTemplate template = new JmsTemplate(
1:                         cachingConnectionFactory);
1:                 final ActiveMQQueue queue = new ActiveMQQueue(TESTING_QUEUE);
1:                 for (int i = 0; i < total; i++) {
1:                     template.send(queue, new MessageCreator() {
1: 
1:                         public Message createMessage(final Session session)
1:                                 throws JMSException {
1:                             final TextMessage message = session
1:                                     .createTextMessage();
1:                             message.setText("Hello World!");
1:                             return message;
1:                         }
1:                     });
1:                 }
1:                 return null;
1:             }
1:         });
1:         
1:         // give network a chance to build, needs advisories
0:         waitForBridgeFormation(10000);
1:         startProducer.countDown();
1:         
1:         pool.shutdown();
1:         pool.awaitTermination(10, TimeUnit.SECONDS);
1:         
1:         LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1: 
1:         int count = 0;
1:         // give it 10 seconds
1:         while (count++ < 10 && broker1Count.get() + broker2Count.get() != total) {
1:             LOG.info("broker1Count " + broker1Count.get() + ", broker2Count " + broker2Count.get());
1:             Thread.sleep(1000);
1:         }
1:         if (broker1Count.get() < 25 || broker2Count.get() < 25) {
1:             fail("Each broker should have gotten at least 25 messages but instead broker1 got "
1:                     + broker1Count.get()
1:                     + " and broker2 got "
1:                     + broker2Count.get());
1:         }
1:     }
1: 
1:     // need to ensure broker bridge is alive before starting the consumer
1:     // peeking at the internals will give us this info
0:     private void waitForBridgeFormation(long delay) throws Exception {
0:         long done = System.currentTimeMillis() + delay;
1:         while (done > System.currentTimeMillis()) {
0:             BrokerService broker = BrokerRegistry.getInstance().lookup("two");
0:             if (broker != null && !broker.getNetworkConnectors().isEmpty()) {
0:                  if (!broker.getNetworkConnectors().get(0).activeBridges().isEmpty()) {
0:                      return;
1:                  }
1:             }
1:             Thread.sleep(1000);
1:         }
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(LoadBalanceTest.class);
============================================================================