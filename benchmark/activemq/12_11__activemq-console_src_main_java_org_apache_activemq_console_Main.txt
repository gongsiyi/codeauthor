1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:5f1adbe:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:7fa8660: package org.apache.activemq.console;
143:d29ca2a: 
1:d29ca2a: import java.io.File;
1:982a119: import java.io.InputStream;
1:982a119: import java.io.PrintStream;
1:9797077: import java.lang.management.ManagementFactory;
1:d29ca2a: import java.lang.reflect.InvocationTargetException;
1:d29ca2a: import java.lang.reflect.Method;
1:d29ca2a: import java.net.JarURLConnection;
1:d29ca2a: import java.net.MalformedURLException;
1:d29ca2a: import java.net.URI;
1:d29ca2a: import java.net.URL;
1:d29ca2a: import java.net.URLClassLoader;
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.Arrays;
1:d778fa4: import java.util.Comparator;
1:d29ca2a: import java.util.Iterator;
1:093b0e2: import java.util.LinkedHashSet;
1:982a119: import java.util.LinkedList;
1:982a119: import java.util.List;
1:d29ca2a: import java.util.Set;
1:d29ca2a: import java.util.StringTokenizer;
1:d778fa4: 
1:d29ca2a: /**
1:5f1adbe:  * Main class that can bootstrap an ActiveMQ broker console. Handles command
1:5f1adbe:  * line argument parsing to set up and run broker tasks.
1:d29ca2a:  */
1:d29ca2a: public class Main {
1:d29ca2a: 
1:5f1adbe:     public static final String TASK_DEFAULT_CLASS = "org.apache.activemq.console.command.ShellCommand";
1:4d7ea5e:     private static boolean useDefExt = true;
1:d29ca2a: 
1:5f1adbe:     private File activeMQHome;
1:5f1adbe:     private File activeMQBase;
1:5f1adbe:     private ClassLoader classLoader;
1:093b0e2:     private final Set<File> extensions = new LinkedHashSet<File>();
1:093b0e2:     private final Set<File> activeMQClassPath = new LinkedHashSet<File>();
1:5f1adbe: 
1:d29ca2a:     public static void main(String[] args) {
1:a7873fc: 
1:a7873fc:         // Create the tmpdir if it does not exist yet..
1:a7873fc:         File tmpdir = new File(System.getProperty("java.io.tmpdir"));
1:a7873fc:         if(!tmpdir.exists()) {
1:a7873fc:             tmpdir.mkdirs();
1:a7873fc:         }
1:a7873fc: 
1:d29ca2a:         Main app = new Main();
1:36265ea: 
1:d29ca2a:         // Convert arguments to collection for easier management
1:5f1adbe:         List<String> tokens = new LinkedList<String>(Arrays.asList(args));
1:70c2d88:         // Parse for extension directory option
1:70c2d88:         app.parseExtensions(tokens);
1:d778fa4: 
1:3a561cc:         // lets add the conf directory first, to find the log4j.properties just in case its not
1:3a561cc:         // in the activemq.classpath system property or some jar incorrectly includes one
1:3a561cc:         File confDir = app.getActiveMQConfig();
1:3a561cc:         app.addClassPath(confDir);
1:d29ca2a: 
1:d778fa4:         // Add the following to the classpath:
1:d778fa4:         //
1:d778fa4:         // ${activemq.base}/conf
1:d778fa4:         // ${activemq.base}/lib/* (only if activemq.base != activemq.home)
1:d778fa4:         // ${activemq.home}/lib/*
1:5f1adbe:         // ${activemq.base}/lib/optional/* (only if activemq.base !=
1:5f1adbe:         // activemq.home)
1:d778fa4:         // ${activemq.home}/lib/optional/*
1:af9cc56:         // ${activemq.base}/lib/web/* (only if activemq.base != activemq.home)
1:af9cc56:         // ${activemq.home}/lib/web/*
1:d778fa4:         //
1:5f1adbe:         if (useDefExt && app.canUseExtdir()) {
1:d778fa4: 
1:d778fa4:             boolean baseIsHome = app.getActiveMQBase().equals(app.getActiveMQHome());
1:d778fa4: 
1:af9cc56:             File baseLibDir = new File(app.getActiveMQBase(), "lib");
1:af9cc56:             File homeLibDir = new File(app.getActiveMQHome(), "lib");
1:d778fa4: 
1:5f1adbe:             if (!baseIsHome) {
1:af9cc56:                 app.addExtensionDirectory(baseLibDir);
1:d778fa4:             }
1:af9cc56:             app.addExtensionDirectory(homeLibDir);
1:d778fa4: 
1:5f1adbe:             if (!baseIsHome) {
1:093b0e2:                 app.addExtensionDirectory(new File(baseLibDir, "camel"));
1:af9cc56:                 app.addExtensionDirectory(new File(baseLibDir, "optional"));
1:af9cc56:                 app.addExtensionDirectory(new File(baseLibDir, "web"));
1:093b0e2:                 app.addExtensionDirectory(new File(baseLibDir, "extra"));
1:d778fa4:             }
1:093b0e2:             app.addExtensionDirectory(new File(homeLibDir, "camel"));
1:af9cc56:             app.addExtensionDirectory(new File(homeLibDir, "optional"));
1:af9cc56:             app.addExtensionDirectory(new File(homeLibDir, "web"));
1:093b0e2:             app.addExtensionDirectory(new File(homeLibDir, "extra"));
90:d29ca2a:         }
1:d778fa4: 
1:5f1adbe:         // Add any custom classpath specified from the system property
1:5f1adbe:         // activemq.classpath
1:f30b0d8:         app.addClassPathList(System.getProperty("activemq.classpath"));
1:d29ca2a: 
14:d29ca2a:         try {
1:e2221e3:             int ret = app.runTaskClass(tokens);
1:e2221e3:             System.exit(ret);
1:36265ea:         } catch (ClassNotFoundException e) {
1:36265ea:             System.out.println("Could not load class: " + e.getMessage());
1:36265ea:             try {
1:36265ea:                 ClassLoader cl = app.getClassLoader();
1:5f1adbe:                 if (cl != null) {
1:36265ea:                     System.out.println("Class loader setup: ");
1:36265ea:                     printClassLoaderTree(cl);
1:36265ea:                 }
1:36265ea:             } catch (MalformedURLException e1) {
1:36265ea:             }
1:b4f65ba:             System.exit(1);
8:d29ca2a:         } catch (Throwable e) {
1:70c2d88:             System.out.println("Failed to execute main task. Reason: " + e);
1:b4f65ba:             System.exit(1);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:36265ea:     /**
1:36265ea:      * Print out what's in the classloader tree being used.
1:3a561cc:      *
1:36265ea:      * @param cl
1:f30b0d8:      * @return depth
1:36265ea:      */
1:36265ea:     private static int printClassLoaderTree(ClassLoader cl) {
1:36265ea:         int depth = 0;
1:5f1adbe:         if (cl.getParent() != null) {
1:5f1adbe:             depth = printClassLoaderTree(cl.getParent()) + 1;
1:36265ea:         }
1:36265ea: 
1:36265ea:         StringBuffer indent = new StringBuffer();
1:36265ea:         for (int i = 0; i < depth; i++) {
1:36265ea:             indent.append("  ");
1:36265ea:         }
1:36265ea: 
1:5f1adbe:         if (cl instanceof URLClassLoader) {
1:5f1adbe:             URLClassLoader ucl = (URLClassLoader)cl;
1:5f1adbe:             System.out.println(indent + cl.getClass().getName() + " {");
1:36265ea:             URL[] urls = ucl.getURLs();
1:36265ea:             for (int i = 0; i < urls.length; i++) {
1:5f1adbe:                 System.out.println(indent + "  " + urls[i]);
1:36265ea:             }
1:5f1adbe:             System.out.println(indent + "}");
1:36265ea:         } else {
1:5f1adbe:             System.out.println(indent + cl.getClass().getName());
1:36265ea:         }
1:36265ea:         return depth;
1:36265ea:     }
1:36265ea: 
1:5f1adbe:     public void parseExtensions(List<String> tokens) {
1:d29ca2a:         if (tokens.isEmpty()) {
27:d29ca2a:             return;
1:d29ca2a:         }
1:d29ca2a: 
1:4b8822f:         int count = tokens.size();
1:4b8822f:         int i = 0;
1:d29ca2a: 
1:4b8822f:         // Parse for all --extdir and --noDefExt options
1:4b8822f:         while (i < count) {
1:5f1adbe:             String token = tokens.get(i);
1:d29ca2a:             // If token is an extension dir option
1:70c2d88:             if (token.equals("--extdir")) {
1:4b8822f:                 // Process token
1:4b8822f:                 count--;
1:4b8822f:                 tokens.remove(i);
1:d29ca2a: 
1:5f1adbe:                 // If no extension directory is specified, or next token is
1:5f1adbe:                 // another option
1:5f1adbe:                 if (i >= count || tokens.get(i).startsWith("-")) {
1:4b8822f:                     System.out.println("Extension directory not specified.");
1:4b8822f:                     System.out.println("Ignoring extension directory option.");
1:4b8822f:                     continue;
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 // Process extension dir token
1:4b8822f:                 count--;
1:5f1adbe:                 File extDir = new File(tokens.remove(i));
1:d29ca2a: 
1:5f1adbe:                 if (!canUseExtdir()) {
1:70c2d88:                     System.out.println("Extension directory feature not available due to the system classpath being able to load: " + TASK_DEFAULT_CLASS);
3:70c2d88:                     System.out.println("Ignoring extension directory option.");
1:4b8822f:                     continue;
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 if (!extDir.isDirectory()) {
1:4b8822f:                     System.out.println("Extension directory specified is not valid directory: " + extDir);
1:4b8822f:                     System.out.println("Ignoring extension directory option.");
1:4b8822f:                     continue;
1:d29ca2a:                 }
1:d29ca2a: 
1:4b8822f:                 addExtensionDirectory(extDir);
1:5f1adbe:             } else if (token.equals("--noDefExt")) { // If token is
1:5f1adbe:                 // --noDefExt option
1:4b8822f:                 count--;
1:4b8822f:                 tokens.remove(i);
1:f9a7635:                 useDefExt = false;
8:d29ca2a:             } else {
1:4b8822f:                 i++;
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:     }
1:d29ca2a: 
1:e2221e3:     public int runTaskClass(List<String> tokens) throws Throwable {
1:d29ca2a: 
1:9797077:         StringBuilder buffer = new StringBuilder();
1:9797077:         buffer.append(System.getProperty("java.vendor"));
1:9797077:         buffer.append(" ");
1:9797077:         buffer.append(System.getProperty("java.version"));
1:9797077:         buffer.append(" ");
1:9797077:         buffer.append(System.getProperty("java.home"));
1:9797077:         System.out.println("Java Runtime: " + buffer.toString());
1:d29ca2a: 
2:9797077:         buffer = new StringBuilder();
1:3a561cc:         buffer.append("current=");
1:3a561cc:         buffer.append(Runtime.getRuntime().totalMemory()/1024L);
1:3a561cc:         buffer.append("k  free=");
1:3a561cc:         buffer.append(Runtime.getRuntime().freeMemory()/1024L);
1:3a561cc:         buffer.append("k  max=");
1:3a561cc:         buffer.append(Runtime.getRuntime().maxMemory()/1024L);
1:9797077:         buffer.append("k");
1:9797077:         System.out.println("  Heap sizes: " + buffer.toString());
1:d29ca2a: 
1:3a561cc:         List<?> jvmArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();
1:3a561cc:         buffer = new StringBuilder();
1:9797077:         for (Object arg : jvmArgs) {
1:9797077:             buffer.append(" ").append(arg);
1:d29ca2a:         }
1:9797077:         System.out.println("    JVM args:" + buffer.toString());
1:093b0e2:         System.out.println("Extensions classpath:\n  " + getExtensionDirForLogging());
1:d29ca2a: 
1:5f1adbe:         System.out.println("ACTIVEMQ_HOME: " + getActiveMQHome());
1:5f1adbe:         System.out.println("ACTIVEMQ_BASE: " + getActiveMQBase());
1:757107d:         System.out.println("ACTIVEMQ_CONF: " + getActiveMQConfig());
1:3a561cc:         System.out.println("ACTIVEMQ_DATA: " + getActiveMQDataDir());
1:d29ca2a: 
2:d29ca2a:         ClassLoader cl = getClassLoader();
1:3a561cc:         Thread.currentThread().setContextClassLoader(cl);
1:d29ca2a: 
1:70c2d88:         // Use reflection to run the task.
1:d29ca2a:         try {
1:5f1adbe:             String[] args = tokens.toArray(new String[tokens.size()]);
1:3a561cc:             Class<?> task = cl.loadClass(TASK_DEFAULT_CLASS);
1:5f1adbe:             Method runTask = task.getMethod("main", new Class[] {
1:5f1adbe:                 String[].class, InputStream.class, PrintStream.class
1:5f1adbe:             });
1:e2221e3:             return (int)runTask.invoke(task.newInstance(), args, System.in, System.out);
1:d29ca2a:         } catch (InvocationTargetException e) {
1:d29ca2a:             throw e.getCause();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void addExtensionDirectory(File directory) {
1:d29ca2a:         extensions.add(directory);
1:d778fa4:     }
1:d778fa4: 
1:f30b0d8:     public void addClassPathList(String fileList) {
1:f30b0d8:         if (fileList != null && fileList.length() > 0) {
1:e0ad700:             StringTokenizer tokenizer = new StringTokenizer(fileList, File.pathSeparator);
1:f30b0d8:             while (tokenizer.hasMoreTokens()) {
1:f30b0d8:                 addClassPath(new File(tokenizer.nextToken()));
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:f30b0d8:     public void addClassPath(File classpath) {
1:f30b0d8:         activeMQClassPath.add(classpath);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5f1adbe:      * The extension directory feature will not work if the broker factory is
1:5f1adbe:      * already in the classpath since we have to load him from a child
1:5f1adbe:      * ClassLoader we build for it to work correctly.
1:3a561cc:      *
1:f30b0d8:      * @return true, if extension dir can be used. false otherwise.
1:d29ca2a:      */
1:d29ca2a:     public boolean canUseExtdir() {
1:d29ca2a:         try {
1:70c2d88:             Main.class.getClassLoader().loadClass(TASK_DEFAULT_CLASS);
1:d29ca2a:             return false;
1:d29ca2a:         } catch (ClassNotFoundException e) {
1:d29ca2a:             return true;
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public ClassLoader getClassLoader() throws MalformedURLException {
1:5f1adbe:         if (classLoader == null) {
1:d29ca2a:             // Setup the ClassLoader
1:d29ca2a:             classLoader = Main.class.getClassLoader();
1:f30b0d8:             if (!extensions.isEmpty() || !activeMQClassPath.isEmpty()) {
1:d778fa4: 
1:5f1adbe:                 ArrayList<URL> urls = new ArrayList<URL>();
1:d778fa4: 
1:5f1adbe:                 for (Iterator<File> iter = activeMQClassPath.iterator(); iter.hasNext();) {
1:5f1adbe:                     File dir = iter.next();
1:b14fec3:                     urls.add(dir.toURI().toURL());
1:d778fa4:                 }
1:d29ca2a: 
1:5f1adbe:                 for (Iterator<File> iter = extensions.iterator(); iter.hasNext();) {
1:5f1adbe:                     File dir = iter.next();
1:5f1adbe:                     if (dir.isDirectory()) {
1:d778fa4:                         File[] files = dir.listFiles();
1:5f1adbe:                         if (files != null) {
1:d778fa4: 
1:3a561cc:                             // Sort the jars so that classpath built is consistently in the same
1:3a561cc:                             // order. Also allows us to use jar names to control classpath order.
1:3a561cc:                             Arrays.sort(files, new Comparator<File>() {
1:e0ad700:                                 @Override
1:3a561cc:                                 public int compare(File f1, File f2) {
1:d778fa4:                                     return f1.getName().compareTo(f2.getName());
1:d778fa4:                                 }
1:5f1adbe:                             });
1:d778fa4: 
1:d778fa4:                             for (int j = 0; j < files.length; j++) {
1:5f1adbe:                                 if (files[j].getName().endsWith(".zip") || files[j].getName().endsWith(".jar")) {
1:b14fec3:                                     urls.add(files[j].toURI().toURL());
1:d778fa4:                                 }
1:d778fa4:                             }
1:d778fa4:                         }
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 URL u[] = new URL[urls.size()];
1:d29ca2a:                 urls.toArray(u);
1:d29ca2a:                 classLoader = new URLClassLoader(u, classLoader);
1:d29ca2a:             }
1:d29ca2a:             Thread.currentThread().setContextClassLoader(classLoader);
1:d29ca2a:         }
1:d29ca2a:         return classLoader;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setActiveMQHome(File activeMQHome) {
1:d29ca2a:         this.activeMQHome = activeMQHome;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public File getActiveMQHome() {
1:5f1adbe:         if (activeMQHome == null) {
1:5f1adbe:             if (System.getProperty("activemq.home") != null) {
1:d29ca2a:                 activeMQHome = new File(System.getProperty("activemq.home"));
1:d29ca2a:             }
1:d29ca2a: 
1:5f1adbe:             if (activeMQHome == null) {
1:d29ca2a:                 // guess from the location of the jar
1:2fc2c28:                 URL url = Main.class.getClassLoader().getResource("org/apache/activemq/console/Main.class");
1:d29ca2a:                 if (url != null) {
1:d29ca2a:                     try {
1:5f1adbe:                         JarURLConnection jarConnection = (JarURLConnection)url.openConnection();
1:d29ca2a:                         url = jarConnection.getJarFileURL();
1:d29ca2a:                         URI baseURI = new URI(url.toString()).resolve("..");
1:d29ca2a:                         activeMQHome = new File(baseURI).getCanonicalFile();
1:5f1adbe:                         System.setProperty("activemq.home", activeMQHome.getAbsolutePath());
1:d29ca2a:                     } catch (Exception ignored) {
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a: 
1:5f1adbe:             if (activeMQHome == null) {
1:2fc2c28:                 activeMQHome = new File("../.");
1:5f1adbe:                 System.setProperty("activemq.home", activeMQHome.getAbsolutePath());
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         return activeMQHome;
1:d29ca2a:     }
1:d778fa4: 
1:d778fa4:     public File getActiveMQBase() {
1:5f1adbe:         if (activeMQBase == null) {
1:5f1adbe:             if (System.getProperty("activemq.base") != null) {
1:d778fa4:                 activeMQBase = new File(System.getProperty("activemq.base"));
1:d778fa4:             }
1:d778fa4: 
1:5f1adbe:             if (activeMQBase == null) {
1:d778fa4:                 activeMQBase = getActiveMQHome();
1:5f1adbe:                 System.setProperty("activemq.base", activeMQBase.getAbsolutePath());
1:d778fa4:             }
1:d778fa4:         }
1:d778fa4: 
1:d778fa4:         return activeMQBase;
1:d778fa4:     }
1:3a561cc: 
1:3a561cc:     public File getActiveMQConfig() {
1:3a561cc:         File activeMQConfig = null;
1:3a561cc: 
1:3a561cc:         if (System.getProperty("activemq.conf") != null) {
1:3a561cc:             activeMQConfig = new File(System.getProperty("activemq.conf"));
1:3a561cc:         } else {
1:3a561cc:             activeMQConfig = new File(getActiveMQBase() + "/conf");
1:2a59294:             System.setProperty("activemq.conf", activeMQConfig.getAbsolutePath());
1:3a561cc:         }
1:3a561cc:         return activeMQConfig;
1:3a561cc:     }
1:3a561cc: 
1:3a561cc:     public File getActiveMQDataDir() {
1:3a561cc:         File activeMQDataDir = null;
1:3a561cc: 
1:3a561cc:         if (System.getProperty("activemq.data") != null) {
1:3a561cc:             activeMQDataDir = new File(System.getProperty("activemq.data"));
1:3a561cc:         } else {
1:3a561cc:             activeMQDataDir = new File(getActiveMQBase() + "/data");
1:2a59294:             System.setProperty("activemq.data", activeMQDataDir.getAbsolutePath());
1:3a561cc:         }
1:3a561cc:         return activeMQDataDir;
1:3a561cc:     }
1:093b0e2: 
1:093b0e2:     public String getExtensionDirForLogging() {
1:093b0e2:         StringBuilder sb = new StringBuilder("[");
1:093b0e2:         for (Iterator<File> it = extensions.iterator(); it.hasNext();) {
1:093b0e2:             File file = it.next();
1:093b0e2:             sb.append(file.getPath());
1:093b0e2:             if (it.hasNext()) {
1:093b0e2:                 sb.append(",");
1:093b0e2:             }
1:093b0e2:         }
1:093b0e2:         sb.append("]");
1:093b0e2:         return sb.toString();
1:093b0e2:     }
1:d29ca2a: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:e0ad700
/////////////////////////////////////////////////////////////////////////
1:             StringTokenizer tokenizer = new StringTokenizer(fileList, File.pathSeparator);
/////////////////////////////////////////////////////////////////////////
1:                                 @Override
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:e2221e3
/////////////////////////////////////////////////////////////////////////
1:             int ret = app.runTaskClass(tokens);
1:             System.exit(ret);
/////////////////////////////////////////////////////////////////////////
1:     public int runTaskClass(List<String> tokens) throws Throwable {
/////////////////////////////////////////////////////////////////////////
1:             return (int)runTask.invoke(task.newInstance(), args, System.in, System.out);
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:2a59294
/////////////////////////////////////////////////////////////////////////
1:             System.setProperty("activemq.conf", activeMQConfig.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
1:             System.setProperty("activemq.data", activeMQDataDir.getAbsolutePath());
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:093b0e2
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashSet;
/////////////////////////////////////////////////////////////////////////
1:     private final Set<File> extensions = new LinkedHashSet<File>();
1:     private final Set<File> activeMQClassPath = new LinkedHashSet<File>();
/////////////////////////////////////////////////////////////////////////
1:                 app.addExtensionDirectory(new File(baseLibDir, "camel"));
1:                 app.addExtensionDirectory(new File(baseLibDir, "extra"));
1:             app.addExtensionDirectory(new File(homeLibDir, "camel"));
1:             app.addExtensionDirectory(new File(homeLibDir, "extra"));
/////////////////////////////////////////////////////////////////////////
1:         System.out.println("Extensions classpath:\n  " + getExtensionDirForLogging());
/////////////////////////////////////////////////////////////////////////
0:             runTask.invoke(task.newInstance(), args, System.in, System.out);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String getExtensionDirForLogging() {
1:         StringBuilder sb = new StringBuilder("[");
1:         for (Iterator<File> it = extensions.iterator(); it.hasNext();) {
1:             File file = it.next();
1:             sb.append(file.getPath());
1:             if (it.hasNext()) {
1:                 sb.append(",");
1:             }
1:         }
1:         sb.append("]");
1:         return sb.toString();
1:     }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:757107d
/////////////////////////////////////////////////////////////////////////
1:         System.out.println("ACTIVEMQ_CONF: " + getActiveMQConfig());
commit:3a561cc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // lets add the conf directory first, to find the log4j.properties just in case its not
1:         // in the activemq.classpath system property or some jar incorrectly includes one
1:         File confDir = app.getActiveMQConfig();
1:         app.addClassPath(confDir);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:         buffer.append("current=");
1:         buffer.append(Runtime.getRuntime().totalMemory()/1024L);
1:         buffer.append("k  free=");
1:         buffer.append(Runtime.getRuntime().freeMemory()/1024L);
1:         buffer.append("k  max=");
1:         buffer.append(Runtime.getRuntime().maxMemory()/1024L);
1:         List<?> jvmArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();
1:         buffer = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
0:         System.out.println("ACTIVEMQ_CONFIG: " + getActiveMQConfig());
1:         System.out.println("ACTIVEMQ_DATA: " + getActiveMQDataDir());
1:         Thread.currentThread().setContextClassLoader(cl);
1:             Class<?> task = cl.loadClass(TASK_DEFAULT_CLASS);
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             // Sort the jars so that classpath built is consistently in the same
1:                             // order. Also allows us to use jar names to control classpath order.
1:                             Arrays.sort(files, new Comparator<File>() {
1:                                 public int compare(File f1, File f2) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public File getActiveMQConfig() {
1:         File activeMQConfig = null;
1: 
1:         if (System.getProperty("activemq.conf") != null) {
1:             activeMQConfig = new File(System.getProperty("activemq.conf"));
1:         } else {
1:             activeMQConfig = new File(getActiveMQBase() + "/conf");
1:         }
1:         return activeMQConfig;
1:     }
1: 
1:     public File getActiveMQDataDir() {
1:         File activeMQDataDir = null;
1: 
1:         if (System.getProperty("activemq.data") != null) {
1:             activeMQDataDir = new File(System.getProperty("activemq.data"));
1:         } else {
1:             activeMQDataDir = new File(getActiveMQBase() + "/data");
1:         }
1:         return activeMQDataDir;
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:a7873fc
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Create the tmpdir if it does not exist yet..
1:         File tmpdir = new File(System.getProperty("java.io.tmpdir"));
1:         if(!tmpdir.exists()) {
1:             tmpdir.mkdirs();
1:         }
1: 
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:b4f65ba
/////////////////////////////////////////////////////////////////////////
0:             System.exit(0);
/////////////////////////////////////////////////////////////////////////
1:             System.exit(1);
1:             System.exit(1);
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
1:  * Main class that can bootstrap an ActiveMQ broker console. Handles command
1:  * line argument parsing to set up and run broker tasks.
1:  * 
1:     public static final String TASK_DEFAULT_CLASS = "org.apache.activemq.console.command.ShellCommand";
1:     private File activeMQHome;
1:     private File activeMQBase;
1:     private ClassLoader classLoader;
0:     private Set<File> extensions = new HashSet<File>(5);
0:     private Set<File> activeMQClassPath = new HashSet<File>(5);
1: 
1:         List<String> tokens = new LinkedList<String>(Arrays.asList(args));
/////////////////////////////////////////////////////////////////////////
1:         // ${activemq.base}/lib/optional/* (only if activemq.base !=
1:         // activemq.home)
1:         if (useDefExt && app.canUseExtdir()) {
1:             if (!baseIsHome) {
1:             if (!baseIsHome) {
/////////////////////////////////////////////////////////////////////////
1:         // Add any custom classpath specified from the system property
1:         // activemq.classpath
/////////////////////////////////////////////////////////////////////////
1:                 if (cl != null) {
/////////////////////////////////////////////////////////////////////////
0:      * 
1:         if (cl.getParent() != null) {
1:             depth = printClassLoaderTree(cl.getParent()) + 1;
/////////////////////////////////////////////////////////////////////////
1:         if (cl instanceof URLClassLoader) {
1:             URLClassLoader ucl = (URLClassLoader)cl;
1:             System.out.println(indent + cl.getClass().getName() + " {");
1:                 System.out.println(indent + "  " + urls[i]);
1:             System.out.println(indent + "}");
1:             System.out.println(indent + cl.getClass().getName());
1:     public void parseExtensions(List<String> tokens) {
/////////////////////////////////////////////////////////////////////////
1:             String token = tokens.get(i);
1:                 // If no extension directory is specified, or next token is
1:                 // another option
1:                 if (i >= count || tokens.get(i).startsWith("-")) {
/////////////////////////////////////////////////////////////////////////
1:                 File extDir = new File(tokens.remove(i));
1:                 if (!canUseExtdir()) {
/////////////////////////////////////////////////////////////////////////
1:             } else if (token.equals("--noDefExt")) { // If token is
1:                 // --noDefExt option
/////////////////////////////////////////////////////////////////////////
0:     public void runTaskClass(List<String> tokens) throws Throwable {
1:         System.out.println("ACTIVEMQ_HOME: " + getActiveMQHome());
1:         System.out.println("ACTIVEMQ_BASE: " + getActiveMQBase());
1:             String[] args = tokens.toArray(new String[tokens.size()]);
1:             Method runTask = task.getMethod("main", new Class[] {
1:                 String[].class, InputStream.class, PrintStream.class
1:             });
0:             runTask.invoke(task.newInstance(), new Object[] {
0:                 args, System.in, System.out
1:             });
/////////////////////////////////////////////////////////////////////////
1:      * The extension directory feature will not work if the broker factory is
1:      * already in the classpath since we have to load him from a child
1:      * ClassLoader we build for it to work correctly.
0:      * 
/////////////////////////////////////////////////////////////////////////
1:         if (classLoader == null) {
1:                 ArrayList<URL> urls = new ArrayList<URL>();
1:                 for (Iterator<File> iter = activeMQClassPath.iterator(); iter.hasNext();) {
1:                     File dir = iter.next();
0:                     // try{ System.out.println("Adding to classpath: " +
0:                     // dir.getCanonicalPath()); }catch(Exception e){}
1:                 for (Iterator<File> iter = extensions.iterator(); iter.hasNext();) {
1:                     File dir = iter.next();
1:                     if (dir.isDirectory()) {
1:                         if (files != null) {
0:                             // Sort the jars so that classpath built is
0:                             // consistently
0:                             // in the same order. Also allows us to use jar
0:                             // names to control
0:                             Arrays.sort(files, new Comparator() {
0:                                     File f1 = (File)o1;
0:                                     File f2 = (File)o2;
1:                                 if (files[j].getName().endsWith(".zip") || files[j].getName().endsWith(".jar")) {
0:                                     // try{ System.out.println("Adding to
0:                                     // classpath: " +
0:                                     // files[j].getCanonicalPath());
0:                                     // }catch(Exception e){}
/////////////////////////////////////////////////////////////////////////
1:         if (activeMQHome == null) {
1:             if (System.getProperty("activemq.home") != null) {
1:             if (activeMQHome == null) {
1:                         JarURLConnection jarConnection = (JarURLConnection)url.openConnection();
1:                         System.setProperty("activemq.home", activeMQHome.getAbsolutePath());
1:             if (activeMQHome == null) {
1:                 System.setProperty("activemq.home", activeMQHome.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
1:         if (activeMQBase == null) {
1:             if (System.getProperty("activemq.base") != null) {
1:             if (activeMQBase == null) {
1:                 System.setProperty("activemq.base", activeMQBase.getAbsolutePath());
commit:36265ea
/////////////////////////////////////////////////////////////////////////
1:         } catch (ClassNotFoundException e) {
1:             System.out.println("Could not load class: " + e.getMessage());
1:             try {
1: 				ClassLoader cl = app.getClassLoader();
0: 				if( cl!=null ) {
1: 		            System.out.println("Class loader setup: ");
1: 					printClassLoaderTree(cl);
1: 				}
1: 			} catch (MalformedURLException e1) {
1: 			}
1:     /**
1:      * Print out what's in the classloader tree being used. 
0:      * 
1:      * @param cl
0:      * @return
1:      */
1: 	private static int printClassLoaderTree(ClassLoader cl) {
1: 		int depth = 0;
0: 		if( cl.getParent()!=null ) {
0: 			depth = printClassLoaderTree(cl.getParent())+1;
1: 		}
1: 		
1: 		StringBuffer indent = new StringBuffer();
1: 		for (int i = 0; i < depth; i++) {
1: 			indent.append("  ");
1: 		}
1: 		
0: 		if( cl instanceof URLClassLoader ) {
0: 			URLClassLoader ucl = (URLClassLoader) cl;
0: 			System.out.println(indent+cl.getClass().getName()+" {");
1: 			URL[] urls = ucl.getURLs();
1: 			for (int i = 0; i < urls.length; i++) {
0: 				System.out.println(indent+"  "+urls[i]);
1: 			}
0: 			System.out.println(indent+"}");
1: 		} else {
0: 			System.out.println(indent+cl.getClass().getName());
1: 		}
1: 		return depth;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1:     	
0:         System.out.println("ACTIVEMQ_BASE: "+ getActiveMQBase());
commit:d778fa4
/////////////////////////////////////////////////////////////////////////
1: import java.util.Comparator;
/////////////////////////////////////////////////////////////////////////
0: 	private File          activeMQBase;
0:     private List          classpaths = new ArrayList(5);
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Add the following to the classpath:
1:         // 
1:         // ${activemq.base}/conf
1:         // ${activemq.base}/lib/* (only if activemq.base != activemq.home)
1:         // ${activemq.home}/lib/* 
0:         // ${activemq.base}/lib/optional/* (only if activemq.base != activemq.home)
1:         // ${activemq.home}/lib/optional/* 
1:         // 
1: 
1:         	boolean baseIsHome = app.getActiveMQBase().equals(app.getActiveMQHome()); 
1:         	
0:             app.addClassPath(new File(app.getActiveMQBase(), "conf"));
1:             
0:             if(!baseIsHome) {
0:                 app.addExtensionDirectory(new File(app.getActiveMQBase(), "lib"));
1:             }
1:             
0:             if(!baseIsHome) {
0:                 app.addExtensionDirectory(new File(new File(app.getActiveMQBase(), "lib"), "optional"));
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
0: 	public void parseExtensions(List tokens) {
/////////////////////////////////////////////////////////////////////////
1:     
0:     private void addClassPath(File file) {
0:         classpaths.add(file);
1: 	}
/////////////////////////////////////////////////////////////////////////
0:             if (!extensions.isEmpty() || !classpaths.isEmpty()) {
1:                 
0:                 for (Iterator iter = classpaths.iterator(); iter.hasNext();) {
1:                 }
1:                 
0:                 for (Iterator iter = extensions.iterator(); iter.hasNext();) {
0:                     File dir = (File) iter.next();
0:                     if( dir.isDirectory() ) {
1: 	                    File[] files = dir.listFiles();
0: 	                    if( files!=null ) {
1: 	                    	
0: 	                    	// Sort the jars so that classpath built is consistently
0: 	                    	// in the same order.  Also allows us to use jar names to control
0: 	                    	// classpath order.
0: 	                    	Arrays.sort(files, new Comparator(){
0: 								public int compare(Object o1, Object o2) {
0: 									File f1 = (File) o1;
0: 									File f2 = (File) o2;
1: 									return f1.getName().compareTo(f2.getName());
1: 								}
0: 							});
1: 	                    	
1: 	                        for (int j = 0; j < files.length; j++) {
0: 	                            if( files[j].getName().endsWith(".zip") || files[j].getName().endsWith(".jar") ) {
0: 	                                // try{ System.out.println("Adding to classpath: " + files[j].getCanonicalPath()); }catch(Exception e){}
0: 	                                urls.add(files[j].toURL());
1: 	                            }
1: 	                        }
1: 	                    }
/////////////////////////////////////////////////////////////////////////
1:     
1:     public File getActiveMQBase() {
0:         if(activeMQBase==null) {
0:             if(System.getProperty("activemq.base") != null) {
1:             	activeMQBase = new File(System.getProperty("activemq.base"));
1:             }
1:             
0:             if(activeMQBase==null){
1:                 activeMQBase = getActiveMQHome();
0:                 System.setProperty("activemq.base",activeMQBase.getAbsolutePath());
1:             }
1:         }
1:         
1:         return activeMQBase;
1:     }
1: 
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a234a6d
/////////////////////////////////////////////////////////////////////////
0:                                 // try{ System.out.println("Adding to classpath: " + files[j].getCanonicalPath()); }catch(Exception e){}
commit:6cf9741
/////////////////////////////////////////////////////////////////////////
0:                     // try{ System.out.println("Adding to classpath: " + dir.getCanonicalPath()); }catch(Exception e){}
commit:982a119
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.PrintStream;
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     public static final String TASK_DEFAULT_CLASS  = "org.apache.activemq.broker.console.DefaultCommand";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             app.runTaskClass(tokens);
/////////////////////////////////////////////////////////////////////////
0:     public void runTaskClass(List tokens) throws Throwable {
0:             String[] args = (String[]) tokens.toArray(new String[tokens.size()]);
0:             Class task = cl.loadClass(TASK_DEFAULT_CLASS);
0:             Method runTask = task.getMethod("main", new Class[] { String[].class, InputStream.class, PrintStream.class });
0:             runTask.invoke(task.newInstance(), new Object[] { args, System.in, System.out });
/////////////////////////////////////////////////////////////////////////
commit:ffad45e
/////////////////////////////////////////////////////////////////////////
0:     public static final String DEFAULT_JMX_URL      = "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi";
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.activemq.broker;
1: 
1: import java.io.File;
0: import java.lang.reflect.Field;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.net.JarURLConnection;
1: import java.net.MalformedURLException;
1: import java.net.URI;
0: import java.net.URISyntaxException;
1: import java.net.URL;
1: import java.net.URLClassLoader;
1: import java.util.ArrayList;
1: import java.util.Arrays;
0: import java.util.Enumeration;
0: import java.util.HashMap;
0: import java.util.HashSet;
1: import java.util.Iterator;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Properties;
1: import java.util.Set;
1: import java.util.StringTokenizer;
1: 
0: import javax.management.MBeanAttributeInfo;
0: import javax.management.MBeanServerConnection;
0: import javax.management.ObjectInstance;
0: import javax.management.ObjectName;
0: import javax.management.remote.JMXConnector;
0: import javax.management.remote.JMXConnectorFactory;
0: import javax.management.remote.JMXServiceURL;
1: 
1: /**
0:  * Main class that can bootstrap a ActiveMQ Broker. Handles command line
0:  * argument parsing to set up the broker classpath and System properties.
0:  *
0:  * @version $Revision$
1:  */
1: public class Main {
0:     public static final int HELP_MAIN_APP     = 0;
0:     public static final int HELP_START_BROKER = 1;
0:     public static final int HELP_STOP_BROKER  = 2;
0:     public static final int HELP_LIST_BROKER  = 3;
0:     public static final int HELP_STAT_BROKER  = 4;
0:     public static final int HELP_QUERY_BROKER = 5;
1: 
0:     public static final int TASK_NONE              = 0;
0:     public static final int TASK_START_BROKER      = 1;
0:     public static final int TASK_STOP_BROKER       = 2;
0:     public static final int TASK_LIST_BROKER       = 3;
0:     public static final int TASK_STAT_BROKER       = 4;
0:     public static final int TASK_QUERY_BROKER      = 5;
0:     public static final int TASK_PRINT_MAIN_HELP   = 6;
0:     public static final int TASK_PRINT_START_HELP  = 7;
0:     public static final int TASK_PRINT_STOP_HELP   = 8;
0:     public static final int TASK_PRINT_LIST_HELP   = 9;
0:     public static final int TASK_PRINT_STAT_HELP   = 10;
0:     public static final int TASK_PRINT_QUERY_HELP  = 11;
0:     public static final int TASK_PRINT_ALL_HELP    = 12;
0:     public static final int TASK_PRINT_VER         = 13;
1: 
0:     public static final String BROKER_FACTORY_CLASS = "org.apache.activemq.broker.BrokerFactory";
0:     public static final String DEFAULT_CONFIG_URI   = "xbean:activemq.xml";
0:     public static final String DEFAULT_JMX_URL      = "service:jmx:rmi:///jndi/rmi://localhost:1099/jmxconnector";
0:     public static final String DEFAULT_JMX_DOMAIN   = "org.apache.activemq";
1: 
0:     private static final String   DEFAULT_KEY_BROKER_NAME    = "BrokerName";
0:     private static final String   DEFAULT_METHOD_BROKER_STOP = "terminateJVM";
0:     private static final Object[] DEFAULT_PARAM_BROKER_STOP  = new Object[] {new Integer(0)};
0:     private static final String[] DEFAULT_SIGN_BROKER_STOP   = new String[] {"int"};
1: 
0:     // Stat retrieve flags
0:     private static final int STAT_BROKER  = Integer.parseInt("0001", 2);
0:     private static final int STAT_ALL     = Integer.parseInt("1111", 2);
1: 
0:     private static final String[] STAT_BROKER_MAP = new String[] {
0:         "TotalEnqueueCount", "TotalDequeueCount", "TotalConsumerCount", "TotalMessages",
0:         "TotalMessagesCached", "MemoryPercentageUsed", "MemoryLimit"
0:     };
1: 
0:     // Stat display flags
0:     private static final int STAT_DISP_BROKER  = Integer.parseInt("0001", 2);
0:     private static final int STAT_DISP_ALL     = Integer.parseInt("1111", 2);
1: 
0:     // Query object type to id mapping
0:     private static final Properties QUERY_TYPE_ID_MAP = new Properties();
1: 
0:     static
0:     {
0:         QUERY_TYPE_ID_MAP.setProperty("Broker",           "BrokerName");
0:         QUERY_TYPE_ID_MAP.setProperty("Connection",       "Connection");
0:         QUERY_TYPE_ID_MAP.setProperty("Connector",        "ConnectorName");
0:         QUERY_TYPE_ID_MAP.setProperty("NetworkConnector", "BrokerName");
0:         QUERY_TYPE_ID_MAP.setProperty("Queue",            "Destination");
0:         QUERY_TYPE_ID_MAP.setProperty("Topic",            "Destination");
0:     };
1: 
0:     private final ArrayList extensions   = new ArrayList();
0:     private final Map       queryObjects = new HashMap();
0:     private final List      queryViews   = new ArrayList();
1: 
0:     private int           taskType = TASK_NONE;
0:     private boolean       stopAll  = false;
0:     private JMXServiceURL jmxUrl;
0:     private URI           configURI;
0:     private File          activeMQHome;
0:     private ClassLoader   classLoader;
1: 
1:     public static void main(String[] args) {
1:         Main app = new Main();
1: 
1:         // Convert arguments to collection for easier management
0:         ArrayList tokens =  new ArrayList(Arrays.asList(args));
1: 
0:         // First token should be task type (start|stop|list|-h|-?|--help|--version)
0:         app.setTaskType(app.parseTask(tokens));
1: 
0:         // Succeeding tokens should be task specific options identified by "-" at the start
0:         app.parseOptions(tokens);
1: 
0:         // Succeeding tokens should be the task data
0:         switch (app.getTaskType()) {
0:             case  TASK_START_BROKER:
1:                 try {
0:                     app.taskStartBrokers(tokens);
1:                 } catch (Throwable e) {
0:                     System.out.println("Failed to start broker. Reason: " + e.getMessage());
1:                 }
0:                 break;
1: 
0:             case  TASK_STOP_BROKER:
1:                 try {
0:                     app.taskStopBrokers(tokens);
1:                 } catch (Throwable e) {
0:                     System.out.println("Failed to stop broker(s). Reason: " + e.getMessage());
1:                 }
0:                 break;
1: 
0:             case  TASK_LIST_BROKER:
1:                 try {
0:                     app.taskListBrokers();
1:                 } catch (Throwable e) {
0:                     e.printStackTrace();
0:                     System.out.println("Failed to list broker(s). Reason: " + e.getMessage());
1:                 }
0:                 break;
1: 
0:             case  TASK_STAT_BROKER:
1:                 try {
0:                     app.taskStatBrokers(tokens);
1:                 } catch (Throwable e) {
0:                     System.out.println("Failed to print broker statistics. Reason: " + e.getMessage());
1:                 }
0:                 break;
1: 
0:             case  TASK_QUERY_BROKER:
1:                 try {
0:                     app.taskQueryBrokers();
1:                 } catch (Throwable e) {
0:                     System.out.println("Failed to query broker. Reason: " + e.getMessage());
1:                 }
0:                 break;
1: 
0:             case  TASK_PRINT_MAIN_HELP:
0:                 app.printHelp(HELP_MAIN_APP);
0:                 break;
1: 
0:             case  TASK_PRINT_START_HELP:
0:                 app.printHelp(HELP_START_BROKER);
0:                 break;
1: 
0:             case  TASK_PRINT_STOP_HELP:
0:                 app.printHelp(HELP_STOP_BROKER);
0:                 break;
1: 
0:             case  TASK_PRINT_LIST_HELP:
0:                 app.printHelp(HELP_LIST_BROKER);
0:                 break;
1: 
0:             case  TASK_PRINT_STAT_HELP:
0:                 app.printHelp(HELP_STAT_BROKER);
0:                 break;
1: 
0:             case  TASK_PRINT_QUERY_HELP:
0:                 app.printHelp(HELP_QUERY_BROKER);
0:                 break;
1: 
0:             case  TASK_PRINT_VER:
0:                 app.printVersion();
0:                 break;
1: 
0:             case  TASK_PRINT_ALL_HELP:
0:                 app.printAllHelp();
0:                 break;
1: 
0:             case TASK_NONE:
0:             default:
0:                 break;
1:         }
1:     }
1: 
0:     public int parseTask(List tokens) {
1:         if (tokens.isEmpty()) {
0:             // If no defined arguments, assume start task and default uri
0:             return TASK_START_BROKER;
1:         }
1: 
0:         // Process task token
0:         String taskToken = (String)tokens.get(0);
1: 
0:         if (taskToken.equals("start")) {
0:             tokens.remove(0);
0:             return TASK_START_BROKER;
0:         } else if (taskToken.equals("stop")) {
0:             tokens.remove(0);
0:             return TASK_STOP_BROKER;
0:         } else if (taskToken.equals("list")) {
0:             tokens.remove(0);
0:             return TASK_LIST_BROKER;
0:         } else if (taskToken.equals("stat")) {
0:             tokens.remove(0);
0:             return TASK_STAT_BROKER;
0:         } else if (taskToken.equals("query")) {
0:             tokens.remove(0);
0:             return TASK_QUERY_BROKER;
0:         } else if (taskToken.equals("-h") || taskToken.equals("-?") || taskToken.equals("--help")) {
0:             // No need to parse other tokens
0:             tokens.clear();
0:             return TASK_PRINT_MAIN_HELP;
0:         } else if (taskToken.equals("--version")) {
0:             // No need to parse other tokens
0:             tokens.clear();
0:             return TASK_PRINT_VER;
1:         } else {
0:             // If not a valid task, assume start task and succeeding args are options
0:             return TASK_START_BROKER;
1:         }
1:     }
1: 
0:     public void parseOptions(List tokens) {
0:         String token;
1: 
0:         while (!tokens.isEmpty()) {
0:             token = (String)tokens.get(0);
1: 
0:             // If token is an option
0:             if (token.startsWith("-")) {
1: 
0:                 // Consider token to be processed
0:                 tokens.remove(0);
1: 
0:                 // If token is a help option
0:                 if (token.equals("-h") || token.equals("-?") || token.equals("--help")) {
0:                     switch (this.getTaskType()) {
0:                         case TASK_STOP_BROKER:
0:                             this.setTaskType(TASK_PRINT_STOP_HELP);
0:                             tokens.clear();
1:                             return;
1: 
0:                         case TASK_LIST_BROKER:
0:                             this.setTaskType(TASK_PRINT_LIST_HELP);
0:                             tokens.clear();
1:                             return;
1: 
0:                         case TASK_STAT_BROKER:
0:                             this.setTaskType(TASK_PRINT_STAT_HELP);
0:                             tokens.clear();
1:                             return;
1: 
0:                         case TASK_QUERY_BROKER:
0:                             this.setTaskType(TASK_PRINT_QUERY_HELP);
0:                             tokens.clear();
1:                             return;
1: 
0:                         case TASK_START_BROKER:
0:                         default:
0:                             this.setTaskType(TASK_PRINT_START_HELP);
0:                             tokens.clear();
1:                             return;
1: 
1:                     }
1: 
0:                 // If token is a version option
0:                 } else if (token.equals("--version")) {
0:                     this.setTaskType(TASK_PRINT_VER);
0:                     tokens.clear();
1:                     return;
1: 
1:                 // If token is an extension dir option
0:                 } else if (token.equals("--extdir")) {
0:                     if(!canUseExtdir()) {
0:                         printError("Extension directory feature not available due to the system classpath being able to load: " + BROKER_FACTORY_CLASS);
0:                         tokens.clear();
1:                         return;
1:                     }
1: 
0:                     // If no extension directory is specified, or next token is another option
0:                     if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                         printError("Extension directory not specified.");
1:                         return;
1:                     }
1: 
1:                     // Process extension dir token
0:                     File extDir = new File((String)tokens.remove(0));
1:                     if (!extDir.isDirectory()) {
0:                         printError("Extension directory specified is not valid directory: " + extDir);
1:                         return;
1:                     }
1: 
0:                     this.addExtensionDirectory(extDir);
1:                 }
1: 
0:                 // If token is a system property define option
0:                 else if (token.startsWith("-D")) {
0:                     String key = token.substring(2);
0:                     String value = "";
0:                     int pos = key.indexOf("=");
0:                     if (pos >= 0) {
0:                         value = key.substring(pos + 1);
0:                         key = key.substring(0, pos);
1:                     }
0:                     System.setProperty(key, value);
1:                 }
1: 
0:                 // If token is a query define option
0:                 else if (token.startsWith("-Q")) {
0:                     String key = token.substring(2);
0:                     String value = "";
0:                     int pos = key.indexOf("=");
0:                     if (pos >= 0) {
0:                         value = key.substring(pos + 1);
0:                         key = key.substring(0, pos);
1:                     }
1: 
0:                     queryObjects.put(key, value);
1:                 }
1: 
0:                 // If token is a view option
0:                 else if (token.startsWith("--view")) {
1: 
0:                     // If no view specified, or next token is a new option
0:                     if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                         printError("Attributes to view not specified");
1:                         return;
1:                     }
1: 
0:                     // Add the attributes to view
0:                     Enumeration viewTokens = new StringTokenizer((String)tokens.remove(0), ",", false);
0:                     while (viewTokens.hasMoreElements()) {
0:                         queryViews.add(viewTokens.nextElement());
1:                     }
1:                 }
1: 
0:                 // If token is a JMX URL option
0:                 else if (token.startsWith("--jmxurl")) {
1: 
0:                     // If no jmx url specified, or next token is a new option
0:                     if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                         printError("JMX URL not specified.");
1:                         return;
1:                     }
1: 
0:                     // If jmx url already specified
0:                     if (getJmxUrl() != null) {
0:                         printError("Multiple JMX URL cannot be specified.");
0:                         tokens.clear();
1:                         return;
1:                     }
1: 
0:                     String strJmxUrl = (String)tokens.remove(0);
1:                     try {
0:                         this.setJmxUrl(new JMXServiceURL(strJmxUrl));
0:                     } catch (MalformedURLException e) {
0:                         printError("Invalid JMX URL format: " + strJmxUrl);
0:                         tokens.clear();
1:                         return;
1:                     }
1: 
0:                 // If token is stop all broker option
0:                 } else if (token.equals("--all")) {
0:                     this.setStopAllBrokers(true);
1: 
1:                 } else {
0:                     System.out.println("Ignoring unrecognized option: " + token);
1:                 }
1: 
0:             // Finish parsing options
1:             } else {
1:                 return;
1:             }
1:         }
1:     }
1: 
0:     protected void taskStartBrokers(List brokerURIs) throws Throwable {
1: 
0:         // Flag an error if there are multiple configuration uris
0:         if (brokerURIs.size() > 1) {
0:             printError("Multiple configuration uris or broker names cannot be specified.");
0:             brokerURIs.clear();
1:             return;
1:         }
1: 
0:         // Add the default directories.
0:         if(canUseExtdir()) {
0:             this.addExtensionDirectory(new File(this.getActiveMQHome(), "conf"));
0:             this.addExtensionDirectory(new File(this.getActiveMQHome(), "lib"));
0:             this.addExtensionDirectory(new File(new File(this.getActiveMQHome(), "lib"), "optional"));
1:         }
1: 
0:         // If no config uri, use default setting
0:         if (brokerURIs.isEmpty()) {
0:             this.setConfigUri(this.getDefaultUri());
0:             this.startBroker(this.getConfigUri());
1: 
0:         // Set configuration data, if available, which in this case would be the config URI
1:         } else {
0:             String strConfigURI;
0: //            while (!brokerURIs.isEmpty()) {
0:                 strConfigURI = (String)brokerURIs.remove(0);
1: 
1:                 try {
0:                     this.setConfigUri(new URI(strConfigURI));
0:                 } catch (URISyntaxException e) {
0:                     printError("Invalid broker configuration URI: " + strConfigURI + ", reason: " + e.getMessage());
1:                     return;
1:                 }
1: 
0:                 this.startBroker(this.getConfigUri());
0: //            }
1:         }
1:     }
1: 
0:     protected void taskStopBrokers(List brokerNames) throws Throwable {
0:         // Check if there is a user-specified JMX URL
0:         if (this.getJmxUrl() == null) {
0:             this.setJmxUrl(this.getDefaultJmxUrl());
1:         }
1: 
0:         // Stop all brokers
0:         if (this.isStopAllBrokers()) {
0:             JMXConnector jmxConnector = JMXConnectorFactory.connect(this.getJmxUrl());
0:             MBeanServerConnection server = jmxConnector.getMBeanServerConnection();
1: 
0:             ObjectName brokerObjName = new ObjectName(DEFAULT_JMX_DOMAIN + ":Type=Broker,*");
1: 
0:             this.stopBroker(server, brokerObjName);
1: 
0:             brokerNames.clear();
1: 
0:             // Maybe no need to close, since context is already closed by broker
0:             //jmxConnector.close();
1: 
1:             return;
1:         }
1: 
0:         // Stop the default broker
0:         if (brokerNames.isEmpty()) {
0:             Set brokerList = this.getBrokerList(this.getJmxUrl());
1: 
0:             // If there is no broker to stop
0:             if (brokerList.isEmpty()) {
0:                 System.out.println("There are no brokers to stop.");
1:                 return;
1: 
0:             // There should only be one broker to stop
0:             } else if (brokerList.size() > 1) {
0:                 System.out.println("There are multiple brokers to stop. Please select the broker(s) to stop or use --all to stop all brokers.");
0:                 System.out.println();
0:                 printHelp(HELP_STOP_BROKER);
0:                 printBrokerList(brokerList);
1:                 return;
1: 
0:             // Stop the only running broker
1:             } else {
0:                 Iterator brokerIter = brokerList.iterator();
1: 
0:                 JMXConnector jmxConnector = JMXConnectorFactory.connect(this.getJmxUrl());
0:                 MBeanServerConnection server = jmxConnector.getMBeanServerConnection();
1: 
0:                 this.stopBroker(server, ((ObjectInstance)brokerIter.next()).getObjectName());
1: 
0:                 // Maybe no need to close, since context is already closed by broker
0:                 //jmxConnector.close();
1:                 return;
1:             }
1:         }
1: 
0:         // Stop each specified broker
0:         String brokerName;
1: 
0:         JMXConnector jmxConnector = JMXConnectorFactory.connect(this.getJmxUrl());
0:         MBeanServerConnection server = jmxConnector.getMBeanServerConnection();
1: 
0:         while (!brokerNames.isEmpty()) {
0:             brokerName = (String)brokerNames.remove(0);
0:             this.stopBroker(server, brokerName);
1:         }
1: 
0:         // Maybe be no need to close, since context is already closed by broker
0:         //jmxConnector.close();
1:     }
1: 
0:     protected void taskListBrokers() throws Throwable {
0:         // Check if there is a user-specified JMX URL
0:         if (this.getJmxUrl() == null) {
0:             this.setJmxUrl(this.getDefaultJmxUrl());
1:         }
1: 
0:         printBrokerList(this.getBrokerList(this.getJmxUrl()));
1:     }
1: 
0:     protected void taskStatBrokers(List brokerNames) throws Throwable {
0:         // Check if there is a user-specified JMX URL
0:         if (this.getJmxUrl() == null) {
0:             this.setJmxUrl(this.getDefaultJmxUrl());
1:         }
1: 
0:         // Print the statistics for the default broker
0:         if (brokerNames.isEmpty()) {
0:             Set brokerList = this.getBrokerList(this.getJmxUrl());
1: 
0:             // If there is no broker to stop
0:             if (brokerList.isEmpty()) {
0:                 System.out.println("There are no brokers running.");
1:                 return;
1: 
0:             // There should only be one broker to stop
0:             } else if (brokerList.size() > 1) {
0:                 System.out.println("There are multiple brokers running. Please select the broker to display the statistics for.");
0:                 System.out.println();
0:                 printHelp(HELP_STAT_BROKER);
0:                 printBrokerList(brokerList);
1:                 return;
1: 
0:             // Print the statistics for the only running broker
1:             } else {
0:                 Iterator brokerIter = brokerList.iterator();
1: 
0:                 JMXConnector jmxConnector = JMXConnectorFactory.connect(this.getJmxUrl());
0:                 MBeanServerConnection server = jmxConnector.getMBeanServerConnection();
1: 
0:                 ObjectName brokerObjName = ((ObjectInstance)brokerIter.next()).getObjectName();
0:                 this.printBrokerStat(brokerObjName.getKeyProperty(DEFAULT_KEY_BROKER_NAME), this.getBrokerStat(server, brokerObjName));
1: 
0:                 jmxConnector.close();
1:                 return;
1:             }
1:         }
1: 
0:         // Print the statistics for each specified broker
0:         String brokerName;
1: 
0:         JMXConnector jmxConnector = JMXConnectorFactory.connect(this.getJmxUrl());
0:         MBeanServerConnection server = jmxConnector.getMBeanServerConnection();
1: 
0:         while (!brokerNames.isEmpty()) {
0:             brokerName = (String)brokerNames.remove(0);
0:             System.out.println("-----------------------------------------------------");
0:             this.printBrokerStat(brokerName, this.getBrokerStat(server, brokerName));
0:             System.out.println();
1:         }
1: 
0:         jmxConnector.close();
1:     }
1: 
0:     protected void taskQueryBrokers() throws Throwable {
0:         // Check if there is a user-specified JMX URL
0:         if (this.getJmxUrl() == null) {
0:             this.setJmxUrl(this.getDefaultJmxUrl());
1:         }
1: 
0:         JMXConnector jmxConnector = JMXConnectorFactory.connect(this.getJmxUrl());
0:         MBeanServerConnection server = jmxConnector.getMBeanServerConnection();
1: 
0:         Set mbeans;
0:         // If there is no query defined get all mbeans
0:         if (this.getQueryObjects().isEmpty()) {
0:             ObjectName queryName = new ObjectName(DEFAULT_JMX_DOMAIN + ":*");
1: 
0:             mbeans = server.queryMBeans(queryName, null);
1: 
0:         // Construct the object name based on the query
1:         } else {
0:             mbeans = new HashSet();
0:             Set queryKeys = queryObjects.keySet();
0:             for (Iterator i=queryKeys.iterator(); i.hasNext();) {
0:                 String objType = (String)i.next();
0:                 String objName = (String)queryObjects.get(objType);
1: 
0:                 // If select all type
0:                 ObjectName queryName;
0:                 if (objName.equals("*")) {
0:                     queryName = new ObjectName(DEFAULT_JMX_DOMAIN + ":Type=" + objType + ",*");
1:                 } else {
0:                     queryName = new ObjectName(DEFAULT_JMX_DOMAIN + ":Type=" + objType + "," +
0:                                                QUERY_TYPE_ID_MAP.getProperty(objType) + "=" + objName + ",*");
1:                 }
0:                 mbeans.addAll(server.queryMBeans(queryName, null));
1:             }
1:         }
1: 
0:         for (Iterator i=mbeans.iterator(); i.hasNext();) {
0:             printMBeanAttr(server, (ObjectInstance)i.next(), this.getQueryViews());
1:         }
1: 
0:         jmxConnector.close();
1:     }
1: 
1:     public void addExtensionDirectory(File directory) {
1:         extensions.add(directory);
1:     }
1: 
0:     public void startBroker(URI configURI) throws Throwable {
0:         System.out.println("Loading Message Broker from: " + configURI);
0:         System.out.println("ACTIVEMQ_HOME: "+ getActiveMQHome());
1: 
1:         ClassLoader cl = getClassLoader();
1: 
0:         // Use reflection to start the broker up.
0:         Object broker;
1:         try {
0:             Class brokerFactory = cl.loadClass(BROKER_FACTORY_CLASS);
0:             Method createBroker = brokerFactory.getMethod("createBroker", new Class[] { URI.class });
0:             broker = createBroker.invoke(null, new Object[] { configURI });
1: 
0:             Method start = broker.getClass().getMethod("start", new Class[]{});
0:             start.invoke(broker, new Object[]{});
1: 
1:         } catch (InvocationTargetException e) {
1:             throw e.getCause();
1:         } catch (Throwable e) {
0:             throw e;
1:         }
1:     }
1: 
0:     public void stopBroker(MBeanServerConnection server, String brokerName) {
0:         ObjectName brokerObjName = null;
1:         try {
0:             brokerObjName = new ObjectName(DEFAULT_JMX_DOMAIN + ":Type=Broker," + DEFAULT_KEY_BROKER_NAME + "=" + brokerName);
0:         } catch (Exception e) {
0:             System.out.println("Invalid broker name: " + brokerName);
1:             return;
1:         }
0:         stopBroker(server, brokerObjName);
1:     }
1: 
0:     public void stopBroker(MBeanServerConnection server, ObjectName brokerObjName) {
0:         String brokerName = brokerObjName.getKeyProperty(DEFAULT_KEY_BROKER_NAME);
1: 
1:         try {
0:             server.invoke(brokerObjName, DEFAULT_METHOD_BROKER_STOP, DEFAULT_PARAM_BROKER_STOP, DEFAULT_SIGN_BROKER_STOP);
0:             System.out.println("Succesfully stopped broker: " + brokerName);
0:         } catch (Exception e) {
0:             // TODO: Check the exceptions thrown
0:             // System.out.println("Failed to stop broker: [ " + brokerName + " ]. Reason: " + e.getMessage());
1:             return;
1:         }
1:     }
1: 
1:     /**
0:      * The extension directory feature will not work if the broker factory is already in the classpath
0:      * since we have to load him from a child ClassLoader we build for it to work correctly.
0:      *
0:      * @return
1:      */
1:     public boolean canUseExtdir() {
1:         try {
0:             Main.class.getClassLoader().loadClass(BROKER_FACTORY_CLASS);
1:             return false;
1:         } catch (ClassNotFoundException e) {
1:             return true;
1:         }
1:     }
1: 
0:     public void printHelp(int helpIndex) {
0:         for (int i=0; i<taskHelp[helpIndex].length; i++) {
0:             System.out.println(taskHelp[helpIndex][i]);
1:         }
1:     }
1: 
0:     public void printAllHelp() {
0:         for (int i=0; i<taskHelp.length; i++) {
0:             printHelp(i);
1:         }
1:     }
1: 
0:     public void printError(String message) {
0:         System.out.println(message);
0:         System.out.println();
0:         setTaskType(TASK_NONE);
1:     }
1: 
0:     public void printVersion() {
0:         System.out.println();
1:         try {
0:             System.out.println("ActiveMQ " + getVersion());
1:         } catch (Throwable e) {
0:             System.out.println("ActiveMQ <unknown version>");
1:         }
0:         System.out.println("For help or more information please see: http://www.logicblaze.com");
0:         System.out.println();
1:     }
1: 
0:     public void printBrokerList(Set brokerList) {
0:         Object[] brokerArray = brokerList.toArray();
1: 
0:         System.out.println("List of available brokers:");
0:         for (int i=0; i<brokerArray.length; i++) {
0:             String brokerName = ((ObjectInstance)brokerArray[i]).getObjectName().getKeyProperty("BrokerName");
0:             System.out.println("    " + (i+1) + ".) " + brokerName);
1:         }
1:     }
1: 
0:     public void printMBeanAttr(MBeanServerConnection server, ObjectInstance mbean, List attrView) {
0:         ObjectName mbeanObjName = mbean.getObjectName();
0:         String mbeanType = mbeanObjName.getKeyProperty("Type");
0:         String mbeanName = mbeanObjName.getKeyProperty(QUERY_TYPE_ID_MAP.getProperty(mbeanType));
0:         System.out.println("MBean Type: " + mbeanType);
0:         System.out.println("MBean Name: " + mbeanName);
0:         System.out.println("MBean Attributes:");
1: 
1:         try {
0:             MBeanAttributeInfo[] attrs = server.getMBeanInfo(mbeanObjName).getAttributes();
1: 
0:             // If there mbean has no attribute, print a no attribute message
0:             if (attrs.length == 0) {
0:                 System.out.println("    MBean has no attributes.");
0:                 System.out.println();
1:                 return;
1:             }
1: 
0:             // If there is no view specified, print all attributes
0:             if (attrView == null || attrView.isEmpty()) {
0:                 for (int i=0; i<attrs.length; i++) {
0:                     Object attrVal = server.getAttribute(mbeanObjName, attrs[i].getName());
0:                     System.out.println("    " + attrs[i].getName() + " = " + attrVal.toString());
1:                 }
0:                 System.out.println();
1:                 return;
1:             }
1: 
0:             // Print attributes specified by view
0:             boolean matchedAttr = false;
0:             for (int i=0; i<attrs.length; i++) {
0:                 if (attrView.contains(attrs[i].getName())) {
0:                     matchedAttr = true;
0:                     Object attrVal = server.getAttribute(mbeanObjName, attrs[i].getName());
0:                     System.out.println("    " + attrs[i].getName() + " = " + attrVal.toString());
1:                 }
1:             }
1: 
0:             // If the mbean's attributes did not match any of the view, display a message
0:             if (!matchedAttr) {
0:                 System.out.println("    View did not match any of the mbean's attributes.");
1:             }
0:             System.out.println();
0:         } catch (Exception e) {
0:             System.out.println("Failed to print mbean attributes. Reason: " + e.getMessage());
1:         }
1:     }
1: 
0:     public void printBrokerStat(String brokerName, Map brokerStat) {
0:         printBrokerStat(brokerName, brokerStat, STAT_DISP_ALL);
1:     }
1: 
0:     public void printBrokerStat(String brokerName, Map brokerStat, int dispFlags) {
1: 
0:         System.out.println("Displaying usage statistics for broker: " + brokerName);
1: 
0:         if ((dispFlags & STAT_DISP_BROKER) != 0) {
0:             System.out.println("    Broker Enqueue Count: "        + brokerStat.get(STAT_BROKER_MAP[0]));
0:             System.out.println("    Broker Dequeue Count: "        + brokerStat.get(STAT_BROKER_MAP[1]));
0:             System.out.println("    Broker Consumer Count: "       + brokerStat.get(STAT_BROKER_MAP[2]));
0:             System.out.println("    Broker Message Count: "        + brokerStat.get(STAT_BROKER_MAP[3]));
0:             System.out.println("    Broker Cached Message Count: " + brokerStat.get(STAT_BROKER_MAP[4]));
0:             System.out.println("    Broker Memory Percent Used: "  + brokerStat.get(STAT_BROKER_MAP[5]));
0:             System.out.println("    Broker Memory Limit: "         + brokerStat.get(STAT_BROKER_MAP[6]));
0:             System.out.println();
1:         }
1:     }
1: 
0:     // Property setters and getters
0:     public void setTaskType(int taskType) {
0:         this.taskType = taskType;
1:     }
1: 
0:     public int getTaskType() {
0:         return taskType;
1:     }
1: 
0:     public void setJmxUrl(JMXServiceURL url) {
0:         jmxUrl = url;
1:     }
1: 
0:     public JMXServiceURL getJmxUrl() {
0:         return jmxUrl;
1:     }
1: 
0:     public JMXServiceURL getDefaultJmxUrl() throws MalformedURLException {
0:         return new JMXServiceURL(DEFAULT_JMX_URL);
1:     }
1: 
0:     public String getVersion() throws Throwable {
0:         // TODO: Why is version returned invalid?
1:         ClassLoader cl = getClassLoader();
0:         // Use reflection to get the version
1:         try {
0:             Class activeMQConnectionMetaData = cl.loadClass("org.apache.activemq.ActiveMQConnectionMetaData");
0:             Field field = activeMQConnectionMetaData.getField("PROVIDER_VERSION");
0:             return (String)field.get(null);
1:         } catch (Throwable e) {
0:             throw e;
1:         }
1:     }
1: 
0:     public URI getDefaultUri() throws URISyntaxException{
0:         return new URI(DEFAULT_CONFIG_URI);
1:     }
1: 
0:     public void setConfigUri(URI uri) {
0:         configURI = uri;
1:     }
1: 
0:     public URI getConfigUri() {
0:         return configURI;
1:     }
1: 
0:     public void setStopAllBrokers(boolean stopAll) {
0:         this.stopAll = stopAll;
1:     }
1: 
0:     public boolean isStopAllBrokers() {
0:         return stopAll;
1:     }
1: 
0:     public Map getQueryObjects() {
0:         return queryObjects;
1:     }
1: 
0:     public List getQueryViews() {
0:         return queryViews;
1:     }
1: 
1:     public ClassLoader getClassLoader() throws MalformedURLException {
0:         if(classLoader==null) {
0:             //
1:             // Setup the ClassLoader
0:             //
1:             classLoader = Main.class.getClassLoader();
0:             if (!extensions.isEmpty()) {
1: 
0:                 ArrayList urls = new ArrayList();
0:                 for (Iterator iter = extensions.iterator(); iter.hasNext();) {
0:                     File dir = (File) iter.next();
0:                     urls.add(dir.toURL());
0:                     File[] files = dir.listFiles();
0:                     if( files!=null ) {
0:                         for (int j = 0; j < files.length; j++) {
0:                             if( files[j].getName().endsWith(".zip") || files[j].getName().endsWith(".jar") ) {
0:                                 urls.add(files[j].toURL());
1:                             }
1:                         }
1:                     }
1:                 }
1: 
1:                 URL u[] = new URL[urls.size()];
1:                 urls.toArray(u);
1:                 classLoader = new URLClassLoader(u, classLoader);
1:             }
1:             Thread.currentThread().setContextClassLoader(classLoader);
1:         }
1:         return classLoader;
1:     }
1: 
1: 
1:     public void setActiveMQHome(File activeMQHome) {
1:         this.activeMQHome = activeMQHome;
1:     }
1: 
1:     public File getActiveMQHome() {
0:         if(activeMQHome==null) {
0:             if(System.getProperty("activemq.home") != null) {
1:                 activeMQHome = new File(System.getProperty("activemq.home"));
1:             }
1: 
0:             if(activeMQHome==null){
1:                 // guess from the location of the jar
0:                 URL url = Main.class.getClassLoader().getResource("org/apache/activemq/broker/Main.class");
1:                 if (url != null) {
1:                     try {
0:                         JarURLConnection jarConnection = (JarURLConnection) url.openConnection();
1:                         url = jarConnection.getJarFileURL();
1:                         URI baseURI = new URI(url.toString()).resolve("..");
1:                         activeMQHome = new File(baseURI).getCanonicalFile();
1:                     } catch (Exception ignored) {
1:                     }
1:                 }
1:             }
1: 
0:             if(activeMQHome==null){
0:                 activeMQHome = new File(".");
1:             }
1:         }
1:         return activeMQHome;
1:     }
1: 
0:     public Set getBrokerList(JMXServiceURL jmxUrl) throws Throwable {
0:         JMXConnector jmxConnector = JMXConnectorFactory.connect(jmxUrl);
0:         MBeanServerConnection server = jmxConnector.getMBeanServerConnection();
1: 
0:         ObjectName brokerObjName = new ObjectName(DEFAULT_JMX_DOMAIN + ":Type=Broker,*");
1: 
0:         Set brokerMBeans = server.queryMBeans(brokerObjName, null);
1: 
0:         jmxConnector.close();
1: 
0:         return brokerMBeans;
1:     }
1: 
0:     public Map getBrokerStat(MBeanServerConnection server, String brokerName) throws Throwable {
0:         return getBrokerStat(server, brokerName, STAT_ALL);
1:     }
1: 
0:     public Map getBrokerStat(MBeanServerConnection server, ObjectName brokerObjName) {
0:         return getBrokerStat(server, brokerObjName, STAT_ALL);
1:     }
1: 
0:     public Map getBrokerStat(MBeanServerConnection server, String brokerName, int statFlags) throws Throwable {
0:         ObjectName brokerObjName = null;
1:         try {
0:             brokerObjName = new ObjectName(DEFAULT_JMX_DOMAIN + ":Type=Broker," + DEFAULT_KEY_BROKER_NAME + "=" + brokerName);
0:         } catch (Exception e) {
0:             System.out.println("Invalid broker name: " + brokerName);
0:             return null;
1:         }
1: 
0:         return getBrokerStat(server, brokerObjName, statFlags);
1:     }
1: 
0:     public Map getBrokerStat(MBeanServerConnection server, ObjectName brokerObjName, int statFlags) {
0:         Map brokerStat = new HashMap();
1: 
1:         try {
0:             if ((statFlags & STAT_BROKER) != 0) {
0:                 for (int i=0; i<STAT_BROKER_MAP.length; i++) {
0:                     brokerStat.put(STAT_BROKER_MAP[i], // key name of statistic
0:                         server.getAttribute(brokerObjName, (String)STAT_BROKER_MAP[i]) // attribute to get)
0:                     );
1:                 }
1:             }
0:         } catch (Exception e) {
0:             return null;
1:         }
1: 
0:         return brokerStat;
1:     }
1: 
0:     // This section contains an array of the help notes of the different tasks
0:     private static final String[][] taskHelp = {
0:         // Main task help
0:         {
0:             "Usage: Main [task] [task-options] [task data]",
0:             "",
0:             "Tasks (default task is start):",
0:             "    start        - Creates and starts a broker using a configuration file, or a broker URI.",
0:             "    stop         - Stops a running broker specified by the broker name.",
0:             "    list         - Lists all available broker in the specified JMX context.",
0:             "    --version    - Display the version information.",
0:             "    -h,-?,--help - Display this help information. To display task specific help, use Main [task] -h,-?,--help",
0:             "",
0:             "Task Options:",
0:             "    - Properties specific to each task.",
0:             "",
0:             "Task Data:",
0:             "    - Information needed by each specific task.",
0:             ""
0:         },
1: 
0:         // Start broker task help
0:         {
0:             "Task Usage: Main start [start-options] [uri]",
0:             "",
0:             "Start Options:",
0:             "    --extdir <dir>        Add the jar files in the directory to the classpath.",
0:             "    -D<name>=<value>      Define a system property.",
0:             "    --version             Display the version information.",
0:             "    -h,-?,--help          Display the start broker help information.",
0:             "",
0:             "URI:",
0:             "",
0:             "    XBean based broker configuration:",
0:             "",
0:             "        Example: Main xbean:file:activemq.xml",
0:             "            Loads the xbean configuration file from the current working directory",
0:             "        Example: Main xbean:activemq.xml",
0:             "            Loads the xbean configuration file from the classpath",
0:             "",
0:             "    URI Parameter based broker configuration:",
0:             "",
0:             "        Example: Main broker:(tcp://localhost:61616, tcp://localhost:5000)?useJmx=true",
0:             "            Configures the broker with 2 transport connectors and jmx enabled",
0:             "        Example: Main broker:(tcp://localhost:61616, network:tcp://localhost:5000)?persistent=false",
0:             "            Configures the broker with 1 transport connector, and 1 network connector and persistence disabled",
0:             ""
0:         },
1: 
0:         // Stop broker task help
0:         {
0:             "Task Usage: Main stop [stop-options] [broker-name1] [broker-name2] ...",
0:             "",
0:             "Stop Options:",
0:             "    --jmxurl <url>      Set the JMX URL to connect to.",
0:             "    --all               Stop all brokers.",
0:             "    --version           Display the version information.",
0:             "    -h,-?,--help        Display the stop broker help information.",
0:             "",
0:             "Broker Names:",
0:             "    Name of the brokers that will be stopped.",
0:             "    If omitted, it is assumed that there is only one broker running, and it will be stopped.",
0:             "    Use -all to stop all running brokers.",
0:             ""
0:         },
1: 
0:         // List brokers task help
0:         {
0:             "Task Usage: Main list [list-options]",
0:             "",
0:             "List Options:",
0:             "    --jmxurl <url>      Set the JMX URL to connect to.",
0:             "    --version           Display the version information.",
0:             "    -h,-?,--help        Display the stop broker help information.",
0:             "",
0:         },
1: 
0:         // Stat brokers task help
0:         {
0:             "Task Usage: Main stat [stat-options] [broker-name1] [broker-name2] ...",
0:             "",
0:             "Stat Options:",
0:             "    --jmxurl <url>      Set the JMX URL to connect to.",
0:             "    --version           Display the version information.",
0:             "    -h,-?,--help        Display the stat broker help information.",
0:             "",
0:         },
1: 
0:         // Query brokers task help
0:         {
0:             "Task Usage: Main query [query-options]",
0:             "",
0:             "Query Options:",
0:             "    -Q<type>=<name>               Filter the specific object type using the defined object identifier.",
0:             "    --view <attr1>,<attr2>,...    Select the specific attribute of the object to view. By default all attributes will be displayed.",
0:             "    --jmxurl <url>                Set the JMX URL to connect to.",
0:             "    --version                     Display the version information.",
0:             "    -h,-?,--help                  Display the query broker help information.",
0:             "",
0:             "Examples:",
0:             "    Main query",
0:             "        - Print all the attributes of all registered objects (queues, topics, connections, etc).",
0:             "",
0:             "    Main query -QQueue=TEST.FOO",
0:             "        - Print all the attributes of the queue with destination name TEST.FOO.",
0:             "",
0:             "    Main query -QTopic=*",
0:             "        - Print all the attributes of all registered topics.",
0:             "",
0:             "    Main query --view EnqueueCount,DequeueCount",
0:             "        - Print the attributes EnqueueCount and DequeueCount of all registered objects.",
0:             "",
0:             "    Main -QTopic=* --view EnqueueCount,DequeueCount",
0:             "        - Print the attributes EnqueueCount and DequeueCount of all registered topics.",
0:             "",
0:             "    Main -QTopic=* -QQueue=* --view EnqueueCount,DequeueCount",
0:             "        - Print the attributes EnqueueCount and DequeueCount of all registered topics and queues.",
0:             ""
1:         }
0:     };
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:b14fec3
/////////////////////////////////////////////////////////////////////////
1:                     urls.add(dir.toURI().toURL());
/////////////////////////////////////////////////////////////////////////
1:                                     urls.add(files[j].toURI().toURL());
author:Robert Davies
-------------------------------------------------------------------------------
commit:9797077
/////////////////////////////////////////////////////////////////////////
1: import java.lang.management.ManagementFactory;
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder buffer = new StringBuilder();
1:         buffer.append(System.getProperty("java.vendor"));
1:         buffer.append(" ");
1:         buffer.append(System.getProperty("java.version"));
1:         buffer.append(" ");
1:         buffer.append(System.getProperty("java.home"));
1:         System.out.println("Java Runtime: " + buffer.toString());
0: 
1:         buffer = new StringBuilder();
0:         buffer.append("current="); 
0:         buffer.append(Runtime.getRuntime().totalMemory()/1024L); 
0:         buffer.append("k  free="); 
0:         buffer.append(Runtime.getRuntime().freeMemory()/1024L); 
0:         buffer.append("k  max="); 
0:         buffer.append(Runtime.getRuntime().maxMemory()/1024L); 
1:         buffer.append("k");
1:         System.out.println("  Heap sizes: " + buffer.toString());
0: 
0:         List jvmArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();
1:         buffer = new StringBuilder(); 
1:         for (Object arg : jvmArgs) {
1:             buffer.append(" ").append(arg);
0:         }
1:         System.out.println("    JVM args:" + buffer.toString());
0: 
author:James Strachan
-------------------------------------------------------------------------------
commit:0576de3
/////////////////////////////////////////////////////////////////////////
0: 		// lets add the conf directory first, to find the log4j.properties just in case its not 
0: 		// in the activemq.classpath system property or some jar incorrectly includes one
0: 		File confDir = new File(app.getActiveMQBase(), "conf");
0: 		app.addClassPath(confDir);
0: 
/////////////////////////////////////////////////////////////////////////
0: 		Thread.currentThread().setContextClassLoader(cl);
commit:af9cc56
/////////////////////////////////////////////////////////////////////////
1:         // ${activemq.base}/lib/web/* (only if activemq.base != activemq.home)
1:         // ${activemq.home}/lib/web/*
1:             File baseLibDir = new File(app.getActiveMQBase(), "lib");
1:             File homeLibDir = new File(app.getActiveMQHome(), "lib");
1:                 app.addExtensionDirectory(baseLibDir);
1:             app.addExtensionDirectory(homeLibDir);
0: 
0:             if(!baseIsHome) {
1:                 app.addExtensionDirectory(new File(baseLibDir, "optional"));
1:                 app.addExtensionDirectory(new File(baseLibDir, "web"));
0:             }
1:             app.addExtensionDirectory(new File(homeLibDir, "optional"));
1:             app.addExtensionDirectory(new File(homeLibDir, "web"));
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:f30b0d8
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import java.util.HashSet;
0: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
0:     private File          activeMQBase;
0:     private Set           extensions = new HashSet(5);
0:     private Set           activeMQClassPath = new HashSet(5);
/////////////////////////////////////////////////////////////////////////
0:         //
0:         // ${activemq.home}/lib/*
0:         // ${activemq.home}/lib/optional/*
0:         //
0:             boolean baseIsHome = app.getActiveMQBase().equals(app.getActiveMQHome());
0: 
0: 
0: 
0:         // Add any custom classpath specified from the system property activemq.classpath
1:         app.addClassPathList(System.getProperty("activemq.classpath"));
0: 
0:                 ClassLoader cl = app.getClassLoader();
0:                 if( cl!=null ) {
0:                     System.out.println("Class loader setup: ");
0:                     printClassLoaderTree(cl);
0:                 }
0:             } catch (MalformedURLException e1) {
0:             }
0:      * Print out what's in the classloader tree being used.
0:      *
1:      * @return depth
0:     private static int printClassLoaderTree(ClassLoader cl) {
0:         int depth = 0;
0:         if( cl.getParent()!=null ) {
0:             depth = printClassLoaderTree(cl.getParent())+1;
0:         }
0:         StringBuffer indent = new StringBuffer();
0:         for (int i = 0; i < depth; i++) {
0:             indent.append("  ");
0:         }
0: 
0:         if( cl instanceof URLClassLoader ) {
0:             URLClassLoader ucl = (URLClassLoader) cl;
0:             System.out.println(indent+cl.getClass().getName()+" {");
0:             URL[] urls = ucl.getURLs();
0:             for (int i = 0; i < urls.length; i++) {
0:                 System.out.println(indent+"  "+urls[i]);
0:             }
0:             System.out.println(indent+"}");
0:         } else {
0:             System.out.println(indent+cl.getClass().getName());
0:         }
0:         return depth;
0:     }
0: 
0:     public void parseExtensions(List tokens) {
/////////////////////////////////////////////////////////////////////////
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void addClassPathList(String fileList) {
1:         if (fileList != null && fileList.length() > 0) {
0:             StringTokenizer tokenizer = new StringTokenizer(fileList, ";");
1:             while (tokenizer.hasMoreTokens()) {
1:                 addClassPath(new File(tokenizer.nextToken()));
0:             }
0:         }
0:     }
0: 
1:     public void addClassPath(File classpath) {
1:         activeMQClassPath.add(classpath);
0:     }
1:      * @return true, if extension dir can be used. false otherwise.
/////////////////////////////////////////////////////////////////////////
1:             if (!extensions.isEmpty() || !activeMQClassPath.isEmpty()) {
0: 
0:                 for (Iterator iter = activeMQClassPath.iterator(); iter.hasNext();) {
0: 
0:                         File[] files = dir.listFiles();
0:                         if( files!=null ) {
0: 
0:                             // Sort the jars so that classpath built is consistently
0:                             // in the same order.  Also allows us to use jar names to control
0:                             // classpath order.
0:                             Arrays.sort(files, new Comparator(){
0:                                 public int compare(Object o1, Object o2) {
0:                                     File f1 = (File) o1;
0:                                     File f2 = (File) o2;
0:                                     return f1.getName().compareTo(f2.getName());
0:                                 }
0:                             });
0: 
0:                             for (int j = 0; j < files.length; j++) {
0:                                 if( files[j].getName().endsWith(".zip") || files[j].getName().endsWith(".jar") ) {
0:                                     // try{ System.out.println("Adding to classpath: " + files[j].getCanonicalPath()); }catch(Exception e){}
0:                                     urls.add(files[j].toURL());
0:                                 }
0:                             }
0:                         }
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:                 activeMQBase = new File(System.getProperty("activemq.base"));
0: 
0: 
commit:2fc2c28
/////////////////////////////////////////////////////////////////////////
1:                 URL url = Main.class.getClassLoader().getResource("org/apache/activemq/console/Main.class");
/////////////////////////////////////////////////////////////////////////
1:                 activeMQHome = new File("../.");
0:         
commit:7fa8660
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.console;
/////////////////////////////////////////////////////////////////////////
0:     public static final String TASK_DEFAULT_CLASS  = "org.apache.activemq.console.command.ShellCommand";
commit:4b8822f
/////////////////////////////////////////////////////////////////////////
0:     public static final String TASK_DEFAULT_CLASS  = "org.apache.activemq.broker.console.command.ShellCommand";
/////////////////////////////////////////////////////////////////////////
1:         int count = tokens.size();
1:         int i = 0;
0: 
1:         // Parse for all --extdir and --noDefExt options
1:         while (i < count) {
0:             String token = (String)tokens.get(i);
1:                 // Process token
1:                 count--;
1:                 tokens.remove(i);
0:                 if (i >= count || ((String)tokens.get(i)).startsWith("-")) {
1:                     System.out.println("Extension directory not specified.");
1:                     System.out.println("Ignoring extension directory option.");
1:                     continue;
0:                 // Process extension dir token
1:                 count--;
0:                 File extDir = new File((String)tokens.remove(i));
0: 
1:                     continue;
0: 
0:                 if (!extDir.isDirectory()) {
1:                     System.out.println("Extension directory specified is not valid directory: " + extDir);
1:                     System.out.println("Ignoring extension directory option.");
1:                     continue;
0:                 }
0: 
1:                 addExtensionDirectory(extDir);
1:                 count--;
1:                 tokens.remove(i);
0:             } else {
1:                 i++;
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
commit:70c2d88
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
0: import java.util.LinkedList;
0: import java.util.Arrays;
0: import java.util.Iterator;
0:  * Main class that can bootstrap an ActiveMQ broker console. Handles command line
0:  * argument parsing to set up and run broker tasks.
0:     public static final int TASK_DEFAULT = 0;
0:     public static final int TASK_START   = 1;
0:     public static final int TASK_STOP    = 2;
0:     public static final int TASK_LIST    = 3;
0:     public static final int TASK_QUERY   = 4;
0:     public static final String TASK_DEFAULT_CLASS  = "org.apache.activemq.broker.console.DefaultTask";
0:     public static final String TASK_START_CLASS    = "org.apache.activemq.broker.console.StartTask";
0:     public static final String TASK_SHUTDOWN_CLASS = "org.apache.activemq.broker.console.ShutdownTask";
0:     public static final String TASK_LIST_CLASS     = "org.apache.activemq.broker.console.ListTask";
0:     public static final String TASK_QUERY_CLASS    = "org.apache.activemq.broker.console.QueryTask";
0:     private int           taskType;
0:     private List          extensions = new ArrayList(5);
/////////////////////////////////////////////////////////////////////////
1:         // Parse for extension directory option
1:         app.parseExtensions(tokens);
0:         // Add default extension directories
0:         if(app.canUseExtdir()) {
0:             app.addExtensionDirectory(new File(app.getActiveMQHome(), "conf"));
0:             app.addExtensionDirectory(new File(app.getActiveMQHome(), "lib"));
0:             app.addExtensionDirectory(new File(new File(app.getActiveMQHome(), "lib"), "optional"));
0:         try {
0:             switch (app.getTaskType()) {
0:                 case TASK_START:   app.runTaskClass(TASK_START_CLASS, tokens);    break;
0:                 case TASK_STOP:    app.runTaskClass(TASK_SHUTDOWN_CLASS, tokens); break;
0:                 case TASK_LIST:    app.runTaskClass(TASK_LIST_CLASS, tokens);     break;
0:                 case TASK_QUERY:   app.runTaskClass(TASK_QUERY_CLASS, tokens);    break;
0:                 case TASK_DEFAULT: app.runTaskClass(TASK_DEFAULT_CLASS, tokens);  break;
0:                 default:
0:                     System.out.println("Encountered unknown task type: " + app.getTaskType());
0:             }
0:         } catch (Throwable e) {
1:             System.out.println("Failed to execute main task. Reason: " + e);
0:             // If no task, run the default task
0:             return TASK_DEFAULT;
/////////////////////////////////////////////////////////////////////////
0:             return TASK_DEFAULT;
0:     public void parseExtensions(List tokens) {
0:         if (tokens.isEmpty()) {
0:         
0:         String token = (String)tokens.get(0);
0:         // If token is an extension dir option
1:         if (token.equals("--extdir")) {
0:             // Process token
0:             tokens.remove(0);
0:             // If no extension directory is specified, or next token is another option
0:             if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                 System.out.println("Extension directory not specified.");
1:                 System.out.println("Ignoring extension directory option.");
0: 
0:             // Process extension dir token
0:             File extDir = new File((String)tokens.remove(0));
0: 
0:             if(!canUseExtdir()) {
1:                 System.out.println("Extension directory feature not available due to the system classpath being able to load: " + TASK_DEFAULT_CLASS);
1:                 System.out.println("Ignoring extension directory option.");
0:                 return;
0:             }
0: 
0:             if (!extDir.isDirectory()) {
0:                 System.out.println("Extension directory specified is not valid directory: " + extDir);
1:                 System.out.println("Ignoring extension directory option.");
0:                 return;
0:             }
0: 
0:             addExtensionDirectory(extDir);
0:     public void runTaskClass(String taskClass, List tokens) throws Throwable {
1:         // Use reflection to run the task.
0:             Class task = cl.loadClass(taskClass);
0:             Method runTask = task.getMethod("runTask", new Class[] { List.class });
0:             runTask.invoke(task.newInstance(), new Object[] { tokens });
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             Main.class.getClassLoader().loadClass(TASK_DEFAULT_CLASS);
/////////////////////////////////////////////////////////////////////////
0:     public int getTaskType() {
0:         return taskType;
0:     }
0: 
0:     public void setTaskType(int taskType) {
0:         this.taskType = taskType;
0:     }
/////////////////////////////////////////////////////////////////////////
commit:34cadaf
/////////////////////////////////////////////////////////////////////////
0:                 // If token is a additive predefined query define option
/////////////////////////////////////////////////////////////////////////
0:                     String predefQuery = PREDEFINED_OBJNAME_QUERY.getProperty(key);
0:                     if (predefQuery == null) {
0:                         printError("Unknown query object type: " + key);
0:                         return;
0:                     String queryStr = createQueryString(predefQuery, value);
0:                     queryAddObjects.add(queryStr);
0:                 // If token is a substractive predefined query define option
0:                 else if (token.startsWith("-xQ")) {
0:                     String key = token.substring(3);
0:                     String value = "";
0:                     int pos = key.indexOf("=");
0:                     if (pos >= 0) {
0:                         value = key.substring(pos + 1);
0:                         key = key.substring(0, pos);
0:                     }
0: 
0:                     // If subtractive query
0:                     String predefQuery = PREDEFINED_OBJNAME_QUERY.getProperty(key);
0:                     if (predefQuery == null) {
0:                         printError("Unknown query object type: " + key);
0:                         return;
0:                     }
0:                     String queryStr = createQueryString(predefQuery, value);
0:                     querySubObjects.add(queryStr);
0:                 }
0: 
0:                 // If token is an additive object name query option
/////////////////////////////////////////////////////////////////////////
0:                     queryAddObjects.add(queryString);
0:                 }
0:                 // If token is a substractive object name query option
0:                 else if (token.startsWith("--xobjname")) {
0:                     // If no object name query is specified, or next token is a new option
0:                     if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                         printError("Object name query not specified");
0:                         return;
0: 
0:                     String queryString = (String)tokens.remove(0);
0:                     querySubObjects.add(queryString);
/////////////////////////////////////////////////////////////////////////
0:             "    -xQ<type>=<name>              Remove from the search list the specific object type matched by the object identifier.",
0:             "    --xobjname <query>            Remove from the search list objects matched by the query similar to the JMX object name format.",
/////////////////////////////////////////////////////////////////////////
0:             "    Main -QTopic=* -xQTopic=ActiveMQ.Advisory.*",
0:             "    Main --objname Type=*Connect*,BrokerName=local* -xQNetworkConnector=*",
0:             "    Main -QQueue=* -xQQueue=????",
commit:04e2cdc
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
0: import java.util.regex.Pattern;
0: import javax.management.InstanceNotFoundException;
0: import javax.management.MBeanException;
0: import javax.management.ReflectionException;
/////////////////////////////////////////////////////////////////////////
0:     public static final int HELP_MAIN       = 0;
0:     public static final int HELP_START_TASK = 1;
0:     public static final int HELP_STOP_TASK  = 2;
0:     public static final int HELP_LIST_TASK  = 3;
0:     public static final int HELP_QUERY_TASK = 4;
0:     public static final int TASK_NONE  = 0;
0:     public static final int TASK_START = 1;
0:     public static final int TASK_STOP  = 2;
0:     public static final int TASK_LIST  = 3;
0:     public static final int TASK_QUERY = 4;
0:     private static final String DEFAULT_KEY_BROKER_NAME = "BrokerName";
0:     // Predefined type=identifier query
0:     private static final Properties PREDEFINED_OBJNAME_QUERY = new Properties();
0:         PREDEFINED_OBJNAME_QUERY.setProperty("Broker",           "Type=Broker,BrokerName=%1,*");
0:         PREDEFINED_OBJNAME_QUERY.setProperty("Connection",       "Type=Connection,Connection=%1,*");
0:         PREDEFINED_OBJNAME_QUERY.setProperty("Connector",        "Type=Connector,ConnectorName=%1,*");
0:         PREDEFINED_OBJNAME_QUERY.setProperty("NetworkConnector", "Type=NetworkConnector,BrokerName=%1,*");
0:         PREDEFINED_OBJNAME_QUERY.setProperty("Queue",            "Type=Queue,Destination=%1,*");
0:         PREDEFINED_OBJNAME_QUERY.setProperty("Topic",            "Type=Topic,Destination=%1,*");
0:     private final List brokers         = new ArrayList(5);
0:     private final List extensions      = new ArrayList(5);
0:     private final List queryAddObjects = new ArrayList(10);
0:     private final List querySubObjects = new ArrayList(10);
0:     private final List queryViews      = new ArrayList(10);
0:     private int     taskType  = TASK_NONE;
0:     private boolean stopAll   = false;
0:     private boolean printHelp = false;
0:     private boolean printVer  = false;
0: 
/////////////////////////////////////////////////////////////////////////
0:         List tokens =  new LinkedList(Arrays.asList(args));
0:         // First token should be task type (start|stop|list|query)
0:         // If display version is set, display and quit no matter the task
0:         if (app.isPrintVersion()) {
0:             app.printVersion();
0:             return;
0:         }
0: 
0:         // Display the main help, if there is no selected task and help flag is set
0:         if (app.getTaskType()==TASK_NONE && app.isPrintHelp()) {
0:             app.printHelp(HELP_MAIN);
0:             return;
0:         }
0: 
0:             case  TASK_START:
0:                 // Print start task help
0:                 if (app.isPrintHelp()) {
0:                     app.printHelp(HELP_START_TASK);
0: 
0:                 // Run start broker task
0:                 } else {
0:                     try {
0:                         app.taskStart(tokens);
0:                     } catch (Throwable e) {
0:                         System.out.println("Failed to execute start task. Reason: " + e);
0:                     }
0:             case  TASK_STOP:
0:                 // Print stop task help
0:                 if (app.isPrintHelp()) {
0:                     app.printHelp(HELP_STOP_TASK);
0: 
0:                 // Run stop broker task
0:                 } else {
0:                     try {
0:                         app.taskStop(tokens);
0:                     } catch (Throwable e) {
0:                         System.out.println("Failed to execute stop task. Reason: " + e);
0:                     }
0:             case  TASK_LIST:
0:                 // Print list broker help
0:                 if (app.isPrintHelp()) {
0:                     app.printHelp(HELP_LIST_TASK);
0: 
0:                 // Run list task
0:                 } else {
0:                     try {
0:                         app.taskList();
0:                     } catch (Throwable e) {
0:                         e.printStackTrace();
0:                         System.out.println("Failed to execute list task. Reason: " + e);
0:                     }
0:             case  TASK_QUERY:
0:                 // Print query broker help
0:                 if (app.isPrintHelp()) {
0:                     app.printHelp(HELP_QUERY_TASK);
0: 
0:                 // Run query task
0:                 } else {
0:                     try {
0:                         app.taskQuery();
0:                     } catch (Throwable e) {
0:                         System.out.println("Failed to execute query task. Reason: " + e);
0:                     }
0:                 break;
0:                 app.printHelp(HELP_MAIN);
/////////////////////////////////////////////////////////////////////////
0:             return TASK_START;
0:         String taskToken = (String)tokens.remove(0);
0:             return TASK_START;
0:             return TASK_STOP;
0:             return TASK_LIST;
0:             return TASK_QUERY;
0:             // If not valid task, push back to list
0:             tokens.add(0, taskToken);
0:             return TASK_NONE;
/////////////////////////////////////////////////////////////////////////
0:             token = (String)tokens.remove(0);
0:                     printHelp = true;
0:                     tokens.clear();
0:                     return;
0:                     printVer = true;
/////////////////////////////////////////////////////////////////////////
0:                     addExtensionDirectory(extDir);
/////////////////////////////////////////////////////////////////////////
0:                 // If token is a predefined query define option
/////////////////////////////////////////////////////////////////////////
0:                     // If subtractive query
0:                     if (key.startsWith("!")) {
0:                         // Transform predefined query to object name query
0:                         String predefQuery = PREDEFINED_OBJNAME_QUERY.getProperty(key.substring(1));
0:                         if (predefQuery == null) {
0:                             printError("Unknown query object type: " + key.substring(1));
0:                             return;
0:                         }
0:                         String queryStr = createQueryString(predefQuery, value);
0:                         querySubObjects.add(queryStr);
0:                     }
0: 
0:                     // If additive query
0:                     else {
0:                         // Transform predefined query to object name query
0:                         String predefQuery = PREDEFINED_OBJNAME_QUERY.getProperty(key);
0:                         if (predefQuery == null) {
0:                             printError("Unknown query object type: " + key);
0:                             return;
0:                         }
0:                         String queryStr = createQueryString(predefQuery, value);
0:                         queryAddObjects.add(queryStr);
0:                     }
0:                 }
0: 
0:                 // If token is an object name query option
0:                 else if (token.startsWith("--objname")) {
0: 
0:                     // If no object name query is specified, or next token is a new option
0:                     if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                         printError("Object name query not specified");
0:                         return;
0:                     }
0: 
0:                     String queryString = (String)tokens.remove(0);
0: 
0:                     // If subtractive query
0:                     if (queryString.startsWith("!")) {
0:                         querySubObjects.add(queryString.substring(1));
0: 
0:                     // If additive query
0:                     } else {
0:                         queryAddObjects.add(queryString);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                     stopAll = true;
/////////////////////////////////////////////////////////////////////////
0:                 // If not valid option, push back to list
0:                 tokens.add(0, token);
0:     protected void taskStart(List brokerURIs) throws Throwable {
0: //        if (brokerURIs.size() > 1) {
0: //            printError("Multiple configuration uris or broker names cannot be specified.");
0: //            brokerURIs.clear();
0: //            return;
0: //        }
0:             addExtensionDirectory(new File(getActiveMQHome(), "conf"));
0:             addExtensionDirectory(new File(getActiveMQHome(), "lib"));
0:             addExtensionDirectory(new File(new File(getActiveMQHome(), "lib"), "optional"));
0:             setConfigUri(getDefaultUri());
0:             startBroker(getConfigUri());
0: 
0:             while (!brokerURIs.isEmpty()) {
0:                     setConfigUri(new URI(strConfigURI));
0:                 startBroker(getConfigUri());
0:             }
0: 
0:         // Prevent the main thread from exiting unless it is terminated elsewhere
0:     protected void taskStop(List brokerNames) throws Throwable {
0:         if (getJmxUrl() == null) {
0:             setJmxUrl(getDefaultJmxUrl());
0:         if (isStopAllBrokers()) {
0:             JMXConnector jmxConnector = JMXConnectorFactory.connect(getJmxUrl());
0:             stopBroker(server, brokerObjName);
/////////////////////////////////////////////////////////////////////////
0:             Set brokerList = getBrokerList(getJmxUrl());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 JMXConnector jmxConnector = JMXConnectorFactory.connect(getJmxUrl());
/////////////////////////////////////////////////////////////////////////
0:         JMXConnector jmxConnector = JMXConnectorFactory.connect(getJmxUrl());
0:             stopBroker(server, brokerName);
0:     protected void taskList() throws Throwable {
0:         if (getJmxUrl() == null) {
0:             setJmxUrl(getDefaultJmxUrl());
0:         printBrokerList(getBrokerList(getJmxUrl()));
0:     protected void taskQuery() throws Throwable {
0:         if (getJmxUrl() == null) {
0:             setJmxUrl(getDefaultJmxUrl());
0:         // Connect to jmx server
0:         JMXConnector jmxConnector = JMXConnectorFactory.connect(getJmxUrl());
0:         // Query for the mbeans to add
0:         Set addMBeans = queryMBeans(server, getAddQueryObjects());
0: 
0:         // Query for the mbeans to sub
0:         if (getSubQueryObjects().size() > 0) {
0:             Set subMBeans = queryMBeans(server, getSubQueryObjects());
0:             addMBeans.removeAll(subMBeans);
0:         }
0: 
0:         for (Iterator i=addMBeans.iterator(); i.hasNext();) {
0:             ObjectInstance mbean = (ObjectInstance)i.next();
0:             printMBeanProp(mbean, null);
0:             printMBeanAttr(server, mbean, getQueryViews());
/////////////////////////////////////////////////////////////////////////
0:     public void addExtensionDirectory(File directory) {
0:         extensions.add(directory);
0:     }
0: 
0:     protected void waitForShutdown() throws Throwable {
0:         final boolean[] shutdown = new boolean[] {false};
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:             Set brokerList = server.queryMBeans(brokerObjName, null);
0: 
0:             // Stop each broker that matches the object name
0:             for (Iterator i=brokerList.iterator(); i.hasNext();) {
0:                 ObjectName broker = ((ObjectInstance)i.next()).getObjectName();
0: 
0:                 String brokerName = broker.getKeyProperty(DEFAULT_KEY_BROKER_NAME);
0:                 System.out.println("Stopping broker: " + brokerName);
0:                 try {
0:                     server.invoke(broker, "terminateJVM", new Object[] {new Integer(0)}, new String[] {"int"});
0:                     System.out.println("Succesfully stopped broker: " + brokerName);
0:                 } catch (Exception e) {
0:                     // TODO: Check exceptions throwned
0:                     //System.out.println("Failed to stop broker: [ " + brokerName + " ]. Reason: " + e.getMessage());
0:                 }
0:             }
0:             System.out.println("Failed to execute stop task. Reason: " + e);
0:     public Set queryMBeans(MBeanServerConnection server, List queryList) throws Exception {
0:         Set mbeans;
0: 
0:         // If there is no query defined get all mbeans
0:         if (queryList==null || queryList.size()==0) {
0:             ObjectName queryName = new ObjectName(DEFAULT_JMX_DOMAIN + ":*");
0: 
0:             mbeans = server.queryMBeans(queryName, null);
0: 
0:         // Construct the object name based on the query
0:         } else {
0:             mbeans = new HashSet();
0: 
0:             for (Iterator i=queryList.iterator(); i.hasNext();) {
0:                 String queryStr = (String)i.next();
0: 
0:                 // Transform string to support regex filtering
0:                 List regexProp = new ArrayList();
0:                 queryStr = createSimpleRegExQuery(queryStr, regexProp);
0: 
0:                 ObjectName queryName = new ObjectName(DEFAULT_JMX_DOMAIN + ":" + queryStr);
0:                 mbeans.addAll(filterUsingRegEx(server.queryMBeans(queryName, null), regexProp));
0:             }
0:         }
0: 
0:         return mbeans;
0:     }
0: 
0:     public Map queryMBeanAttrs(MBeanServerConnection server, ObjectName mbeanObjName, List attrView) throws Exception {
0:         Map attr = new HashMap();
0:         MBeanAttributeInfo[] attrs = server.getMBeanInfo(mbeanObjName).getAttributes();
0: 
0:         // If the mbean has no attribute, print a no attribute message
0:         if (attrs.length == 0) {
0:             return null;
0:         }
0: 
0:         // If there is no view specified, get all attributes
0:         if (attrView == null || attrView.isEmpty()) {
0:             for (int i=0; i<attrs.length; i++) {
0:                 Object attrVal = server.getAttribute(mbeanObjName, attrs[i].getName());
0:                 attr.put(attrs[i].getName(), attrVal);
0:             }
0:             return attr;
0:         }
0: 
0:         // Get attributes specified by view
0:         for (int i=0; i<attrs.length; i++) {
0:             if (attrView.contains(attrs[i].getName())) {
0:                 Object attrVal = server.getAttribute(mbeanObjName, attrs[i].getName());
0:                 attr.put(attrs[i].getName(), attrVal);
0:             }
0:         }
0: 
0:         return attr;
0:     }
0: 
0:     protected String createQueryString(String query, String param) {
0:         return query.replaceAll("%1", param);
0:     }
0: 
0:     protected String createQueryString(String query, List params) {
0: 
0:         int count = 1;
0:         for (Iterator i=params.iterator();i.hasNext();) {
0:             query.replaceAll("%" + count++, i.next().toString());
0:         }
0: 
0:         return query;
0:     }
0: 
0:     protected String createSimpleRegExQuery(String query, List regExMap) throws Exception {
0:         if (regExMap==null) {
0:             regExMap = new ArrayList();
0:         }
0: 
0:         StringBuffer newQueryStr = new StringBuffer();
0: 
0:         for (StringTokenizer tokenizer = new StringTokenizer(query, ","); tokenizer.hasMoreTokens();) {
0:             String token = tokenizer.nextToken();
0: 
0:             // Get key value pair
0:             String key = token;
0:             String value = "";
0:             int pos = key.indexOf("=");
0:             if (pos >= 0) {
0:                 value = key.substring(pos + 1);
0:                 key = key.substring(0, pos);
0:             }
0: 
0:             // Check if value is a wildcard query
0:             if ((value.indexOf("*") >= 0) || (value.indexOf("?") >= 0)) {
0:                 // If value is a wildcard query, convert to regex
0:                 // and remove the object name query to ensure it selects all
0:                 regExMap.add(Pattern.compile("(.*)(" + key + "=)(" + transformWildcardQueryToRegEx(value) + ")(,)(.*)"));
0: 
0:             // Re-add valid key value pair. Remove all * property and just add one at the end.
0:             } else if ((key != "") && (value != "")) {
0:                 newQueryStr.append(key + "=" + value + ",");
0:             }
0:         }
0: 
0:         newQueryStr.append("*");
0:         return newQueryStr.toString();
0:     }
0: 
0:     protected String transformWildcardQueryToRegEx(String query) {
0:         query = query.replaceAll("[.]", "\\\\."); // Escape all dot characters. From (.) to (\.)
0:         query = query.replaceAll("[?]", ".");
0:         query = query.replaceAll("[*]", ".*?"); // Use reluctant quantifier
0: 
0:         return query;
0:     }
0: 
0:     protected Set filterUsingRegEx(Set mbeans, List regexProp) {
0:         // No regular expressions filtering needed
0:         if (regexProp==null || regexProp.isEmpty()) {
0:             return mbeans;
0:         }
0: 
0:         Set filteredMbeans = new HashSet();
0: 
0:         // Get each bean to filter
0:         for (Iterator i=mbeans.iterator(); i.hasNext();) {
0:             ObjectInstance mbeanInstance = (ObjectInstance)i.next();
0:             String mbeanName = mbeanInstance.getObjectName().getKeyPropertyListString();
0: 
0:             // Ensure name ends with ,* to guarantee correct parsing behavior
0:             if (!mbeanName.endsWith(",*")) {
0:                 mbeanName = mbeanName + ",*";
0:             }
0:             boolean match = true;
0: 
0:             // Match the object name to each regex
0:             for (Iterator j=regexProp.iterator(); j.hasNext();) {
0:                 Pattern p = (Pattern)j.next();
0: 
0:                 if (!p.matcher(mbeanName).matches()) {
0:                     match = false;
0:                     break;
0:                 }
0:             }
0: 
0:             // If name of mbean matches all regex pattern, add it
0:             if (match) {
0:                 filteredMbeans.add(mbeanInstance);
0:             }
0:         }
0: 
0:         return filteredMbeans;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     public void printMBeanProp(ObjectInstance mbean, List propView) {
0:         // Filter properties to print
0:         if (propView != null && !propView.isEmpty()) {
0:             Map mbeanProps = mbean.getObjectName().getKeyPropertyList();
0:             for (Iterator i=propView.iterator(); i.hasNext();) {
0:                 Object key = i.next();
0:                 Object val = mbeanProps.get(key);
0: 
0:                 if (val != null) {
0:                     System.out.println("MBean " + key + ": " + val);
0:                 }
0:             }
0: 
0:         // Print all properties
0:         } else {
0:             Map mbeanProps = mbean.getObjectName().getKeyPropertyList();
0:             for (Iterator i=mbeanProps.keySet().iterator(); i.hasNext();) {
0:                 Object key = i.next();
0:                 Object val = mbeanProps.get(key);
0: 
0:                 System.out.println("MBean " + key + ": " + val);
0:             }
0:         }
0:     }
0: 
0:             Map attrList = queryMBeanAttrs(server, mbean.getObjectName(), attrView);
0:             // If the mbean has no attribute, print a no attribute message
0:             if (attrList == null) {
0:             // If the mbean's attributes did not match any of the view, display a message
0:             if (attrList.isEmpty()) {
0:                 System.out.println("    View did not match any of the mbean's attributes.");
0:                 System.out.println("");
0:             // Display mbean attributes
0: 
0:             // If attrView is available, use it. This allows control over the display order
0:             if (attrView != null && !attrView.isEmpty()) {
0:                 for (Iterator i=attrView.iterator(); i.hasNext();) {
0:                     Object key = i.next();
0:                     Object val = attrList.get(key);
0: 
0:                     if (val != null) {
0:                         System.out.println("    " + key + " = " + attrList.get(key));
0:                     }
0:                 }
0: 
0:             // If attrView is not available, print all attributes
0:             } else {
0:                 for (Iterator i=attrList.keySet().iterator(); i.hasNext();) {
0:                     Object key = i.next();
0:                     System.out.println("    " + key + " = " + attrList.get(key));
0:             System.out.println("");
0:             
/////////////////////////////////////////////////////////////////////////
0:     public boolean isPrintVersion() {
0:         return printVer;
0:     }
0: 
0:     public boolean isPrintHelp() {
0:         return printHelp;
0:     }
0: 
0:     public List getAddQueryObjects() {
0:         return queryAddObjects;
0:     }
0: 
0:     public List getSubQueryObjects() {
0:         return querySubObjects;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             "    query        - Display selected broker component's attributes and statistics.",
/////////////////////////////////////////////////////////////////////////
0:             "Description: Creates and starts a broker using a configuration file, or a broker URI.",
/////////////////////////////////////////////////////////////////////////
0:             "Description: Stops a running broker.",
/////////////////////////////////////////////////////////////////////////
0:             "Description:  Lists all available broker in the specified JMX context.",
/////////////////////////////////////////////////////////////////////////
0:             "Description: Display selected broker component's attributes and statistics.",
0:             "    -Q<type>=<name>               Add to the search list the specific object type matched by the defined object identifier.",
0:             "    -Q!<type>=<name>              Remove from the search list the specific object type matched by the object identifier.",
0:             "    --objname <query>             Add to the search list objects matched by the query similar to the JMX object name format.",
0:             "    --objname !<query>            Remove from the search list objects matched by the query similar to the JMX object name format.",
/////////////////////////////////////////////////////////////////////////
0:             "",
0:             "    Main -QTopic=* -Q!Topic=ActiveMQ.Advisory.*",
0:             "        - Print all attributes of all topics except those that has a name that begins with \"ActiveMQ.Advisory\".",
0:             "",
0:             "    Main --objname Type=*Connect*,BrokerName=local* -Q!NetworkConnector=*",
0:             "        - Print all attributes of all connectors, connections excluding network connectors that belongs to the broker that begins with local.",
0:             "",
0:             "    Main -QQueue=* -Q!Queue=????",
0:             "        - Print all attributes of all queues except those that are 4 letters long.",
0:             "",
commit:6cbd6d2
/////////////////////////////////////////////////////////////////////////
0:             brokers.add(broker);
/////////////////////////////////////////////////////////////////////////
commit:b70c8d1
/////////////////////////////////////////////////////////////////////////
0:     private final List brokers      = new ArrayList();
0:     private final List extensions   = new ArrayList();
0:     private final Map  queryObjects = new HashMap();
0:     private final List queryViews   = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0:         
0:         waitForShutdown();
/////////////////////////////////////////////////////////////////////////
0:     public void waitForShutdown() throws Throwable {
0:         // Prevent the main thread from exiting, in case this is the last user thread
0:         final boolean[] shutdown = new boolean[]{false};
0:         Runtime.getRuntime().addShutdownHook(new Thread() {
0:             public void run() {
0:                 synchronized(shutdown) {
0:                     shutdown[0]=true;
0:                     shutdown.notify();
0:                 }
0:             }
0:         });
0:         synchronized(shutdown) {
0:             while( !shutdown[0] ) {
0:                 shutdown.wait();
0:             }
0:         }
0: 
0:         // Use reflection to stop the broker in case, the vm was exited via unconventional means
0:         try {
0:             for (Iterator i=brokers.iterator(); i.hasNext();) {
0:                 Object broker = i.next();
0:                 Method stop = broker.getClass().getMethod("stop", new Class[] {});
0:                 stop.invoke(broker, new Object[] {});
0:             }
0:         } catch (InvocationTargetException e) {
0:             throw e.getCause();
0:         } catch (Throwable e) {
0:             throw e;
0:         }
0:     }
0: 
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:3a59e68
/////////////////////////////////////////////////////////////////////////
0:                         System.setProperty("activemq.home",activeMQHome.getAbsolutePath());
/////////////////////////////////////////////////////////////////////////
0:                 System.setProperty("activemq.home",activeMQHome.getAbsolutePath());
author:Dennis Cook
-------------------------------------------------------------------------------
commit:f9a7635
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         int tokencnt = tokens.size();
0:         String token = (String) tokens.remove(0);
0: 
0:         for (int processedcnt = 0; processedcnt < tokencnt; processedcnt++)
0:                 if (!tokens.isEmpty()) {
0:                     token = (String) tokens.remove(0);
0:                     if (token.startsWith("-"))
0:                     {
0:                         System.out.println("Extension directory not specified.");
0:                         System.out.println("Ignoring extension directory option.");
0:                         continue;
0:                     }
0:                 } else
0:                 {
0:                     break;
0:                 // Process token
0:                 processedcnt++;
0:                 
0:                 } else
0:                 {
0:                     // Process extension dir token
0:                     File extDir = new File(token);
0:                     if (!extDir.isDirectory()) {
0:                         System.out.println("Extension directory specified is not valid directory: " + extDir);
0:                         System.out.println("Ignoring extension directory option.");
0:                         continue;
0:                     }
0:                     addExtensionDirectory(extDir);
0:                 }
0:                 System.out.println("Bypassing default ext add.");
1:                 useDefExt = false;
0:             if (!tokens.isEmpty()) token = (String) tokens.remove(0);
/////////////////////////////////////////////////////////////////////////
0:                     try{ System.out.println("Adding to classpath: " + dir.getCanonicalPath()); }catch(Exception e){}
0:                                 try{ System.out.println("Adding to classpath: " + files[j].getCanonicalPath()); }catch(Exception e){}
commit:d3aa9bf
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < tokens.size(); i++)
0:         {
0:             String token = (String)tokens.get(i);
0:             // If token is an extension dir option
0:             if (token.equals("--extdir")) {
0:                 // Process token
0:                 tokens.remove(0);
0:                 // If no extension directory is specified, or next token is another option
0:                 if (tokens.isEmpty() || ((String)tokens.get(0)).startsWith("-")) {
0:                     System.out.println("Extension directory not specified.");
0:                     System.out.println("Ignoring extension directory option.");
0:                     return;
0:                 }
0:                 // Process extension dir token
0:                 File extDir = new File((String)tokens.remove(0));
0: 
0:                 if(!canUseExtdir()) {
0:                     System.out.println("Extension directory feature not available due to the system classpath being able to load: " + TASK_DEFAULT_CLASS);
0:                     System.out.println("Ignoring extension directory option.");
0:                     return;
0:                 }
0: 
0:                 if (!extDir.isDirectory()) {
0:                     System.out.println("Extension directory specified is not valid directory: " + extDir);
0:                     System.out.println("Ignoring extension directory option.");
0:                     return;
0:                 }
0: 
0:                 addExtensionDirectory(extDir);
0:             } else if (token.equals("--noDefExt")) { // If token is --noDefExt option
0:                     useDefExt = false;
0:             } else
0:             {
0:                 break;
0:         }
commit:4d7ea5e
/////////////////////////////////////////////////////////////////////////
1:     private static boolean useDefExt = true;
0: 
/////////////////////////////////////////////////////////////////////////
0:         if(useDefExt && app.canUseExtdir()) {
/////////////////////////////////////////////////////////////////////////
0:         } else if (token.equals("--noDefExt")) { // If token is --noDefExt option
0:                 useDefExt = false;
0: 		  }
0: 
============================================================================