1:ee55abb: /**
1:ee55abb:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:ee55abb:  * contributor license agreements.  See the NOTICE file distributed with
1:ee55abb:  * this work for additional information regarding copyright ownership.
1:ee55abb:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:ee55abb:  * (the "License"); you may not use this file except in compliance with
1:ee55abb:  * the License.  You may obtain a copy of the License at
1:ee55abb:  *
1:ee55abb:  *      http://www.apache.org/licenses/LICENSE-2.0
1:ee55abb:  *
1:ee55abb:  * Unless required by applicable law or agreed to in writing, software
1:ee55abb:  * distributed under the License is distributed on an "AS IS" BASIS,
1:ee55abb:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ee55abb:  * See the License for the specific language governing permissions and
1:ee55abb:  * limitations under the License.
1:ee55abb:  */
1:ee55abb: package org.apache.activemq.store.kahadb.plist;
1:926fdd7: 
1:0619a87: import org.apache.activemq.broker.BrokerService;
1:0619a87: import org.apache.activemq.broker.BrokerServiceAware;
1:32e63dc: import org.apache.activemq.openwire.OpenWireFormat;
1:d5dd937: import org.apache.activemq.store.JournaledStore;
1:d5dd937: import org.apache.activemq.store.PList;
1:d5dd937: import org.apache.activemq.store.PListStore;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.journal.Journal;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.journal.Location;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Page;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1:d5dd937: import org.apache.activemq.thread.Scheduler;
1:d5dd937: import org.apache.activemq.util.*;
1:32e63dc: import org.apache.activemq.wireformat.WireFormat;
1:0619a87: import org.slf4j.Logger;
1:0619a87: import org.slf4j.LoggerFactory;
16:ee55abb: 
1:d5dd937: import java.io.DataInput;
1:d5dd937: import java.io.DataOutput;
1:d5dd937: import java.io.File;
1:d5dd937: import java.io.IOException;
1:d5dd937: import java.util.*;
1:d5dd937: import java.util.Map.Entry;
1:d5dd937: 
1:cf7a935: /**
1:cf7a935:  * @org.apache.xbean.XBean
1:cf7a935:  */
1:d5dd937: public class PListStoreImpl extends ServiceSupport implements BrokerServiceAware, Runnable, PListStore, JournaledStore {
1:d5dd937:     static final Logger LOG = LoggerFactory.getLogger(PListStoreImpl.class);
1:ee55abb:     private static final int DATABASE_LOCKED_WAIT_DELAY = 10 * 1000;
1:ee55abb: 
1:d71eefc:     static final int CLOSED_STATE = 1;
1:d71eefc:     static final int OPEN_STATE = 2;
1:ee55abb: 
1:ee55abb:     private File directory;
1:5a87481:     private File indexDirectory;
1:ee55abb:     PageFile pageFile;
1:ee55abb:     private Journal journal;
1:ee55abb:     private LockFile lockFile;
1:ee55abb:     private boolean failIfDatabaseIsLocked;
1:ee55abb:     private int journalMaxFileLength = Journal.DEFAULT_MAX_FILE_LENGTH;
1:ee55abb:     private int journalMaxWriteBatchSize = Journal.DEFAULT_MAX_WRITE_BATCH_SIZE;
1:ee55abb:     private boolean enableIndexWriteAsync = false;
1:d71eefc:     private boolean initialized = false;
1:7d082c3:     private boolean lazyInit = true;
1:ee55abb:     // private int indexWriteBatchSize = PageFile.DEFAULT_WRITE_BATCH_SIZE;
1:ee55abb:     MetaData metaData = new MetaData(this);
1:ee55abb:     final MetaDataMarshaller metaDataMarshaller = new MetaDataMarshaller(this);
1:d5dd937:     Map<String, PListImpl> persistentLists = new HashMap<String, PListImpl>();
1:cf7a935:     final Object indexLock = new Object();
1:0619a87:     private Scheduler scheduler;
1:0619a87:     private long cleanupInterval = 30000;
1:cf7a935: 
1:2b10259:     private int indexPageSize = PageFile.DEFAULT_PAGE_SIZE;
1:2b10259:     private int indexCacheSize = PageFile.DEFAULT_PAGE_CACHE_SIZE;
1:2b10259:     private int indexWriteBatchSize = PageFile.DEFAULT_WRITE_BATCH_SIZE;
1:bf59b7d:     private boolean indexEnablePageCaching = true;
1:2b10259: 
1:cf7a935:     public Object getIndexLock() {
1:cf7a935:         return indexLock;
1:cf7a935:     }
1:ee55abb: 
1:a82c95c:     @Override
1:0619a87:     public void setBrokerService(BrokerService brokerService) {
1:0619a87:         this.scheduler = brokerService.getScheduler();
1:0619a87:     }
1:0619a87: 
1:2b10259:     public int getIndexPageSize() {
1:2b10259:         return indexPageSize;
1:2b10259:     }
1:2b10259: 
1:2b10259:     public int getIndexCacheSize() {
1:2b10259:         return indexCacheSize;
1:2b10259:     }
1:2b10259: 
1:2b10259:     public int getIndexWriteBatchSize() {
1:2b10259:         return indexWriteBatchSize;
1:2b10259:     }
1:2b10259: 
1:2b10259:     public void setIndexPageSize(int indexPageSize) {
1:2b10259:         this.indexPageSize = indexPageSize;
1:2b10259:     }
1:2b10259: 
1:2b10259:     public void setIndexCacheSize(int indexCacheSize) {
1:2b10259:         this.indexCacheSize = indexCacheSize;
1:2b10259:     }
1:2b10259: 
1:2b10259:     public void setIndexWriteBatchSize(int indexWriteBatchSize) {
1:2b10259:         this.indexWriteBatchSize = indexWriteBatchSize;
1:2b10259:     }
1:2b10259: 
1:bf59b7d:     public boolean getIndexEnablePageCaching() {
1:bf59b7d:         return indexEnablePageCaching;
1:bf59b7d:     }
1:bf59b7d: 
1:bf59b7d:     public void setIndexEnablePageCaching(boolean indexEnablePageCaching) {
1:bf59b7d:         this.indexEnablePageCaching = indexEnablePageCaching;
1:bf59b7d:     }
1:bf59b7d: 
1:ee55abb:     protected class MetaData {
1:d5dd937:         protected MetaData(PListStoreImpl store) {
1:ee55abb:             this.store = store;
15:ee55abb:         }
1:d71eefc: 
1:d5dd937:         private final PListStoreImpl store;
1:ee55abb:         Page<MetaData> page;
1:d5dd937:         BTreeIndex<String, PListImpl> lists;
1:ee55abb: 
1:ee55abb:         void createIndexes(Transaction tx) throws IOException {
1:d5dd937:             this.lists = new BTreeIndex<String, PListImpl>(pageFile, tx.allocate().getPageId());
1:ee55abb:         }
1:ee55abb: 
1:ee55abb:         void load(Transaction tx) throws IOException {
1:2b10259:             this.lists.setKeyMarshaller(StringMarshaller.INSTANCE);
1:2b10259:             this.lists.setValueMarshaller(new PListMarshaller(this.store));
1:2b10259:             this.lists.load(tx);
1:ee55abb:         }
1:ee55abb: 
1:d5dd937:         void loadLists(Transaction tx, Map<String, PListImpl> lists) throws IOException {
1:d5dd937:             for (Iterator<Entry<String, PListImpl>> i = this.lists.iterator(tx); i.hasNext();) {
1:d5dd937:                 Entry<String, PListImpl> entry = i.next();
1:ee55abb:                 entry.getValue().load(tx);
1:2b10259:                 lists.put(entry.getKey(), entry.getValue());
1:ee55abb:             }
1:ee55abb:         }
1:ee55abb: 
1:ee55abb:         public void read(DataInput is) throws IOException {
1:d5dd937:             this.lists = new BTreeIndex<String, PListImpl>(pageFile, is.readLong());
1:2b10259:             this.lists.setKeyMarshaller(StringMarshaller.INSTANCE);
1:2b10259:             this.lists.setValueMarshaller(new PListMarshaller(this.store));
1:ee55abb:         }
1:ee55abb: 
1:ee55abb:         public void write(DataOutput os) throws IOException {
1:2b10259:             os.writeLong(this.lists.getPageId());
1:ee55abb:         }
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     class MetaDataMarshaller extends VariableMarshaller<MetaData> {
1:d5dd937:         private final PListStoreImpl store;
1:ee55abb: 
1:d5dd937:         MetaDataMarshaller(PListStoreImpl store) {
1:ee55abb:             this.store = store;
1:ee55abb:         }
1:a82c95c:         @Override
1:ee55abb:         public MetaData readPayload(DataInput dataIn) throws IOException {
1:ee55abb:             MetaData rc = new MetaData(this.store);
1:ee55abb:             rc.read(dataIn);
1:ee55abb:             return rc;
1:ee55abb:         }
1:ee55abb: 
1:a82c95c:         @Override
1:ee55abb:         public void writePayload(MetaData object, DataOutput dataOut) throws IOException {
1:ee55abb:             object.write(dataOut);
1:ee55abb:         }
1:ee55abb:     }
1:ee55abb: 
1:d5dd937:     class PListMarshaller extends VariableMarshaller<PListImpl> {
1:d5dd937:         private final PListStoreImpl store;
1:d5dd937:         PListMarshaller(PListStoreImpl store) {
1:ee55abb:             this.store = store;
1:ee55abb:         }
1:a82c95c:         @Override
1:d5dd937:         public PListImpl readPayload(DataInput dataIn) throws IOException {
1:d5dd937:             PListImpl result = new PListImpl(this.store);
1:ee55abb:             result.read(dataIn);
3:ee55abb:             return result;
1:ee55abb:         }
1:ee55abb: 
1:a82c95c:         @Override
1:d5dd937:         public void writePayload(PListImpl list, DataOutput dataOut) throws IOException {
1:2b10259:             list.write(dataOut);
1:ee55abb:         }
1:ee55abb:     }
1:ee55abb: 
1:926fdd7:     public Journal getJournal() {
1:926fdd7:         return this.journal;
1:926fdd7:     }
1:926fdd7: 
1:d5dd937:     @Override
1:ee55abb:     public File getDirectory() {
1:ee55abb:         return directory;
1:ee55abb:     }
1:ee55abb: 
1:d5dd937:     @Override
1:ee55abb:     public void setDirectory(File directory) {
1:ee55abb:         this.directory = directory;
1:ee55abb:     }
1:d71eefc: 
1:5a87481:     public File getIndexDirectory() {
1:5a87481:         return indexDirectory != null ? indexDirectory : directory;
1:5a87481:     }
1:5a87481: 
1:5a87481:     public void setIndexDirectory(File indexDirectory) {
1:5a87481:         this.indexDirectory = indexDirectory;
1:5a87481:     }
1:5a87481: 
1:a82c95c:     @Override
1:ee55abb:     public long size() {
1:128a8f7:         synchronized (this) {
1:a2af47b:             if (!initialized) {
1:a2af47b:                 return 0;
1:a2af47b:             }
1:ee55abb:         }
1:ee55abb:         try {
1:ee55abb:             return journal.getDiskSize() + pageFile.getDiskSize();
1:ee55abb:         } catch (IOException e) {
1:ee55abb:             throw new RuntimeException(e);
1:d8d20f5:         }
1:ee55abb:     }
1:ee55abb: 
1:d5dd937:     @Override
1:d5dd937:     public PListImpl getPList(final String name) throws Exception {
1:d71eefc:         if (!isStarted()) {
1:d71eefc:             throw new IllegalStateException("Not started");
1:d71eefc:         }
1:d71eefc:         intialize();
1:128a8f7:         synchronized (indexLock) {
1:128a8f7:             synchronized (this) {
1:d5dd937:                 PListImpl result = this.persistentLists.get(name);
1:128a8f7:                 if (result == null) {
1:d5dd937:                     final PListImpl pl = new PListImpl(this);
1:128a8f7:                     pl.setName(name);
1:128a8f7:                     getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:a82c95c:                         @Override
1:128a8f7:                         public void execute(Transaction tx) throws IOException {
1:2b10259:                             pl.setHeadPageId(tx.allocate().getPageId());
1:128a8f7:                             pl.load(tx);
1:2b10259:                             metaData.lists.put(tx, name, pl);
1:128a8f7:                         }
1:128a8f7:                     });
1:128a8f7:                     result = pl;
1:128a8f7:                     this.persistentLists.put(name, pl);
1:128a8f7:                 }
1:d5dd937:                 final PListImpl toLoad = result;
1:128a8f7:                 getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:a82c95c:                     @Override
1:128a8f7:                     public void execute(Transaction tx) throws IOException {
1:bf59b7d:                         toLoad.load(tx);
1:128a8f7:                     }
1:128a8f7:                 });
1:d71eefc: 
1:128a8f7:                 return result;
1:128a8f7:             }
1:ee55abb:         }
1:ee55abb:     }
1:ee55abb: 
1:d5dd937:     @Override
1:128a8f7:     public boolean removePList(final String name) throws Exception {
1:ee55abb:         boolean result = false;
1:128a8f7:         synchronized (indexLock) {
1:128a8f7:             synchronized (this) {
1:128a8f7:                 final PList pl = this.persistentLists.remove(name);
1:128a8f7:                 result = pl != null;
1:128a8f7:                 if (result) {
1:128a8f7:                     getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:a82c95c:                         @Override
1:128a8f7:                         public void execute(Transaction tx) throws IOException {
1:2b10259:                             metaData.lists.remove(tx, name);
1:2b10259:                             pl.destroy();
1:128a8f7:                         }
1:128a8f7:                     });
1:128a8f7:                 }
1:ee55abb:             }
1:ee55abb:         }
1:ee55abb:         return result;
1:ee55abb:     }
1:ee55abb: 
1:d71eefc:     protected synchronized void intialize() throws Exception {
1:d71eefc:         if (isStarted()) {
1:d71eefc:             if (this.initialized == false) {
1:d71eefc:                 if (this.directory == null) {
1:a82c95c:                     this.directory = getDefaultDirectory();
1:d71eefc:                 }
1:d71eefc:                 IOHelper.mkdirs(this.directory);
1:768fa17:                 IOHelper.deleteChildren(this.directory);
1:5a87481:                 if (this.indexDirectory != null) {
1:5a87481:                     IOHelper.mkdirs(this.indexDirectory);
1:5a87481:                     IOHelper.deleteChildren(this.indexDirectory);
1:5a87481:                 }
1:d71eefc:                 lock();
1:d71eefc:                 this.journal = new Journal();
1:d71eefc:                 this.journal.setDirectory(directory);
1:d71eefc:                 this.journal.setMaxFileLength(getJournalMaxFileLength());
1:d71eefc:                 this.journal.setWriteBatchSize(getJournalMaxWriteBatchSize());
1:d71eefc:                 this.journal.start();
1:5a87481:                 this.pageFile = new PageFile(getIndexDirectory(), "tmpDB");
1:bf59b7d:                 this.pageFile.setEnablePageCaching(getIndexEnablePageCaching());
1:2b10259:                 this.pageFile.setPageSize(getIndexPageSize());
1:2b10259:                 this.pageFile.setWriteBatchSize(getIndexWriteBatchSize());
1:2b10259:                 this.pageFile.setPageCacheSize(getIndexCacheSize());
1:d71eefc:                 this.pageFile.load();
1:d71eefc: 
1:d71eefc:                 this.pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:a82c95c:                     @Override
1:d71eefc:                     public void execute(Transaction tx) throws IOException {
1:d71eefc:                         if (pageFile.getPageCount() == 0) {
1:d71eefc:                             Page<MetaData> page = tx.allocate();
1:d71eefc:                             assert page.getPageId() == 0;
1:d71eefc:                             page.set(metaData);
1:d71eefc:                             metaData.page = page;
1:d71eefc:                             metaData.createIndexes(tx);
1:d71eefc:                             tx.store(metaData.page, metaDataMarshaller, true);
1:d71eefc: 
1:f24edca:                         } else {
1:d71eefc:                             Page<MetaData> page = tx.load(0, metaDataMarshaller);
1:d71eefc:                             metaData = page.get();
1:d71eefc:                             metaData.page = page;
1:f24edca:                         }
1:d71eefc:                         metaData.load(tx);
1:d71eefc:                         metaData.loadLists(tx, persistentLists);
1:d71eefc:                     }
1:d71eefc:                 });
1:d71eefc:                 this.pageFile.flush();
1:0619a87: 
1:0619a87:                 if (cleanupInterval > 0) {
1:0619a87:                     if (scheduler == null) {
1:d5dd937:                         scheduler = new Scheduler(PListStoreImpl.class.getSimpleName());
1:0619a87:                         scheduler.start();
1:0619a87:                     }
1:0619a87:                     scheduler.executePeriodically(this, cleanupInterval);
1:0619a87:                 }
1:4a697f8:                 this.initialized = true;
1:d71eefc:                 LOG.info(this + " initialized");
1:d71eefc:             }
1:d71eefc:         }
1:d71eefc:     }
1:d71eefc: 
1:a82c95c:     protected File getDefaultDirectory() {
1:a82c95c:         return new File(IOHelper.getDefaultDataDirectory() + File.pathSeparator + "delayedDB");
1:a82c95c:     }
1:a82c95c: 
1:a82c95c:     protected void cleanupDirectory(final File dir) {
1:a82c95c:         if (dir != null && dir.exists()) {
1:a82c95c:             IOHelper.delete(dir);
1:a82c95c:         }
1:a82c95c:     }
1:a82c95c: 
1:0619a87:     @Override
1:ee55abb:     protected synchronized void doStart() throws Exception {
1:7d082c3:         if (!lazyInit) {
1:7d082c3:             intialize();
1:a82c95c:         } else {
1:a82c95c:             if (this.directory == null) {
1:a82c95c:                 this.directory = getDefaultDirectory();
1:a82c95c:             }
1:a82c95c:             //Go ahead and clean up previous data on start up
1:a82c95c:             cleanupDirectory(this.directory);
1:a82c95c:             cleanupDirectory(this.indexDirectory);
1:7d082c3:         }
1:ee55abb:         LOG.info(this + " started");
1:d71eefc:     }
1:d71eefc: 
1:ee55abb:     @Override
1:ee55abb:     protected synchronized void doStop(ServiceStopper stopper) throws Exception {
1:0619a87:         if (scheduler != null) {
1:d5dd937:             if (PListStoreImpl.class.getSimpleName().equals(scheduler.getName())) {
1:0619a87:                 scheduler.stop();
1:0619a87:                 scheduler = null;
1:0619a87:             }
1:0619a87:         }
1:d5dd937:         for (PListImpl pl : this.persistentLists.values()) {
1:2b10259:             pl.unload(null);
1:ee55abb:         }
1:ee55abb:         if (this.pageFile != null) {
1:ee55abb:             this.pageFile.unload();
1:ee55abb:         }
1:ee55abb:         if (this.journal != null) {
1:ee55abb:             journal.close();
1:ee55abb:         }
1:ee55abb:         if (this.lockFile != null) {
1:ee55abb:             this.lockFile.unlock();
1:ee55abb:         }
1:ee55abb:         this.lockFile = null;
1:d71eefc:         this.initialized = false;
1:ee55abb:         LOG.info(this + " stopped");
1:d71eefc: 
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     @Override
1:0619a87:     public void run() {
1:0619a87:         try {
1:926fdd7:             if (isStopping()) {
1:d8d20f5:                 return;
1:926fdd7:             }
1:bf59b7d:             final int lastJournalFileId = journal.getLastAppendLocation().getDataFileId();
1:0619a87:             final Set<Integer> candidates = journal.getFileMap().keySet();
1:0619a87:             LOG.trace("Full gc candidate set:" + candidates);
1:128a8f7:             if (candidates.size() > 1) {
1:bf59b7d:                 // prune current write
1:bf59b7d:                 for (Iterator<Integer> iterator = candidates.iterator(); iterator.hasNext();) {
1:bf59b7d:                     if (iterator.next() >= lastJournalFileId) {
1:bf59b7d:                         iterator.remove();
1:bf59b7d:                     }
1:bf59b7d:                 }
1:d5dd937:                 List<PListImpl> plists = null;
1:bf59b7d:                 synchronized (indexLock) {
1:bf59b7d:                     synchronized (this) {
1:d5dd937:                         plists = new ArrayList<PListImpl>(persistentLists.values());
1:bf59b7d:                     }
1:0619a87:                 }
1:d5dd937:                 for (PListImpl list : plists) {
1:128a8f7:                     list.claimFileLocations(candidates);
1:d8d20f5:                     if (isStopping()) {
1:128a8f7:                         return;
1:128a8f7:                     }
1:128a8f7:                     LOG.trace("Remaining gc candidate set after refs from: " + list.getName() + ":" + candidates);
1:128a8f7:                 }
1:128a8f7:                 LOG.trace("GC Candidate set:" + candidates);
1:128a8f7:                 this.journal.removeDataFiles(candidates);
1:0619a87:             }
1:0619a87:         } catch (IOException e) {
1:0619a87:             LOG.error("Exception on periodic cleanup: " + e, e);
1:0619a87:         }
1:ee55abb:     }
1:ee55abb: 
1:2b10259:     ByteSequence getPayload(Location location) throws IllegalStateException, IOException {
1:ee55abb:         ByteSequence result = null;
1:ee55abb:         result = this.journal.read(location);
1:ee55abb:         return result;
1:ee55abb:     }
1:ee55abb: 
1:2b10259:     Location write(ByteSequence payload, boolean sync) throws IllegalStateException, IOException {
1:ee55abb:         return this.journal.write(payload, sync);
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     private void lock() throws IOException {
1:ee55abb:         if (lockFile == null) {
1:ee55abb:             File lockFileName = new File(directory, "lock");
1:ee55abb:             lockFile = new LockFile(lockFileName, true);
1:ee55abb:             if (failIfDatabaseIsLocked) {
1:ee55abb:                 lockFile.lock();
1:d71eefc:             } else {
1:ee55abb:                 while (true) {
1:ee55abb:                     try {
1:ee55abb:                         lockFile.lock();
1:ee55abb:                         break;
1:ee55abb:                     } catch (IOException e) {
1:ee55abb:                         LOG.info("Database " + lockFileName + " is locked... waiting "
1:ee55abb:                                 + (DATABASE_LOCKED_WAIT_DELAY / 1000)
1:ee55abb:                                 + " seconds for the database to be unlocked. Reason: " + e);
1:ee55abb:                         try {
1:ee55abb:                             Thread.sleep(DATABASE_LOCKED_WAIT_DELAY);
1:ee55abb:                         } catch (InterruptedException e1) {
1:ee55abb:                         }
1:ee55abb:                     }
1:ee55abb:                 }
1:ee55abb:             }
1:ee55abb:         }
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     PageFile getPageFile() {
1:ee55abb:         this.pageFile.isLoaded();
1:ee55abb:         return this.pageFile;
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     public boolean isFailIfDatabaseIsLocked() {
1:ee55abb:         return failIfDatabaseIsLocked;
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     public void setFailIfDatabaseIsLocked(boolean failIfDatabaseIsLocked) {
1:ee55abb:         this.failIfDatabaseIsLocked = failIfDatabaseIsLocked;
1:ee55abb:     }
1:ee55abb: 
1:a82c95c:     @Override
1:ee55abb:     public int getJournalMaxFileLength() {
1:ee55abb:         return journalMaxFileLength;
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     public void setJournalMaxFileLength(int journalMaxFileLength) {
1:ee55abb:         this.journalMaxFileLength = journalMaxFileLength;
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     public int getJournalMaxWriteBatchSize() {
1:ee55abb:         return journalMaxWriteBatchSize;
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     public void setJournalMaxWriteBatchSize(int journalMaxWriteBatchSize) {
1:ee55abb:         this.journalMaxWriteBatchSize = journalMaxWriteBatchSize;
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     public boolean isEnableIndexWriteAsync() {
1:ee55abb:         return enableIndexWriteAsync;
1:ee55abb:     }
1:ee55abb: 
1:ee55abb:     public void setEnableIndexWriteAsync(boolean enableIndexWriteAsync) {
1:ee55abb:         this.enableIndexWriteAsync = enableIndexWriteAsync;
1:ee55abb:     }
1:ee55abb: 
1:0619a87:     public long getCleanupInterval() {
1:0619a87:         return cleanupInterval;
1:0619a87:     }
1:0619a87: 
1:0619a87:     public void setCleanupInterval(long cleanupInterval) {
1:0619a87:         this.cleanupInterval = cleanupInterval;
1:0619a87:     }
1:0619a87: 
1:7d082c3:     public boolean isLazyInit() {
1:7d082c3:         return lazyInit;
1:7d082c3:     }
1:7d082c3: 
1:7d082c3:     public void setLazyInit(boolean lazyInit) {
1:7d082c3:         this.lazyInit = lazyInit;
1:7d082c3:     }
1:7d082c3: 
1:ee55abb:     @Override
1:ee55abb:     public String toString() {
1:2b10259:         String path = getDirectory() != null ? getDirectory().getAbsolutePath() : "DIRECTORY_NOT_SET";
1:5a87481:         if (indexDirectory != null) {
1:5a87481:             path += "|" + indexDirectory.getAbsolutePath();
1:5a87481:         }
1:5bf13b0:         return "PListStore:[" + path + "]";
1:ee55abb:     }
1:ee55abb: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:a82c95c
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                         @Override
/////////////////////////////////////////////////////////////////////////
1:                     this.directory = getDefaultDirectory();
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     protected File getDefaultDirectory() {
1:         return new File(IOHelper.getDefaultDataDirectory() + File.pathSeparator + "delayedDB");
1:     }
1: 
1:     protected void cleanupDirectory(final File dir) {
1:         if (dir != null && dir.exists()) {
1:             IOHelper.delete(dir);
1:         }
1:     }
1: 
1:         } else {
1:             if (this.directory == null) {
1:                 this.directory = getDefaultDirectory();
1:             }
1:             //Go ahead and clean up previous data on start up
1:             cleanupDirectory(this.directory);
1:             cleanupDirectory(this.indexDirectory);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:gtully
-------------------------------------------------------------------------------
commit:5a87481
/////////////////////////////////////////////////////////////////////////
1:     private File indexDirectory;
/////////////////////////////////////////////////////////////////////////
1:     public File getIndexDirectory() {
1:         return indexDirectory != null ? indexDirectory : directory;
1:     }
1: 
1:     public void setIndexDirectory(File indexDirectory) {
1:         this.indexDirectory = indexDirectory;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (this.indexDirectory != null) {
1:                     IOHelper.mkdirs(this.indexDirectory);
1:                     IOHelper.deleteChildren(this.indexDirectory);
1:                 }
1:                 this.pageFile = new PageFile(getIndexDirectory(), "tmpDB");
/////////////////////////////////////////////////////////////////////////
1:         if (indexDirectory != null) {
1:             path += "|" + indexDirectory.getAbsolutePath();
1:         }
commit:768fa17
/////////////////////////////////////////////////////////////////////////
1:                 IOHelper.deleteChildren(this.directory);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:32e63dc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.openwire.OpenWireFormat;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.wireformat.WireFormat;
commit:c5cf038
commit:d5dd937
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.JournaledStore;
1: import org.apache.activemq.store.PList;
1: import org.apache.activemq.store.PListStore;
1: import org.apache.activemq.thread.Scheduler;
1: import org.apache.activemq.util.*;
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.*;
1: import java.util.Map.Entry;
1: 
1: public class PListStoreImpl extends ServiceSupport implements BrokerServiceAware, Runnable, PListStore, JournaledStore {
1:     static final Logger LOG = LoggerFactory.getLogger(PListStoreImpl.class);
/////////////////////////////////////////////////////////////////////////
1:     Map<String, PListImpl> persistentLists = new HashMap<String, PListImpl>();
/////////////////////////////////////////////////////////////////////////
1:         protected MetaData(PListStoreImpl store) {
1:         private final PListStoreImpl store;
1:         BTreeIndex<String, PListImpl> lists;
1:             this.lists = new BTreeIndex<String, PListImpl>(pageFile, tx.allocate().getPageId());
/////////////////////////////////////////////////////////////////////////
1:         void loadLists(Transaction tx, Map<String, PListImpl> lists) throws IOException {
1:             for (Iterator<Entry<String, PListImpl>> i = this.lists.iterator(tx); i.hasNext();) {
1:                 Entry<String, PListImpl> entry = i.next();
1:             this.lists = new BTreeIndex<String, PListImpl>(pageFile, is.readLong());
/////////////////////////////////////////////////////////////////////////
1:         private final PListStoreImpl store;
1:         MetaDataMarshaller(PListStoreImpl store) {
/////////////////////////////////////////////////////////////////////////
1:     class PListMarshaller extends VariableMarshaller<PListImpl> {
1:         private final PListStoreImpl store;
1:         PListMarshaller(PListStoreImpl store) {
1:         public PListImpl readPayload(DataInput dataIn) throws IOException {
1:             PListImpl result = new PListImpl(this.store);
1:         public void writePayload(PListImpl list, DataOutput dataOut) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public PListImpl getPList(final String name) throws Exception {
1:                 PListImpl result = this.persistentLists.get(name);
1:                     final PListImpl pl = new PListImpl(this);
/////////////////////////////////////////////////////////////////////////
1:                 final PListImpl toLoad = result;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                         scheduler = new Scheduler(PListStoreImpl.class.getSimpleName());
/////////////////////////////////////////////////////////////////////////
1:             if (PListStoreImpl.class.getSimpleName().equals(scheduler.getName())) {
1:         for (PListImpl pl : this.persistentLists.values()) {
/////////////////////////////////////////////////////////////////////////
1:                 List<PListImpl> plists = null;
1:                         plists = new ArrayList<PListImpl>(persistentLists.values());
1:                 for (PListImpl list : plists) {
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;
1: import org.apache.activemq.store.kahadb.disk.journal.Journal;
1: import org.apache.activemq.store.kahadb.disk.journal.Location;
1: import org.apache.activemq.store.kahadb.disk.page.Page;
1: import org.apache.activemq.store.kahadb.disk.page.PageFile;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
0: import org.apache.activemq.util.ByteSequence;
0: import org.apache.activemq.util.LockFile;
1: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:5bf13b0
/////////////////////////////////////////////////////////////////////////
1:         return "PListStore:[" + path + "]";
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:926fdd7
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Journal getJournal() {
1:         return this.journal;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (isStopping()) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:                         plists = new ArrayList<PList>(persistentLists.values());
/////////////////////////////////////////////////////////////////////////
author:Gary Tully
-------------------------------------------------------------------------------
commit:7d082c3
/////////////////////////////////////////////////////////////////////////
1:     private boolean lazyInit = true;
/////////////////////////////////////////////////////////////////////////
1:         if (!lazyInit) {
1:             intialize();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isLazyInit() {
1:         return lazyInit;
1:     }
1: 
1:     public void setLazyInit(boolean lazyInit) {
1:         this.lazyInit = lazyInit;
1:     }
1: 
commit:4a697f8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 this.initialized = true;
commit:d8d20f5
/////////////////////////////////////////////////////////////////////////
1:              if (isStopping()) {
1:                 return;
1:              }
commit:bf59b7d
/////////////////////////////////////////////////////////////////////////
1:     private boolean indexEnablePageCaching = true;
/////////////////////////////////////////////////////////////////////////
1:     public boolean getIndexEnablePageCaching() {
1:         return indexEnablePageCaching;
1:     }
1: 
1:     public void setIndexEnablePageCaching(boolean indexEnablePageCaching) {
1:         this.indexEnablePageCaching = indexEnablePageCaching;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 final PList toLoad = result;
1:                         toLoad.load(tx);
/////////////////////////////////////////////////////////////////////////
1:                 this.pageFile.setEnablePageCaching(getIndexEnablePageCaching());
/////////////////////////////////////////////////////////////////////////
1:             final int lastJournalFileId = journal.getLastAppendLocation().getDataFileId();
1:                 // prune current write
1:                 for (Iterator<Integer> iterator = candidates.iterator(); iterator.hasNext();) {
1:                     if (iterator.next() >= lastJournalFileId) {
1:                         iterator.remove();
1:                     }
1:                 }
1:                 synchronized (indexLock) {
1:                     synchronized (this) {
0:                         plists = new ArrayList(persistentLists.values());
1:                     }
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1:     private int indexPageSize = PageFile.DEFAULT_PAGE_SIZE;
1:     private int indexCacheSize = PageFile.DEFAULT_PAGE_CACHE_SIZE;
1:     private int indexWriteBatchSize = PageFile.DEFAULT_WRITE_BATCH_SIZE;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int getIndexPageSize() {
1:         return indexPageSize;
1:     }
1: 
1:     public int getIndexCacheSize() {
1:         return indexCacheSize;
1:     }
1: 
1:     public int getIndexWriteBatchSize() {
1:         return indexWriteBatchSize;
1:     }
1: 
1:     public void setIndexPageSize(int indexPageSize) {
1:         this.indexPageSize = indexPageSize;
1:     }
1: 
1:     public void setIndexCacheSize(int indexCacheSize) {
1:         this.indexCacheSize = indexCacheSize;
1:     }
1: 
1:     public void setIndexWriteBatchSize(int indexWriteBatchSize) {
1:         this.indexWriteBatchSize = indexWriteBatchSize;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         BTreeIndex<String, PList> lists;
0:             this.lists = new BTreeIndex<String, PList>(pageFile, tx.allocate().getPageId());
1:             this.lists.setKeyMarshaller(StringMarshaller.INSTANCE);
1:             this.lists.setValueMarshaller(new PListMarshaller(this.store));
1:             this.lists.load(tx);
0:         void loadLists(Transaction tx, Map<String, PList> lists) throws IOException {
0:             for (Iterator<Entry<String, PList>> i = this.lists.iterator(tx); i.hasNext();) {
1:                 lists.put(entry.getKey(), entry.getValue());
0:             this.lists = new BTreeIndex<String, PList>(pageFile, is.readLong());
1:             this.lists.setKeyMarshaller(StringMarshaller.INSTANCE);
1:             this.lists.setValueMarshaller(new PListMarshaller(this.store));
1:             os.writeLong(this.lists.getPageId());
/////////////////////////////////////////////////////////////////////////
0:     class PListMarshaller extends VariableMarshaller<PList> {
0:         PListMarshaller(PListStore store) {
/////////////////////////////////////////////////////////////////////////
0:         public void writePayload(PList list, DataOutput dataOut) throws IOException {
1:             list.write(dataOut);
/////////////////////////////////////////////////////////////////////////
1:                             pl.setHeadPageId(tx.allocate().getPageId());
1:                             metaData.lists.put(tx, name, pl);
/////////////////////////////////////////////////////////////////////////
1:                             metaData.lists.remove(tx, name);
1:                             pl.destroy();
/////////////////////////////////////////////////////////////////////////
1:                 this.pageFile.setPageSize(getIndexPageSize());
1:                 this.pageFile.setWriteBatchSize(getIndexWriteBatchSize());
1:                 this.pageFile.setPageCacheSize(getIndexCacheSize());
/////////////////////////////////////////////////////////////////////////
1:             pl.unload(null);
/////////////////////////////////////////////////////////////////////////
1:     ByteSequence getPayload(Location location) throws IllegalStateException, IOException {
1:     Location write(ByteSequence payload, boolean sync) throws IllegalStateException, IOException {
/////////////////////////////////////////////////////////////////////////
1:         String path = getDirectory() != null ? getDirectory().getAbsolutePath() : "DIRECTORY_NOT_SET";
0:         return "PListStore:[" + path + " ]";
commit:128a8f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public PList getPList(final String name) throws Exception {
1:         synchronized (indexLock) {
1:             synchronized (this) {
0:                 PList result = this.persistentLists.get(name);
1:                 if (result == null) {
0:                     final PList pl = new PList(this);
1:                     pl.setName(name);
1:                     getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                         public void execute(Transaction tx) throws IOException {
0:                             pl.setRootId(tx.allocate().getPageId());
1:                             pl.load(tx);
0:                             metaData.storedSchedulers.put(tx, name, pl);
1:                         }
1:                     });
1:                     result = pl;
1:                     this.persistentLists.put(name, pl);
0:                 final PList load = result;
1:                 getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                     public void execute(Transaction tx) throws IOException {
0:                         load.load(tx);
1:                     }
1:                 });
1:                 return result;
1:             }
1:         }
1:     public boolean removePList(final String name) throws Exception {
1:         synchronized (indexLock) {
1:             synchronized (this) {
1:                 final PList pl = this.persistentLists.remove(name);
1:                 result = pl != null;
1:                 if (result) {
1:                     getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                         public void execute(Transaction tx) throws IOException {
0:                             metaData.storedSchedulers.remove(tx, name);
0:                             pl.destroy(tx);
1:                         }
1:                     });
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (candidates.size() > 1) {
0:                 List<PList> plists = null;
1:                 synchronized (this) {
0:                     plists = new ArrayList(persistentLists.values());
0:                 for (PList list : plists) {
1:                     list.claimFileLocations(candidates);
0:                     if (isStopping()) {
1:                         return;
1:                     }
1:                     LOG.trace("Remaining gc candidate set after refs from: " + list.getName() + ":" + candidates);
1:                 }
1:                 LOG.trace("GC Candidate set:" + candidates);
1:                 this.journal.removeDataFiles(candidates);
commit:0619a87
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
0: import java.util.concurrent.TimeUnit;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.BrokerServiceAware;
0: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: public class PListStore extends ServiceSupport implements BrokerServiceAware, Runnable {
/////////////////////////////////////////////////////////////////////////
1:     private Scheduler scheduler;
1:     private long cleanupInterval = 30000;
1:     @Override
1:     public void setBrokerService(BrokerService brokerService) {
1:         this.scheduler = brokerService.getScheduler();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if (cleanupInterval > 0) {
1:                     if (scheduler == null) {
0:                         scheduler = new Scheduler(PListStore.class.getSimpleName());
1:                         scheduler.start();
1:                     }
1:                     scheduler.executePeriodically(this, cleanupInterval);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (scheduler != null) {
0:             if (PListStore.class.getSimpleName().equals(scheduler.getName())) {
1:                 scheduler.stop();
1:                 scheduler = null;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public void run() {
1:         try {
1:             final Set<Integer> candidates = journal.getFileMap().keySet();
1:             LOG.trace("Full gc candidate set:" + candidates);
0:             for (PList list : persistentLists.values()) {
0:                 PListEntry entry = list.getFirst();
0:                 while (entry != null) {
0:                     claimCandidates(entry, candidates);
0:                     entry = list.getNext(entry);
1:                 }
0:                 LOG.trace("Remaining gc candidate set after refs from: " + list.getName() + ":" + candidates);
1:             }
0:             LOG.debug("GC Candidate set:" + candidates);
0:             this.journal.removeDataFiles(candidates);
1:         } catch (IOException e) {
1:             LOG.error("Exception on periodic cleanup: " + e, e);
1:         }
0:     private void claimCandidates(PListEntry entry, Set<Integer> candidates) {
0:         EntryLocation location = entry.getEntry();
0:         if (location != null) {
0:             candidates.remove(location.getLocation().getDataFileId());
/////////////////////////////////////////////////////////////////////////
1:     public long getCleanupInterval() {
1:         return cleanupInterval;
1:     }
1: 
1:     public void setCleanupInterval(long cleanupInterval) {
1:         this.cleanupInterval = cleanupInterval;
1:     }
1: 
commit:cf7a935
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * @org.apache.xbean.XBean
1:  */
/////////////////////////////////////////////////////////////////////////
1:     final Object indexLock = new Object();
1: 
1:     public Object getIndexLock() {
1:         return indexLock;
1:     }
/////////////////////////////////////////////////////////////////////////
0:     synchronized public PList getPList(final String name) throws Exception {
commit:a2af47b
/////////////////////////////////////////////////////////////////////////
0:         synchronized (this) {
1:             if (!initialized) {
1:                 return 0;
1:             }
commit:f24edca
/////////////////////////////////////////////////////////////////////////
0:         if (logId != Location.NOT_SET) {
0:             int refCount = this.metaData.journalRC.get(tx, logId);
0:             refCount--;
0:             if (refCount <= 0) {
0:                 this.metaData.journalRC.remove(tx, logId);
0:                 Set<Integer> set = new HashSet<Integer>();
0:                 set.add(logId);
0:                 this.journal.removeDataFiles(set);
1:             } else {
0:                 this.metaData.journalRC.put(tx, logId, refCount);
1:             }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     static final Logger LOG = LoggerFactory.getLogger(PListStore.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:2643089
/////////////////////////////////////////////////////////////////////////
0:                 this.pageFile = new PageFile(directory, "tmpDB");
commit:d71eefc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     static final int CLOSED_STATE = 1;
1:     static final int OPEN_STATE = 2;
/////////////////////////////////////////////////////////////////////////
1:     private boolean initialized = false;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (!initialized) {
/////////////////////////////////////////////////////////////////////////
1:         if (!isStarted()) {
1:             throw new IllegalStateException("Not started");
1:         }
1:         intialize();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     protected synchronized void intialize() throws Exception {
1:         if (isStarted()) {
1:             if (this.initialized == false) {
0:                 this.initialized = true;
1:                 if (this.directory == null) {
0:                     this.directory = new File(IOHelper.getDefaultDataDirectory() + File.pathSeparator + "delayedDB");
1:                 }
1:                 IOHelper.mkdirs(this.directory);
1:                 lock();
1:                 this.journal = new Journal();
1:                 this.journal.setDirectory(directory);
1:                 this.journal.setMaxFileLength(getJournalMaxFileLength());
1:                 this.journal.setWriteBatchSize(getJournalMaxWriteBatchSize());
1:                 this.journal.start();
0:                 this.pageFile = new PageFile(directory, "scheduleDB");
1:                 this.pageFile.load();
1: 
1:                 this.pageFile.tx().execute(new Transaction.Closure<IOException>() {
1:                     public void execute(Transaction tx) throws IOException {
1:                         if (pageFile.getPageCount() == 0) {
1:                             Page<MetaData> page = tx.allocate();
1:                             assert page.getPageId() == 0;
1:                             page.set(metaData);
1:                             metaData.page = page;
1:                             metaData.createIndexes(tx);
1:                             tx.store(metaData.page, metaDataMarshaller, true);
1: 
1:                         } else {
1:                             Page<MetaData> page = tx.load(0, metaDataMarshaller);
1:                             metaData = page.get();
1:                             metaData.page = page;
1:                         }
1:                         metaData.load(tx);
1:                         metaData.loadLists(tx, persistentLists);
1:                     }
1:                 });
1: 
1:                 this.pageFile.flush();
1:                 LOG.info(this + " initialized");
1:             }
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.initialized = false;
/////////////////////////////////////////////////////////////////////////
0:         return "PListStore:" + this.directory;
commit:ee55abb
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.kahadb.plist;
1: 
0: import java.io.DataInput;
0: import java.io.DataOutput;
0: import java.io.File;
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.HashMap;
0: import java.util.HashSet;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.Map.Entry;
0: import org.apache.activemq.util.IOHelper;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.kahadb.index.BTreeIndex;
0: import org.apache.kahadb.journal.Journal;
0: import org.apache.kahadb.journal.Location;
0: import org.apache.kahadb.page.Page;
0: import org.apache.kahadb.page.PageFile;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.util.ByteSequence;
0: import org.apache.kahadb.util.IntegerMarshaller;
0: import org.apache.kahadb.util.LockFile;
0: import org.apache.kahadb.util.StringMarshaller;
0: import org.apache.kahadb.util.VariableMarshaller;
1: 
0: public class PListStore extends ServiceSupport {
0:     static final Log LOG = LogFactory.getLog(PListStore.class);
1:     private static final int DATABASE_LOCKED_WAIT_DELAY = 10 * 1000;
1: 
0:     public static final int CLOSED_STATE = 1;
0:     public static final int OPEN_STATE = 2;
1: 
1:     private File directory;
1:     PageFile pageFile;
1:     private Journal journal;
1:     private LockFile lockFile;
1:     private boolean failIfDatabaseIsLocked;
1:     private int journalMaxFileLength = Journal.DEFAULT_MAX_FILE_LENGTH;
1:     private int journalMaxWriteBatchSize = Journal.DEFAULT_MAX_WRITE_BATCH_SIZE;
1:     private boolean enableIndexWriteAsync = false;
1:     // private int indexWriteBatchSize = PageFile.DEFAULT_WRITE_BATCH_SIZE;
1:     MetaData metaData = new MetaData(this);
1:     final MetaDataMarshaller metaDataMarshaller = new MetaDataMarshaller(this);
0:     Map<String, PList> persistentLists = new HashMap<String, PList>();
1: 
1:     protected class MetaData {
0:         protected MetaData(PListStore store) {
1:             this.store = store;
0:             LinkedList list = new LinkedList();
1:         }
0:         private final PListStore store;
1:         Page<MetaData> page;
0:         BTreeIndex<Integer, Integer> journalRC;
0:         BTreeIndex<String, PList> storedSchedulers;
1: 
1:         void createIndexes(Transaction tx) throws IOException {
0:             this.storedSchedulers = new BTreeIndex<String, PList>(pageFile, tx.allocate().getPageId());
0:             this.journalRC = new BTreeIndex<Integer, Integer>(pageFile, tx.allocate().getPageId());
1:         }
1: 
1:         void load(Transaction tx) throws IOException {
0:             this.storedSchedulers.setKeyMarshaller(StringMarshaller.INSTANCE);
0:             this.storedSchedulers.setValueMarshaller(new JobSchedulerMarshaller(this.store));
0:             this.storedSchedulers.load(tx);
0:             this.journalRC.setKeyMarshaller(IntegerMarshaller.INSTANCE);
0:             this.journalRC.setValueMarshaller(IntegerMarshaller.INSTANCE);
0:             this.journalRC.load(tx);
1:         }
1: 
0:         void loadLists(Transaction tx, Map<String, PList> schedulers) throws IOException {
0:             for (Iterator<Entry<String, PList>> i = this.storedSchedulers.iterator(tx); i.hasNext();) {
0:                 Entry<String, PList> entry = i.next();
1:                 entry.getValue().load(tx);
0:                 schedulers.put(entry.getKey(), entry.getValue());
1:             }
1:         }
1: 
1:         public void read(DataInput is) throws IOException {
0:             this.storedSchedulers = new BTreeIndex<String, PList>(pageFile, is.readLong());
0:             this.storedSchedulers.setKeyMarshaller(StringMarshaller.INSTANCE);
0:             this.storedSchedulers.setValueMarshaller(new JobSchedulerMarshaller(this.store));
0:             this.journalRC = new BTreeIndex<Integer, Integer>(pageFile, is.readLong());
0:             this.journalRC.setKeyMarshaller(IntegerMarshaller.INSTANCE);
0:             this.journalRC.setValueMarshaller(IntegerMarshaller.INSTANCE);
1:         }
1: 
1:         public void write(DataOutput os) throws IOException {
0:             os.writeLong(this.storedSchedulers.getPageId());
0:             os.writeLong(this.journalRC.getPageId());
1: 
1:         }
1:     }
1: 
1:     class MetaDataMarshaller extends VariableMarshaller<MetaData> {
0:         private final PListStore store;
1: 
0:         MetaDataMarshaller(PListStore store) {
1:             this.store = store;
1:         }
1:         public MetaData readPayload(DataInput dataIn) throws IOException {
1:             MetaData rc = new MetaData(this.store);
1:             rc.read(dataIn);
1:             return rc;
1:         }
1: 
1:         public void writePayload(MetaData object, DataOutput dataOut) throws IOException {
1:             object.write(dataOut);
1:         }
1:     }
1: 
0:     class ValueMarshaller extends VariableMarshaller<List<EntryLocation>> {
0:         public List<EntryLocation> readPayload(DataInput dataIn) throws IOException {
0:             List<EntryLocation> result = new ArrayList<EntryLocation>();
0:             int size = dataIn.readInt();
0:             for (int i = 0; i < size; i++) {
0:                 EntryLocation jobLocation = new EntryLocation();
0:                 jobLocation.readExternal(dataIn);
0:                 result.add(jobLocation);
1:             }
1:             return result;
1:         }
1: 
0:         public void writePayload(List<EntryLocation> value, DataOutput dataOut) throws IOException {
0:             dataOut.writeInt(value.size());
0:             for (EntryLocation jobLocation : value) {
0:                 jobLocation.writeExternal(dataOut);
1:             }
1:         }
1:     }
1: 
0:     class JobSchedulerMarshaller extends VariableMarshaller<PList> {
0:         private final PListStore store;
0:         JobSchedulerMarshaller(PListStore store) {
1:             this.store = store;
1:         }
0:         public PList readPayload(DataInput dataIn) throws IOException {
0:             PList result = new PList(this.store);
1:             result.read(dataIn);
1:             return result;
1:         }
1: 
0:         public void writePayload(PList js, DataOutput dataOut) throws IOException {
0:             js.write(dataOut);
1:         }
1:     }
1: 
1:     public File getDirectory() {
1:         return directory;
1:     }
1: 
1:     public void setDirectory(File directory) {
1:         this.directory = directory;
1:     }
1:     
1:     public long size() {
0:         if ( !isStarted() ) {
0:             return 0;
1:         }
1:         try {
1:             return journal.getDiskSize() + pageFile.getDiskSize();
1:         } catch (IOException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1: 
0:     public PList getPList(final String name) throws Exception {
0:         PList result = this.persistentLists.get(name);
0:         if (result == null) {
0:             final PList pl = new PList(this);
0:             pl.setName(name);
0:             getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:                 public void execute(Transaction tx) throws IOException {
0:                     pl.setRootId(tx.allocate().getPageId());
0:                     pl.load(tx);
0:                     metaData.storedSchedulers.put(tx, name, pl);
1:                 }
0:             });
0:             result = pl;
0:             this.persistentLists.put(name, pl);
1:         }
0:         final PList load = result;
0:         getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 load.load(tx);
1:             }
0:         });
1:        
1:         return result;
1:     }
1: 
0:     synchronized public boolean removePList(final String name) throws Exception {
1:         boolean result = false;
0:         final PList pl = this.persistentLists.remove(name);
0:         result = pl != null;
0:         if (result) {
0:             getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:                 public void execute(Transaction tx) throws IOException {
0:                     metaData.storedSchedulers.remove(tx, name);
0:                     pl.destroy(tx);
1:                 }
0:             });
1:         }
1:         return result;
1:     }
1: 
1:     @Override
1:     protected synchronized void doStart() throws Exception {
0:         if (this.directory == null) {
0:             this.directory = new File(IOHelper.getDefaultDataDirectory() + File.pathSeparator + "delayedDB");
1:         }
0:         IOHelper.mkdirs(this.directory);
0:         lock();
0:         this.journal = new Journal();
0:         this.journal.setDirectory(directory);
0:         this.journal.setMaxFileLength(getJournalMaxFileLength());
0:         this.journal.setWriteBatchSize(getJournalMaxWriteBatchSize());
0:         this.journal.start();
0:         this.pageFile = new PageFile(directory, "scheduleDB");
0:         this.pageFile.load();
1: 
0:         this.pageFile.tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 if (pageFile.getPageCount() == 0) {
0:                     Page<MetaData> page = tx.allocate();
0:                     assert page.getPageId() == 0;
0:                     page.set(metaData);
0:                     metaData.page = page;
0:                     metaData.createIndexes(tx);
0:                     tx.store(metaData.page, metaDataMarshaller, true);
1: 
0:                 } else {
0:                     Page<MetaData> page = tx.load(0, metaDataMarshaller);
0:                     metaData = page.get();
0:                     metaData.page = page;
1:                 }
0:                 metaData.load(tx);
0:                 metaData.loadLists(tx, persistentLists);
1:             }
0:         });
1: 
0:         this.pageFile.flush();
1:         LOG.info(this + " started");
1:     }
1:     
1:     @Override
1:     protected synchronized void doStop(ServiceStopper stopper) throws Exception {
0:         for (PList pl : this.persistentLists.values()) {
0:             pl.unload();
1:         }
1:         if (this.pageFile != null) {
1:             this.pageFile.unload();
1:         }
1:         if (this.journal != null) {
1:             journal.close();
1:         }
1:         if (this.lockFile != null) {
1:             this.lockFile.unlock();
1:         }
1:         this.lockFile = null;
1:         LOG.info(this + " stopped");
1: 
1:     }
1: 
0:     synchronized void incrementJournalCount(Transaction tx, Location location) throws IOException {
0:         int logId = location.getDataFileId();
0:         Integer val = this.metaData.journalRC.get(tx, logId);
0:         int refCount = val != null ? val.intValue() + 1 : 1;
0:         this.metaData.journalRC.put(tx, logId, refCount);
1: 
1:     }
1: 
0:     synchronized void decrementJournalCount(Transaction tx, Location location) throws IOException {
0:         int logId = location.getDataFileId();
0:         int refCount = this.metaData.journalRC.get(tx, logId);
0:         refCount--;
0:         if (refCount <= 0) {
0:             this.metaData.journalRC.remove(tx, logId);
0:             Set<Integer> set = new HashSet<Integer>();
0:             set.add(logId);
0:             this.journal.removeDataFiles(set);
0:         } else {
0:             this.metaData.journalRC.put(tx, logId, refCount);
1:         }
1: 
1:     }
1: 
0:     synchronized ByteSequence getPayload(Location location) throws IllegalStateException, IOException {
1:         ByteSequence result = null;
1:         result = this.journal.read(location);
1:         return result;
1:     }
1: 
0:     synchronized Location write(ByteSequence payload, boolean sync) throws IllegalStateException, IOException {
1:         return this.journal.write(payload, sync);
1:     }
1: 
1:     private void lock() throws IOException {
1:         if (lockFile == null) {
1:             File lockFileName = new File(directory, "lock");
1:             lockFile = new LockFile(lockFileName, true);
1:             if (failIfDatabaseIsLocked) {
1:                 lockFile.lock();
0:             } else {
1:                 while (true) {
1:                     try {
1:                         lockFile.lock();
1:                         break;
1:                     } catch (IOException e) {
1:                         LOG.info("Database " + lockFileName + " is locked... waiting "
1:                                 + (DATABASE_LOCKED_WAIT_DELAY / 1000)
1:                                 + " seconds for the database to be unlocked. Reason: " + e);
1:                         try {
1:                             Thread.sleep(DATABASE_LOCKED_WAIT_DELAY);
1:                         } catch (InterruptedException e1) {
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1:     PageFile getPageFile() {
1:         this.pageFile.isLoaded();
1:         return this.pageFile;
1:     }
1: 
1:     public boolean isFailIfDatabaseIsLocked() {
1:         return failIfDatabaseIsLocked;
1:     }
1: 
1:     public void setFailIfDatabaseIsLocked(boolean failIfDatabaseIsLocked) {
1:         this.failIfDatabaseIsLocked = failIfDatabaseIsLocked;
1:     }
1: 
1:     public int getJournalMaxFileLength() {
1:         return journalMaxFileLength;
1:     }
1: 
1:     public void setJournalMaxFileLength(int journalMaxFileLength) {
1:         this.journalMaxFileLength = journalMaxFileLength;
1:     }
1: 
1:     public int getJournalMaxWriteBatchSize() {
1:         return journalMaxWriteBatchSize;
1:     }
1: 
1:     public void setJournalMaxWriteBatchSize(int journalMaxWriteBatchSize) {
1:         this.journalMaxWriteBatchSize = journalMaxWriteBatchSize;
1:     }
1: 
1:     public boolean isEnableIndexWriteAsync() {
1:         return enableIndexWriteAsync;
1:     }
1: 
1:     public void setEnableIndexWriteAsync(boolean enableIndexWriteAsync) {
1:         this.enableIndexWriteAsync = enableIndexWriteAsync;
1:     }
1: 
1:     @Override
1:     public String toString() {
0:         return "JobSchedulerStore:" + this.directory;
1:     }
1: 
1: }
============================================================================