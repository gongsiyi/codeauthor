2:04ee70a: /**
1:04ee70a:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:04ee70a:  * contributor license agreements.  See the NOTICE file distributed with
1:04ee70a:  * this work for additional information regarding copyright ownership.
1:04ee70a:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:04ee70a:  * (the "License"); you may not use this file except in compliance with
1:04ee70a:  * the License.  You may obtain a copy of the License at
1:04ee70a:  *
1:04ee70a:  *      http://www.apache.org/licenses/LICENSE-2.0
1:04ee70a:  *
1:04ee70a:  * Unless required by applicable law or agreed to in writing, software
1:04ee70a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:04ee70a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:04ee70a:  * See the License for the specific language governing permissions and
1:04ee70a:  * limitations under the License.
2:04ee70a:  */
1:e14aca8: package org.apache.activemq.transport.auto;
9:04ee70a: 
1:04ee70a: import java.io.IOException;
1:04ee70a: import java.io.InputStream;
1:04ee70a: import java.net.Socket;
1:04ee70a: import java.net.URI;
1:04ee70a: import java.net.URISyntaxException;
1:04ee70a: import java.nio.ByteBuffer;
1:9ab9488: import java.util.HashMap;
1:04ee70a: import java.util.Map;
1:04ee70a: import java.util.Set;
1:04ee70a: import java.util.concurrent.ConcurrentHashMap;
1:04ee70a: import java.util.concurrent.ConcurrentMap;
1:e14aca8: import java.util.concurrent.Future;
1:e14aca8: import java.util.concurrent.LinkedBlockingQueue;
1:e14aca8: import java.util.concurrent.ThreadPoolExecutor;
1:e14aca8: import java.util.concurrent.TimeUnit;
1:e14aca8: import java.util.concurrent.TimeoutException;
1:e14aca8: import java.util.concurrent.atomic.AtomicInteger;
1:04ee70a: 
1:04ee70a: import javax.net.ServerSocketFactory;
1:04ee70a: 
1:04ee70a: import org.apache.activemq.broker.BrokerService;
1:04ee70a: import org.apache.activemq.broker.BrokerServiceAware;
1:04ee70a: import org.apache.activemq.openwire.OpenWireFormatFactory;
1:e14aca8: import org.apache.activemq.transport.InactivityIOException;
1:04ee70a: import org.apache.activemq.transport.Transport;
1:04ee70a: import org.apache.activemq.transport.TransportFactory;
1:04ee70a: import org.apache.activemq.transport.TransportServer;
1:e14aca8: import org.apache.activemq.transport.protocol.AmqpProtocolVerifier;
1:e14aca8: import org.apache.activemq.transport.protocol.MqttProtocolVerifier;
1:e14aca8: import org.apache.activemq.transport.protocol.OpenWireProtocolVerifier;
1:e14aca8: import org.apache.activemq.transport.protocol.ProtocolVerifier;
1:e14aca8: import org.apache.activemq.transport.protocol.StompProtocolVerifier;
1:04ee70a: import org.apache.activemq.transport.tcp.TcpTransport;
1:04ee70a: import org.apache.activemq.transport.tcp.TcpTransport.InitBuffer;
1:04ee70a: import org.apache.activemq.transport.tcp.TcpTransportFactory;
1:04ee70a: import org.apache.activemq.transport.tcp.TcpTransportServer;
1:04ee70a: import org.apache.activemq.util.FactoryFinder;
1:04ee70a: import org.apache.activemq.util.IOExceptionSupport;
1:04ee70a: import org.apache.activemq.util.IntrospectionSupport;
1:e14aca8: import org.apache.activemq.util.ServiceStopper;
1:04ee70a: import org.apache.activemq.wireformat.WireFormat;
1:04ee70a: import org.apache.activemq.wireformat.WireFormatFactory;
1:04ee70a: import org.slf4j.Logger;
1:04ee70a: import org.slf4j.LoggerFactory;
1:04ee70a: 
1:04ee70a: /**
1:04ee70a:  * A TCP based implementation of {@link TransportServer}
1:04ee70a:  */
1:04ee70a: public class AutoTcpTransportServer extends TcpTransportServer {
1:04ee70a: 
1:04ee70a:     private static final Logger LOG = LoggerFactory.getLogger(AutoTcpTransportServer.class);
1:04ee70a: 
1:04ee70a:     protected Map<String, Map<String, Object>> wireFormatOptions;
1:04ee70a:     protected Map<String, Object> autoTransportOptions;
1:04ee70a:     protected Set<String> enabledProtocols;
1:04ee70a:     protected final Map<String, ProtocolVerifier> protocolVerifiers = new ConcurrentHashMap<String, ProtocolVerifier>();
1:04ee70a: 
1:04ee70a:     protected BrokerService brokerService;
1:04ee70a: 
1:27238b2:     protected final ThreadPoolExecutor newConnectionExecutor;
1:27238b2:     protected final ThreadPoolExecutor protocolDetectionExecutor;
1:e14aca8:     protected int maxConnectionThreadPoolSize = Integer.MAX_VALUE;
1:2a0b785:     protected int protocolDetectionTimeOut = 30000;
1:e14aca8: 
1:04ee70a:     private static final FactoryFinder TRANSPORT_FACTORY_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/transport/");
1:04ee70a:     private final ConcurrentMap<String, TransportFactory> transportFactories = new ConcurrentHashMap<String, TransportFactory>();
1:04ee70a: 
1:04ee70a:     private static final FactoryFinder WIREFORMAT_FACTORY_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/wireformat/");
1:04ee70a: 
1:04ee70a:     public WireFormatFactory findWireFormatFactory(String scheme, Map<String, Map<String, Object>> options) throws IOException {
1:04ee70a:         WireFormatFactory wff = null;
2:04ee70a:         try {
1:04ee70a:             wff = (WireFormatFactory)WIREFORMAT_FACTORY_FINDER.newInstance(scheme);
1:04ee70a:             if (options != null) {
1:9ab9488:                 final Map<String, Object> wfOptions = new HashMap<>();
1:9ab9488:                 if (options.get(AutoTransportUtils.ALL) != null) {
1:9ab9488:                     wfOptions.putAll(options.get(AutoTransportUtils.ALL));
1:9ab9488:                 }
1:9ab9488:                 if (options.get(scheme) != null) {
1:9ab9488:                     wfOptions.putAll(options.get(scheme));
1:9ab9488:                 }
1:9ab9488:                 IntrospectionSupport.setProperties(wff, wfOptions);
5:04ee70a:             }
1:04ee70a:             if (wff instanceof OpenWireFormatFactory) {
1:04ee70a:                 protocolVerifiers.put(AutoTransportUtils.OPENWIRE, new OpenWireProtocolVerifier((OpenWireFormatFactory) wff));
1:04ee70a:             }
1:04ee70a:             return wff;
1:04ee70a:         } catch (Throwable e) {
1:04ee70a:            throw IOExceptionSupport.create("Could not create wire format factory for: " + scheme + ", reason: " + e, e);
1:04ee70a:         }
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     public TransportFactory findTransportFactory(String scheme, Map<String, ?> options) throws IOException {
1:04ee70a:         scheme = append(scheme, "nio");
1:04ee70a:         scheme = append(scheme, "ssl");
1:04ee70a: 
1:04ee70a:         if (scheme.isEmpty()) {
1:04ee70a:             scheme = "tcp";
1:04ee70a:         }
1:04ee70a: 
1:04ee70a:         TransportFactory tf = transportFactories.get(scheme);
1:04ee70a:         if (tf == null) {
1:04ee70a:             // Try to load if from a META-INF property.
1:e14aca8:             try {
1:04ee70a:                 tf = (TransportFactory)TRANSPORT_FACTORY_FINDER.newInstance(scheme);
1:e14aca8:                 if (options != null) {
1:04ee70a:                     IntrospectionSupport.setProperties(tf, options);
1:e14aca8:                 }
1:04ee70a:                 transportFactories.put(scheme, tf);
1:04ee70a:             } catch (Throwable e) {
1:04ee70a:                 throw IOExceptionSupport.create("Transport scheme NOT recognized: [" + scheme + "]", e);
1:04ee70a:             }
1:04ee70a:         }
1:04ee70a:         return tf;
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     protected String append(String currentScheme, String scheme) {
1:04ee70a:         if (this.getBindLocation().getScheme().contains(scheme)) {
1:04ee70a:             if (!currentScheme.isEmpty()) {
1:04ee70a:                 currentScheme += "+";
1:04ee70a:             }
1:04ee70a:             currentScheme += scheme;
1:04ee70a:         }
1:04ee70a:         return currentScheme;
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     /**
1:04ee70a:      * @param transportFactory
1:04ee70a:      * @param location
1:04ee70a:      * @param serverSocketFactory
1:04ee70a:      * @throws IOException
1:04ee70a:      * @throws URISyntaxException
1:04ee70a:      */
1:04ee70a:     public AutoTcpTransportServer(TcpTransportFactory transportFactory,
1:04ee70a:             URI location, ServerSocketFactory serverSocketFactory, BrokerService brokerService,
1:04ee70a:             Set<String> enabledProtocols)
1:04ee70a:             throws IOException, URISyntaxException {
1:04ee70a:         super(transportFactory, location, serverSocketFactory);
1:e14aca8: 
1:e14aca8:         //Use an executor service here to handle new connections.  Setting the max number
1:e14aca8:         //of threads to the maximum number of connections the thread count isn't unbounded
1:27238b2:         newConnectionExecutor = new ThreadPoolExecutor(maxConnectionThreadPoolSize,
1:e14aca8:                 maxConnectionThreadPoolSize,
1:e14aca8:                 30L, TimeUnit.SECONDS,
1:e14aca8:                 new LinkedBlockingQueue<Runnable>());
1:e14aca8:         //allow the thread pool to shrink if the max number of threads isn't needed
1:27238b2:         //and the pool can grow and shrink as needed if contention is high
1:27238b2:         newConnectionExecutor.allowCoreThreadTimeOut(true);
1:27238b2: 
1:27238b2:         //Executor for waiting for bytes to detection of protocol
1:27238b2:         protocolDetectionExecutor = new ThreadPoolExecutor(maxConnectionThreadPoolSize,
1:27238b2:                 maxConnectionThreadPoolSize,
1:27238b2:                 30L, TimeUnit.SECONDS,
1:27238b2:                 new LinkedBlockingQueue<Runnable>());
1:27238b2:         //allow the thread pool to shrink if the max number of threads isn't needed
1:27238b2:         protocolDetectionExecutor.allowCoreThreadTimeOut(true);
1:e14aca8: 
1:04ee70a:         this.brokerService = brokerService;
1:04ee70a:         this.enabledProtocols = enabledProtocols;
1:04ee70a:         initProtocolVerifiers();
1:04ee70a:     }
1:04ee70a: 
1:e14aca8:     public int getMaxConnectionThreadPoolSize() {
1:e14aca8:         return maxConnectionThreadPoolSize;
1:e14aca8:     }
1:e14aca8: 
1:27238b2:     /**
1:27238b2:      * Set the number of threads to be used for processing connections.  Defaults
1:27238b2:      * to Integer.MAX_SIZE.  Set this value to be lower to reduce the
1:27238b2:      * number of simultaneous connection attempts.  If not set then the maximum number of
1:27238b2:      * threads will generally be controlled by the transport maxConnections setting:
1:27238b2:      * {@link TcpTransportServer#setMaximumConnections(int)}.
1:27238b2:      *<p>
1:27238b2:      * Note that this setter controls two thread pools because connection attempts
1:27238b2:      * require 1 thread to start processing the connection and another thread to read from the
1:27238b2:      * socket and to detect the protocol. Two threads are needed because some transports
1:27238b2:      * block on socket read so the first thread needs to be able to abort the second thread on timeout.
1:27238b2:      * Therefore this setting will set each thread pool to the size passed in essentially giving
1:27238b2:      * 2 times as many potential threads as the value set.
1:27238b2:      *<p>
1:27238b2:      * Both thread pools will close idle threads after a period of time
1:27238b2:      * essentially allowing the thread pools to grow and shrink dynamically based on load.
1:27238b2:      *
1:27238b2:      * @see {@link TcpTransportServer#setMaximumConnections(int)}.
1:27238b2:      * @param maxConnectionThreadPoolSize
1:27238b2:      */
1:e14aca8:     public void setMaxConnectionThreadPoolSize(int maxConnectionThreadPoolSize) {
1:e14aca8:         this.maxConnectionThreadPoolSize = maxConnectionThreadPoolSize;
1:27238b2:         newConnectionExecutor.setCorePoolSize(maxConnectionThreadPoolSize);
1:27238b2:         newConnectionExecutor.setMaximumPoolSize(maxConnectionThreadPoolSize);
1:27238b2:         protocolDetectionExecutor.setCorePoolSize(maxConnectionThreadPoolSize);
1:27238b2:         protocolDetectionExecutor.setMaximumPoolSize(maxConnectionThreadPoolSize);
1:e14aca8:     }
1:e14aca8: 
1:e14aca8:     public void setProtocolDetectionTimeOut(int protocolDetectionTimeOut) {
1:e14aca8:         this.protocolDetectionTimeOut = protocolDetectionTimeOut;
1:e14aca8:     }
1:e14aca8: 
2:04ee70a:     @Override
1:04ee70a:     public void setWireFormatFactory(WireFormatFactory factory) {
1:04ee70a:         super.setWireFormatFactory(factory);
1:04ee70a:         initOpenWireProtocolVerifier();
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     protected void initProtocolVerifiers() {
1:04ee70a:         initOpenWireProtocolVerifier();
1:04ee70a: 
1:04ee70a:         if (isAllProtocols() || enabledProtocols.contains(AutoTransportUtils.AMQP)) {
1:04ee70a:             protocolVerifiers.put(AutoTransportUtils.AMQP, new AmqpProtocolVerifier());
1:04ee70a:         }
1:04ee70a:         if (isAllProtocols() || enabledProtocols.contains(AutoTransportUtils.STOMP)) {
1:04ee70a:             protocolVerifiers.put(AutoTransportUtils.STOMP, new StompProtocolVerifier());
1:04ee70a:         }
1:04ee70a:         if (isAllProtocols()|| enabledProtocols.contains(AutoTransportUtils.MQTT)) {
1:04ee70a:             protocolVerifiers.put(AutoTransportUtils.MQTT, new MqttProtocolVerifier());
1:04ee70a:         }
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     protected void initOpenWireProtocolVerifier() {
1:04ee70a:         if (isAllProtocols() || enabledProtocols.contains(AutoTransportUtils.OPENWIRE)) {
1:04ee70a:             OpenWireProtocolVerifier owpv;
1:04ee70a:             if (wireFormatFactory instanceof OpenWireFormatFactory) {
1:04ee70a:                 owpv = new OpenWireProtocolVerifier((OpenWireFormatFactory) wireFormatFactory);
1:e14aca8:             } else {
1:04ee70a:                 owpv = new OpenWireProtocolVerifier(new OpenWireFormatFactory());
1:04ee70a:             }
1:04ee70a:             protocolVerifiers.put(AutoTransportUtils.OPENWIRE, owpv);
1:04ee70a:         }
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     protected boolean isAllProtocols() {
1:04ee70a:         return enabledProtocols == null || enabledProtocols.isEmpty();
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     @Override
1:04ee70a:     protected void handleSocket(final Socket socket) {
1:04ee70a:         final AutoTcpTransportServer server = this;
1:04ee70a:         //This needs to be done in a new thread because
1:04ee70a:         //the socket might be waiting on the client to send bytes
1:04ee70a:         //doHandleSocket can't complete until the protocol can be detected
1:27238b2:         newConnectionExecutor.submit(new Runnable() {
1:04ee70a:             @Override
1:04ee70a:             public void run() {
1:04ee70a:                 server.doHandleSocket(socket);
1:04ee70a:             }
1:04ee70a:         });
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     @Override
1:04ee70a:     protected TransportInfo configureTransport(final TcpTransportServer server, final Socket socket) throws Exception {
1:e14aca8:         final InputStream is = socket.getInputStream();
1:e14aca8:         final AtomicInteger readBytes = new AtomicInteger(0);
1:e14aca8:         final ByteBuffer data = ByteBuffer.allocate(8);
1:27238b2: 
1:e14aca8:         // We need to peak at the first 8 bytes of the buffer to detect the protocol
1:27238b2:         Future<?> future = protocolDetectionExecutor.submit(new Runnable() {
1:e14aca8:             @Override
1:e14aca8:             public void run() {
1:e14aca8:                 try {
1:e14aca8:                     do {
1:27238b2:                         //will block until enough bytes or read or a timeout
1:27238b2:                         //and the socket is closed
1:e14aca8:                         int read = is.read();
1:e14aca8:                         if (read == -1) {
1:3c358b3:                             throw new IOException("Connection failed, stream is closed.");
1:e14aca8:                         }
1:e14aca8:                         data.put((byte) read);
1:e14aca8:                         readBytes.incrementAndGet();
1:27238b2:                     } while (readBytes.get() < 8 && !Thread.interrupted());
1:e14aca8:                 } catch (Exception e) {
1:e14aca8:                     throw new IllegalStateException(e);
1:e14aca8:                 }
1:e14aca8:             }
1:e14aca8:         });
1:04ee70a: 
1:27238b2:         try {
1:27238b2:             //If this fails and throws an exception and the socket will be closed
1:27238b2:             waitForProtocolDetectionFinish(future, readBytes);
1:27238b2:         } finally {
1:27238b2:             //call cancel in case task didn't complete
1:27238b2:             future.cancel(true);
1:27238b2:         }
1:3c358b3:         data.flip();
1:e14aca8:         ProtocolInfo protocolInfo = detectProtocol(data.array());
1:04ee70a: 
1:7e648d5:         InitBuffer initBuffer = new InitBuffer(readBytes.get(), ByteBuffer.allocate(readBytes.get()));
1:e14aca8:         initBuffer.buffer.put(data.array());
1:04ee70a: 
1:e14aca8:         if (protocolInfo.detectedTransportFactory instanceof BrokerServiceAware) {
1:e14aca8:             ((BrokerServiceAware) protocolInfo.detectedTransportFactory).setBrokerService(brokerService);
1:e14aca8:         }
1:04ee70a: 
1:04ee70a:         WireFormat format = protocolInfo.detectedWireFormatFactory.createWireFormat();
1:7e648d5:         Transport transport = createTransport(socket, format, protocolInfo.detectedTransportFactory, initBuffer);
1:04ee70a: 
1:04ee70a:         return new TransportInfo(format, transport, protocolInfo.detectedTransportFactory);
1:04ee70a:     }
1:04ee70a: 
1:3c358b3:     protected void waitForProtocolDetectionFinish(final Future<?> future, final AtomicInteger readBytes) throws Exception {
1:3c358b3:         try {
1:3c358b3:             //Wait for protocolDetectionTimeOut if defined
1:3c358b3:             if (protocolDetectionTimeOut > 0) {
1:3c358b3:                 future.get(protocolDetectionTimeOut, TimeUnit.MILLISECONDS);
1:3c358b3:             } else {
1:3c358b3:                 future.get();
1:3c358b3:             }
1:3c358b3:         } catch (TimeoutException e) {
1:3c358b3:             throw new InactivityIOException("Client timed out before wire format could be detected. " +
1:3c358b3:                     " 8 bytes are required to detect the protocol but only: " + readBytes.get() + " byte(s) were sent.");
1:3c358b3:         }
1:3c358b3:     }
1:3c358b3: 
1:04ee70a:     /**
1:04ee70a:      * @param socket
1:04ee70a:      * @param format
1:04ee70a:      * @param detectedTransportFactory
1:04ee70a:      * @return
1:04ee70a:      */
1:04ee70a:     protected TcpTransport createTransport(Socket socket, WireFormat format,
1:7e648d5:             TcpTransportFactory detectedTransportFactory, InitBuffer initBuffer) throws IOException {
1:7e648d5:         return new TcpTransport(format, socket, initBuffer);
1:e14aca8:     }
1:e14aca8: 
1:04ee70a:     public void setWireFormatOptions(Map<String, Map<String, Object>> wireFormatOptions) {
1:04ee70a:         this.wireFormatOptions = wireFormatOptions;
1:e14aca8:     }
1:04ee70a: 
1:04ee70a:     public void setEnabledProtocols(Set<String> enabledProtocols) {
1:04ee70a:         this.enabledProtocols = enabledProtocols;
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     public void setAutoTransportOptions(Map<String, Object> autoTransportOptions) {
1:04ee70a:         this.autoTransportOptions = autoTransportOptions;
1:e14aca8:         if (autoTransportOptions.get("protocols") != null) {
1:04ee70a:             this.enabledProtocols = AutoTransportUtils.parseProtocols((String) autoTransportOptions.get("protocols"));
1:e14aca8:         }
1:e14aca8:     }
1:e14aca8:     @Override
1:e14aca8:     protected void doStop(ServiceStopper stopper) throws Exception {
1:27238b2:         if (newConnectionExecutor != null) {
1:27238b2:             newConnectionExecutor.shutdownNow();
1:27238b2:             try {
1:27238b2:                 if (!newConnectionExecutor.awaitTermination(3, TimeUnit.SECONDS)) {
1:27238b2:                     LOG.warn("Auto Transport newConnectionExecutor didn't shutdown cleanly");
1:27238b2:                 }
1:27238b2:             } catch (InterruptedException e) {
1:27238b2:             }
1:27238b2:         }
1:27238b2:         if (protocolDetectionExecutor != null) {
1:27238b2:             protocolDetectionExecutor.shutdownNow();
1:27238b2:             try {
1:27238b2:                 if (!protocolDetectionExecutor.awaitTermination(3, TimeUnit.SECONDS)) {
1:27238b2:                     LOG.warn("Auto Transport protocolDetectionExecutor didn't shutdown cleanly");
1:27238b2:                 }
1:27238b2:             } catch (InterruptedException e) {
1:27238b2:             }
1:e14aca8:         }
1:e14aca8:         super.doStop(stopper);
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     protected ProtocolInfo detectProtocol(byte[] buffer) throws IOException {
1:04ee70a:         TcpTransportFactory detectedTransportFactory = transportFactory;
1:04ee70a:         WireFormatFactory detectedWireFormatFactory = wireFormatFactory;
1:04ee70a: 
1:04ee70a:         boolean found = false;
1:04ee70a:         for (String scheme : protocolVerifiers.keySet()) {
1:04ee70a:             if (protocolVerifiers.get(scheme).isProtocol(buffer)) {
1:3c358b3:                 LOG.debug("Detected protocol " + scheme);
1:04ee70a:                 detectedWireFormatFactory = findWireFormatFactory(scheme, wireFormatOptions);
1:04ee70a: 
1:04ee70a:                 if (scheme.equals("default")) {
1:04ee70a:                     scheme = "";
1:04ee70a:                 }
1:04ee70a: 
1:04ee70a:                 detectedTransportFactory = (TcpTransportFactory) findTransportFactory(scheme, transportOptions);
1:04ee70a:                 found = true;
1:04ee70a:                 break;
1:04ee70a:             }
1:04ee70a:         }
1:04ee70a: 
1:04ee70a:         if (!found) {
1:3c358b3:             throw new IllegalStateException("Could not detect the wire format");
1:04ee70a:         }
1:04ee70a: 
1:04ee70a:         return new ProtocolInfo(detectedTransportFactory, detectedWireFormatFactory);
1:04ee70a: 
1:04ee70a:     }
1:04ee70a: 
1:04ee70a:     protected class ProtocolInfo {
1:04ee70a:         public final TcpTransportFactory detectedTransportFactory;
1:04ee70a:         public final WireFormatFactory detectedWireFormatFactory;
1:04ee70a: 
1:04ee70a:         public ProtocolInfo(TcpTransportFactory detectedTransportFactory,
1:04ee70a:                 WireFormatFactory detectedWireFormatFactory) {
1:04ee70a:             super();
1:04ee70a:             this.detectedTransportFactory = detectedTransportFactory;
1:04ee70a:             this.detectedWireFormatFactory = detectedWireFormatFactory;
1:04ee70a:         }
1:04ee70a:     }
1:04ee70a: 
1:04ee70a: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:2a0b785
/////////////////////////////////////////////////////////////////////////
1:     protected int protocolDetectionTimeOut = 30000;
commit:27238b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final ThreadPoolExecutor newConnectionExecutor;
1:     protected final ThreadPoolExecutor protocolDetectionExecutor;
0:     protected int protocolDetectionTimeOut = 15000;
/////////////////////////////////////////////////////////////////////////
1:         newConnectionExecutor = new ThreadPoolExecutor(maxConnectionThreadPoolSize,
1:         //and the pool can grow and shrink as needed if contention is high
1:         newConnectionExecutor.allowCoreThreadTimeOut(true);
1: 
1:         //Executor for waiting for bytes to detection of protocol
1:         protocolDetectionExecutor = new ThreadPoolExecutor(maxConnectionThreadPoolSize,
1:                 maxConnectionThreadPoolSize,
1:                 30L, TimeUnit.SECONDS,
1:                 new LinkedBlockingQueue<Runnable>());
1:         //allow the thread pool to shrink if the max number of threads isn't needed
1:         protocolDetectionExecutor.allowCoreThreadTimeOut(true);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set the number of threads to be used for processing connections.  Defaults
1:      * to Integer.MAX_SIZE.  Set this value to be lower to reduce the
1:      * number of simultaneous connection attempts.  If not set then the maximum number of
1:      * threads will generally be controlled by the transport maxConnections setting:
1:      * {@link TcpTransportServer#setMaximumConnections(int)}.
1:      *<p>
1:      * Note that this setter controls two thread pools because connection attempts
1:      * require 1 thread to start processing the connection and another thread to read from the
1:      * socket and to detect the protocol. Two threads are needed because some transports
1:      * block on socket read so the first thread needs to be able to abort the second thread on timeout.
1:      * Therefore this setting will set each thread pool to the size passed in essentially giving
1:      * 2 times as many potential threads as the value set.
1:      *<p>
1:      * Both thread pools will close idle threads after a period of time
1:      * essentially allowing the thread pools to grow and shrink dynamically based on load.
1:      *
1:      * @see {@link TcpTransportServer#setMaximumConnections(int)}.
1:      * @param maxConnectionThreadPoolSize
1:      */
1:         newConnectionExecutor.setCorePoolSize(maxConnectionThreadPoolSize);
1:         newConnectionExecutor.setMaximumPoolSize(maxConnectionThreadPoolSize);
1:         protocolDetectionExecutor.setCorePoolSize(maxConnectionThreadPoolSize);
1:         protocolDetectionExecutor.setMaximumPoolSize(maxConnectionThreadPoolSize);
/////////////////////////////////////////////////////////////////////////
1:         newConnectionExecutor.submit(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1: 
1:         Future<?> future = protocolDetectionExecutor.submit(new Runnable() {
1:                         //will block until enough bytes or read or a timeout
1:                         //and the socket is closed
1:                     } while (readBytes.get() < 8 && !Thread.interrupted());
1:         try {
1:             //If this fails and throws an exception and the socket will be closed
1:             waitForProtocolDetectionFinish(future, readBytes);
1:         } finally {
1:             //call cancel in case task didn't complete
1:             future.cancel(true);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (newConnectionExecutor != null) {
1:             newConnectionExecutor.shutdownNow();
1:             try {
1:                 if (!newConnectionExecutor.awaitTermination(3, TimeUnit.SECONDS)) {
1:                     LOG.warn("Auto Transport newConnectionExecutor didn't shutdown cleanly");
1:                 }
1:             } catch (InterruptedException e) {
1:             }
1:         }
1:         if (protocolDetectionExecutor != null) {
1:             protocolDetectionExecutor.shutdownNow();
1:             try {
1:                 if (!protocolDetectionExecutor.awaitTermination(3, TimeUnit.SECONDS)) {
1:                     LOG.warn("Auto Transport protocolDetectionExecutor didn't shutdown cleanly");
1:                 }
1:             } catch (InterruptedException e) {
1:             }
commit:7e648d5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         InitBuffer initBuffer = new InitBuffer(readBytes.get(), ByteBuffer.allocate(readBytes.get()));
/////////////////////////////////////////////////////////////////////////
1:         Transport transport = createTransport(socket, format, protocolInfo.detectedTransportFactory, initBuffer);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             TcpTransportFactory detectedTransportFactory, InitBuffer initBuffer) throws IOException {
1:         return new TcpTransport(format, socket, initBuffer);
commit:9ab9488
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:                 final Map<String, Object> wfOptions = new HashMap<>();
1:                 if (options.get(AutoTransportUtils.ALL) != null) {
1:                     wfOptions.putAll(options.get(AutoTransportUtils.ALL));
1:                 }
1:                 if (options.get(scheme) != null) {
1:                     wfOptions.putAll(options.get(scheme));
1:                 }
1:                 IntrospectionSupport.setProperties(wff, wfOptions);
commit:98c5866
/////////////////////////////////////////////////////////////////////////
0:         Transport transport = createTransport(socket, format, protocolInfo.detectedTransportFactory);
commit:3c358b3
/////////////////////////////////////////////////////////////////////////
1:                             throw new IOException("Connection failed, stream is closed.");
/////////////////////////////////////////////////////////////////////////
0:         waitForProtocolDetectionFinish(future, readBytes);
1:         data.flip();
/////////////////////////////////////////////////////////////////////////
1:     protected void waitForProtocolDetectionFinish(final Future<?> future, final AtomicInteger readBytes) throws Exception {
1:         try {
1:             //Wait for protocolDetectionTimeOut if defined
1:             if (protocolDetectionTimeOut > 0) {
1:                 future.get(protocolDetectionTimeOut, TimeUnit.MILLISECONDS);
1:             } else {
1:                 future.get();
1:             }
1:         } catch (TimeoutException e) {
1:             throw new InactivityIOException("Client timed out before wire format could be detected. " +
1:                     " 8 bytes are required to detect the protocol but only: " + readBytes.get() + " byte(s) were sent.");
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Detected protocol " + scheme);
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalStateException("Could not detect the wire format");
commit:e14aca8
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.transport.auto;
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.Future;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.TimeoutException;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import org.apache.activemq.transport.InactivityIOException;
1: import org.apache.activemq.transport.protocol.AmqpProtocolVerifier;
1: import org.apache.activemq.transport.protocol.MqttProtocolVerifier;
1: import org.apache.activemq.transport.protocol.OpenWireProtocolVerifier;
1: import org.apache.activemq.transport.protocol.ProtocolVerifier;
1: import org.apache.activemq.transport.protocol.StompProtocolVerifier;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceStopper;
/////////////////////////////////////////////////////////////////////////
1:     protected int maxConnectionThreadPoolSize = Integer.MAX_VALUE;
0:     protected int protocolDetectionTimeOut = 30000;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (options != null) {
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
1:         //Use an executor service here to handle new connections.  Setting the max number
1:         //of threads to the maximum number of connections the thread count isn't unbounded
0:         service = new ThreadPoolExecutor(maxConnectionThreadPoolSize,
1:                 maxConnectionThreadPoolSize,
1:                 30L, TimeUnit.SECONDS,
1:                 new LinkedBlockingQueue<Runnable>());
1:         //allow the thread pool to shrink if the max number of threads isn't needed
0:         service.allowCoreThreadTimeOut(true);
1: 
1:     public int getMaxConnectionThreadPoolSize() {
1:         return maxConnectionThreadPoolSize;
1:     }
1: 
1:     public void setMaxConnectionThreadPoolSize(int maxConnectionThreadPoolSize) {
1:         this.maxConnectionThreadPoolSize = maxConnectionThreadPoolSize;
0:         service.setCorePoolSize(maxConnectionThreadPoolSize);
0:         service.setMaximumPoolSize(maxConnectionThreadPoolSize);
1:     }
1: 
1:     public void setProtocolDetectionTimeOut(int protocolDetectionTimeOut) {
1:         this.protocolDetectionTimeOut = protocolDetectionTimeOut;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected final ThreadPoolExecutor service;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final InputStream is = socket.getInputStream();
0:         ExecutorService executor = Executors.newSingleThreadExecutor();
1:         final AtomicInteger readBytes = new AtomicInteger(0);
1:         final ByteBuffer data = ByteBuffer.allocate(8);
1:         // We need to peak at the first 8 bytes of the buffer to detect the protocol
0:         Future<?> future = executor.submit(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     do {
1:                         int read = is.read();
1:                         if (read == -1) {
0:                             throw new IOException("Connection faild, stream is closed.");
1:                         }
1:                         data.put((byte) read);
1:                         readBytes.incrementAndGet();
0:                     } while (readBytes.get() < 8);
1:                 } catch (Exception e) {
1:                     throw new IllegalStateException(e);
1:                 }
1:             }
1:         });
1:         try {
0:             //Wait for protocolDetectionTimeOut if defined
0:             if (protocolDetectionTimeOut > 0) {
0:                 future.get(protocolDetectionTimeOut, TimeUnit.MILLISECONDS);
1:             } else {
0:                 future.get();
1:             }
0:             data.flip();
0:         } catch (TimeoutException e) {
0:             throw new InactivityIOException("Client timed out before wire format could be detected. " +
0:                     " 8 bytes are required to detect the protocol but only: " + readBytes + " were sent.");
1:         }
1:         ProtocolInfo protocolInfo = detectProtocol(data.array());
0:         initBuffer = new InitBuffer(readBytes.get(), ByteBuffer.allocate(readBytes.get()));
1:         initBuffer.buffer.put(data.array());
1: 
1:         if (protocolInfo.detectedTransportFactory instanceof BrokerServiceAware) {
1:             ((BrokerServiceAware) protocolInfo.detectedTransportFactory).setBrokerService(brokerService);
1:         }
0:         Transport transport = createTransport(socket, format,protocolInfo.detectedTransportFactory);
/////////////////////////////////////////////////////////////////////////
1:         if (autoTransportOptions.get("protocols") != null) {
1:         }
1:     }
1:     @Override
1:     protected void doStop(ServiceStopper stopper) throws Exception {
0:         if (service != null) {
0:             service.shutdown();
1:         }
1:         super.doStop(stopper);
commit:04ee70a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.activemq.broker.transport.auto;
1: 
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.net.Socket;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.nio.ByteBuffer;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.ConcurrentMap;
0: import java.util.concurrent.ExecutorService;
0: import java.util.concurrent.Executors;
1: 
1: import javax.net.ServerSocketFactory;
1: 
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.BrokerServiceAware;
0: import org.apache.activemq.broker.transport.protocol.AmqpProtocolVerifier;
0: import org.apache.activemq.broker.transport.protocol.MqttProtocolVerifier;
0: import org.apache.activemq.broker.transport.protocol.OpenWireProtocolVerifier;
0: import org.apache.activemq.broker.transport.protocol.ProtocolVerifier;
0: import org.apache.activemq.broker.transport.protocol.StompProtocolVerifier;
1: import org.apache.activemq.openwire.OpenWireFormatFactory;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportFactory;
1: import org.apache.activemq.transport.TransportServer;
1: import org.apache.activemq.transport.tcp.TcpTransport;
1: import org.apache.activemq.transport.tcp.TcpTransport.InitBuffer;
1: import org.apache.activemq.transport.tcp.TcpTransportFactory;
1: import org.apache.activemq.transport.tcp.TcpTransportServer;
1: import org.apache.activemq.util.FactoryFinder;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.wireformat.WireFormat;
1: import org.apache.activemq.wireformat.WireFormatFactory;
0: import org.fusesource.hawtbuf.Buffer;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A TCP based implementation of {@link TransportServer}
1:  */
1: public class AutoTcpTransportServer extends TcpTransportServer {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AutoTcpTransportServer.class);
1: 
1:     protected Map<String, Map<String, Object>> wireFormatOptions;
1:     protected Map<String, Object> autoTransportOptions;
1:     protected Set<String> enabledProtocols;
1:     protected final Map<String, ProtocolVerifier> protocolVerifiers = new ConcurrentHashMap<String, ProtocolVerifier>();
1: 
1:     protected BrokerService brokerService;
1: 
1:     private static final FactoryFinder TRANSPORT_FACTORY_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/transport/");
1:     private final ConcurrentMap<String, TransportFactory> transportFactories = new ConcurrentHashMap<String, TransportFactory>();
1: 
1:     private static final FactoryFinder WIREFORMAT_FACTORY_FINDER = new FactoryFinder("META-INF/services/org/apache/activemq/wireformat/");
1: 
1:     public WireFormatFactory findWireFormatFactory(String scheme, Map<String, Map<String, Object>> options) throws IOException {
1:         WireFormatFactory wff = null;
1:         try {
1:             wff = (WireFormatFactory)WIREFORMAT_FACTORY_FINDER.newInstance(scheme);
1:             if (options != null) {
0:                 IntrospectionSupport.setProperties(wff, options.get(AutoTransportUtils.ALL));
0:                 IntrospectionSupport.setProperties(wff, options.get(scheme));
1:             }
1:             if (wff instanceof OpenWireFormatFactory) {
1:                 protocolVerifiers.put(AutoTransportUtils.OPENWIRE, new OpenWireProtocolVerifier((OpenWireFormatFactory) wff));
1:             }
1:             return wff;
1:         } catch (Throwable e) {
1:            throw IOExceptionSupport.create("Could not create wire format factory for: " + scheme + ", reason: " + e, e);
1:         }
1:     }
1: 
1:     public TransportFactory findTransportFactory(String scheme, Map<String, ?> options) throws IOException {
1:         scheme = append(scheme, "nio");
1:         scheme = append(scheme, "ssl");
1: 
1:         if (scheme.isEmpty()) {
1:             scheme = "tcp";
1:         }
1: 
1:         TransportFactory tf = transportFactories.get(scheme);
1:         if (tf == null) {
1:             // Try to load if from a META-INF property.
1:             try {
1:                 tf = (TransportFactory)TRANSPORT_FACTORY_FINDER.newInstance(scheme);
0:                 if (options != null)
1:                     IntrospectionSupport.setProperties(tf, options);
1:                 transportFactories.put(scheme, tf);
1:             } catch (Throwable e) {
1:                 throw IOExceptionSupport.create("Transport scheme NOT recognized: [" + scheme + "]", e);
1:             }
1:         }
1:         return tf;
1:     }
1: 
1:     protected String append(String currentScheme, String scheme) {
1:         if (this.getBindLocation().getScheme().contains(scheme)) {
1:             if (!currentScheme.isEmpty()) {
1:                 currentScheme += "+";
1:             }
1:             currentScheme += scheme;
1:         }
1:         return currentScheme;
1:     }
1: 
1:     /**
1:      * @param transportFactory
1:      * @param location
1:      * @param serverSocketFactory
1:      * @throws IOException
1:      * @throws URISyntaxException
1:      */
1:     public AutoTcpTransportServer(TcpTransportFactory transportFactory,
1:             URI location, ServerSocketFactory serverSocketFactory, BrokerService brokerService,
1:             Set<String> enabledProtocols)
1:             throws IOException, URISyntaxException {
1:         super(transportFactory, location, serverSocketFactory);
0:         service = Executors.newCachedThreadPool();
1:         this.brokerService = brokerService;
1:         this.enabledProtocols = enabledProtocols;
1:         initProtocolVerifiers();
1:     }
1: 
1:     @Override
1:     public void setWireFormatFactory(WireFormatFactory factory) {
1:         super.setWireFormatFactory(factory);
1:         initOpenWireProtocolVerifier();
1:     }
1: 
1:     protected void initProtocolVerifiers() {
1:         initOpenWireProtocolVerifier();
1: 
1:         if (isAllProtocols() || enabledProtocols.contains(AutoTransportUtils.AMQP)) {
1:             protocolVerifiers.put(AutoTransportUtils.AMQP, new AmqpProtocolVerifier());
1:         }
1:         if (isAllProtocols() || enabledProtocols.contains(AutoTransportUtils.STOMP)) {
1:             protocolVerifiers.put(AutoTransportUtils.STOMP, new StompProtocolVerifier());
1:         }
1:         if (isAllProtocols()|| enabledProtocols.contains(AutoTransportUtils.MQTT)) {
1:             protocolVerifiers.put(AutoTransportUtils.MQTT, new MqttProtocolVerifier());
1:         }
1:     }
1: 
1:     protected void initOpenWireProtocolVerifier() {
1:         if (isAllProtocols() || enabledProtocols.contains(AutoTransportUtils.OPENWIRE)) {
1:             OpenWireProtocolVerifier owpv;
1:             if (wireFormatFactory instanceof OpenWireFormatFactory) {
1:                 owpv = new OpenWireProtocolVerifier((OpenWireFormatFactory) wireFormatFactory);
0:             } else {
1:                 owpv = new OpenWireProtocolVerifier(new OpenWireFormatFactory());
1:             }
1:             protocolVerifiers.put(AutoTransportUtils.OPENWIRE, owpv);
1:         }
1:     }
1: 
1:     protected boolean isAllProtocols() {
1:         return enabledProtocols == null || enabledProtocols.isEmpty();
1:     }
1: 
1: 
0:     protected final ExecutorService service;
1: 
1: 
1:     /**
0:      * This holds the initial buffer that has been read to detect the protocol.
1:      */
0:     public InitBuffer initBuffer;
1: 
1:     @Override
1:     protected void handleSocket(final Socket socket) {
1:         final AutoTcpTransportServer server = this;
1: 
1:         //This needs to be done in a new thread because
1:         //the socket might be waiting on the client to send bytes
1:         //doHandleSocket can't complete until the protocol can be detected
0:         service.submit(new Runnable() {
1:             @Override
1:             public void run() {
1:                 server.doHandleSocket(socket);
1:             }
1:         });
1:     }
1: 
1:     @Override
1:     protected TransportInfo configureTransport(final TcpTransportServer server, final Socket socket) throws Exception {
0:          InputStream is = socket.getInputStream();
1: 
0:          //We need to peak at the first 8 bytes of the buffer to detect the protocol
0:          Buffer magic = new Buffer(8);
0:          magic.readFrom(is);
1: 
0:          ProtocolInfo protocolInfo = detectProtocol(magic.getData());
1: 
0:          initBuffer = new InitBuffer(8, ByteBuffer.allocate(8));
0:          initBuffer.buffer.put(magic.getData());
1: 
0:          if (protocolInfo.detectedTransportFactory instanceof BrokerServiceAware) {
0:              ((BrokerServiceAware) protocolInfo.detectedTransportFactory).setBrokerService(brokerService);
1:          }
1: 
1:         WireFormat format = protocolInfo.detectedWireFormatFactory.createWireFormat();
0:         Transport transport = createTransport(socket, format, protocolInfo.detectedTransportFactory);
1: 
1:         return new TransportInfo(format, transport, protocolInfo.detectedTransportFactory);
1:     }
1: 
1:     @Override
0:     protected TcpTransport createTransport(Socket socket, WireFormat format) throws IOException {
0:         return new TcpTransport(format, socket, this.initBuffer);
1:     }
1: 
1:     /**
1:      * @param socket
1:      * @param format
1:      * @param detectedTransportFactory
1:      * @return
1:      */
1:     protected TcpTransport createTransport(Socket socket, WireFormat format,
0:             TcpTransportFactory detectedTransportFactory) throws IOException {
0:         return createTransport(socket, format);
1:     }
1: 
1:     public void setWireFormatOptions(Map<String, Map<String, Object>> wireFormatOptions) {
1:         this.wireFormatOptions = wireFormatOptions;
1:     }
1: 
1:     public void setEnabledProtocols(Set<String> enabledProtocols) {
1:         this.enabledProtocols = enabledProtocols;
1:     }
1: 
1:     public void setAutoTransportOptions(Map<String, Object> autoTransportOptions) {
1:         this.autoTransportOptions = autoTransportOptions;
0:         if (autoTransportOptions.get("protocols") != null)
1:             this.enabledProtocols = AutoTransportUtils.parseProtocols((String) autoTransportOptions.get("protocols"));
1:     }
1: 
1:     protected ProtocolInfo detectProtocol(byte[] buffer) throws IOException {
1:         TcpTransportFactory detectedTransportFactory = transportFactory;
1:         WireFormatFactory detectedWireFormatFactory = wireFormatFactory;
1: 
1:         boolean found = false;
1:         for (String scheme : protocolVerifiers.keySet()) {
1:             if (protocolVerifiers.get(scheme).isProtocol(buffer)) {
0:                 LOG.debug("Detected " + scheme);
1:                 detectedWireFormatFactory = findWireFormatFactory(scheme, wireFormatOptions);
1: 
1:                 if (scheme.equals("default")) {
1:                     scheme = "";
1:                 }
1: 
1:                 detectedTransportFactory = (TcpTransportFactory) findTransportFactory(scheme, transportOptions);
1:                 found = true;
1:                 break;
1:             }
1:         }
1: 
1:         if (!found) {
0:             throw new IllegalStateException("Could not detect wire format");
1:         }
1: 
1:         return new ProtocolInfo(detectedTransportFactory, detectedWireFormatFactory);
1: 
1:     }
1: 
1:     protected class ProtocolInfo {
1:         public final TcpTransportFactory detectedTransportFactory;
1:         public final WireFormatFactory detectedWireFormatFactory;
1: 
1:         public ProtocolInfo(TcpTransportFactory detectedTransportFactory,
1:                 WireFormatFactory detectedWireFormatFactory) {
1:             super();
1:             this.detectedTransportFactory = detectedTransportFactory;
1:             this.detectedWireFormatFactory = detectedWireFormatFactory;
1:         }
1:     }
1: 
1: }
============================================================================