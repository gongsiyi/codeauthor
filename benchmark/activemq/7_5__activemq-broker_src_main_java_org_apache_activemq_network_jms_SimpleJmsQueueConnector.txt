11:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f812e34:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
11:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.network.jms;
8:d29ca2a: 
1:49e8a80: import javax.jms.Connection;
1:d29ca2a: import javax.jms.Destination;
1:bc78238: import javax.jms.ExceptionListener;
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.Queue;
1:d29ca2a: import javax.jms.QueueConnection;
1:d29ca2a: import javax.jms.QueueConnectionFactory;
1:d29ca2a: import javax.jms.QueueSession;
1:d29ca2a: import javax.jms.Session;
1:d29ca2a: import javax.naming.NamingException;
1:74a7a8b: 
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:f812e34: 
1:d29ca2a: /**
1:d29ca2a:  */
1:7c9fec6: public class SimpleJmsQueueConnector extends JmsConnector {
1:7c9fec6:     private static final Logger LOG = LoggerFactory.getLogger(SimpleJmsQueueConnector.class);
1:d29ca2a:     private String outboundQueueConnectionFactoryName;
1:d29ca2a:     private String localConnectionFactoryName;
1:d29ca2a:     private QueueConnectionFactory outboundQueueConnectionFactory;
1:d29ca2a:     private QueueConnectionFactory localQueueConnectionFactory;
1:d29ca2a:     private InboundQueueBridge[] inboundQueueBridges;
1:f812e34:     private OutboundQueueBridge[] outboundQueueBridges;
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the inboundQueueBridges.
1:d29ca2a:      */
1:f812e34:     public InboundQueueBridge[] getInboundQueueBridges() {
1:d29ca2a:         return inboundQueueBridges;
1:f812e34:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * @param inboundQueueBridges The inboundQueueBridges to set.
1:d29ca2a:      */
1:f812e34:     public void setInboundQueueBridges(InboundQueueBridge[] inboundQueueBridges) {
1:f812e34:         this.inboundQueueBridges = inboundQueueBridges;
1:86cbdfd:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the outboundQueueBridges.
1:d29ca2a:      */
1:f812e34:     public OutboundQueueBridge[] getOutboundQueueBridges() {
1:d29ca2a:         return outboundQueueBridges;
12:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * @param outboundQueueBridges The outboundQueueBridges to set.
1:d29ca2a:      */
1:f812e34:     public void setOutboundQueueBridges(OutboundQueueBridge[] outboundQueueBridges) {
1:f812e34:         this.outboundQueueBridges = outboundQueueBridges;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the localQueueConnectionFactory.
1:d29ca2a:      */
1:f812e34:     public QueueConnectionFactory getLocalQueueConnectionFactory() {
1:d29ca2a:         return localQueueConnectionFactory;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5e05df1:      * @param localConnectionFactory The localQueueConnectionFactory to
1:f812e34:      *                set.
1:d29ca2a:      */
1:f812e34:     public void setLocalQueueConnectionFactory(QueueConnectionFactory localConnectionFactory) {
1:f812e34:         this.localQueueConnectionFactory = localConnectionFactory;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the outboundQueueConnectionFactory.
1:d29ca2a:      */
1:f812e34:     public QueueConnectionFactory getOutboundQueueConnectionFactory() {
1:d29ca2a:         return outboundQueueConnectionFactory;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the outboundQueueConnectionFactoryName.
1:d29ca2a:      */
1:f812e34:     public String getOutboundQueueConnectionFactoryName() {
1:d29ca2a:         return outboundQueueConnectionFactoryName;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5e05df1:      * @param foreignQueueConnectionFactoryName The
1:5e05df1:      *                foreignQueueConnectionFactoryName to set.
1:d29ca2a:      */
1:f812e34:     public void setOutboundQueueConnectionFactoryName(String foreignQueueConnectionFactoryName) {
1:f812e34:         this.outboundQueueConnectionFactoryName = foreignQueueConnectionFactoryName;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the localConnectionFactoryName.
1:d29ca2a:      */
1:f812e34:     public String getLocalConnectionFactoryName() {
1:d29ca2a:         return localConnectionFactoryName;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * @param localConnectionFactoryName The localConnectionFactoryName to set.
1:d29ca2a:      */
1:f812e34:     public void setLocalConnectionFactoryName(String localConnectionFactoryName) {
1:f812e34:         this.localConnectionFactoryName = localConnectionFactoryName;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the localQueueConnection.
1:d29ca2a:      */
1:f812e34:     public QueueConnection getLocalQueueConnection() {
1:bc78238:         return (QueueConnection) localConnection.get();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * @param localQueueConnection The localQueueConnection to set.
1:d29ca2a:      */
1:f812e34:     public void setLocalQueueConnection(QueueConnection localQueueConnection) {
1:bc78238:         this.localConnection.set(localQueueConnection);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the outboundQueueConnection.
1:d29ca2a:      */
1:f812e34:     public QueueConnection getOutboundQueueConnection() {
1:bc78238:         return (QueueConnection) foreignConnection.get();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5e05df1:      * @param foreignQueueConnection The foreignQueueConnection to set.
1:d29ca2a:      */
1:f812e34:     public void setOutboundQueueConnection(QueueConnection foreignQueueConnection) {
1:bc78238:         this.foreignConnection.set(foreignQueueConnection);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5e05df1:      * @param foreignQueueConnectionFactory The foreignQueueConnectionFactory to set.
1:d29ca2a:      */
1:f812e34:     public void setOutboundQueueConnectionFactory(QueueConnectionFactory foreignQueueConnectionFactory) {
1:f812e34:         this.outboundQueueConnectionFactory = foreignQueueConnectionFactory;
1:d29ca2a:     }
1:d29ca2a: 
1:5e05df1:     @Override
1:bc78238:     protected void initializeForeignConnection() throws NamingException, JMSException {
1:d29ca2a: 
1:03785a4:         QueueConnection newConnection = null;
1:d29ca2a: 
1:03785a4:         try {
1:03785a4:             if (foreignConnection.get() == null) {
1:03785a4:                 // get the connection factories
1:03785a4:                 if (outboundQueueConnectionFactory == null) {
1:03785a4:                     // look it up from JNDI
1:03785a4:                     if (outboundQueueConnectionFactoryName != null) {
1:03785a4:                         outboundQueueConnectionFactory = jndiOutboundTemplate
1:03785a4:                             .lookup(outboundQueueConnectionFactoryName, QueueConnectionFactory.class);
1:03785a4:                         if (outboundUsername != null) {
1:03785a4:                             newConnection = outboundQueueConnectionFactory
1:03785a4:                                 .createQueueConnection(outboundUsername, outboundPassword);
1:03785a4:                         } else {
1:03785a4:                             newConnection = outboundQueueConnectionFactory.createQueueConnection();
1:03785a4:                         }
1:03785a4:                     } else {
1:03785a4:                         throw new JMSException("Cannot create foreignConnection - no information");
1:03785a4:                     }
1:03785a4:                 } else {
2:f812e34:                     if (outboundUsername != null) {
2:bc78238:                         newConnection = outboundQueueConnectionFactory
2:f812e34:                             .createQueueConnection(outboundUsername, outboundPassword);
2:f812e34:                     } else {
2:bc78238:                         newConnection = outboundQueueConnectionFactory.createQueueConnection();
1:d29ca2a:                     }
1:d29ca2a:                 }
1:f812e34:             } else {
1:03785a4:                 // Clear if for now in case something goes wrong during the init.
1:03785a4:                 newConnection = (QueueConnection) foreignConnection.getAndSet(null);
1:03785a4:             }
1:03785a4: 
1:03785a4:             // Register for any async error notifications now so we can reset in the
1:03785a4:             // case where there's not a lot of activity and a connection drops.
1:03785a4:             newConnection.setExceptionListener(new ExceptionListener() {
1:03785a4:                 @Override
1:03785a4:                 public void onException(JMSException exception) {
1:03785a4:                     handleConnectionFailure(foreignConnection.get());
1:d29ca2a:                 }
1:03785a4:             });
1:03785a4: 
1:03785a4:             if (outboundClientId != null && outboundClientId.length() > 0) {
1:03785a4:                 newConnection.setClientID(getOutboundClientId());
1:d29ca2a:             }
1:03785a4:             newConnection.start();
1:d29ca2a: 
1:03785a4:             outboundMessageConvertor.setConnection(newConnection);
1:d29ca2a: 
1:03785a4:             // Configure the bridges with the new Outbound connection.
1:03785a4:             initializeInboundDestinationBridgesOutboundSide(newConnection);
1:03785a4:             initializeOutboundDestinationBridgesOutboundSide(newConnection);
1:d29ca2a: 
1:03785a4:             // At this point all looks good, so this our current connection now.
1:03785a4:             foreignConnection.set(newConnection);
1:03785a4:         } catch (Exception ex) {
1:03785a4:             if (newConnection != null) {
1:03785a4:                 try {
1:03785a4:                     newConnection.close();
1:03785a4:                 } catch (Exception ignore) {}
1:d29ca2a:             }
1:d29ca2a: 
1:03785a4:             throw ex;
1:03785a4:         }
1:d29ca2a:     }
1:d29ca2a: 
1:bc78238:     @Override
1:bc78238:     protected void initializeLocalConnection() throws NamingException, JMSException {
1:d29ca2a: 
1:03785a4:         QueueConnection newConnection = null;
1:d29ca2a: 
1:03785a4:         try {
1:03785a4:             if (localConnection.get() == null) {
1:03785a4:                 // get the connection factories
1:03785a4:                 if (localQueueConnectionFactory == null) {
1:03785a4:                     if (embeddedConnectionFactory == null) {
1:03785a4:                         // look it up from JNDI
1:03785a4:                         if (localConnectionFactoryName != null) {
1:03785a4:                             localQueueConnectionFactory = jndiLocalTemplate
1:03785a4:                                 .lookup(localConnectionFactoryName, QueueConnectionFactory.class);
1:03785a4:                             if (localUsername != null) {
1:03785a4:                                 newConnection = localQueueConnectionFactory
1:03785a4:                                     .createQueueConnection(localUsername, localPassword);
1:03785a4:                             } else {
1:03785a4:                                 newConnection = localQueueConnectionFactory.createQueueConnection();
1:03785a4:                             }
1:f812e34:                         } else {
1:03785a4:                             throw new JMSException("Cannot create localConnection - no information");
1:f812e34:                         }
1:f812e34:                     } else {
1:03785a4:                         newConnection = embeddedConnectionFactory.createQueueConnection();
1:d29ca2a:                     }
1:f812e34:                 } else {
1:03785a4:                     if (localUsername != null) {
1:03785a4:                         newConnection = localQueueConnectionFactory.
1:03785a4:                                 createQueueConnection(localUsername, localPassword);
1:03785a4:                     } else {
1:03785a4:                         newConnection = localQueueConnectionFactory.createQueueConnection();
1:03785a4:                     }
1:d29ca2a:                 }
1:03785a4: 
1:f812e34:             } else {
1:03785a4:                 // Clear if for now in case something goes wrong during the init.
1:03785a4:                 newConnection = (QueueConnection) localConnection.getAndSet(null);
1:03785a4:             }
1:03785a4: 
1:03785a4:             // Register for any async error notifications now so we can reset in the
1:03785a4:             // case where there's not a lot of activity and a connection drops.
1:03785a4:             newConnection.setExceptionListener(new ExceptionListener() {
1:03785a4:                 @Override
1:03785a4:                 public void onException(JMSException exception) {
1:03785a4:                     handleConnectionFailure(localConnection.get());
1:d29ca2a:                 }
1:03785a4:             });
1:03785a4: 
1:03785a4:             if (localClientId != null && localClientId.length() > 0) {
1:03785a4:                 newConnection.setClientID(getLocalClientId());
1:03785a4:             }
1:03785a4:             newConnection.start();
1:03785a4: 
1:03785a4:             inboundMessageConvertor.setConnection(newConnection);
1:03785a4: 
1:03785a4:             // Configure the bridges with the new Local connection.
1:03785a4:             initializeInboundDestinationBridgesLocalSide(newConnection);
1:03785a4:             initializeOutboundDestinationBridgesLocalSide(newConnection);
1:03785a4: 
1:03785a4:             // At this point all looks good, so this our current connection now.
1:03785a4:             localConnection.set(newConnection);
1:03785a4:         } catch (Exception ex) {
1:03785a4:             if (newConnection != null) {
1:03785a4:                 try {
1:03785a4:                     newConnection.close();
1:03785a4:                 } catch (Exception ignore) {}
1:d29ca2a:             }
1:f812e34: 
1:03785a4:             throw ex;
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:bc78238:     protected void initializeInboundDestinationBridgesOutboundSide(QueueConnection connection) throws JMSException {
1:f812e34:         if (inboundQueueBridges != null) {
1:bc78238:             QueueSession outboundSession = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a: 
1:bc78238:             for (InboundQueueBridge bridge : inboundQueueBridges) {
1:902a8ea:                 String queueName = bridge.getInboundQueueName();
1:f812e34:                 Queue foreignQueue = createForeignQueue(outboundSession, queueName);
1:bc78238:                 bridge.setConsumer(null);
1:d29ca2a:                 bridge.setConsumerQueue(foreignQueue);
1:bc78238:                 bridge.setConsumerConnection(connection);
1:bc78238:                 bridge.setJmsConnector(this);
1:bc78238:                 addInboundBridge(bridge);
1:d29ca2a:             }
1:d29ca2a:             outboundSession.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:bc78238:     protected void initializeInboundDestinationBridgesLocalSide(QueueConnection connection) throws JMSException {
1:bc78238:         if (inboundQueueBridges != null) {
1:bc78238:             QueueSession localSession = connection.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
1:d29ca2a: 
1:bc78238:             for (InboundQueueBridge bridge : inboundQueueBridges) {
1:f812e34:                 String localQueueName = bridge.getLocalQueueName();
1:f812e34:                 Queue activemqQueue = createActiveMQQueue(localSession, localQueueName);
1:d29ca2a:                 bridge.setProducerQueue(activemqQueue);
1:bc78238:                 bridge.setProducerConnection(connection);
1:f812e34:                 if (bridge.getJmsMessageConvertor() == null) {
1:28647f1:                     bridge.setJmsMessageConvertor(getInboundMessageConvertor());
1:d29ca2a:                 }
1:28647f1:                 bridge.setJmsConnector(this);
1:d29ca2a:                 addInboundBridge(bridge);
1:d29ca2a:             }
2:d29ca2a:             localSession.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:bc78238:     protected void initializeOutboundDestinationBridgesOutboundSide(QueueConnection connection) throws JMSException {
1:f812e34:         if (outboundQueueBridges != null) {
1:bc78238:             QueueSession outboundSession = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a: 
1:bc78238:             for (OutboundQueueBridge bridge : outboundQueueBridges) {
1:f812e34:                 String queueName = bridge.getOutboundQueueName();
1:f812e34:                 Queue foreignQueue = createForeignQueue(outboundSession, queueName);
1:d29ca2a:                 bridge.setProducerQueue(foreignQueue);
1:bc78238:                 bridge.setProducerConnection(connection);
1:f812e34:                 if (bridge.getJmsMessageConvertor() == null) {
1:28647f1:                     bridge.setJmsMessageConvertor(getOutboundMessageConvertor());
1:d29ca2a:                 }
1:28647f1:                 bridge.setJmsConnector(this);
1:d29ca2a:                 addOutboundBridge(bridge);
1:d29ca2a:             }
1:d29ca2a:             outboundSession.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:bc78238:     protected void initializeOutboundDestinationBridgesLocalSide(QueueConnection connection) throws JMSException {
1:bc78238:         if (outboundQueueBridges != null) {
1:bc78238:             QueueSession localSession =
1:bc78238:                     connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a: 
1:bc78238:             for (OutboundQueueBridge bridge : outboundQueueBridges) {
1:f812e34:                 String localQueueName = bridge.getLocalQueueName();
1:f812e34:                 Queue activemqQueue = createActiveMQQueue(localSession, localQueueName);
1:bc78238:                 bridge.setConsumer(null);
1:d29ca2a:                 bridge.setConsumerQueue(activemqQueue);
1:bc78238:                 bridge.setConsumerConnection(connection);
1:bc78238:                 bridge.setJmsConnector(this);
1:bc78238:                 addOutboundBridge(bridge);
1:d29ca2a:             }
1:d29ca2a:             localSession.close();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
2:bc78238:     @Override
1:f812e34:     protected Destination createReplyToBridge(Destination destination, Connection replyToProducerConnection,
1:f812e34:                                               Connection replyToConsumerConnection) {
1:f812e34:         Queue replyToProducerQueue = (Queue)destination;
1:bc78238:         boolean isInbound = replyToProducerConnection.equals(localConnection.get());
1:f812e34: 
1:f812e34:         if (isInbound) {
1:f812e34:             InboundQueueBridge bridge = (InboundQueueBridge)replyToBridges.get(replyToProducerQueue);
1:f812e34:             if (bridge == null) {
1:f812e34:                 bridge = new InboundQueueBridge() {
1:5e05df1:                     @Override
1:f812e34:                     protected Destination processReplyToDestination(Destination destination) {
1:f812e34:                         return null;
1:f812e34:                     }
1:f812e34:                 };
1:f812e34:                 try {
1:f812e34:                     QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)
1:f812e34:                         .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:f812e34:                     Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();
1:f812e34:                     replyToConsumerSession.close();
1:f812e34:                     bridge.setConsumerQueue(replyToConsumerQueue);
1:f812e34:                     bridge.setProducerQueue(replyToProducerQueue);
1:f812e34:                     bridge.setProducerConnection((QueueConnection)replyToProducerConnection);
1:f812e34:                     bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);
1:f812e34:                     bridge.setDoHandleReplyTo(false);
1:f812e34:                     if (bridge.getJmsMessageConvertor() == null) {
1:f812e34:                         bridge.setJmsMessageConvertor(getInboundMessageConvertor());
1:f812e34:                     }
1:f812e34:                     bridge.setJmsConnector(this);
1:f812e34:                     bridge.start();
1:e1bbde7:                     LOG.info("Created replyTo bridge for {}", replyToProducerQueue);
1:f812e34:                 } catch (Exception e) {
1:e1bbde7:                     LOG.error("Failed to create replyTo bridge for queue: {}", replyToProducerQueue, e);
1:f812e34:                     return null;
1:f812e34:                 }
1:f812e34:                 replyToBridges.put(replyToProducerQueue, bridge);
1:f812e34:             }
1:f812e34:             return bridge.getConsumerQueue();
1:f812e34:         } else {
1:f812e34:             OutboundQueueBridge bridge = (OutboundQueueBridge)replyToBridges.get(replyToProducerQueue);
1:f812e34:             if (bridge == null) {
1:f812e34:                 bridge = new OutboundQueueBridge() {
1:5e05df1:                     @Override
1:f812e34:                     protected Destination processReplyToDestination(Destination destination) {
1:f812e34:                         return null;
1:f812e34:                     }
1:f812e34:                 };
1:f812e34:                 try {
1:f812e34:                     QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)
1:f812e34:                         .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:f812e34:                     Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();
1:f812e34:                     replyToConsumerSession.close();
1:f812e34:                     bridge.setConsumerQueue(replyToConsumerQueue);
1:f812e34:                     bridge.setProducerQueue(replyToProducerQueue);
1:f812e34:                     bridge.setProducerConnection((QueueConnection)replyToProducerConnection);
1:f812e34:                     bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);
1:f812e34:                     bridge.setDoHandleReplyTo(false);
1:f812e34:                     if (bridge.getJmsMessageConvertor() == null) {
1:f812e34:                         bridge.setJmsMessageConvertor(getOutboundMessageConvertor());
1:f812e34:                     }
1:f812e34:                     bridge.setJmsConnector(this);
1:f812e34:                     bridge.start();
1:e1bbde7:                     LOG.info("Created replyTo bridge for {}", replyToProducerQueue);
2:f812e34:                 } catch (Exception e) {
1:e1bbde7:                     LOG.error("Failed to create replyTo bridge for queue: {}", replyToProducerQueue, e);
1:f812e34:                     return null;
1:f812e34:                 }
1:f812e34:                 replyToBridges.put(replyToProducerQueue, bridge);
1:f812e34:             }
1:f812e34:             return bridge.getConsumerQueue();
1:f812e34:         }
1:d29ca2a:     }
1:f812e34: 
1:f812e34:     protected Queue createActiveMQQueue(QueueSession session, String queueName) throws JMSException {
1:d29ca2a:         return session.createQueue(queueName);
1:d29ca2a:     }
1:f812e34: 
1:f812e34:     protected Queue createForeignQueue(QueueSession session, String queueName) throws JMSException {
1:d29ca2a:         Queue result = null;
1:d29ca2a: 
1:c176fa8:         if (preferJndiDestinationLookup) {
1:f812e34:             try {
2:c176fa8:                 // look-up the Queue
1:5e05df1:                 result = jndiOutboundTemplate.lookup(queueName, Queue.class);
1:c176fa8:             } catch (NamingException e) {
1:f812e34:                 try {
1:d29ca2a:                     result = session.createQueue(queueName);
1:c176fa8:                 } catch (JMSException e1) {
1:c176fa8:                     String errStr = "Failed to look-up or create Queue for name: " + queueName;
2:c176fa8:                     LOG.error(errStr, e);
2:c176fa8:                     JMSException jmsEx = new JMSException(errStr);
2:c176fa8:                     jmsEx.setLinkedException(e1);
2:c176fa8:                     throw jmsEx;
1:d29ca2a:                 }
1:d29ca2a:             }
1:f812e34:         } else {
3:c176fa8:             try {
2:c176fa8:                 result = session.createQueue(queueName);
1:f812e34:             } catch (JMSException e) {
1:f812e34:                 // look-up the Queue
1:f812e34:                 try {
1:5e05df1:                     result = jndiOutboundTemplate.lookup(queueName, Queue.class);
1:f812e34:                 } catch (NamingException e1) {
1:d29ca2a:                     String errStr = "Failed to look-up Queue for name: " + queueName;
1:fc00993:                     LOG.error(errStr, e);
1:f812e34:                     JMSException jmsEx = new JMSException(errStr);
1:d29ca2a:                     jmsEx.setLinkedException(e1);
1:d29ca2a:                     throw jmsEx;
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a: 
2:d29ca2a:         return result;
1:d29ca2a:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:03785a4
/////////////////////////////////////////////////////////////////////////
1:         QueueConnection newConnection = null;
1:         try {
1:             if (foreignConnection.get() == null) {
1:                 // get the connection factories
1:                 if (outboundQueueConnectionFactory == null) {
1:                     // look it up from JNDI
1:                     if (outboundQueueConnectionFactoryName != null) {
1:                         outboundQueueConnectionFactory = jndiOutboundTemplate
1:                             .lookup(outboundQueueConnectionFactoryName, QueueConnectionFactory.class);
1:                         if (outboundUsername != null) {
1:                             newConnection = outboundQueueConnectionFactory
1:                                 .createQueueConnection(outboundUsername, outboundPassword);
1:                         } else {
1:                             newConnection = outboundQueueConnectionFactory.createQueueConnection();
1:                         }
1:                     } else {
1:                         throw new JMSException("Cannot create foreignConnection - no information");
1:                     }
1:                 } else {
1:                 // Clear if for now in case something goes wrong during the init.
1:                 newConnection = (QueueConnection) foreignConnection.getAndSet(null);
1:             }
1: 
1:             // Register for any async error notifications now so we can reset in the
1:             // case where there's not a lot of activity and a connection drops.
1:             newConnection.setExceptionListener(new ExceptionListener() {
1:                 @Override
1:                 public void onException(JMSException exception) {
1:                     handleConnectionFailure(foreignConnection.get());
1:             });
1: 
1:             if (outboundClientId != null && outboundClientId.length() > 0) {
1:                 newConnection.setClientID(getOutboundClientId());
1:             newConnection.start();
1:             outboundMessageConvertor.setConnection(newConnection);
1:             // Configure the bridges with the new Outbound connection.
1:             initializeInboundDestinationBridgesOutboundSide(newConnection);
1:             initializeOutboundDestinationBridgesOutboundSide(newConnection);
1:             // At this point all looks good, so this our current connection now.
1:             foreignConnection.set(newConnection);
1:         } catch (Exception ex) {
1:             if (newConnection != null) {
1:                 try {
1:                     newConnection.close();
1:                 } catch (Exception ignore) {}
1:             throw ex;
1:         }
1:         QueueConnection newConnection = null;
1:         try {
1:             if (localConnection.get() == null) {
1:                 // get the connection factories
1:                 if (localQueueConnectionFactory == null) {
1:                     if (embeddedConnectionFactory == null) {
1:                         // look it up from JNDI
1:                         if (localConnectionFactoryName != null) {
1:                             localQueueConnectionFactory = jndiLocalTemplate
1:                                 .lookup(localConnectionFactoryName, QueueConnectionFactory.class);
1:                             if (localUsername != null) {
1:                                 newConnection = localQueueConnectionFactory
1:                                     .createQueueConnection(localUsername, localPassword);
1:                             } else {
1:                                 newConnection = localQueueConnectionFactory.createQueueConnection();
1:                             }
1:                             throw new JMSException("Cannot create localConnection - no information");
1:                         newConnection = embeddedConnectionFactory.createQueueConnection();
1:                     if (localUsername != null) {
1:                         newConnection = localQueueConnectionFactory.
1:                                 createQueueConnection(localUsername, localPassword);
1:                     } else {
1:                         newConnection = localQueueConnectionFactory.createQueueConnection();
1:                     }
1: 
1:                 // Clear if for now in case something goes wrong during the init.
1:                 newConnection = (QueueConnection) localConnection.getAndSet(null);
1:             }
1: 
1:             // Register for any async error notifications now so we can reset in the
1:             // case where there's not a lot of activity and a connection drops.
1:             newConnection.setExceptionListener(new ExceptionListener() {
1:                 @Override
1:                 public void onException(JMSException exception) {
1:                     handleConnectionFailure(localConnection.get());
1:             });
1: 
1:             if (localClientId != null && localClientId.length() > 0) {
1:                 newConnection.setClientID(getLocalClientId());
1:             }
1:             newConnection.start();
1: 
1:             inboundMessageConvertor.setConnection(newConnection);
1: 
1:             // Configure the bridges with the new Local connection.
1:             initializeInboundDestinationBridgesLocalSide(newConnection);
1:             initializeOutboundDestinationBridgesLocalSide(newConnection);
1: 
1:             // At this point all looks good, so this our current connection now.
1:             localConnection.set(newConnection);
1:         } catch (Exception ex) {
1:             if (newConnection != null) {
1:                 try {
1:                     newConnection.close();
1:                 } catch (Exception ignore) {}
1:             throw ex;
commit:5e05df1
/////////////////////////////////////////////////////////////////////////
1:      * @param localConnectionFactory The localQueueConnectionFactory to
/////////////////////////////////////////////////////////////////////////
1:      * @param foreignQueueConnectionFactoryName The
1:      *                foreignQueueConnectionFactoryName to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param foreignQueueConnection The foreignQueueConnection to set.
1:      * @param foreignQueueConnectionFactory The foreignQueueConnectionFactory to set.
/////////////////////////////////////////////////////////////////////////
0:                     outboundQueueConnectionFactory = jndiOutboundTemplate
/////////////////////////////////////////////////////////////////////////
0:                         localQueueConnectionFactory = jndiLocalTemplate
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                 result = jndiOutboundTemplate.lookup(queueName, Queue.class);
/////////////////////////////////////////////////////////////////////////
1:                     result = jndiOutboundTemplate.lookup(queueName, Queue.class);
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Created replyTo bridge for {}", replyToProducerQueue);
1:                     LOG.error("Failed to create replyTo bridge for queue: {}", replyToProducerQueue, e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.info("Created replyTo bridge for {}", replyToProducerQueue);
1:                     LOG.error("Failed to create replyTo bridge for queue: {}", replyToProducerQueue, e);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:7c9fec6
/////////////////////////////////////////////////////////////////////////
1: public class SimpleJmsQueueConnector extends JmsConnector {
1:     private static final Logger LOG = LoggerFactory.getLogger(SimpleJmsQueueConnector.class);
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(JmsQueueConnector.class);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Failed to initialize the JMSConnector", e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Created replyTo bridge for " + replyToProducerQueue);
0:                     LOG.error("Failed to create replyTo bridge for queue: " + replyToProducerQueue, e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.info("Created replyTo bridge for " + replyToProducerQueue);
0:                     LOG.error("Failed to create replyTo bridge for queue: " + replyToProducerQueue, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error(errStr, e);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
1:  * 
0: public class JmsQueueConnector extends JmsConnector {
0:     private static final Log log = LogFactory.getLog(JmsQueueConnector.class);
/////////////////////////////////////////////////////////////////////////
1:     private OutboundQueueBridge[] outboundQueueBridges;
0:     public boolean init() {
0:         boolean result = super.init();
0:         if (result) {
1:             try {
1:             } catch (Exception e) {
0:                 log.error("Failed to initialize the JMSConnector", e);
1:     }
1:     public InboundQueueBridge[] getInboundQueueBridges() {
1:      * @param inboundQueueBridges The inboundQueueBridges to set.
1:     public void setInboundQueueBridges(InboundQueueBridge[] inboundQueueBridges) {
1:         this.inboundQueueBridges = inboundQueueBridges;
1:     public OutboundQueueBridge[] getOutboundQueueBridges() {
1:      * @param outboundQueueBridges The outboundQueueBridges to set.
1:     public void setOutboundQueueBridges(OutboundQueueBridge[] outboundQueueBridges) {
1:         this.outboundQueueBridges = outboundQueueBridges;
1:     public QueueConnectionFactory getLocalQueueConnectionFactory() {
0:      * @param localQueueConnectionFactory The localQueueConnectionFactory to
1:      *                set.
1:     public void setLocalQueueConnectionFactory(QueueConnectionFactory localConnectionFactory) {
1:         this.localQueueConnectionFactory = localConnectionFactory;
1:     public QueueConnectionFactory getOutboundQueueConnectionFactory() {
1:     public String getOutboundQueueConnectionFactoryName() {
0:      * @param outboundQueueConnectionFactoryName The
0:      *                outboundQueueConnectionFactoryName to set.
1:     public void setOutboundQueueConnectionFactoryName(String foreignQueueConnectionFactoryName) {
1:         this.outboundQueueConnectionFactoryName = foreignQueueConnectionFactoryName;
1:     public String getLocalConnectionFactoryName() {
1:      * @param localConnectionFactoryName The localConnectionFactoryName to set.
1:     public void setLocalConnectionFactoryName(String localConnectionFactoryName) {
1:         this.localConnectionFactoryName = localConnectionFactoryName;
1:     public QueueConnection getLocalQueueConnection() {
1:      * @param localQueueConnection The localQueueConnection to set.
1:     public void setLocalQueueConnection(QueueConnection localQueueConnection) {
0:         this.localQueueConnection = localQueueConnection;
1:     public QueueConnection getOutboundQueueConnection() {
0:      * @param outboundQueueConnection The outboundQueueConnection to set.
1:     public void setOutboundQueueConnection(QueueConnection foreignQueueConnection) {
0:         this.outboundQueueConnection = foreignQueueConnection;
0:      * @param outboundQueueConnectionFactory The outboundQueueConnectionFactory
0:      *                to set.
1:     public void setOutboundQueueConnectionFactory(QueueConnectionFactory foreignQueueConnectionFactory) {
1:         this.outboundQueueConnectionFactory = foreignQueueConnectionFactory;
/////////////////////////////////////////////////////////////////////////
0:     protected void initializeForeignQueueConnection() throws NamingException, JMSException {
0:         if (outboundQueueConnection == null) {
0:             if (outboundQueueConnectionFactory == null) {
0:                 if (outboundQueueConnectionFactoryName != null) {
0:                     outboundQueueConnectionFactory = (QueueConnectionFactory)jndiOutboundTemplate
0:                         .lookup(outboundQueueConnectionFactoryName, QueueConnectionFactory.class);
1:                     if (outboundUsername != null) {
0:                         outboundQueueConnection = outboundQueueConnectionFactory
1:                             .createQueueConnection(outboundUsername, outboundPassword);
1:                     } else {
0:                         outboundQueueConnection = outboundQueueConnectionFactory.createQueueConnection();
1:                 } else {
1:             } else {
1:                 if (outboundUsername != null) {
0:                     outboundQueueConnection = outboundQueueConnectionFactory
1:                         .createQueueConnection(outboundUsername, outboundPassword);
1:                 } else {
0:                     outboundQueueConnection = outboundQueueConnectionFactory.createQueueConnection();
0:     protected void initializeLocalQueueConnection() throws NamingException, JMSException {
0:         if (localQueueConnection == null) {
0:             if (localQueueConnectionFactory == null) {
0:                 if (embeddedConnectionFactory == null) {
0:                     if (localConnectionFactoryName != null) {
0:                         localQueueConnectionFactory = (QueueConnectionFactory)jndiLocalTemplate
0:                             .lookup(localConnectionFactoryName, QueueConnectionFactory.class);
0:                         if (localUsername != null) {
0:                             localQueueConnection = localQueueConnectionFactory
0:                                 .createQueueConnection(localUsername, localPassword);
1:                         } else {
0:                             localQueueConnection = localQueueConnectionFactory.createQueueConnection();
1:                     } else {
1:                 } else {
1:             } else {
0:                 if (localUsername != null) {
0:                     localQueueConnection = localQueueConnectionFactory.createQueueConnection(localUsername,
0:                                                                                              localPassword);
1:                 } else {
0:                     localQueueConnection = localQueueConnectionFactory.createQueueConnection();
1: 
0:     protected void initializeInboundJmsMessageConvertor() {
0:         inboundMessageConvertor.setConnection(localQueueConnection);
0:     protected void initializeOutboundJmsMessageConvertor() {
0:         outboundMessageConvertor.setConnection(outboundQueueConnection);
1:     }
1: 
0:     protected void initializeInboundQueueBridges() throws JMSException {
1:         if (inboundQueueBridges != null) {
0:             QueueSession outboundSession = outboundQueueConnection
1:                 .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
0:             QueueSession localSession = localQueueConnection.createQueueSession(false,
0:                                                                                 Session.AUTO_ACKNOWLEDGE);
0:             for (int i = 0; i < inboundQueueBridges.length; i++) {
0:                 InboundQueueBridge bridge = inboundQueueBridges[i];
1:                 String localQueueName = bridge.getLocalQueueName();
1:                 Queue activemqQueue = createActiveMQQueue(localSession, localQueueName);
1:                 Queue foreignQueue = createForeignQueue(outboundSession, queueName);
1:                 if (bridge.getJmsMessageConvertor() == null) {
/////////////////////////////////////////////////////////////////////////
0:     protected void initializeOutboundQueueBridges() throws JMSException {
1:         if (outboundQueueBridges != null) {
0:             QueueSession outboundSession = outboundQueueConnection
1:                 .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
0:             QueueSession localSession = localQueueConnection.createQueueSession(false,
0:                                                                                 Session.AUTO_ACKNOWLEDGE);
0:             for (int i = 0; i < outboundQueueBridges.length; i++) {
0:                 OutboundQueueBridge bridge = outboundQueueBridges[i];
1:                 String localQueueName = bridge.getLocalQueueName();
1:                 Queue activemqQueue = createActiveMQQueue(localSession, localQueueName);
1:                 String queueName = bridge.getOutboundQueueName();
1:                 Queue foreignQueue = createForeignQueue(outboundSession, queueName);
1:                 if (bridge.getJmsMessageConvertor() == null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected Destination createReplyToBridge(Destination destination, Connection replyToProducerConnection,
1:                                               Connection replyToConsumerConnection) {
1:         Queue replyToProducerQueue = (Queue)destination;
0:         boolean isInbound = replyToProducerConnection.equals(localQueueConnection);
1: 
1:         if (isInbound) {
1:             InboundQueueBridge bridge = (InboundQueueBridge)replyToBridges.get(replyToProducerQueue);
1:             if (bridge == null) {
1:                 bridge = new InboundQueueBridge() {
1:                     protected Destination processReplyToDestination(Destination destination) {
1:                         return null;
1:                     }
1:                 };
1:                 try {
1:                     QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)
0:                         .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:                     Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();
1:                     replyToConsumerSession.close();
1:                     bridge.setConsumerQueue(replyToConsumerQueue);
1:                     bridge.setProducerQueue(replyToProducerQueue);
1:                     bridge.setProducerConnection((QueueConnection)replyToProducerConnection);
1:                     bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);
1:                     bridge.setDoHandleReplyTo(false);
1:                     if (bridge.getJmsMessageConvertor() == null) {
1:                         bridge.setJmsMessageConvertor(getInboundMessageConvertor());
1:                     }
1:                     bridge.setJmsConnector(this);
1:                     bridge.start();
0:                     log.info("Created replyTo bridge for " + replyToProducerQueue);
1:                 } catch (Exception e) {
0:                     log.error("Failed to create replyTo bridge for queue: " + replyToProducerQueue, e);
1:                     return null;
1:                 }
1:                 replyToBridges.put(replyToProducerQueue, bridge);
1:             }
1:             return bridge.getConsumerQueue();
0:         } else {
1:             OutboundQueueBridge bridge = (OutboundQueueBridge)replyToBridges.get(replyToProducerQueue);
1:             if (bridge == null) {
1:                 bridge = new OutboundQueueBridge() {
1:                     protected Destination processReplyToDestination(Destination destination) {
1:                         return null;
1:                     }
1:                 };
1:                 try {
1:                     QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection)
0:                         .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:                     Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();
1:                     replyToConsumerSession.close();
1:                     bridge.setConsumerQueue(replyToConsumerQueue);
1:                     bridge.setProducerQueue(replyToProducerQueue);
1:                     bridge.setProducerConnection((QueueConnection)replyToProducerConnection);
1:                     bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);
1:                     bridge.setDoHandleReplyTo(false);
1:                     if (bridge.getJmsMessageConvertor() == null) {
1:                         bridge.setJmsMessageConvertor(getOutboundMessageConvertor());
1:                     }
1:                     bridge.setJmsConnector(this);
1:                     bridge.start();
0:                     log.info("Created replyTo bridge for " + replyToProducerQueue);
1:                 } catch (Exception e) {
0:                     log.error("Failed to create replyTo bridge for queue: " + replyToProducerQueue, e);
1:                     return null;
1:                 }
1:                 replyToBridges.put(replyToProducerQueue, bridge);
1:             }
1:             return bridge.getConsumerQueue();
1:         }
1: 
1:     protected Queue createActiveMQQueue(QueueSession session, String queueName) throws JMSException {
1: 
1:     protected Queue createForeignQueue(QueueSession session, String queueName) throws JMSException {
1:         try {
1:         } catch (JMSException e) {
1:             // look-up the Queue
1:             try {
0:                 result = (Queue)jndiOutboundTemplate.lookup(queueName, Queue.class);
1:             } catch (NamingException e1) {
0:                 log.error(errStr, e);
1:                 JMSException jmsEx = new JMSException(errStr);
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: }
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:68d245f
/////////////////////////////////////////////////////////////////////////
0:  * @org.apache.xbean.XBean
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.network.jms;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Queue;
1: import javax.jms.QueueConnection;
1: import javax.jms.QueueConnectionFactory;
1: import javax.jms.QueueSession;
1: import javax.jms.Session;
1: import javax.naming.NamingException;
1: /**
0:  * A Bridge to other JMS Queue providers
0:  * 
0:  * @org.xbean.XBean
0:  *
0:  * @version $Revision: 1.1.1.1 $
1:  */
0: public class JmsQueueConnector extends JmsConnector{
0:     private static final Log log=LogFactory.getLog(JmsQueueConnector.class);
1:     private String outboundQueueConnectionFactoryName;
1:     private String localConnectionFactoryName;
1:     private QueueConnectionFactory outboundQueueConnectionFactory;
1:     private QueueConnectionFactory localQueueConnectionFactory;
0:     private QueueConnection outboundQueueConnection;
0:     private QueueConnection localQueueConnection;
1:     private InboundQueueBridge[] inboundQueueBridges;
0:     private OutboundQueueBridge[] outboundQueueBridges;
0:     private String outboundUsername;
0:     private String outboundPassword;
0:     private String localUsername;
0:     private String localPassword;
1:    
1:    
1:    
1: 
0:     public boolean init(){
0:         boolean result=super.init();
0:         if(result){
0:             try{
0:                 initializeForeignQueueConnection();
0:                 initializeLocalQueueConnection();
0:                 initializeInboundQueueBridges();
0:                 initializeOutboundQueueBridges();
0:             }catch(Exception e){
0:                 log.error("Failed to initialize the JMSConnector",e);
1:             }
1:         }
1:         return result;
1:     }   
1:     
1: 
1:     
1:     /**
1:      * @return Returns the inboundQueueBridges.
1:      */
0:     public InboundQueueBridge[] getInboundQueueBridges(){
1:         return inboundQueueBridges;
1:     }
1: 
1:     /**
0:      * @param inboundQueueBridges
0:      *            The inboundQueueBridges to set.
1:      */
0:     public void setInboundQueueBridges(InboundQueueBridge[] inboundQueueBridges){
0:         this.inboundQueueBridges=inboundQueueBridges;
1:     }
1: 
1:     /**
1:      * @return Returns the outboundQueueBridges.
1:      */
0:     public OutboundQueueBridge[] getOutboundQueueBridges(){
1:         return outboundQueueBridges;
1:     }
1: 
1:     /**
0:      * @param outboundQueueBridges
0:      *            The outboundQueueBridges to set.
1:      */
0:     public void setOutboundQueueBridges(OutboundQueueBridge[] outboundQueueBridges){
0:         this.outboundQueueBridges=outboundQueueBridges;
1:     }
1: 
1:     /**
1:      * @return Returns the localQueueConnectionFactory.
1:      */
0:     public QueueConnectionFactory getLocalQueueConnectionFactory(){
1:         return localQueueConnectionFactory;
1:     }
1: 
1:     /**
0:      * @param localQueueConnectionFactory
0:      *            The localQueueConnectionFactory to set.
1:      */
0:     public void setLocalQueueConnectionFactory(QueueConnectionFactory localConnectionFactory){
0:         this.localQueueConnectionFactory=localConnectionFactory;
1:     }
1: 
1:     /**
1:      * @return Returns the outboundQueueConnectionFactory.
1:      */
0:     public QueueConnectionFactory getOutboundQueueConnectionFactory(){
1:         return outboundQueueConnectionFactory;
1:     }
1: 
1:     /**
1:      * @return Returns the outboundQueueConnectionFactoryName.
1:      */
0:     public String getOutboundQueueConnectionFactoryName(){
1:         return outboundQueueConnectionFactoryName;
1:     }
1: 
1:     /**
0:      * @param outboundQueueConnectionFactoryName
0:      *            The outboundQueueConnectionFactoryName to set.
1:      */
0:     public void setOutboundQueueConnectionFactoryName(String foreignQueueConnectionFactoryName){
0:         this.outboundQueueConnectionFactoryName=foreignQueueConnectionFactoryName;
1:     }
1: 
1:     /**
1:      * @return Returns the localConnectionFactoryName.
1:      */
0:     public String getLocalConnectionFactoryName(){
1:         return localConnectionFactoryName;
1:     }
1: 
1:     /**
0:      * @param localConnectionFactoryName
0:      *            The localConnectionFactoryName to set.
1:      */
0:     public void setLocalConnectionFactoryName(String localConnectionFactoryName){
0:         this.localConnectionFactoryName=localConnectionFactoryName;
1:     }
1: 
1:     /**
1:      * @return Returns the localQueueConnection.
1:      */
0:     public QueueConnection getLocalQueueConnection(){
0:         return localQueueConnection;
1:     }
1: 
1:     /**
0:      * @param localQueueConnection
0:      *            The localQueueConnection to set.
1:      */
0:     public void setLocalQueueConnection(QueueConnection localQueueConnection){
0:         this.localQueueConnection=localQueueConnection;
1:     }
1: 
1:     /**
1:      * @return Returns the outboundQueueConnection.
1:      */
0:     public QueueConnection getOutboundQueueConnection(){
0:         return outboundQueueConnection;
1:     }
1: 
1:     /**
0:      * @param outboundQueueConnection
0:      *            The outboundQueueConnection to set.
1:      */
0:     public void setOutboundQueueConnection(QueueConnection foreignQueueConnection){
0:         this.outboundQueueConnection=foreignQueueConnection;
1:     }
1: 
1:     /**
0:      * @param outboundQueueConnectionFactory
0:      *            The outboundQueueConnectionFactory to set.
1:      */
0:     public void setOutboundQueueConnectionFactory(QueueConnectionFactory foreignQueueConnectionFactory){
0:         this.outboundQueueConnectionFactory=foreignQueueConnectionFactory;
1:     }
1: 
1:     /**
0:      * @return Returns the outboundPassword.
1:      */
0:     public String getOutboundPassword(){
0:         return outboundPassword;
1:     }
1: 
1:     /**
0:      * @param outboundPassword
0:      *            The outboundPassword to set.
1:      */
0:     public void setOutboundPassword(String foreignPassword){
0:         this.outboundPassword=foreignPassword;
1:     }
1: 
1:     /**
0:      * @return Returns the outboundUsername.
1:      */
0:     public String getOutboundUsername(){
0:         return outboundUsername;
1:     }
1: 
1:     /**
0:      * @param outboundUsername
0:      *            The outboundUsername to set.
1:      */
0:     public void setOutboundUsername(String foreignUsername){
0:         this.outboundUsername=foreignUsername;
1:     }
1: 
1:     /**
0:      * @return Returns the localPassword.
1:      */
0:     public String getLocalPassword(){
0:         return localPassword;
1:     }
1: 
1:     /**
0:      * @param localPassword
0:      *            The localPassword to set.
1:      */
0:     public void setLocalPassword(String localPassword){
0:         this.localPassword=localPassword;
1:     }
1: 
1:     /**
0:      * @return Returns the localUsername.
1:      */
0:     public String getLocalUsername(){
0:         return localUsername;
1:     }
1: 
1:     /**
0:      * @param localUsername
0:      *            The localUsername to set.
1:      */
0:     public void setLocalUsername(String localUsername){
0:         this.localUsername=localUsername;
1:     }
1:     
1:     /**
0:      * @return Returns the replyToDestinationCacheSize.
1:      */
0:     public int getReplyToDestinationCacheSize(){
0:         return replyToDestinationCacheSize;
1:     }
1: 
1:     /**
0:      * @param replyToDestinationCacheSize The replyToDestinationCacheSize to set.
1:      */
0:     public void setReplyToDestinationCacheSize(int temporaryQueueCacheSize){
0:         this.replyToDestinationCacheSize=temporaryQueueCacheSize;
1:     }
1: 
0:     protected void initializeForeignQueueConnection() throws NamingException,JMSException{
0:         if(outboundQueueConnection==null){
0:             // get the connection factories
0:             if(outboundQueueConnectionFactory==null){
0:                 // look it up from JNDI
0:                 if(outboundQueueConnectionFactoryName!=null){
0:                     outboundQueueConnectionFactory=(QueueConnectionFactory) jndiTemplate.lookup(
0:                                     outboundQueueConnectionFactoryName,QueueConnectionFactory.class);
0:                     if(outboundUsername!=null){
0:                         outboundQueueConnection=outboundQueueConnectionFactory.createQueueConnection(outboundUsername,
0:                                         outboundPassword);
0:                     }else{
0:                         outboundQueueConnection=outboundQueueConnectionFactory.createQueueConnection();
1:                     }
0:                 }else {
0:                     throw new JMSException("Cannot create localConnection - no information");
1:                 }
0:             }else {
0:                 if(outboundUsername!=null){
0:                     outboundQueueConnection=outboundQueueConnectionFactory.createQueueConnection(outboundUsername,
0:                                     outboundPassword);
0:                 }else{
0:                     outboundQueueConnection=outboundQueueConnectionFactory.createQueueConnection();
1:                 }
1:             }
1:         }
0:         outboundQueueConnection.start();
1:     }
1: 
0:     protected void initializeLocalQueueConnection() throws NamingException,JMSException{
0:         if(localQueueConnection==null){
0:             // get the connection factories
0:             if(localQueueConnectionFactory==null){
0:                 if(embeddedConnectionFactory==null){
0:                     // look it up from JNDI
0:                     if(localConnectionFactoryName!=null){
0:                         localQueueConnectionFactory=(QueueConnectionFactory) jndiTemplate.lookup(
0:                                         localConnectionFactoryName,QueueConnectionFactory.class);
0:                         if(localUsername!=null){
0:                             localQueueConnection=localQueueConnectionFactory.createQueueConnection(localUsername,
0:                                             localPassword);
0:                         }else{
0:                             localQueueConnection=localQueueConnectionFactory.createQueueConnection();
1:                         }
0:                     }else {
0:                         throw new JMSException("Cannot create localConnection - no information");
1:                     }
0:                 }else{
0:                     localQueueConnection = embeddedConnectionFactory.createQueueConnection();
1:                 }
0:             }else {
0:                 if(localUsername!=null){
0:                     localQueueConnection=localQueueConnectionFactory.createQueueConnection(localUsername,
0:                                     localPassword);
0:                 }else{
0:                     localQueueConnection=localQueueConnectionFactory.createQueueConnection();
1:                 }
1:             }
1:         }
0:         localQueueConnection.start();
1:     }
1: 
0:     protected void initializeInboundQueueBridges() throws JMSException{
0:         if(inboundQueueBridges!=null){
0:             QueueSession outboundSession = outboundQueueConnection.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0:             QueueSession localSession = localQueueConnection.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0:             for(int i=0;i<inboundQueueBridges.length;i++){
0:                 InboundQueueBridge bridge=inboundQueueBridges[i];
0:                 String queueName=bridge.getInboundQueueName();
0:                 Queue activemqQueue=createActiveMQQueue(localSession,queueName);
0:                 Queue foreignQueue=createForeignQueue(outboundSession,queueName);
1:                 bridge.setConsumerQueue(foreignQueue);
1:                 bridge.setProducerQueue(activemqQueue);
0:                 bridge.setProducerConnection(localQueueConnection);
0:                 bridge.setConsumerConnection(outboundQueueConnection);
0:                 if(bridge.getJmsMessageConvertor()==null){
0:                     bridge.setJmsMessageConvertor(getJmsMessageConvertor());
1:                 }
0:                 bridge.setJmsQueueConnector(this);
1:                 addInboundBridge(bridge);
1:             }
1:             outboundSession.close();
1:             localSession.close();
1:         }
1:     }
1: 
0:     protected void initializeOutboundQueueBridges() throws JMSException{
0:         if(outboundQueueBridges!=null){
0:             QueueSession outboundSession = outboundQueueConnection.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0:             QueueSession localSession = localQueueConnection.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0:             for(int i=0;i<outboundQueueBridges.length;i++){
0:                 OutboundQueueBridge bridge=outboundQueueBridges[i];
0:                 String queueName=bridge.getOutboundQueueName();
0:                 Queue activemqQueue=createActiveMQQueue(localSession,queueName);
0:                 Queue foreignQueue=createForeignQueue(outboundSession,queueName);
1:                 bridge.setConsumerQueue(activemqQueue);
1:                 bridge.setProducerQueue(foreignQueue);
0:                 bridge.setProducerConnection(outboundQueueConnection);
0:                 bridge.setConsumerConnection(localQueueConnection);
0:                 bridge.setDoHandleReplyTo(false);
0:                 if(bridge.getJmsMessageConvertor()==null){
0:                     bridge.setJmsMessageConvertor(getJmsMessageConvertor());
1:                 }
0:                 bridge.setJmsQueueConnector(this);
1:                 addOutboundBridge(bridge);
1:             }
1:             outboundSession.close();
1:             localSession.close();
1:         }
1:     }
1:     
0:     protected Destination createReplyToQueueBridge(Queue queue, QueueConnection consumerConnection, QueueConnection producerConnection){
0:         OutboundQueueBridge bridge = (OutboundQueueBridge) replyToBridges.get(queue);
0:         if (bridge == null){
0:             bridge = new OutboundQueueBridge(){
0:                 //we only handle replyTo destinations - inbound
0:                 protected Destination processReplyToDestination (Destination destination){
0:                     return null;
1:                 }
0:             };
0:             try{
0:                 QueueSession localSession = localQueueConnection.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0:                 Queue localQueue = localSession.createTemporaryQueue();
1:                 localSession.close();
0:                 bridge.setConsumerQueue(localQueue);
0:                 bridge.setProducerQueue(queue);
0:                 bridge.setProducerConnection(outboundQueueConnection);
0:                 bridge.setConsumerConnection(localQueueConnection);
0:                 bridge.setDoHandleReplyTo(false);
0:                 if(bridge.getJmsMessageConvertor()==null){
0:                     bridge.setJmsMessageConvertor(getJmsMessageConvertor());
1:                 }
0:                 bridge.setJmsQueueConnector(this);
0:                 bridge.start();
0:                 log.info("Created replyTo bridge for " + queue);
0:             }catch(Exception e){
0:                log.error("Failed to create replyTo bridge for queue: " + queue,e);
0:                return null;
1:             }
0:             replyToBridges.put(queue, bridge);
1:         }
0:         return bridge.getConsumerQueue();
1:     }
1:     
0:     protected Queue createActiveMQQueue(QueueSession session,String queueName) throws JMSException{
1:         return session.createQueue(queueName);
1:     }
1:     
0:     protected Queue createForeignQueue(QueueSession session,String queueName) throws JMSException{
1:         Queue result = null;
0:         try{
1:             result = session.createQueue(queueName);
0:         }catch(JMSException e){
0:             //look-up the Queue
0:             try{
0:                 result = (Queue) jndiTemplate.lookup(queueName, Queue.class);
0:             }catch(NamingException e1){
1:                 String errStr = "Failed to look-up Queue for name: " + queueName;
0:                 log.error(errStr,e);
0:                 JMSException jmsEx =  new JMSException(errStr);
1:                 jmsEx.setLinkedException(e1);
1:                 throw jmsEx;
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c176fa8
/////////////////////////////////////////////////////////////////////////
0: 
1:         if (preferJndiDestinationLookup) {
1:                 // look-up the Queue
1:             } catch (NamingException e) {
1:                 try {
1:                     result = session.createQueue(queueName);
1:                 } catch (JMSException e1) {
1:                     String errStr = "Failed to look-up or create Queue for name: " + queueName;
1:                     LOG.error(errStr, e);
1:                     JMSException jmsEx = new JMSException(errStr);
1:                     jmsEx.setLinkedException(e1);
1:                     throw jmsEx;
0:                 }
0:             }
0:         } else {
1:             try {
1:                 result = session.createQueue(queueName);
0:             } catch (JMSException e) {
1:                 // look-up the Queue
1:                 try {
0:                     result = (Queue)jndiOutboundTemplate.lookup(queueName, Queue.class);
0:                 } catch (NamingException e1) {
0:                     String errStr = "Failed to look-up Queue for name: " + queueName;
1:                     LOG.error(errStr, e);
1:                     JMSException jmsEx = new JMSException(errStr);
1:                     jmsEx.setLinkedException(e1);
1:                     throw jmsEx;
0:                 }
0: 
commit:bc78238
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.ExceptionListener;
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return (QueueConnection) localConnection.get();
1:         this.localConnection.set(localQueueConnection);
1:         return (QueueConnection) foreignConnection.get();
1:         this.foreignConnection.set(foreignQueueConnection);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected void initializeForeignConnection() throws NamingException, JMSException {
0:         final QueueConnection newConnection;
0:         if (foreignConnection.get() == null) {
/////////////////////////////////////////////////////////////////////////
1:                         newConnection = outboundQueueConnectionFactory
1:                         newConnection = outboundQueueConnectionFactory.createQueueConnection();
1:                     newConnection = outboundQueueConnectionFactory
1:                     newConnection = outboundQueueConnectionFactory.createQueueConnection();
0:         } else {
0:             // Clear if for now in case something goes wrong during the init.
0:             newConnection = (QueueConnection) foreignConnection.getAndSet(null);
0: 
0:         if (outboundClientId != null && outboundClientId.length() > 0) {
0:             newConnection.setClientID(getOutboundClientId());
0:         newConnection.start();
0: 
0:         outboundMessageConvertor.setConnection(newConnection);
0: 
0:         // Configure the bridges with the new Outbound connection.
0:         initializeInboundDestinationBridgesOutboundSide(newConnection);
0:         initializeOutboundDestinationBridgesOutboundSide(newConnection);
0: 
0:         // Register for any async error notifications now so we can reset in the
0:         // case where there's not a lot of activity and a connection drops.
0:         newConnection.setExceptionListener(new ExceptionListener() {
1:             @Override
0:             public void onException(JMSException exception) {
0:                 handleConnectionFailure(newConnection);
0:             }
0:         });
0: 
0:         // At this point all looks good, so this our current connection now.
0:         foreignConnection.set(newConnection);
1:     @Override
1:     protected void initializeLocalConnection() throws NamingException, JMSException {
0: 
0:         final QueueConnection newConnection;
0: 
0:         if (localConnection.get() == null) {
/////////////////////////////////////////////////////////////////////////
0:                             newConnection = localQueueConnectionFactory
0:                             newConnection = localQueueConnectionFactory.createQueueConnection();
0:                     newConnection = embeddedConnectionFactory.createQueueConnection();
0:                     newConnection = localQueueConnectionFactory.
0:                             createQueueConnection(localUsername, localPassword);
0:                     newConnection = localQueueConnectionFactory.createQueueConnection();
0: 
0:         } else {
0:             // Clear if for now in case something goes wrong during the init.
0:             newConnection = (QueueConnection) localConnection.getAndSet(null);
0: 
0:             newConnection.setClientID(getLocalClientId());
0:         newConnection.start();
0: 
0:         inboundMessageConvertor.setConnection(newConnection);
0: 
0:         // Configure the bridges with the new Local connection.
0:         initializeInboundDestinationBridgesLocalSide(newConnection);
0:         initializeOutboundDestinationBridgesLocalSide(newConnection);
0: 
0:         // Register for any async error notifications now so we can reset in the
0:         // case where there's not a lot of activity and a connection drops.
0:         newConnection.setExceptionListener(new ExceptionListener() {
0:             @Override
0:             public void onException(JMSException exception) {
0:                 handleConnectionFailure(newConnection);
0:             }
0:         });
0: 
0:         // At this point all looks good, so this our current connection now.
0:         localConnection.set(newConnection);
1:     protected void initializeInboundDestinationBridgesOutboundSide(QueueConnection connection) throws JMSException {
1:             QueueSession outboundSession = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
1:             for (InboundQueueBridge bridge : inboundQueueBridges) {
1:                 bridge.setConsumer(null);
1:                 bridge.setConsumerConnection(connection);
1:                 bridge.setJmsConnector(this);
1:                 addInboundBridge(bridge);
0:             }
0:             outboundSession.close();
0:         }
0:     }
0: 
1:     protected void initializeInboundDestinationBridgesLocalSide(QueueConnection connection) throws JMSException {
1:         if (inboundQueueBridges != null) {
1:             QueueSession localSession = connection.createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0: 
1:             for (InboundQueueBridge bridge : inboundQueueBridges) {
0:                 String localQueueName = bridge.getLocalQueueName();
0:                 Queue activemqQueue = createActiveMQQueue(localSession, localQueueName);
1:                 bridge.setProducerConnection(connection);
1:     protected void initializeOutboundDestinationBridgesOutboundSide(QueueConnection connection) throws JMSException {
1:             QueueSession outboundSession = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
1:             for (OutboundQueueBridge bridge : outboundQueueBridges) {
1:                 bridge.setProducerConnection(connection);
/////////////////////////////////////////////////////////////////////////
0:         }
0:     }
0: 
1:     protected void initializeOutboundDestinationBridgesLocalSide(QueueConnection connection) throws JMSException {
1:         if (outboundQueueBridges != null) {
1:             QueueSession localSession =
1:                     connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
1:             for (OutboundQueueBridge bridge : outboundQueueBridges) {
0:                 String localQueueName = bridge.getLocalQueueName();
0:                 Queue activemqQueue = createActiveMQQueue(localSession, localQueueName);
1:                 bridge.setConsumer(null);
0:                 bridge.setConsumerQueue(activemqQueue);
1:                 bridge.setConsumerConnection(connection);
1:                 bridge.setJmsConnector(this);
1:                 addOutboundBridge(bridge);
0:             }
/////////////////////////////////////////////////////////////////////////
1:         boolean isInbound = replyToProducerConnection.equals(localConnection.get());
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Logger LOG = LoggerFactory.getLogger(JmsQueueConnector.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:1c26c9a
/////////////////////////////////////////////////////////////////////////
0: 
0:         // the outboundQueueConnection was reestablished - publish the new connection to the bridges
0:         if (inboundQueueBridges != null) {
0:         	for (int i = 0; i < inboundQueueBridges.length; i++) {
0:         		InboundQueueBridge bridge = inboundQueueBridges[i];
0:         		bridge.setConsumerConnection(outboundQueueConnection);
0:         	}
0:         }
0:         if (outboundQueueBridges != null) {
0:         	for (int i = 0; i < outboundQueueBridges.length; i++) {
0:         		OutboundQueueBridge bridge = outboundQueueBridges[i];
0:         		bridge.setProducerConnection(outboundQueueConnection);
0:         	}
0:         }
/////////////////////////////////////////////////////////////////////////
0:                     throw new JMSException("Cannot create foreignConnection - no information");
commit:4acbd59
/////////////////////////////////////////////////////////////////////////
0:         if (localClientId != null && localClientId.length() > 0) {
0:             outboundQueueConnection.setClientID(getOutboundClientId());
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (localClientId != null && localClientId.length() > 0) {
0:             localQueueConnection.setClientID(getLocalClientId());
0:         }
commit:902a8ea
/////////////////////////////////////////////////////////////////////////
0:                 String localQueueName=bridge.getLocalQueueName();
0:                 Queue activemqQueue=createActiveMQQueue(localSession,localQueueName);
1:                 String queueName = bridge.getInboundQueueName();
/////////////////////////////////////////////////////////////////////////
0:                 String localQueueName=bridge.getLocalQueueName();              
0:                 Queue activemqQueue=createActiveMQQueue(localSession,localQueueName);
commit:28647f1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private OutboundQueueBridge[] outboundQueueBridges;   
/////////////////////////////////////////////////////////////////////////
0:                 initializeInboundJmsMessageConvertor();
0:                 initializeOutboundJmsMessageConvertor();
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void initializeInboundJmsMessageConvertor(){
0:     	inboundMessageConvertor.setConnection(localQueueConnection);
0:     }
0:     
0:     protected void initializeOutboundJmsMessageConvertor(){
0:     	outboundMessageConvertor.setConnection(outboundQueueConnection);
0:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected Destination createReplyToBridge(Destination destination, Connection replyToProducerConnection, Connection replyToConsumerConnection){        
0:     	Queue replyToProducerQueue =(Queue)destination;
0:     	boolean isInbound = replyToProducerConnection.equals(localQueueConnection);
0:     	
0:     	if(isInbound){
0:     		InboundQueueBridge bridge = (InboundQueueBridge) replyToBridges.get(replyToProducerQueue);
0:     		if (bridge == null){
0:     			bridge = new InboundQueueBridge(){
0:     				protected Destination processReplyToDestination (Destination destination){
0:     					return null;
0:     				}
0:     			};
0:     			try{
0:     				QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection).createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0:     				Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();
0:     				replyToConsumerSession.close();
0:     				bridge.setConsumerQueue(replyToConsumerQueue);
0:     				bridge.setProducerQueue(replyToProducerQueue);
0:     				bridge.setProducerConnection((QueueConnection)replyToProducerConnection);
0:     				bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);
0:     				bridge.setDoHandleReplyTo(false);
0:     				if(bridge.getJmsMessageConvertor()==null){
1:     					bridge.setJmsMessageConvertor(getInboundMessageConvertor());
0:     				}
1:     				bridge.setJmsConnector(this);
0:     				bridge.start();
0:     				log.info("Created replyTo bridge for " + replyToProducerQueue);
0:     			}catch(Exception e){
0:     				log.error("Failed to create replyTo bridge for queue: " + replyToProducerQueue, e);
0:     				return null;
0:     			}
0:     			replyToBridges.put(replyToProducerQueue, bridge);
0:     		}
0:     		return bridge.getConsumerQueue();
0:     	}else{
0:     		OutboundQueueBridge bridge = (OutboundQueueBridge) replyToBridges.get(replyToProducerQueue);
0:     		if (bridge == null){
0:     			bridge = new OutboundQueueBridge(){
0:     				protected Destination processReplyToDestination (Destination destination){
0:     					return null;
0:     				}
0:     			};
0:     			try{
0:     				QueueSession replyToConsumerSession = ((QueueConnection)replyToConsumerConnection).createQueueSession(false,Session.AUTO_ACKNOWLEDGE);
0:     				Queue replyToConsumerQueue = replyToConsumerSession.createTemporaryQueue();
0:     				replyToConsumerSession.close();
0:     				bridge.setConsumerQueue(replyToConsumerQueue);
0:     				bridge.setProducerQueue(replyToProducerQueue);
0:     				bridge.setProducerConnection((QueueConnection)replyToProducerConnection);
0:     				bridge.setConsumerConnection((QueueConnection)replyToConsumerConnection);
0:     				bridge.setDoHandleReplyTo(false);
0:     				if(bridge.getJmsMessageConvertor()==null){
1:     					bridge.setJmsMessageConvertor(getOutboundMessageConvertor());
0:     				}
1:     				bridge.setJmsConnector(this);
0:     				bridge.start();
0:     				log.info("Created replyTo bridge for " + replyToProducerQueue);
0:     			}catch(Exception e){
0:     				log.error("Failed to create replyTo bridge for queue: " + replyToProducerQueue, e);
0:     				return null;
0:     			}
0:     			replyToBridges.put(replyToProducerQueue, bridge);
0:     		}
0:     		return bridge.getConsumerQueue();
0:     	}		
commit:49e8a80
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Connection;
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 bridge.setJmsConnector(this);
/////////////////////////////////////////////////////////////////////////
0:                 bridge.setJmsConnector(this);
/////////////////////////////////////////////////////////////////////////
0:     protected Destination createReplyToBridge(Destination destination, Connection consumerConnection, Connection producerConnection){
0:         Queue queue = (Queue)destination;
/////////////////////////////////////////////////////////////////////////
0:                 bridge.setJmsConnector(this);
commit:6ea186c
/////////////////////////////////////////////////////////////////////////
0:                     bridge.setJmsMessageConvertor(getInboundMessageConvertor());
/////////////////////////////////////////////////////////////////////////
0:                     bridge.setJmsMessageConvertor(getOutboundMessageConvertor());
/////////////////////////////////////////////////////////////////////////
0:                     bridge.setJmsMessageConvertor(getOutboundMessageConvertor());
commit:e1bc55d
/////////////////////////////////////////////////////////////////////////
0:                     outboundQueueConnectionFactory=(QueueConnectionFactory) jndiOutboundTemplate.lookup(
/////////////////////////////////////////////////////////////////////////
0:                         localQueueConnectionFactory=(QueueConnectionFactory) jndiLocalTemplate.lookup(
/////////////////////////////////////////////////////////////////////////
0:                 result = (Queue) jndiOutboundTemplate.lookup(queueName, Queue.class);
author:James Strachan
-------------------------------------------------------------------------------
commit:fbad105
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void restartProducerConnection() throws NamingException, JMSException {
0:         outboundQueueConnection = null;
0:         initializeForeignQueueConnection();
0:     }
0: 
============================================================================