1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:b5a1916:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b5a1916:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:f0d9f83: 
1:2280719: import java.io.IOException;
1:2280719: import java.net.URI;
1:2280719: import java.util.ArrayList;
1:2280719: import java.util.Collections;
1:2280719: import java.util.HashMap;
1:2280719: import java.util.List;
1:3a8eb74: import java.util.Locale;
1:2280719: import java.util.Map;
1:2280719: import java.util.Set;
1:2280719: import java.util.concurrent.ConcurrentHashMap;
1:2280719: import java.util.concurrent.CopyOnWriteArrayList;
1:2280719: import java.util.concurrent.ThreadPoolExecutor;
1:cdb38b3: import java.util.concurrent.atomic.AtomicBoolean;
1:2280719: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:a1bd85e: 
1:2280719: import javax.jms.InvalidClientIDException;
1:2280719: import javax.jms.JMSException;
1:3a8eb74: 
1:b9fd189: import org.apache.activemq.broker.Broker;
1:b9fd189: import org.apache.activemq.broker.BrokerService;
1:b9fd189: import org.apache.activemq.broker.Connection;
1:b9fd189: import org.apache.activemq.broker.ConnectionContext;
1:b9fd189: import org.apache.activemq.broker.ConsumerBrokerExchange;
1:b9fd189: import org.apache.activemq.broker.EmptyBroker;
1:b9fd189: import org.apache.activemq.broker.ProducerBrokerExchange;
1:b9fd189: import org.apache.activemq.broker.TransportConnection;
1:b9fd189: import org.apache.activemq.broker.TransportConnector;
1:a414c20: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
1:d29ca2a: import org.apache.activemq.broker.region.policy.PolicyMap;
1:d7aaca5: import org.apache.activemq.command.ActiveMQDestination;
1:708be6d: import org.apache.activemq.command.ActiveMQMessage;
1:d7aaca5: import org.apache.activemq.command.BrokerId;
1:d7aaca5: import org.apache.activemq.command.BrokerInfo;
1:d7aaca5: import org.apache.activemq.command.ConnectionId;
1:d7aaca5: import org.apache.activemq.command.ConnectionInfo;
1:8d3ca90: import org.apache.activemq.command.ConsumerControl;
1:d7aaca5: import org.apache.activemq.command.ConsumerInfo;
1:d7aaca5: import org.apache.activemq.command.DestinationInfo;
1:d7aaca5: import org.apache.activemq.command.Message;
1:d7aaca5: import org.apache.activemq.command.MessageAck;
1:d7aaca5: import org.apache.activemq.command.MessageDispatch;
1:d7aaca5: import org.apache.activemq.command.MessageDispatchNotification;
1:d7aaca5: import org.apache.activemq.command.MessagePull;
1:d7aaca5: import org.apache.activemq.command.ProducerInfo;
1:d7aaca5: import org.apache.activemq.command.RemoveSubscriptionInfo;
1:d7aaca5: import org.apache.activemq.command.Response;
1:d7aaca5: import org.apache.activemq.command.TransactionId;
1:ea74731: import org.apache.activemq.state.ConnectionState;
1:d5dd937: import org.apache.activemq.store.PListStore;
1:1a5ad28: import org.apache.activemq.thread.Scheduler;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:6cebd2c: import org.apache.activemq.transport.TransmitCallback;
1:6d8e2c5: import org.apache.activemq.usage.SystemUsage;
1:a414c20: import org.apache.activemq.util.BrokerSupport;
1:d29ca2a: import org.apache.activemq.util.IdGenerator;
1:8a1f994: import org.apache.activemq.util.InetAddressUtil;
1:d29ca2a: import org.apache.activemq.util.LongSequenceGenerator;
1:013f372: import org.apache.activemq.util.ServiceStopper;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2280719: 
1:d29ca2a: /**
1:d29ca2a:  * Routes Broker operations to the correct messaging regions for processing.
1:d29ca2a:  */
1:4ee029e: public class RegionBroker extends EmptyBroker {
1:7a59d28:     public static final String ORIGINAL_EXPIRATION = "originalExpiration";
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(RegionBroker.class);
1:fc00993:     private static final IdGenerator BROKER_ID_GENERATOR = new IdGenerator();
1:3a8eb74: 
1:ecf89a6:     protected final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:ecf89a6:     protected DestinationFactory destinationFactory;
1:ecf89a6:     protected final Map<ConnectionId, ConnectionState> connectionStates = Collections.synchronizedMap(new HashMap<ConnectionId, ConnectionState>());
1:b5a1916: 
1:d29ca2a:     private final Region queueRegion;
1:d29ca2a:     private final Region topicRegion;
1:d29ca2a:     private final Region tempQueueRegion;
1:d29ca2a:     private final Region tempTopicRegion;
1:fd84b78:     protected final BrokerService brokerService;
1:230a86c:     private boolean started;
1:230a86c:     private boolean keepDurableSubsActive;
1:b5a1916: 
1:ecf89a6:     private final CopyOnWriteArrayList<Connection> connections = new CopyOnWriteArrayList<Connection>();
1:d7aaca5:     private final Map<ActiveMQDestination, ActiveMQDestination> destinationGate = new HashMap<ActiveMQDestination, ActiveMQDestination>();
1:ecf89a6:     private final Map<ActiveMQDestination, Destination> destinations = new ConcurrentHashMap<ActiveMQDestination, Destination>();
1:c752230:     private final Map<BrokerId, BrokerInfo> brokerInfos = new HashMap<BrokerId, BrokerInfo>();
1:ecf89a6: 
1:230a86c:     private final LongSequenceGenerator sequenceGenerator = new LongSequenceGenerator();
1:d29ca2a:     private BrokerId brokerId;
1:d29ca2a:     private String brokerName;
1:fd84b78:     private final Map<String, ConnectionContext> clientIdSet = new HashMap<String, ConnectionContext>();
1:da67a38:     private final DestinationInterceptor destinationInterceptor;
1:8abb655:     private ConnectionContext adminConnectionContext;
1:1a5ad28:     private final Scheduler scheduler;
1:1a5ad28:     private final ThreadPoolExecutor executor;
1:254d920:     private boolean allowTempAutoCreationOnSend;
1:ead8df6: 
1:ead8df6:     private final ReentrantReadWriteLock inactiveDestinationsPurgeLock = new ReentrantReadWriteLock();
1:cdb38b3:     private final TaskRunnerFactory taskRunnerFactory;
1:cdb38b3:     private final AtomicBoolean purgeInactiveDestinationsTaskInProgress = new AtomicBoolean(false);
1:2705e36:     private final Runnable purgeInactiveDestinationsTask = new Runnable() {
1:3a8eb74:         @Override
1:2705e36:         public void run() {
1:cdb38b3:             if (purgeInactiveDestinationsTaskInProgress.compareAndSet(false, true)) {
1:cdb38b3:                 taskRunnerFactory.execute(purgeInactiveDestinationsWork);
1:cdb38b3:             }
1:cdb38b3:         }
1:cdb38b3:     };
1:cdb38b3:     private final Runnable purgeInactiveDestinationsWork = new Runnable() {
1:cdb38b3:         @Override
1:cdb38b3:         public void run() {
1:cdb38b3:             try {
1:cdb38b3:                 purgeInactiveDestinations();
1:cdb38b3:             } catch (Throwable ignored) {
1:cdb38b3:                 LOG.error("Unexpected exception on purgeInactiveDestinations {}", this, ignored);
1:cdb38b3:             } finally {
1:cdb38b3:                 purgeInactiveDestinationsTaskInProgress.set(false);
1:cdb38b3:             }
1:9b260dc:         }
1:2705e36:     };
1:254d920: 
1:6d8e2c5:     public RegionBroker(BrokerService brokerService, TaskRunnerFactory taskRunnerFactory, SystemUsage memoryManager, DestinationFactory destinationFactory,
1:d7aaca5:         DestinationInterceptor destinationInterceptor, Scheduler scheduler, ThreadPoolExecutor executor) throws IOException {
1:4098942:         this.brokerService = brokerService;
1:d7aaca5:         this.executor = executor;
1:1a5ad28:         this.scheduler = scheduler;
1:bfaff9b:         if (destinationFactory == null) {
1:bfaff9b:             throw new IllegalArgumentException("null destinationFactory");
1:ce18ec8:         }
1:230a86c:         this.sequenceGenerator.setLastSequenceId(destinationFactory.getLastMessageBrokerSequenceId());
1:bfaff9b:         this.destinationFactory = destinationFactory;
1:bfaff9b:         queueRegion = createQueueRegion(memoryManager, taskRunnerFactory, destinationFactory);
1:bfaff9b:         topicRegion = createTopicRegion(memoryManager, taskRunnerFactory, destinationFactory);
1:da67a38:         this.destinationInterceptor = destinationInterceptor;
1:bfaff9b:         tempQueueRegion = createTempQueueRegion(memoryManager, taskRunnerFactory, destinationFactory);
1:230a86c:         tempTopicRegion = createTempTopicRegion(memoryManager, taskRunnerFactory, destinationFactory);
1:cdb38b3:         this.taskRunnerFactory = taskRunnerFactory;
1:ca242f4:     }
1:8d3ca90: 
1:8d3ca90:     @Override
1:933eb2f:     public Map<ActiveMQDestination, Destination> getDestinationMap() {
1:4d17a70:         Map<ActiveMQDestination, Destination> answer = new HashMap<ActiveMQDestination, Destination>(getQueueRegion().getDestinationMap());
1:d680ba1:         answer.putAll(getTopicRegion().getDestinationMap());
1:230a86c:         return answer;
1:ca242f4:     }
1:ce18ec8: 
1:1a5ad28:     @Override
1:27b3a7c:     public Map<ActiveMQDestination, Destination> getDestinationMap(ActiveMQDestination destination) {
1:27b3a7c:         try {
1:27b3a7c:             return getRegion(destination).getDestinationMap();
1:27b3a7c:         } catch (JMSException jmse) {
1:27b3a7c:             return Collections.emptyMap();
1:27b3a7c:         }
1:27b3a7c:     }
1:27b3a7c: 
1:27b3a7c:     @Override
1:d7aaca5:     public Set<Destination> getDestinations(ActiveMQDestination destination) {
1:ca242f4:         try {
1:7400977:             return getRegion(destination).getDestinations(destination);
1:7400977:         } catch (JMSException jmse) {
1:fd84b78:             return Collections.emptySet();
1:ca242f4:         }
1:b5a1916:     }
1:b5a1916: 
1:d680ba1:     public Region getQueueRegion() {
1:d7aaca5:         return queueRegion;
1:b5a1916:     }
1:b5a1916: 
1:d680ba1:     public Region getTempQueueRegion() {
1:d7aaca5:         return tempQueueRegion;
1:230a86c:     }
1:b5a1916: 
1:d680ba1:     public Region getTempTopicRegion() {
1:d7aaca5:         return tempTopicRegion;
1:230a86c:     }
1:b5a1916: 
1:d680ba1:     public Region getTopicRegion() {
1:d7aaca5:         return topicRegion;
1:3b88ba0:     }
1:e07d29c: 
1:6d8e2c5:     protected Region createTempTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:230a86c:         return new TempTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:d29ca2a:     }
1:230a86c: 
1:6d8e2c5:     protected Region createTempQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:1005fc5:         return new TempQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:d29ca2a:     }
1:230a86c: 
1:6d8e2c5:     protected Region createTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:230a86c:         return new TopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:d29ca2a:     }
1:230a86c: 
1:6d8e2c5:     protected Region createQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:230a86c:         return new QueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:d29ca2a:     public void start() throws Exception {
1:d2e6062:         started = true;
1:013f372:         queueRegion.start();
1:013f372:         topicRegion.start();
1:013f372:         tempQueueRegion.start();
1:013f372:         tempTopicRegion.start();
1:2705e36:         int period = this.brokerService.getSchedulePeriodForDestinationPurge();
1:2705e36:         if (period > 0) {
1:2705e36:             this.scheduler.executePeriodically(purgeInactiveDestinationsTask, period);
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:d29ca2a:     public void stop() throws Exception {
1:d2e6062:         started = false;
1:2705e36:         this.scheduler.cancel(purgeInactiveDestinationsTask);
1:013f372:         ServiceStopper ss = new ServiceStopper();
1:3cd3fd3:         doStop(ss);
1:013f372:         ss.throwFirstException();
1:62e1abf:         // clear the state
1:62e1abf:         clientIdSet.clear();
1:62e1abf:         connections.clear();
1:62e1abf:         destinations.clear();
1:62e1abf:         brokerInfos.clear();
1:d29ca2a:     }
1:230a86c: 
1:230a86c:     public PolicyMap getDestinationPolicy() {
1:6cb66e4:         return brokerService != null ? brokerService.getDestinationPolicy() : null;
1:d29ca2a:     }
1:230a86c: 
1:a581d01:     public ConnectionContext getConnectionContext(String clientId) {
1:a581d01:         return clientIdSet.get(clientId);
1:a581d01:     }
1:a581d01: 
1:ee55abb:     @Override
1:7f5213b:     public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {
1:de23149:         String clientId = info.getClientId();
1:de23149:         if (clientId == null) {
1:de23149:             throw new InvalidClientIDException("No clientID specified for connection request");
1:d29ca2a:         }
1:3873ecf: 
1:3873ecf:         ConnectionContext oldContext = null;
1:3873ecf: 
1:230a86c:         synchronized (clientIdSet) {
1:3873ecf:             oldContext = clientIdSet.get(clientId);
1:3873ecf:             if (oldContext != null) {
1:62c20eb:                 if (context.isAllowLinkStealing()) {
1:62c20eb:                     clientIdSet.put(clientId, context);
1:62c20eb:                 } else {
1:16c1627:                     throw new InvalidClientIDException("Broker: " + getBrokerName() + " - Client: " + clientId + " already connected from "
1:62c20eb:                         + oldContext.getConnection().getRemoteAddress());
1:c6a485f:                 }
1:c6a485f:             } else {
1:97a591f:                 clientIdSet.put(clientId, context);
1:b5a1916:             }
1:d29ca2a:         }
1:230a86c: 
1:230a86c:         if (oldContext != null) {
1:3873ecf:             if (oldContext.getConnection() != null) {
1:3873ecf:                 Connection connection = oldContext.getConnection();
1:3873ecf:                 LOG.warn("Stealing link for clientId {} From Connection {}", clientId, oldContext.getConnection());
1:3873ecf:                 if (connection instanceof TransportConnection) {
1:3873ecf:                     TransportConnection transportConnection = (TransportConnection) connection;
1:e19293d:                     transportConnection.stopAsync(new IOException("Stealing link for clientId " + clientId + " From Connection " + oldContext.getConnection().getConnectionId()));
1:3873ecf:                 } else {
1:3873ecf:                     connection.stop();
1:3873ecf:                 }
1:3873ecf:             } else {
1:3873ecf:                 LOG.error("No Connection found for {}", oldContext);
1:3873ecf:             }
1:3873ecf:         }
1:3873ecf: 
1:d29ca2a:         connections.add(context.getConnection());
1:62c20eb:     }
1:230a86c: 
1:ee55abb:     @Override
1:7f5213b:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {
1:de23149:         String clientId = info.getClientId();
1:de23149:         if (clientId == null) {
1:de23149:             throw new InvalidClientIDException("No clientID specified for connection disconnect request");
1:62c20eb:         }
1:de23149:         synchronized (clientIdSet) {
1:97a591f:             ConnectionContext oldValue = clientIdSet.get(clientId);
1:3873ecf:             // we may be removing the duplicate connection, not the first connection to be created
1:cb77064:             // so lets check that their connection IDs are the same
1:230a86c:             if (oldValue == context) {
1:cb77064:                 if (isEqual(oldValue.getConnectionId(), info.getConnectionId())) {
1:16c1627:                     clientIdSet.remove(clientId);
1:497fbfc:                 }
1:16c1627:             }
1:16c1627:         }
1:d29ca2a:         connections.remove(context.getConnection());
1:d29ca2a:     }
1:5b53083: 
1:cb77064:     protected boolean isEqual(ConnectionId connectionId, ConnectionId connectionId2) {
1:cb77064:         return connectionId == connectionId2 || (connectionId != null && connectionId.equals(connectionId2));
1:d29ca2a:     }
41:d29ca2a: 
1:ee55abb:     @Override
1:7f5213b:     public Connection[] getClients() throws Exception {
1:ecf89a6:         ArrayList<Connection> l = new ArrayList<Connection>(connections);
1:d29ca2a:         Connection rc[] = new Connection[l.size()];
1:3b88ba0:         l.toArray(rc);
1:3b88ba0:         return rc;
1:d29ca2a:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:179d95e:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemp) throws Exception {
1:d29ca2a: 
1:230a86c:         Destination answer;
1:3b88ba0: 
1:179d95e:         answer = destinations.get(destination);
1:179d95e:         if (answer != null) {
1:179d95e:             return answer;
1:179d95e:         }
1:179d95e: 
1:d7aaca5:         synchronized (destinationGate) {
1:d7aaca5:             answer = destinations.get(destination);
1:d7aaca5:             if (answer != null) {
1:d7aaca5:                 return answer;
1:d7aaca5:             }
1:d7aaca5: 
1:d7aaca5:             if (destinationGate.get(destination) != null) {
1:d7aaca5:                 // Guard against spurious wakeup.
1:d7aaca5:                 while (destinationGate.containsKey(destination)) {
1:d7aaca5:                     destinationGate.wait();
1:d7aaca5:                 }
1:d7aaca5:                 answer = destinations.get(destination);
1:d7aaca5:                 if (answer != null) {
1:d7aaca5:                     return answer;
1:62c20eb:                 } else {
1:d7aaca5:                     // In case of intermediate remove or add failure
1:d7aaca5:                     destinationGate.put(destination, destination);
1:d7aaca5:                 }
1:d7aaca5:             }
1:ecf89a6:         }
1:3b88ba0: 
1:7400977:         try {
1:7400977:             boolean create = true;
1:d7aaca5:             if (destination.isTemporary()) {
1:7400977:                 create = createIfTemp;
1:d7aaca5:             }
1:7400977:             answer = getRegion(destination).addDestination(context, destination, create);
1:d7aaca5:             destinations.put(destination, answer);
1:d7aaca5:         } finally {
1:d7aaca5:             synchronized (destinationGate) {
1:d7aaca5:                 destinationGate.remove(destination);
1:d7aaca5:                 destinationGate.notifyAll();
1:179d95e:             }
1:d7aaca5:         }
1:230a86c: 
1:230a86c:         return answer;
1:d7aaca5:     }
1:3b88ba0: 
1:ee55abb:     @Override
1:230a86c:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {
1:2d0fa5e:         if (destinations.containsKey(destination)) {
1:7400977:             getRegion(destination).removeDestination(context, destination, timeout);
1:2d0fa5e:             destinations.remove(destination);
1:6672740:         }
1:6672740:     }
1:6672740: 
1:ee55abb:     @Override
1:230a86c:     public void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
1:d7aaca5:         addDestination(context, info.getDestination(), true);
1:3b88ba0: 
1:3b88ba0:     }
1:3b88ba0: 
1:ee55abb:     @Override
1:230a86c:     public void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
1:230a86c:         removeDestination(context, info.getDestination(), info.getTimeout());
1:d29ca2a:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:7f5213b:     public ActiveMQDestination[] getDestinations() throws Exception {
1:b2fd5d6:         ArrayList<ActiveMQDestination> l;
1:3b88ba0: 
1:b2fd5d6:         l = new ArrayList<ActiveMQDestination>(getDestinationMap().keySet());
1:3b88ba0: 
1:230a86c:         ActiveMQDestination rc[] = new ActiveMQDestination[l.size()];
1:230a86c:         l.toArray(rc);
1:230a86c:         return rc;
1:3b88ba0:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:7f5213b:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:d29ca2a:         ActiveMQDestination destination = info.getDestination();
1:ead8df6:         if (destination != null) {
1:ead8df6:             inactiveDestinationsPurgeLock.readLock().lock();
1:d7aaca5:             try {
1:179d95e:                 // This seems to cause the destination to be added but without
1:179d95e:                 // advisories firing...
1:179d95e:                 context.getBroker().addDestination(context, destination, isAllowTempAutoCreationOnSend());
1:7400977:                 getRegion(destination).addProducer(context, info);
1:ead8df6:             } finally {
1:ead8df6:                 inactiveDestinationsPurgeLock.readLock().unlock();
1:d4ccc50:             }
1:d4ccc50:         }
1:d4ccc50:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:7f5213b:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:d29ca2a:         ActiveMQDestination destination = info.getDestination();
1:ead8df6:         if (destination != null) {
1:ead8df6:             inactiveDestinationsPurgeLock.readLock().lock();
1:d7aaca5:             try {
1:7400977:                 getRegion(destination).removeProducer(context, info);
1:ead8df6:             } finally {
1:ead8df6:                 inactiveDestinationsPurgeLock.readLock().unlock();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:0def1d4:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:634da7a:         ActiveMQDestination destination = info.getDestination();
1:d17eceb:         if (destinationInterceptor != null) {
1:d17eceb:             destinationInterceptor.create(this, context, destination);
1:d17eceb:         }
1:ead8df6:         inactiveDestinationsPurgeLock.readLock().lock();
1:ead8df6:         try {
1:7400977:             return getRegion(destination).addConsumer(context, info);
1:ead8df6:         } finally {
1:ead8df6:             inactiveDestinationsPurgeLock.readLock().unlock();
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:7f5213b:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
1:634da7a:         ActiveMQDestination destination = info.getDestination();
1:ead8df6:         inactiveDestinationsPurgeLock.readLock().lock();
1:ead8df6:         try {
1:7400977:             getRegion(destination).removeConsumer(context, info);
1:ead8df6:         } finally {
1:ead8df6:             inactiveDestinationsPurgeLock.readLock().unlock();
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:7f5213b:     public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Exception {
1:ead8df6:         inactiveDestinationsPurgeLock.readLock().lock();
1:ead8df6:         try {
1:d29ca2a:             topicRegion.removeSubscription(context, info);
1:ead8df6:         } finally {
1:ead8df6:             inactiveDestinationsPurgeLock.readLock().unlock();
1:e06685f: 
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:230a86c:     public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {
1:e07d29c:         ActiveMQDestination destination = message.getDestination();
1:a401575:         message.setBrokerInTime(System.currentTimeMillis());
1:44d6be4:         if (producerExchange.isMutable() || producerExchange.getRegion() == null
1:d7aaca5:             || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {
1:25a252f:             // ensure the destination is registered with the RegionBroker
1:d7aaca5:             producerExchange.getConnectionContext().getBroker()
1:d7aaca5:                 .addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());
1:7400977:             producerExchange.setRegion(getRegion(destination));
1:44d6be4:             producerExchange.setRegionDestination(null);
1:d29ca2a:         }
1:b5a1916: 
1:230a86c:         producerExchange.getRegion().send(producerExchange, message);
1:d29ca2a: 
1:e07d29c:         // clean up so these references aren't kept (possible leak) in the producer exchange
1:e07d29c:         // especially since temps are transitory
1:7400977:         if (producerExchange.isMutable()) {
1:e07d29c:             producerExchange.setRegionDestination(null);
1:e07d29c:             producerExchange.setRegion(null);
1:e07d29c:         }
1:d29ca2a:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:230a86c:     public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {
1:230a86c:         if (consumerExchange.isWildcard() || consumerExchange.getRegion() == null) {
1:230a86c:             ActiveMQDestination destination = ack.getDestination();
1:7400977:             consumerExchange.setRegion(getRegion(destination));
1:d29ca2a:         }
1:230a86c:         consumerExchange.getRegion().acknowledge(consumerExchange, ack);
1:d29ca2a:     }
1:d29ca2a: 
1:88daeec:     public Region getRegion(ActiveMQDestination destination) throws JMSException {
1:8d3ca90:         switch (destination.getDestinationType()) {
1:8d3ca90:             case ActiveMQDestination.QUEUE_TYPE:
1:7400977:                 return queueRegion;
1:8d3ca90:             case ActiveMQDestination.TOPIC_TYPE:
1:7400977:                 return topicRegion;
1:8d3ca90:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:7400977:                 return tempQueueRegion;
1:8d3ca90:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:7400977:                 return tempTopicRegion;
1:8d3ca90:             default:
1:7400977:                 throw createUnknownDestinationTypeException(destination);
1:7400977:         }
1:7400977:     }
1:7400977: 
1:ee55abb:     @Override
1:9d671b7:     public Response messagePull(ConnectionContext context, MessagePull pull) throws Exception {
1:9d671b7:         ActiveMQDestination destination = pull.getDestination();
1:7400977:         return getRegion(destination).messagePull(context, pull);
1:6672740:     }
1:b5a1916: 
1:ee55abb:     @Override
1:7f5213b:     public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Exception {
1:d29ca2a:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:6672740:     }
1:6672740: 
1:ee55abb:     @Override
1:7f5213b:     public void beginTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:d29ca2a:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:6672740:     }
1:6672740: 
1:ee55abb:     @Override
1:7f5213b:     public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:d29ca2a:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:3b88ba0:     }
1:230a86c: 
1:ee55abb:     @Override
1:7f5213b:     public void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:d29ca2a:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:3b88ba0:     }
1:230a86c: 
1:ee55abb:     @Override
1:7f5213b:     public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {
1:d29ca2a:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:7f5213b:     public void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Exception {
1:d29ca2a:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:d29ca2a:     public void gc() {
1:d29ca2a:         queueRegion.gc();
1:d29ca2a:         topicRegion.gc();
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:d29ca2a:     public BrokerId getBrokerId() {
1:230a86c:         if (brokerId == null) {
1:fc00993:             brokerId = new BrokerId(BROKER_ID_GENERATOR.generateId());
1:d29ca2a:         }
1:d29ca2a:         return brokerId;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setBrokerId(BrokerId brokerId) {
1:d29ca2a:         this.brokerId = brokerId;
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:d29ca2a:     public String getBrokerName() {
1:230a86c:         if (brokerName == null) {
1:ead8df6:             try {
1:4b44d31:                 brokerName = InetAddressUtil.getLocalHostName().toLowerCase(Locale.ENGLISH);
1:230a86c:             } catch (Exception e) {
1:230a86c:                 brokerName = "localhost";
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return brokerName;
1:d29ca2a:     }
1:0bb9013: 
1:d29ca2a:     public void setBrokerName(String brokerName) {
1:d29ca2a:         this.brokerName = brokerName;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public DestinationStatistics getDestinationStatistics() {
1:d29ca2a:         return destinationStatistics;
1:d29ca2a:     }
1:230a86c: 
1:0def1d4:     protected JMSException createUnknownDestinationTypeException(ActiveMQDestination destination) {
1:0def1d4:         return new JMSException("Unknown destination type: " + destination.getDestinationType());
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:230a86c:     public synchronized void addBroker(Connection connection, BrokerInfo info) {
1:c752230:         BrokerInfo existing = brokerInfos.get(info.getBrokerId());
1:c752230:         if (existing == null) {
1:c752230:             existing = info.copy();
1:c752230:             existing.setPeerBrokerInfos(null);
1:c752230:             brokerInfos.put(info.getBrokerId(), existing);
1:c752230:         }
1:c752230:         existing.incrementRefCount();
1:e1bbde7:         LOG.debug("{} addBroker: {} brokerInfo size: {}", new Object[]{ getBrokerName(), info.getBrokerName(), brokerInfos.size() });
1:2280719:         addBrokerInClusterUpdate(info);
1:44ef96e:     }
1:230a86c: 
1:ee55abb:     @Override
1:230a86c:     public synchronized void removeBroker(Connection connection, BrokerInfo info) {
1:230a86c:         if (info != null) {
1:c752230:             BrokerInfo existing = brokerInfos.get(info.getBrokerId());
1:c752230:             if (existing != null && existing.decrementRefCount() == 0) {
1:c752230:                 brokerInfos.remove(info.getBrokerId());
1:c752230:             }
1:e1bbde7:             LOG.debug("{} removeBroker: {} brokerInfo size: {}", new Object[]{ getBrokerName(), info.getBrokerName(), brokerInfos.size()});
1:3a8eb74:             // When stopping don't send cluster updates since we are the one's tearing down
1:3a8eb74:             // our own bridges.
1:3a8eb74:             if (!brokerService.isStopping()) {
1:2280719:                 removeBrokerInClusterUpdate(info);
1:44ef96e:             }
1:3a8eb74:         }
1:230a86c:     }
1:230a86c: 
1:ee55abb:     @Override
1:230a86c:     public synchronized BrokerInfo[] getPeerBrokerInfos() {
1:4098942:         BrokerInfo[] result = new BrokerInfo[brokerInfos.size()];
1:c752230:         result = brokerInfos.values().toArray(result);
1:4098942:         return result;
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:6cebd2c:     public void preProcessDispatch(final MessageDispatch messageDispatch) {
1:6cebd2c:         final Message message = messageDispatch.getMessage();
1:230a86c:         if (message != null) {
1:230a86c:             long endTime = System.currentTimeMillis();
1:c07b233:             message.setBrokerOutTime(endTime);
1:230a86c:             if (getBrokerService().isEnableStatistics()) {
1:c07b233:                 long totalTime = endTime - message.getBrokerInTime();
1:d7aaca5:                 ((Destination) message.getRegionDestination()).getDestinationStatistics().getProcessTime().addTime(totalTime);
1:d29ca2a:             }
1:dc25f2a:             if (((BaseDestination) message.getRegionDestination()).isPersistJMSRedelivered() && !message.isRedelivered()) {
1:266d23e:                 final int originalValue = message.getRedeliveryCounter();
1:266d23e:                 message.incrementRedeliveryCounter();
1:266d23e:                 try {
1:dc25f2a:                     if (message.isPersistent()) {
1:dc25f2a:                         ((BaseDestination) message.getRegionDestination()).getMessageStore().updateMessage(message);
1:dc25f2a:                     }
1:6cebd2c:                     messageDispatch.setTransmitCallback(new TransmitCallback() {
1:6cebd2c:                         // dispatch is considered a delivery, so update sub state post dispatch otherwise
1:6cebd2c:                         // on a disconnect/reconnect cached messages will not reflect initial delivery attempt
1:6cebd2c:                         final TransmitCallback delegate = messageDispatch.getTransmitCallback();
1:6cebd2c:                         @Override
1:6cebd2c:                         public void onSuccess() {
1:6cebd2c:                             message.incrementRedeliveryCounter();
1:6cebd2c:                             if (delegate != null) {
1:6cebd2c:                                 delegate.onSuccess();
1:6cebd2c:                             }
1:6cebd2c:                         }
1:6cebd2c: 
1:6cebd2c:                         @Override
1:6cebd2c:                         public void onFailure() {
1:6cebd2c:                             if (delegate != null) {
1:6cebd2c:                                 delegate.onFailure();
1:6cebd2c:                             }
1:6cebd2c:                         }
1:6cebd2c:                     });
1:266d23e:                 } catch (IOException error) {
1:52e1a05:                     RuntimeException runtimeException = new RuntimeException("Failed to persist JMSRedeliveryFlag on " + message.getMessageId() + " in " + message.getDestination(), error);
1:52e1a05:                     LOG.warn(runtimeException.getLocalizedMessage(), runtimeException);
1:52e1a05:                     throw runtimeException;
1:266d23e:                 } finally {
1:266d23e:                     message.setRedeliveryCounter(originalValue);
1:266d23e:                 }
1:266d23e:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:230a86c:     public void postProcessDispatch(MessageDispatch messageDispatch) {
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:7f5213b:     public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception {
1:4098942:         ActiveMQDestination destination = messageDispatchNotification.getDestination();
1:7400977:         getRegion(destination).processDispatchNotification(messageDispatchNotification);
1:d29ca2a:     }
1:3b88ba0: 
1:ee55abb:     @Override
1:230a86c:     public boolean isStopped() {
1:d2e6062:         return !started;
1:d29ca2a:     }
1:230a86c: 
1:ee55abb:     @Override
1:933eb2f:     public Set<ActiveMQDestination> getDurableDestinations() {
1:bfaff9b:         return destinationFactory.getDestinations();
1:d29ca2a:     }
1:230a86c: 
1:3cd3fd3:     protected void doStop(ServiceStopper ss) {
1:013f372:         ss.stop(queueRegion);
1:013f372:         ss.stop(topicRegion);
1:013f372:         ss.stop(tempQueueRegion);
1:013f372:         ss.stop(tempTopicRegion);
1:2705e36:     }
1:d29ca2a: 
1:449981b:     public boolean isKeepDurableSubsActive() {
1:449981b:         return keepDurableSubsActive;
1:449981b:     }
1:449981b: 
1:449981b:     public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {
1:449981b:         this.keepDurableSubsActive = keepDurableSubsActive;
1:d7aaca5:         ((TopicRegion) topicRegion).setKeepDurableSubsActive(keepDurableSubsActive);
1:449981b:     }
1:449981b: 
1:da67a38:     public DestinationInterceptor getDestinationInterceptor() {
1:da67a38:         return destinationInterceptor;
1:2705e36:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:8abb655:     public ConnectionContext getAdminConnectionContext() {
1:8abb655:         return adminConnectionContext;
1:2705e36:     }
1:230a86c: 
1:ee55abb:     @Override
1:8abb655:     public void setAdminConnectionContext(ConnectionContext adminConnectionContext) {
1:8abb655:         this.adminConnectionContext = adminConnectionContext;
1:5b53083:     }
1:230a86c: 
1:230a86c:     public Map<ConnectionId, ConnectionState> getConnectionStates() {
1:230a86c:         return connectionStates;
1:230a86c:     }
1:5b53083: 
1:ee55abb:     @Override
1:ee55abb:     public PListStore getTempDataStore() {
1:7d1e6bc:         return brokerService.getTempDataStore();
1:2705e36:     }
1:230a86c: 
1:ee55abb:     @Override
1:230a86c:     public URI getVmConnectorURI() {
1:4741136:         return brokerService.getVmConnectorURI();
1:2705e36:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:230a86c:     public void brokerServiceStarted() {
1:2705e36:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:230a86c:     public BrokerService getBrokerService() {
1:25a252f:         return brokerService;
1:2705e36:     }
1:230a86c: 
1:ee55abb:     @Override
1:a401575:     public boolean isExpired(MessageReference messageReference) {
1:6cc2c11:         return messageReference.canProcessAsExpired();
1:ca242f4:     }
1:ca242f4: 
1:ca242f4:     private boolean stampAsExpired(Message message) throws IOException {
1:d7aaca5:         boolean stamped = false;
1:ca242f4:         if (message.getProperty(ORIGINAL_EXPIRATION) == null) {
1:d7aaca5:             long expiration = message.getExpiration();
1:d7aaca5:             message.setProperty(ORIGINAL_EXPIRATION, new Long(expiration));
1:ca242f4:             stamped = true;
1:ca242f4:         }
1:ca242f4:         return stamped;
1:2705e36:     }
1:a1bd85e: 
1:ee55abb:     @Override
1:27c1719:     public void messageExpired(ConnectionContext context, MessageReference node, Subscription subscription) {
1:e1bbde7:         LOG.debug("Message expired {}", node);
1:708be6d:         getRoot().sendToDeadLetterQueue(context, node, subscription, new Throwable("Message Expired. Expiration:" + node.getExpiration()));
1:2705e36:     }
1:b5a1916: 
1:ee55abb:     @Override
1:708be6d:     public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference node, Subscription subscription, Throwable poisonCause) {
1:ead8df6:         try {
1:d7aaca5:             if (node != null) {
1:d7aaca5:                 Message message = node.getMessage();
1:d7aaca5:                 if (message != null && node.getRegionDestination() != null) {
1:d7aaca5:                     DeadLetterStrategy deadLetterStrategy = ((Destination) node.getRegionDestination()).getDeadLetterStrategy();
1:d7aaca5:                     if (deadLetterStrategy != null) {
1:d7aaca5:                         if (deadLetterStrategy.isSendToDeadLetterQueue(message)) {
1:66cfc7b:                             ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(message, subscription);
1:66cfc7b:                             // Prevent a DLQ loop where same message is sent from a DLQ back to itself
1:66cfc7b:                             if (deadLetterDestination.equals(message.getDestination())) {
1:66cfc7b:                                 LOG.debug("Not re-adding to DLQ: {}, dest: {}", message.getMessageId(), message.getDestination());
1:66cfc7b:                                 return false;
1:66cfc7b:                             }
1:66cfc7b: 
1:a1bd85e:                             // message may be inflight to other subscriptions so do not modify
1:a1bd85e:                             message = message.copy();
1:0142c4d:                             long dlqExpiration = deadLetterStrategy.getExpiration();
1:0142c4d:                             if (dlqExpiration > 0) {
1:0142c4d:                                 dlqExpiration += System.currentTimeMillis();
1:0142c4d:                             } else {
1:0142c4d:                                 stampAsExpired(message);
1:0142c4d:                             }
1:0142c4d:                             message.setExpiration(dlqExpiration);
1:d7aaca5:                             if (!message.isPersistent()) {
1:99819f3:                                 message.setPersistent(true);
1:d7aaca5:                                 message.setProperty("originalDeliveryMode", "NON_PERSISTENT");
1:99819f3:                             }
1:708be6d:                             if (poisonCause != null) {
1:708be6d:                                 message.setProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY,
1:708be6d:                                         poisonCause.toString());
1:708be6d:                             }
1:b5a1916:                             // The original destination and transaction id do
1:99819f3:                             // not get filled when the message is first sent,
1:b5a1916:                             // it is only populated if the message is routed to
1:b5a1916:                             // another destination like the DLQ
1:7646526:                             ConnectionContext adminContext = context;
1:7646526:                             if (context.getSecurityContext() == null || !context.getSecurityContext().isBrokerContext()) {
1:7646526:                                 adminContext = BrokerSupport.getConnectionContext(this);
1:b5a1916:                             }
1:d2c0edd:                             addDestination(adminContext, deadLetterDestination, false).getActiveMQDestination().setDLQ(true);
1:7646526:                             BrokerSupport.resendNoCopy(adminContext, message, deadLetterDestination);
1:0bb9013:                             return true;
1:b5a1916:                         }
1:62c20eb:                     } else {
1:e1bbde7:                         LOG.debug("Dead Letter message with no DLQ strategy in place, message id: {}, destination: {}", message.getMessageId(), message.getDestination());
1:b5a1916:                     }
1:b5a1916:                 }
1:b5a1916:             }
1:d7aaca5:         } catch (Exception e) {
1:e1bbde7:             LOG.warn("Caught an exception sending to DLQ: {}", node, e);
1:b5a1916:         }
1:d29ca2a: 
1:0bb9013:         return false;
1:b5a1916:     }
1:d29ca2a: 
1:ee55abb:     @Override
1:230a86c:     public Broker getRoot() {
1:6672740:         try {
1:a414c20:             return getBrokerService().getBroker();
1:230a86c:         } catch (Exception e) {
1:e1bbde7:             LOG.error("Trying to get Root Broker", e);
1:a414c20:             throw new RuntimeException("The broker from the BrokerService should not throw an exception");
1:b5a1916:         }
1:2705e36:     }
1:b5a1916: 
1:dfcf776:     /**
1:dfcf776:      * @return the broker sequence id
1:dfcf776:      */
1:ee55abb:     @Override
1:dfcf776:     public long getBrokerSequenceId() {
1:d7aaca5:         synchronized (sequenceGenerator) {
1:dfcf776:             return sequenceGenerator.getNextSequenceId();
1:2705e36:         }
1:2705e36:     }
1:b5a1916: 
1:ee55abb:     @Override
1:1a5ad28:     public Scheduler getScheduler() {
1:1a5ad28:         return this.scheduler;
1:2705e36:     }
1:b5a1916: 
1:3a8eb74:     @Override
1:1a5ad28:     public ThreadPoolExecutor getExecutor() {
1:1a5ad28:         return this.executor;
1:2705e36:     }
1:b5a1916: 
1:ee55abb:     @Override
1:8d3ca90:     public void processConsumerControl(ConsumerBrokerExchange consumerExchange, ConsumerControl control) {
1:8d3ca90:         ActiveMQDestination destination = control.getDestination();
1:7400977:         try {
1:7400977:             getRegion(destination).processConsumerControl(consumerExchange, control);
1:7400977:         } catch (JMSException jmse) {
1:e1bbde7:             LOG.warn("unmatched destination: {}, in consumerControl: {}", destination, control);
1:2705e36:         }
1:1a5ad28:     }
1:8d3ca90: 
1:2280719:     protected void addBrokerInClusterUpdate(BrokerInfo info) {
1:f392884:         List<TransportConnector> connectors = this.brokerService.getTransportConnectors();
1:f392884:         for (TransportConnector connector : connectors) {
1:be55d0a:             if (connector.isUpdateClusterClients()) {
1:2280719:                 connector.addPeerBroker(info);
1:be55d0a:                 connector.updateClientClusterInfo();
1:1a5ad28:             }
1:be55d0a:         }
1:be55d0a:     }
1:8d3ca90: 
1:2280719:     protected void removeBrokerInClusterUpdate(BrokerInfo info) {
1:be55d0a:         List<TransportConnector> connectors = this.brokerService.getTransportConnectors();
1:be55d0a:         for (TransportConnector connector : connectors) {
1:be55d0a:             if (connector.isUpdateClusterClients() && connector.isUpdateClusterClientsOnRemove()) {
1:2280719:                 connector.removePeerBroker(info);
1:be55d0a:                 connector.updateClientClusterInfo();
1:be55d0a:             }
1:be55d0a:         }
2:f392884:     }
1:d29ca2a: 
1:2705e36:     protected void purgeInactiveDestinations() {
1:ead8df6:         inactiveDestinationsPurgeLock.writeLock().lock();
1:ead8df6:         try {
1:17995e6:             List<Destination> list = new ArrayList<Destination>();
1:2705e36:             Map<ActiveMQDestination, Destination> map = getDestinationMap();
1:254d920:             if (isAllowTempAutoCreationOnSend()) {
1:254d920:                 map.putAll(tempQueueRegion.getDestinationMap());
1:254d920:                 map.putAll(tempTopicRegion.getDestinationMap());
1:254d920:             }
1:f0d9f83:             long maxPurgedDests = this.brokerService.getMaxPurgedDestinationsPerSweep();
1:2705e36:             long timeStamp = System.currentTimeMillis();
1:2705e36:             for (Destination d : map.values()) {
1:17995e6:                 d.markForGC(timeStamp);
1:17995e6:                 if (d.canGC()) {
1:17995e6:                     list.add(d);
1:17995e6:                     if (maxPurgedDests > 0 && list.size() == maxPurgedDests) {
4:8d3ca90:                         break;
1:8d3ca90:                     }
1:8d3ca90:                 }
1:f0d9f83:             }
1:8d3ca90: 
1:17995e6:             if (!list.isEmpty()) {
1:ec30bf0:                 ConnectionContext context = BrokerSupport.getConnectionContext(this);
1:2705e36:                 context.setBroker(this);
1:8d3ca90: 
1:17995e6:                 for (Destination dest : list) {
1:17995e6:                     Logger log = LOG;
1:17995e6:                     if (dest instanceof BaseDestination) {
1:17995e6:                         log = ((BaseDestination) dest).getLog();
1:17995e6:                     }
1:b9fd189:                     log.info("{} Inactive for longer than {} ms - removing ...", dest.getName(), dest.getInactiveTimeoutBeforeGC());
2:230a86c:                     try {
1:254d920:                         getRoot().removeDestination(context, dest.getActiveMQDestination(), isAllowTempAutoCreationOnSend() ? 1 : 0);
1:6d14e4e:                     } catch (Throwable e) {
1:e1bbde7:                         LOG.error("Failed to remove inactive destination {}", dest, e);
1:230a86c:                     }
1:230a86c:                 }
1:230a86c:             }
1:ead8df6:         } finally {
1:ead8df6:             inactiveDestinationsPurgeLock.writeLock().unlock();
1:230a86c:         }
1:230a86c:     }
1:b5a1916: 
1:254d920:     public boolean isAllowTempAutoCreationOnSend() {
1:254d920:         return allowTempAutoCreationOnSend;
1:254d920:     }
1:254d920: 
1:254d920:     public void setAllowTempAutoCreationOnSend(boolean allowTempAutoCreationOnSend) {
1:254d920:         this.allowTempAutoCreationOnSend = allowTempAutoCreationOnSend;
1:254d920:     }
1:55da9bc: 
1:b9fd189:     @Override
1:55da9bc:     public void reapplyInterceptor() {
1:55da9bc:         queueRegion.reapplyInterceptor();
1:55da9bc:         topicRegion.reapplyInterceptor();
1:55da9bc:         tempQueueRegion.reapplyInterceptor();
1:55da9bc:         tempTopicRegion.reapplyInterceptor();
1:55da9bc:     }
1:3b88ba0: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:6d14e4e
/////////////////////////////////////////////////////////////////////////
1:                     } catch (Throwable e) {
commit:cdb38b3
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     private final TaskRunnerFactory taskRunnerFactory;
1:     private final AtomicBoolean purgeInactiveDestinationsTaskInProgress = new AtomicBoolean(false);
1:             if (purgeInactiveDestinationsTaskInProgress.compareAndSet(false, true)) {
1:                 taskRunnerFactory.execute(purgeInactiveDestinationsWork);
1:             }
1:         }
1:     };
1:     private final Runnable purgeInactiveDestinationsWork = new Runnable() {
1:         @Override
1:         public void run() {
1:             try {
1:                 purgeInactiveDestinations();
1:             } catch (Throwable ignored) {
1:                 LOG.error("Unexpected exception on purgeInactiveDestinations {}", this, ignored);
1:             } finally {
1:                 purgeInactiveDestinationsTaskInProgress.set(false);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         this.taskRunnerFactory = taskRunnerFactory;
commit:d2c0edd
/////////////////////////////////////////////////////////////////////////
1:                             addDestination(adminContext, deadLetterDestination, false).getActiveMQDestination().setDLQ(true);
commit:88daeec
/////////////////////////////////////////////////////////////////////////
1:     public Region getRegion(ActiveMQDestination destination) throws JMSException {
commit:6cc2c11
/////////////////////////////////////////////////////////////////////////
1:         return messageReference.canProcessAsExpired();
commit:0142c4d
/////////////////////////////////////////////////////////////////////////
1:                             long dlqExpiration = deadLetterStrategy.getExpiration();
1:                             if (dlqExpiration > 0) {
1:                                 dlqExpiration += System.currentTimeMillis();
1:                             } else {
1:                                 stampAsExpired(message);
1:                             }
1:                             message.setExpiration(dlqExpiration);
commit:be919fb
/////////////////////////////////////////////////////////////////////////
0:                             addDestination(adminContext, deadLetterDestination, false).getActiveMQDestination().setDLQ();
commit:dc25f2a
/////////////////////////////////////////////////////////////////////////
1:             if (((BaseDestination) message.getRegionDestination()).isPersistJMSRedelivered() && !message.isRedelivered()) {
1:                     if (message.isPersistent()) {
1:                         ((BaseDestination) message.getRegionDestination()).getMessageStore().updateMessage(message);
1:                     }
commit:6cebd2c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransmitCallback;
/////////////////////////////////////////////////////////////////////////
1:     public void preProcessDispatch(final MessageDispatch messageDispatch) {
1:         final Message message = messageDispatch.getMessage();
/////////////////////////////////////////////////////////////////////////
1:                     messageDispatch.setTransmitCallback(new TransmitCallback() {
1:                         // dispatch is considered a delivery, so update sub state post dispatch otherwise
1:                         // on a disconnect/reconnect cached messages will not reflect initial delivery attempt
1:                         final TransmitCallback delegate = messageDispatch.getTransmitCallback();
1:                         @Override
1:                         public void onSuccess() {
1:                             message.incrementRedeliveryCounter();
1:                             if (delegate != null) {
1:                                 delegate.onSuccess();
1:                             }
1:                         }
1: 
1:                         @Override
1:                         public void onFailure() {
1:                             if (delegate != null) {
1:                                 delegate.onFailure();
1:                             }
1:                         }
1:                     });
commit:52e1a05
/////////////////////////////////////////////////////////////////////////
1:                     RuntimeException runtimeException = new RuntimeException("Failed to persist JMSRedeliveryFlag on " + message.getMessageId() + " in " + message.getDestination(), error);
1:                     LOG.warn(runtimeException.getLocalizedMessage(), runtimeException);
1:                     throw runtimeException;
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
0:                             message.getMessageId().setFutureOrSequenceLong(null);
commit:27b3a7c
/////////////////////////////////////////////////////////////////////////
1:     public Map<ActiveMQDestination, Destination> getDestinationMap(ActiveMQDestination destination) {
1:         try {
1:             return getRegion(destination).getDestinationMap();
1:         } catch (JMSException jmse) {
1:             return Collections.emptyMap();
1:         }
1:     }
1: 
1:     @Override
commit:266d23e
/////////////////////////////////////////////////////////////////////////
0:             if (((BaseDestination) message.getRegionDestination()).isPersistJMSRedelivered() && !message.isRedelivered() && message.isPersistent()) {
1:                 final int originalValue = message.getRedeliveryCounter();
1:                 message.incrementRedeliveryCounter();
1:                 try {
0:                     ((BaseDestination) message.getRegionDestination()).getMessageStore().updateMessage(message);
1:                 } catch (IOException error) {
0:                     LOG.error("Failed to persist JMSRedeliveryFlag on {} in {}", message.getMessageId(), message.getDestination(), error);
1:                 } finally {
1:                     message.setRedeliveryCounter(originalValue);
1:                 }
1:             }
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:5076808
/////////////////////////////////////////////////////////////////////////
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:66cfc7b
/////////////////////////////////////////////////////////////////////////
1:                             ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(message, subscription);
1:                             // Prevent a DLQ loop where same message is sent from a DLQ back to itself
1:                             if (deadLetterDestination.equals(message.getDestination())) {
1:                                 LOG.debug("Not re-adding to DLQ: {}, dest: {}", message.getMessageId(), message.getDestination());
1:                                 return false;
1:                             }
1: 
/////////////////////////////////////////////////////////////////////////
commit:3873ecf
/////////////////////////////////////////////////////////////////////////
1: 
1:         ConnectionContext oldContext = null;
1: 
1:             oldContext = clientIdSet.get(clientId);
/////////////////////////////////////////////////////////////////////////
1:         if (oldContext != null) {
1:             if (oldContext.getConnection() != null) {
1:                 Connection connection = oldContext.getConnection();
1:                 LOG.warn("Stealing link for clientId {} From Connection {}", clientId, oldContext.getConnection());
1:                 if (connection instanceof TransportConnection) {
1:                     TransportConnection transportConnection = (TransportConnection) connection;
0:                     transportConnection.stopAsync();
1:                 } else {
1:                     connection.stop();
1:                 }
1:             } else {
1:                 LOG.error("No Connection found for {}", oldContext);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             // we may be removing the duplicate connection, not the first connection to be created
commit:62c20eb
/////////////////////////////////////////////////////////////////////////
1:                 if (context.isAllowLinkStealing()) {
1:                     clientIdSet.put(clientId, context);
0:                     if (oldContext.getConnection() != null) {
0:                         Connection connection = oldContext.getConnection();
0:                         LOG.warn("Stealing link for clientId {} From Connection {}", clientId, oldContext.getConnection());
0:                         if (connection instanceof TransportConnection) {
0:                             transportConnection.stopAsync();
1:                         } else {
0:                             connection.stop();
1:                         }
1:                     } else {
0:                         LOG.error("No Connection found for {}", oldContext);
1:                     }
1:                 } else {
1:                         + oldContext.getConnection().getRemoteAddress());
commit:b9fd189
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.Connection;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.ConsumerBrokerExchange;
1: import org.apache.activemq.broker.EmptyBroker;
1: import org.apache.activemq.broker.ProducerBrokerExchange;
1: import org.apache.activemq.broker.TransportConnection;
1: import org.apache.activemq.broker.TransportConnector;
/////////////////////////////////////////////////////////////////////////
1:                     log.info("{} Inactive for longer than {} ms - removing ...", dest.getName(), dest.getInactiveTimeoutBeforeGC());
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:                         LOG.warn("Stealing link for clientId {} From Connection {}", clientId, oldContext.getConnection());
0:                          LOG.error("Not Connection for {}", oldContext);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("{} addBroker: {} brokerInfo size: {}", new Object[]{ getBrokerName(), info.getBrokerName(), brokerInfos.size() });
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("{} removeBroker: {} brokerInfo size: {}", new Object[]{ getBrokerName(), info.getBrokerName(), brokerInfos.size()});
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("unexpected exception on message expiry determination for: {}", messageReference, e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("Message expired {}", node);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Dead Letter message with no DLQ strategy in place, message id: {}, destination: {}", message.getMessageId(), message.getDestination());
1:             LOG.warn("Caught an exception sending to DLQ: {}", node, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Trying to get Root Broker", e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("unmatched destination: {}, in consumerControl: {}", destination, control);
/////////////////////////////////////////////////////////////////////////
0:                     log.info("{} Inactive for longer than {} ms - removing ...", dest.getName(), dest.getInactiveTimoutBeforeGC());
1:                         LOG.error("Failed to remove inactive destination {}", dest, e);
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:e19293d
/////////////////////////////////////////////////////////////////////////
1:                     transportConnection.stopAsync(new IOException("Stealing link for clientId " + clientId + " From Connection " + oldContext.getConnection().getConnectionId()));
commit:1cab713
/////////////////////////////////////////////////////////////////////////
commit:7646526
/////////////////////////////////////////////////////////////////////////
1:                             ConnectionContext adminContext = context;
1:                             if (context.getSecurityContext() == null || !context.getSecurityContext().isBrokerContext()) {
1:                                 adminContext = BrokerSupport.getConnectionContext(this);
1:                             BrokerSupport.resendNoCopy(adminContext, message, deadLetterDestination);
commit:55da9bc
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void reapplyInterceptor() {
1:         queueRegion.reapplyInterceptor();
1:         topicRegion.reapplyInterceptor();
1:         tempQueueRegion.reapplyInterceptor();
1:         tempTopicRegion.reapplyInterceptor();
1:     }
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:a581d01
/////////////////////////////////////////////////////////////////////////
1:     public ConnectionContext getConnectionContext(String clientId) {
1:         return clientIdSet.get(clientId);
1:     }
1: 
author:Rob Davies
-------------------------------------------------------------------------------
commit:497fbfc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.*;
/////////////////////////////////////////////////////////////////////////
0:                          Connection connection = oldContext.getConnection();
0:                          LOG.warn("Stealing link for clientId {} From Connection {}", clientId, oldContext.getConnection());
0:                          if (connection instanceof TransportConnection){
0:                             TransportConnection transportConnection = (TransportConnection) connection;
0:                              transportConnection.stopAsync();
0:                          }else{
0:                              connection.stop();
1:                          }
commit:16c1627
/////////////////////////////////////////////////////////////////////////
0:                 if (context.isAllowLinkStealing()){
1:                      clientIdSet.remove(clientId);
0:                      if (oldContext.getConnection() != null) {
0:                         LOG.warn("Stealing link for clientId " + clientId + " From Connection " + oldContext.getConnection());
0:                         oldContext.getConnection().stop();
0:                      }else{
0:                          LOG.error("Not Connection for " + oldContext);
1:                      }
0:                 }else{
1:                     throw new InvalidClientIDException("Broker: " + getBrokerName() + " - Client: " + clientId + " already connected from "
0:                             + oldContext.getConnection().getRemoteAddress());
1:                 }
author:Gary Tully
-------------------------------------------------------------------------------
commit:708be6d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
1:         getRoot().sendToDeadLetterQueue(context, node, subscription, new Throwable("Message Expired. Expiration:" + node.getExpiration()));
1:     public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference node, Subscription subscription, Throwable poisonCause) {
/////////////////////////////////////////////////////////////////////////
1:                             if (poisonCause != null) {
1:                                 message.setProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY,
1:                                         poisonCause.toString());
1:                             }
commit:1005fc5
/////////////////////////////////////////////////////////////////////////
1:         return new TempQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
commit:33cdefa
/////////////////////////////////////////////////////////////////////////
commit:179d95e
/////////////////////////////////////////////////////////////////////////
1:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination, boolean createIfTemp) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:      synchronized (destinations) {
1:         answer = destinations.get(destination);
1:         if (answer != null) {
1:             return answer;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:             answer = tempQueueRegion.addDestination(context, destination, createIfTemp);
0:             answer = tempTopicRegion.addDestination(context, destination, createIfTemp);
/////////////////////////////////////////////////////////////////////////
1:      }
/////////////////////////////////////////////////////////////////////////
1:                 // This seems to cause the destination to be added but without
1:                 // advisories firing...
1:                 context.getBroker().addDestination(context, destination, isAllowTempAutoCreationOnSend());
commit:d4ccc50
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.TransportConnection;
/////////////////////////////////////////////////////////////////////////
0:                 if (!destinations.containsKey(destination)) {
0:                     // This seems to cause the destination to be added but without
0:                     // advisories firing...
0:                     context.getBroker().addDestination(context, destination, true);
0:                     // associate it with the connection so that it can get deleted
0:                     if (destination.isTemporary() && context.getConnectionState() != null) {
0:                         DestinationInfo destinationInfo = new DestinationInfo(context.getConnectionId(),
0:                                 DestinationInfo.ADD_OPERATION_TYPE,
0:                                 destination);
0:                         context.getConnectionState().addTempDestination(destinationInfo);
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("assigning ownership of auto created temp : " + destination + " to connection:"
0:                                     + context.getConnectionId());
1:                         }
1:                     }
1:                 }
commit:f260b17
/////////////////////////////////////////////////////////////////////////
0:                 tempQueueRegion.removeDestination(context, destination, timeout);
0:                 tempTopicRegion.removeDestination(context, destination, timeout);
commit:6590d4b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3b7507f
/////////////////////////////////////////////////////////////////////////
commit:4d17a70
/////////////////////////////////////////////////////////////////////////
1:         Map<ActiveMQDestination, Destination> answer = new HashMap<ActiveMQDestination, Destination>(getQueueRegion().getDestinationMap());
commit:254d920
/////////////////////////////////////////////////////////////////////////
1:     private boolean allowTempAutoCreationOnSend;
/////////////////////////////////////////////////////////////////////////
0:             producerExchange.getConnectionContext().getBroker().addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());
/////////////////////////////////////////////////////////////////////////
1:             if (isAllowTempAutoCreationOnSend()) {
1:                 map.putAll(tempQueueRegion.getDestinationMap());
1:                 map.putAll(tempTopicRegion.getDestinationMap());
1:             }
/////////////////////////////////////////////////////////////////////////
1:                         getRoot().removeDestination(context, dest.getActiveMQDestination(), isAllowTempAutoCreationOnSend() ? 1 : 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isAllowTempAutoCreationOnSend() {
1:         return allowTempAutoCreationOnSend;
1:     }
1: 
1:     public void setAllowTempAutoCreationOnSend(boolean allowTempAutoCreationOnSend) {
1:         this.allowTempAutoCreationOnSend = allowTempAutoCreationOnSend;
1:     }
commit:b9045db
/////////////////////////////////////////////////////////////////////////
0:                 context.getBroker().addDestination(context, destination, true);
commit:32d24fb
/////////////////////////////////////////////////////////////////////////
0:         getRoot().sendToDeadLetterQueue(context, node, subscription);
commit:27c1719
/////////////////////////////////////////////////////////////////////////
1:     public void messageExpired(ConnectionContext context, MessageReference node, Subscription subscription) {
0:         getRoot().sendToDeadLetterQueue(context, node, null);
0: 	        MessageReference node, Subscription subscription){
/////////////////////////////////////////////////////////////////////////
0: 							        .getDeadLetterQueueFor(message, subscription);
commit:c752230
/////////////////////////////////////////////////////////////////////////
1:     private final Map<BrokerId, BrokerInfo> brokerInfos = new HashMap<BrokerId, BrokerInfo>();
/////////////////////////////////////////////////////////////////////////
1:         BrokerInfo existing = brokerInfos.get(info.getBrokerId());
1:         if (existing == null) {
1:             existing = info.copy();
1:             existing.setPeerBrokerInfos(null);
1:             brokerInfos.put(info.getBrokerId(), existing);
1:         }
1:         existing.incrementRefCount();
0:         LOG.debug(getBrokerName() + " addBroker:" + info.getBrokerName() + " brokerInfo size : " + brokerInfos.size());
1:             BrokerInfo existing = brokerInfos.get(info.getBrokerId());
1:             if (existing != null && existing.decrementRefCount() == 0) {
1:                brokerInfos.remove(info.getBrokerId());
1:             }
0:             LOG.debug(getBrokerName() + " removeBroker:" + info.getBrokerName() + " brokerInfo size : " + brokerInfos.size());
/////////////////////////////////////////////////////////////////////////
1:         result = brokerInfos.values().toArray(result);
commit:66a945a
/////////////////////////////////////////////////////////////////////////
0: 					        LOG.debug("Dead Letter message with no DLQ strategy in place, message id: "
0:                                     + message.getMessageId() + ", destination: " + message.getDestination());
commit:8d3ca90
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
1:     
1:     @Override
1:     public void processConsumerControl(ConsumerBrokerExchange consumerExchange, ConsumerControl control) {
1:         ActiveMQDestination destination = control.getDestination();
1:         switch (destination.getDestinationType()) {
1:         case ActiveMQDestination.QUEUE_TYPE:
0:             queueRegion.processConsumerControl(consumerExchange, control);
1:             break;
1: 
1:         case ActiveMQDestination.TOPIC_TYPE:
0:             topicRegion.processConsumerControl(consumerExchange, control);
1:             break;
1:             
1:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             tempQueueRegion.processConsumerControl(consumerExchange, control);
1:             break;
1:             
1:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             tempTopicRegion.processConsumerControl(consumerExchange, control);
1:             break;
1:             
1:         default:
0:             LOG.warn("unmatched destination: " + destination + ", in consumerControl: "  + control);
1:         }
1:     }
commit:e80bf00
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 						    stampAsExpired(message);
commit:9b260dc
/////////////////////////////////////////////////////////////////////////
1: 							}
commit:ce18ec8
/////////////////////////////////////////////////////////////////////////
1: 							}                        
1: 							                           
0: 							// Clear out the memory usage for the old queue. 
0: 							// We'll reset it to the DLQ below:
0: 							message.setMemoryUsage(null);
commit:a1bd85e
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             long expiration=message.getExpiration();     
1:     
/////////////////////////////////////////////////////////////////////////
1: 						    // message may be inflight to other subscriptions so do not modify
1: 						    message = message.copy();
0: 						    message.setExpiration(0);
0: 						    if(!message.isPersistent()){
/////////////////////////////////////////////////////////////////////////
0: 							BrokerSupport.resendNoCopy(context,message,
commit:ca242f4
/////////////////////////////////////////////////////////////////////////
0:         boolean expired = false;
0:         if (messageReference.isExpired()) {
1:             try {
0:                 // prevent duplicate expiry processing
0:                 Message message = messageReference.getMessage();
0:                 synchronized (message) {
0:                     expired = stampAsExpired(message);
1:                 }
0:             } catch (IOException e) {
0:                 LOG.warn("unexpected exception on message expiry determination for: " + messageReference, e);
1:             }
1:         }
0:         return expired;
1:     }
1:    
1:     private boolean stampAsExpired(Message message) throws IOException {
0:         boolean stamped=false;
1:         if (message.getProperty(ORIGINAL_EXPIRATION) == null) {
0:             long expiration=message.getExpiration();
0:             message.setExpiration(0);
0:             message.setProperty(ORIGINAL_EXPIRATION,new Long(expiration));
1:             stamped = true;
1:         }
1:         return stamped;
/////////////////////////////////////////////////////////////////////////
0: 				stampAsExpired(message);
0: 				if(message!=null && node.getRegionDestination()!=null){
/////////////////////////////////////////////////////////////////////////
commit:7a59d28
/////////////////////////////////////////////////////////////////////////
1:     public static final String ORIGINAL_EXPIRATION = "originalExpiration";
/////////////////////////////////////////////////////////////////////////
0: 							message.setProperty(ORIGINAL_EXPIRATION,new Long(
commit:c6a485f
/////////////////////////////////////////////////////////////////////////
1: 					} else {
0: 					    if (LOG.isDebugEnabled()) {
0: 					        LOG.debug("Expired message with no DLQ strategy in place");
1: 					    }
commit:2d0fa5e
/////////////////////////////////////////////////////////////////////////
1:         if (destinations.containsKey(destination)) {
/////////////////////////////////////////////////////////////////////////
1:             destinations.remove(destination);
commit:99819f3
/////////////////////////////////////////////////////////////////////////
0: 						    if (node.getRegionDestination().getActiveMQDestination().isTopic()) {
0: 						        // message may be inflight to other subscriptions so do not modify
0: 						        message = message.copy();
1: 						    }
1: 							    message.setPersistent(true);
0: 							    message.setProperty("originalDeliveryMode",
1: 							// not get filled when the message is first sent,
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e06685f
/////////////////////////////////////////////////////////////////////////
1: 
commit:7400977
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             return getRegion(destination).getDestinations(destination);
1:         } catch (JMSException jmse) {
/////////////////////////////////////////////////////////////////////////
1:         boolean create = true;
0:         if (destination.isTemporary())
1:             create = createIfTemp;
1:         answer = getRegion(destination).addDestination(context, destination, create);
/////////////////////////////////////////////////////////////////////////
1:             getRegion(destination).removeDestination(context, destination, timeout);
/////////////////////////////////////////////////////////////////////////
1:                 getRegion(destination).addProducer(context, info);
/////////////////////////////////////////////////////////////////////////
1:                 getRegion(destination).removeProducer(context, info);
/////////////////////////////////////////////////////////////////////////
1:             return getRegion(destination).addConsumer(context, info);
/////////////////////////////////////////////////////////////////////////
1:             getRegion(destination).removeConsumer(context, info);
/////////////////////////////////////////////////////////////////////////
1:             producerExchange.setRegion(getRegion(destination));
/////////////////////////////////////////////////////////////////////////
1:         if (producerExchange.isMutable()) {
/////////////////////////////////////////////////////////////////////////
1:             consumerExchange.setRegion(getRegion(destination));
0:     protected Region getRegion(ActiveMQDestination destination) throws JMSException {
0:         switch (destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
1:             return queueRegion;
0:         case ActiveMQDestination.TOPIC_TYPE:
1:             return topicRegion;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:             return tempQueueRegion;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:             return tempTopicRegion;
0:         default:
1:             throw createUnknownDestinationTypeException(destination);
1:         }
1:     }
1: 
1:         return getRegion(destination).messagePull(context, pull);
/////////////////////////////////////////////////////////////////////////
1:         getRegion(destination).processDispatchNotification(messageDispatchNotification);
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             getRegion(destination).processConsumerControl(consumerExchange, control);
1:         } catch (JMSException jmse) {
commit:e66967b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ((TopicRegion)topicRegion).setKeepDurableSubsActive(keepDurableSubsActive);
commit:2280719
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.InvalidClientIDException;
1: import javax.jms.JMSException;
1: import java.io.IOException;
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
/////////////////////////////////////////////////////////////////////////
1:         addBrokerInClusterUpdate(info);
/////////////////////////////////////////////////////////////////////////
1:             removeBrokerInClusterUpdate(info);
/////////////////////////////////////////////////////////////////////////
1:     protected void addBrokerInClusterUpdate(BrokerInfo info) {
1:                 connector.addPeerBroker(info);
1:     protected void removeBrokerInClusterUpdate(BrokerInfo info) {
1:                 connector.removePeerBroker(info);
commit:44ef96e
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug(getBrokerName() + " addBroker:" + info.getBrokerName() + " brokerInfo size : " + brokerInfos.size());
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug(getBrokerName() + " removeBroker:" + info.getBrokerName() + " brokerInfo size : " + brokerInfos.size());
1:             }
commit:d17eceb
/////////////////////////////////////////////////////////////////////////
1:         if (destinationInterceptor != null) {
1:             destinationInterceptor.create(this, context, destination);
1:         }
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(RegionBroker.class);
/////////////////////////////////////////////////////////////////////////
0:             LOG.error("Trying to get Root Broker " + e);
commit:ec30bf0
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionContext context = BrokerSupport.getConnectionContext(this);
commit:44d6be4
/////////////////////////////////////////////////////////////////////////
1:         if (producerExchange.isMutable() || producerExchange.getRegion() == null
0:                 || (producerExchange.getRegion() != null && producerExchange.getRegion().getDestinationMap().get(message.getDestination()) == null)) {
/////////////////////////////////////////////////////////////////////////
1:             producerExchange.setRegionDestination(null);
commit:62e1abf
/////////////////////////////////////////////////////////////////////////
1:         // clear the state
1:         clientIdSet.clear();
1:         connections.clear();
1:         destinations.clear();
1:         brokerInfos.clear();
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:0bb9013
/////////////////////////////////////////////////////////////////////////
0:     public boolean sendToDeadLetterQueue(ConnectionContext context, MessageReference node, Subscription subscription) {
/////////////////////////////////////////////////////////////////////////
1:                             return true;
/////////////////////////////////////////////////////////////////////////
1: 
1:         return false;
commit:d7aaca5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.BrokerId;
1: import org.apache.activemq.command.BrokerInfo;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerControl;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageDispatchNotification;
1: import org.apache.activemq.command.MessagePull;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.TransactionId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ActiveMQDestination, ActiveMQDestination> destinationGate = new HashMap<ActiveMQDestination, ActiveMQDestination>();
/////////////////////////////////////////////////////////////////////////
1:         DestinationInterceptor destinationInterceptor, Scheduler scheduler, ThreadPoolExecutor executor) throws IOException {
1:         this.executor = executor;
/////////////////////////////////////////////////////////////////////////
1:     public Set<Destination> getDestinations(ActiveMQDestination destination) {
/////////////////////////////////////////////////////////////////////////
0:                     + oldContext.getConnection().getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1:         synchronized (destinationGate) {
1:             answer = destinations.get(destination);
1:             if (answer != null) {
1:                 return answer;
1:             }
1: 
1:             if (destinationGate.get(destination) != null) {
1:                 // Guard against spurious wakeup.
1:                 while (destinationGate.containsKey(destination)) {
1:                     destinationGate.wait();
1:                 }
1:                 answer = destinations.get(destination);
1:                 if (answer != null) {
1:                     return answer;
0:                 } else {
1:                     // In case of intermediate remove or add failure
1:                     destinationGate.put(destination, destination);
1:                 }
1:             }
1:         try {
0:             boolean create = true;
1:             if (destination.isTemporary()) {
0:                 create = createIfTemp;
1:             }
0:             answer = getRegion(destination).addDestination(context, destination, create);
1:             destinations.put(destination, answer);
1:         } finally {
1:             synchronized (destinationGate) {
1:                 destinationGate.remove(destination);
1:                 destinationGate.notifyAll();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         addDestination(context, info.getDestination(), true);
/////////////////////////////////////////////////////////////////////////
1:             || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {
1:             producerExchange.getConnectionContext().getBroker()
1:                 .addDestination(producerExchange.getConnectionContext(), destination, isAllowTempAutoCreationOnSend());
/////////////////////////////////////////////////////////////////////////
0:             case ActiveMQDestination.QUEUE_TYPE:
1:                 return queueRegion;
0:             case ActiveMQDestination.TOPIC_TYPE:
1:                 return topicRegion;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
1:                 return tempQueueRegion;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
1:                 return tempTopicRegion;
0:             default:
0:                 throw createUnknownDestinationTypeException(destination);
/////////////////////////////////////////////////////////////////////////
0:                 brokerInfos.remove(info.getBrokerId());
/////////////////////////////////////////////////////////////////////////
1:                 ((Destination) message.getRegionDestination()).getDestinationStatistics().getProcessTime().addTime(totalTime);
/////////////////////////////////////////////////////////////////////////
1:         ((TopicRegion) topicRegion).setKeepDurableSubsActive(keepDurableSubsActive);
/////////////////////////////////////////////////////////////////////////
1:         boolean stamped = false;
1:             long expiration = message.getExpiration();
1:             message.setProperty(ORIGINAL_EXPIRATION, new Long(expiration));
/////////////////////////////////////////////////////////////////////////
0:     public void sendToDeadLetterQueue(ConnectionContext context, MessageReference node, Subscription subscription) {
1:         try {
1:             if (node != null) {
1:                 Message message = node.getMessage();
1:                 if (message != null && node.getRegionDestination() != null) {
1:                     DeadLetterStrategy deadLetterStrategy = ((Destination) node.getRegionDestination()).getDeadLetterStrategy();
1:                     if (deadLetterStrategy != null) {
1:                         if (deadLetterStrategy.isSendToDeadLetterQueue(message)) {
1:                             if (!message.isPersistent()) {
1:                                 message.setProperty("originalDeliveryMode", "NON_PERSISTENT");
0:                             ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(message, subscription);
0:                             if (context.getBroker() == null) {
0:                             BrokerSupport.resendNoCopy(context, message, deadLetterDestination);
0:                             LOG.debug("Dead Letter message with no DLQ strategy in place, message id: " + message.getMessageId() + ", destination: "
0:                                 + message.getDestination());
1:         } catch (Exception e) {
0:             LOG.warn("Caught an exception sending to DLQ: " + node, e);
/////////////////////////////////////////////////////////////////////////
1:         synchronized (sequenceGenerator) {
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("unmatched destination: " + destination + ", in consumerControl: " + control);
/////////////////////////////////////////////////////////////////////////
0:                     log.info(dest.getName() + " Inactive for longer than " + dest.getInactiveTimoutBeforeGC() + " ms - removing ...");
commit:3a8eb74
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.URI;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.List;
1: import java.util.Locale;
0: import java.util.Map;
0: import java.util.Set;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.ThreadPoolExecutor;
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
0: import javax.jms.InvalidClientIDException;
0: import javax.jms.JMSException;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:             // When stopping don't send cluster updates since we are the one's tearing down
1:             // our own bridges.
1:             if (!brokerService.isStopping()) {
0:                 removeBrokerInClusterUpdate(info);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:17995e6
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("rawtypes")
/////////////////////////////////////////////////////////////////////////
1:             List<Destination> list = new ArrayList<Destination>();
/////////////////////////////////////////////////////////////////////////
1:                 d.markForGC(timeStamp);
1:                 if (d.canGC()) {
1:                     list.add(d);
1:                     if (maxPurgedDests > 0 && list.size() == maxPurgedDests) {
0:                         break;
1:             if (!list.isEmpty()) {
1:                 for (Destination dest : list) {
1:                     Logger log = LOG;
1:                     if (dest instanceof BaseDestination) {
1:                         log = ((BaseDestination) dest).getLog();
1:                     }
0:                     log.info(dest.getName() + " Inactive for longer than " +
0:                              dest.getInactiveTimoutBeforeGC() + " ms - removing ...");
commit:f0d9f83
/////////////////////////////////////////////////////////////////////////
1:             long maxPurgedDests = this.brokerService.getMaxPurgedDestinationsPerSweep();
/////////////////////////////////////////////////////////////////////////
1: 
0:                         if (maxPurgedDests > 0 && list.size() == maxPurgedDests) {
0:                             break;
1:                         }
commit:ead8df6
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
/////////////////////////////////////////////////////////////////////////
1: 
1:     private final ReentrantReadWriteLock inactiveDestinationsPurgeLock = new ReentrantReadWriteLock();
/////////////////////////////////////////////////////////////////////////
1:         if (destination != null) {
1:             inactiveDestinationsPurgeLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
1:                 inactiveDestinationsPurgeLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         if (destination != null) {
1:             inactiveDestinationsPurgeLock.readLock().lock();
1:             try {
/////////////////////////////////////////////////////////////////////////
1:             } finally {
1:                 inactiveDestinationsPurgeLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         inactiveDestinationsPurgeLock.readLock().lock();
1:         try {
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             inactiveDestinationsPurgeLock.readLock().unlock();
1:         inactiveDestinationsPurgeLock.readLock().lock();
1:         try {
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             inactiveDestinationsPurgeLock.readLock().unlock();
1:         inactiveDestinationsPurgeLock.readLock().lock();
1:         try {
1:         } finally {
1:             inactiveDestinationsPurgeLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:         inactiveDestinationsPurgeLock.writeLock().lock();
1:         try {
/////////////////////////////////////////////////////////////////////////
1:         } finally {
1:             inactiveDestinationsPurgeLock.writeLock().unlock();
commit:b5a1916
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
/////////////////////////////////////////////////////////////////////////
0:                 if (context.isFaultTolerant() || context.isNetworkConnection()){
0:                     //remove the old connection
0:                     try{
0:                         removeConnection(oldContext, info, new Exception("remove stale client"));
0:                     }catch(Exception e){
0:                         LOG.warn("Failed to remove stale connection ",e);
1:                     }
0:                 }else{
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 || (producerExchange.getRegion() != null && producerExchange.getRegion().getDestinationMap().get(message.getDestination()) == null)
0:                 || (producerExchange.getRegionDestination() != null && producerExchange.getRegionDestination().isDisposed())) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:             long expiration=message.getExpiration();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:             MessageReference node, Subscription subscription){
0:         try{
0:             if(node!=null){
0:                 Message message=node.getMessage();
0:                 if(message!=null && node.getRegionDestination()!=null){
0:                     DeadLetterStrategy deadLetterStrategy=node
0:                             .getRegionDestination().getDeadLetterStrategy();
0:                     if(deadLetterStrategy!=null){
0:                         if(deadLetterStrategy.isSendToDeadLetterQueue(message)){
0:                             // message may be inflight to other subscriptions so do not modify
0:                             message = message.copy();
0:                             stampAsExpired(message);
0:                             message.setExpiration(0);
0:                             if(!message.isPersistent()){
0:                                 message.setPersistent(true);
0:                                 message.setProperty("originalDeliveryMode",
0:                                         "NON_PERSISTENT");
1:                             }
1:                             // The original destination and transaction id do
0:                             // not get filled when the message is first sent,
1:                             // it is only populated if the message is routed to
1:                             // another destination like the DLQ
0:                             ActiveMQDestination deadLetterDestination=deadLetterStrategy
0:                                     .getDeadLetterQueueFor(message, subscription);
0:                             if (context.getBroker()==null) {
0:                                 context.setBroker(getRoot());
1:                             }
0:                             BrokerSupport.resendNoCopy(context,message,
0:                                     deadLetterDestination);
1:                         }
0:                     } else {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Dead Letter message with no DLQ strategy in place, message id: "
1:                         }
1:                     }
1:                 }
1:             }
0:         }catch(Exception e){
0:             LOG.warn("Caught an exception sending to DLQ: "+node,e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:6672740
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.advisory.AdvisorySupport;
/////////////////////////////////////////////////////////////////////////
0:                 removeAdvisoryTopics("Queue.", context, destination, timeout);
0:                 removeAdvisoryTopics("Topic.", context, destination, timeout);
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void removeAdvisoryTopics(String destinationType, ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {
0:         if (this.brokerService.isAdvisorySupport()) {
0:             String producerAdvisoryTopic = AdvisorySupport.PRODUCER_ADVISORY_TOPIC_PREFIX + destinationType + destination.getPhysicalName();
0:             String consumerAdvisoryTopic = AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX + destinationType + destination.getPhysicalName();
1: 
0:             ActiveMQDestination dests[] = getDestinations();
0:             for (ActiveMQDestination dest: dests) {
0:                 String name = dest.getPhysicalName();
0:                 if ( name.equals(producerAdvisoryTopic) || name.equals(consumerAdvisoryTopic) ) {
1:                     try {
0:                         removeDestination(context, dest, timeout);
0:                     } catch (JMSException ignore) {
0:                         // at least ignore the Unknown Destination Type JMSException
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
author:Christian Posta
-------------------------------------------------------------------------------
commit:e07d29c
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination destination = message.getDestination();
/////////////////////////////////////////////////////////////////////////
1: 
1:         // clean up so these references aren't kept (possible leak) in the producer exchange
1:         // especially since temps are transitory
0:         if (destination.isTemporary()) {
1:             producerExchange.setRegionDestination(null);
1:             producerExchange.setRegion(null);
1:         }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:30f531d
/////////////////////////////////////////////////////////////////////////
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
0:                 ((Destination)message.getRegionDestination()).getDestinationStatistics().getProcessTime().addTime(totalTime);
/////////////////////////////////////////////////////////////////////////
0:                     DeadLetterStrategy deadLetterStrategy=((Destination)node
0:                             .getRegionDestination()).getDeadLetterStrategy();
commit:d5dd937
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PListStore;
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:13829ef
/////////////////////////////////////////////////////////////////////////
0:     protected BrokerService brokerService;
/////////////////////////////////////////////////////////////////////////
0:         return new TempQueueRegion(this, brokerService, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     public Map<ActiveMQDestination, Destination> getDestinationMap() {
0:         Map<ActiveMQDestination, Destination> answer = getQueueRegion().getDestinationMap();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public Set<ActiveMQDestination> getDurableDestinations() {
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     protected final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:     protected DestinationFactory destinationFactory;
1:     protected final Map<ConnectionId, ConnectionState> connectionStates = Collections.synchronizedMap(new HashMap<ConnectionId, ConnectionState>());
1: 
/////////////////////////////////////////////////////////////////////////
1:     private final CopyOnWriteArrayList<Connection> connections = new CopyOnWriteArrayList<Connection>();
1:     private final Map<ActiveMQDestination, Destination> destinations = new ConcurrentHashMap<ActiveMQDestination, Destination>();
0:     private final CopyOnWriteArrayList<BrokerInfo> brokerInfos = new CopyOnWriteArrayList<BrokerInfo>();
0:     private Map<String, ConnectionContext> clientIdSet = new HashMap<String, ConnectionContext>(); 
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Connection> l = new ArrayList<Connection>(connections);
/////////////////////////////////////////////////////////////////////////
0:         answer = destinations.get(destination);
0:         if (answer != null) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Destination> l;
0:         l = new ArrayList<Destination>(destinations.values());
/////////////////////////////////////////////////////////////////////////
0:         result = brokerInfos.toArray(result);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     private static final IdGenerator BROKER_ID_GENERATOR = new IdGenerator();
/////////////////////////////////////////////////////////////////////////
1:             brokerId = new BrokerId(BROKER_ID_GENERATOR.generateId());
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(RegionBroker.class);
/////////////////////////////////////////////////////////////////////////
1:     private boolean started;
1:     private boolean keepDurableSubsActive;
1: 
1: 
1:     private final LongSequenceGenerator sequenceGenerator = new LongSequenceGenerator();
0:     private Map<String, ConnectionContext> clientIdSet = new HashMap<String, ConnectionContext>(); // we
0:     // will
0:     // synchronize
0:     // access
1: 
0:     public RegionBroker(BrokerService brokerService, TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, DestinationFactory destinationFactory,
0:                         DestinationInterceptor destinationInterceptor) throws IOException {
1:         this.sequenceGenerator.setLastSequenceId(destinationFactory.getLastMessageBrokerSequenceId());
1:         tempTopicRegion = createTempTopicRegion(memoryManager, taskRunnerFactory, destinationFactory);
1: 
/////////////////////////////////////////////////////////////////////////
0:         switch (destination.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
0:     public Broker getAdaptor(Class type) {
0:         if (type.isInstance(this)) {
/////////////////////////////////////////////////////////////////////////
1:         return new TempTopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
0:         return new TempQueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:         return new TopicRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1:         return new QueueRegion(this, destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public PolicyMap getDestinationPolicy() {
/////////////////////////////////////////////////////////////////////////
1:         synchronized (clientIdSet) {
0:             ConnectionContext oldContext = clientIdSet.get(clientId);
1:             if (oldContext != null) {
0:                 throw new InvalidClientIDException("Broker: " + getBrokerName() + " - Client: " + clientId + " already connected from "
0:                                                    + oldContext.getConnection().getRemoteAddress());
0:             } else {
/////////////////////////////////////////////////////////////////////////
0:             // we may be removing the duplicate connection, not the first
0:             // connection to be created
1:             if (oldValue == context) {
/////////////////////////////////////////////////////////////////////////
1:         Destination answer;
0:         answer = (Destination)destinations.get(destination);
0:         if (answer != null)
1:             return answer;
0:         switch (destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             answer = queueRegion.addDestination(context, destination);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             answer = topicRegion.addDestination(context, destination);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             answer = tempQueueRegion.addDestination(context, destination);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             answer = tempTopicRegion.addDestination(context, destination);
0:             break;
0:         default:
0:             throw createUnknownDestinationTypeException(destination);
1:         }
0:         destinations.put(destination, answer);
1:         return answer;
1:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {
1: 
0:         if (destinations.remove(destination) != null) {
0:             switch (destination.getDestinationType()) {
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 queueRegion.removeDestination(context, destination, timeout);
0:                 break;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 topicRegion.removeDestination(context, destination, timeout);
0:                 break;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 tempQueueRegion.removeDestination(context, destination, timeout);
0:                 break;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 tempTopicRegion.removeDestination(context, destination, timeout);
0:                 break;
0:             default:
0:                 throw createUnknownDestinationTypeException(destination);
1:             }
1:         }
1: 
1:     }
1: 
1:     public void addDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
0:         addDestination(context, info.getDestination());
1: 
1:     }
1: 
1:     public void removeDestinationInfo(ConnectionContext context, DestinationInfo info) throws Exception {
1:         removeDestination(context, info.getDestination(), info.getTimeout());
1: 
0:         ArrayList l;
0:         l = new ArrayList(destinations.values());
1:         ActiveMQDestination rc[] = new ActiveMQDestination[l.size()];
1:         l.toArray(rc);
1:         return rc;
1:     }
/////////////////////////////////////////////////////////////////////////
0:         switch (destination.getDestinationType()) {
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         switch (destination.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
1:     public void send(ProducerBrokerExchange producerExchange, Message message) throws Exception {
0:         long si = sequenceGenerator.getNextSequenceId();
0:         if (producerExchange.isMutable() || producerExchange.getRegion() == null) {
0:             ActiveMQDestination destination = message.getDestination();
0:             addDestination(producerExchange.getConnectionContext(), destination);
0:             Region region = null;
0:             switch (destination.getDestinationType()) {
0:                 region = queueRegion;
0:                 region = topicRegion;
0:                 region = tempQueueRegion;
0:                 region = tempTopicRegion;
1:         producerExchange.getRegion().send(producerExchange, message);
1:     public void acknowledge(ConsumerBrokerExchange consumerExchange, MessageAck ack) throws Exception {
1:         if (consumerExchange.isWildcard() || consumerExchange.getRegion() == null) {
1:             ActiveMQDestination destination = ack.getDestination();
0:             Region region = null;
0:             switch (destination.getDestinationType()) {
0:                 region = queueRegion;
0:                 region = topicRegion;
0:                 region = tempQueueRegion;
0:                 region = tempTopicRegion;
1:         consumerExchange.getRegion().acknowledge(consumerExchange, ack);
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (brokerId == null) {
0:             // TODO: this should persist the broker id so that subsequent
0:             // startup
0:             brokerId = new BrokerId(brokerIdGenerator.generateId());
1: 
1:         if (brokerName == null) {
1:                 brokerName = "localhost";
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void addBroker(Connection connection, BrokerInfo info) {
0:         brokerInfos.add(info);
1:     public synchronized void removeBroker(Connection connection, BrokerInfo info) {
1:         if (info != null) {
0:             brokerInfos.remove(info);
1:         }
1:     }
1: 
1:     public synchronized BrokerInfo[] getPeerBrokerInfos() {
1: 
0:     public void preProcessDispatch(MessageDispatch messageDispatch) {
0:         Message message = messageDispatch.getMessage();
1:         if (message != null) {
1:             long endTime = System.currentTimeMillis();
1:             if (getBrokerService().isEnableStatistics()) {
1: 
1:     public void postProcessDispatch(MessageDispatch messageDispatch) {
1: 
0:         switch (destination.getDestinationType()) {
/////////////////////////////////////////////////////////////////////////
1: 
0:     public boolean isSlaveBroker() {
1: 
1:     public boolean isStopped() {
1: 
0:     public Set getDurableDestinations() {
1: 
0:     public boolean isFaultTolerantConfiguration() {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public Map<ConnectionId, ConnectionState> getConnectionStates() {
1:         return connectionStates;
1:     }
1: 
1:     public URI getVmConnectorURI() {
1:     public void brokerServiceStarted() {
1:     public BrokerService getBrokerService() {
1: 
0:     public void messageExpired(ConnectionContext context, MessageReference node) {
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Message expired " + node);
0:         getRoot().sendToDeadLetterQueue(context, node);
0:     public void sendToDeadLetterQueue(ConnectionContext context, MessageReference node) {
1:         try {
0:             if (node != null) {
0:                 Message message = node.getMessage();
0:                 if (message != null) {
0:                     DeadLetterStrategy deadLetterStrategy = node.getRegionDestination().getDeadLetterStrategy();
0:                     if (deadLetterStrategy != null) {
0:                         if (deadLetterStrategy.isSendToDeadLetterQueue(message)) {
0:                             long expiration = message.getExpiration();
0:                             message.setProperty("originalExpiration", new Long(expiration));
0:                             if (!message.isPersistent()) {
0:                                 message.setProperty("originalDeliveryMode", "NON_PERSISTENT");
0:                             // The original destination and transaction id do
0:                             // not get filled when the message is first
0:                             // it is only populated if the message is routed to
0:                             // another destination like the DLQ
0:                             ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(message.getDestination());
0:                             BrokerSupport.resend(context, message, deadLetterDestination);
0:                 } else {
0:                     LOG.warn("Null message for node: " + node);
1:         } catch (Exception e) {
0:             LOG.warn("Failed to pass expired message to dead letter queue");
1:     public Broker getRoot() {
1:         try {
1:         } catch (Exception e) {
0:             LOG.fatal("Trying to get Root Broker " + e);
commit:ea74731
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.state.ConnectionState;
/////////////////////////////////////////////////////////////////////////
0:     protected final Map<ConnectionId, ConnectionState> connectionStates = Collections.synchronizedMap(new HashMap<ConnectionId, ConnectionState>());
/////////////////////////////////////////////////////////////////////////
0: 	public Map<ConnectionId, ConnectionState> getConnectionStates() {
commit:3b88ba0
/////////////////////////////////////////////////////////////////////////
0:     private final Map destinations = new ConcurrentHashMap();
/////////////////////////////////////////////////////////////////////////
0: 		Destination answer;
0: 		answer = (Destination) destinations.get(destination);
0: 		if (answer != null)
0: 			return answer;
1: 
0: 		switch (destination.getDestinationType()) {
0: 		case ActiveMQDestination.QUEUE_TYPE:
0: 			answer = queueRegion.addDestination(context, destination);
0: 			break;
0: 		case ActiveMQDestination.TOPIC_TYPE:
0: 			answer = topicRegion.addDestination(context, destination);
0: 			break;
0: 		case ActiveMQDestination.TEMP_QUEUE_TYPE:
0: 			answer = tempQueueRegion.addDestination(context, destination);
0: 			break;
0: 		case ActiveMQDestination.TEMP_TOPIC_TYPE:
0: 			answer = tempTopicRegion.addDestination(context, destination);
0: 			break;
0: 		default:
0: 			throw createUnknownDestinationTypeException(destination);
1: 		}
1: 
0: 		destinations.put(destination, answer);
0: 		return answer;
1: 
1: 	}
1: 
0: 	public void removeDestination(ConnectionContext context,
0: 			ActiveMQDestination destination, long timeout) throws Exception {
1: 
0: 		if (destinations.remove(destination) != null) {
0: 			switch (destination.getDestinationType()) {
0: 			case ActiveMQDestination.QUEUE_TYPE:
0: 				queueRegion.removeDestination(context, destination, timeout);
0: 				break;
0: 			case ActiveMQDestination.TOPIC_TYPE:
0: 				topicRegion.removeDestination(context, destination, timeout);
0: 				break;
0: 			case ActiveMQDestination.TEMP_QUEUE_TYPE:
0: 				tempQueueRegion
0: 						.removeDestination(context, destination, timeout);
0: 				break;
0: 			case ActiveMQDestination.TEMP_TOPIC_TYPE:
0: 				tempTopicRegion
0: 						.removeDestination(context, destination, timeout);
0: 				break;
0: 			default:
0: 				throw createUnknownDestinationTypeException(destination);
1: 			}
1: 		}
1: 
1: 	}
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList l;
1: 
0: 		l = new ArrayList(destinations.values());
1: 
0: 		ActiveMQDestination rc[] = new ActiveMQDestination[l.size()];
1: 		l.toArray(rc);
1: 		return rc;
1: 	}
commit:97a591f
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private Map<String, ConnectionContext> clientIdSet = new HashMap<String, ConnectionContext>(); // we will synchronize access
/////////////////////////////////////////////////////////////////////////
0:         	ConnectionContext oldContext = clientIdSet.get(clientId);
0:             if (oldContext!=null) {
0:             	throw new InvalidClientIDException("Broker: " + getBrokerName() + " - Client: " + clientId + " already connected from "+oldContext.getConnection().getRemoteAddress());
1:                 clientIdSet.put(clientId, context);
/////////////////////////////////////////////////////////////////////////
1:             ConnectionContext oldValue = clientIdSet.get(clientId);
0:             if (oldValue == context ) {
commit:26198c2
/////////////////////////////////////////////////////////////////////////
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CopyOnWriteArraySet;
commit:5b53083
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.HashMap;
0: import java.util.Map;
0: import java.util.Set;
1: 
0: import javax.jms.InvalidClientIDException;
0: import javax.jms.JMSException;
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArraySet;
/////////////////////////////////////////////////////////////////////////
0:     protected final ConcurrentHashMap connectionStates = new ConcurrentHashMap();
/////////////////////////////////////////////////////////////////////////
0: 	public Map getConnectionStates() {
0: 		return connectionStates;
1: 	}
1: 
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:449981b
/////////////////////////////////////////////////////////////////////////
0:     private boolean keepDurableSubsActive=false;
/////////////////////////////////////////////////////////////////////////
0:         ((TopicRegion)topicRegion).setKeepDurableSubsActive(keepDurableSubsActive);
/////////////////////////////////////////////////////////////////////////
1:     public boolean isKeepDurableSubsActive() {
1:         return keepDurableSubsActive;
1:     }
1: 
1:     public void setKeepDurableSubsActive(boolean keepDurableSubsActive) {
1:         this.keepDurableSubsActive = keepDurableSubsActive;
1:     }
1: 
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public void addConnection(ConnectionContext context, ConnectionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Connection[] getClients() throws Exception {
0:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public ActiveMQDestination[] getDestinations() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void addSession(ConnectionContext context, SessionInfo info) throws Exception {
0:     public void removeSession(ConnectionContext context, SessionInfo info) throws Exception {
1:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
1:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Exception {
0:     public void addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Exception {
0:     public void send(ConnectionContext context,  Message message) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void acknowledge(ConnectionContext context, MessageAck ack) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Exception {
1:     public void beginTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:     public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:     public void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Exception {
1:     public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Exception {
1:     public void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Exception {
commit:4f6e901
/////////////////////////////////////////////////////////////////////////
0:         if (message.getTimestamp() > 0 && (message.getBrokerPath() == null || message.getBrokerPath().length == 0)) { 
commit:013f372
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ServiceStopper;
/////////////////////////////////////////////////////////////////////////
1:         queueRegion.start();
1:         topicRegion.start();
1:         tempQueueRegion.start();
1:         tempTopicRegion.start();
1:         ServiceStopper ss = new ServiceStopper();
1:         ss.stop(queueRegion);
1:         ss.stop(topicRegion);
1:         ss.stop(tempQueueRegion);
1:         ss.stop(tempTopicRegion);
1:         ss.throwFirstException();
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArraySet;
1: 
0: import org.apache.activemq.broker.Broker;
0: import org.apache.activemq.broker.Connection;
0: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.BrokerId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.memory.UsageManager;
0: import org.apache.activemq.store.PersistenceAdapter;
0: import org.apache.activemq.store.memory.MemoryPersistenceAdapter;
1: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.util.IdGenerator;
1: import org.apache.activemq.util.LongSequenceGenerator;
1: 
0: import javax.jms.JMSException;
1: 
0: import java.io.IOException;
0: import java.util.ArrayList;
1: 
1: /**
1:  * Routes Broker operations to the correct messaging regions for processing.
0:  * 
0:  * @version $Revision$
1:  */
0: public class RegionBroker implements Broker {
1: 
0:     private static final IdGenerator brokerIdGenerator = new IdGenerator();
1: 
1:     private final Region queueRegion;
1:     private final Region topicRegion;
1:     private final Region tempQueueRegion;
1:     private final Region tempTopicRegion;
1:     
0:     protected final DestinationStatistics destinationStatistics = new DestinationStatistics();
1:     
0:     private final CopyOnWriteArrayList connections = new CopyOnWriteArrayList();
0:     private final CopyOnWriteArraySet destinations = new CopyOnWriteArraySet();
1: 
0:     private final LongSequenceGenerator sequenceGenerator = new LongSequenceGenerator();    
1:     private BrokerId brokerId;
1:     private String brokerName;
1: 
0:     public RegionBroker(TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, PersistenceAdapter adapter) throws IOException {
0:         this(taskRunnerFactory, memoryManager, createDefaultPersistenceAdapter(memoryManager), null);
1:     }
1:     
0:     public RegionBroker(TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, PersistenceAdapter adapter, PolicyMap policyMap) throws IOException {
0:         this.sequenceGenerator.setLastSequenceId( adapter.getLastMessageBrokerSequenceId() );
1:         
0:         queueRegion = createQueueRegion(memoryManager, taskRunnerFactory, adapter, policyMap);
0:         topicRegion = createTopicRegion(memoryManager, taskRunnerFactory, adapter, policyMap);
1:         
0:         tempQueueRegion = createTempQueueRegion(memoryManager, taskRunnerFactory);
0:         tempTopicRegion = createTempTopicRegion(memoryManager, taskRunnerFactory);        
1:     }
1: 
0:     protected Region createTempTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory) {
0:         return new TempTopicRegion(destinationStatistics, memoryManager, taskRunnerFactory);
1:     }
1: 
0:     protected Region createTempQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory) {
0:         return new TempQueueRegion(destinationStatistics, memoryManager, taskRunnerFactory);
1:     }
1: 
0:     protected Region createTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, PersistenceAdapter adapter, PolicyMap policyMap) {
0:         return new TopicRegion(destinationStatistics, memoryManager, taskRunnerFactory, adapter, policyMap);
1:     }
1: 
0:     protected Region createQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, PersistenceAdapter adapter, PolicyMap policyMap) {
0:         return new QueueRegion(destinationStatistics, memoryManager, taskRunnerFactory, adapter, policyMap);
1:     }
1:     
0:     private static PersistenceAdapter createDefaultPersistenceAdapter(UsageManager memoryManager) throws IOException {
0:         return new MemoryPersistenceAdapter();
1:     }
1:     
1:     
1:     public void start() throws Exception {
1:     }
1: 
1:     public void stop() throws Exception {
1:     }
1: 
0:     public void addConnection(ConnectionContext context, ConnectionInfo info) throws Throwable {
1:         connections.add(context.getConnection());
1:     }
1: 
0:     public void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Throwable {
1:         connections.remove(context.getConnection());
1:     }
1: 
0:     public Connection[] getClients() throws Throwable {
0:         ArrayList l = new ArrayList(connections);
1:         Connection rc[] = new Connection[l.size()];
0:         l.toArray(rc);
0:         return rc;
1:     }
1: 
0:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination) throws Throwable {
0:         if( destinations.contains(destination) )
0:             throw new JMSException("Destination already exists: "+destination);
1:         
0:         Destination answer = null;
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             answer  = queueRegion.addDestination(context, destination);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             answer = topicRegion.addDestination(context, destination);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             answer = tempQueueRegion.addDestination(context, destination);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             answer = tempTopicRegion.addDestination(context, destination);
0:             break;
0:         default:
0:             throwUnknownDestinationType(destination);
1:         }
1: 
0:         destinations.add(destination);
0:         return answer;
1:     }
1: 
0:     public void removeDestination(ConnectionContext context, ActiveMQDestination destination, long timeout) throws Throwable {
0:         if( !destinations.contains(destination) )
0:             throw new JMSException("Destination does not exist: "+destination);
1:         
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             queueRegion.removeDestination(context, destination, timeout);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             topicRegion.removeDestination(context, destination, timeout);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             tempQueueRegion.removeDestination(context, destination, timeout);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             tempTopicRegion.removeDestination(context, destination, timeout);
0:             break;
0:         default:
0:             throwUnknownDestinationType(destination);
1:         }
1:         
0:         destinations.remove(destination);
1:     }
1: 
0:     public ActiveMQDestination[] getDestinations() throws Throwable {
0:         ArrayList l = new ArrayList(destinations);
0:         ActiveMQDestination rc[] = new ActiveMQDestination[l.size()];
0:         l.toArray(rc);
0:         return rc;
1:     }
1: 
1: 
0:     public void addSession(ConnectionContext context, SessionInfo info) throws Throwable {
1:     }
1: 
0:     public void removeSession(ConnectionContext context, SessionInfo info) throws Throwable {
1:     }
1: 
0:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Throwable {
1:     }
1: 
0:     public void removeProducer(ConnectionContext context, ProducerInfo info) throws Throwable {
1:     }
1: 
0:     public void addConsumer(ConnectionContext context, ConsumerInfo info) throws Throwable {
1:         ActiveMQDestination destination = info.getDestination();
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             queueRegion.addConsumer(context, info);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             topicRegion.addConsumer(context, info);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             tempQueueRegion.addConsumer(context, info);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             tempTopicRegion.addConsumer(context, info);
0:             break;
0:         default:
0:             throwUnknownDestinationType(destination);
1:         }
1:     }
1: 
0:     public void removeConsumer(ConnectionContext context, ConsumerInfo info) throws Throwable {
1:         ActiveMQDestination destination = info.getDestination();
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             queueRegion.removeConsumer(context, info);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             topicRegion.removeConsumer(context, info);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             tempQueueRegion.removeConsumer(context, info);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             tempTopicRegion.removeConsumer(context, info);
0:             break;
0:         default:
0:             throwUnknownDestinationType(destination);
1:         }
1:     }
1: 
0:     public void removeSubscription(ConnectionContext context, RemoveSubscriptionInfo info) throws Throwable {
1:         topicRegion.removeSubscription(context, info);
1:     }
1: 
0:     public void send(ConnectionContext context,  Message message) throws Throwable {
1:         
0:         message.getMessageId().setBrokerSequenceId(sequenceGenerator.getNextSequenceId());
0:         ActiveMQDestination destination = message.getDestination();
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             queueRegion.send(context, message);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             topicRegion.send(context, message);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             tempQueueRegion.send(context, message);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             tempTopicRegion.send(context, message);
0:             break;
0:         default:
0:             throwUnknownDestinationType(destination);
1:         }
1:     }
1: 
0:     public void acknowledge(ConnectionContext context, MessageAck ack) throws Throwable {
0:         ActiveMQDestination destination = ack.getDestination();
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             queueRegion.acknowledge(context, ack);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             topicRegion.acknowledge(context, ack);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             tempQueueRegion.acknowledge(context, ack);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             tempTopicRegion.acknowledge(context, ack);
0:             break;
0:         default:
0:             throwUnknownDestinationType(destination);
1:         }
1:     }
1: 
0:     public TransactionId[] getPreparedTransactions(ConnectionContext context) throws Throwable {
1:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:     }
1: 
0:     public void beginTransaction(ConnectionContext context, TransactionId xid) throws Throwable {
1:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:     }
1: 
0:     public int prepareTransaction(ConnectionContext context, TransactionId xid) throws Throwable {
1:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:     }
1: 
0:     public void rollbackTransaction(ConnectionContext context, TransactionId xid) throws Throwable {
1:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:     }
1: 
0:     public void commitTransaction(ConnectionContext context, TransactionId xid, boolean onePhase) throws Throwable {
1:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:     }
1:     
0:     public void forgetTransaction(ConnectionContext context, TransactionId transactionId) throws Throwable {
1:         throw new IllegalAccessException("Transaction operation not implemented by this broker.");
1:     }
1: 
1: 
1:     public void gc() {
1:         queueRegion.gc();
1:         topicRegion.gc();
1:     }
1: 
1:     public BrokerId getBrokerId() {
0:         if( brokerId==null ) {
0:             // TODO: this should persist the broker id so that subsequent startup
0:             // uses the same broker id.
0:             brokerId=new BrokerId(brokerIdGenerator.generateId());
1:         }
1:         return brokerId;
1:     }
1:     
1:     public void setBrokerId(BrokerId brokerId) {
1:         this.brokerId = brokerId;
1:     }
1: 
1:     public String getBrokerName() {
0:         if( brokerName==null ) {
0:             try {
0:                 brokerName = java.net.InetAddress.getLocalHost().getHostName().toLowerCase();
0:             } catch (Exception e) {
0:                 brokerName="localhost";
1:             }
1:         }
1:         return brokerName;
1:     }
1:     
1:     public void setBrokerName(String brokerName) {
1:         this.brokerName = brokerName;
1:     }
1: 	
1:     public DestinationStatistics getDestinationStatistics() {
1:         return destinationStatistics;
1:     }
1: 
0:     protected void throwUnknownDestinationType(ActiveMQDestination destination) throws JMSException {
0:         throw new JMSException("Unknown destination type: " + destination.getDestinationType());
1:     }
1: 
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:4b44d31
/////////////////////////////////////////////////////////////////////////
0: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:                 brokerName = InetAddressUtil.getLocalHostName().toLowerCase(Locale.ENGLISH);
author:Bruce Snyder
-------------------------------------------------------------------------------
commit:8a1f994
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.InetAddressUtil;
/////////////////////////////////////////////////////////////////////////
0:                 brokerName = InetAddressUtil.getLocalHostName().toLowerCase();
author:Robert Davies
-------------------------------------------------------------------------------
commit:2705e36
/////////////////////////////////////////////////////////////////////////
0:     
1:     private final Runnable purgeInactiveDestinationsTask = new Runnable() {
1:         public void run() {
0:             purgeInactiveDestinations();
1:         }
1:     };
/////////////////////////////////////////////////////////////////////////
1:         int period = this.brokerService.getSchedulePeriodForDestinationPurge();
1:         if (period > 0) {
1:             this.scheduler.executePeriodically(purgeInactiveDestinationsTask, period);
1:         }
1:         this.scheduler.cancel(purgeInactiveDestinationsTask);
/////////////////////////////////////////////////////////////////////////
0:     public void addProducer(ConnectionContext context, ProducerInfo info) throws Exception {
0:         synchronized (purgeInactiveDestinationsTask) {
0:             if (destination != null) {
0:                 // This seems to cause the destination to be added but without
0:                 // advisories firing...
0:                 context.getBroker().addDestination(context, destination, false);
0:                 switch (destination.getDestinationType()) {
0:                 case ActiveMQDestination.QUEUE_TYPE:
0:                     queueRegion.addProducer(context, info);
0:                     break;
0:                 case ActiveMQDestination.TOPIC_TYPE:
0:                     topicRegion.addProducer(context, info);
0:                     break;
0:                 case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                     tempQueueRegion.addProducer(context, info);
0:                     break;
0:                 case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                     tempTopicRegion.addProducer(context, info);
0:                     break;
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         synchronized (purgeInactiveDestinationsTask) {
0:             if (destination != null) {
0:                 switch (destination.getDestinationType()) {
0:                 case ActiveMQDestination.QUEUE_TYPE:
0:                     queueRegion.removeProducer(context, info);
0:                     break;
0:                 case ActiveMQDestination.TOPIC_TYPE:
0:                     topicRegion.removeProducer(context, info);
0:                     break;
0:                 case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                     tempQueueRegion.removeProducer(context, info);
0:                     break;
0:                 case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                     tempTopicRegion.removeProducer(context, info);
0:                     break;
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         synchronized (purgeInactiveDestinationsTask) {
0:             switch (destination.getDestinationType()) {
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 return queueRegion.addConsumer(context, info);
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 return topicRegion.addConsumer(context, info);
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 return tempQueueRegion.addConsumer(context, info);
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 return tempTopicRegion.addConsumer(context, info);
0:             default:
0:                 throw createUnknownDestinationTypeException(destination);
1:             }
0:         synchronized (purgeInactiveDestinationsTask) {
0:             switch (destination.getDestinationType()) {
0: 
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 queueRegion.removeConsumer(context, info);
0:                 break;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 topicRegion.removeConsumer(context, info);
0:                 break;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 tempQueueRegion.removeConsumer(context, info);
0:                 break;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 tempTopicRegion.removeConsumer(context, info);
0:                 break;
0:             default:
0:                 throw createUnknownDestinationTypeException(destination);
1:             }
0:         synchronized (purgeInactiveDestinationsTask) {
0:             topicRegion.removeSubscription(context, info);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected void purgeInactiveDestinations() {
0:         synchronized (purgeInactiveDestinationsTask) {
0:             List<BaseDestination> list = new ArrayList<BaseDestination>();
1:             Map<ActiveMQDestination, Destination> map = getDestinationMap();
1:             long timeStamp = System.currentTimeMillis();
1:             for (Destination d : map.values()) {
0:                 if (d instanceof BaseDestination) {
0:                     BaseDestination bd = (BaseDestination) d;
0:                     bd.markForGC(timeStamp);
0:                     if (bd.canGC()) {
0:                         list.add(bd);
1:                     }
1:                 }
1:             }
0: 
0:             if (list.isEmpty() == false) {
0: 
0:                 ConnectionContext context = new ConnectionContext();
1:                 context.setBroker(this);
0: 
0:                 for (BaseDestination dest : list) {
0:                     dest.getLog().info(
0:                             dest.getName() + " Inactive for longer than " + dest.getInactiveTimoutBeforeGC()
0:                                     + " ms - removing ...");
0:                     try {
0:                         getRoot().removeDestination(context, dest.getActiveMQDestination(), 0);
0:                     } catch (Exception e) {
0:                         LOG.error("Failed to remove inactive destination " + dest, e);
1:                     }
1:                 }
1:             }
1:         }
1:     }
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ThreadPoolExecutor;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
1:     private final Scheduler scheduler;
1:     private final ThreadPoolExecutor executor;
0:                         DestinationInterceptor destinationInterceptor,Scheduler scheduler,ThreadPoolExecutor executor) throws IOException {
0:         this.executor=executor;
1:         this.scheduler = scheduler;
/////////////////////////////////////////////////////////////////////////
0:     
1:     @Override
1:     public Scheduler getScheduler() {
1:         return this.scheduler;
1:     }
0:     
1:     public ThreadPoolExecutor getExecutor() {
1:         return this.executor;
1:     }
0:     
commit:be55d0a
/////////////////////////////////////////////////////////////////////////
0:         addBrokerInClusterUpdate();
0:             removeBrokerInClusterUpdate();
/////////////////////////////////////////////////////////////////////////
0:     protected void addBrokerInClusterUpdate() {
1:             if (connector.isUpdateClusterClients()) {
1:                 connector.updateClientClusterInfo();
1:             }
1:         }
1:     }
0: 
0:     protected void removeBrokerInClusterUpdate() {
1:         List<TransportConnector> connectors = this.brokerService.getTransportConnectors();
1:         for (TransportConnector connector : connectors) {
1:             if (connector.isUpdateClusterClients() && connector.isUpdateClusterClientsOnRemove()) {
1:                 connector.updateClientClusterInfo();
1:             }
commit:f392884
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.TransportConnector;
/////////////////////////////////////////////////////////////////////////
0:         updateClients();
0:             updateClients();
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected void updateClients() {
1:         List<TransportConnector> connectors = this.brokerService.getTransportConnectors();
1:         for (TransportConnector connector : connectors) {
0:             connector.updateClientClusterInfo();
1:         }
1:     }
commit:204f91f
/////////////////////////////////////////////////////////////////////////
0:     public Destination addDestination(ConnectionContext context, ActiveMQDestination destination,boolean create) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             answer = queueRegion.addDestination(context, destination,true);
0:             answer = topicRegion.addDestination(context, destination,true);
0:             answer = tempQueueRegion.addDestination(context, destination,create);
0:             answer = tempTopicRegion.addDestination(context, destination,create);
/////////////////////////////////////////////////////////////////////////
0:         addDestination(context, info.getDestination(),true);
/////////////////////////////////////////////////////////////////////////
0:             context.getBroker().addDestination(context, destination,false);
/////////////////////////////////////////////////////////////////////////
0:             producerExchange.getConnectionContext().getBroker().addDestination(producerExchange.getConnectionContext(), destination,false);
commit:ee55abb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.plist.PListStore;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public PListStore getTempDataStore() {
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
commit:4ee029e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.EmptyBroker;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class RegionBroker extends EmptyBroker {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.usage.Usage;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void fastProducer(ConnectionContext context,ProducerInfo producerInfo) {
0:     }
0: 
0:     public void isFull(ConnectionContext context,Destination destination, Usage usage) {
0:     }
0: 
0:     public void messageConsumed(ConnectionContext context,MessageReference messageReference) {
0:     }
0: 
0:     public void messageDelivered(ConnectionContext context,MessageReference messageReference) {
0:     }
0: 
0:     public void messageDiscarded(ConnectionContext context,MessageReference messageReference) {
0:     }
0: 
0:     public void slowConsumer(ConnectionContext context, Destination dest, Subscription subs) {
0:     }
commit:dfcf776
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * @return the broker sequence id
1:      */
1:     public long getBrokerSequenceId() {
0:         synchronized(sequenceGenerator) {
1:             return sequenceGenerator.getNextSequenceId();
0:         }
0:     }
commit:b2fd5d6
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ActiveMQDestination> l;
1:         l = new ArrayList<ActiveMQDestination>(getDestinationMap().keySet());
commit:3b0afd6
/////////////////////////////////////////////////////////////////////////
0:             	if (context.isFaultTolerant() || context.isNetworkConnection()){
0:             		//remove the old connection
0:             		try{
0:             			removeConnection(oldContext, info, new Exception("remove stale client"));
0:             		}catch(Exception e){
0:             			LOG.warn("Failed to remove stale connection ",e);
0:             		}
0:             	}else{
0:             	}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:23cda2d
/////////////////////////////////////////////////////////////////////////
0: 					}else {
0: 					  //don't want to warn about failing to send 
0: 					  // if there isn't a dead letter strategy 
0: 					   sent=true;
0: 				LOG.warn("Failed to send "+node+" to DLQ");
0: 			LOG.warn("Caught an exception sending to DLQ: "+node,e);
commit:83c3dca
/////////////////////////////////////////////////////////////////////////
commit:8d11f07
/////////////////////////////////////////////////////////////////////////
0:             addDestination(context, destination);
commit:634da7a
/////////////////////////////////////////////////////////////////////////
0:     public void addProducer(ConnectionContext context, ProducerInfo info)
0:             throws Exception {
1:         ActiveMQDestination destination = info.getDestination();
0:         if (destination != null) {
0:             switch (destination.getDestinationType()) {
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 queueRegion.addProducer(context, info);
0:                 break;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 topicRegion.addProducer(context, info);
0:                 break;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 tempQueueRegion.addProducer(context, info);
0:                 break;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 tempTopicRegion.addProducer(context, info);
0:                 break;
0:             }
0:         }
1:         ActiveMQDestination destination = info.getDestination();
0:         if (destination != null) {
0:             switch (destination.getDestinationType()) {
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 queueRegion.removeProducer(context, info);
0:                 break;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 topicRegion.removeProducer(context, info);
0:                 break;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 tempQueueRegion.removeProducer(context, info);
0:                 break;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 tempTopicRegion.removeProducer(context, info);
0:                 break;
0:             }
0:         }
commit:5f4db41
/////////////////////////////////////////////////////////////////////////
0:     public Set <Destination> getDestinations(ActiveMQDestination destination) {
commit:1195ae7
/////////////////////////////////////////////////////////////////////////
0: 							if (context.getBroker()==null) {
0: 								context.setBroker(getRoot());
0: 							}
commit:3cd1e6c
/////////////////////////////////////////////////////////////////////////
0:     public void sendToDeadLetterQueue(ConnectionContext context,
0: 	        MessageReference node){
0: 		try{
0: 			boolean sent=false;
0: 			if(node!=null){
0: 				Message message=node.getMessage();
0: 				if(message!=null&&node.getRegionDestination()!=null){
0: 					DeadLetterStrategy deadLetterStrategy=node
0: 					        .getRegionDestination().getDeadLetterStrategy();
0: 					if(deadLetterStrategy!=null){
0: 						if(deadLetterStrategy.isSendToDeadLetterQueue(message)){
0: 							long expiration=message.getExpiration();
0: 							message.setExpiration(0);
0: 							message.setProperty("originalExpiration",new Long(
0: 							        expiration));
0: 							if(!message.isPersistent()){
0: 								message.setPersistent(true);
0: 								message.setProperty("originalDeliveryMode",
0: 								        "NON_PERSISTENT");
0: 							}
0: 							// The original destination and transaction id do
0: 							// not get filled when the message is first
0: 							// sent,
0: 							// it is only populated if the message is routed to
0: 							// another destination like the DLQ
0: 							ActiveMQDestination deadLetterDestination=deadLetterStrategy
0: 							        .getDeadLetterQueueFor(message
0: 							                .getDestination());
0: 							BrokerSupport.resend(context,message,
0: 							        deadLetterDestination);
0: 							sent=true;
0: 						}
0: 					}
0: 				}
0: 			}
0: 			if(sent==false){
0: 				LOG.warn("Failed to send "+node+" to dead letter queue");
0: 			}
0: 		}catch(Exception e){
0: 			LOG.warn("Failed to pass expired message to dead letter queue",e);
0: 		}
0: 	}
commit:6d8e2c5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
1:     public RegionBroker(BrokerService brokerService, TaskRunnerFactory taskRunnerFactory, SystemUsage memoryManager, DestinationFactory destinationFactory,
/////////////////////////////////////////////////////////////////////////
1:     protected Region createTempTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:     protected Region createTempQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:     protected Region createTopicRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
1:     protected Region createQueueRegion(SystemUsage memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
commit:c07b233
/////////////////////////////////////////////////////////////////////////
0:     public void preProcessDispatch(MessageDispatch messageDispatch){
0:         Message message=messageDispatch.getMessage();
0:         if(message!=null){
0:             long endTime=System.currentTimeMillis();
1:             message.setBrokerOutTime(endTime);
0:             if(getBrokerService().isEnableStatistics()){
1:                 long totalTime = endTime - message.getBrokerInTime();
0:                 message.getRegionDestination().getDestinationStatistics().getProcessTime().addTime(totalTime);
0:             }
commit:a401575
/////////////////////////////////////////////////////////////////////////
1:         message.setBrokerInTime(System.currentTimeMillis());
/////////////////////////////////////////////////////////////////////////
0:     public void preProcessDispatch(MessageDispatch messageDispatch){ 
0:         Message message = messageDispatch.getMessage();
0:         if(message != null) {
0:             message.setBrokerOutTime(System.currentTimeMillis());
0:         }
0:     }
0:     
0:     public void postProcessDispatch(MessageDispatch messageDispatch){   
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isExpired(MessageReference messageReference) {
0:         return messageReference.isExpired();
0:     }
commit:a414c20
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.BrokerSupport;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void messageExpired(ConnectionContext context,MessageReference node){
0:         if(log.isDebugEnabled()){
0:             log.debug("Message expired "+node);
0:         }
0:         getRoot().sendToDeadLetterQueue(context,node);
0:     }
0: 
0:     public void sendToDeadLetterQueue(ConnectionContext context,MessageReference node){
0:         try{
0:             if(node!=null){
0:                 Message message=node.getMessage();
0:                 if(message!=null){
0:                     DeadLetterStrategy deadLetterStrategy=node.getRegionDestination().getDeadLetterStrategy();
0:                     if(deadLetterStrategy!=null){
0:                         if(deadLetterStrategy.isSendToDeadLetterQueue(message)){
0:                             long expiration=message.getExpiration();
0:                             message.setExpiration(0);
0:                             message.setProperty("originalExpiration",new Long(expiration));
0:                             if(!message.isPersistent()){
0:                                 message.setPersistent(true);
0:                                 message.setProperty("originalDeliveryMode","NON_PERSISTENT");
0:                             }
0:                             // The original destination and transaction id do not get filled when the message is first
0:                             // sent,
0:                             // it is only populated if the message is routed to another destination like the DLQ
0:                             ActiveMQDestination deadLetterDestination=deadLetterStrategy.getDeadLetterQueueFor(message
0:                                     .getDestination());
0:                             BrokerSupport.resend(context,message,deadLetterDestination);
0:                         }
0:                     }
0:                 }else{
0:                     log.warn("Null message for node: "+node);
0:                 }
0:             }
0:         }catch(Exception e){
0:             log.warn("Failed to pass expired message to dead letter queue");
0:         }
0:     }
0: 
0:     public Broker getRoot(){
0:         try{
1:             return getBrokerService().getBroker();
0:         }catch(Exception e){
0:             log.fatal("Trying to get Root Broker "+e);
1:             throw new RuntimeException("The broker from the BrokerService should not throw an exception");
0:         }
0:     }
commit:25a252f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.TransactionBroker;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log log = LogFactory.getLog(RegionBroker.class);
/////////////////////////////////////////////////////////////////////////
0:    
/////////////////////////////////////////////////////////////////////////
0:     public void send(ProducerBrokerExchange producerExchange,Message message) throws Exception{
0:         long si=sequenceGenerator.getNextSequenceId();
0:         if(producerExchange.isMutable()||producerExchange.getRegion()==null){
0:             ActiveMQDestination destination=message.getDestination();
1:             // ensure the destination is registered with the RegionBroker
0:             Region region=null;
0:             switch(destination.getDestinationType()){
0:                 region=queueRegion;
0:                 region=topicRegion;
0:                 region=tempQueueRegion;
0:                 region=tempTopicRegion;
/////////////////////////////////////////////////////////////////////////
0: 
0:     public void brokerServiceStarted(){
0:     }
0: 
0:     public BrokerService getBrokerService(){
1:         return brokerService;
0:     }
0:     
0:     
commit:4741136
/////////////////////////////////////////////////////////////////////////
0: import java.net.URI;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public URI getVmConnectorURI(){
1:         return brokerService.getVmConnectorURI();
0:     }
commit:985b4ce
/////////////////////////////////////////////////////////////////////////
0:             //ensure the destination is registered with the RegionBroker
0:             addDestination(producerExchange.getConnectionContext(),destination);
commit:2eaafc0
/////////////////////////////////////////////////////////////////////////
0:         if(consumerExchange.isWildcard() || consumerExchange.getRegion()==null){
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.ConsumerBrokerExchange;
0: import org.apache.activemq.broker.ProducerBrokerExchange;
/////////////////////////////////////////////////////////////////////////
0:     public void send(ProducerBrokerExchange producerExchange,  Message message) throws Exception {
0:         if (producerExchange.isMutable() || producerExchange.getRegion()==null) {
0:             ActiveMQDestination destination = message.getDestination();
0:             Region region = null;
0:             switch(destination.getDestinationType()) {
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 region = queueRegion;
0:                 break;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 region = topicRegion;
0:                 break;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 region = tempQueueRegion;
0:                 break;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 region = tempTopicRegion;
0:                 break;
0:             default:
0:                 throw createUnknownDestinationTypeException(destination);
0:             }
0:             producerExchange.setRegion(region);
0:         producerExchange.getRegion().send(producerExchange,message);
0:     public void acknowledge(ConsumerBrokerExchange consumerExchange,MessageAck ack) throws Exception{
0:         if(consumerExchange.getRegion()==null){
0:             ActiveMQDestination destination=ack.getDestination();
0:             Region region=null;
0:             switch(destination.getDestinationType()){
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 region=queueRegion;
0:                 break;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 region=topicRegion;
0:                 break;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 region=tempQueueRegion;
0:                 break;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 region=tempTopicRegion;
0:                 break;
0:             default:
0:                 throw createUnknownDestinationTypeException(destination);
0:             }
0:             consumerExchange.setRegion(region);
0:         consumerExchange.getRegion().acknowledge(consumerExchange,ack);
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
commit:d2e6062
/////////////////////////////////////////////////////////////////////////
0:     private boolean started = false;
/////////////////////////////////////////////////////////////////////////
1:         started = true;
/////////////////////////////////////////////////////////////////////////
1:         started = false;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         long si = sequenceGenerator.getNextSequenceId();
0:         message.getMessageId().setBrokerSequenceId(si);
/////////////////////////////////////////////////////////////////////////
1:         return !started;
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PendingDurableSubscriberMessageStoragePolicy;
0: import org.apache.activemq.broker.region.policy.VMPendingDurableSubscriberMessageStoragePolicy;
/////////////////////////////////////////////////////////////////////////
0:     private PendingDurableSubscriberMessageStoragePolicy pendingDurableSubscriberPolicy = new VMPendingDurableSubscriberMessageStoragePolicy();
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
0:      * @return the pendingDurableSubscriberPolicy
0:      */
0:     public PendingDurableSubscriberMessageStoragePolicy getPendingDurableSubscriberPolicy(){
0:         return this.pendingDurableSubscriberPolicy;
0:     }
0:   
0:     /**
0:      * @param pendingDurableSubscriberPolicy the pendingDurableSubscriberPolicy to set
0:      */
0:     public void setPendingDurableSubscriberPolicy(PendingDurableSubscriberMessageStoragePolicy durableSubscriberCursor){
0:         this.pendingDurableSubscriberPolicy=durableSubscriberCursor;
0:     }
commit:7d1e6bc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.kaha.Store;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Store getTempDataStore() {
1:         return brokerService.getTempDataStore();
0:     }
commit:bfaff9b
/////////////////////////////////////////////////////////////////////////
0:     protected DestinationFactory destinationFactory;
0:     public RegionBroker(BrokerService brokerService,TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, DestinationFactory destinationFactory, DestinationInterceptor destinationInterceptor) throws IOException {
1:         if (destinationFactory == null) {
1:             throw new IllegalArgumentException("null destinationFactory");
0:         }
0:         this.sequenceGenerator.setLastSequenceId( destinationFactory.getLastMessageBrokerSequenceId() );
1:         this.destinationFactory = destinationFactory;
1:         queueRegion = createQueueRegion(memoryManager, taskRunnerFactory, destinationFactory);
1:         topicRegion = createTopicRegion(memoryManager, taskRunnerFactory, destinationFactory);
1:         tempQueueRegion = createTempQueueRegion(memoryManager, taskRunnerFactory, destinationFactory);
0:         tempTopicRegion = createTempTopicRegion(memoryManager, taskRunnerFactory, destinationFactory);        
/////////////////////////////////////////////////////////////////////////
0:     protected Region createTempTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
0:         return new TempTopicRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
0:     protected Region createTempQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
0:         return new TempQueueRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
0:     protected Region createTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
0:         return new TopicRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
0:     protected Region createQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, DestinationFactory destinationFactory) {
0:         return new QueueRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, destinationFactory);
/////////////////////////////////////////////////////////////////////////
1:         return destinationFactory.getDestinations();
commit:ef0734b
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean isFaultTolerantConfiguration(){
0:         return false;
0:     }
/////////////////////////////////////////////////////////////////////////
0:     
0: 
commit:daddd41
/////////////////////////////////////////////////////////////////////////
0:     public void removeDestination(ConnectionContext context,ActiveMQDestination destination,long timeout)
0:                     throws Exception{
0:         if(destinations.contains(destination)){
0:             switch(destination.getDestinationType()){
0:             case ActiveMQDestination.QUEUE_TYPE:
0:                 queueRegion.removeDestination(context,destination,timeout);
0:                 break;
0:             case ActiveMQDestination.TOPIC_TYPE:
0:                 topicRegion.removeDestination(context,destination,timeout);
0:                 break;
0:             case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:                 tempQueueRegion.removeDestination(context,destination,timeout);
0:                 break;
0:             case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:                 tempTopicRegion.removeDestination(context,destination,timeout);
0:                 break;
0:             default:
0:                 throw createUnknownDestinationTypeException(destination);
0:             }
0:             destinations.remove(destination);
commit:9cd60d8
/////////////////////////////////////////////////////////////////////////
commit:a9c49a7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.DestinationInfo;
/////////////////////////////////////////////////////////////////////////
0:         if( destinations.contains(destination) ){
0:             System.err.println(brokerService.getBrokerName() + " SPLATYTTTT!!!!");
0:         }
/////////////////////////////////////////////////////////////////////////
0:     
0:     public void addDestinationInfo(ConnectionContext context,DestinationInfo info) throws Exception{
0:         addDestination(context,info.getDestination());
0:         
0:     }
0: 
0:     public void removeDestinationInfo(ConnectionContext context,DestinationInfo info) throws Exception{
0:         removeDestination(context,info.getDestination(), info.getTimeout());
0:         
0:     }
commit:6cb66e4
/////////////////////////////////////////////////////////////////////////
0:         
0:         queueRegion = createQueueRegion(memoryManager, taskRunnerFactory, adapter);
0:         topicRegion = createTopicRegion(memoryManager, taskRunnerFactory, adapter);
/////////////////////////////////////////////////////////////////////////
0:     protected Region createTopicRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, PersistenceAdapter adapter) {
0:         return new TopicRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, adapter);
0:     protected Region createQueueRegion(UsageManager memoryManager, TaskRunnerFactory taskRunnerFactory, PersistenceAdapter adapter) {
0:         return new QueueRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, adapter);
/////////////////////////////////////////////////////////////////////////
0:     
0:     public PolicyMap getDestinationPolicy(){
1:         return brokerService != null ? brokerService.getDestinationPolicy() : null;
0:     }
commit:2eae054
/////////////////////////////////////////////////////////////////////////
0:         this.adaptor = adapter;//weird - both are valid spellings ...
commit:c82f6f3
/////////////////////////////////////////////////////////////////////////
0:     protected  PersistenceAdapter adaptor;
commit:f7ed407
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0:         return adaptor != null ? adaptor.getDestinations() : Collections.EMPTY_SET;
commit:debd0cc
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     private PersistenceAdapter adaptor;
/////////////////////////////////////////////////////////////////////////
0:         this.adaptor = adaptor;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Set getDurableDestinations(){
0:         return adaptor.getDestinations();
0:     }
commit:b59d0b5
/////////////////////////////////////////////////////////////////////////
0:         if (message.getTimestamp() > 0 && (message.getBrokerPath() == null | message.getBrokerPath().length == 0)) { 
0:             //timestamp not been disabled and has not passed through a network
0:             message.setTimestamp(System.currentTimeMillis());
0:         }
commit:5a429d9
/////////////////////////////////////////////////////////////////////////
0:                 throw new InvalidClientIDException("Broker: " + getBrokerName() + " - Client: " + clientId + " already connected");
commit:233b604
/////////////////////////////////////////////////////////////////////////
0:     private boolean stopped = false;
/////////////////////////////////////////////////////////////////////////
0:         stopped = true;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public boolean isStopped(){
0:         return stopped;
0:     }
commit:4098942
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageDispatchNotification;
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:     private BrokerService brokerService;
0:     private final CopyOnWriteArrayList brokerInfos = new CopyOnWriteArrayList();
0:     public RegionBroker(BrokerService brokerService,TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, PersistenceAdapter adapter) throws IOException {
0:         this(brokerService,taskRunnerFactory, memoryManager, createDefaultPersistenceAdapter(memoryManager), null);
0:     public RegionBroker(BrokerService brokerService,TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, PersistenceAdapter adapter, PolicyMap policyMap) throws IOException {
1:         this.brokerService = brokerService;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Broker getAdaptor(Class type){
0:         if (type.isInstance(this)){
0:             return this;
0:         }
0:         return null;
0:     }
0:         return new TempTopicRegion(this,destinationStatistics, memoryManager, taskRunnerFactory);
0:         return new TempQueueRegion(this,destinationStatistics, memoryManager, taskRunnerFactory);
0:         return new TopicRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, adapter, policyMap);
0:         return new QueueRegion(this,destinationStatistics, memoryManager, taskRunnerFactory, adapter, policyMap);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void addBroker(Connection connection,BrokerInfo info){
0:             brokerInfos.add(info);
0:     }
0:     
0:     public synchronized void removeBroker(Connection connection,BrokerInfo info){
0:         if (info != null){
0:             brokerInfos.remove(info);
0:         }   
0:     }
0: 
0:     public synchronized BrokerInfo[] getPeerBrokerInfos(){
1:         BrokerInfo[] result = new BrokerInfo[brokerInfos.size()];
0:         result = (BrokerInfo[])brokerInfos.toArray(result);
1:         return result;
0:     }
0:     
0:     public void processDispatch(MessageDispatch messageDispatch){
0:         
0:     }
0:     
0:     public void processDispatchNotification(MessageDispatchNotification messageDispatchNotification) throws Throwable {
1:         ActiveMQDestination destination = messageDispatchNotification.getDestination();
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             queueRegion.processDispatchNotification(messageDispatchNotification);
0:             break;
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             topicRegion.processDispatchNotification(messageDispatchNotification);
0:             break;
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             tempQueueRegion.processDispatchNotification(messageDispatchNotification);
0:             break;
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             tempTopicRegion.processDispatchNotification(messageDispatchNotification);
0:             break;
0:         default:
0:             throwUnknownDestinationType(destination);
0:         }
0:     }
0:     
0:     public boolean isSlaveBroker(){
0:         return brokerService.isSlave();
0:     }
0: 
0:     
0: 
author:David Jencks
-------------------------------------------------------------------------------
commit:fd84b78
/////////////////////////////////////////////////////////////////////////
1:     protected final BrokerService brokerService;
/////////////////////////////////////////////////////////////////////////
1:     private final Map<String, ConnectionContext> clientIdSet = new HashMap<String, ConnectionContext>();
/////////////////////////////////////////////////////////////////////////
1:             return Collections.emptySet();
/////////////////////////////////////////////////////////////////////////
0:             Region region;
/////////////////////////////////////////////////////////////////////////
0:             Region region;
author:James Strachan
-------------------------------------------------------------------------------
commit:3cbee72
/////////////////////////////////////////////////////////////////////////
0: 
0:             // This seems to cause the destination to be added but without advisories firing...
0:             context.getBroker().addDestination(context, destination);
/////////////////////////////////////////////////////////////////////////
0:             producerExchange.getConnectionContext().getBroker().addDestination(producerExchange.getConnectionContext(), destination);
commit:b006e61
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.DestinationAlreadyExistsException;
/////////////////////////////////////////////////////////////////////////
0:             throw new DestinationAlreadyExistsException(destination);
commit:efd5168
/////////////////////////////////////////////////////////////////////////
commit:9d671b7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessagePull;
0: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public Response messagePull(ConnectionContext context, MessagePull pull) throws Exception {
1:         ActiveMQDestination destination = pull.getDestination();
0:         switch (destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             return queueRegion.messagePull(context, pull);
0: 
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             return topicRegion.messagePull(context, pull);
0: 
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             return tempQueueRegion.messagePull(context, pull);
0: 
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             return tempTopicRegion.messagePull(context, pull);
0:         default:
0:             throw createUnknownDestinationTypeException(destination);
0:         }
0:     }
0: 
commit:cb77064
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConnectionId;
/////////////////////////////////////////////////////////////////////////
1:             // so lets check that their connection IDs are the same
0:             if (oldValue != null) {
1:                 if (isEqual(oldValue.getConnectionId(), info.getConnectionId())) {
0:                     clientIdSet.remove(clientId);
0:                 }
1:     protected boolean isEqual(ConnectionId connectionId, ConnectionId connectionId2) {
1:         return connectionId == connectionId2 || (connectionId != null && connectionId.equals(connectionId2));
0:     }
0: 
commit:8abb655
/////////////////////////////////////////////////////////////////////////
1:     private ConnectionContext adminConnectionContext;
/////////////////////////////////////////////////////////////////////////
1:     public ConnectionContext getAdminConnectionContext() {
1:         return adminConnectionContext;
0:     }
0:  
1:     public void setAdminConnectionContext(ConnectionContext adminConnectionContext) {
1:         this.adminConnectionContext = adminConnectionContext;
0:     }
commit:da67a38
/////////////////////////////////////////////////////////////////////////
1:     private final DestinationInterceptor destinationInterceptor;
0:     public RegionBroker(BrokerService brokerService,TaskRunnerFactory taskRunnerFactory, UsageManager memoryManager, PersistenceAdapter adapter, DestinationInterceptor destinationInterceptor) throws IOException {
1:         this.destinationInterceptor = destinationInterceptor;
/////////////////////////////////////////////////////////////////////////
1:     public DestinationInterceptor getDestinationInterceptor() {
1:         return destinationInterceptor;
0:     }
commit:06a5829
/////////////////////////////////////////////////////////////////////////
0:     public Set getDestinations(ActiveMQDestination destination) {
0:         switch(destination.getDestinationType()) {
0:         case ActiveMQDestination.QUEUE_TYPE:
0:             return queueRegion.getDestinations(destination);
0:         case ActiveMQDestination.TOPIC_TYPE:
0:             return topicRegion.getDestinations(destination);
0:         case ActiveMQDestination.TEMP_QUEUE_TYPE:
0:             return tempQueueRegion.getDestinations(destination);
0:         case ActiveMQDestination.TEMP_TOPIC_TYPE:
0:             return tempTopicRegion.getDestinations(destination);
0:         default:
0:             return Collections.EMPTY_SET;
0:         }
0:     }
0: 
commit:d680ba1
/////////////////////////////////////////////////////////////////////////
0:     public Map getDestinationMap() {
0:         Map answer = getQueueRegion().getDestinationMap();
1:         answer.putAll(getTopicRegion().getDestinationMap());
0:         return answer;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public Region getQueueRegion() {
0:         return queueRegion;
0:     }
0: 
1:     public Region getTempQueueRegion() {
0:         return tempQueueRegion;
0:     }
0: 
1:     public Region getTempTopicRegion() {
0:         return tempTopicRegion;
0:     }
0: 
1:     public Region getTopicRegion() {
0:         return topicRegion;
0:     }
0: 
commit:0def1d4
/////////////////////////////////////////////////////////////////////////
0:             throw createUnknownDestinationTypeException(destination);
/////////////////////////////////////////////////////////////////////////
0:             throw createUnknownDestinationTypeException(destination);
/////////////////////////////////////////////////////////////////////////
1:     public Subscription addConsumer(ConnectionContext context, ConsumerInfo info) throws Exception {
0:             return queueRegion.addConsumer(context, info);
0:             
0:             return topicRegion.addConsumer(context, info);
0:         
0:             return tempQueueRegion.addConsumer(context, info);
0:             
0:             return tempTopicRegion.addConsumer(context, info);
0:             
0:             throw createUnknownDestinationTypeException(destination);
/////////////////////////////////////////////////////////////////////////
0:             throw createUnknownDestinationTypeException(destination);
/////////////////////////////////////////////////////////////////////////
0:             throw createUnknownDestinationTypeException(destination);
/////////////////////////////////////////////////////////////////////////
0:             throw createUnknownDestinationTypeException(destination);
/////////////////////////////////////////////////////////////////////////
1:     protected JMSException createUnknownDestinationTypeException(ActiveMQDestination destination) {
1:         return new JMSException("Unknown destination type: " + destination.getDestinationType());
/////////////////////////////////////////////////////////////////////////
0:             throw createUnknownDestinationTypeException(destination);
commit:3cd3fd3
/////////////////////////////////////////////////////////////////////////
1:         doStop(ss);
/////////////////////////////////////////////////////////////////////////
0: 
1:     protected void doStop(ServiceStopper ss) {
0:         ss.stop(queueRegion);
0:         ss.stop(topicRegion);
0:         ss.stop(tempQueueRegion);
0:         ss.stop(tempTopicRegion);
0:     }
0: 
commit:de23149
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidClientIDException;
0: import java.util.*;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     private Map clientIdSet = new HashMap(); // we will synchronize access
/////////////////////////////////////////////////////////////////////////
1:         String clientId = info.getClientId();
1:         if (clientId == null) {
1:             throw new InvalidClientIDException("No clientID specified for connection request");
0:         }
0:         synchronized (clientIdSet ) {
0:             if (clientIdSet.containsKey(clientId)) {
0:                 throw new InvalidClientIDException("Client: " + clientId + " already connected");
0:             }
0:             else {
0:                 clientIdSet.put(clientId, info);
0:             }
0:         }
0: 
1:         String clientId = info.getClientId();
1:         if (clientId == null) {
1:             throw new InvalidClientIDException("No clientID specified for connection disconnect request");
0:         }
1:         synchronized (clientIdSet) {
0:             ConnectionInfo oldValue = (ConnectionInfo) clientIdSet.get(clientId);
0:             // we may be removing the duplicate connection, not the first connection to be created
0:             if (oldValue == info) {
0:                 clientIdSet.remove(clientId);
0:             }
0:         }
0: 
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:bd7d59c
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     private final HashMap destinations = new HashMap();
/////////////////////////////////////////////////////////////////////////
0:   
0:     	Destination answer;
0:     	synchronized(destinations) {
0:     		answer = (Destination) destinations.get(destination);
0:             if( answer!=null )
0:             	return answer;
0:     	}
0:     	
/////////////////////////////////////////////////////////////////////////
0:     	synchronized(destinations) {
0:             destinations.put(destination, answer);
0:             return answer;
0:     	}
0:     public void removeDestination(ConnectionContext context,ActiveMQDestination destination,long timeout) throws Exception{
0:     	synchronized(destinations) {
0: 	        if( destinations.remove(destination)!=null ){
0: 	            switch(destination.getDestinationType()){
0: 	            case ActiveMQDestination.QUEUE_TYPE:
0: 	                queueRegion.removeDestination(context,destination,timeout);
0: 	                break;
0: 	            case ActiveMQDestination.TOPIC_TYPE:
0: 	                topicRegion.removeDestination(context,destination,timeout);
0: 	                break;
0: 	            case ActiveMQDestination.TEMP_QUEUE_TYPE:
0: 	                tempQueueRegion.removeDestination(context,destination,timeout);
0: 	                break;
0: 	            case ActiveMQDestination.TEMP_TOPIC_TYPE:
0: 	                tempTopicRegion.removeDestination(context,destination,timeout);
0: 	                break;
0: 	            default:
0: 	                throw createUnknownDestinationTypeException(destination);
0: 	            }
0: 	        }
0:     	}
/////////////////////////////////////////////////////////////////////////
0:     	ArrayList l;
0:     	synchronized(destinations) {
0: 	        l = new ArrayList(destinations.values());
0:     	}
============================================================================