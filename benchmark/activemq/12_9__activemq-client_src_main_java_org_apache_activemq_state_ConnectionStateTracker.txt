3:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
2:220ad62:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.state;
32:d29ca2a: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.util.Iterator;
1:e225ba6: import java.util.LinkedHashMap;
1:e225ba6: import java.util.Map;
1:8d3ca90: import java.util.Map.Entry;
1:e7703f7: import java.util.Vector;
1:fb3b6db: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:220ad62: 
1:b836af8: import javax.jms.TransactionRolledBackException;
1:4eafccc: import javax.transaction.xa.XAResource;
1:220ad62: 
1:d29ca2a: import org.apache.activemq.command.Command;
1:d29ca2a: import org.apache.activemq.command.ConnectionId;
1:d29ca2a: import org.apache.activemq.command.ConnectionInfo;
1:8d3ca90: import org.apache.activemq.command.ConsumerControl;
1:d29ca2a: import org.apache.activemq.command.ConsumerId;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.DestinationInfo;
1:b836af8: import org.apache.activemq.command.ExceptionResponse;
1:4eafccc: import org.apache.activemq.command.IntegerResponse;
1:d29ca2a: import org.apache.activemq.command.Message;
1:966de0c: import org.apache.activemq.command.MessagePull;
1:d29ca2a: import org.apache.activemq.command.ProducerId;
1:d29ca2a: import org.apache.activemq.command.ProducerInfo;
1:d29ca2a: import org.apache.activemq.command.Response;
1:d29ca2a: import org.apache.activemq.command.SessionId;
1:d29ca2a: import org.apache.activemq.command.SessionInfo;
1:d29ca2a: import org.apache.activemq.command.TransactionInfo;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:f812e34: 
1:d29ca2a: /**
1:f812e34:  * Tracks the state of a connection so a newly established transport can be
1:f812e34:  * re-initialized to the state that was tracked.
1:e7703f7:  *
1:e7703f7:  *
1:d29ca2a:  */
1:fb3b6db: public class ConnectionStateTracker extends CommandVisitorAdapter {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ConnectionStateTracker.class);
1:f812e34: 
1:fc00993:     private static final Tracked TRACKED_RESPONSE_MARKER = new Tracked(null);
1:0817f5d:     private static final int MESSAGE_PULL_SIZE = 400;
1:90b808a:     protected final ConcurrentMap<ConnectionId, ConnectionState> connectionStates = new ConcurrentHashMap<>();
1:f812e34: 
1:ecf89a6:     private boolean trackTransactions;
1:f812e34:     private boolean restoreSessions = true;
1:f812e34:     private boolean restoreConsumers = true;
1:f812e34:     private boolean restoreProducers = true;
1:f812e34:     private boolean restoreTransaction = true;
1:e225ba6:     private boolean trackMessages = true;
1:b9e51d6:     private boolean trackTransactionProducers = true;
1:e225ba6:     private int maxCacheSize = 128 * 1024;
1:e7703f7:     private long currentCacheSize;  // use long to prevent overflow for folks who set high max.
1:e7703f7: 
1:e7703f7:     private final Map<Object,Command> messageCache = new LinkedHashMap<Object,Command>(){
1:e7703f7:         @Override
1:966de0c:         protected boolean removeEldestEntry(Map.Entry<Object,Command> eldest) {
1:e225ba6:             boolean result = currentCacheSize > maxCacheSize;
1:c42c5ff:             if (result) {
1:966de0c:                 if (eldest.getValue() instanceof Message) {
1:966de0c:                     currentCacheSize -= ((Message)eldest.getValue()).getSize();
1:e8d45cb:                 } else if (eldest.getValue() instanceof MessagePull) {
1:0817f5d:                     currentCacheSize -= MESSAGE_PULL_SIZE;
1:966de0c:                 }
1:5cf33b5:                 if (LOG.isTraceEnabled()) {
1:5cf33b5:                     LOG.trace("removing tracked message: " + eldest.getKey());
1:5cf33b5:                 }
1:b9e51d6:             }
1:e225ba6:             return result;
1:b9e51d6:         }
1:e225ba6:     };
1:e7703f7: 
1:4eafccc:     private class RemoveTransactionAction implements ResponseHandler {
1:f812e34:         private final TransactionInfo info;
1:e7703f7: 
1:f812e34:         public RemoveTransactionAction(TransactionInfo info) {
1:8641928:             this.info = info;
1:f812e34:         }
1:f812e34: 
1:e7703f7:         @Override
1:4eafccc:         public void onResponse(Command response) {
1:f812e34:             ConnectionId connectionId = info.getConnectionId();
1:ecf89a6:             ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:             if (cs != null) {
1:f812e34:                 cs.removeTransactionState(info.getTransactionId());
1:f812e34:             }
1:220ad62:         }
1:220ad62:     }
1:f812e34: 
1:8641928:     private final class ExceptionResponseCheckAction implements ResponseHandler {
1:90b808a:         private final Command tracked;
1:8641928: 
1:90b808a:         public ExceptionResponseCheckAction(Command tracked) {
1:90b808a:             this.tracked = tracked;
1:8641928:         }
1:8641928: 
1:e7703f7:         @Override
1:8641928:         public void onResponse(Command response) {
1:8641928:             if (ExceptionResponse.DATA_STRUCTURE_TYPE == response.getDataStructureType()) {
1:90b808a:                 if (tracked.getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE) {
1:90b808a:                     processRemoveConsumer(((ConsumerInfo) tracked).getConsumerId(), 0l);
1:90b808a:                 } else if (tracked.getDataStructureType() == ProducerInfo.DATA_STRUCTURE_TYPE) {
1:90b808a:                     processRemoveProducer(((ProducerInfo) tracked).getProducerId());
1:90b808a:                 }
1:8641928:             }
1:8641928:         }
1:8641928:     }
1:8641928: 
1:e7703f7:     private class PrepareReadonlyTransactionAction extends RemoveTransactionAction {
1:4eafccc:         public PrepareReadonlyTransactionAction(TransactionInfo info) {
1:4eafccc:             super(info);
1:220ad62:         }
1:f812e34: 
1:e7703f7:         @Override
1:4eafccc:         public void onResponse(Command command) {
1:f69cbd8:             if (command instanceof IntegerResponse) {
1:f69cbd8:                 IntegerResponse response = (IntegerResponse) command;
1:f69cbd8:                 if (XAResource.XA_RDONLY == response.getResult()) {
1:f69cbd8:                     // all done, no commit or rollback from TM
1:f69cbd8:                     super.onResponse(command);
1:f69cbd8:                 }
1:229c634:             }
1:4eafccc:         }
1:4eafccc:     }
1:f812e34: 
1:220ad62:     /**
1:e7703f7:      * Entry point for all tracked commands in the tracker.  Commands should be tracked before
1:e7703f7:      * there is an attempt to send them on the wire.  Upon a successful send of a command it is
1:e7703f7:      * necessary to call the trackBack method to complete the tracking of the given command.
1:e7703f7:      *
1:220ad62:      * @param command
1:e7703f7:      *      The command that is to be tracked by this tracker.
1:e7703f7:      *
1:220ad62:      * @return null if the command is not state tracked.
1:e7703f7:      *
1:e7703f7:      * @throws IOException if an error occurs during setup of the tracking operation.
1:220ad62:      */
1:220ad62:     public Tracked track(Command command) throws IOException {
1:d29ca2a:         try {
1:f812e34:             return (Tracked)command.visit(this);
1:d29ca2a:         } catch (IOException e) {
1:d29ca2a:             throw e;
1:d29ca2a:         } catch (Throwable e) {
1:d29ca2a:             throw IOExceptionSupport.create(e);
1:f812e34:         }
1:d29ca2a:     }
1:e7703f7: 
1:e7703f7:     /**
1:e7703f7:      * Completes the two phase tracking operation for a command that is sent on the wire.  Once
1:e7703f7:      * the command is sent successfully to complete the tracking operation or otherwise update
1:e7703f7:      * the state of the tracker.
1:e7703f7:      *
1:e7703f7:      * @param command
1:e7703f7:      *      The command that was previously provided to the track method.
1:e7703f7:      */
1:e225ba6:     public void trackBack(Command command) {
1:966de0c:         if (command != null) {
1:966de0c:             if (trackMessages && command.isMessage()) {
1:966de0c:                 Message message = (Message) command;
1:966de0c:                 if (message.getTransactionId()==null) {
1:966de0c:                     currentCacheSize = currentCacheSize +  message.getSize();
1:d29ca2a:                 }
1:966de0c:             } else if (command instanceof MessagePull) {
1:e7703f7:                 // We only track one MessagePull per consumer so only add to cache size
1:e7703f7:                 // when the command has been marked as tracked.
1:e7703f7:                 if (((MessagePull)command).isTracked()) {
1:e7703f7:                     // just needs to be a rough estimate of size, ~4 identifiers
1:e7703f7:                     currentCacheSize += MESSAGE_PULL_SIZE;
1:e7703f7:                 }
1:966de0c:             }
1:4eafccc:         }
1:4eafccc:     }
1:f812e34: 
1:f812e34:     public void restore(Transport transport) throws IOException {
1:d29ca2a:         // Restore the connections.
1:ecf89a6:         for (Iterator<ConnectionState> iter = connectionStates.values().iterator(); iter.hasNext();) {
1:ecf89a6:             ConnectionState connectionState = iter.next();
1:a6a6a70:             connectionState.getInfo().setFailoverReconnect(true);
1:a6a6a70:             if (LOG.isDebugEnabled()) {
1:8732f70:                 LOG.debug("conn: " + connectionState.getInfo().getConnectionId());
1:a6a6a70:             }
1:d29ca2a:             transport.oneway(connectionState.getInfo());
1:d29ca2a:             restoreTempDestinations(transport, connectionState);
1:f812e34: 
1:ecf89a6:             if (restoreSessions) {
1:d29ca2a:                 restoreSessions(transport, connectionState);
1:ecf89a6:             }
1:f812e34: 
1:ecf89a6:             if (restoreTransaction) {
1:f812e34:                 restoreTransactions(transport, connectionState);
1:ecf89a6:             }
1:d29ca2a:         }
1:e7703f7: 
1:e7703f7:         // now flush messages and MessagePull commands.
1:e7703f7:         for (Command msg : messageCache.values()) {
1:6efc268:             if (LOG.isDebugEnabled()) {
1:5cf33b5:                 LOG.debug("command: " + (msg.isMessage() ? ((Message) msg).getMessageId() : msg));
1:d29ca2a:             }
1:e225ba6:             transport.oneway(msg);
1:8d3ca90:         }
1:8d3ca90:     }
1:220ad62: 
1:220ad62:     private void restoreTransactions(Transport transport, ConnectionState connectionState) throws IOException {
1:90b808a:         Vector<TransactionInfo> toRollback = new Vector<>();
1:b9e51d6:         for (TransactionState transactionState : connectionState.getTransactionStates()) {
1:8732f70:             if (LOG.isDebugEnabled()) {
1:e45bb06:                 LOG.debug("tx: " + transactionState.getId());
1:8d3ca90:             }
1:e7703f7: 
1:b836af8:             // rollback any completed transactions - no way to know if commit got there
1:b836af8:             // or if reply went missing
1:b836af8:             //
1:b836af8:             if (!transactionState.getCommands().isEmpty()) {
1:b836af8:                 Command lastCommand = transactionState.getCommands().get(transactionState.getCommands().size() - 1);
1:6efc268:                 if (lastCommand instanceof TransactionInfo) {
1:6efc268:                     TransactionInfo transactionInfo = (TransactionInfo) lastCommand;
1:6efc268:                     if (transactionInfo.getType() == TransactionInfo.COMMIT_ONE_PHASE) {
1:6efc268:                         if (LOG.isDebugEnabled()) {
1:b836af8:                             LOG.debug("rolling back potentially completed tx: " + transactionState.getId());
1:6efc268:                         }
1:b836af8:                         toRollback.add(transactionInfo);
1:6efc268:                         continue;
1:6efc268:                     }
1:6efc268:                 }
1:6efc268:             }
1:295850d: 
1:6efc268:             // replay short lived producers that may have been involved in the transaction
1:b9e51d6:             for (ProducerState producerState : transactionState.getProducerStates().values()) {
1:b9e51d6:                 if (LOG.isDebugEnabled()) {
1:b9e51d6:                     LOG.debug("tx replay producer :" + producerState.getInfo());
1:6efc268:                 }
1:b9e51d6:                 transport.oneway(producerState.getInfo());
1:8732f70:             }
1:e7703f7: 
1:b9e51d6:             for (Command command : transactionState.getCommands()) {
2:e45bb06:                 if (LOG.isDebugEnabled()) {
1:e45bb06:                     LOG.debug("tx replay: " + command);
1:b9e51d6:                 }
1:f812e34:                 transport.oneway(command);
1:f812e34:             }
1:e7703f7: 
1:b9e51d6:             for (ProducerState producerState : transactionState.getProducerStates().values()) {
1:b9e51d6:                 if (LOG.isDebugEnabled()) {
1:b9e51d6:                     LOG.debug("tx remove replayed producer :" + producerState.getInfo());
1:f812e34:                 }
1:b9e51d6:                 transport.oneway(producerState.getInfo().createRemoveCommand());
1:f812e34:             }
1:220ad62:         }
1:e7703f7: 
1:b836af8:         for (TransactionInfo command: toRollback) {
1:6efc268:             // respond to the outstanding commit
1:b836af8:             ExceptionResponse response = new ExceptionResponse();
1:b836af8:             response.setException(new TransactionRolledBackException("Transaction completion in doubt due to failover. Forcing rollback of " + command.getTransactionId()));
1:6efc268:             response.setCorrelationId(command.getCommandId());
1:6efc268:             transport.getTransportListener().onCommand(response);
1:220ad62:         }
1:220ad62:     }
1:220ad62: 
1:f812e34:     /**
1:d29ca2a:      * @param transport
1:d29ca2a:      * @param connectionState
1:220ad62:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     protected void restoreSessions(Transport transport, ConnectionState connectionState) throws IOException {
1:d29ca2a:         // Restore the connection's sessions
1:d29ca2a:         for (Iterator iter2 = connectionState.getSessionStates().iterator(); iter2.hasNext();) {
1:f812e34:             SessionState sessionState = (SessionState)iter2.next();
1:8732f70:             if (LOG.isDebugEnabled()) {
1:8732f70:                 LOG.debug("session: " + sessionState.getInfo().getSessionId());
1:6efc268:             }
1:d29ca2a:             transport.oneway(sessionState.getInfo());
1:295850d: 
1:ecf89a6:             if (restoreProducers) {
1:d29ca2a:                 restoreProducers(transport, sessionState);
1:ecf89a6:             }
1:f812e34: 
1:ecf89a6:             if (restoreConsumers) {
1:d29ca2a:                 restoreConsumers(transport, sessionState);
1:ecf89a6:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:295850d: 
1:220ad62:     /**
1:d29ca2a:      * @param transport
1:d29ca2a:      * @param sessionState
2:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     protected void restoreConsumers(Transport transport, SessionState sessionState) throws IOException {
1:8d3ca90:         // Restore the session's consumers but possibly in pull only (prefetch 0 state) till recovery complete
1:8d3ca90:         final ConnectionState connectionState = connectionStates.get(sessionState.getInfo().getSessionId().getParentId());
1:8d3ca90:         final boolean connectionInterruptionProcessingComplete = connectionState.isConnectionInterruptProcessingComplete();
1:e7703f7:         for (ConsumerState consumerState : sessionState.getConsumerStates()) {
1:8d3ca90:             ConsumerInfo infoToSend = consumerState.getInfo();
1:8d3ca90:             if (!connectionInterruptionProcessingComplete && infoToSend.getPrefetchSize() > 0) {
1:8d3ca90:                 infoToSend = consumerState.getInfo().copy();
1:8d3ca90:                 connectionState.getRecoveringPullConsumers().put(infoToSend.getConsumerId(), consumerState.getInfo());
1:8d3ca90:                 infoToSend.setPrefetchSize(0);
1:8d3ca90:                 if (LOG.isDebugEnabled()) {
1:8d3ca90:                     LOG.debug("restore consumer: " + infoToSend.getConsumerId() + " in pull mode pending recovery, overriding prefetch: " + consumerState.getInfo().getPrefetchSize());
1:d29ca2a:                 }
1:d29ca2a:             }
1:8d3ca90:             if (LOG.isDebugEnabled()) {
1:cfe099d:                 LOG.debug("consumer: " + infoToSend.getConsumerId());
1:8d3ca90:             }
1:8d3ca90:             transport.oneway(infoToSend);
1:8d3ca90:         }
1:8732f70:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param transport
1:d29ca2a:      * @param sessionState
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     protected void restoreProducers(Transport transport, SessionState sessionState) throws IOException {
1:d29ca2a:         // Restore the session's producers
1:d29ca2a:         for (Iterator iter3 = sessionState.getProducerStates().iterator(); iter3.hasNext();) {
1:f812e34:             ProducerState producerState = (ProducerState)iter3.next();
1:8732f70:             if (LOG.isDebugEnabled()) {
1:8732f70:                 LOG.debug("producer: " + producerState.getInfo().getProducerId());
1:d29ca2a:             }
1:d29ca2a:             transport.oneway(producerState.getInfo());
1:d29ca2a:         }
1:8732f70:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param transport
1:d29ca2a:      * @param connectionState
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:f812e34:     protected void restoreTempDestinations(Transport transport, ConnectionState connectionState)
1:f812e34:         throws IOException {
1:d29ca2a:         // Restore the connection's temp destinations.
1:53ea4ca:         for (Iterator iter2 = connectionState.getTempDestinations().iterator(); iter2.hasNext();) {
1:705a877:             DestinationInfo info = (DestinationInfo)iter2.next();
1:705a877:             transport.oneway(info);
1:705a877:             if (LOG.isDebugEnabled()) {
1:705a877:                 LOG.debug("tempDest: " + info.getDestination());
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:8641928:     @Override
1:f812e34:     public Response processAddDestination(DestinationInfo info) {
1:f812e34:         if (info != null) {
1:ecf89a6:             ConnectionState cs = connectionStates.get(info.getConnectionId());
1:f812e34:             if (cs != null && info.getDestination().isTemporary()) {
1:9614aa9:                 cs.addTempDestination(info);
1:705a877:             }
1:b9e51d6:         }
1:220ad62:         return TRACKED_RESPONSE_MARKER;
1:d29ca2a:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processRemoveDestination(DestinationInfo info) {
1:f812e34:         if (info != null) {
1:ecf89a6:             ConnectionState cs = connectionStates.get(info.getConnectionId());
1:f812e34:             if (cs != null && info.getDestination().isTemporary()) {
1:d29ca2a:                 cs.removeTempDestination(info.getDestination());
1:d29ca2a:             }
1:d29ca2a:         }
1:220ad62:         return TRACKED_RESPONSE_MARKER;
1:b9e51d6:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processAddProducer(ProducerInfo info) {
1:f812e34:         if (info != null && info.getProducerId() != null) {
1:f812e34:             SessionId sessionId = info.getProducerId().getParentId();
1:f812e34:             if (sessionId != null) {
1:f812e34:                 ConnectionId connectionId = sessionId.getParentId();
1:f812e34:                 if (connectionId != null) {
1:ecf89a6:                     ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                     if (cs != null) {
1:f812e34:                         SessionState ss = cs.getSessionState(sessionId);
1:f812e34:                         if (ss != null) {
1:d29ca2a:                             ss.addProducer(info);
1:90b808a:                             if (info.isResponseRequired()) {
1:90b808a:                                 return new Tracked(new ExceptionResponseCheckAction(info));
1:90b808a:                             }
1:d29ca2a:                         }
1:b9e51d6:                     }
1:b9e51d6:                 }
1:e45bb06:             }
1:e45bb06:         }
4:d29ca2a:         return TRACKED_RESPONSE_MARKER;
1:c42c5ff:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processRemoveProducer(ProducerId id) {
1:f812e34:         if (id != null) {
1:f812e34:             SessionId sessionId = id.getParentId();
1:f812e34:             if (sessionId != null) {
1:f812e34:                 ConnectionId connectionId = sessionId.getParentId();
1:f812e34:                 if (connectionId != null) {
1:ecf89a6:                     ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                     if (cs != null) {
1:f812e34:                         SessionState ss = cs.getSessionState(sessionId);
1:f812e34:                         if (ss != null) {
1:d29ca2a:                             ss.removeProducer(id);
1:d29ca2a:                         }
1:e225ba6:                     }
1:e225ba6:                 }
1:e225ba6:             }
1:e225ba6:         }
1:d29ca2a:         return TRACKED_RESPONSE_MARKER;
1:e225ba6:     }
1:220ad62: 
1:e7703f7:     @Override
1:f812e34:     public Response processAddConsumer(ConsumerInfo info) {
1:f812e34:         if (info != null) {
1:f812e34:             SessionId sessionId = info.getConsumerId().getParentId();
1:f812e34:             if (sessionId != null) {
1:f812e34:                 ConnectionId connectionId = sessionId.getParentId();
1:f812e34:                 if (connectionId != null) {
1:ecf89a6:                     ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                     if (cs != null) {
1:f812e34:                         SessionState ss = cs.getSessionState(sessionId);
1:f812e34:                         if (ss != null) {
1:d29ca2a:                             ss.addConsumer(info);
1:8641928:                             if (info.isResponseRequired()) {
1:8641928:                                 return new Tracked(new ExceptionResponseCheckAction(info));
1:8641928:                             }
1:d29ca2a:                         }
1:e225ba6:                     }
1:e225ba6:                 }
1:e225ba6:             }
1:e225ba6:         }
1:d29ca2a:         return TRACKED_RESPONSE_MARKER;
1:e225ba6:     }
1:220ad62: 
1:e7703f7:     @Override
1:84dbbc7:     public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) {
1:f812e34:         if (id != null) {
1:f812e34:             SessionId sessionId = id.getParentId();
1:f812e34:             if (sessionId != null) {
1:f812e34:                 ConnectionId connectionId = sessionId.getParentId();
1:f812e34:                 if (connectionId != null) {
1:ecf89a6:                     ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                     if (cs != null) {
1:f812e34:                         SessionState ss = cs.getSessionState(sessionId);
1:f812e34:                         if (ss != null) {
1:d29ca2a:                             ss.removeConsumer(id);
1:d29ca2a:                         }
1:dc0291b:                         cs.getRecoveringPullConsumers().remove(id);
1:a3e3821:                     }
1:a3e3821:                 }
57:e6a418b:             }
1:e6a418b:         }
1:d29ca2a:         return TRACKED_RESPONSE_MARKER;
1:e6a418b:     }
1:d29ca2a: 
1:e7703f7:     @Override
1:f812e34:     public Response processAddSession(SessionInfo info) {
1:f812e34:         if (info != null) {
1:f812e34:             ConnectionId connectionId = info.getSessionId().getParentId();
1:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:d29ca2a:                     cs.addSession(info);
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return TRACKED_RESPONSE_MARKER;
1:d29ca2a:     }
1:f812e34: 
1:e7703f7:     @Override
1:84dbbc7:     public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) {
1:f812e34:         if (id != null) {
1:f812e34:             ConnectionId connectionId = id.getParentId();
1:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:d29ca2a:                     cs.removeSession(id);
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:         return TRACKED_RESPONSE_MARKER;
1:d29ca2a:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processAddConnection(ConnectionInfo info) {
1:e6a418b:         if (info != null) {
1:f812e34:             connectionStates.put(info.getConnectionId(), new ConnectionState(info));
1:d29ca2a:         }
1:d29ca2a:         return TRACKED_RESPONSE_MARKER;
1:d29ca2a:     }
1:d29ca2a: 
1:e7703f7:     @Override
1:84dbbc7:     public Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws Exception {
1:f812e34:         if (id != null) {
1:f812e34:             connectionStates.remove(id);
1:f812e34:         }
1:f812e34:         return TRACKED_RESPONSE_MARKER;
1:f812e34:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processMessage(Message send) throws Exception {
1:e225ba6:         if (send != null) {
1:e225ba6:             if (trackTransactions && send.getTransactionId() != null) {
1:b9e51d6:                 ProducerId producerId = send.getProducerId();
1:b9e51d6:                 ConnectionId connectionId = producerId.getParentId().getParentId();
1:f812e34:                 if (connectionId != null) {
1:ecf89a6:                     ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                     if (cs != null) {
1:f812e34:                         TransactionState transactionState = cs.getTransactionState(send.getTransactionId());
1:f812e34:                         if (transactionState != null) {
1:220ad62:                             transactionState.addCommand(send);
1:e7703f7: 
1:b9e51d6:                             if (trackTransactionProducers) {
1:b9e51d6:                                 // for jmstemplate, track the producer in case it is closed before commit
1:b9e51d6:                                 // and needs to be replayed
1:b9e51d6:                                 SessionState ss = cs.getSessionState(producerId.getParentId());
1:b9e51d6:                                 ProducerState producerState = ss.getProducerState(producerId);
1:e7703f7:                                 producerState.setTransactionState(transactionState);
1:220ad62:                             }
1:220ad62:                         }
1:d29ca2a:                     }
1:d29ca2a:                 }
1:220ad62:                 return TRACKED_RESPONSE_MARKER;
1:e225ba6:             }else if (trackMessages) {
1:0817f5d:                 messageCache.put(send.getMessageId(), send);
1:d29ca2a:             }
1:d29ca2a:         }
4:220ad62:         return null;
1:f812e34:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processBeginTransaction(TransactionInfo info) {
1:f812e34:         if (trackTransactions && info != null && info.getTransactionId() != null) {
1:f812e34:             ConnectionId connectionId = info.getConnectionId();
1:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:220ad62:                     cs.addTransactionState(info.getTransactionId());
1:4118d02:                     TransactionState state = cs.getTransactionState(info.getTransactionId());
1:4118d02:                     state.addCommand(info);
1:f812e34:                 }
1:ec14f65:             }
1:220ad62:             return TRACKED_RESPONSE_MARKER;
1:220ad62:         }
1:ec14f65:         return null;
1:220ad62:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processPrepareTransaction(TransactionInfo info) throws Exception {
1:8188f7f:         if (trackTransactions && info != null && info.getTransactionId() != null) {
1:f812e34:             ConnectionId connectionId = info.getConnectionId();
1:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:f812e34:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:f812e34:                     if (transactionState != null) {
2:220ad62:                         transactionState.addCommand(info);
1:4eafccc:                         return new Tracked(new PrepareReadonlyTransactionAction(info));
1:220ad62:                     }
1:220ad62:                 }
1:295850d:             }
1:295850d:         }
1:220ad62:         return null;
1:295850d:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
1:8188f7f:         if (trackTransactions && info != null && info.getTransactionId() != null) {
1:f812e34:             ConnectionId connectionId = info.getConnectionId();
1:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:f812e34:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:f812e34:                     if (transactionState != null) {
1:220ad62:                         transactionState.addCommand(info);
2:220ad62:                         return new Tracked(new RemoveTransactionAction(info));
1:220ad62:                     }
1:220ad62:                 }
1:220ad62:             }
1:295850d:         }
1:220ad62:         return null;
1:295850d:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
1:8188f7f:         if (trackTransactions && info != null && info.getTransactionId() != null) {
1:f812e34:             ConnectionId connectionId = info.getConnectionId();
1:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:f812e34:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:f812e34:                     if (transactionState != null) {
1:220ad62:                         transactionState.addCommand(info);
1:220ad62:                         return new Tracked(new RemoveTransactionAction(info));
1:220ad62:                     }
1:220ad62:                 }
1:220ad62:             }
1:220ad62:         }
1:220ad62:         return null;
1:220ad62:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processRollbackTransaction(TransactionInfo info) throws Exception {
1:8188f7f:         if (trackTransactions && info != null && info.getTransactionId() != null) {
1:f812e34:             ConnectionId connectionId = info.getConnectionId();
1:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:f812e34:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:f812e34:                     if (transactionState != null) {
1:f812e34:                         transactionState.addCommand(info);
1:f812e34:                         return new Tracked(new RemoveTransactionAction(info));
1:f812e34:                     }
1:f812e34:                 }
1:f812e34:             }
1:f812e34:         }
1:f812e34:         return null;
1:f812e34:     }
1:f812e34: 
1:e7703f7:     @Override
1:f812e34:     public Response processEndTransaction(TransactionInfo info) throws Exception {
1:8188f7f:         if (trackTransactions && info != null && info.getTransactionId() != null) {
1:f812e34:             ConnectionId connectionId = info.getConnectionId();
2:f812e34:             if (connectionId != null) {
1:ecf89a6:                 ConnectionState cs = connectionStates.get(connectionId);
1:f812e34:                 if (cs != null) {
1:f812e34:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
2:f812e34:                     if (transactionState != null) {
1:220ad62:                         transactionState.addCommand(info);
1:220ad62:                     }
1:220ad62:                 }
1:220ad62:             }
1:220ad62:             return TRACKED_RESPONSE_MARKER;
1:295850d:         }
1:220ad62:         return null;
1:d29ca2a:     }
1:f812e34: 
1:966de0c:     @Override
1:966de0c:     public Response processMessagePull(MessagePull pull) throws Exception {
1:966de0c:         if (pull != null) {
1:966de0c:             // leave a single instance in the cache
1:966de0c:             final String id = pull.getDestination() + "::" + pull.getConsumerId();
1:e7703f7:             if (messageCache.put(id.intern(), pull) == null) {
1:e7703f7:                 // Only marked as tracked if this is the first request we've seen.
1:e7703f7:                 pull.setTracked(true);
1:e7703f7:             }
1:d29ca2a:         }
1:220ad62:         return null;
1:d29ca2a:     }
1:ec14f65: 
1:d29ca2a:     public boolean isRestoreConsumers() {
1:d29ca2a:         return restoreConsumers;
1:d29ca2a:     }
1:220ad62: 
1:d29ca2a:     public void setRestoreConsumers(boolean restoreConsumers) {
1:d29ca2a:         this.restoreConsumers = restoreConsumers;
1:d29ca2a:     }
1:220ad62: 
1:d29ca2a:     public boolean isRestoreProducers() {
1:d29ca2a:         return restoreProducers;
1:d29ca2a:     }
1:220ad62: 
1:d29ca2a:     public void setRestoreProducers(boolean restoreProducers) {
1:d29ca2a:         this.restoreProducers = restoreProducers;
1:d29ca2a:     }
1:220ad62: 
1:d29ca2a:     public boolean isRestoreSessions() {
1:d29ca2a:         return restoreSessions;
1:d29ca2a:     }
1:220ad62: 
1:d29ca2a:     public void setRestoreSessions(boolean restoreSessions) {
1:d29ca2a:         this.restoreSessions = restoreSessions;
1:220ad62:     }
1:220ad62: 
1:f812e34:     public boolean isTrackTransactions() {
1:f812e34:         return trackTransactions;
1:f812e34:     }
1:220ad62: 
1:f812e34:     public void setTrackTransactions(boolean trackTransactions) {
1:f812e34:         this.trackTransactions = trackTransactions;
1:f812e34:     }
1:e7703f7: 
1:b9e51d6:     public boolean isTrackTransactionProducers() {
1:b9e51d6:         return this.trackTransactionProducers;
1:220ad62:     }
1:220ad62: 
1:b9e51d6:     public void setTrackTransactionProducers(boolean trackTransactionProducers) {
1:b9e51d6:         this.trackTransactionProducers = trackTransactionProducers;
1:220ad62:     }
1:e7703f7: 
1:f812e34:     public boolean isRestoreTransaction() {
1:f812e34:         return restoreTransaction;
1:f812e34:     }
1:220ad62: 
1:f812e34:     public void setRestoreTransaction(boolean restoreTransaction) {
1:f812e34:         this.restoreTransaction = restoreTransaction;
1:f812e34:     }
1:ec14f65: 
1:e225ba6:     public boolean isTrackMessages() {
1:e225ba6:         return trackMessages;
1:220ad62:     }
1:220ad62: 
1:e225ba6:     public void setTrackMessages(boolean trackMessages) {
1:e225ba6:         this.trackMessages = trackMessages;
1:d29ca2a:     }
1:295850d: 
1:e225ba6:     public int getMaxCacheSize() {
1:e225ba6:         return maxCacheSize;
1:d29ca2a:     }
1:295850d: 
1:e225ba6:     public void setMaxCacheSize(int maxCacheSize) {
1:e225ba6:         this.maxCacheSize = maxCacheSize;
1:d29ca2a:     }
1:d29ca2a: 
1:e7703f7:     /**
1:e7703f7:      * @return the current cache size for the Message and MessagePull Command cache.
1:e7703f7:      */
1:e7703f7:     public long getCurrentCacheSize() {
1:e7703f7:         return this.currentCacheSize;
1:e7703f7:     }
1:e7703f7: 
1:8d3ca90:     public void connectionInterruptProcessingComplete(Transport transport, ConnectionId connectionId) {
1:8d3ca90:         ConnectionState connectionState = connectionStates.get(connectionId);
1:8d3ca90:         if (connectionState != null) {
1:8d3ca90:             connectionState.setConnectionInterruptProcessingComplete(true);
1:8d3ca90:             Map<ConsumerId, ConsumerInfo> stalledConsumers = connectionState.getRecoveringPullConsumers();
1:8d3ca90:             for (Entry<ConsumerId, ConsumerInfo> entry: stalledConsumers.entrySet()) {
1:8d3ca90:                 ConsumerControl control = new ConsumerControl();
1:8d3ca90:                 control.setConsumerId(entry.getKey());
1:8d3ca90:                 control.setPrefetch(entry.getValue().getPrefetchSize());
1:8d3ca90:                 control.setDestination(entry.getValue().getDestination());
1:8d3ca90:                 try {
1:8d3ca90:                     if (LOG.isDebugEnabled()) {
1:8d3ca90:                         LOG.debug("restored recovering consumer: " + control.getConsumerId() + " with: " + control.getPrefetch());
1:d29ca2a:                     }
1:e7703f7:                     transport.oneway(control);
1:8d3ca90:                 } catch (Exception ex) {
1:8d3ca90:                     if (LOG.isDebugEnabled()) {
1:8d3ca90:                         LOG.debug("Failed to submit control for consumer: " + control.getConsumerId()
1:8d3ca90:                                 + " with: " + control.getPrefetch(), ex);
1:d29ca2a:                     }
1:966de0c:                 }
1:966de0c:             }
1:8d3ca90:             stalledConsumers.clear();
1:8d3ca90:         }
1:8d3ca90:     }
1:d29ca2a: 
1:4c4f0d1:     public void transportInterrupted(ConnectionId connectionId) {
1:4c4f0d1:         ConnectionState connectionState = connectionStates.get(connectionId);
1:4c4f0d1:         if (connectionState != null) {
1:8d3ca90:             connectionState.setConnectionInterruptProcessingComplete(false);
1:8d3ca90:         }
1:8d3ca90:     }
1:8d3ca90: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:90b808a
/////////////////////////////////////////////////////////////////////////
1:     protected final ConcurrentMap<ConnectionId, ConnectionState> connectionStates = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:         private final Command tracked;
1:         public ExceptionResponseCheckAction(Command tracked) {
1:             this.tracked = tracked;
1:                 if (tracked.getDataStructureType() == ConsumerInfo.DATA_STRUCTURE_TYPE) {
1:                     processRemoveConsumer(((ConsumerInfo) tracked).getConsumerId(), 0l);
1:                 } else if (tracked.getDataStructureType() == ProducerInfo.DATA_STRUCTURE_TYPE) {
1:                     processRemoveProducer(((ProducerInfo) tracked).getProducerId());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         Vector<TransactionInfo> toRollback = new Vector<>();
/////////////////////////////////////////////////////////////////////////
1:                             if (info.isResponseRequired()) {
1:                                 return new Tracked(new ExceptionResponseCheckAction(info));
1:                             }
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
0:     protected final ConcurrentMap<ConnectionId, ConnectionState> connectionStates = new ConcurrentHashMap<ConnectionId, ConnectionState>();
commit:e7703f7
/////////////////////////////////////////////////////////////////////////
1: import java.util.Vector;
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
0:     protected final ConcurrentHashMap<ConnectionId, ConnectionState> connectionStates = new ConcurrentHashMap<ConnectionId, ConnectionState>();
/////////////////////////////////////////////////////////////////////////
1:     private long currentCacheSize;  // use long to prevent overflow for folks who set high max.
1: 
1:     private final Map<Object,Command> messageCache = new LinkedHashMap<Object,Command>(){
1:         @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     private class PrepareReadonlyTransactionAction extends RemoveTransactionAction {
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:      * Entry point for all tracked commands in the tracker.  Commands should be tracked before
1:      * there is an attempt to send them on the wire.  Upon a successful send of a command it is
1:      * necessary to call the trackBack method to complete the tracking of the given command.
1:      *
1:      *      The command that is to be tracked by this tracker.
1:      *
1:      *
1:      * @throws IOException if an error occurs during setup of the tracking operation.
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Completes the two phase tracking operation for a command that is sent on the wire.  Once
1:      * the command is sent successfully to complete the tracking operation or otherwise update
1:      * the state of the tracker.
1:      *
1:      * @param command
1:      *      The command that was previously provided to the track method.
1:      */
/////////////////////////////////////////////////////////////////////////
1:                 // We only track one MessagePull per consumer so only add to cache size
1:                 // when the command has been marked as tracked.
1:                 if (((MessagePull)command).isTracked()) {
1:                     // just needs to be a rough estimate of size, ~4 identifiers
1:                     currentCacheSize += MESSAGE_PULL_SIZE;
1:                 }
/////////////////////////////////////////////////////////////////////////
1: 
1:         // now flush messages and MessagePull commands.
1:         for (Command msg : messageCache.values()) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (ConsumerState consumerState : sessionState.getConsumerStates()) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:                                 producerState.setTransactionState(transactionState);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             if (messageCache.put(id.intern(), pull) == null) {
1:                 // Only marked as tracked if this is the first request we've seen.
1:                 pull.setTracked(true);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return the current cache size for the Message and MessagePull Command cache.
1:      */
1:     public long getCurrentCacheSize() {
1:         return this.currentCacheSize;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     transport.oneway(control);
author:gtully
-------------------------------------------------------------------------------
commit:8641928
/////////////////////////////////////////////////////////////////////////
1:     private final class ExceptionResponseCheckAction implements ResponseHandler {
0:         private final ConsumerInfo info;
1: 
0:         public ExceptionResponseCheckAction(ConsumerInfo info) {
1:             this.info = info;
1:         }
1: 
1:         @Override
1:         public void onResponse(Command response) {
1:             if (ExceptionResponse.DATA_STRUCTURE_TYPE == response.getDataStructureType()) {
0:                 processRemoveConsumer(info.getConsumerId(), 0l);
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                             if (info.isResponseRequired()) {
1:                                 return new Tracked(new ExceptionResponseCheckAction(info));
1:                             }
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("consumer: " + infoToSend.getConsumerId());
commit:dc0291b
/////////////////////////////////////////////////////////////////////////
1:                         cs.getRecoveringPullConsumers().remove(id);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:8188f7f
/////////////////////////////////////////////////////////////////////////
1:         if (trackTransactions && info != null && info.getTransactionId() != null) {
/////////////////////////////////////////////////////////////////////////
1:         if (trackTransactions && info != null && info.getTransactionId() != null) {
/////////////////////////////////////////////////////////////////////////
1:         if (trackTransactions && info != null && info.getTransactionId() != null) {
/////////////////////////////////////////////////////////////////////////
1:         if (trackTransactions && info != null && info.getTransactionId() != null) {
/////////////////////////////////////////////////////////////////////////
1:         if (trackTransactions && info != null && info.getTransactionId() != null) {
author:Torsten Mielke
-------------------------------------------------------------------------------
commit:f69cbd8
/////////////////////////////////////////////////////////////////////////
1:             if (command instanceof IntegerResponse) {
1:                 IntegerResponse response = (IntegerResponse) command;
1:                 if (XAResource.XA_RDONLY == response.getResult()) {
1:                     // all done, no commit or rollback from TM
1:                     super.onResponse(command);
1:                 }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     protected final ConcurrentHashMap<ConnectionId, ConnectionState> connectionStates = new ConcurrentHashMap<ConnectionId, ConnectionState>();
1:     private boolean trackTransactions;
/////////////////////////////////////////////////////////////////////////
1:             ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator<ConnectionState> iter = connectionStates.values().iterator(); iter.hasNext();) {
1:             ConnectionState connectionState = iter.next();
1:             if (restoreSessions) {
1:             }
1:             if (restoreTransaction) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (restoreProducers) {
1:             }
1:             if (restoreConsumers) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             ConnectionState cs = connectionStates.get(info.getConnectionId());
/////////////////////////////////////////////////////////////////////////
1:             ConnectionState cs = connectionStates.get(info.getConnectionId());
/////////////////////////////////////////////////////////////////////////
1:                     ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                     ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                     ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                     ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionState cs = connectionStates.get(connectionId);
/////////////////////////////////////////////////////////////////////////
0:                 ConnectionState cs = connectionStates.get(connectionId);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     private static final Tracked TRACKED_RESPONSE_MARKER = new Tracked(null);
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * Tracks the state of a connection so a newly established transport can be
1:  * re-initialized to the state that was tracked.
0:     private final static Tracked TRACKED_RESPONSE_MARKER = new Tracked(null);
1: 
0:     private boolean trackTransactions = false;
1: 
1:     private boolean restoreSessions = true;
1:     private boolean restoreConsumers = true;
1:     private boolean restoreProducers = true;
1:     private boolean restoreTransaction = true;
1: 
1: 
1:         private final TransactionInfo info;
1: 
1:         public RemoveTransactionAction(TransactionInfo info) {
0:             this.info = info;
1:         }
1: 
0:         public void run() {
1:             ConnectionId connectionId = info.getConnectionId();
0:             ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:             cs.removeTransactionState(info.getTransactionId());
1:         }
/////////////////////////////////////////////////////////////////////////
1:             return (Tracked)command.visit(this);
1:     }
1: 
1:     public void restore(Transport transport) throws IOException {
0:             ConnectionState connectionState = (ConnectionState)iter.next();
1: 
0:             if (restoreSessions)
1: 
0:             if (restoreTransaction)
1:                 restoreTransactions(transport, connectionState);
0:         for (Iterator iter = connectionState.getTransactionStates().iterator(); iter.hasNext();) {
0:             TransactionState transactionState = (TransactionState)iter.next();
0:             for (Iterator iterator = transactionState.getCommands().iterator(); iterator.hasNext();) {
0:                 Command command = (Command)iterator.next();
1:                 transport.oneway(command);
1:             }
1:         }
1:     }
1:     /**
/////////////////////////////////////////////////////////////////////////
1:             SessionState sessionState = (SessionState)iter2.next();
0:             if (restoreProducers)
1: 
0:             if (restoreConsumers)
/////////////////////////////////////////////////////////////////////////
0:             ConsumerState consumerState = (ConsumerState)iter3.next();
/////////////////////////////////////////////////////////////////////////
1:             ProducerState producerState = (ProducerState)iter3.next();
/////////////////////////////////////////////////////////////////////////
1:     protected void restoreTempDestinations(Transport transport, ConnectionState connectionState)
1:         throws IOException {
0:             transport.oneway((DestinationInfo)iter2.next());
1:     public Response processAddDestination(DestinationInfo info) {
1:         if (info != null) {
0:             ConnectionState cs = (ConnectionState)connectionStates.get(info.getConnectionId());
1:             if (cs != null && info.getDestination().isTemporary()) {
1:     public Response processRemoveDestination(DestinationInfo info) {
1:         if (info != null) {
0:             ConnectionState cs = (ConnectionState)connectionStates.get(info.getConnectionId());
1:             if (cs != null && info.getDestination().isTemporary()) {
1:     public Response processAddProducer(ProducerInfo info) {
1:         if (info != null && info.getProducerId() != null) {
1:             SessionId sessionId = info.getProducerId().getParentId();
1:             if (sessionId != null) {
1:                 ConnectionId connectionId = sessionId.getParentId();
1:                 if (connectionId != null) {
0:                     ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                     if (cs != null) {
1:                         SessionState ss = cs.getSessionState(sessionId);
1:                         if (ss != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Response processRemoveProducer(ProducerId id) {
1:         if (id != null) {
1:             SessionId sessionId = id.getParentId();
1:             if (sessionId != null) {
1:                 ConnectionId connectionId = sessionId.getParentId();
1:                 if (connectionId != null) {
0:                     ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                     if (cs != null) {
1:                         SessionState ss = cs.getSessionState(sessionId);
1:                         if (ss != null) {
/////////////////////////////////////////////////////////////////////////
1:     public Response processAddConsumer(ConsumerInfo info) {
1:         if (info != null) {
1:             SessionId sessionId = info.getConsumerId().getParentId();
1:             if (sessionId != null) {
1:                 ConnectionId connectionId = sessionId.getParentId();
1:                 if (connectionId != null) {
0:                     ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                     if (cs != null) {
1:                         SessionState ss = cs.getSessionState(sessionId);
1:                         if (ss != null) {
/////////////////////////////////////////////////////////////////////////
1: 
0:     public Response processRemoveConsumer(ConsumerId id) {
1:         if (id != null) {
1:             SessionId sessionId = id.getParentId();
1:             if (sessionId != null) {
1:                 ConnectionId connectionId = sessionId.getParentId();
1:                 if (connectionId != null) {
0:                     ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                     if (cs != null) {
1:                         SessionState ss = cs.getSessionState(sessionId);
1:                         if (ss != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Response processAddSession(SessionInfo info) {
1:         if (info != null) {
1:             ConnectionId connectionId = info.getSessionId().getParentId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1: 
0:     public Response processRemoveSession(SessionId id) {
1:         if (id != null) {
1:             ConnectionId connectionId = id.getParentId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1: 
1:     public Response processAddConnection(ConnectionInfo info) {
1:             connectionStates.put(info.getConnectionId(), new ConnectionState(info));
0:     public Response processRemoveConnection(ConnectionId id) throws Exception {
1:         if (id != null) {
1:             connectionStates.remove(id);
1:         }
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1: 
1:     public Response processMessage(Message send) throws Exception {
0:         if (trackTransactions && send != null && send.getTransactionId() != null) {
0:             ConnectionId connectionId = send.getProducerId().getParentId().getParentId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1:                     TransactionState transactionState = cs.getTransactionState(send.getTransactionId());
1:                     if (transactionState != null) {
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
0:     public Response processMessageAck(MessageAck ack) {
0:         if (trackTransactions && ack != null && ack.getTransactionId() != null) {
0:             ConnectionId connectionId = ack.getConsumerId().getParentId().getParentId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
0:                     TransactionState transactionState = cs.getTransactionState(ack.getTransactionId());
1:                     if (transactionState != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Response processBeginTransaction(TransactionInfo info) {
1:         if (trackTransactions && info != null && info.getTransactionId() != null) {
1:             ConnectionId connectionId = info.getConnectionId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1:     }
1: 
1:     public Response processPrepareTransaction(TransactionInfo info) throws Exception {
0:         if (trackTransactions && info != null) {
1:             ConnectionId connectionId = info.getConnectionId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:                     if (transactionState != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
0:         if (trackTransactions && info != null) {
1:             ConnectionId connectionId = info.getConnectionId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:                     if (transactionState != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
0:         if (trackTransactions && info != null) {
1:             ConnectionId connectionId = info.getConnectionId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:                     if (transactionState != null) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Response processRollbackTransaction(TransactionInfo info) throws Exception {
0:         if (trackTransactions && info != null) {
1:             ConnectionId connectionId = info.getConnectionId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:                     if (transactionState != null) {
1:                         transactionState.addCommand(info);
1:                         return new Tracked(new RemoveTransactionAction(info));
1:                     }
1:                 }
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     public Response processEndTransaction(TransactionInfo info) throws Exception {
0:         if (trackTransactions && info != null) {
1:             ConnectionId connectionId = info.getConnectionId();
1:             if (connectionId != null) {
0:                 ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
1:                 if (cs != null) {
1:                     TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:                     if (transactionState != null) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean isTrackTransactions() {
1:         return trackTransactions;
1:     }
1:     public void setTrackTransactions(boolean trackTransactions) {
1:         this.trackTransactions = trackTransactions;
1:     }
1:     public boolean isRestoreTransaction() {
1:         return restoreTransaction;
1:     }
1:     public void setRestoreTransaction(boolean restoreTransaction) {
1:         this.restoreTransaction = restoreTransaction;
1:     }
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:fb3b6db
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
1: public class ConnectionStateTracker extends CommandVisitorAdapter {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ec14f65
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ProducerAck;
/////////////////////////////////////////////////////////////////////////
0:     public Response processProducerAck(ProducerAck ack) throws Exception {
1: 		return null;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
commit:220ad62
/////////////////////////////////////////////////////////////////////////
0: 	private final static Tracked TRACKED_RESPONSE_MARKER = new Tracked(null);
0: 	private boolean trackTransactions = false;
0:     private boolean restoreConsumers=true;
0:     private boolean restoreTransaction=true;
1:         
0:     private class RemoveTransactionAction implements Runnable {
0: 		private final TransactionInfo info;
0: 		public RemoveTransactionAction(TransactionInfo info) {
0: 			this.info = info;
1: 		}
0: 		public void run() {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        cs.removeTransactionState(info.getTransactionId());
1: 		}
1:     }
1: 
1:     /**
1:      * 
1:      * 
1:      * @param command
1:      * @return null if the command is not state tracked.
1:      * @throws IOException
1:      */
1:     public Tracked track(Command command) throws IOException {
0:         	return (Tracked) command.visit(this);
/////////////////////////////////////////////////////////////////////////
1:             
0:             if( restoreTransaction )
0:             	restoreTransactions(transport, connectionState);
1:     private void restoreTransactions(Transport transport, ConnectionState connectionState) throws IOException {
0:     	for (Iterator iter = connectionState.getTransactionStates().iterator(); iter.hasNext();) {
0: 			TransactionState transactionState = (TransactionState) iter.next();
0: 			for (Iterator iterator = transactionState.getCommands().iterator(); iterator.hasNext();) {
0: 				Command command = (Command) iterator.next();
0: 	            transport.oneway(command);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
0:     	if( trackTransactions && send.getTransactionId() != null ) {
0:             ConnectionId connectionId = send.getProducerId().getParentId().getParentId();
0:             ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:             TransactionState transactionState = cs.getTransactionState(send.getTransactionId());
1:             transactionState.addCommand(send);    		
1:             return TRACKED_RESPONSE_MARKER;
1:     	}
1:     	return null;
1:     }    
0:     	if( trackTransactions && ack.getTransactionId() != null ) {
0:             ConnectionId connectionId = ack.getConsumerId().getParentId().getParentId();
0:             ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:             TransactionState transactionState = cs.getTransactionState(ack.getTransactionId());
0:             transactionState.addCommand(ack);    		
1:             return TRACKED_RESPONSE_MARKER;
1:     	}
1:     	return null;
1:     
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
1: 	        cs.addTransactionState(info.getTransactionId());
1: 	        return TRACKED_RESPONSE_MARKER;
1:     	}
1:     	return null;
1:     }    
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1: 	        transactionState.addCommand(info);
1: 	        return TRACKED_RESPONSE_MARKER;
1:     	} 
1:     	return null;
1:     
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        if( transactionState !=null ) {
1: 		        transactionState.addCommand(info);
1: 		        return new Tracked(new RemoveTransactionAction(info));
1: 	        }
1:     	}
1:     	return null;
1:     }        
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        if( transactionState !=null ) {
1: 		        transactionState.addCommand(info);
1: 		        return new Tracked(new RemoveTransactionAction(info));
1: 	        }
1:     	}
1:     	return null;
1:     
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        if( transactionState !=null ) {
1: 		        transactionState.addCommand(info);
1: 		        return new Tracked(new RemoveTransactionAction(info));
1: 	        }
1:     	}
1:     	return null;
1:     }
1:     
0:     public Response processEndTransaction(TransactionInfo info) throws Exception {
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1: 	        transactionState.addCommand(info);
1: 	        return TRACKED_RESPONSE_MARKER;
1:     	}
1:     	return null;
1:     }
1:     
0:     public Response processRecoverTransactions(TransactionInfo info) {
0:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
1:         return null;
1:     }
1: 
1:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public boolean isTrackTransactions() {
0: 		return trackTransactions;
1: 	}
1: 
0: 	public void setTrackTransactions(boolean trackTransactions) {
0: 		this.trackTransactions = trackTransactions;
1: 	}
1: 
0: 	public boolean isRestoreTransaction() {
0: 		return restoreTransaction;
1: 	}
1: 
0: 	public void setRestoreTransaction(boolean restoreTransaction) {
0: 		this.restoreTransaction = restoreTransaction;
1: 	}
1: 
commit:295850d
/////////////////////////////////////////////////////////////////////////
0:     private final static Response TRACKED_RESPONSE_MARKER = new Response();
0:     boolean trackTransactions = false;
0:     boolean trackMessages = false;
0:     boolean trackAcks = false;
0:     boolean restoreConsumers=true;
1:     
0:     public boolean track(Command command) throws IOException {
0:             return command.visit(this)!=null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return null;
1:     }
0:         return null;
0:         return null;
1:     }
0:         return null;
0:         return null;
1:     }
0:         return null;
/////////////////////////////////////////////////////////////////////////
0:     public Response processRecoverTransactions(TransactionInfo info) {
0:         return null;
1:     }
1: 
0:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
0:         return null;
1:     }
1: 
0:     public Response processEndTransaction(TransactionInfo info) throws Exception {
0:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:9614aa9
/////////////////////////////////////////////////////////////////////////
1:             cs.addTempDestination(info);
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddProducer(ProducerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveProducer(ProducerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddConsumer(ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveConsumer(ConsumerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddSession(SessionInfo info) throws Exception {
0:     public Response processRemoveSession(SessionId id) throws Exception {        
0:     public Response processAddConnection(ConnectionInfo info) throws Exception {
0:     public Response processRemoveConnection(ConnectionId id) throws Exception {
0:     public Response processRemoveSubscription(RemoveSubscriptionInfo info) throws Exception {
0:     public Response processMessage(Message send) throws Exception {
0:     public Response processMessageAck(MessageAck ack) throws Exception {
0:     public Response processBeginTransaction(TransactionInfo info) throws Exception {
0:     public Response processPrepareTransaction(TransactionInfo info) throws Exception {
0:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
0:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
0:     public Response processRollbackTransaction(TransactionInfo info) throws Exception {
0:     public Response processWireFormat(WireFormatInfo info) throws Exception {
0:     public Response processKeepAlive(KeepAliveInfo info) throws Exception {
0:     public Response processShutdown(ShutdownInfo info) throws Exception {
0:     public Response processBrokerInfo(BrokerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
0:     public Response processEndTransaction(TransactionInfo info) throws Exception {
0:     public Response processFlush(FlushCommand command) throws Exception {
0:     public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Exception{
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.state;
1: 
1: import java.io.IOException;
1: import java.util.Iterator;
1: 
0: import org.apache.activemq.command.BrokerInfo;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.FlushCommand;
0: import org.apache.activemq.command.KeepAliveInfo;
1: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
1: import org.apache.activemq.command.TransactionInfo;
0: import org.apache.activemq.command.WireFormatInfo;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.util.IOExceptionSupport;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
1: /**
0:  * Tracks the state of a connection so a newly established transport can 
0:  * be re-initialized to the state that was tracked.
0:  * 
0:  * @version $Revision$
1:  */
0: public class ConnectionStateTracker implements CommandVisitor {
1: 
0:     private final static Response TRACKED_RESPONSE_MARKER = new Response();
1:     
0:     boolean trackTransactions = false;
0:     boolean trackMessages = false;
0:     boolean trackAcks = false;
1:     
0:     private boolean restoreSessions=true;
0:     boolean restoreConsumers=true;
0:     private boolean restoreProducers=true;
1:     
0:     protected final ConcurrentHashMap connectionStates = new ConcurrentHashMap();
1:     
0:     public boolean track(Command command) throws IOException {
1:         try {
0:             return command.visit(this)!=null;
1:         } catch (IOException e) {
1:             throw e;
1:         } catch (Throwable e) {
1:             throw IOExceptionSupport.create(e);
1:         }
1:     }   
1:     
0:     public void restore( Transport transport ) throws IOException {
1:         // Restore the connections.
0:         for (Iterator iter = connectionStates.values().iterator(); iter.hasNext();) {
0:             ConnectionState connectionState = (ConnectionState) iter.next();
1:             transport.oneway(connectionState.getInfo());
1:             restoreTempDestinations(transport, connectionState);
1:             
0:             if( restoreSessions )
1:                 restoreSessions(transport, connectionState);
1:         }
1:     }
1: 
1:     /**
1:      * @param transport
1:      * @param connectionState
1:      * @throws IOException
1:      */
1:     protected void restoreSessions(Transport transport, ConnectionState connectionState) throws IOException {
1:         // Restore the connection's sessions
1:         for (Iterator iter2 = connectionState.getSessionStates().iterator(); iter2.hasNext();) {
0:             SessionState sessionState = (SessionState) iter2.next();
1:             transport.oneway(sessionState.getInfo());
1: 
0:             if( restoreProducers )
1:                 restoreProducers(transport, sessionState);
1:             
0:             if( restoreConsumers )
1:                 restoreConsumers(transport, sessionState);
1:         }
1:     }
1: 
1:     /**
1:      * @param transport
1:      * @param sessionState
1:      * @throws IOException
1:      */
1:     protected void restoreConsumers(Transport transport, SessionState sessionState) throws IOException {
0:         // Restore the session's consumers
0:         for (Iterator iter3 = sessionState.getConsumerStates().iterator(); iter3.hasNext();) {
0:             ConsumerState consumerState = (ConsumerState) iter3.next();
0:             transport.oneway(consumerState.getInfo());
1:         }
1:     }
1: 
1:     /**
1:      * @param transport
1:      * @param sessionState
1:      * @throws IOException
1:      */
1:     protected void restoreProducers(Transport transport, SessionState sessionState) throws IOException {
1:         // Restore the session's producers
1:         for (Iterator iter3 = sessionState.getProducerStates().iterator(); iter3.hasNext();) {
0:             ProducerState producerState = (ProducerState) iter3.next();
1:             transport.oneway(producerState.getInfo());
1:         }
1:     }
1: 
1:     /**
1:      * @param transport
1:      * @param connectionState
1:      * @throws IOException
1:      */
0:     protected void restoreTempDestinations(Transport transport, ConnectionState connectionState) throws IOException {
1:         // Restore the connection's temp destinations.
0:         for (Iterator iter2 = connectionState.getTempDesinations().iterator(); iter2.hasNext();) {
0:             transport.oneway((DestinationInfo) iter2.next());
1:         }
1:     }
1: 
0:     public Response processAddDestination(DestinationInfo info) throws Throwable {
0:         ConnectionState cs = (ConnectionState) connectionStates.get(info.getConnectionId());
0:         if( info.getDestination().isTemporary() ) {
0:             cs.addTempDestination(info.getDestination());
1:         }
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1: 
0:     public Response processRemoveDestination(DestinationInfo info) throws Throwable {
0:         ConnectionState cs = (ConnectionState) connectionStates.get(info.getConnectionId());
0:         if( info.getDestination().isTemporary() ) {
1:             cs.removeTempDestination(info.getDestination());
1:         }
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1: 
1: 
0:     public Response processAddProducer(ProducerInfo info) throws Throwable {
0:         SessionId sessionId = info.getProducerId().getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();
0:         ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
1:         ss.addProducer(info);
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1:     
0:     public Response processRemoveProducer(ProducerId id) throws Throwable {
0:         SessionId sessionId = id.getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();        
0:         ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
1:         ss.removeProducer(id);        
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1: 
0:     public Response processAddConsumer(ConsumerInfo info) throws Throwable {
0:         SessionId sessionId = info.getConsumerId().getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();
0:         ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
1:         ss.addConsumer(info);
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1:     
0:     public Response processRemoveConsumer(ConsumerId id) throws Throwable {
0:         SessionId sessionId = id.getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();
0:         ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
1:         ss.removeConsumer(id);
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1:     
0:     public Response processAddSession(SessionInfo info) throws Throwable {
0:         ConnectionId connectionId = info.getSessionId().getParentId();
0:         ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
1:         cs.addSession(info);
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1:     
0:     public Response processRemoveSession(SessionId id) throws Throwable {        
0:         ConnectionId connectionId = id.getParentId();
0:         ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
1:         cs.removeSession(id);
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1:     
0:     public Response processAddConnection(ConnectionInfo info) throws Throwable {
0:         connectionStates.put(info.getConnectionId(), new ConnectionState(info));        
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1:     
0:     public Response processRemoveConnection(ConnectionId id) throws Throwable {
0:         connectionStates.remove(id);
1:         return TRACKED_RESPONSE_MARKER;
1:     }
1: 
0:     public Response processRemoveSubscription(RemoveSubscriptionInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processMessage(Message send) throws Throwable {
0:         return null;
1:     }
0:     public Response processMessageAck(MessageAck ack) throws Throwable {
0:         return null;
1:     }
0:     public Response processBeginTransaction(TransactionInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processPrepareTransaction(TransactionInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processRollbackTransaction(TransactionInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processWireFormat(WireFormatInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processKeepAlive(KeepAliveInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processShutdown(ShutdownInfo info) throws Throwable {
0:         return null;
1:     }
0:     public Response processBrokerInfo(BrokerInfo info) throws Throwable {
0:         return null;
1:     }
1: 
0:     public Response processRecoverTransactions(TransactionInfo info) {
0:         return null;
1:     }
1: 
0:     public Response processForgetTransaction(TransactionInfo info) throws Throwable {
0:         return null;
1:     }
1: 
0:     public Response processEndTransaction(TransactionInfo info) throws Throwable {
0:         return null;
1:     }
1: 
0:     public Response processFlush(FlushCommand command) throws Throwable {
0:         return null;
1:     }
1: 
1:     public boolean isRestoreConsumers() {
1:         return restoreConsumers;
1:     }
1: 
1:     public void setRestoreConsumers(boolean restoreConsumers) {
1:         this.restoreConsumers = restoreConsumers;
1:     }
1: 
1:     public boolean isRestoreProducers() {
1:         return restoreProducers;
1:     }
1: 
1:     public void setRestoreProducers(boolean restoreProducers) {
1:         this.restoreProducers = restoreProducers;
1:     }
1: 
1:     public boolean isRestoreSessions() {
1:         return restoreSessions;
1:     }
1: 
1:     public void setRestoreSessions(boolean restoreSessions) {
1:         this.restoreSessions = restoreSessions;
1:     }
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:229c634
/////////////////////////////////////////////////////////////////////////
0:             if (cs != null) {
0:                 cs.removeTransactionState(info.getTransactionId());
1:             }
author:Gary Tully
-------------------------------------------------------------------------------
commit:705a877
/////////////////////////////////////////////////////////////////////////
1:             DestinationInfo info = (DestinationInfo)iter2.next();
1:             transport.oneway(info);
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("tempDest: " + info.getDestination());
1:             }
commit:5cf33b5
/////////////////////////////////////////////////////////////////////////
1:                 if (LOG.isTraceEnabled()) {
1:                     LOG.trace("removing tracked message: " + eldest.getKey());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("command: " + (msg.isMessage() ? ((Message) msg).getMessageId() : msg));
commit:0817f5d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final int MESSAGE_PULL_SIZE = 400;
/////////////////////////////////////////////////////////////////////////
1:                     currentCacheSize -= MESSAGE_PULL_SIZE;
/////////////////////////////////////////////////////////////////////////
0:                 currentCacheSize += MESSAGE_PULL_SIZE;
/////////////////////////////////////////////////////////////////////////
1:                 messageCache.put(send.getMessageId(), send);
commit:e8d45cb
/////////////////////////////////////////////////////////////////////////
1:                 } else if (eldest.getValue() instanceof MessagePull) {
commit:a1c19c5
/////////////////////////////////////////////////////////////////////////
0:                 } else if (eldest.getValue() instance of MessagePull) {
0:                     currentCacheSize -= 400;
commit:4c4f0d1
/////////////////////////////////////////////////////////////////////////
1:     public void transportInterrupted(ConnectionId connectionId) {
1:         ConnectionState connectionState = connectionStates.get(connectionId);
1:         if (connectionState != null) {
commit:966de0c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessagePull;
/////////////////////////////////////////////////////////////////////////
0:     private Map<Object,Command> messageCache = new LinkedHashMap<Object,Command>(){
1:         protected boolean removeEldestEntry(Map.Entry<Object,Command> eldest) {
1:                 if (eldest.getValue() instanceof Message) {
1:                     currentCacheSize -= ((Message)eldest.getValue()).getSize();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (command != null) {
1:             if (trackMessages && command.isMessage()) {
1:                 Message message = (Message) command;
1:                 if (message.getTransactionId()==null) {
1:                     currentCacheSize = currentCacheSize +  message.getSize();
1:                 }
1:             } else if (command instanceof MessagePull) {
0:                 // just needs to be a rough estimate of size, ~4 identifiers
0:                 currentCacheSize += 400;
/////////////////////////////////////////////////////////////////////////
0:         for (Command msg:messageCache.values()) {
0:                 LOG.debug("command: " + msg.getCommandId());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public Response processMessagePull(MessagePull pull) throws Exception {
1:         if (pull != null) {
1:             // leave a single instance in the cache
1:             final String id = pull.getDestination() + "::" + pull.getConsumerId();
0:             messageCache.put(id.intern(), pull);
1:         }
0:         return null;
1:     }
0: 
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
1:             connectionState.getInfo().setFailoverReconnect(true);
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("message: " + msg.getMessageId());
1:             }
commit:4eafccc
/////////////////////////////////////////////////////////////////////////
1: import javax.transaction.xa.XAResource;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.IntegerResponse;
/////////////////////////////////////////////////////////////////////////
1:     private class RemoveTransactionAction implements ResponseHandler {
1:         public void onResponse(Command response) {
0:     
0:     private class PrepareReadonlyTransactionAction extends RemoveTransactionAction {
0: 
1:         public PrepareReadonlyTransactionAction(TransactionInfo info) {
1:             super(info);
1:         }
0: 
1:         public void onResponse(Command command) {
0:             IntegerResponse response = (IntegerResponse) command;
0:             if (XAResource.XA_RDONLY == response.getResult()) {
0:                 // all done, no commit or rollback from TM
0:                 super.onResponse(command);
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:                         return new Tracked(new PrepareReadonlyTransactionAction(info));
commit:b836af8
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.TransactionRolledBackException;
0: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ExceptionResponse;
/////////////////////////////////////////////////////////////////////////
0:         Vector<TransactionInfo> toRollback = new Vector<TransactionInfo>();
1:             // rollback any completed transactions - no way to know if commit got there
1:             // or if reply went missing
1:             //
1:             if (!transactionState.getCommands().isEmpty()) {
1:                 Command lastCommand = transactionState.getCommands().get(transactionState.getCommands().size() - 1);
1:                             LOG.debug("rolling back potentially completed tx: " + transactionState.getId());
1:                         toRollback.add(transactionInfo);
/////////////////////////////////////////////////////////////////////////
1:         for (TransactionInfo command: toRollback) {
1:             ExceptionResponse response = new ExceptionResponse();
1:             response.setException(new TransactionRolledBackException("Transaction completion in doubt due to failover. Forcing rollback of " + command.getTransactionId()));
commit:8d3ca90
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map.Entry;
1: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
0:     protected final ConcurrentHashMap<ConnectionId, ConnectionState> connectionStates = new ConcurrentHashMap<ConnectionId, ConnectionState>(); 
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Restore the session's consumers but possibly in pull only (prefetch 0 state) till recovery complete
1:         final ConnectionState connectionState = connectionStates.get(sessionState.getInfo().getSessionId().getParentId());
1:         final boolean connectionInterruptionProcessingComplete = connectionState.isConnectionInterruptProcessingComplete();
0:         for (ConsumerState consumerState : sessionState.getConsumerStates()) {   
1:             ConsumerInfo infoToSend = consumerState.getInfo();
1:             if (!connectionInterruptionProcessingComplete && infoToSend.getPrefetchSize() > 0) {
1:                 infoToSend = consumerState.getInfo().copy();
1:                 connectionState.getRecoveringPullConsumers().put(infoToSend.getConsumerId(), consumerState.getInfo());
1:                 infoToSend.setPrefetchSize(0);
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("restore consumer: " + infoToSend.getConsumerId() + " in pull mode pending recovery, overriding prefetch: " + consumerState.getInfo().getPrefetchSize());
1:                 }
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("restore consumer: " + infoToSend.getConsumerId());
1:             }
1:             transport.oneway(infoToSend);
/////////////////////////////////////////////////////////////////////////
1:     public void connectionInterruptProcessingComplete(Transport transport, ConnectionId connectionId) {
1:         ConnectionState connectionState = connectionStates.get(connectionId);
1:         if (connectionState != null) {
1:             connectionState.setConnectionInterruptProcessingComplete(true);
1:             Map<ConsumerId, ConsumerInfo> stalledConsumers = connectionState.getRecoveringPullConsumers();
1:             for (Entry<ConsumerId, ConsumerInfo> entry: stalledConsumers.entrySet()) {
1:                 ConsumerControl control = new ConsumerControl();
1:                 control.setConsumerId(entry.getKey());
1:                 control.setPrefetch(entry.getValue().getPrefetchSize());
1:                 control.setDestination(entry.getValue().getDestination());
1:                 try {
1:                     if (LOG.isDebugEnabled()) {
1:                         LOG.debug("restored recovering consumer: " + control.getConsumerId() + " with: " + control.getPrefetch());
1:                     }
0:                     transport.oneway(control);  
1:                 } catch (Exception ex) {
1:                     if (LOG.isDebugEnabled()) {
1:                         LOG.debug("Failed to submit control for consumer: " + control.getConsumerId()
1:                                 + " with: " + control.getPrefetch(), ex);
1:                     }
1:                 }
1:             }
1:             stalledConsumers.clear();
1:         }
1:     }
0: 
0:     public void transportInterrupted() {
0:         for (ConnectionState connectionState : connectionStates.values()) {
1:             connectionState.setConnectionInterruptProcessingComplete(false);
1:         }
1:     }
commit:6efc268
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
/////////////////////////////////////////////////////////////////////////
0:         Vector<Command> toIgnore = new Vector<Command>();
0:             // ignore any empty (ack) transaction
0:             if (transactionState.getCommands().size() == 2) {
0:                 Command lastCommand = transactionState.getCommands().get(1);
1:                 if (lastCommand instanceof TransactionInfo) {
1:                     TransactionInfo transactionInfo = (TransactionInfo) lastCommand;
1:                     if (transactionInfo.getType() == TransactionInfo.COMMIT_ONE_PHASE) {
1:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("not replaying empty (ack) tx: " + transactionState.getId());
1:                         }
0:                         toIgnore.add(lastCommand);
1:                         continue;
1:                     }
1:                 }
1:             }
0:             
1:             // replay short lived producers that may have been involved in the transaction
/////////////////////////////////////////////////////////////////////////
0:         
0:         for (Command command: toIgnore) {
1:             // respond to the outstanding commit
0:             Response response = new Response();
1:             response.setCorrelationId(command.getCommandId());
1:             transport.getTransportListener().onCommand(response);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("restore consumer: " + consumerState.getInfo().getConsumerId());
1:             }
commit:8732f70
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("conn: " + connectionState.getInfo().getConnectionId());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("session: " + sessionState.getInfo().getSessionId());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("producer: " + producerState.getInfo().getProducerId());
1:             }
commit:b9e51d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private boolean trackTransactionProducers = true;
/////////////////////////////////////////////////////////////////////////
1:         for (TransactionState transactionState : connectionState.getTransactionStates()) {
0:             
1:             for (ProducerState producerState : transactionState.getProducerStates().values()) {
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("tx replay producer :" + producerState.getInfo());
1:                 }
1:                 transport.oneway(producerState.getInfo());
1:             }
0:             
1:             for (Command command : transactionState.getCommands()) {
0:             
1:             for (ProducerState producerState : transactionState.getProducerStates().values()) {
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("tx remove replayed producer :" + producerState.getInfo());
1:                 }
1:                 transport.oneway(producerState.getInfo().createRemoveCommand());
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 ProducerId producerId = send.getProducerId();
1:                 ConnectionId connectionId = producerId.getParentId().getParentId();
0:                             
1:                             if (trackTransactionProducers) {
1:                                 // for jmstemplate, track the producer in case it is closed before commit
1:                                 // and needs to be replayed
1:                                 SessionState ss = cs.getSessionState(producerId.getParentId());
1:                                 ProducerState producerState = ss.getProducerState(producerId);
0:                                 producerState.setTransactionState(transactionState);            
1:                             }
/////////////////////////////////////////////////////////////////////////
0:     
1:     public boolean isTrackTransactionProducers() {
1:         return this.trackTransactionProducers;
1:     }
1:     public void setTrackTransactionProducers(boolean trackTransactionProducers) {
1:         this.trackTransactionProducers = trackTransactionProducers;
1:     }
0:     
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(ConnectionStateTracker.class);
/////////////////////////////////////////////////////////////////////////
1:             if (LOG.isDebugEnabled()) {
1:                 LOG.debug("tx: " + transactionState.getId());
1:             }
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("tx replay: " + command);
1:                 }
/////////////////////////////////////////////////////////////////////////
commit:84dbbc7
/////////////////////////////////////////////////////////////////////////
1:     public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) {
/////////////////////////////////////////////////////////////////////////
1:     public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) {
/////////////////////////////////////////////////////////////////////////
1:     public Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws Exception {
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ConnectionStateTracker.class);
commit:53ea4ca
/////////////////////////////////////////////////////////////////////////
1:         for (Iterator iter2 = connectionState.getTempDestinations().iterator(); iter2.hasNext();) {
author:Robert Davies
-------------------------------------------------------------------------------
commit:4118d02
/////////////////////////////////////////////////////////////////////////
1:                     TransactionState state = cs.getTransactionState(info.getTransactionId());
1:                     state.addCommand(info);
commit:c42c5ff
/////////////////////////////////////////////////////////////////////////
1:             if (result) {
0:                 currentCacheSize -= eldest.getValue().getSize();
1:             }
/////////////////////////////////////////////////////////////////////////
0:                 currentCacheSize = currentCacheSize +  message.getSize();
commit:e225ba6
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedHashMap;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessageId;
/////////////////////////////////////////////////////////////////////////
0:      
1:     private boolean trackMessages = true;
1:     private int maxCacheSize = 128 * 1024;
0:     private int currentCacheSize;
0:     private Map<MessageId,Message> messageCache = new LinkedHashMap<MessageId,Message>(){
0:         protected boolean removeEldestEntry(Map.Entry<MessageId,Message> eldest) {
1:             boolean result = currentCacheSize > maxCacheSize;
0:             currentCacheSize -= eldest.getValue().getSize();
1:             return result;
1:         }
1:     };
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void trackBack(Command command) {
0:         if (trackMessages && command != null && command.isMessage()) {
0:             Message message = (Message) command;
0:             if (message.getTransactionId()==null) {
0:                 currentCacheSize+=message.getSize();
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:         //now flush messages
0:         for (Message msg:messageCache.values()) {
1:             transport.oneway(msg);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (send != null) {
1:             if (trackTransactions && send.getTransactionId() != null) {
0:                 ConnectionId connectionId = send.getProducerId().getParentId().getParentId();
0:                 if (connectionId != null) {
0:                     ConnectionState cs = connectionStates.get(connectionId);
0:                     if (cs != null) {
0:                         TransactionState transactionState = cs.getTransactionState(send.getTransactionId());
0:                         if (transactionState != null) {
0:                             transactionState.addCommand(send);
1:                         }
0:                 return TRACKED_RESPONSE_MARKER;
1:             }else if (trackMessages) {
0:                 messageCache.put(send.getMessageId(), send.copy());
/////////////////////////////////////////////////////////////////////////
1:     public boolean isTrackMessages() {
1:         return trackMessages;
1:     }
0: 
1:     public void setTrackMessages(boolean trackMessages) {
1:         this.trackMessages = trackMessages;
1:     }
0: 
1:     public int getMaxCacheSize() {
1:         return maxCacheSize;
1:     }
0: 
1:     public void setMaxCacheSize(int maxCacheSize) {
1:         this.maxCacheSize = maxCacheSize;
1:     }
0: 
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddDestination(DestinationInfo info){
0:         if(info!=null){
0:             ConnectionState cs=(ConnectionState)connectionStates.get(info.getConnectionId());
0:             if(cs!=null&&info.getDestination().isTemporary()){
0:                 cs.addTempDestination(info);
1:             }
0:     public Response processRemoveDestination(DestinationInfo info){
0:         if(info!=null){
0:             ConnectionState cs=(ConnectionState)connectionStates.get(info.getConnectionId());
0:             if(cs!=null&&info.getDestination().isTemporary()){
0:                 cs.removeTempDestination(info.getDestination());
1:             }
commit:e6a418b
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddDestination(DestinationInfo info)  {
0:         if( cs != null && info != null && info.getDestination().isTemporary() ) {
0:     public Response processRemoveDestination(DestinationInfo info)  {
0:         if( cs != null && info != null && info.getDestination().isTemporary() ) {
0:     public Response processAddProducer(ProducerInfo info){
0:         if(info!=null&&info.getProducerId()!=null){
0:             SessionId sessionId=info.getProducerId().getParentId();
0:             if(sessionId!=null){
0:                 ConnectionId connectionId=sessionId.getParentId();
0:                 if(connectionId!=null){
0:                     ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                     if(cs!=null){
0:                         SessionState ss=cs.getSessionState(sessionId);
0:                         if(ss!=null){
0:                             ss.addProducer(info);
1:                         }
1:                     }
1:                 }
1:             }
1:         }
0:     public Response processRemoveProducer(ProducerId id){
0:         if(id!=null){
0:             SessionId sessionId=id.getParentId();
0:             if(sessionId!=null){
0:                 ConnectionId connectionId=sessionId.getParentId();
0:                 if(connectionId!=null){
0:                     ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                     if(cs!=null){
0:                         SessionState ss=cs.getSessionState(sessionId);
0:                         if(ss!=null){
0:                             ss.removeProducer(id);
1:                         }
1:                     }
1:                 }
1:             }
1:         }
0:     public Response processAddConsumer(ConsumerInfo info){
0:         if(info!=null){
0:             SessionId sessionId=info.getConsumerId().getParentId();
0:             if(sessionId!=null){
0:                 ConnectionId connectionId=sessionId.getParentId();
0:                 if(connectionId!=null){
0:                     ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                     if(cs!=null){
0:                         SessionState ss=cs.getSessionState(sessionId);
0:                         if(ss!=null){
0:                             ss.addConsumer(info);
1:                         }
1:                     }
1:                 }
1:             }
1:         }
0:     public Response processRemoveConsumer(ConsumerId id){
0:         if(id!=null){
0:             SessionId sessionId=id.getParentId();
0:             if(sessionId!=null){
0:                 ConnectionId connectionId=sessionId.getParentId();
0:                 if(connectionId!=null){
0:                     ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                     if(cs!=null){
0:                         SessionState ss=cs.getSessionState(sessionId);
0:                         if(ss!=null){
0:                             ss.removeConsumer(id);
1:                         }
1:                     }
1:                 }
1:             }
1:         }
0:     public Response processAddSession(SessionInfo info){
0:         if(info!=null){
0:             ConnectionId connectionId=info.getSessionId().getParentId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     cs.addSession(info);
1:                 }
1:             }
1:         }
0:     public Response processRemoveSession(SessionId id){
0:         if(id!=null){
0:             ConnectionId connectionId=id.getParentId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     cs.removeSession(id);
1:                 }
1:             }
1:         }
0:     public Response processAddConnection(ConnectionInfo info){
1:         if (info != null) {
0:         connectionStates.put(info.getConnectionId(), new ConnectionState(info)); 
1:         }
0:         if (id != null) {
1:         }
0:     
0:     public Response processMessage(Message send) throws Exception{
0:         if(trackTransactions&&send!=null&&send.getTransactionId()!=null){
0:             ConnectionId connectionId=send.getProducerId().getParentId().getParentId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     TransactionState transactionState=cs.getTransactionState(send.getTransactionId());
0:                     if(transactionState!=null){
0:                         transactionState.addCommand(send);
1:                     }
1:                 }
1:             }
1:         }
0:         return null;
0:     
0:     public Response processMessageAck(MessageAck ack){
0:         if(trackTransactions&&ack!=null&&ack.getTransactionId()!=null){
0:             ConnectionId connectionId=ack.getConsumerId().getParentId().getParentId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     TransactionState transactionState=cs.getTransactionState(ack.getTransactionId());
0:                     if(transactionState!=null){
0:                         transactionState.addCommand(ack);
1:                     }
1:                 }
1:             }
1:         }
0:         return null;
0:     public Response processBeginTransaction(TransactionInfo info){
0:         if(trackTransactions&&info!=null && info.getTransactionId() != null){
0:             ConnectionId connectionId=info.getConnectionId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     cs.addTransactionState(info.getTransactionId());
1:                 }
1:             }
0:             return TRACKED_RESPONSE_MARKER;
1:         }
0:         return null;
0:     
0:     public Response processPrepareTransaction(TransactionInfo info) throws Exception{
0:         if(trackTransactions&&info!=null){
0:             ConnectionId connectionId=info.getConnectionId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     TransactionState transactionState=cs.getTransactionState(info.getTransactionId());
0:                     if(transactionState!=null){
0:                         transactionState.addCommand(info);
1:                     }
1:                 }
1:             }
0:             return TRACKED_RESPONSE_MARKER;
1:         }
0:         return null;
0:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception{
0:         if(trackTransactions&&info!=null){
0:             ConnectionId connectionId=info.getConnectionId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     TransactionState transactionState=cs.getTransactionState(info.getTransactionId());
0:                     if(transactionState!=null){
0:                         transactionState.addCommand(info);
0:                         return new Tracked(new RemoveTransactionAction(info));
1:                     }
1:                 }
1:             }
1:         }
0:         return null;
0:     
0:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception{
0:         if(trackTransactions&&info!=null){
0:             ConnectionId connectionId=info.getConnectionId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     TransactionState transactionState=cs.getTransactionState(info.getTransactionId());
0:                     if(transactionState!=null){
0:                         transactionState.addCommand(info);
0:                         return new Tracked(new RemoveTransactionAction(info));
1:                     }
1:                 }
1:             }
1:         }
0:         return null;
0:     public Response processRollbackTransaction(TransactionInfo info) throws Exception{
0:         if(trackTransactions&&info!=null){
0:             ConnectionId connectionId=info.getConnectionId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     TransactionState transactionState=cs.getTransactionState(info.getTransactionId());
0:                     if(transactionState!=null){
0:                         transactionState.addCommand(info);
0:                         return new Tracked(new RemoveTransactionAction(info));
1:                     }
1:                 }
1:             }
1:         }
0:         return null;
0:     public Response processEndTransaction(TransactionInfo info) throws Exception{
0:         if(trackTransactions&&info!=null){
0:             ConnectionId connectionId=info.getConnectionId();
0:             if(connectionId!=null){
0:                 ConnectionState cs=(ConnectionState)connectionStates.get(connectionId);
0:                 if(cs!=null){
0:                     TransactionState transactionState=cs.getTransactionState(info.getTransactionId());
0:                     if(transactionState!=null){
0:                         transactionState.addCommand(info);
1:                     }
1:                 }
1:             }
0:             return TRACKED_RESPONSE_MARKER;
1:         }
0:         return null;
commit:4098942
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessageDispatchNotification;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Throwable{
0:         return null;
0:     }
author:Adrian T. Co
-------------------------------------------------------------------------------
commit:04c3b07
/////////////////////////////////////////////////////////////////////////
0: 	private final static Tracked TRACKED_RESPONSE_MARKER = new Tracked(null);
0: 	private boolean trackTransactions = false;
0:     private boolean restoreConsumers=true;
0:     private boolean restoreTransaction=true;
0:         
0:     private class RemoveTransactionAction implements Runnable {
0: 		private final TransactionInfo info;
0: 		public RemoveTransactionAction(TransactionInfo info) {
0: 			this.info = info;
0: 		}
0: 		public void run() {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState)connectionStates.get(connectionId);
0: 	        if( cs != null ) {
0: 	        	cs.removeTransactionState(info.getTransactionId());
0: 	        }
0: 		}
0:     }
0: 
0:     /**
0:      * 
0:      * 
0:      * @param command
0:      * @return null if the command is not state tracked.
0:      * @throws IOException
0:      */
0:     public Tracked track(Command command) throws IOException {
0:         	return (Tracked) command.visit(this);
/////////////////////////////////////////////////////////////////////////
0:             
0:             if( restoreTransaction )
0:             	restoreTransactions(transport, connectionState);
0:     private void restoreTransactions(Transport transport, ConnectionState connectionState) throws IOException {
0:     	for (Iterator iter = connectionState.getTransactionStates().iterator(); iter.hasNext();) {
0: 			TransactionState transactionState = (TransactionState) iter.next();
0: 			for (Iterator iterator = transactionState.getCommands().iterator(); iterator.hasNext();) {
0: 				Command command = (Command) iterator.next();
0: 	            transport.oneway(command);
0: 			}
0: 		}
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
0:     	if( trackTransactions && send.getTransactionId() != null ) {
0:             ConnectionId connectionId = send.getProducerId().getParentId().getParentId();
0:             ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:             TransactionState transactionState = cs.getTransactionState(send.getTransactionId());
0:             transactionState.addCommand(send);    		
0:             return TRACKED_RESPONSE_MARKER;
0:     	}
0:     	return null;
0:     }    
0:     	if( trackTransactions && ack.getTransactionId() != null ) {
0:             ConnectionId connectionId = ack.getConsumerId().getParentId().getParentId();
0:             ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0:             TransactionState transactionState = cs.getTransactionState(ack.getTransactionId());
0:             transactionState.addCommand(ack);    		
0:             return TRACKED_RESPONSE_MARKER;
0:     	}
0:     	return null;
0:     
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        cs.addTransactionState(info.getTransactionId());
0: 	        return TRACKED_RESPONSE_MARKER;
0:     	}
0:     	return null;
0:     }    
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        transactionState.addCommand(info);
0: 	        return TRACKED_RESPONSE_MARKER;
0:     	} 
0:     	return null;
0:     
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        if( transactionState !=null ) {
0: 		        transactionState.addCommand(info);
0: 		        return new Tracked(new RemoveTransactionAction(info));
0: 	        }
0:     	}
0:     	return null;
0:     }        
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        if( transactionState !=null ) {
0: 		        transactionState.addCommand(info);
0: 		        return new Tracked(new RemoveTransactionAction(info));
0: 	        }
0:     	}
0:     	return null;
0:     
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        if( transactionState !=null ) {
0: 		        transactionState.addCommand(info);
0: 		        return new Tracked(new RemoveTransactionAction(info));
0: 	        }
0:     	}
0:     	return null;
0:     }
0:     
0:     public Response processEndTransaction(TransactionInfo info) throws Exception {
0:     	if( trackTransactions ) {
0: 	        ConnectionId connectionId = info.getConnectionId();
0: 	        ConnectionState cs = (ConnectionState) connectionStates.get(connectionId);
0: 	        TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0: 	        transactionState.addCommand(info);
0: 	        return TRACKED_RESPONSE_MARKER;
0:     	}
0:     	return null;
0:     }
0:     
0:     public Response processRecoverTransactions(TransactionInfo info) {
0:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
0:         return null;
0:     }
0: 
0:     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public boolean isTrackTransactions() {
0: 		return trackTransactions;
0: 	}
0: 
0: 	public void setTrackTransactions(boolean trackTransactions) {
0: 		this.trackTransactions = trackTransactions;
0: 	}
0: 
0: 	public boolean isRestoreTransaction() {
0: 		return restoreTransaction;
0: 	}
0: 
0: 	public void setRestoreTransaction(boolean restoreTransaction) {
0: 		this.restoreTransaction = restoreTransaction;
0: 	}
author:James Strachan
-------------------------------------------------------------------------------
commit:9d671b7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessagePull;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Response processMessagePull(MessagePull pull) throws Exception {
0:         return null;
0:     }
/////////////////////////////////////////////////////////////////////////
0:         
============================================================================