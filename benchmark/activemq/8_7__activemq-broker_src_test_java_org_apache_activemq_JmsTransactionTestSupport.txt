1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:230a86c:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
2:230a86c:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
1:230a86c: 
1:013f372: import java.net.URI;
1:013f372: import java.net.URISyntaxException;
1:d29ca2a: import java.util.ArrayList;
1:d29ca2a: import java.util.List;
1:933eb2f: 
1:d29ca2a: import javax.jms.Connection;
1:d29ca2a: import javax.jms.ConnectionFactory;
1:d29ca2a: import javax.jms.Destination;
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.Message;
1:d29ca2a: import javax.jms.MessageConsumer;
1:d29ca2a: import javax.jms.MessageListener;
1:d29ca2a: import javax.jms.MessageProducer;
1:d9b9427: import javax.jms.ObjectMessage;
1:d29ca2a: import javax.jms.Session;
1:d29ca2a: import javax.jms.TextMessage;
1:933eb2f: 
1:013f372: import org.apache.activemq.broker.BrokerFactory;
1:013f372: import org.apache.activemq.broker.BrokerService;
1:d29ca2a: import org.apache.activemq.test.JmsResourceProvider;
1:d29ca2a: import org.apache.activemq.test.TestSupport;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:013f372: 
1:d29ca2a: /**
1:4a2af3a:  *
1:d29ca2a:  */
1:fc00993: public abstract class JmsTransactionTestSupport extends TestSupport implements MessageListener {
1:013f372: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JmsTransactionTestSupport.class);
1:fc00993:     private static final int MESSAGE_COUNT = 5;
1:fc00993:     private static final String MESSAGE_TEXT = "message";
1:d29ca2a: 
1:d29ca2a:     protected Connection connection;
1:d29ca2a:     protected Session session;
1:d29ca2a:     protected MessageConsumer consumer;
1:d29ca2a:     protected MessageProducer producer;
1:d29ca2a:     protected JmsResourceProvider resourceProvider;
1:d29ca2a:     protected Destination destination;
1:0e6a7e4:     protected int batchCount = 10;
1:0e6a7e4:     protected int batchSize = 20;
1:0e6a7e4:     protected BrokerService broker;
1:230a86c: 
1:933eb2f:     // for message listener test
1:4a2af3a:     private final List<Message> unackMessages = new ArrayList<Message>(MESSAGE_COUNT);
1:4a2af3a:     private final List<Message> ackMessages = new ArrayList<Message>(MESSAGE_COUNT);
1:933eb2f:     private boolean resendPhase;
1:933eb2f: 
1:d29ca2a:     public JmsTransactionTestSupport() {
1:d29ca2a:         super();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public JmsTransactionTestSupport(String name) {
1:d29ca2a:         super(name);
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     /*
1:230a86c:      * (non-Javadoc)
1:4a2af3a:      *
1:d29ca2a:      * @see junit.framework.TestCase#setUp()
1:d29ca2a:      */
1:4a2af3a:     @Override
1:d29ca2a:     protected void setUp() throws Exception {
1:013f372:         broker = createBroker();
1:013f372:         broker.start();
1:358b522:         broker.waitUntilStarted();
1:230a86c: 
1:d29ca2a:         resourceProvider = getJmsResourceProvider();
1:d29ca2a:         topic = resourceProvider.isTopic();
1:d29ca2a:         // We will be using transacted sessions.
1:1f00a39:         setSessionTransacted();
1:1f00a39:         connectionFactory = newConnectionFactory();
1:d29ca2a:         reconnect();
1:d29ca2a:     }
1:013f372: 
1:1f00a39:     protected void setSessionTransacted() {
1:d29ca2a:         resourceProvider.setTransacted(true);
1:d29ca2a:     }
1:d29ca2a: 
1:1f00a39:     protected ConnectionFactory newConnectionFactory() throws Exception {
1:1f00a39:         return resourceProvider.createConnectionFactory();
1:d29ca2a:     }
1:d29ca2a: 
1:1f00a39:     protected void beginTx() throws Exception {
1:1f00a39:         //no-op for local tx
1:d29ca2a:     }
1:d29ca2a: 
1:1f00a39:     protected void commitTx() throws Exception {
23:d29ca2a:         session.commit();
1:d29ca2a:     }
1:d29ca2a: 
1:1f00a39:     protected void rollbackTx() throws Exception {
4:d29ca2a:         session.rollback();
1:1f00a39:     }
1:d29ca2a: 
1:013f372:     /**
1:013f372:      */
1:013f372:     protected BrokerService createBroker() throws Exception, URISyntaxException {
1:013f372:         return BrokerFactory.createBroker(new URI("broker://()/localhost?persistent=false"));
1:013f372:     }
1:013f372: 
1:230a86c:     /*
1:230a86c:      * (non-Javadoc)
1:4a2af3a:      *
1:d29ca2a:      * @see junit.framework.TestCase#tearDown()
1:d29ca2a:      */
1:4a2af3a:     @Override
1:d29ca2a:     protected void tearDown() throws Exception {
1:230a86c:         LOG.info("Closing down connection");
1:d29ca2a: 
1:4a2af3a:         try {
1:4a2af3a:             session.close();
1:4a2af3a:             session = null;
1:29b833f:         } catch (Exception e) {
1:29b833f:             LOG.info("Caught exception while closing resources.");
1:29b833f:         }
1:29b833f:         try {
1:4a2af3a:             connection.close();
1:4a2af3a:             connection = null;
1:4a2af3a:         } catch (Exception e) {
1:4a2af3a:             LOG.info("Caught exception while closing resources.");
1:4a2af3a:         }
1:4a2af3a: 
1:4a2af3a:         try {
1:4a2af3a:             broker.stop();
1:4a2af3a:             broker.waitUntilStopped();
1:4a2af3a:             broker = null;
1:4a2af3a:         } catch (Exception e) {
1:4a2af3a:             LOG.info("Caught exception while shutting down the Broker", e);
1:4a2af3a:         }
1:230a86c: 
1:230a86c:         LOG.info("Connection closed.");
1:1f00a39:     }
1:b022a9d: 
1:d29ca2a:     protected abstract JmsResourceProvider getJmsResourceProvider();
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sends a batch of messages and validates that the messages are received.
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     public void testSendReceiveTransactedBatches() throws Exception {
1:230a86c: 
1:d29ca2a:         TextMessage message = session.createTextMessage("Batch Message");
1:d29ca2a:         for (int j = 0; j < batchCount; j++) {
1:230a86c:             LOG.info("Producing bacth " + j + " of " + batchSize + " messages");
1:d29ca2a: 
1:1f00a39:             beginTx();
1:d29ca2a:             for (int i = 0; i < batchSize; i++) {
1:d29ca2a:                 producer.send(message);
1:1f00a39:             }
1:4118d02:             messageSent();
1:1f00a39:             commitTx();
1:230a86c:             LOG.info("Consuming bacth " + j + " of " + batchSize + " messages");
1:d29ca2a: 
1:1f00a39:             beginTx();
1:d29ca2a:             for (int i = 0; i < batchSize; i++) {
1:230a86c:                 message = (TextMessage)consumer.receive(1000 * 5);
1:d29ca2a:                 assertNotNull("Received only " + i + " messages in batch " + j, message);
1:d29ca2a:                 assertEquals("Batch Message", message.getText());
1:d29ca2a:             }
1:d29ca2a: 
1:1f00a39:             commitTx();
1:1f00a39:         }
1:1f00a39:     }
1:d29ca2a: 
1:4118d02:     protected void messageSent() throws Exception {
1:4118d02:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sends a batch of messages and validates that the rollbacked message was
1:230a86c:      * not consumed.
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     public void testSendRollback() throws Exception {
1:230a86c:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:d29ca2a: 
1:230a86c:         // sends a message
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(outbound[0]);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         // sends a message that gets rollbacked
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(session.createTextMessage("I'm going to get rolled back."));
1:1f00a39:         rollbackTx();
1:230a86c: 
1:230a86c:         // sends a message
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(outbound[1]);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         // receives the first message
1:1f00a39:         beginTx();
1:933eb2f:         ArrayList<Message> messages = new ArrayList<Message>();
1:230a86c:         LOG.info("About to consume message 1");
1:d29ca2a:         Message message = consumer.receive(1000);
1:d29ca2a:         messages.add(message);
1:230a86c:         LOG.info("Received: " + message);
1:d29ca2a: 
1:230a86c:         // receives the second message
1:230a86c:         LOG.info("About to consume message 2");
1:d29ca2a:         message = consumer.receive(4000);
1:d29ca2a:         messages.add(message);
1:230a86c:         LOG.info("Received: " + message);
1:d29ca2a: 
1:230a86c:         // validates that the rollbacked was not consumed
1:1f00a39:         commitTx();
1:d29ca2a:         Message inbound[] = new Message[messages.size()];
1:d29ca2a:         messages.toArray(inbound);
1:d29ca2a:         assertTextMessagesEqual("Rollback did not work.", outbound, inbound);
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:1f00a39:      * spec section 3.6 acking a message with automation acks has no effect.
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:1f00a39:     public void testAckMessageInTx() throws Exception {
1:1f00a39:         Message[] outbound = new Message[] {session.createTextMessage("First Message")};
1:d29ca2a: 
1:1f00a39:         // sends a message
1:1f00a39:         beginTx();
1:1f00a39:         producer.send(outbound[0]);
1:1f00a39:         outbound[0].acknowledge();
1:1f00a39:         commitTx();
1:1f00a39:         outbound[0].acknowledge();
1:d29ca2a: 
1:1f00a39:         // receives the first message
1:1f00a39:         beginTx();
1:933eb2f:         ArrayList<Message> messages = new ArrayList<Message>();
1:1f00a39:         LOG.info("About to consume message 1");
1:1f00a39:         Message message = consumer.receive(1000);
1:1f00a39:         messages.add(message);
1:1f00a39:         LOG.info("Received: " + message);
1:d29ca2a: 
1:1f00a39:         // validates that the rollbacked was not consumed
1:1f00a39:         commitTx();
1:1f00a39:         Message inbound[] = new Message[messages.size()];
1:1f00a39:         messages.toArray(inbound);
1:1f00a39:         assertTextMessagesEqual("Message not delivered.", outbound, inbound);
1:1f00a39:     }
1:d29ca2a: 
1:1f00a39:     /**
1:230a86c:      * Sends a batch of messages and validates that the message sent before
1:230a86c:      * session close is not consumed.
1:4a2af3a:      *
1:1f00a39:      * This test only works with local transactions, not xa.
1:1f00a39:      * @throws Exception
1:1f00a39:      */
1:d29ca2a:     public void testSendSessionClose() throws Exception {
1:230a86c:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:230a86c: 
1:230a86c:         // sends a message
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(outbound[0]);
1:1f00a39:         commitTx();
1:230a86c: 
1:230a86c:         // sends a message that gets rollbacked
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(session.createTextMessage("I'm going to get rolled back."));
1:d29ca2a:         consumer.close();
1:230a86c: 
1:05ea5d4:         reconnectSession();
1:230a86c: 
1:230a86c:         // sends a message
1:d29ca2a:         producer.send(outbound[1]);
1:1f00a39:         commitTx();
1:230a86c: 
1:230a86c:         // receives the first message
1:933eb2f:         ArrayList<Message> messages = new ArrayList<Message>();
1:230a86c:         LOG.info("About to consume message 1");
1:1f00a39:         beginTx();
1:d29ca2a:         Message message = consumer.receive(1000);
1:d29ca2a:         messages.add(message);
1:230a86c:         LOG.info("Received: " + message);
1:230a86c: 
1:230a86c:         // receives the second message
1:230a86c:         LOG.info("About to consume message 2");
1:d29ca2a:         message = consumer.receive(4000);
1:d29ca2a:         messages.add(message);
1:230a86c:         LOG.info("Received: " + message);
1:230a86c: 
1:230a86c:         // validates that the rollbacked was not consumed
1:1f00a39:         commitTx();
1:d29ca2a:         Message inbound[] = new Message[messages.size()];
1:d29ca2a:         messages.toArray(inbound);
1:d29ca2a:         assertTextMessagesEqual("Rollback did not work.", outbound, inbound);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sends a batch of messages and validates that the message sent before
1:230a86c:      * session close is not consumed.
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:05ea5d4:     public void testSendSessionAndConnectionClose() throws Exception {
1:230a86c:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:d29ca2a: 
1:230a86c:         // sends a message
1:1f00a39:         beginTx();
1:05ea5d4:         producer.send(outbound[0]);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         // sends a message that gets rollbacked
1:1f00a39:         beginTx();
1:05ea5d4:         producer.send(session.createTextMessage("I'm going to get rolled back."));
1:05ea5d4:         consumer.close();
1:d29ca2a:         session.close();
1:d29ca2a: 
1:d29ca2a:         reconnect();
1:d29ca2a: 
1:230a86c:         // sends a message
1:1f00a39:         beginTx();
1:05ea5d4:         producer.send(outbound[1]);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         // receives the first message
1:1f00a39:         ArrayList<Message> messages = new ArrayList<Message>();
1:230a86c:         LOG.info("About to consume message 1");
1:1f00a39:         beginTx();
1:05ea5d4:         Message message = consumer.receive(1000);
1:05ea5d4:         messages.add(message);
1:230a86c:         LOG.info("Received: " + message);
1:d29ca2a: 
1:230a86c:         // receives the second message
1:230a86c:         LOG.info("About to consume message 2");
1:05ea5d4:         message = consumer.receive(4000);
1:05ea5d4:         messages.add(message);
1:230a86c:         LOG.info("Received: " + message);
1:d29ca2a: 
1:230a86c:         // validates that the rollbacked was not consumed
1:1f00a39:         commitTx();
1:05ea5d4:         Message inbound[] = new Message[messages.size()];
1:05ea5d4:         messages.toArray(inbound);
1:05ea5d4:         assertTextMessagesEqual("Rollback did not work.", outbound, inbound);
1:05ea5d4:     }
1:d29ca2a: 
1:05ea5d4:     /**
1:230a86c:      * Sends a batch of messages and validates that the rollbacked message was
1:230a86c:      * redelivered.
1:4a2af3a:      *
1:05ea5d4:      * @throws Exception
1:05ea5d4:      */
1:d29ca2a:     public void testReceiveRollback() throws Exception {
1:230a86c:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:d29ca2a: 
1:fa8b889:         // lets consume any outstanding messages from prev test runs
1:1f00a39:         beginTx();
1:d29ca2a:             while (consumer.receive(1000) != null) {
1:d29ca2a:         }
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         // sent both messages
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(outbound[0]);
1:d29ca2a:         producer.send(outbound[1]);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         LOG.info("Sent 0: " + outbound[0]);
1:230a86c:         LOG.info("Sent 1: " + outbound[1]);
1:d29ca2a: 
1:933eb2f:         ArrayList<Message> messages = new ArrayList<Message>();
1:1f00a39:         beginTx();
1:d29ca2a:         Message message = consumer.receive(1000);
1:d29ca2a:         messages.add(message);
1:d29ca2a:         assertEquals(outbound[0], message);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:d29ca2a:         // rollback so we can get that last message again.
1:1f00a39:         beginTx();
1:d29ca2a:         message = consumer.receive(1000);
1:d29ca2a:         assertNotNull(message);
1:d29ca2a:         assertEquals(outbound[1], message);
1:1f00a39:         rollbackTx();
1:d29ca2a: 
1:fa8b889:         // Consume again.. the prev message should
1:d29ca2a:         // get redelivered.
1:1f00a39:         beginTx();
1:d29ca2a:         message = consumer.receive(5000);
1:d29ca2a:         assertNotNull("Should have re-received the message again!", message);
1:d29ca2a:         messages.add(message);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:d29ca2a:         Message inbound[] = new Message[messages.size()];
1:d29ca2a:         messages.toArray(inbound);
1:d29ca2a:         assertTextMessagesEqual("Rollback did not work", outbound, inbound);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sends a batch of messages and validates that the rollbacked message was
1:230a86c:      * redelivered.
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     public void testReceiveTwoThenRollback() throws Exception {
1:230a86c:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:d29ca2a: 
1:fa8b889:         // lets consume any outstanding messages from prev test runs
1:1f00a39:         beginTx();
1:d29ca2a:         while (consumer.receive(1000) != null) {
1:d29ca2a:         }
1:1f00a39:         commitTx();
1:d29ca2a: 
1:d29ca2a:         //
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(outbound[0]);
1:d29ca2a:         producer.send(outbound[1]);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         LOG.info("Sent 0: " + outbound[0]);
1:230a86c:         LOG.info("Sent 1: " + outbound[1]);
1:d29ca2a: 
1:933eb2f:         ArrayList<Message> messages = new ArrayList<Message>();
1:1f00a39:         beginTx();
1:d29ca2a:         Message message = consumer.receive(1000);
1:d29ca2a:         assertEquals(outbound[0], message);
1:d29ca2a: 
1:d29ca2a:         message = consumer.receive(1000);
1:d29ca2a:         assertNotNull(message);
1:d29ca2a:         assertEquals(outbound[1], message);
1:1f00a39:         rollbackTx();
1:d29ca2a: 
1:fa8b889:         // Consume again.. the prev message should
1:d29ca2a:         // get redelivered.
1:1f00a39:         beginTx();
1:d29ca2a:         message = consumer.receive(5000);
1:d29ca2a:         assertNotNull("Should have re-received the first message again!", message);
1:d29ca2a:         messages.add(message);
1:d29ca2a:         assertEquals(outbound[0], message);
1:d29ca2a:         message = consumer.receive(5000);
1:d29ca2a:         assertNotNull("Should have re-received the second message again!", message);
1:d29ca2a:         messages.add(message);
1:d29ca2a:         assertEquals(outbound[1], message);
1:230a86c: 
1:230a86c:         assertNull(consumer.receiveNoWait());
1:1f00a39:         commitTx();
1:d29ca2a: 
1:d29ca2a:         Message inbound[] = new Message[messages.size()];
1:d29ca2a:         messages.toArray(inbound);
1:d29ca2a:         assertTextMessagesEqual("Rollback did not work", outbound, inbound);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sends a batch of messages and validates that the rollbacked message was
1:230a86c:      * not consumed.
1:b0c2a40:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     public void testSendReceiveWithPrefetchOne() throws Exception {
1:d29ca2a:         setPrefetchToOne();
1:230a86c:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message"), session.createTextMessage("Third Message"),
1:230a86c:                                             session.createTextMessage("Fourth Message")};
1:d29ca2a: 
1:1f00a39:         beginTx();
1:d29ca2a:         for (int i = 0; i < outbound.length; i++) {
1:230a86c:             // sends a message
1:d29ca2a:             producer.send(outbound[i]);
1:d29ca2a:         }
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         // receives the first message
1:1f00a39:         beginTx();
1:d29ca2a:         for (int i = 0; i < outbound.length; i++) {
1:230a86c:             LOG.info("About to consume message 1");
1:d29ca2a:             Message message = consumer.receive(1000);
1:d29ca2a:             assertNotNull(message);
1:230a86c:             LOG.info("Received: " + message);
1:d29ca2a:         }
1:d29ca2a: 
1:230a86c:         // validates that the rollbacked was not consumed
1:1f00a39:         commitTx();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Perform the test that validates if the rollbacked message was redelivered
1:230a86c:      * multiple times.
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     public void testReceiveTwoThenRollbackManyTimes() throws Exception {
1:fc00993:         for (int i = 0; i < 5; i++) {
1:d29ca2a:             testReceiveTwoThenRollback();
1:fc00993:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sends a batch of messages and validates that the rollbacked message was
1:230a86c:      * not consumed. This test differs by setting the message prefetch to one.
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     public void testSendRollbackWithPrefetchOfOne() throws Exception {
1:d29ca2a:         setPrefetchToOne();
1:d29ca2a:         testSendRollback();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Sends a batch of messages and and validates that the rollbacked message
1:230a86c:      * was redelivered. This test differs by setting the message prefetch to
1:230a86c:      * one.
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception
1:d29ca2a:      */
1:d29ca2a:     public void testReceiveRollbackWithPrefetchOfOne() throws Exception {
1:d29ca2a:         setPrefetchToOne();
1:d29ca2a:         testReceiveRollback();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Tests if the messages can still be received if the consumer is closed
1:230a86c:      * (session is not closed).
1:4a2af3a:      *
1:d29ca2a:      * @throws Exception see http://jira.codehaus.org/browse/AMQ-143
1:d29ca2a:      */
1:d29ca2a:     public void testCloseConsumerBeforeCommit() throws Exception {
1:230a86c:         TextMessage[] outbound = new TextMessage[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:d29ca2a: 
1:fa8b889:         // lets consume any outstanding messages from prev test runs
1:1f00a39:         beginTx();
1:d29ca2a:         while (consumer.receiveNoWait() != null) {
1:d29ca2a:         }
1:d29ca2a: 
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         // sends the messages
1:1f00a39:         beginTx();
1:d29ca2a:         producer.send(outbound[0]);
1:d29ca2a:         producer.send(outbound[1]);
1:1f00a39:         commitTx();
1:230a86c:         LOG.info("Sent 0: " + outbound[0]);
1:230a86c:         LOG.info("Sent 1: " + outbound[1]);
1:d29ca2a: 
1:1f00a39:         beginTx();
1:230a86c:         TextMessage message = (TextMessage)consumer.receive(1000);
1:230a86c:         assertEquals(outbound[0].getText(), message.getText());
1:230a86c:         // Close the consumer before the commit. This should not cause the
1:230a86c:         // received message
1:d29ca2a:         // to rollback.
1:d29ca2a:         consumer.close();
1:1f00a39:         commitTx();
1:d29ca2a: 
1:d29ca2a:         // Create a new consumer
1:d29ca2a:         consumer = resourceProvider.createConsumer(session, destination);
1:230a86c:         LOG.info("Created consumer: " + consumer);
1:d29ca2a: 
1:1f00a39:         beginTx();
1:230a86c:         message = (TextMessage)consumer.receive(1000);
1:d29ca2a:         assertEquals(outbound[1].getText(), message.getText());
1:1f00a39:         commitTx();
1:d29ca2a:     }
1:d29ca2a: 
1:d9b9427:     public void testChangeMutableObjectInObjectMessageThenRollback() throws Exception {
1:933eb2f:         ArrayList<String> list = new ArrayList<String>();
1:d9b9427:         list.add("First");
1:d9b9427:         Message outbound = session.createObjectMessage(list);
1:d9b9427:         outbound.setStringProperty("foo", "abc");
1:d29ca2a: 
1:1f00a39:         beginTx();
1:d9b9427:         producer.send(outbound);
1:1f00a39:         commitTx();
1:d29ca2a: 
1:230a86c:         LOG.info("About to consume message 1");
1:1f00a39:         beginTx();
1:d5193d2:         Message message = consumer.receive(5000);
1:d29ca2a: 
1:933eb2f:         List<String> body = assertReceivedObjectMessageWithListBody(message);
1:d29ca2a: 
1:d9b9427:         // now lets try mutate it
1:d9b9427:         try {
1:d9b9427:             message.setStringProperty("foo", "def");
1:d9b9427:             fail("Cannot change properties of the object!");
1:230a86c:         } catch (JMSException e) {
1:230a86c:             LOG.info("Caught expected exception: " + e, e);
2:d9b9427:         }
1:d9b9427:         body.clear();
1:d9b9427:         body.add("This should never be seen!");
1:1f00a39:         rollbackTx();
1:d29ca2a: 
1:1f00a39:         beginTx();
1:d5193d2:         message = consumer.receive(5000);
1:933eb2f:         List<String> secondBody = assertReceivedObjectMessageWithListBody(message);
1:d9b9427:         assertNotSame("Second call should return a different body", secondBody, body);
1:1f00a39:         commitTx();
1:d9b9427:     }
1:d29ca2a: 
1:933eb2f:     @SuppressWarnings("unchecked")
1:933eb2f:     protected List<String> assertReceivedObjectMessageWithListBody(Message message) throws JMSException {
1:d9b9427:         assertNotNull("Should have received a message!", message);
1:d9b9427:         assertEquals("foo header", "abc", message.getStringProperty("foo"));
2:1f00a39: 
1:d9b9427:         assertTrue("Should be an object message but was: " + message, message instanceof ObjectMessage);
1:230a86c:         ObjectMessage objectMessage = (ObjectMessage)message;
1:933eb2f:         List<String> body = (List<String>)objectMessage.getObject();
1:230a86c:         LOG.info("Received body: " + body);
1:1f00a39: 
1:d9b9427:         assertEquals("Size of list should be 1", 1, body.size());
1:d9b9427:         assertEquals("element 0 of list", "First", body.get(0));
1:d9b9427:         return body;
1:d9b9427:     }
1:1f00a39: 
1:d29ca2a:     /**
1:d29ca2a:      * Recreates the connection.
1:4a2af3a:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:1f00a39:     protected void reconnect() throws Exception {
1:230a86c: 
1:d29ca2a:         if (connection != null) {
1:fa8b889:             // Close the prev connection.
2:d29ca2a:             connection.close();
1:d29ca2a:         }
1:230a86c:         session = null;
1:95a2aa6:         connection = resourceProvider.createConnection(connectionFactory);
1:05ea5d4:         reconnectSession();
1:d29ca2a:         connection.start();
1:05ea5d4:     }
1:230a86c: 
1:05ea5d4:     /**
1:05ea5d4:      * Recreates the connection.
1:4a2af3a:      *
1:05ea5d4:      * @throws JMSException
1:05ea5d4:      */
1:05ea5d4:     protected void reconnectSession() throws JMSException {
1:05ea5d4:         if (session != null) {
1:d29ca2a:             session.close();
1:05ea5d4:         }
1:230a86c: 
1:d29ca2a:         session = resourceProvider.createSession(connection);
1:d29ca2a:         destination = resourceProvider.createDestination(session, getSubject());
1:d29ca2a:         producer = resourceProvider.createProducer(session, destination);
1:d29ca2a:         consumer = resourceProvider.createConsumer(session, destination);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets the prefeftch policy to one.
1:d29ca2a:      */
1:d29ca2a:     protected void setPrefetchToOne() {
1:1f00a39:         ActiveMQPrefetchPolicy prefetchPolicy = getPrefetchPolicy();
1:d29ca2a:         prefetchPolicy.setQueuePrefetch(1);
1:d29ca2a:         prefetchPolicy.setTopicPrefetch(1);
1:d29ca2a:         prefetchPolicy.setDurableTopicPrefetch(1);
1:fa8b889:         prefetchPolicy.setOptimizeDurableTopicPrefetch(1);
1:d29ca2a:     }
1:d29ca2a: 
1:1f00a39:     protected ActiveMQPrefetchPolicy getPrefetchPolicy() {
1:1f00a39:         return ((ActiveMQConnection)connection).getPrefetchPolicy();
1:1f00a39:     }
1:1f00a39: 
1:1f00a39:     //This test won't work with xa tx so no beginTx() has been added.
1:d29ca2a:     public void testMessageListener() throws Exception {
1:230a86c:         // send messages
1:fc00993:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:fc00993:             producer.send(session.createTextMessage(MESSAGE_TEXT + i));
1:d29ca2a:         }
1:1f00a39:         commitTx();
1:d29ca2a:         consumer.setMessageListener(this);
1:230a86c:         // wait receive
1:d29ca2a:         waitReceiveUnack();
1:fc00993:         assertEquals(unackMessages.size(), MESSAGE_COUNT);
1:230a86c:         // resend phase
1:d29ca2a:         waitReceiveAck();
1:fc00993:         assertEquals(ackMessages.size(), MESSAGE_COUNT);
1:230a86c:         // should no longer re-receive
1:d29ca2a:         consumer.setMessageListener(null);
1:d29ca2a:         assertNull(consumer.receive(500));
1:d29ca2a:         reconnect();
1:d29ca2a:     }
1:d29ca2a: 
1:4a2af3a:     @Override
1:d29ca2a:     public void onMessage(Message message) {
1:230a86c:         if (!resendPhase) {
1:d29ca2a:             unackMessages.add(message);
1:fc00993:             if (unackMessages.size() == MESSAGE_COUNT) {
1:d29ca2a:                 try {
1:1f00a39:                     rollbackTx();
1:d29ca2a:                     resendPhase = true;
1:d29ca2a:                 } catch (Exception e) {
1:d29ca2a:                     e.printStackTrace();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         } else {
1:d29ca2a:             ackMessages.add(message);
1:fc00993:             if (ackMessages.size() == MESSAGE_COUNT) {
1:d29ca2a:                 try {
1:1f00a39:                     commitTx();
1:d29ca2a:                 } catch (Exception e) {
1:d29ca2a:                     e.printStackTrace();
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private void waitReceiveUnack() throws Exception {
1:230a86c:         for (int i = 0; i < 100 && !resendPhase; i++) {
1:d29ca2a:             Thread.sleep(100);
1:d29ca2a:         }
1:230a86c:         assertTrue(resendPhase);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private void waitReceiveAck() throws Exception {
1:fc00993:         for (int i = 0; i < 100 && ackMessages.size() < MESSAGE_COUNT; i++) {
1:d29ca2a:             Thread.sleep(100);
1:d29ca2a:         }
1:fc00993:         assertFalse(ackMessages.size() < MESSAGE_COUNT);
1:d29ca2a:     }
1:d29ca2a: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:gtully
-------------------------------------------------------------------------------
commit:29b833f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } catch (Exception e) {
1:             LOG.info("Caught exception while closing resources.");
1:         }
1:         try {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:4a2af3a
/////////////////////////////////////////////////////////////////////////
1:  *
/////////////////////////////////////////////////////////////////////////
1:     private final List<Message> unackMessages = new ArrayList<Message>(MESSAGE_COUNT);
1:     private final List<Message> ackMessages = new ArrayList<Message>(MESSAGE_COUNT);
/////////////////////////////////////////////////////////////////////////
1:      *
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:      *
1:     @Override
1:         try {
1:             session.close();
1:             session = null;
1:             connection.close();
1:             connection = null;
1:         } catch (Exception e) {
1:             LOG.info("Caught exception while closing resources.");
1:         }
1: 
1:         try {
1:             broker.stop();
1:             broker.waitUntilStopped();
1:             broker = null;
1:         } catch (Exception e) {
1:             LOG.info("Caught exception while shutting down the Broker", e);
1:         }
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:bfbe90b
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log LOG = LogFactory.getLog(JmsTransactionTestSupport.class);
/////////////////////////////////////////////////////////////////////////
1:     // for message listener test
0:     private List<Message> unackMessages = new ArrayList<Message>(MESSAGE_COUNT);
0:     private List<Message> ackMessages = new ArrayList<Message>(MESSAGE_COUNT);
1:     private boolean resendPhase;
1: 
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Message> messages = new ArrayList<Message>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Message> messages = new ArrayList<Message>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Message> messages = new ArrayList<Message>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Message> messages = new ArrayList<Message>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Message> messages = new ArrayList<Message>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> list = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         List<String> body = assertReceivedObjectMessageWithListBody(message);
/////////////////////////////////////////////////////////////////////////
1:         List<String> secondBody = assertReceivedObjectMessageWithListBody(message);
1:     @SuppressWarnings("unchecked")
1:     protected List<String> assertReceivedObjectMessageWithListBody(Message message) throws JMSException {
1:         List<String> body = (List<String>)objectMessage.getObject();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1: public abstract class JmsTransactionTestSupport extends TestSupport implements MessageListener {
1:     private static final int MESSAGE_COUNT = 5;
1:     private static final String MESSAGE_TEXT = "message";
/////////////////////////////////////////////////////////////////////////
0:     private List unackMessages = new ArrayList(MESSAGE_COUNT);
0:     private List ackMessages = new ArrayList(MESSAGE_COUNT);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 5; i++) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < MESSAGE_COUNT; i++) {
1:             producer.send(session.createTextMessage(MESSAGE_TEXT + i));
1:         assertEquals(unackMessages.size(), MESSAGE_COUNT);
1:         assertEquals(ackMessages.size(), MESSAGE_COUNT);
/////////////////////////////////////////////////////////////////////////
1:             if (unackMessages.size() == MESSAGE_COUNT) {
/////////////////////////////////////////////////////////////////////////
1:             if (ackMessages.size() == MESSAGE_COUNT) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 100 && ackMessages.size() < MESSAGE_COUNT; i++) {
1:         assertFalse(ackMessages.size() < MESSAGE_COUNT);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
0:     private static final org.apache.commons.logging.Log LOG = org.apache.commons.logging.LogFactory.getLog(JmsTransactionTestSupport.class);
/////////////////////////////////////////////////////////////////////////
1: 
0:     private boolean resendPhase;
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * (non-Javadoc)
1:      * 
1: 
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * (non-Javadoc)
1:      * 
1:         LOG.info("Closing down connection");
1:         session = null;
0:         connection = null;
0:         broker = null;
1: 
1:         LOG.info("Connection closed.");
1:      * 
1: 
1:             LOG.info("Producing bacth " + j + " of " + batchSize + " messages");
1:             LOG.info("Consuming bacth " + j + " of " + batchSize + " messages");
1:                 message = (TextMessage)consumer.receive(1000 * 5);
/////////////////////////////////////////////////////////////////////////
1:      * Sends a batch of messages and validates that the rollbacked message was
1:      * not consumed.
0:      * 
1:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:         // sends a message
1:         // sends a message that gets rollbacked
1: 
1:         // sends a message
1:         // receives the first message
1:         LOG.info("About to consume message 1");
1:         LOG.info("Received: " + message);
1:         // receives the second message
1:         LOG.info("About to consume message 2");
1:         LOG.info("Received: " + message);
1:         // validates that the rollbacked was not consumed
1: 
1:      * Sends a batch of messages and validates that the message sent before
1:      * session close is not consumed.
0:      * 
1:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1: 
1:         // sends a message
1: 
1:         // sends a message that gets rollbacked
1: 
1: 
1:         // sends a message
1: 
1:         // receives the first message
1:         LOG.info("About to consume message 1");
1:         LOG.info("Received: " + message);
1: 
1:         // receives the second message
1:         LOG.info("About to consume message 2");
1:         LOG.info("Received: " + message);
1: 
1:         // validates that the rollbacked was not consumed
/////////////////////////////////////////////////////////////////////////
1:      * Sends a batch of messages and validates that the message sent before
1:      * session close is not consumed.
0:      * 
1:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:         // sends a message
1:         // sends a message that gets rollbacked
1:         // sends a message
1:         // receives the first message
1:         LOG.info("About to consume message 1");
1:         LOG.info("Received: " + message);
1:         // receives the second message
1:         LOG.info("About to consume message 2");
1:         LOG.info("Received: " + message);
1:         // validates that the rollbacked was not consumed
/////////////////////////////////////////////////////////////////////////
1:      * Sends a batch of messages and validates that the rollbacked message was
1:      * redelivered.
0:      * 
1:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
1:         // sent both messages
1:         LOG.info("Sent 0: " + outbound[0]);
1:         LOG.info("Sent 1: " + outbound[1]);
/////////////////////////////////////////////////////////////////////////
1:      * Sends a batch of messages and validates that the rollbacked message was
1:      * redelivered.
0:      * 
1:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Sent 0: " + outbound[0]);
1:         LOG.info("Sent 1: " + outbound[1]);
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertNull(consumer.receiveNoWait());
/////////////////////////////////////////////////////////////////////////
1:      * Sends a batch of messages and validates that the rollbacked message was
1:      * not consumed.
0:      * 
1:         Message[] outbound = new Message[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message"), session.createTextMessage("Third Message"),
1:                                             session.createTextMessage("Fourth Message")};
1:             // sends a message
1:         // receives the first message
1:             LOG.info("About to consume message 1");
1:             LOG.info("Received: " + message);
1:         // validates that the rollbacked was not consumed
1:      * Perform the test that validates if the rollbacked message was redelivered
1:      * multiple times.
0:      * 
/////////////////////////////////////////////////////////////////////////
1:      * Sends a batch of messages and validates that the rollbacked message was
1:      * not consumed. This test differs by setting the message prefetch to one.
0:      * 
/////////////////////////////////////////////////////////////////////////
1:      * Sends a batch of messages and and validates that the rollbacked message
1:      * was redelivered. This test differs by setting the message prefetch to
1:      * one.
0:      * 
/////////////////////////////////////////////////////////////////////////
1:      * Tests if the messages can still be received if the consumer is closed
1:      * (session is not closed).
0:      * 
1:         TextMessage[] outbound = new TextMessage[] {session.createTextMessage("First Message"), session.createTextMessage("Second Message")};
/////////////////////////////////////////////////////////////////////////
1:         // sends the messages
1:         LOG.info("Sent 0: " + outbound[0]);
1:         LOG.info("Sent 1: " + outbound[1]);
1:         TextMessage message = (TextMessage)consumer.receive(1000);
1:         assertEquals(outbound[0].getText(), message.getText());
1:         // Close the consumer before the commit. This should not cause the
1:         // received message
1:         LOG.info("Created consumer: " + consumer);
1:         message = (TextMessage)consumer.receive(1000);
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("About to consume message 1");
/////////////////////////////////////////////////////////////////////////
1:         } catch (JMSException e) {
1:             LOG.info("Caught expected exception: " + e, e);
/////////////////////////////////////////////////////////////////////////
1:         ObjectMessage objectMessage = (ObjectMessage)message;
0:         List body = (List)objectMessage.getObject();
1:         LOG.info("Received body: " + body);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         ActiveMQPrefetchPolicy prefetchPolicy = ((ActiveMQConnection)connection).getPrefetchPolicy();
/////////////////////////////////////////////////////////////////////////
1:         // send messages
0:         for (int i = 0; i < messageCount; i++) {
0:             producer.send(session.createTextMessage(messageText + i));
1:         // wait receive
0:         assertEquals(unackMessages.size(), messageCount);
1:         // resend phase
0:         assertEquals(ackMessages.size(), messageCount);
1:         // should no longer re-receive
1:         if (!resendPhase) {
0:             if (unackMessages.size() == messageCount) {
/////////////////////////////////////////////////////////////////////////
0:             if (ackMessages.size() == messageCount) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 100 && !resendPhase; i++) {
1:         assertTrue(resendPhase);
0:         for (int i = 0; i < 100 && ackMessages.size() < messageCount; i++) {
0:         assertFalse(ackMessages.size() < messageCount);
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:b022a9d
/////////////////////////////////////////////////////////////////////////
0:         session=null;
0:         connection=null;
0:         broker=null;
1:         
commit:013f372
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerService;
/////////////////////////////////////////////////////////////////////////
1: 
1: import java.net.URI;
1: import java.net.URISyntaxException;
/////////////////////////////////////////////////////////////////////////
0:     private BrokerService broker;
1: 
/////////////////////////////////////////////////////////////////////////
1:         broker = createBroker();
1:         broker.start();
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      */
1:     protected BrokerService createBroker() throws Exception, URISyntaxException {
1:         return BrokerFactory.createBroker(new URI("broker://()/localhost?persistent=false"));
1:     }
1: 
0:         broker.stop();
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.ActiveMQPrefetchPolicy;
1: import org.apache.activemq.test.JmsResourceProvider;
1: import org.apache.activemq.test.TestSupport;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.jms.MessageListener;
1: import java.util.ArrayList;
1: import java.util.List;
1: 
1: /**
0:  * @version $Revision: 1.9 $
1:  */
0: abstract public class JmsTransactionTestSupport extends TestSupport implements MessageListener {
1:     
0:     private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory
0:             .getLog(JmsTransactionTestSupport.class);
1: 
0:     protected ConnectionFactory connectionFactory;
1:     protected Connection connection;
1:     protected Session session;
1:     protected MessageConsumer consumer;
1:     protected MessageProducer producer;
1:     protected JmsResourceProvider resourceProvider;
1:     protected Destination destination;
1:     
0:     // for message listener test
0:     private final int messageCount = 5;
0:     private final String messageText = "message";
0:     private List unackMessages = new ArrayList(messageCount);
0:     private List ackMessages = new ArrayList(messageCount);
0:     private boolean resendPhase = false;
1: 
1:     public JmsTransactionTestSupport() {
1:         super();
1:     }
1: 
1:     public JmsTransactionTestSupport(String name) {
1:         super(name);
1:     }
1: 
1: 
0:     /* (non-Javadoc)
1:      * @see junit.framework.TestCase#setUp()
1:      */
1:     protected void setUp() throws Exception {
0:         super.setUp();
1:         resourceProvider = getJmsResourceProvider();
1:         topic = resourceProvider.isTopic();
1:         // We will be using transacted sessions.
1:         resourceProvider.setTransacted(true);
0:         connectionFactory = resourceProvider.createConnectionFactory();
1:         reconnect();
1:     }
1: 
0:     /* (non-Javadoc)
1:      * @see junit.framework.TestCase#tearDown()
1:      */
1:     protected void tearDown() throws Exception {
0:         //TODO
0:         //log.info("Test Done.  Stats");
0:         //((ActiveMQConnectionFactory) connectionFactory).getFactoryStats().dump(new IndentPrinter());
0:         log.info("Closing down connection");
1: 
1:         session.close();
1:         connection.close();
0:         log.info("Connection closed.");
1:     }
1: 
1:     protected abstract JmsResourceProvider getJmsResourceProvider();
1: 
1:     /**
1:      * Sends a batch of messages and validates that the messages are received.
0:      *
1:      * @throws Exception
1:      */
1:     public void testSendReceiveTransactedBatches() throws Exception {
0:         int batchCount = 10;
0:         int batchSize = 20;
1:         TextMessage message = session.createTextMessage("Batch Message");
1: 
1:         for (int j = 0; j < batchCount; j++) {
0:             log.info("Producing bacth " + j + " of " + batchSize + " messages");
1: 
1:             for (int i = 0; i < batchSize; i++) {
1:                 producer.send(message);
1:             }
1: 
1:             session.commit();
0:             log.info("Consuming bacth " + j + " of " + batchSize + " messages");
1: 
1:             for (int i = 0; i < batchSize; i++) {
0:                 message = (TextMessage) consumer.receive(1000 * 5);
1:                 assertNotNull("Received only " + i + " messages in batch " + j, message);
1:                 assertEquals("Batch Message", message.getText());
1:             }
1: 
1:             session.commit();
1:         }
1:     }
1: 
1:     /**
0:      * Sends a batch of messages and validates that the rollbacked message was not consumed.
0:      *
1:      * @throws Exception
1:      */
1:     public void testSendRollback() throws Exception {
0:         Message[] outbound = new Message[]{
0:             session.createTextMessage("First Message"),
0:             session.createTextMessage("Second Message")
0:         };
1: 
0:         //sends a message
1:         producer.send(outbound[0]);
1:         session.commit();
1: 
0:         //sends a message that gets rollbacked
1:         producer.send(session.createTextMessage("I'm going to get rolled back."));
1:         session.rollback();
1:         
0:         //sends a message
1:         producer.send(outbound[1]);
1:         session.commit();
1: 
0:         //receives the first message
0:         ArrayList messages = new ArrayList();
0:         log.info("About to consume message 1");
1:         Message message = consumer.receive(1000);
1:         messages.add(message);
0:         log.info("Received: " + message);
1: 
0:         //receives the second message
0:         log.info("About to consume message 2");
1:         message = consumer.receive(4000);
1:         messages.add(message);
0:         log.info("Received: " + message);
1: 
0:         //validates that the rollbacked was not consumed
1:         session.commit();
1:         Message inbound[] = new Message[messages.size()];
1:         messages.toArray(inbound);
1:         assertTextMessagesEqual("Rollback did not work.", outbound, inbound);
1:     }
1: 
1:     /**
0:      * Sends a batch of messages and validates that the message sent before session close is not consumed.
0:      *
1:      * @throws Exception
1:      */
1:     public void testSendSessionClose() throws Exception {
0:         Message[] outbound = new Message[]{
0:             session.createTextMessage("First Message"),
0:             session.createTextMessage("Second Message")
0:         };
1: 
0:         //sends a message
1:         producer.send(outbound[0]);
1:         session.commit();
1: 
0:         //sends a message that gets rollbacked
1:         producer.send(session.createTextMessage("I'm going to get rolled back."));
1:         consumer.close();
1:         session.close();
1: 
1:         reconnect();
1: 
0:         //sends a message
1:         producer.send(outbound[1]);
1:         session.commit();
1: 
0:         //receives the first message
0:         ArrayList messages = new ArrayList();
0:         log.info("About to consume message 1");
1:         Message message = consumer.receive(1000);
1:         messages.add(message);
0:         log.info("Received: " + message);
1: 
0:         //receives the second message
0:         log.info("About to consume message 2");
1:         message = consumer.receive(4000);
1:         messages.add(message);
0:         log.info("Received: " + message);
1: 
0:         //validates that the rollbacked was not consumed
1:         session.commit();
1:         Message inbound[] = new Message[messages.size()];
1:         messages.toArray(inbound);
1:         assertTextMessagesEqual("Rollback did not work.", outbound, inbound);
1:     }
1: 
1:     /**
0:      * Sends a batch of messages and validates that the rollbacked message was redelivered.
0:      *
1:      * @throws Exception
1:      */
1:     public void testReceiveRollback() throws Exception {
0:         Message[] outbound = new Message[]{
0:             session.createTextMessage("First Message"),
0:             session.createTextMessage("Second Message")
0:         };
1: 
0:         // lets consume any outstanding messages from previous test runs
1:         while (consumer.receive(1000) != null) {
1:         }
1:         session.commit();
1: 
0:         //sent both messages
1:         producer.send(outbound[0]);
1:         producer.send(outbound[1]);
1:         session.commit();
1: 
0:         log.info("Sent 0: " + outbound[0]);
0:         log.info("Sent 1: " + outbound[1]);
1: 
0:         ArrayList messages = new ArrayList();
1:         Message message = consumer.receive(1000);
1:         messages.add(message);
1:         assertEquals(outbound[0], message);
1:         session.commit();
1: 
1:         // rollback so we can get that last message again.
1:         message = consumer.receive(1000);
1:         assertNotNull(message);
1:         assertEquals(outbound[1], message);
1:         session.rollback();
1: 
0:         // Consume again.. the previous message should
1:         // get redelivered.
1:         message = consumer.receive(5000);
1:         assertNotNull("Should have re-received the message again!", message);
1:         messages.add(message);
1:         session.commit();
1: 
1:         Message inbound[] = new Message[messages.size()];
1:         messages.toArray(inbound);
1:         assertTextMessagesEqual("Rollback did not work", outbound, inbound);
1:     }
1: 
1:     /**
0:      * Sends a batch of messages and validates that the rollbacked message was redelivered.
0:      *
1:      * @throws Exception
1:      */
1:     public void testReceiveTwoThenRollback() throws Exception {
0:         Message[] outbound = new Message[]{
0:             session.createTextMessage("First Message"),
0:             session.createTextMessage("Second Message")
0:         };
1: 
0:         // lets consume any outstanding messages from previous test runs
1:         while (consumer.receive(1000) != null) {
1:         }
1:         session.commit();
1: 
1:         //
1:         producer.send(outbound[0]);
1:         producer.send(outbound[1]);
1:         session.commit();
1: 
0:         log.info("Sent 0: " + outbound[0]);
0:         log.info("Sent 1: " + outbound[1]);
1: 
0:         ArrayList messages = new ArrayList();
1:         Message message = consumer.receive(1000);
1:         assertEquals(outbound[0], message);
1: 
1:         message = consumer.receive(1000);
1:         assertNotNull(message);
1:         assertEquals(outbound[1], message);
1:         session.rollback();
1: 
0:         // Consume again.. the previous message should
1:         // get redelivered.
1:         message = consumer.receive(5000);
1:         assertNotNull("Should have re-received the first message again!", message);
1:         messages.add(message);
1:         assertEquals(outbound[0], message);
1:         message = consumer.receive(5000);
1:         assertNotNull("Should have re-received the second message again!", message);
1:         messages.add(message);
1:         assertEquals(outbound[1], message);
1:         
0:         assertNull(consumer.receiveNoWait());        
1:         session.commit();
1: 
1:         Message inbound[] = new Message[messages.size()];
1:         messages.toArray(inbound);
1:         assertTextMessagesEqual("Rollback did not work", outbound, inbound);
1:     }
1: 
1:     /**
0:      * Sends a batch of messages and validates that the rollbacked message was not consumed.
0:      *
1:      * @throws Exception
1:      */
1:     public void testSendReceiveWithPrefetchOne() throws Exception {
1:         setPrefetchToOne();
0:         Message[] outbound = new Message[]{
0:             session.createTextMessage("First Message"),
0:             session.createTextMessage("Second Message"),
0:             session.createTextMessage("Third Message"),
0:             session.createTextMessage("Fourth Message")
0:         };
1: 
1:         for (int i = 0; i < outbound.length; i++) {
0:             //sends a message
1:             producer.send(outbound[i]);
1:         }
1:         session.commit();
1: 
0:         //receives the first message
1:         for (int i = 0; i < outbound.length; i++) {
0:             log.info("About to consume message 1");
1:             Message message = consumer.receive(1000);
1:             assertNotNull(message);
0:             log.info("Received: " + message);
1:         }
1: 
0:         //validates that the rollbacked was not consumed
1:         session.commit();
1:     }
1: 
1:     /**
0:      * Perform the test that validates if the rollbacked message was redelivered multiple times.
0:      *
1:      * @throws Exception
1:      */
1:     public void testReceiveTwoThenRollbackManyTimes() throws Exception {
0:         for (int i = 0; i < 5; i++)
1:             testReceiveTwoThenRollback();
1:     }
1: 
1:     /**
0:      * Sends a batch of messages and validates that the rollbacked message was not consumed. This test differs by
0:      * setting the message prefetch to one.
0:      *
1:      * @throws Exception
1:      */
1:     public void testSendRollbackWithPrefetchOfOne() throws Exception {
1:         setPrefetchToOne();
1:         testSendRollback();
1:     }
1: 
1:     /**
0:      * Sends a batch of messages and  and validates that the rollbacked message was redelivered. This test differs by
0:      * setting the message prefetch to one.
0:      *
1:      * @throws Exception
1:      */
1:     public void testReceiveRollbackWithPrefetchOfOne() throws Exception {
1:         setPrefetchToOne();
1:         testReceiveRollback();
1:     }
1: 
1:     /**
0:      * Tests if the messages can still be received if the consumer is closed (session is not closed).
0:      *
1:      * @throws Exception see http://jira.codehaus.org/browse/AMQ-143
1:      */
1:     public void testCloseConsumerBeforeCommit() throws Exception {
0:         TextMessage[] outbound = new TextMessage[]{
0:             session.createTextMessage("First Message"),
0:             session.createTextMessage("Second Message")
0:         };
1: 
0:         // lets consume any outstanding messages from previous test runs
1:         while (consumer.receiveNoWait() != null) {
1:         }
1: 
1:         session.commit();
1: 
0:         //sends the messages
1:         producer.send(outbound[0]);
1:         producer.send(outbound[1]);
1:         session.commit();
0:         log.info("Sent 0: " + outbound[0]);
0:         log.info("Sent 1: " + outbound[1]);
1: 
0:         TextMessage message = (TextMessage) consumer.receive(1000);
0:         assertEquals(outbound[0].getText(), message.getText());        
0:         // Close the consumer before the commit.  This should not cause the received message
1:         // to rollback.
1:         consumer.close();
1:         session.commit();
1: 
1:         // Create a new consumer
1:         consumer = resourceProvider.createConsumer(session, destination);
0:         log.info("Created consumer: " + consumer);
1: 
0:         message = (TextMessage) consumer.receive(1000);
1:         assertEquals(outbound[1].getText(), message.getText());
1:         session.commit();
1:     }
1: 
1: 
1:     /**
1:      * Recreates the connection.
0:      *
1:      * @throws JMSException
1:      */
0:     protected void reconnect() throws JMSException {
1: 
0:         Connection t = resourceProvider.createConnection(connectionFactory);
1:         if (connection != null) {
0:             // Close the previous connection.
1:             connection.close();
1:         }
0:         connection = t;
1: 
1:         session = resourceProvider.createSession(connection);
1:         destination = resourceProvider.createDestination(session, getSubject());
1:         producer = resourceProvider.createProducer(session, destination);
1:         consumer = resourceProvider.createConsumer(session, destination);
1:         connection.start();
1:     }
1: 
1:     /**
1:      * Sets the prefeftch policy to one.
1:      */
1:     protected void setPrefetchToOne() {
0:         ActiveMQPrefetchPolicy prefetchPolicy = ((ActiveMQConnection) connection).getPrefetchPolicy();
1:         prefetchPolicy.setQueuePrefetch(1);
1:         prefetchPolicy.setTopicPrefetch(1);
1:         prefetchPolicy.setDurableTopicPrefetch(1);
1:     }
1: 
1:     public void testMessageListener() throws Exception {
0:         //send messages
0:         for(int i = 0;i<messageCount;i++) {
0:             producer.send(session.createTextMessage(messageText+i));
1:         }
1:         session.commit();
1:         consumer.setMessageListener(this);
0:         //wait receive
1:         waitReceiveUnack();
0:         assertEquals(unackMessages.size(),messageCount);
0:         //resend phase
1:         waitReceiveAck();
0:         assertEquals(ackMessages.size(),messageCount);
0:         //should no longer re-receive
1:         consumer.setMessageListener(null);
1:         assertNull(consumer.receive(500));
1:         reconnect();
1:     }
1: 
1:     public void onMessage(Message message) {
0:         if(!resendPhase) {
1:             unackMessages.add(message);
0:             if(unackMessages.size() == messageCount) {
1:                 try {
1:                     session.rollback();
1:                     resendPhase = true;
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         } else {
1:             ackMessages.add(message);
0:             if(ackMessages.size() == messageCount) {
1:                 try {
1:                     session.commit();
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private void waitReceiveUnack() throws Exception {
0:         for(int i=0; i < 100 && !resendPhase; i++) {
1:             Thread.sleep(100);
1:         }
0:         assertTrue(resendPhase); 
1:     }
1: 
1:     private void waitReceiveAck() throws Exception {
0:         for(int i=0; i < 100 && ackMessages.size() < messageCount; i++) {
1:             Thread.sleep(100);
1:         }
0:         assertFalse(ackMessages.size() < messageCount); 
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JmsTransactionTestSupport.class);
commit:358b522
/////////////////////////////////////////////////////////////////////////
1:         broker.waitUntilStarted();
/////////////////////////////////////////////////////////////////////////
0:         broker.waitUntilStopped();
author:David Jencks
-------------------------------------------------------------------------------
commit:cd694f7
/////////////////////////////////////////////////////////////////////////
0:             while (consumer.receive(1000) != null) {
commit:1f00a39
/////////////////////////////////////////////////////////////////////////
1:         setSessionTransacted();
1:         connectionFactory = newConnectionFactory();
1:     protected void setSessionTransacted() {
0:         resourceProvider.setTransacted(true);
1:     }
1: 
1:     protected ConnectionFactory newConnectionFactory() throws Exception {
1:         return resourceProvider.createConnectionFactory();
1:     }
1: 
1:     protected void beginTx() throws Exception {
1:         //no-op for local tx
1:     }
1: 
1:     protected void commitTx() throws Exception {
0:         session.commit();
1:     }
1: 
1:     protected void rollbackTx() throws Exception {
0:         session.rollback();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             beginTx();
1:             commitTx();
1:             beginTx();
1:             commitTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         rollbackTx();
1:         beginTx();
1:         commitTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         commitTx();
1:      * spec section 3.6 acking a message with automation acks has no effect.
1:      * @throws Exception
1:      */
1:     public void testAckMessageInTx() throws Exception {
1:         Message[] outbound = new Message[] {session.createTextMessage("First Message")};
0: 
1:         // sends a message
1:         beginTx();
1:         producer.send(outbound[0]);
1:         outbound[0].acknowledge();
1:         commitTx();
1:         outbound[0].acknowledge();
0: 
1:         // receives the first message
1:         beginTx();
1:         ArrayList<Message> messages = new ArrayList<Message>();
1:         LOG.info("About to consume message 1");
1:         Message message = consumer.receive(1000);
1:         messages.add(message);
1:         LOG.info("Received: " + message);
0: 
1:         // validates that the rollbacked was not consumed
1:         commitTx();
1:         Message inbound[] = new Message[messages.size()];
1:         messages.toArray(inbound);
1:         assertTextMessagesEqual("Message not delivered.", outbound, inbound);
1:     }
0: 
1:     /**
0:      *
1:      * This test only works with local transactions, not xa.
1:         beginTx();
1:         commitTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         commitTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         rollbackTx();
1:         beginTx();
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         rollbackTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         commitTx();
1:         beginTx();
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:         beginTx();
1:         commitTx();
1:         beginTx();
/////////////////////////////////////////////////////////////////////////
1:         rollbackTx();
1:         beginTx();
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:     protected void reconnect() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQPrefetchPolicy prefetchPolicy = getPrefetchPolicy();
1:     protected ActiveMQPrefetchPolicy getPrefetchPolicy() {
1:         return ((ActiveMQConnection)connection).getPrefetchPolicy();
1:     }
0: 
1:     //This test won't work with xa tx so no beginTx() has been added.
1:         commitTx();
/////////////////////////////////////////////////////////////////////////
1:                     rollbackTx();
/////////////////////////////////////////////////////////////////////////
1:                     commitTx();
author:Robert Davies
-------------------------------------------------------------------------------
commit:4118d02
/////////////////////////////////////////////////////////////////////////
1:             messageSent();
/////////////////////////////////////////////////////////////////////////
1:     protected void messageSent() throws Exception {
1:     }
0: 
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:     private static final int messageCount = 5;
0:     private static final String messageText = "message";
commit:fa8b889
/////////////////////////////////////////////////////////////////////////
1:         // lets consume any outstanding messages from prev test runs
/////////////////////////////////////////////////////////////////////////
1:         // Consume again.. the prev message should
/////////////////////////////////////////////////////////////////////////
1:         // lets consume any outstanding messages from prev test runs
/////////////////////////////////////////////////////////////////////////
1:         // Consume again.. the prev message should
/////////////////////////////////////////////////////////////////////////
1:         // lets consume any outstanding messages from prev test runs
/////////////////////////////////////////////////////////////////////////
1:             // Close the prev connection.
/////////////////////////////////////////////////////////////////////////
1:         prefetchPolicy.setOptimizeDurableTopicPrefetch(1);
commit:0e6a7e4
/////////////////////////////////////////////////////////////////////////
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.ArrayList;
0: import java.util.List;
0: import javax.jms.MessageListener;
0: import org.apache.activemq.broker.BrokerFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.test.JmsResourceProvider;
0: import org.apache.activemq.test.TestSupport;
/////////////////////////////////////////////////////////////////////////
1:     protected int batchCount = 10;
1:     protected int batchSize = 20;
1:     protected BrokerService broker;
/////////////////////////////////////////////////////////////////////////
0:        
author:James Strachan
-------------------------------------------------------------------------------
commit:05ea5d4
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:                 session.createTextMessage("First Message"),
0:                 session.createTextMessage("Second Message")
0:         };
0:         
0:         //sends a message
1:         producer.send(outbound[0]);
0:         session.commit();
0:         
0:         //sends a message that gets rollbacked
1:         producer.send(session.createTextMessage("I'm going to get rolled back."));
1:         consumer.close();
0:         
1:         reconnectSession();
0:         
0:         //sends a message
1:         producer.send(outbound[1]);
0:         session.commit();
0:         
0:         //receives the first message
0:         ArrayList messages = new ArrayList();
0:         log.info("About to consume message 1");
1:         Message message = consumer.receive(1000);
1:         messages.add(message);
0:         log.info("Received: " + message);
0:         
0:         //receives the second message
0:         log.info("About to consume message 2");
1:         message = consumer.receive(4000);
1:         messages.add(message);
0:         log.info("Received: " + message);
0:         
0:         //validates that the rollbacked was not consumed
0:         session.commit();
1:         Message inbound[] = new Message[messages.size()];
1:         messages.toArray(inbound);
1:         assertTextMessagesEqual("Rollback did not work.", outbound, inbound);
1:     }
0: 
1:     /**
0:      * Sends a batch of messages and validates that the message sent before session close is not consumed.
0:      *
1:      * @throws Exception
1:      */
1:     public void testSendSessionAndConnectionClose() throws Exception {
0:         Message[] outbound = new Message[]{
/////////////////////////////////////////////////////////////////////////
0:         
0:         session = null;
1:         reconnectSession();
0:         connection.start();
1:     }
0:     
1:     /**
1:      * Recreates the connection.
0:      * 
1:      * @throws JMSException
1:      */
1:     protected void reconnectSession() throws JMSException {
1:         if (session != null) {
0:             session.close();
1:         }
0:         
commit:d5193d2
/////////////////////////////////////////////////////////////////////////
1:         Message message = consumer.receive(5000);
/////////////////////////////////////////////////////////////////////////
1:         message = consumer.receive(5000);
commit:d9b9427
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.ObjectMessage;
0: import java.io.Serializable;
/////////////////////////////////////////////////////////////////////////
1:     public void testChangeMutableObjectInObjectMessageThenRollback() throws Exception {
0:         ArrayList list = new ArrayList();
1:         list.add("First");
1:         Message outbound = session.createObjectMessage(list);
1:         outbound.setStringProperty("foo", "abc");
0: 
1:         producer.send(outbound);
0:         session.commit();
0: 
0:         log.info("About to consume message 1");
0:         Message message = consumer.receive(1000);
0: 
0:         List body = assertReceivedObjectMessageWithListBody(message);
0: 
1:         // now lets try mutate it
1:         try {
1:             message.setStringProperty("foo", "def");
1:             fail("Cannot change properties of the object!");
1:         }
0:         catch (JMSException e) {
0:             log.info("Caught expected exception: " + e, e);
1:         }
1:         body.clear();
1:         body.add("This should never be seen!");
0:         session.rollback();
0: 
0:         message = consumer.receive(1000);
0:         List secondBody = assertReceivedObjectMessageWithListBody(message);
1:         assertNotSame("Second call should return a different body", secondBody, body);
0:         session.commit();
1:     }
0: 
0:     protected List assertReceivedObjectMessageWithListBody(Message message) throws JMSException {
1:         assertNotNull("Should have received a message!", message);
1:         assertEquals("foo header", "abc", message.getStringProperty("foo"));
0: 
1:         assertTrue("Should be an object message but was: " + message, message instanceof ObjectMessage);
0:         ObjectMessage objectMessage = (ObjectMessage) message;
0:         List body = (List) objectMessage.getObject();
0:         log.info("Received body: " + body);
0: 
1:         assertEquals("Size of list should be 1", 1, body.size());
1:         assertEquals("element 0 of list", "First", body.get(0));
1:         return body;
1:     }
0: 
0:      * 
commit:95a2aa6
/////////////////////////////////////////////////////////////////////////
1:         connection = resourceProvider.createConnection(connectionFactory);
============================================================================