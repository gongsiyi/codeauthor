1:3f32507: /*
1:3f32507:  * ? 2001-2009, Progress Software Corporation and/or its subsidiaries or affiliates.  All rights reserved.
1:3f32507:  *
1:3f32507:  * Licensed under the Apache License, Version 2.0 (the "License");
1:3f32507:  * you may not use this file except in compliance with the License.
1:3f32507:  * You may obtain a copy of the License at
1:3f32507:  *
1:3f32507:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3f32507:  *
1:3f32507:  * Unless required by applicable law or agreed to in writing, software
1:3f32507:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3f32507:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3f32507:  * See the License for the specific language governing permissions and
1:3f32507:  * limitations under the License.
1:3f32507:  
1:3f32507: Sample Application
1:3f32507: 
1:3f32507: Writing a Basic JMS Application with Point-to-Point Queues,
1:3f32507: using:
1:3f32507:     - Synchronous Request/Reply
1:3f32507:     - javax.jms.QueueRequestor class
1:3f32507:     - JMSReplyTo Header
1:3f32507: 
1:3f32507: When this program runs, it waits for messages on the queue,
1:3f32507: "SampleQ1" (by default).
1:3f32507: When that message arrives, a response based on the request
1:3f32507: is sent back to the "Requestor" specified in the JMSReplyTo header.
1:3f32507: 
1:3f32507: This sample replies with a simple text manipulation of the request;
1:3f32507: the text is either folded to all UPPERCASE or all lowercase.
1:3f32507: 
1:3f32507: Usage:
1:3f32507:   java Replier -b <broker:port> -u <username> -p <password> -qr <queue> -m <code>
1:3f32507:       -b broker:port points to your message broker
1:3f32507:                      Default: tcp://localhost:61616
1:3f32507:       -u username    must be unique (but is not checked)
1:3f32507:                      Default: SampleReplier
1:3f32507:       -p password    password for user (not checked)
1:3f32507:                      Default: password
1:3f32507:       -qr queue      name of queue for receiving requests
1:3f32507:                      Default:  Q1
1:3f32507:       -m mode        replier mode (uppercase, or lowercase)
1:3f32507:                      Default: uppercase
1:3f32507: 
1:3f32507: Suggested demonstration:
1:3f32507:   - In a console window with the environment set,
1:3f32507:     start a copy of the Replier. For example:
1:3f32507:        java Replier -u SampleQReplier
1:3f32507:   - In another console window, start a Requestor.
1:3f32507:     For example:
1:3f32507:        java Requestor -u SampleQRequestor
1:3f32507:   - Enter text in the Requestor window then press Enter.
1:3f32507:     The Replier responds with the message in all uppercase characters.
1:3f32507:   - Start other Requestors with different user names to see that
1:3f32507:     replies are not broadcast to all users. For example:
1:3f32507:        java Requestor -u SampleRequestorFoo
1:3f32507: 
1:3f32507:   - Start other Repliers.
1:3f32507:   - See that only one replier is receiving messages,(as it should).
1:3f32507:   - See the Requestor only receives one response.
1:3f32507:        java Replier -u toLower -m lowercase
1:3f32507: 
1:3f32507:  */
1:3f32507: import org.apache.activemq.*;
1:3f32507: 
1:3f32507: 
1:3f32507: public class Replier
1:3f32507:     implements javax.jms.MessageListener
1:3f32507: {
1:3f32507:     private static final String DEFAULT_BROKER_NAME = "tcp://localhost:61616";
1:3f32507:     private static final String DEFAULT_USER_NAME = "SampleReplier";
1:3f32507:     private static final String DEFAULT_PASSWORD = "password";
1:3f32507:     private static final String DEFAULT_QUEUE = "Q1";
1:3f32507:     private static final String DEFAULT_MODE = "uppercase";
1:3f32507:     private static final int UPPERCASE = 0;
1:3f32507:     private static final int LOWERCASE = 1;
1:3f32507: 
1:3f32507:     private javax.jms.Connection connect = null;
1:3f32507:     private javax.jms.Session session = null;
1:3f32507:     private javax.jms.MessageProducer replier = null;
1:3f32507: 
1:3f32507:     private int imode = UPPERCASE;
1:3f32507: 
1:3f32507:     /** Create JMS client for sending and receiving messages. */
1:3f32507:     private void start ( String broker, String username, String password, String rQueue, String mode)
1:3f32507:     {
1:3f32507:         // Set the operation mode
1:3f32507:         imode = (mode.equals("uppercase")) ? UPPERCASE : LOWERCASE;
1:3f32507: 
1:3f32507:         // Create a connection.
1:3f32507:         try
1:3f32507:         {
1:3f32507:             javax.jms.ConnectionFactory factory;
1:3f32507:             factory = new ActiveMQConnectionFactory(username, password, broker);
1:3f32507:             connect = factory.createConnection (username, password);
1:3f32507:             session = connect.createSession(true, javax.jms.Session.AUTO_ACKNOWLEDGE);
1:3f32507:         }
1:3f32507:         catch (javax.jms.JMSException jmse)
1:3f32507:         {
1:3f32507:             System.err.println("error: Cannot connect to Broker - " + broker);
1:3f32507:             jmse.printStackTrace();
1:3f32507:             System.exit(1);
1:3f32507:         }
1:3f32507: 
1:3f32507:         // Create Receivers to application queues as well as a Sender
1:3f32507:         // to use for JMS replies.
1:3f32507:         try
1:3f32507:         {
1:3f32507:             javax.jms.Queue queue = session.createQueue (rQueue);
1:3f32507:             javax.jms.MessageConsumer receiver = session.createConsumer(queue);
1:3f32507:             receiver.setMessageListener(this);
1:3f32507:             replier = session.createProducer(null);  // Queue will be set for each reply
1:3f32507:             // Now that all setup is complete, start the Connection
1:3f32507:             connect.start();
1:3f32507:         }
1:3f32507:         catch (javax.jms.JMSException jmse)
1:3f32507:         {
1:3f32507:             jmse.printStackTrace();
1:3f32507:             exit();
1:3f32507:         }
1:3f32507: 
1:3f32507:         try
1:3f32507:         {
1:3f32507:             // Read standard input waiting for "EXIT" command.
1:3f32507:             java.io.BufferedReader stdin =
1:3f32507:                 new java.io.BufferedReader( new java.io.InputStreamReader( System.in ) );
1:3f32507:             while ( true )
1:3f32507:             {
1:3f32507:                    System.out.println ("\nReplier application:\n"
1:3f32507: 			            					+ "============================\n"
1:3f32507: 			            					+ "The application user " + username + " connects to the broker at " + DEFAULT_BROKER_NAME + ".\n"
1:3f32507: 											+ "The application gets requests with JMSReplyTo set on the " + DEFAULT_QUEUE + " queue."
1:3f32507: 											+ "The message is transformed to all uppercase or all lowercase, and then returned to the requestor."
1:3f32507: 			                                + "The Requestor application displays the result.\n\n"
1:3f32507: 			                                + "Enter EXIT or press Ctrl+C to close the Replier.\n");
1:3f32507:                 String s = stdin.readLine();
1:3f32507:                 if ( s == null || s.equalsIgnoreCase("EXIT"))
1:3f32507:                 {
1:3f32507:                     System.out.println ("\nStopping Replier. Please wait..\n>");
1:3f32507:                     exit();
1:3f32507:                 }
1:3f32507:            }
1:3f32507:         }
1:3f32507:         catch ( java.io.IOException ioe )
1:3f32507:         {
1:3f32507:             ioe.printStackTrace();
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Handle the message.
1:3f32507:      * (as specified in the javax.jms.MessageListener interface).
1:3f32507:      *
1:3f32507:      * IMPORTANT NOTES:
1:3f32507:      * (1)We must follow the design paradigm for JMS
1:3f32507:      *    synchronous requests.  That is, we must:
1:3f32507:      *     - get the message
1:3f32507:      *     - look for the header specifying JMSReplyTo
1:3f32507:      *     - send a reply to the queue specified there.
1:3f32507:      *    Failing to follow these steps might leave the originator
1:3f32507:      *    of the request waiting forever.
1:3f32507:      * (2)Unlike the 'Talk' sample and others using an asynchronous
1:3f32507:      *    message listener, it is possible here to use ONLY
1:3f32507:      *    ONE SESSION because the messages being sent are sent from
1:3f32507:      *    the same thread of control handling message delivery. For
1:3f32507:      *    more information see the JMS spec v1.0.2 section 4.4.6.
1:3f32507:      *
1:3f32507:      * OPTIONAL BEHAVIOR: The following actions taken by the
1:3f32507:      * message handler represent good programming style, but are
1:3f32507:      * not required by the design paradigm for JMS requests.
1:3f32507:      *   - set the JMSCorrelationID (tying the response back to
1:3f32507:      *     the original request.
1:3f32507:      *   - use transacted session "commit" so receipt of request
1:3f32507:      *     won't happen without the reply being sent.
1:3f32507:      *
1:3f32507:      */
1:3f32507:     public void onMessage( javax.jms.Message aMessage)
1:3f32507:     {
1:3f32507:         try
1:3f32507:         {
1:3f32507:             // Cast the message as a text message.
1:3f32507:             javax.jms.TextMessage textMessage = (javax.jms.TextMessage) aMessage;
1:3f32507: 
1:3f32507:             // This handler reads a single String from the
1:3f32507:             // message and prints it to the standard output.
1:3f32507:             try
1:3f32507:             {
1:3f32507:                 String string = textMessage.getText();
1:3f32507:                 System.out.println( "[Request] " + string );
1:3f32507: 
1:3f32507:                 // Check for a ReplyTo Queue
1:3f32507:                 javax.jms.Queue replyQueue = (javax.jms.Queue) aMessage.getJMSReplyTo();
1:3f32507:                 if (replyQueue != null)
1:3f32507:                 {
1:3f32507:                     // Send the modified message back.
1:3f32507:                     javax.jms.TextMessage reply =  session.createTextMessage();
1:3f32507:                     if (imode == UPPERCASE)
1:3f32507:                         reply.setText("Uppercasing-" + string.toUpperCase());
1:3f32507:                     else
1:3f32507:                         reply.setText("Lowercasing-" + string.toLowerCase());
1:3f32507:                     reply.setJMSCorrelationID(aMessage.getJMSMessageID());
1:3f32507:                     replier.send (replyQueue, reply);
1:3f32507:                     session.commit();
1:3f32507:                 }
1:3f32507:             }
1:3f32507:             catch (javax.jms.JMSException jmse)
1:3f32507:             {
1:3f32507:                 jmse.printStackTrace();
1:3f32507:             }
1:3f32507:         }
1:3f32507:         catch (java.lang.RuntimeException rte)
1:3f32507:         {
1:3f32507:             rte.printStackTrace();
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:3f32507:     /** Cleanup resources cleanly and exit. */
1:3f32507:     private void exit()
1:3f32507:     {
1:3f32507:         try
1:3f32507:         {
1:3f32507:             connect.close();
1:3f32507:         }
1:3f32507:         catch (javax.jms.JMSException jmse)
1:3f32507:         {
1:3f32507:             jmse.printStackTrace();
1:3f32507:         }
1:3f32507: 
1:3f32507:         System.exit(0);
1:3f32507:     }
1:3f32507: 
1:3f32507:     //
1:3f32507:     // NOTE: the remainder of this sample deals with reading arguments
1:3f32507:     // and does not utilize any JMS classes or code.
1:3f32507:     //
1:3f32507: 
1:3f32507:     /** Main program entry point. */
1:3f32507:     public static void main(String argv[]) {
1:3f32507: 
1:3f32507:         // Values to be read from parameters
1:3f32507:         String broker    = DEFAULT_BROKER_NAME;
1:3f32507:         String username  = DEFAULT_USER_NAME;
1:3f32507:         String password  = DEFAULT_PASSWORD;
1:3f32507:         String queue     = DEFAULT_QUEUE;
1:3f32507:         String mode      = DEFAULT_MODE;
1:3f32507: 
1:3f32507:         // Check parameters
1:3f32507:         for (int i = 0; i < argv.length; i++) {
1:3f32507:             String arg = argv[i];
1:3f32507: 
1:3f32507: 
1:3f32507:             if (arg.equals("-b")) {
1:3f32507:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:3f32507:                     System.err.println("error: missing broker name:port");
1:3f32507:                     System.exit(1);
1:3f32507:                 }
1:3f32507:                 broker = argv[++i];
1:3f32507:                 continue;
1:3f32507:             }
1:3f32507: 
1:3f32507:             if (arg.equals("-u")) {
1:3f32507:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:3f32507:                     System.err.println("error: missing user name");
1:3f32507:                     System.exit(1);
1:3f32507:                 }
1:3f32507:                 username = argv[++i];
1:3f32507:                 continue;
1:3f32507:             }
1:3f32507: 
1:3f32507:             if (arg.equals("-p")) {
1:3f32507:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:3f32507:                     System.err.println("error: missing password");
1:3f32507:                     System.exit(1);
1:3f32507:                 }
1:3f32507:                 password = argv[++i];
1:3f32507:                 continue;
1:3f32507:             }
1:3f32507: 
1:3f32507:             if (arg.equals("-qr")) {
1:3f32507:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:3f32507:                     System.err.println("error: missing queue");
1:3f32507:                     System.exit(1);
1:3f32507:                 }
1:3f32507:                 queue = argv[++i];
1:3f32507:                 continue;
1:3f32507:             }
1:3f32507: 
1:3f32507:             if (arg.equals("-m")) {
1:3f32507:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:3f32507:                     System.err.println("error: missing mode");
1:3f32507:                     System.exit(1);
1:3f32507:                 }
1:3f32507:                 mode = argv[++i];
1:3f32507:                 if (!(mode.equals("uppercase") || mode.equals("lowercase"))) {
1:3f32507:                     System.err.println("error: mode must be 'uppercase' or 'lowercase'");
1:3f32507:                     System.exit(1);
1:3f32507:                 }
1:3f32507:                 continue;
1:3f32507:             }
1:3f32507: 
1:3f32507:             if (arg.equals("-h")) {
1:3f32507:                 printUsage();
1:3f32507:                 System.exit(1);
1:3f32507:             }
1:3f32507: 
1:3f32507:             // Invalid argument
1:3f32507:             System.err.println ("error: unexpected argument: "+arg);
1:3f32507:             printUsage();
1:3f32507:             System.exit(1);
1:3f32507:         }
1:3f32507: 
1:3f32507:         // Start the JMS client.
1:3f32507:         Replier replier = new Replier ();
1:3f32507:         replier.start (broker, username, password, queue, mode);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /** Prints the usage. */
1:3f32507:     private static void printUsage() {
1:3f32507: 
1:3f32507:         StringBuffer use = new StringBuffer();
1:3f32507:         use.append("usage: java Replier (options) ...\n\n");
1:3f32507:         use.append("options:\n");
1:3f32507:         use.append("  -b name:port Specify name:port of broker.\n");
1:3f32507:         use.append("               Default broker: "+DEFAULT_BROKER_NAME+"\n");
1:3f32507:         use.append("  -u name      Specify unique user name.\n");
1:3f32507:         use.append("               Default broker: "+DEFAULT_USER_NAME+"\n");
1:3f32507:         use.append("  -p password  Specify password for user.\n");
1:3f32507:         use.append("               Default password: "+DEFAULT_PASSWORD+"\n");
1:3f32507:         use.append("  -m mode      Replier operating mode - uppercase or lowercase.\n");
1:3f32507:         use.append("               Default mode: "+DEFAULT_MODE+"\n");
1:3f32507:         use.append("  -qr queue    Specify name of queue for receiving.\n");
1:3f32507:         use.append("               Default queue: "+DEFAULT_QUEUE+"\n");
1:3f32507:         use.append("  -h           This help screen.\n");
1:3f32507:         System.err.println (use);
1:3f32507:     }
1:3f32507: 
1:3f32507: }
1:3f32507: 
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:3f32507
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * ? 2001-2009, Progress Software Corporation and/or its subsidiaries or affiliates.  All rights reserved.
1:  *
1:  * Licensed under the Apache License, Version 2.0 (the "License");
1:  * you may not use this file except in compliance with the License.
1:  * You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  
1: Sample Application
1: 
1: Writing a Basic JMS Application with Point-to-Point Queues,
1: using:
1:     - Synchronous Request/Reply
1:     - javax.jms.QueueRequestor class
1:     - JMSReplyTo Header
1: 
1: When this program runs, it waits for messages on the queue,
1: "SampleQ1" (by default).
1: When that message arrives, a response based on the request
1: is sent back to the "Requestor" specified in the JMSReplyTo header.
1: 
1: This sample replies with a simple text manipulation of the request;
1: the text is either folded to all UPPERCASE or all lowercase.
1: 
1: Usage:
1:   java Replier -b <broker:port> -u <username> -p <password> -qr <queue> -m <code>
1:       -b broker:port points to your message broker
1:                      Default: tcp://localhost:61616
1:       -u username    must be unique (but is not checked)
1:                      Default: SampleReplier
1:       -p password    password for user (not checked)
1:                      Default: password
1:       -qr queue      name of queue for receiving requests
1:                      Default:  Q1
1:       -m mode        replier mode (uppercase, or lowercase)
1:                      Default: uppercase
1: 
1: Suggested demonstration:
1:   - In a console window with the environment set,
1:     start a copy of the Replier. For example:
1:        java Replier -u SampleQReplier
1:   - In another console window, start a Requestor.
1:     For example:
1:        java Requestor -u SampleQRequestor
1:   - Enter text in the Requestor window then press Enter.
1:     The Replier responds with the message in all uppercase characters.
1:   - Start other Requestors with different user names to see that
1:     replies are not broadcast to all users. For example:
1:        java Requestor -u SampleRequestorFoo
1: 
1:   - Start other Repliers.
1:   - See that only one replier is receiving messages,(as it should).
1:   - See the Requestor only receives one response.
1:        java Replier -u toLower -m lowercase
1: 
1:  */
1: import org.apache.activemq.*;
1: 
1: 
1: public class Replier
1:     implements javax.jms.MessageListener
1: {
1:     private static final String DEFAULT_BROKER_NAME = "tcp://localhost:61616";
1:     private static final String DEFAULT_USER_NAME = "SampleReplier";
1:     private static final String DEFAULT_PASSWORD = "password";
1:     private static final String DEFAULT_QUEUE = "Q1";
1:     private static final String DEFAULT_MODE = "uppercase";
1:     private static final int UPPERCASE = 0;
1:     private static final int LOWERCASE = 1;
1: 
1:     private javax.jms.Connection connect = null;
1:     private javax.jms.Session session = null;
1:     private javax.jms.MessageProducer replier = null;
1: 
1:     private int imode = UPPERCASE;
1: 
1:     /** Create JMS client for sending and receiving messages. */
1:     private void start ( String broker, String username, String password, String rQueue, String mode)
1:     {
1:         // Set the operation mode
1:         imode = (mode.equals("uppercase")) ? UPPERCASE : LOWERCASE;
1: 
1:         // Create a connection.
1:         try
1:         {
1:             javax.jms.ConnectionFactory factory;
1:             factory = new ActiveMQConnectionFactory(username, password, broker);
1:             connect = factory.createConnection (username, password);
1:             session = connect.createSession(true, javax.jms.Session.AUTO_ACKNOWLEDGE);
1:         }
1:         catch (javax.jms.JMSException jmse)
1:         {
1:             System.err.println("error: Cannot connect to Broker - " + broker);
1:             jmse.printStackTrace();
1:             System.exit(1);
1:         }
1: 
1:         // Create Receivers to application queues as well as a Sender
1:         // to use for JMS replies.
1:         try
1:         {
1:             javax.jms.Queue queue = session.createQueue (rQueue);
1:             javax.jms.MessageConsumer receiver = session.createConsumer(queue);
1:             receiver.setMessageListener(this);
1:             replier = session.createProducer(null);  // Queue will be set for each reply
1:             // Now that all setup is complete, start the Connection
1:             connect.start();
1:         }
1:         catch (javax.jms.JMSException jmse)
1:         {
1:             jmse.printStackTrace();
1:             exit();
1:         }
1: 
1:         try
1:         {
1:             // Read standard input waiting for "EXIT" command.
1:             java.io.BufferedReader stdin =
1:                 new java.io.BufferedReader( new java.io.InputStreamReader( System.in ) );
1:             while ( true )
1:             {
1:                    System.out.println ("\nReplier application:\n"
1: 			            					+ "============================\n"
1: 			            					+ "The application user " + username + " connects to the broker at " + DEFAULT_BROKER_NAME + ".\n"
1: 											+ "The application gets requests with JMSReplyTo set on the " + DEFAULT_QUEUE + " queue."
1: 											+ "The message is transformed to all uppercase or all lowercase, and then returned to the requestor."
1: 			                                + "The Requestor application displays the result.\n\n"
1: 			                                + "Enter EXIT or press Ctrl+C to close the Replier.\n");
1:                 String s = stdin.readLine();
1:                 if ( s == null || s.equalsIgnoreCase("EXIT"))
1:                 {
1:                     System.out.println ("\nStopping Replier. Please wait..\n>");
1:                     exit();
1:                 }
1:            }
1:         }
1:         catch ( java.io.IOException ioe )
1:         {
1:             ioe.printStackTrace();
1:         }
1:     }
1: 
1:     /**
1:      * Handle the message.
1:      * (as specified in the javax.jms.MessageListener interface).
1:      *
1:      * IMPORTANT NOTES:
1:      * (1)We must follow the design paradigm for JMS
1:      *    synchronous requests.  That is, we must:
1:      *     - get the message
1:      *     - look for the header specifying JMSReplyTo
1:      *     - send a reply to the queue specified there.
1:      *    Failing to follow these steps might leave the originator
1:      *    of the request waiting forever.
1:      * (2)Unlike the 'Talk' sample and others using an asynchronous
1:      *    message listener, it is possible here to use ONLY
1:      *    ONE SESSION because the messages being sent are sent from
1:      *    the same thread of control handling message delivery. For
1:      *    more information see the JMS spec v1.0.2 section 4.4.6.
1:      *
1:      * OPTIONAL BEHAVIOR: The following actions taken by the
1:      * message handler represent good programming style, but are
1:      * not required by the design paradigm for JMS requests.
1:      *   - set the JMSCorrelationID (tying the response back to
1:      *     the original request.
1:      *   - use transacted session "commit" so receipt of request
1:      *     won't happen without the reply being sent.
1:      *
1:      */
1:     public void onMessage( javax.jms.Message aMessage)
1:     {
1:         try
1:         {
1:             // Cast the message as a text message.
1:             javax.jms.TextMessage textMessage = (javax.jms.TextMessage) aMessage;
1: 
1:             // This handler reads a single String from the
1:             // message and prints it to the standard output.
1:             try
1:             {
1:                 String string = textMessage.getText();
1:                 System.out.println( "[Request] " + string );
1: 
1:                 // Check for a ReplyTo Queue
1:                 javax.jms.Queue replyQueue = (javax.jms.Queue) aMessage.getJMSReplyTo();
1:                 if (replyQueue != null)
1:                 {
1:                     // Send the modified message back.
1:                     javax.jms.TextMessage reply =  session.createTextMessage();
1:                     if (imode == UPPERCASE)
1:                         reply.setText("Uppercasing-" + string.toUpperCase());
1:                     else
1:                         reply.setText("Lowercasing-" + string.toLowerCase());
1:                     reply.setJMSCorrelationID(aMessage.getJMSMessageID());
1:                     replier.send (replyQueue, reply);
1:                     session.commit();
1:                 }
1:             }
1:             catch (javax.jms.JMSException jmse)
1:             {
1:                 jmse.printStackTrace();
1:             }
1:         }
1:         catch (java.lang.RuntimeException rte)
1:         {
1:             rte.printStackTrace();
1:         }
1:     }
1: 
1:     /** Cleanup resources cleanly and exit. */
1:     private void exit()
1:     {
1:         try
1:         {
1:             connect.close();
1:         }
1:         catch (javax.jms.JMSException jmse)
1:         {
1:             jmse.printStackTrace();
1:         }
1: 
1:         System.exit(0);
1:     }
1: 
1:     //
1:     // NOTE: the remainder of this sample deals with reading arguments
1:     // and does not utilize any JMS classes or code.
1:     //
1: 
1:     /** Main program entry point. */
1:     public static void main(String argv[]) {
1: 
1:         // Values to be read from parameters
1:         String broker    = DEFAULT_BROKER_NAME;
1:         String username  = DEFAULT_USER_NAME;
1:         String password  = DEFAULT_PASSWORD;
1:         String queue     = DEFAULT_QUEUE;
1:         String mode      = DEFAULT_MODE;
1: 
1:         // Check parameters
1:         for (int i = 0; i < argv.length; i++) {
1:             String arg = argv[i];
1: 
1: 
1:             if (arg.equals("-b")) {
1:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:                     System.err.println("error: missing broker name:port");
1:                     System.exit(1);
1:                 }
1:                 broker = argv[++i];
1:                 continue;
1:             }
1: 
1:             if (arg.equals("-u")) {
1:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:                     System.err.println("error: missing user name");
1:                     System.exit(1);
1:                 }
1:                 username = argv[++i];
1:                 continue;
1:             }
1: 
1:             if (arg.equals("-p")) {
1:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:                     System.err.println("error: missing password");
1:                     System.exit(1);
1:                 }
1:                 password = argv[++i];
1:                 continue;
1:             }
1: 
1:             if (arg.equals("-qr")) {
1:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:                     System.err.println("error: missing queue");
1:                     System.exit(1);
1:                 }
1:                 queue = argv[++i];
1:                 continue;
1:             }
1: 
1:             if (arg.equals("-m")) {
1:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
1:                     System.err.println("error: missing mode");
1:                     System.exit(1);
1:                 }
1:                 mode = argv[++i];
1:                 if (!(mode.equals("uppercase") || mode.equals("lowercase"))) {
1:                     System.err.println("error: mode must be 'uppercase' or 'lowercase'");
1:                     System.exit(1);
1:                 }
1:                 continue;
1:             }
1: 
1:             if (arg.equals("-h")) {
1:                 printUsage();
1:                 System.exit(1);
1:             }
1: 
1:             // Invalid argument
1:             System.err.println ("error: unexpected argument: "+arg);
1:             printUsage();
1:             System.exit(1);
1:         }
1: 
1:         // Start the JMS client.
1:         Replier replier = new Replier ();
1:         replier.start (broker, username, password, queue, mode);
1:     }
1: 
1:     /** Prints the usage. */
1:     private static void printUsage() {
1: 
1:         StringBuffer use = new StringBuffer();
1:         use.append("usage: java Replier (options) ...\n\n");
1:         use.append("options:\n");
1:         use.append("  -b name:port Specify name:port of broker.\n");
1:         use.append("               Default broker: "+DEFAULT_BROKER_NAME+"\n");
1:         use.append("  -u name      Specify unique user name.\n");
1:         use.append("               Default broker: "+DEFAULT_USER_NAME+"\n");
1:         use.append("  -p password  Specify password for user.\n");
1:         use.append("               Default password: "+DEFAULT_PASSWORD+"\n");
1:         use.append("  -m mode      Replier operating mode - uppercase or lowercase.\n");
1:         use.append("               Default mode: "+DEFAULT_MODE+"\n");
1:         use.append("  -qr queue    Specify name of queue for receiving.\n");
1:         use.append("               Default queue: "+DEFAULT_QUEUE+"\n");
1:         use.append("  -h           This help screen.\n");
1:         System.err.println (use);
1:     }
1: 
1: }
1: 
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:2ecf41d
/////////////////////////////////////////////////////////////////////////
0: /*
0:  * ? 2001-2009, Progress Software Corporation and/or its subsidiaries or affiliates.  All rights reserved.
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  
0: Sample Application
0: 
0: Writing a Basic JMS Application with Point-to-Point Queues,
0: using:
0:     - Synchronous Request/Reply
0:     - javax.jms.QueueRequestor class
0:     - JMSReplyTo Header
0: 
0: When this program runs, it waits for messages on the queue,
0: "SampleQ1" (by default).
0: When that message arrives, a response based on the request
0: is sent back to the "Requestor" specified in the JMSReplyTo header.
0: 
0: This sample replies with a simple text manipulation of the request;
0: the text is either folded to all UPPERCASE or all lowercase.
0: 
0: Usage:
0:   java Replier -b <broker:port> -u <username> -p <password> -qr <queue> -m <code>
0:       -b broker:port points to your message broker
0:                      Default: tcp://localhost:61616
0:       -u username    must be unique (but is not checked)
0:                      Default: SampleReplier
0:       -p password    password for user (not checked)
0:                      Default: password
0:       -qr queue      name of queue for receiving requests
0:                      Default:  Q1
0:       -m mode        replier mode (uppercase, or lowercase)
0:                      Default: uppercase
0: 
0: Suggested demonstration:
0:   - In a console window with the environment set,
0:     start a copy of the Replier. For example:
0:        java Replier -u SampleQReplier
0:   - In another console window, start a Requestor.
0:     For example:
0:        java Requestor -u SampleQRequestor
0:   - Enter text in the Requestor window then press Enter.
0:     The Replier responds with the message in all uppercase characters.
0:   - Start other Requestors with different user names to see that
0:     replies are not broadcast to all users. For example:
0:        java Requestor -u SampleRequestorFoo
0: 
0:   - Start other Repliers.
0:   - See that only one replier is receiving messages,(as it should).
0:   - See the Requestor only receives one response.
0:        java Replier -u toLower -m lowercase
0: 
0:  */
0: import org.apache.activemq.*;
0: 
0: 
0: public class Replier
0:     implements javax.jms.MessageListener
0: {
0:     private static final String DEFAULT_BROKER_NAME = "tcp://localhost:61616";
0:     private static final String DEFAULT_USER_NAME = "SampleReplier";
0:     private static final String DEFAULT_PASSWORD = "password";
0:     private static final String DEFAULT_QUEUE = "Q1";
0:     private static final String DEFAULT_MODE = "uppercase";
0:     private static final int UPPERCASE = 0;
0:     private static final int LOWERCASE = 1;
0: 
0:     private javax.jms.Connection connect = null;
0:     private javax.jms.Session session = null;
0:     private javax.jms.MessageProducer replier = null;
0: 
0:     private int imode = UPPERCASE;
0: 
0:     /** Create JMS client for sending and receiving messages. */
0:     private void start ( String broker, String username, String password, String rQueue, String mode)
0:     {
0:         // Set the operation mode
0:         imode = (mode.equals("uppercase")) ? UPPERCASE : LOWERCASE;
0: 
0:         // Create a connection.
0:         try
0:         {
0:             javax.jms.ConnectionFactory factory;
0:             factory = new ActiveMQConnectionFactory(username, password, broker);
0:             connect = factory.createConnection (username, password);
0:             session = connect.createSession(true, javax.jms.Session.AUTO_ACKNOWLEDGE);
0:         }
0:         catch (javax.jms.JMSException jmse)
0:         {
0:             System.err.println("error: Cannot connect to Broker - " + broker);
0:             jmse.printStackTrace();
0:             System.exit(1);
0:         }
0: 
0:         // Create Receivers to application queues as well as a Sender
0:         // to use for JMS replies.
0:         try
0:         {
0:             javax.jms.Queue queue = session.createQueue (rQueue);
0:             javax.jms.MessageConsumer receiver = session.createConsumer(queue);
0:             receiver.setMessageListener(this);
0:             replier = session.createProducer(null);  // Queue will be set for each reply
0:             // Now that all setup is complete, start the Connection
0:             connect.start();
0:         }
0:         catch (javax.jms.JMSException jmse)
0:         {
0:             jmse.printStackTrace();
0:             exit();
0:         }
0: 
0:         try
0:         {
0:             // Read standard input waiting for "EXIT" command.
0:             java.io.BufferedReader stdin =
0:                 new java.io.BufferedReader( new java.io.InputStreamReader( System.in ) );
0:             while ( true )
0:             {
0:                    System.out.println ("\nReplier application:\n"
0: 			            					+ "============================\n"
0: 			            					+ "The application user " + username + " connects to the broker at " + DEFAULT_BROKER_NAME + ".\n"
0: 											+ "The application gets requests with JMSReplyTo set on the " + DEFAULT_QUEUE + " queue."
0: 											+ "The message is transformed to all uppercase or all lowercase, and then returned to the requestor."
0: 			                                + "The Requestor application displays the result.\n\n"
0: 			                                + "Enter EXIT or press Ctrl+C to close the Replier.\n");
0:                 String s = stdin.readLine();
0:                 if ( s == null || s.equalsIgnoreCase("EXIT"))
0:                 {
0:                     System.out.println ("\nStopping Replier. Please wait..\n>");
0:                     exit();
0:                 }
0:            }
0:         }
0:         catch ( java.io.IOException ioe )
0:         {
0:             ioe.printStackTrace();
0:         }
0:     }
0: 
0:     /**
0:      * Handle the message.
0:      * (as specified in the javax.jms.MessageListener interface).
0:      *
0:      * IMPORTANT NOTES:
0:      * (1)We must follow the design paradigm for JMS
0:      *    synchronous requests.  That is, we must:
0:      *     - get the message
0:      *     - look for the header specifying JMSReplyTo
0:      *     - send a reply to the queue specified there.
0:      *    Failing to follow these steps might leave the originator
0:      *    of the request waiting forever.
0:      * (2)Unlike the 'Talk' sample and others using an asynchronous
0:      *    message listener, it is possible here to use ONLY
0:      *    ONE SESSION because the messages being sent are sent from
0:      *    the same thread of control handling message delivery. For
0:      *    more information see the JMS spec v1.0.2 section 4.4.6.
0:      *
0:      * OPTIONAL BEHAVIOR: The following actions taken by the
0:      * message handler represent good programming style, but are
0:      * not required by the design paradigm for JMS requests.
0:      *   - set the JMSCorrelationID (tying the response back to
0:      *     the original request.
0:      *   - use transacted session "commit" so receipt of request
0:      *     won't happen without the reply being sent.
0:      *
0:      */
0:     public void onMessage( javax.jms.Message aMessage)
0:     {
0:         try
0:         {
0:             // Cast the message as a text message.
0:             javax.jms.TextMessage textMessage = (javax.jms.TextMessage) aMessage;
0: 
0:             // This handler reads a single String from the
0:             // message and prints it to the standard output.
0:             try
0:             {
0:                 String string = textMessage.getText();
0:                 System.out.println( "[Request] " + string );
0: 
0:                 // Check for a ReplyTo Queue
0:                 javax.jms.Queue replyQueue = (javax.jms.Queue) aMessage.getJMSReplyTo();
0:                 if (replyQueue != null)
0:                 {
0:                     // Send the modified message back.
0:                     javax.jms.TextMessage reply =  session.createTextMessage();
0:                     if (imode == UPPERCASE)
0:                         reply.setText("Uppercasing-" + string.toUpperCase());
0:                     else
0:                         reply.setText("Lowercasing-" + string.toLowerCase());
0:                     reply.setJMSCorrelationID(aMessage.getJMSMessageID());
0:                     replier.send (replyQueue, reply);
0:                     session.commit();
0:                 }
0:             }
0:             catch (javax.jms.JMSException jmse)
0:             {
0:                 jmse.printStackTrace();
0:             }
0:         }
0:         catch (java.lang.RuntimeException rte)
0:         {
0:             rte.printStackTrace();
0:         }
0:     }
0: 
0:     /** Cleanup resources cleanly and exit. */
0:     private void exit()
0:     {
0:         try
0:         {
0:             connect.close();
0:         }
0:         catch (javax.jms.JMSException jmse)
0:         {
0:             jmse.printStackTrace();
0:         }
0: 
0:         System.exit(0);
0:     }
0: 
0:     //
0:     // NOTE: the remainder of this sample deals with reading arguments
0:     // and does not utilize any JMS classes or code.
0:     //
0: 
0:     /** Main program entry point. */
0:     public static void main(String argv[]) {
0: 
0:         // Values to be read from parameters
0:         String broker    = DEFAULT_BROKER_NAME;
0:         String username  = DEFAULT_USER_NAME;
0:         String password  = DEFAULT_PASSWORD;
0:         String queue     = DEFAULT_QUEUE;
0:         String mode      = DEFAULT_MODE;
0: 
0:         // Check parameters
0:         for (int i = 0; i < argv.length; i++) {
0:             String arg = argv[i];
0: 
0: 
0:             if (arg.equals("-b")) {
0:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
0:                     System.err.println("error: missing broker name:port");
0:                     System.exit(1);
0:                 }
0:                 broker = argv[++i];
0:                 continue;
0:             }
0: 
0:             if (arg.equals("-u")) {
0:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
0:                     System.err.println("error: missing user name");
0:                     System.exit(1);
0:                 }
0:                 username = argv[++i];
0:                 continue;
0:             }
0: 
0:             if (arg.equals("-p")) {
0:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
0:                     System.err.println("error: missing password");
0:                     System.exit(1);
0:                 }
0:                 password = argv[++i];
0:                 continue;
0:             }
0: 
0:             if (arg.equals("-qr")) {
0:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
0:                     System.err.println("error: missing queue");
0:                     System.exit(1);
0:                 }
0:                 queue = argv[++i];
0:                 continue;
0:             }
0: 
0:             if (arg.equals("-m")) {
0:                 if (i == argv.length - 1 || argv[i+1].startsWith("-")) {
0:                     System.err.println("error: missing mode");
0:                     System.exit(1);
0:                 }
0:                 mode = argv[++i];
0:                 if (!(mode.equals("uppercase") || mode.equals("lowercase"))) {
0:                     System.err.println("error: mode must be 'uppercase' or 'lowercase'");
0:                     System.exit(1);
0:                 }
0:                 continue;
0:             }
0: 
0:             if (arg.equals("-h")) {
0:                 printUsage();
0:                 System.exit(1);
0:             }
0: 
0:             // Invalid argument
0:             System.err.println ("error: unexpected argument: "+arg);
0:             printUsage();
0:             System.exit(1);
0:         }
0: 
0:         // Start the JMS client.
0:         Replier replier = new Replier ();
0:         replier.start (broker, username, password, queue, mode);
0:     }
0: 
0:     /** Prints the usage. */
0:     private static void printUsage() {
0: 
0:         StringBuffer use = new StringBuffer();
0:         use.append("usage: java Replier (options) ...\n\n");
0:         use.append("options:\n");
0:         use.append("  -b name:port Specify name:port of broker.\n");
0:         use.append("               Default broker: "+DEFAULT_BROKER_NAME+"\n");
0:         use.append("  -u name      Specify unique user name.\n");
0:         use.append("               Default broker: "+DEFAULT_USER_NAME+"\n");
0:         use.append("  -p password  Specify password for user.\n");
0:         use.append("               Default password: "+DEFAULT_PASSWORD+"\n");
0:         use.append("  -m mode      Replier operating mode - uppercase or lowercase.\n");
0:         use.append("               Default mode: "+DEFAULT_MODE+"\n");
0:         use.append("  -qr queue    Specify name of queue for receiving.\n");
0:         use.append("               Default queue: "+DEFAULT_QUEUE+"\n");
0:         use.append("  -h           This help screen.\n");
0:         System.err.println (use);
0:     }
0: 
0: }
0: 
============================================================================