1:9c2b1d2: /**
1:9c2b1d2:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9c2b1d2:  * contributor license agreements.  See the NOTICE file distributed with
1:9c2b1d2:  * this work for additional information regarding copyright ownership.
1:9c2b1d2:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9c2b1d2:  * (the "License"); you may not use this file except in compliance with
1:9c2b1d2:  * the License.  You may obtain a copy of the License at
1:9c2b1d2:  *
1:9c2b1d2:  *      http://www.apache.org/licenses/LICENSE-2.0
1:9c2b1d2:  *
1:9c2b1d2:  * Unless required by applicable law or agreed to in writing, software
1:9c2b1d2:  * distributed under the License is distributed on an "AS IS" BASIS,
1:9c2b1d2:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9c2b1d2:  * See the License for the specific language governing permissions and
1:9c2b1d2:  * limitations under the License.
1:9c2b1d2:  */
1:9c2b1d2: package org.apache.activemq.bugs;
4:9c2b1d2: 
1:9c2b1d2: import java.util.ArrayList;
1:9c2b1d2: import java.util.Arrays;
1:9c2b1d2: import java.util.Collections;
1:9c2b1d2: import java.util.HashMap;
1:9c2b1d2: import java.util.List;
1:9c2b1d2: import java.util.Map;
1:9c2b1d2: import java.util.TreeSet;
1:9c2b1d2: import java.util.UUID;
1:9c2b1d2: import java.util.concurrent.CyclicBarrier;
1:9c2b1d2: import java.util.concurrent.TimeUnit;
1:9c2b1d2: import java.util.concurrent.atomic.AtomicBoolean;
1:9c2b1d2: import javax.jms.Message;
1:9c2b1d2: import javax.jms.MessageConsumer;
1:9c2b1d2: import javax.jms.MessageProducer;
1:9c2b1d2: import javax.jms.Queue;
1:9c2b1d2: import javax.jms.QueueConnection;
1:9c2b1d2: import javax.jms.Session;
1:9c2b1d2: import javax.jms.TextMessage;
1:9c2b1d2: import org.apache.activemq.ActiveMQConnection;
1:9c2b1d2: import org.apache.activemq.ActiveMQConnectionFactory;
1:9c2b1d2: import org.apache.activemq.RedeliveryPolicy;
1:3042797: import org.apache.activemq.TestSupport;
1:9c2b1d2: import org.apache.activemq.broker.BrokerService;
1:9c2b1d2: import org.apache.activemq.broker.TransportConnector;
1:9c2b1d2: import org.apache.activemq.broker.region.RegionBroker;
1:9c2b1d2: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:9c2b1d2: import org.apache.activemq.broker.region.policy.PolicyMap;
1:9c2b1d2: import org.apache.activemq.command.ActiveMQQueue;
1:9c2b1d2: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
1:9c2b1d2: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
1:9c2b1d2: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:9c2b1d2: import org.apache.derby.jdbc.EmbeddedDataSource;
1:9c2b1d2: import org.junit.After;
1:9c2b1d2: import org.junit.Before;
1:9c2b1d2: import org.junit.Test;
1:9c2b1d2: import org.junit.runner.RunWith;
1:9c2b1d2: import org.junit.runners.Parameterized;
1:9c2b1d2: import org.slf4j.Logger;
1:9c2b1d2: import org.slf4j.LoggerFactory;
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2: import static org.junit.Assert.assertEquals;
1:9c2b1d2: 
1:9c2b1d2: /*
1:9c2b1d2:  * pause producers if consumers stall and verify broker drained before resume
1:9c2b1d2:  */
1:9c2b1d2: @RunWith(Parameterized.class)
1:9c2b1d2: public class AMQ5266StarvedConsumerTest {
1:9c2b1d2:     static Logger LOG = LoggerFactory.getLogger(AMQ5266StarvedConsumerTest.class);
1:9c2b1d2:     String activemqURL;
1:9c2b1d2:     BrokerService brokerService;
1:9c2b1d2: 
1:9c2b1d2:     public int messageSize = 1000;
1:9c2b1d2: 
1:9c2b1d2:     @Parameterized.Parameter(0)
1:9c2b1d2:     public int publisherMessagesPerThread = 1000;
1:9c2b1d2: 
1:9c2b1d2:     @Parameterized.Parameter(1)
1:9c2b1d2:     public int publisherThreadCount = 20;
1:9c2b1d2: 
1:9c2b1d2:     @Parameterized.Parameter(2)
1:9c2b1d2:     public int consumerThreadsPerQueue = 5;
1:9c2b1d2: 
1:9c2b1d2:     @Parameterized.Parameter(3)
1:9c2b1d2:     public int destMemoryLimit = 50 * 1024;
1:9c2b1d2: 
1:9c2b1d2:     @Parameterized.Parameter(4)
1:9c2b1d2:     public boolean useCache = true;
1:9c2b1d2: 
1:9c2b1d2:     @Parameterized.Parameter(5)
1:3042797:     public TestSupport.PersistenceAdapterChoice persistenceAdapterChoice = TestSupport.PersistenceAdapterChoice.KahaDB;
1:9c2b1d2: 
1:9c2b1d2:     @Parameterized.Parameter(6)
1:9c2b1d2:     public boolean optimizeDispatch = false;
1:9c2b1d2:     private  AtomicBoolean didNotReceive = new AtomicBoolean(false);
1:9c2b1d2: 
1:3042797:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},store:{5},optimizedDispatch:{6}")
1:9c2b1d2:     public static Iterable<Object[]> parameters() {
1:9c2b1d2:         return Arrays.asList(new Object[][]{
1:3042797:                 {1000, 40,  5,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.KahaDB, true},
1:3042797:                 {1000, 40,  5,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.LevelDB, true},
1:3042797:                 {1000, 40,  5,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.JDBC, true},
1:3042797: 
1:3042797:                 {500, 20,  20,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.KahaDB, true},
1:3042797:                 {500, 20,  20,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.LevelDB, true},
1:3042797:                 {500, 20,  20,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.JDBC, true},
1:9c2b1d2:         });
4:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     public int consumerBatchSize = 5;
1:9c2b1d2: 
1:9c2b1d2:     @Before
1:9c2b1d2:     public void startBroker() throws Exception {
1:9c2b1d2:         brokerService = new BrokerService();
1:3042797:         TestSupport.setPersistenceAdapter(brokerService, persistenceAdapterChoice);
1:9c2b1d2:         brokerService.setDeleteAllMessagesOnStartup(true);
1:9c2b1d2:         brokerService.setUseJmx(false);
1:9c2b1d2:         brokerService.setAdvisorySupport(false);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         PolicyMap policyMap = new PolicyMap();
1:9c2b1d2:         PolicyEntry defaultEntry = new PolicyEntry();
1:9c2b1d2:         defaultEntry.setUseConsumerPriority(false); // java.lang.IllegalArgumentException: Comparison method violates its general contract!
1:9c2b1d2:         defaultEntry.setMaxAuditDepth(publisherThreadCount);
1:9c2b1d2:         defaultEntry.setEnableAudit(true);
1:9c2b1d2:         defaultEntry.setUseCache(useCache);
1:9c2b1d2:         defaultEntry.setMaxPageSize(1000);
1:9c2b1d2:         defaultEntry.setOptimizedDispatch(optimizeDispatch);
1:9c2b1d2:         defaultEntry.setMemoryLimit(destMemoryLimit);
1:9c2b1d2:         defaultEntry.setExpireMessagesPeriod(0);
1:9c2b1d2:         policyMap.setDefaultEntry(defaultEntry);
1:9c2b1d2:         brokerService.setDestinationPolicy(policyMap);
1:9c2b1d2: 
1:9c2b1d2:         brokerService.getSystemUsage().getMemoryUsage().setLimit(512 * 1024 * 1024);
1:9c2b1d2: 
1:9c2b1d2:         TransportConnector transportConnector = brokerService.addConnector("tcp://0.0.0.0:0");
1:9c2b1d2:         brokerService.start();
1:9c2b1d2:         activemqURL = transportConnector.getPublishableConnectString();
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     @After
1:9c2b1d2:     public void stopBroker() throws Exception {
1:9c2b1d2:         if (brokerService != null) {
1:9c2b1d2:             brokerService.stop();
1:9c2b1d2:         }
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     CyclicBarrier globalProducerHalt = new CyclicBarrier(publisherThreadCount, new Runnable() {
1:9c2b1d2:         @Override
1:9c2b1d2:         public void run() {
1:9c2b1d2:             // wait for queue size to go to zero
2:9c2b1d2:             try {
1:9c2b1d2:                 while (((RegionBroker)brokerService.getRegionBroker()).getDestinationStatistics().getMessages().getCount() > 0) {
1:9c2b1d2:                     LOG.info("Total messageCount: " + ((RegionBroker)brokerService.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:9c2b1d2:                     TimeUnit.SECONDS.sleep(5);
1:9c2b1d2:                 }
1:9c2b1d2:             } catch (Exception ignored) {
1:9c2b1d2:                 ignored.printStackTrace();
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2:     });
1:9c2b1d2: 
1:9c2b1d2:     @Test(timeout = 30 * 60 * 1000)
1:9c2b1d2:     public void test() throws Exception {
1:9c2b1d2: 
1:9c2b1d2:         String activemqQueues = "activemq,activemq2,activemq3,activemq4";//,activemq5,activemq6,activemq7,activemq8,activemq9";
1:9c2b1d2: 
1:9c2b1d2:         int consumerWaitForConsumption = 5 * 60 * 1000;
1:9c2b1d2: 
1:9c2b1d2:         ExportQueuePublisher publisher = null;
1:9c2b1d2:         ExportQueueConsumer consumer = null;
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("Publisher will publish " + (publisherMessagesPerThread * publisherThreadCount) + " messages to each queue specified.");
1:9c2b1d2:         LOG.info("\nBuilding Publisher...");
1:9c2b1d2: 
1:9c2b1d2:         publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("Building Consumer...");
1:9c2b1d2: 
1:9c2b1d2:         consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("Starting Publisher...");
1:9c2b1d2: 
1:9c2b1d2:         publisher.start();
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("Starting Consumer...");
1:9c2b1d2: 
1:9c2b1d2:         consumer.start();
1:9c2b1d2: 
1:9c2b1d2:         int distinctPublishedCount = 0;
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("Waiting For Publisher Completion...");
1:9c2b1d2: 
1:9c2b1d2:         publisher.waitForCompletion();
1:9c2b1d2: 
1:9c2b1d2:         List publishedIds = publisher.getIDs();
1:9c2b1d2:         distinctPublishedCount = new TreeSet(publishedIds).size();
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("Publisher Complete. Published: " + publishedIds.size() + ", Distinct IDs Published: " + distinctPublishedCount);
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         long endWait = System.currentTimeMillis() + consumerWaitForConsumption;
1:9c2b1d2:         while (!consumer.completed() && System.currentTimeMillis() < endWait) {
1:9c2b1d2:             try {
1:9c2b1d2:                 int secs = (int) (endWait - System.currentTimeMillis()) / 1000;
1:9c2b1d2:                 LOG.info("Waiting For Consumer Completion. Time left: " + secs + " secs");
1:9c2b1d2:                 Thread.sleep(10000);
1:9c2b1d2:             } catch (Exception e) {
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("\nConsumer Complete: " + consumer.completed() +", Shutting Down.");
1:9c2b1d2: 
1:9c2b1d2:         consumer.shutdown();
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:         LOG.info("Consumer Stats:");
1:9c2b1d2: 
1:9c2b1d2:         for (Map.Entry<String, List<String>> entry : consumer.getIDs().entrySet()) {
1:9c2b1d2: 
1:9c2b1d2:             List<String> idList = entry.getValue();
1:9c2b1d2: 
1:9c2b1d2:             int distinctConsumed = new TreeSet<String>(idList).size();
1:9c2b1d2: 
1:9c2b1d2:             StringBuilder sb = new StringBuilder();
1:9c2b1d2:             sb.append("   Queue: " + entry.getKey() +
1:9c2b1d2:                     " -> Total Messages Consumed: " + idList.size() +
1:9c2b1d2:                     ", Distinct IDs Consumed: " + distinctConsumed);
1:9c2b1d2: 
1:9c2b1d2:             int diff = distinctPublishedCount - distinctConsumed;
1:9c2b1d2:             sb.append(" ( " + (diff > 0 ? diff : "NO") + " STUCK MESSAGES " + " ) ");
1:9c2b1d2:             LOG.info(sb.toString());
1:9c2b1d2: 
1:9c2b1d2:             assertEquals("expect to get all messages!", 0, diff);
1:9c2b1d2: 
1:9c2b1d2:         }
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     public class ExportQueuePublisher {
1:9c2b1d2: 
1:9c2b1d2:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:9c2b1d2:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:9c2b1d2:         private ActiveMQConnectionFactory connectionFactory = null;
1:9c2b1d2:         private String activemqURL = null;
1:9c2b1d2:         private String activemqQueues = null;
1:9c2b1d2:         // Collection of distinct IDs that the publisher has published.
1:9c2b1d2:         // After a message is published, its UUID will be written to this list for tracking.
1:9c2b1d2:         // This list of IDs (or distinct count) will be used to compare to the consumed list of IDs.
1:9c2b1d2:         //private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
1:9c2b1d2:         private List<String> ids = Collections.synchronizedList(new ArrayList<String>());
1:9c2b1d2:         private List<PublisherThread> threads;
1:9c2b1d2: 
1:9c2b1d2:         public ExportQueuePublisher(String activemqURL, String activemqQueues, int messagesPerThread, int threadCount) throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             this.activemqURL = activemqURL;
1:9c2b1d2:             this.activemqQueues = activemqQueues;
1:9c2b1d2: 
1:9c2b1d2:             threads = new ArrayList<PublisherThread>();
1:9c2b1d2: 
1:9c2b1d2:             // Build the threads and tell them how many messages to publish
1:9c2b1d2:             for (int i = 0; i < threadCount; i++) {
1:9c2b1d2:                 PublisherThread pt = new PublisherThread(messagesPerThread);
1:9c2b1d2:                 threads.add(pt);
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         public List<String> getIDs() {
1:9c2b1d2:             return ids;
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         // Kick off threads
1:9c2b1d2:         public void start() throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             for (PublisherThread pt : threads) {
1:9c2b1d2:                 pt.start();
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         // Wait for threads to complete. They will complete once they've published all of their messages.
1:9c2b1d2:         public void waitForCompletion() throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             for (PublisherThread pt : threads) {
1:9c2b1d2:                 pt.join();
1:9c2b1d2:                 pt.close();
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:9c2b1d2:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         private synchronized QueueConnection newQueueConnection() throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             if (connectionFactory == null) {
1:9c2b1d2:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:9c2b1d2:                 connectionFactory.setWatchTopicAdvisories(false);
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:9c2b1d2:             // after the queue has had a certain number of failures (default is 6)
1:9c2b1d2:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:9c2b1d2:             policy.setMaximumRedeliveries(-1);
1:9c2b1d2: 
1:9c2b1d2:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:9c2b1d2:             amqConnection.start();
1:9c2b1d2:             return amqConnection;
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         private class PublisherThread extends Thread {
1:9c2b1d2: 
1:9c2b1d2:             private int count;
1:9c2b1d2:             private QueueConnection qc;
1:9c2b1d2:             private Session session;
1:9c2b1d2:             private MessageProducer mp;
1:9c2b1d2:             private Queue q;
1:9c2b1d2: 
1:9c2b1d2:             private PublisherThread(int count) throws Exception {
1:9c2b1d2: 
1:9c2b1d2:                 this.count = count;
1:9c2b1d2: 
1:9c2b1d2:                 // Each Thread has its own Connection and Session, so no sync worries
1:9c2b1d2:                 qc = newQueueConnection();
1:9c2b1d2:                 session = newSession(qc);
1:9c2b1d2: 
1:9c2b1d2:                 // In our code, when publishing to multiple queues,
1:9c2b1d2:                 // we're using composite destinations like below
1:9c2b1d2:                 q = new ActiveMQQueue(activemqQueues);
1:9c2b1d2:                 mp = session.createProducer(null);
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             public void run() {
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2: 
1:9c2b1d2:                     // Loop until we've published enough messages
1:9c2b1d2:                     while (count-- > 0) {
1:9c2b1d2: 
1:9c2b1d2:                         TextMessage tm = session.createTextMessage(getMessageText());
1:9c2b1d2:                         String id = UUID.randomUUID().toString();
1:9c2b1d2:                         tm.setStringProperty("KEY", id);
1:9c2b1d2:                         ids.add(id);                            // keep track of the key to compare against consumer
1:9c2b1d2: 
1:9c2b1d2:                         mp.send(q, tm);
1:9c2b1d2:                         session.commit();
1:9c2b1d2: 
1:9c2b1d2:                         if (didNotReceive.get()) {
1:9c2b1d2:                             globalProducerHalt.await();
1:9c2b1d2:                         }
1:9c2b1d2:                     }
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2:                     e.printStackTrace();
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             // Called by waitForCompletion
1:9c2b1d2:             public void close() {
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2:                     mp.close();
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2:                 }
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2:                     session.close();
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2:                 }
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2:                     qc.close();
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2:     String messageText;
1:9c2b1d2:     private String getMessageText() {
1:9c2b1d2: 
1:9c2b1d2:         if (messageText == null) {
1:9c2b1d2: 
1:9c2b1d2:             synchronized (this) {
1:9c2b1d2: 
1:9c2b1d2:                 if (messageText == null) {
1:9c2b1d2: 
1:9c2b1d2:                     StringBuilder sb = new StringBuilder();
1:9c2b1d2:                     for (int i = 0; i < messageSize; i++) {
1:9c2b1d2:                         sb.append("X");
1:9c2b1d2:                     }
1:9c2b1d2:                     messageText = sb.toString();
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         return messageText;
1:9c2b1d2:     }
1:9c2b1d2: 
1:9c2b1d2: 
1:9c2b1d2:     public class ExportQueueConsumer {
1:9c2b1d2: 
1:9c2b1d2:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:9c2b1d2:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:9c2b1d2:         private final int totalToExpect;
1:9c2b1d2:         private ActiveMQConnectionFactory connectionFactory = null;
1:9c2b1d2:         private String activemqURL = null;
1:9c2b1d2:         private String activemqQueues = null;
1:9c2b1d2:         private String[] queues = null;
1:9c2b1d2:         // Map of IDs that were consumed, keyed by queue name.
1:9c2b1d2:         // We'll compare these against what was published to know if any got stuck or dropped.
1:9c2b1d2:         private Map<String, List<String>> idsByQueue = new HashMap<String, List<String>>();
1:9c2b1d2:         private Map<String, List<ConsumerThread>> threads;
1:9c2b1d2: 
1:9c2b1d2:         public ExportQueueConsumer(String activemqURL, String activemqQueues, int threadsPerQueue, int batchSize, int totalToExpect) throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             this.activemqURL = activemqURL;
1:9c2b1d2:             this.activemqQueues = activemqQueues;
1:9c2b1d2:             this.totalToExpect = totalToExpect;
1:9c2b1d2: 
1:9c2b1d2:             queues = this.activemqQueues.split(",");
1:9c2b1d2: 
1:9c2b1d2:             for (int i = 0; i < queues.length; i++) {
1:9c2b1d2:                 queues[i] = queues[i].trim();
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             threads = new HashMap<String, List<ConsumerThread>>();
1:9c2b1d2: 
1:9c2b1d2:             // For each queue, create a list of threads and set up the list of ids
1:9c2b1d2:             for (String q : queues) {
1:9c2b1d2: 
1:9c2b1d2:                 List<ConsumerThread> list = new ArrayList<ConsumerThread>();
1:9c2b1d2: 
1:9c2b1d2:                 idsByQueue.put(q, Collections.synchronizedList(new ArrayList<String>()));
1:9c2b1d2: 
1:9c2b1d2:                 for (int i = 0; i < threadsPerQueue; i++) {
1:9c2b1d2:                     list.add(new ConsumerThread(q, batchSize));
1:9c2b1d2:                 }
1:9c2b1d2: 
1:9c2b1d2:                 threads.put(q, list);
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         public Map<String, List<String>> getIDs() {
1:9c2b1d2:             return idsByQueue;
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         // Start the threads
1:9c2b1d2:         public void start() throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             for (List<ConsumerThread> list : threads.values()) {
1:9c2b1d2: 
1:9c2b1d2:                 for (ConsumerThread ct : list) {
1:9c2b1d2: 
1:9c2b1d2:                     ct.start();
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         // Tell the threads to stop
1:9c2b1d2:         // Then wait for them to stop
1:9c2b1d2:         public void shutdown() throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             for (List<ConsumerThread> list : threads.values()) {
1:9c2b1d2: 
1:9c2b1d2:                 for (ConsumerThread ct : list) {
1:9c2b1d2: 
1:9c2b1d2:                     ct.shutdown();
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             for (List<ConsumerThread> list : threads.values()) {
1:9c2b1d2: 
1:9c2b1d2:                 for (ConsumerThread ct : list) {
1:9c2b1d2: 
1:9c2b1d2:                     ct.join();
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:9c2b1d2:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         private synchronized QueueConnection newQueueConnection() throws Exception {
1:9c2b1d2: 
1:9c2b1d2:             if (connectionFactory == null) {
1:9c2b1d2:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:9c2b1d2:                 connectionFactory.setWatchTopicAdvisories(false);
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:9c2b1d2:             // after the queue has had a certain number of failures (default is 6)
1:9c2b1d2:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:9c2b1d2:             policy.setMaximumRedeliveries(-1);
1:9c2b1d2: 
1:9c2b1d2:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:9c2b1d2:             amqConnection.start();
1:9c2b1d2:             return amqConnection;
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         public boolean completed() {
1:9c2b1d2:             for (List<ConsumerThread> list : threads.values()) {
1:9c2b1d2: 
1:9c2b1d2:                 for (ConsumerThread ct : list) {
1:9c2b1d2: 
1:9c2b1d2:                     if (ct.isAlive()) {
1:9c2b1d2:                         LOG.info("thread for {} is still alive.", ct.qName);
1:9c2b1d2:                         return false;
1:9c2b1d2:                     }
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2:             return true;
1:9c2b1d2:         }
1:9c2b1d2: 
1:9c2b1d2:         private class ConsumerThread extends Thread {
1:9c2b1d2: 
1:9c2b1d2:             private int batchSize;
1:9c2b1d2:             private QueueConnection qc;
1:9c2b1d2:             private Session session;
1:9c2b1d2:             private MessageConsumer mc;
1:9c2b1d2:             private List<String> idList;
1:9c2b1d2:             private boolean shutdown = false;
1:9c2b1d2:             private String qName;
1:9c2b1d2: 
1:9c2b1d2:             private ConsumerThread(String queueName, int batchSize) throws Exception {
1:9c2b1d2: 
1:9c2b1d2:                 this.batchSize = batchSize;
1:9c2b1d2: 
1:9c2b1d2:                 // Each thread has its own connection and session
1:9c2b1d2:                 qName = queueName;
1:9c2b1d2:                 qc = newQueueConnection();
1:9c2b1d2:                 session = newSession(qc);
1:9c2b1d2:                 Queue q = session.createQueue(queueName + "?consumer.prefetchSize=" + batchSize);
1:9c2b1d2:                 mc = session.createConsumer(q);
1:9c2b1d2: 
1:9c2b1d2:                 idList = idsByQueue.get(queueName);
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             public void run() {
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2: 
1:9c2b1d2:                     int count = 0;
1:9c2b1d2: 
1:9c2b1d2:                     // Keep reading as long as it hasn't been told to shutdown
1:9c2b1d2:                     while (!shutdown) {
1:9c2b1d2: 
1:9c2b1d2:                         if (idList.size() >= totalToExpect) {
1:9c2b1d2:                             LOG.info("Got {} for q: {}", +idList.size(), qName);
1:9c2b1d2:                             session.commit();
1:9c2b1d2:                             break;
1:9c2b1d2:                         }
1:9c2b1d2:                         Message m = mc.receive(4000);
1:9c2b1d2: 
1:9c2b1d2:                         if (m != null) {
1:9c2b1d2: 
1:9c2b1d2:                             // We received a non-null message, add the ID to our list
1:9c2b1d2: 
1:9c2b1d2:                             idList.add(m.getStringProperty("KEY"));
1:9c2b1d2: 
1:9c2b1d2:                             count++;
1:9c2b1d2: 
1:9c2b1d2:                             // If we've reached our batch size, commit the batch and reset the count
1:9c2b1d2: 
1:9c2b1d2:                             if (count == batchSize) {
1:9c2b1d2:                                 session.commit();
1:9c2b1d2:                                 count = 0;
1:9c2b1d2:                             }
2:9c2b1d2:                         } else {
1:9c2b1d2: 
1:9c2b1d2:                             // We didn't receive anything this time, commit any current batch and reset the count
1:9c2b1d2: 
1:9c2b1d2:                             session.commit();
1:9c2b1d2:                             count = 0;
1:9c2b1d2: 
1:9c2b1d2:                             // Sleep a little before trying to read after not getting a message
1:9c2b1d2: 
1:9c2b1d2:                             try {
1:9c2b1d2:                                 if (idList.size() < totalToExpect) {
1:9c2b1d2:                                     LOG.info("did not receive on {}, current count: {}", qName, idList.size());
1:9c2b1d2:                                     didNotReceive.set(true);
1:9c2b1d2:                                 }
1:9c2b1d2:                                 //sleep(3000);
1:9c2b1d2:                             } catch (Exception e) {
1:9c2b1d2:                             }
1:9c2b1d2:                         }
1:9c2b1d2:                     }
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2:                     e.printStackTrace();
1:9c2b1d2:                 } finally {
1:9c2b1d2: 
1:9c2b1d2:                     // Once we exit, close everything
1:9c2b1d2:                     close();
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             public void shutdown() {
1:9c2b1d2:                 shutdown = true;
1:9c2b1d2:             }
1:9c2b1d2: 
1:9c2b1d2:             public void close() {
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2:                     mc.close();
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2:                 }
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2:                     session.close();
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2:                 }
1:9c2b1d2: 
1:9c2b1d2:                 try {
1:9c2b1d2:                     qc.close();
1:9c2b1d2:                 } catch (Exception e) {
1:9c2b1d2: 
1:9c2b1d2:                 }
1:9c2b1d2:             }
1:9c2b1d2:         }
1:9c2b1d2:     }
1:9c2b1d2: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:3042797
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.TestSupport;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public TestSupport.PersistenceAdapterChoice persistenceAdapterChoice = TestSupport.PersistenceAdapterChoice.KahaDB;
1:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},store:{5},optimizedDispatch:{6}")
1:                 {1000, 40,  5,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.KahaDB, true},
1:                 {1000, 40,  5,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.LevelDB, true},
1:                 {1000, 40,  5,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.JDBC, true},
1: 
1:                 {500, 20,  20,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.KahaDB, true},
1:                 {500, 20,  20,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.LevelDB, true},
1:                 {500, 20,  20,   1024*1024,  false, TestSupport.PersistenceAdapterChoice.JDBC, true},
/////////////////////////////////////////////////////////////////////////
1:         TestSupport.setPersistenceAdapter(brokerService, persistenceAdapterChoice);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9c2b1d2
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.bugs;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.TreeSet;
1: import java.util.UUID;
1: import java.util.concurrent.CyclicBarrier;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.QueueConnection;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.RedeliveryPolicy;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
1: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.derby.jdbc.EmbeddedDataSource;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
1: import static org.junit.Assert.assertEquals;
1: 
1: /*
1:  * pause producers if consumers stall and verify broker drained before resume
1:  */
1: @RunWith(Parameterized.class)
1: public class AMQ5266StarvedConsumerTest {
1:     static Logger LOG = LoggerFactory.getLogger(AMQ5266StarvedConsumerTest.class);
1:     String activemqURL;
1:     BrokerService brokerService;
0:     private EmbeddedDataSource dataSource;
1: 
1:     public int messageSize = 1000;
1: 
1:     @Parameterized.Parameter(0)
1:     public int publisherMessagesPerThread = 1000;
1: 
1:     @Parameterized.Parameter(1)
1:     public int publisherThreadCount = 20;
1: 
1:     @Parameterized.Parameter(2)
1:     public int consumerThreadsPerQueue = 5;
1: 
1:     @Parameterized.Parameter(3)
1:     public int destMemoryLimit = 50 * 1024;
1: 
1:     @Parameterized.Parameter(4)
1:     public boolean useCache = true;
1: 
1:     @Parameterized.Parameter(5)
0:     public boolean useDefaultStore = false;
1: 
1:     @Parameterized.Parameter(6)
1:     public boolean optimizeDispatch = false;
1:     private  AtomicBoolean didNotReceive = new AtomicBoolean(false);
1: 
0:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},useDefaultStore:{5},optimizedDispatch:{6}")
1:     public static Iterable<Object[]> parameters() {
1:         return Arrays.asList(new Object[][]{
0:                 {1000, 40,  5,   1024*1024,  false,  false, true},
1:         });
1:     }
1: 
1:     public int consumerBatchSize = 5;
1: 
1:     @Before
1:     public void startBroker() throws Exception {
1:         brokerService = new BrokerService();
1: 
0:         dataSource = new EmbeddedDataSource();
0:         dataSource.setDatabaseName("target/derbyDb");
0:         dataSource.setCreateDatabase("create");
1: 
0:         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
0:         jdbcPersistenceAdapter.setDataSource(dataSource);
0:         jdbcPersistenceAdapter.setUseLock(false);
1: 
0:         if (!useDefaultStore) {
0:             brokerService.setPersistenceAdapter(jdbcPersistenceAdapter);
1:         } else {
0:             KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter) brokerService.getPersistenceAdapter();
0:             kahaDBPersistenceAdapter.setConcurrentStoreAndDispatchQueues(true);
1:         }
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:         brokerService.setUseJmx(false);
1:         brokerService.setAdvisorySupport(false);
1: 
1: 
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
1:         defaultEntry.setUseConsumerPriority(false); // java.lang.IllegalArgumentException: Comparison method violates its general contract!
1:         defaultEntry.setMaxAuditDepth(publisherThreadCount);
1:         defaultEntry.setEnableAudit(true);
1:         defaultEntry.setUseCache(useCache);
1:         defaultEntry.setMaxPageSize(1000);
1:         defaultEntry.setOptimizedDispatch(optimizeDispatch);
1:         defaultEntry.setMemoryLimit(destMemoryLimit);
1:         defaultEntry.setExpireMessagesPeriod(0);
1:         policyMap.setDefaultEntry(defaultEntry);
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         brokerService.getSystemUsage().getMemoryUsage().setLimit(512 * 1024 * 1024);
1: 
1:         TransportConnector transportConnector = brokerService.addConnector("tcp://0.0.0.0:0");
1:         brokerService.start();
1:         activemqURL = transportConnector.getPublishableConnectString();
1:     }
1: 
1:     @After
1:     public void stopBroker() throws Exception {
1:         if (brokerService != null) {
1:             brokerService.stop();
1:         }
1:         try {
0:             dataSource.setShutdownDatabase("shutdown");
0:             dataSource.getConnection();
0:         } catch (Exception ignored) {}
1:     }
1: 
1:     CyclicBarrier globalProducerHalt = new CyclicBarrier(publisherThreadCount, new Runnable() {
1:         @Override
1:         public void run() {
1:             // wait for queue size to go to zero
1:             try {
1:                 while (((RegionBroker)brokerService.getRegionBroker()).getDestinationStatistics().getMessages().getCount() > 0) {
1:                     LOG.info("Total messageCount: " + ((RegionBroker)brokerService.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:                     TimeUnit.SECONDS.sleep(5);
1:                 }
1:             } catch (Exception ignored) {
1:                 ignored.printStackTrace();
1:             }
1:         }
1:     });
1: 
1:     @Test(timeout = 30 * 60 * 1000)
1:     public void test() throws Exception {
1: 
1:         String activemqQueues = "activemq,activemq2,activemq3,activemq4";//,activemq5,activemq6,activemq7,activemq8,activemq9";
1: 
1:         int consumerWaitForConsumption = 5 * 60 * 1000;
1: 
1:         ExportQueuePublisher publisher = null;
1:         ExportQueueConsumer consumer = null;
1: 
1:         LOG.info("Publisher will publish " + (publisherMessagesPerThread * publisherThreadCount) + " messages to each queue specified.");
1:         LOG.info("\nBuilding Publisher...");
1: 
1:         publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);
1: 
1:         LOG.info("Building Consumer...");
1: 
1:         consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);
1: 
1: 
1:         LOG.info("Starting Publisher...");
1: 
1:         publisher.start();
1: 
1:         LOG.info("Starting Consumer...");
1: 
1:         consumer.start();
1: 
1:         int distinctPublishedCount = 0;
1: 
1: 
1:         LOG.info("Waiting For Publisher Completion...");
1: 
1:         publisher.waitForCompletion();
1: 
1:         List publishedIds = publisher.getIDs();
1:         distinctPublishedCount = new TreeSet(publishedIds).size();
1: 
1:         LOG.info("Publisher Complete. Published: " + publishedIds.size() + ", Distinct IDs Published: " + distinctPublishedCount);
1: 
1: 
1:         long endWait = System.currentTimeMillis() + consumerWaitForConsumption;
1:         while (!consumer.completed() && System.currentTimeMillis() < endWait) {
1:             try {
1:                 int secs = (int) (endWait - System.currentTimeMillis()) / 1000;
1:                 LOG.info("Waiting For Consumer Completion. Time left: " + secs + " secs");
0:                 if (!useDefaultStore) {
0:                     DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
1:                 }
1:                 Thread.sleep(10000);
1:             } catch (Exception e) {
1:             }
1:         }
1: 
1:         LOG.info("\nConsumer Complete: " + consumer.completed() +", Shutting Down.");
1: 
1:         consumer.shutdown();
1: 
0:         TimeUnit.SECONDS.sleep(2);
0:         LOG.info("DB Contents START");
0:         if (!useDefaultStore) {
0:             DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
1:         }
0:         LOG.info("DB Contents END");
1: 
1:         LOG.info("Consumer Stats:");
1: 
1:         for (Map.Entry<String, List<String>> entry : consumer.getIDs().entrySet()) {
1: 
1:             List<String> idList = entry.getValue();
1: 
1:             int distinctConsumed = new TreeSet<String>(idList).size();
1: 
1:             StringBuilder sb = new StringBuilder();
1:             sb.append("   Queue: " + entry.getKey() +
1:                     " -> Total Messages Consumed: " + idList.size() +
1:                     ", Distinct IDs Consumed: " + distinctConsumed);
1: 
1:             int diff = distinctPublishedCount - distinctConsumed;
1:             sb.append(" ( " + (diff > 0 ? diff : "NO") + " STUCK MESSAGES " + " ) ");
1:             LOG.info(sb.toString());
1: 
1:             assertEquals("expect to get all messages!", 0, diff);
1: 
1:         }
1:     }
1: 
1:     public class ExportQueuePublisher {
1: 
1:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:         private ActiveMQConnectionFactory connectionFactory = null;
1:         private String activemqURL = null;
1:         private String activemqQueues = null;
1:         // Collection of distinct IDs that the publisher has published.
1:         // After a message is published, its UUID will be written to this list for tracking.
1:         // This list of IDs (or distinct count) will be used to compare to the consumed list of IDs.
1:         //private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
1:         private List<String> ids = Collections.synchronizedList(new ArrayList<String>());
1:         private List<PublisherThread> threads;
1: 
1:         public ExportQueuePublisher(String activemqURL, String activemqQueues, int messagesPerThread, int threadCount) throws Exception {
1: 
1:             this.activemqURL = activemqURL;
1:             this.activemqQueues = activemqQueues;
1: 
1:             threads = new ArrayList<PublisherThread>();
1: 
1:             // Build the threads and tell them how many messages to publish
1:             for (int i = 0; i < threadCount; i++) {
1:                 PublisherThread pt = new PublisherThread(messagesPerThread);
1:                 threads.add(pt);
1:             }
1:         }
1: 
1:         public List<String> getIDs() {
1:             return ids;
1:         }
1: 
1:         // Kick off threads
1:         public void start() throws Exception {
1: 
1:             for (PublisherThread pt : threads) {
1:                 pt.start();
1:             }
1:         }
1: 
1:         // Wait for threads to complete. They will complete once they've published all of their messages.
1:         public void waitForCompletion() throws Exception {
1: 
1:             for (PublisherThread pt : threads) {
1:                 pt.join();
1:                 pt.close();
1:             }
1:         }
1: 
1:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:         }
1: 
1:         private synchronized QueueConnection newQueueConnection() throws Exception {
1: 
1:             if (connectionFactory == null) {
1:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:                 connectionFactory.setWatchTopicAdvisories(false);
1:             }
1: 
1:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:             // after the queue has had a certain number of failures (default is 6)
1:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:             policy.setMaximumRedeliveries(-1);
1: 
1:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:             amqConnection.start();
1:             return amqConnection;
1:         }
1: 
1:         private class PublisherThread extends Thread {
1: 
1:             private int count;
1:             private QueueConnection qc;
1:             private Session session;
1:             private MessageProducer mp;
1:             private Queue q;
1: 
1:             private PublisherThread(int count) throws Exception {
1: 
1:                 this.count = count;
1: 
1:                 // Each Thread has its own Connection and Session, so no sync worries
1:                 qc = newQueueConnection();
1:                 session = newSession(qc);
1: 
1:                 // In our code, when publishing to multiple queues,
1:                 // we're using composite destinations like below
1:                 q = new ActiveMQQueue(activemqQueues);
1:                 mp = session.createProducer(null);
1:             }
1: 
1:             public void run() {
1: 
1:                 try {
1: 
1:                     // Loop until we've published enough messages
1:                     while (count-- > 0) {
1: 
1:                         TextMessage tm = session.createTextMessage(getMessageText());
1:                         String id = UUID.randomUUID().toString();
1:                         tm.setStringProperty("KEY", id);
1:                         ids.add(id);                            // keep track of the key to compare against consumer
1: 
1:                         mp.send(q, tm);
1:                         session.commit();
1: 
1:                         if (didNotReceive.get()) {
1:                             globalProducerHalt.await();
1:                         }
1:                     }
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1: 
1:             // Called by waitForCompletion
1:             public void close() {
1: 
1:                 try {
1:                     mp.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     session.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     qc.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1: 
1:     }
1: 
1:     String messageText;
1:     private String getMessageText() {
1: 
1:         if (messageText == null) {
1: 
1:             synchronized (this) {
1: 
1:                 if (messageText == null) {
1: 
1:                     StringBuilder sb = new StringBuilder();
1:                     for (int i = 0; i < messageSize; i++) {
1:                         sb.append("X");
1:                     }
1:                     messageText = sb.toString();
1:                 }
1:             }
1:         }
1: 
1:         return messageText;
1:     }
1: 
1: 
1:     public class ExportQueueConsumer {
1: 
1:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:         private final int totalToExpect;
1:         private ActiveMQConnectionFactory connectionFactory = null;
1:         private String activemqURL = null;
1:         private String activemqQueues = null;
1:         private String[] queues = null;
1:         // Map of IDs that were consumed, keyed by queue name.
1:         // We'll compare these against what was published to know if any got stuck or dropped.
1:         private Map<String, List<String>> idsByQueue = new HashMap<String, List<String>>();
1:         private Map<String, List<ConsumerThread>> threads;
1: 
1:         public ExportQueueConsumer(String activemqURL, String activemqQueues, int threadsPerQueue, int batchSize, int totalToExpect) throws Exception {
1: 
1:             this.activemqURL = activemqURL;
1:             this.activemqQueues = activemqQueues;
1:             this.totalToExpect = totalToExpect;
1: 
1:             queues = this.activemqQueues.split(",");
1: 
1:             for (int i = 0; i < queues.length; i++) {
1:                 queues[i] = queues[i].trim();
1:             }
1: 
1:             threads = new HashMap<String, List<ConsumerThread>>();
1: 
1:             // For each queue, create a list of threads and set up the list of ids
1:             for (String q : queues) {
1: 
1:                 List<ConsumerThread> list = new ArrayList<ConsumerThread>();
1: 
1:                 idsByQueue.put(q, Collections.synchronizedList(new ArrayList<String>()));
1: 
1:                 for (int i = 0; i < threadsPerQueue; i++) {
1:                     list.add(new ConsumerThread(q, batchSize));
1:                 }
1: 
1:                 threads.put(q, list);
1:             }
1:         }
1: 
1:         public Map<String, List<String>> getIDs() {
1:             return idsByQueue;
1:         }
1: 
1:         // Start the threads
1:         public void start() throws Exception {
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.start();
1:                 }
1:             }
1:         }
1: 
1:         // Tell the threads to stop
1:         // Then wait for them to stop
1:         public void shutdown() throws Exception {
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.shutdown();
1:                 }
1:             }
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.join();
1:                 }
1:             }
1:         }
1: 
1:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:             return queueConnection.createSession(true, Session.SESSION_TRANSACTED);
1:         }
1: 
1:         private synchronized QueueConnection newQueueConnection() throws Exception {
1: 
1:             if (connectionFactory == null) {
1:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:                 connectionFactory.setWatchTopicAdvisories(false);
1:             }
1: 
1:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:             // after the queue has had a certain number of failures (default is 6)
1:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:             policy.setMaximumRedeliveries(-1);
1: 
1:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:             amqConnection.start();
1:             return amqConnection;
1:         }
1: 
1:         public boolean completed() {
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     if (ct.isAlive()) {
1:                         LOG.info("thread for {} is still alive.", ct.qName);
1:                         return false;
1:                     }
1:                 }
1:             }
1:             return true;
1:         }
1: 
1:         private class ConsumerThread extends Thread {
1: 
1:             private int batchSize;
1:             private QueueConnection qc;
1:             private Session session;
1:             private MessageConsumer mc;
1:             private List<String> idList;
1:             private boolean shutdown = false;
1:             private String qName;
1: 
1:             private ConsumerThread(String queueName, int batchSize) throws Exception {
1: 
1:                 this.batchSize = batchSize;
1: 
1:                 // Each thread has its own connection and session
1:                 qName = queueName;
1:                 qc = newQueueConnection();
1:                 session = newSession(qc);
1:                 Queue q = session.createQueue(queueName + "?consumer.prefetchSize=" + batchSize);
1:                 mc = session.createConsumer(q);
1: 
1:                 idList = idsByQueue.get(queueName);
1:             }
1: 
1:             public void run() {
1: 
1:                 try {
1: 
1:                     int count = 0;
1: 
1:                     // Keep reading as long as it hasn't been told to shutdown
1:                     while (!shutdown) {
1: 
1:                         if (idList.size() >= totalToExpect) {
1:                             LOG.info("Got {} for q: {}", +idList.size(), qName);
1:                             session.commit();
1:                             break;
1:                         }
1:                         Message m = mc.receive(4000);
1: 
1:                         if (m != null) {
1: 
1:                             // We received a non-null message, add the ID to our list
1: 
1:                             idList.add(m.getStringProperty("KEY"));
1: 
1:                             count++;
1: 
1:                             // If we've reached our batch size, commit the batch and reset the count
1: 
1:                             if (count == batchSize) {
1:                                 session.commit();
1:                                 count = 0;
1:                             }
1:                         } else {
1: 
1:                             // We didn't receive anything this time, commit any current batch and reset the count
1: 
1:                             session.commit();
1:                             count = 0;
1: 
1:                             // Sleep a little before trying to read after not getting a message
1: 
1:                             try {
1:                                 if (idList.size() < totalToExpect) {
1:                                     LOG.info("did not receive on {}, current count: {}", qName, idList.size());
1:                                     didNotReceive.set(true);
1:                                 }
1:                                 //sleep(3000);
1:                             } catch (Exception e) {
1:                             }
1:                         }
1:                     }
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 } finally {
1: 
1:                     // Once we exit, close everything
1:                     close();
1:                 }
1:             }
1: 
1:             public void shutdown() {
1:                 shutdown = true;
1:             }
1: 
1:             public void close() {
1: 
1:                 try {
1:                     mc.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     session.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     qc.close();
1:                 } catch (Exception e) {
1: 
1:                 }
1:             }
1:         }
1:     }
1: }
============================================================================