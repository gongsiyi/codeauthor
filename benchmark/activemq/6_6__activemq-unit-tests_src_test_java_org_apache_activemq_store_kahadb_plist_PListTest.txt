1:ee55abb: /**
1:ee55abb:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:ee55abb:  * contributor license agreements.  See the NOTICE file distributed with
1:ee55abb:  * this work for additional information regarding copyright ownership.
1:ee55abb:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:ee55abb:  * (the "License"); you may not use this file except in compliance with
1:ee55abb:  * the License.  You may obtain a copy of the License at
1:ee55abb:  *
1:ee55abb:  *      http://www.apache.org/licenses/LICENSE-2.0
1:ee55abb:  *
1:ee55abb:  * Unless required by applicable law or agreed to in writing, software
1:ee55abb:  * distributed under the License is distributed on an "AS IS" BASIS,
1:ee55abb:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ee55abb:  * See the License for the specific language governing permissions and
1:ee55abb:  * limitations under the License.
1:ee55abb:  */
1:ee55abb: package org.apache.activemq.store.kahadb.plist;
1:0619a87: 
1:ee55abb: import static org.junit.Assert.assertEquals;
1:f24edca: import static org.junit.Assert.assertFalse;
1:f24edca: import static org.junit.Assert.assertTrue;
1:0619a87: 
1:ee55abb: import java.io.File;
1:ee55abb: import java.io.IOException;
1:bf59b7d: import java.util.HashMap;
1:2b10259: import java.util.Iterator;
1:ee55abb: import java.util.LinkedHashMap;
1:ee55abb: import java.util.Map;
1:0619a87: import java.util.Vector;
1:0619a87: import java.util.concurrent.ExecutorService;
1:0619a87: import java.util.concurrent.Executors;
1:0619a87: import java.util.concurrent.TimeUnit;
1:0619a87: 
1:d5dd937: import org.apache.activemq.store.PList;
1:d635a36: import org.apache.activemq.store.PList.PListIterator;
1:d5dd937: import org.apache.activemq.store.PListEntry;
1:1aab71b: import org.apache.activemq.util.ByteSequence;
1:3c83c17: import org.apache.activemq.util.IOHelper;
1:ee55abb: import org.junit.After;
1:ee55abb: import org.junit.Before;
1:ee55abb: import org.junit.Test;
1:128a8f7: import org.slf4j.Logger;
1:128a8f7: import org.slf4j.LoggerFactory;
1:0619a87: 
1:ee55abb: public class PListTest {
1:128a8f7:     static final Logger LOG = LoggerFactory.getLogger(PListTest.class);
1:d5dd937:     private PListStoreImpl store;
1:d5dd937:     private PListImpl plist;
1:128a8f7:     final ByteSequence payload = new ByteSequence(new byte[400]);
1:bf59b7d:     final String idSeed = new String("Seed" + new byte[1024]);
1:128a8f7:     final Vector<Throwable> exceptions = new Vector<Throwable>();
1:bf59b7d:     ExecutorService executor;
1:030d09b: 
1:32e63dc:     private PListEntry getFirst(PList plist) throws IOException {
1:32e63dc:         PList.PListIterator iterator = plist.iterator();
1:32e63dc:         try {
1:3c83c17:             if (iterator.hasNext()) {
1:32e63dc:                 return iterator.next();
1:32e63dc:             } else {
1:32e63dc:                 return null;
1:32e63dc:             }
1:3c83c17:         } finally {
1:32e63dc:             iterator.release();
1:32e63dc:         }
1:32e63dc:     }
1:32e63dc: 
1:030d09b:     @Test
1:ee55abb:     public void testAddLast() throws Exception {
1:799c033:         final int COUNT = 1000;
2:ee55abb:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
2:ee55abb:         for (int i = 0; i < COUNT; i++) {
2:ee55abb:             String test = new String("test" + i);
2:ee55abb:             ByteSequence bs = new ByteSequence(test.getBytes());
2:ee55abb:             map.put(test, bs);
2:ee55abb:             plist.addLast(test, bs);
1:0619a87:         }
2:ee55abb:         assertEquals(plist.size(), COUNT);
1:d635a36:         assertTrue(plist.messageSize() > 0);
1:ee55abb:         int count = 0;
1:ee55abb:         for (ByteSequence bs : map.values()) {
1:ee55abb:             String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:ee55abb:             PListEntry entry = plist.get(count);
1:3c83c17:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(), entry.getByteSequence().getLength());
1:ee55abb:             assertEquals(origStr, plistString);
1:ee55abb:             count++;
10:ee55abb:         }
1:ee55abb:     }
1:bf59b7d: 
1:3c83c17:     @Test
1:ee55abb:     public void testAddFirst() throws Exception {
1:799c033:         final int COUNT = 1000;
1:ee55abb:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:ee55abb:         for (int i = 0; i < COUNT; i++) {
1:ee55abb:             String test = new String("test" + i);
1:ee55abb:             ByteSequence bs = new ByteSequence(test.getBytes());
1:ee55abb:             map.put(test, bs);
1:ee55abb:             plist.addFirst(test, bs);
1:ee55abb:         }
1:ee55abb:         assertEquals(plist.size(), COUNT);
1:d635a36:         assertTrue(plist.messageSize() > 0);
1:2b10259:         long count = plist.size() - 1;
1:ee55abb:         for (ByteSequence bs : map.values()) {
1:ee55abb:             String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:ee55abb:             PListEntry entry = plist.get(count);
1:3c83c17:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(), entry.getByteSequence().getLength());
1:ee55abb:             assertEquals(origStr, plistString);
1:ee55abb:             count--;
1:ee55abb:         }
1:ee55abb:     }
1:128a8f7: 
1:f24edca:     @Test
1:ee55abb:     public void testRemove() throws IOException {
1:af31f2d:         doTestRemove(2000);
1:af31f2d:     }
1:030d09b: 
1:030d09b:     protected void doTestRemove(final int COUNT) throws IOException {
1:ee55abb:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:ee55abb:         for (int i = 0; i < COUNT; i++) {
1:ee55abb:             String test = new String("test" + i);
1:ee55abb:             ByteSequence bs = new ByteSequence(test.getBytes());
1:ee55abb:             map.put(test, bs);
1:ee55abb:             plist.addLast(test, bs);
1:ee55abb:         }
1:ee55abb:         assertEquals(plist.size(), COUNT);
2:ee55abb:         PListEntry entry = plist.getFirst();
2:ee55abb:         while (entry != null) {
1:2b10259:             plist.remove(entry.getId());
1:ee55abb:             entry = plist.getFirst();
1:ee55abb:         }
1:3c83c17:         assertEquals(0, plist.size());
1:d635a36:         assertEquals(0, plist.messageSize());
1:ee55abb:     }
1:0619a87: 
1:af31f2d:     @Test
1:af31f2d:     public void testDestroy() throws Exception {
1:af31f2d:         doTestRemove(1);
1:af31f2d:         plist.destroy();
1:3c83c17:         assertEquals(0, plist.size());
1:d635a36:         assertEquals(0, plist.messageSize());
1:af31f2d:     }
1:030d09b: 
1:af31f2d:     @Test
1:af31f2d:     public void testDestroyNonEmpty() throws Exception {
1:af31f2d:         final int COUNT = 1000;
1:af31f2d:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:af31f2d:         for (int i = 0; i < COUNT; i++) {
1:af31f2d:             String test = new String("test" + i);
1:af31f2d:             ByteSequence bs = new ByteSequence(test.getBytes());
1:af31f2d:             map.put(test, bs);
1:af31f2d:             plist.addLast(test, bs);
1:af31f2d:         }
1:af31f2d:         plist.destroy();
1:3c83c17:         assertEquals(0, plist.size());
1:d635a36:         assertEquals(0, plist.messageSize());
1:ee55abb:     }
1:030d09b: 
4:ee55abb:     @Test
1:f24edca:     public void testRemoveSecond() throws Exception {
1:f24edca:         plist.addLast("First", new ByteSequence("A".getBytes()));
1:f24edca:         plist.addLast("Second", new ByteSequence("B".getBytes()));
1:030d09b: 
1:f24edca:         assertTrue(plist.remove("Second"));
1:f24edca:         assertTrue(plist.remove("First"));
1:f24edca:         assertFalse(plist.remove("doesNotExist"));
1:f24edca:     }
1:030d09b: 
1:bf59b7d:     @Test
1:bf59b7d:     public void testRemoveSingleEntry() throws Exception {
1:bf59b7d:         plist.addLast("First", new ByteSequence("A".getBytes()));
1:bf59b7d: 
1:bf59b7d:         Iterator<PListEntry> iterator = plist.iterator();
1:bf59b7d:         while (iterator.hasNext()) {
1:030d09b:             iterator.next();
1:bf59b7d:             iterator.remove();
1:bf59b7d:         }
1:bf59b7d:     }
1:bf59b7d: 
1:f24edca:     @Test
1:f24edca:     public void testRemoveSecondPosition() throws Exception {
1:f24edca:         plist.addLast("First", new ByteSequence("A".getBytes()));
1:f24edca:         plist.addLast("Second", new ByteSequence("B".getBytes()));
1:030d09b: 
1:f24edca:         assertTrue(plist.remove(1));
1:f24edca:         assertTrue(plist.remove(0));
1:bf59b7d:         assertFalse(plist.remove(0));
1:0619a87:     }
1:0619a87: 
1:0619a87:     @Test
1:0619a87:     public void testConcurrentAddRemove() throws Exception {
1:030d09b:         File directory = store.getDirectory();
1:030d09b:         store.stop();
1:030d09b:         IOHelper.mkdirs(directory);
1:030d09b:         IOHelper.deleteChildren(directory);
1:d5dd937:         store = new PListStoreImpl();
1:bf59b7d:         store.setCleanupInterval(400);
1:030d09b:         store.setDirectory(directory);
1:3c83c17:         store.setJournalMaxFileLength(1024 * 5);
1:7d082c3:         store.setLazyInit(false);
1:030d09b:         store.start();
1:030d09b: 
1:3c83c17:         final ByteSequence payload = new ByteSequence(new byte[1024 * 2]);
1:128a8f7: 
1:0619a87:         final Vector<Throwable> exceptions = new Vector<Throwable>();
1:030d09b:         final int iterations = 1000;
1:0619a87:         final int numLists = 10;
1:030d09b: 
1:0619a87:         final PList[] lists = new PList[numLists];
1:bf59b7d:         String threadName = Thread.currentThread().getName();
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:3c83c17:             Thread.currentThread().setName("C:" + String.valueOf(i));
1:bf59b7d:             lists[i] = store.getPList(String.valueOf(i));
1:128a8f7:         }
1:bf59b7d:         Thread.currentThread().setName(threadName);
1:128a8f7: 
1:bf59b7d:         executor = Executors.newFixedThreadPool(100);
1:0619a87:         class A implements Runnable {
1:0619a87:             @Override
1:0619a87:             public void run() {
1:bf59b7d:                 final String threadName = Thread.currentThread().getName();
1:0619a87:                 try {
1:3c83c17:                     for (int i = 0; i < iterations; i++) {
1:3c83c17:                         PList candidate = lists[i % numLists];
1:3c83c17:                         Thread.currentThread().setName("ALRF:" + candidate.getName());
1:bf59b7d:                         synchronized (plistLocks(candidate)) {
1:3c83c17:                             Object locator = candidate.addLast(String.valueOf(i), payload);
1:32e63dc:                             getFirst(candidate);
1:3c83c17:                             assertTrue(candidate.remove(locator));
1:bf59b7d:                         }
1:bf59b7d:                     }
1:0619a87:                 } catch (Exception error) {
1:bf59b7d:                     LOG.error("Unexpcted ex", error);
1:0619a87:                     error.printStackTrace();
1:0619a87:                     exceptions.add(error);
1:3c83c17:                 } finally {
1:bf59b7d:                     Thread.currentThread().setName(threadName);
1:0619a87:                 }
1:0619a87:             }
1:0619a87:         };
1:128a8f7: 
1:3c83c17:         class B implements Runnable {
1:0619a87:             @Override
1:0619a87:             public void run() {
1:bf59b7d:                 final String threadName = Thread.currentThread().getName();
1:0619a87:                 try {
1:3c83c17:                     for (int i = 0; i < iterations; i++) {
1:3c83c17:                         PList candidate = lists[i % numLists];
1:3c83c17:                         Thread.currentThread().setName("ALRF:" + candidate.getName());
1:3c83c17:                         synchronized (plistLocks(candidate)) {
1:3c83c17:                             Object locator = candidate.addLast(String.valueOf(i), payload);
1:32e63dc:                             getFirst(candidate);
1:3c83c17:                             assertTrue(candidate.remove(locator));
1:3c83c17:                         }
1:0619a87:                     }
1:0619a87:                 } catch (Exception error) {
1:0619a87:                     error.printStackTrace();
1:0619a87:                     exceptions.add(error);
1:3c83c17:                 } finally {
1:bf59b7d:                     Thread.currentThread().setName(threadName);
1:0619a87:                 }
1:0619a87:             }
1:0619a87:         };
1:0619a87: 
1:0619a87:         executor.execute(new A());
1:0619a87:         executor.execute(new A());
1:0619a87:         executor.execute(new A());
1:0619a87:         executor.execute(new B());
1:0619a87:         executor.execute(new B());
1:0619a87:         executor.execute(new B());
1:0619a87: 
1:0619a87:         executor.shutdown();
1:783ba85:         boolean finishedInTime = executor.awaitTermination(30, TimeUnit.SECONDS);
1:128a8f7: 
1:2b10259:         assertTrue("no exceptions", exceptions.isEmpty());
1:783ba85:         assertTrue("finished ok", finishedInTime);
1:128a8f7:     }
1:128a8f7: 
1:128a8f7:     @Test
1:128a8f7:     public void testConcurrentAddLast() throws Exception {
1:128a8f7:         File directory = store.getDirectory();
1:128a8f7:         store.stop();
1:128a8f7:         IOHelper.mkdirs(directory);
1:128a8f7:         IOHelper.deleteChildren(directory);
1:d5dd937:         store = new PListStoreImpl();
1:128a8f7:         store.setDirectory(directory);
1:128a8f7:         store.start();
1:128a8f7: 
1:128a8f7:         final int numThreads = 20;
1:c709527:         final int iterations = 1000;
1:bf59b7d:         executor = Executors.newFixedThreadPool(100);
1:3c83c17:         for (int i = 0; i < numThreads; i++) {
1:128a8f7:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:128a8f7:         }
1:128a8f7: 
1:3c83c17:         for (int i = 0; i < numThreads; i++) {
1:128a8f7:             executor.execute(new Job(i, PListTest.TaskType.ITERATE, iterations));
1:128a8f7:         }
1:128a8f7: 
1:3c83c17:         for (int i = 0; i < 100; i++) {
1:3c83c17:             executor.execute(new Job(i + 20, PListTest.TaskType.ADD, 100));
1:128a8f7:         }
1:128a8f7: 
1:128a8f7:         executor.shutdown();
1:3c83c17:         boolean finishedInTime = executor.awaitTermination(60 * 5, TimeUnit.SECONDS);
1:783ba85:         assertTrue("finished ok", finishedInTime);
1:128a8f7:     }
1:128a8f7: 
1:128a8f7:     @Test
1:128a8f7:     public void testOverFlow() throws Exception {
1:128a8f7:         File directory = store.getDirectory();
1:128a8f7:         store.stop();
1:128a8f7:         IOHelper.mkdirs(directory);
1:128a8f7:         IOHelper.deleteChildren(directory);
1:d5dd937:         store = new PListStoreImpl();
1:128a8f7:         store.setDirectory(directory);
1:128a8f7:         store.start();
1:128a8f7: 
1:3c83c17:         for (int i = 0; i < 2000; i++) {
1:128a8f7:             new Job(i, PListTest.TaskType.ADD, 5).run();
1:128a8f7: 
1:128a8f7:         }
1:128a8f7:         LOG.info("After Load index file: " + store.pageFile.getFile().length());
1:128a8f7:         LOG.info("After remove index file: " + store.pageFile.getFile().length());
1:128a8f7:     }
1:128a8f7: 
1:128a8f7:     @Test
1:128a8f7:     public void testConcurrentAddRemoveWithPreload() throws Exception {
1:128a8f7:         File directory = store.getDirectory();
1:128a8f7:         store.stop();
1:128a8f7:         IOHelper.mkdirs(directory);
1:128a8f7:         IOHelper.deleteChildren(directory);
1:d5dd937:         store = new PListStoreImpl();
1:128a8f7:         store.setDirectory(directory);
1:3c83c17:         store.setJournalMaxFileLength(1024 * 5);
1:128a8f7:         store.setCleanupInterval(5000);
1:030d09b:         store.setIndexWriteBatchSize(500);
1:128a8f7:         store.start();
1:128a8f7: 
1:c709527:         final int iterations = 500;
1:c709527:         final int numLists = 10;
1:128a8f7: 
1:128a8f7:         // prime the store
1:128a8f7: 
1:128a8f7:         // create/delete
1:030d09b:         LOG.info("create");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:030d09b:             new Job(i, PListTest.TaskType.CREATE, iterations).run();
1:030d09b:         }
1:030d09b: 
1:2b10259:         LOG.info("delete");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:128a8f7:             new Job(i, PListTest.TaskType.DELETE, iterations).run();
1:030d09b:         }
1:030d09b: 
1:2b10259:         LOG.info("fill");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:128a8f7:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:128a8f7:         }
1:2b10259:         LOG.info("remove");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:128a8f7:             new Job(i, PListTest.TaskType.REMOVE, iterations).run();
1:128a8f7:         }
1:2b10259: 
1:2b10259:         LOG.info("check empty");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:2b10259:             assertEquals("empty " + i, 0, store.getPList("List-" + i).size());
1:2b10259:         }
1:2b10259: 
1:2b10259:         LOG.info("delete again");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:128a8f7:             new Job(i, PListTest.TaskType.DELETE, iterations).run();
1:128a8f7:         }
1:128a8f7: 
1:2b10259:         LOG.info("fill again");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:128a8f7:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:128a8f7:         }
1:128a8f7: 
1:2b10259:         LOG.info("parallel add and remove");
1:3c83c17:         executor = Executors.newFixedThreadPool(numLists * 2);
1:3c83c17:         for (int i = 0; i < numLists * 2; i++) {
1:3c83c17:             executor.execute(new Job(i, i >= numLists ? PListTest.TaskType.ADD : PListTest.TaskType.REMOVE, iterations));
1:128a8f7:         }
1:128a8f7: 
1:128a8f7:         executor.shutdown();
1:2b10259:         LOG.info("wait for parallel work to complete");
1:3c83c17:         boolean finishedInTime = executor.awaitTermination(60 * 5, TimeUnit.SECONDS);
1:bf59b7d:         assertTrue("no exceptions", exceptions.isEmpty());
1:783ba85:         assertTrue("finished ok", finishedInTime);
1:128a8f7:     }
1:128a8f7: 
1:bf59b7d:     // for non determinant issues, increasing this may help diagnose
1:bf59b7d:     final int numRepeats = 1;
1:bf59b7d: 
1:bf59b7d:     @Test
1:bf59b7d:     public void testRepeatStressWithCache() throws Exception {
1:3c83c17:         for (int i = 0; i < numRepeats; i++) {
1:bf59b7d:             do_testConcurrentAddIterateRemove(true);
1:bf59b7d:         }
1:bf59b7d:     }
1:bf59b7d: 
1:bf59b7d:     @Test
1:bf59b7d:     public void testRepeatStressWithOutCache() throws Exception {
1:3c83c17:         for (int i = 0; i < numRepeats; i++) {
1:bf59b7d:             do_testConcurrentAddIterateRemove(false);
1:bf59b7d:         }
1:bf59b7d:     }
1:bf59b7d: 
1:bf59b7d:     public void do_testConcurrentAddIterateRemove(boolean enablePageCache) throws Exception {
1:bf59b7d:         File directory = store.getDirectory();
1:bf59b7d:         store.stop();
1:bf59b7d:         IOHelper.mkdirs(directory);
1:bf59b7d:         IOHelper.deleteChildren(directory);
1:d5dd937:         store = new PListStoreImpl();
1:bf59b7d:         store.setIndexEnablePageCaching(enablePageCache);
1:3c83c17:         store.setIndexPageSize(2 * 1024);
1:bf59b7d:         store.setDirectory(directory);
1:bf59b7d:         store.start();
1:bf59b7d: 
1:c709527:         final int iterations = 500;
1:128a8f7:         final int numLists = 10;
1:bf59b7d: 
1:bf59b7d:         LOG.info("create");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:bf59b7d:             new Job(i, PListTest.TaskType.CREATE, iterations).run();
1:bf59b7d:         }
1:bf59b7d: 
1:bf59b7d:         LOG.info("fill");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:bf59b7d:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:bf59b7d:         }
1:bf59b7d: 
1:bf59b7d:         LOG.info("parallel add and remove");
1:030d09b:         executor = Executors.newFixedThreadPool(400);
1:bf59b7d:         final int numProducer = 5;
1:c709527:         final int numConsumer = 10;
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:3c83c17:             for (int j = 0; j < numProducer; j++) {
1:3c83c17:                 executor.execute(new Job(i, PListTest.TaskType.ADD, iterations * 2));
1:bf59b7d:             }
1:3c83c17:             for (int k = 0; k < numConsumer; k++) {
1:3c83c17:                 executor.execute(new Job(i, TaskType.ITERATE_REMOVE, iterations / 4));
1:bf59b7d:             }
1:bf59b7d:         }
1:bf59b7d: 
1:3c83c17:         for (int i = numLists; i < numLists * 10; i++) {
1:bf59b7d:             executor.execute(new Job(i, PListTest.TaskType.ADD, iterations));
1:3c83c17:         }
1:bf59b7d: 
1:bf59b7d:         executor.shutdown();
1:bf59b7d:         LOG.info("wait for parallel work to complete");
1:3c83c17:         boolean shutdown = executor.awaitTermination(60 * 60, TimeUnit.SECONDS);
1:030d09b:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:bf59b7d:         assertTrue("test did not  timeout ", shutdown);
1:030d09b:     }
1:030d09b: 
1:030d09b:     @Test
1:030d09b:     public void testConcurrentAddIterate() throws Exception {
1:030d09b:         File directory = store.getDirectory();
1:030d09b:         store.stop();
1:030d09b:         IOHelper.mkdirs(directory);
1:030d09b:         IOHelper.deleteChildren(directory);
1:d5dd937:         store = new PListStoreImpl();
1:3c83c17:         store.setIndexPageSize(2 * 1024);
1:3c83c17:         store.setJournalMaxFileLength(1024 * 1024);
1:030d09b:         store.setDirectory(directory);
2:030d09b:         store.setCleanupInterval(-1);
2:030d09b:         store.setIndexEnablePageCaching(false);
1:030d09b:         store.setIndexWriteBatchSize(100);
1:030d09b:         store.start();
1:030d09b: 
1:030d09b:         final int iterations = 250;
1:030d09b:         final int numLists = 10;
1:030d09b: 
1:030d09b:         LOG.info("create");
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:030d09b:             new Job(i, PListTest.TaskType.CREATE, iterations).run();
1:030d09b:         }
1:030d09b: 
1:030d09b:         LOG.info("parallel add and iterate");
1:3c83c17:         // We want a lot of adds occurring so that new free pages get created
1:3c83c17:         // along
1:3c83c17:         // with overlapping seeks from the iterators so that we are likely to
1:3c83c17:         // seek into
1:030d09b:         // some bad area in the page file.
1:30d3fae:         executor = Executors.newFixedThreadPool(100);
1:30d3fae:         final int numProducer = 30;
1:30d3fae:         final int numConsumer = 10;
1:3c83c17:         for (int i = 0; i < numLists; i++) {
1:3c83c17:             for (int j = 0; j < numProducer; j++) {
1:030d09b:                 executor.execute(new Job(i, PListTest.TaskType.ADD, iterations));
1:030d09b:             }
1:3c83c17:             for (int k = 0; k < numConsumer; k++) {
1:3c83c17:                 executor.execute(new Job(i, TaskType.ITERATE, iterations * 2));
1:030d09b:             }
1:030d09b:         }
1:030d09b: 
1:030d09b:         executor.shutdown();
1:030d09b:         LOG.info("wait for parallel work to complete");
1:30d3fae:         boolean shutdown = executor.awaitTermination(5 * 60, TimeUnit.SECONDS);
1:030d09b:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:030d09b:         assertTrue("test did not  timeout ", shutdown);
2:030d09b:         LOG.info("Num dataFiles:" + store.getJournal().getFiles().size());
1:030d09b:     }
1:030d09b: 
1:3c83c17:     enum TaskType {
1:3c83c17:         CREATE, DELETE, ADD, REMOVE, ITERATE, ITERATE_REMOVE
1:3c83c17:     }
1:bf59b7d: 
1:128a8f7:     class Job implements Runnable {
1:128a8f7: 
1:128a8f7:         int id;
1:128a8f7:         TaskType task;
1:128a8f7:         int iterations;
1:128a8f7: 
1:128a8f7:         public Job(int id, TaskType t, int iterations) {
1:128a8f7:             this.id = id;
1:128a8f7:             this.task = t;
1:128a8f7:             this.iterations = iterations;
1:bf59b7d:         }
1:128a8f7: 
1:128a8f7:         @Override
1:128a8f7:         public void run() {
1:bf59b7d:             final String threadName = Thread.currentThread().getName();
1:128a8f7:             try {
1:d5dd937:                 PListImpl plist = null;
1:128a8f7:                 switch (task) {
1:128a8f7:                     case CREATE:
1:3c83c17:                         Thread.currentThread().setName("C:" + id);
1:bf59b7d:                         plist = store.getPList(String.valueOf(id));
1:bf59b7d:                         LOG.info("Job-" + id + ", CREATE");
1:128a8f7:                         break;
1:128a8f7:                     case DELETE:
1:3c83c17:                         Thread.currentThread().setName("D:" + id);
1:bf59b7d:                         store.removePList(String.valueOf(id));
1:128a8f7:                         break;
1:128a8f7:                     case ADD:
1:3c83c17:                         Thread.currentThread().setName("A:" + id);
1:bf59b7d:                         plist = store.getPList(String.valueOf(id));
1:128a8f7: 
1:128a8f7:                         for (int j = 0; j < iterations; j++) {
1:bf59b7d:                             synchronized (plistLocks(plist)) {
1:030d09b:                                 if (exceptions.isEmpty()) {
1:3c83c17:                                     plist.addLast("PL>" + id + idSeed + "-" + j, payload);
1:030d09b:                                 } else {
1:030d09b:                                     break;
1:030d09b:                                 }
1:bf59b7d:                             }
1:128a8f7:                         }
1:030d09b: 
1:030d09b:                         if (exceptions.isEmpty()) {
1:030d09b:                             LOG.info("Job-" + id + ", Add, done: " + iterations);
1:030d09b:                         }
1:128a8f7:                         break;
1:128a8f7:                     case REMOVE:
1:3c83c17:                         Thread.currentThread().setName("R:" + id);
1:bf59b7d:                         plist = store.getPList(String.valueOf(id));
1:bf59b7d:                         synchronized (plistLocks(plist)) {
1:128a8f7: 
1:3c83c17:                             for (int j = iterations - 1; j >= 0; j--) {
1:3c83c17:                                 plist.remove("PL>" + id + idSeed + "-" + j);
1:bf59b7d:                                 if (j > 0 && j % (iterations / 2) == 0) {
1:bf59b7d:                                     LOG.info("Job-" + id + " Done remove: " + j);
1:bf59b7d:                                 }
1:128a8f7:                             }
1:128a8f7:                         }
1:128a8f7:                         break;
1:128a8f7:                     case ITERATE:
1:3c83c17:                         Thread.currentThread().setName("I:" + id);
1:bf59b7d:                         plist = store.getPList(String.valueOf(id));
1:030d09b:                         int iterateCount = 0;
1:bf59b7d:                         synchronized (plistLocks(plist)) {
1:030d09b:                             if (exceptions.isEmpty()) {
1:030d09b:                                 Iterator<PListEntry> iterator = plist.iterator();
1:030d09b:                                 while (iterator.hasNext() && exceptions.isEmpty()) {
1:030d09b:                                     iterator.next();
1:030d09b:                                     iterateCount++;
1:030d09b:                                 }
1:030d09b: 
1:3c83c17:                                 // LOG.info("Job-" + id + " Done iterate: it=" +
1:3c83c17:                                 // iterator + ", count:" + iterateCount +
1:3c83c17:                                 // ", size:" + plist.size());
1:030d09b:                                 if (plist.size() != iterateCount) {
1:030d09b:                                     System.err.println("Count Wrong: " + iterator);
1:030d09b:                                 }
1:3c83c17:                                 assertEquals("iterate got all " + id + " iterator:" + iterator, plist.size(), iterateCount);
1:bf59b7d:                             }
1:128a8f7:                         }
1:128a8f7:                         break;
1:bf59b7d: 
1:bf59b7d:                     case ITERATE_REMOVE:
1:3c83c17:                         Thread.currentThread().setName("IRM:" + id);
1:bf59b7d:                         plist = store.getPList(String.valueOf(id));
1:bf59b7d: 
1:bf59b7d:                         int removeCount = 0;
1:bf59b7d:                         synchronized (plistLocks(plist)) {
1:bf59b7d: 
1:bf59b7d:                             Iterator<PListEntry> removeIterator = plist.iterator();
1:bf59b7d: 
1:bf59b7d:                             while (removeIterator.hasNext()) {
1:030d09b:                                 removeIterator.next();
1:bf59b7d:                                 removeIterator.remove();
1:bf59b7d:                                 if (removeCount++ > iterations) {
1:bf59b7d:                                     break;
1:bf59b7d:                                 }
1:bf59b7d:                             }
1:bf59b7d:                         }
1:bf59b7d:                         LOG.info("Job-" + id + " Done remove: " + removeCount);
1:bf59b7d:                         break;
1:bf59b7d: 
1:128a8f7:                     default:
1:128a8f7:                 }
1:128a8f7: 
1:128a8f7:             } catch (Exception e) {
1:3c83c17:                 LOG.warn("Job[" + id + "] caught exception: " + e.getMessage());
1:128a8f7:                 e.printStackTrace();
1:128a8f7:                 exceptions.add(e);
1:030d09b:                 if (executor != null) {
1:030d09b:                     executor.shutdownNow();
1:030d09b:                 }
1:bf59b7d:             } finally {
1:bf59b7d:                 Thread.currentThread().setName(threadName);
1:128a8f7:             }
1:128a8f7:         }
1:128a8f7:     }
1:128a8f7: 
1:bf59b7d:     Map<PList, Object> locks = new HashMap<PList, Object>();
1:3c83c17: 
1:bf59b7d:     private Object plistLocks(PList plist) {
1:bf59b7d:         Object lock = null;
1:bf59b7d:         synchronized (locks) {
1:bf59b7d:             if (locks.containsKey(plist)) {
1:bf59b7d:                 lock = locks.get(plist);
1:3c83c17:             } else {
1:bf59b7d:                 lock = new Object();
1:bf59b7d:                 locks.put(plist, lock);
1:bf59b7d:             }
1:bf59b7d:         }
1:bf59b7d:         return lock;
1:bf59b7d:     }
1:bf59b7d: 
1:ee55abb:     @Before
1:ee55abb:     public void setUp() throws Exception {
1:7e20661:         File directory = new File("target/test/PlistDB");
1:0619a87:         IOHelper.mkdirs(directory);
1:0619a87:         IOHelper.deleteChildren(directory);
1:ee55abb:         startStore(directory);
1:128a8f7: 
1:128a8f7:     }
1:0619a87: 
1:ee55abb:     protected void startStore(File directory) throws Exception {
1:d5dd937:         store = new PListStoreImpl();
1:0619a87:         store.setDirectory(directory);
1:0619a87:         store.start();
1:bf59b7d:         plist = store.getPList("main");
1:128a8f7:     }
1:0619a87: 
1:ee55abb:     @After
1:ee55abb:     public void tearDown() throws Exception {
1:783ba85:         if (executor != null) {
1:783ba85:             executor.shutdownNow();
1:783ba85:         }
1:0619a87:         store.stop();
1:128a8f7:         exceptions.clear();
1:0619a87:     }
1:0619a87: 
1:f24edca: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:d635a36
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PList.PListIterator;
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(plist.messageSize() > 0);
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(plist.messageSize() > 0);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, plist.messageSize());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, plist.messageSize());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, plist.messageSize());
author:gtully
-------------------------------------------------------------------------------
commit:30d3fae
/////////////////////////////////////////////////////////////////////////
1:         executor = Executors.newFixedThreadPool(100);
1:         final int numProducer = 30;
1:         final int numConsumer = 10;
/////////////////////////////////////////////////////////////////////////
1:         boolean shutdown = executor.awaitTermination(5 * 60, TimeUnit.SECONDS);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
commit:3c83c17
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IOHelper;
/////////////////////////////////////////////////////////////////////////
1:             if (iterator.hasNext()) {
1:         } finally {
/////////////////////////////////////////////////////////////////////////
1:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(), entry.getByteSequence().getLength());
1:     @Test
/////////////////////////////////////////////////////////////////////////
1:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(), entry.getByteSequence().getLength());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, plist.size());
1:         assertEquals(0, plist.size());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(0, plist.size());
/////////////////////////////////////////////////////////////////////////
1:         store.setJournalMaxFileLength(1024 * 5);
1:         final ByteSequence payload = new ByteSequence(new byte[1024 * 2]);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < numLists; i++) {
1:             Thread.currentThread().setName("C:" + String.valueOf(i));
/////////////////////////////////////////////////////////////////////////
1:                     for (int i = 0; i < iterations; i++) {
1:                         PList candidate = lists[i % numLists];
1:                         Thread.currentThread().setName("ALRF:" + candidate.getName());
1:                             Object locator = candidate.addLast(String.valueOf(i), payload);
1:                             assertTrue(candidate.remove(locator));
1:                 } finally {
1:         class B implements Runnable {
1:                     for (int i = 0; i < iterations; i++) {
1:                         PList candidate = lists[i % numLists];
1:                         Thread.currentThread().setName("ALRF:" + candidate.getName());
1:                         synchronized (plistLocks(candidate)) {
1:                             Object locator = candidate.addLast(String.valueOf(i), payload);
1:                             assertTrue(candidate.remove(locator));
1:                         }
1:                 } finally {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < numThreads; i++) {
1:         for (int i = 0; i < numThreads; i++) {
1:         for (int i = 0; i < 100; i++) {
1:             executor.execute(new Job(i + 20, PListTest.TaskType.ADD, 100));
1:         boolean finishedInTime = executor.awaitTermination(60 * 5, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 2000; i++) {
/////////////////////////////////////////////////////////////////////////
1:         store.setJournalMaxFileLength(1024 * 5);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < numLists; i++) {
1:         for (int i = 0; i < numLists; i++) {
1:         for (int i = 0; i < numLists; i++) {
1:         for (int i = 0; i < numLists; i++) {
1:         for (int i = 0; i < numLists; i++) {
1:         for (int i = 0; i < numLists; i++) {
1:         for (int i = 0; i < numLists; i++) {
1:         executor = Executors.newFixedThreadPool(numLists * 2);
1:         for (int i = 0; i < numLists * 2; i++) {
1:             executor.execute(new Job(i, i >= numLists ? PListTest.TaskType.ADD : PListTest.TaskType.REMOVE, iterations));
1:         boolean finishedInTime = executor.awaitTermination(60 * 5, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < numRepeats; i++) {
1:         for (int i = 0; i < numRepeats; i++) {
/////////////////////////////////////////////////////////////////////////
1:         store.setIndexPageSize(2 * 1024);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < numLists; i++) {
1:         for (int i = 0; i < numLists; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < numLists; i++) {
1:             for (int j = 0; j < numProducer; j++) {
1:                 executor.execute(new Job(i, PListTest.TaskType.ADD, iterations * 2));
1:             for (int k = 0; k < numConsumer; k++) {
1:                 executor.execute(new Job(i, TaskType.ITERATE_REMOVE, iterations / 4));
1:         for (int i = numLists; i < numLists * 10; i++) {
1:         }
1:         boolean shutdown = executor.awaitTermination(60 * 60, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
1:         store.setIndexPageSize(2 * 1024);
1:         store.setJournalMaxFileLength(1024 * 1024);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < numLists; i++) {
1:         // We want a lot of adds occurring so that new free pages get created
1:         // along
1:         // with overlapping seeks from the iterators so that we are likely to
1:         // seek into
1:         for (int i = 0; i < numLists; i++) {
1:             for (int j = 0; j < numProducer; j++) {
1:             for (int k = 0; k < numConsumer; k++) {
1:                 executor.execute(new Job(i, TaskType.ITERATE, iterations * 2));
0:         boolean shutdown = executor.awaitTermination(60 * 60, TimeUnit.SECONDS);
1:     enum TaskType {
1:         CREATE, DELETE, ADD, REMOVE, ITERATE, ITERATE_REMOVE
1:     }
/////////////////////////////////////////////////////////////////////////
1:                         Thread.currentThread().setName("C:" + id);
1:                         Thread.currentThread().setName("D:" + id);
1:                         Thread.currentThread().setName("A:" + id);
1:                                     plist.addLast("PL>" + id + idSeed + "-" + j, payload);
/////////////////////////////////////////////////////////////////////////
1:                         Thread.currentThread().setName("R:" + id);
1:                             for (int j = iterations - 1; j >= 0; j--) {
1:                                 plist.remove("PL>" + id + idSeed + "-" + j);
/////////////////////////////////////////////////////////////////////////
1:                         Thread.currentThread().setName("I:" + id);
/////////////////////////////////////////////////////////////////////////
1:                                 // LOG.info("Job-" + id + " Done iterate: it=" +
1:                                 // iterator + ", count:" + iterateCount +
1:                                 // ", size:" + plist.size());
1:                                 assertEquals("iterate got all " + id + " iterator:" + iterator, plist.size(), iterateCount);
1:                         Thread.currentThread().setName("IRM:" + id);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Job[" + id + "] caught exception: " + e.getMessage());
/////////////////////////////////////////////////////////////////////////
1: 
1:             } else {
commit:53f07b0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:030d09b
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected void doTestRemove(final int COUNT) throws IOException {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             iterator.next();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                             candidate.getFirst();
/////////////////////////////////////////////////////////////////////////
0:                             candidate.getFirst();
/////////////////////////////////////////////////////////////////////////
1:         store.setIndexWriteBatchSize(500);
/////////////////////////////////////////////////////////////////////////
1:     @Test
0:     public void testSerialAddIterate() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
0:         store = new PListStore();
0:         store.setIndexPageSize(512);
0:         store.setJournalMaxFileLength(100*1024);
1:         store.setDirectory(directory);
1:         store.setCleanupInterval(-1);
1:         store.setIndexEnablePageCaching(false);
0:         store.setIndexWriteBatchSize(2000);
0:         store.setEnableIndexWriteAsync(false);
1:         store.start();
1: 
1:         final int iterations = 1000;
0:         final int numLists = 1;
1: 
1:         LOG.info("create");
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.CREATE, iterations).run();
1:         }
1: 
0:         LOG.info("serial add and iterate");
0:         for (int i=0; i<iterations; i++) {
0:             new Job(0, TaskType.ADD, i).run();
0:             new Job(0, TaskType.ITERATE, 0).run();
1:         }
1: 
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:         LOG.info("Num dataFiles:" + store.getJournal().getFiles().size());
1:     }
1: 
1:     @Test
1:     public void testConcurrentAddIterate() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
0:         store = new PListStore();
0:         store.setIndexPageSize(2*1024);
0:         store.setJournalMaxFileLength(1024*1024);
1:         store.setDirectory(directory);
1:         store.setCleanupInterval(-1);
1:         store.setIndexEnablePageCaching(false);
1:         store.setIndexWriteBatchSize(100);
1:         store.start();
1: 
1:         final int iterations = 250;
1:         final int numLists = 10;
1: 
1:         LOG.info("create");
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.CREATE, iterations).run();
1:         }
1: 
1:         LOG.info("parallel add and iterate");
0:         // We want a lot of adds occurring so that new free pages get created along
0:         // with overlapping seeks from the iterators so that we are likely to seek into
1:         // some bad area in the page file.
1:         executor = Executors.newFixedThreadPool(400);
0:         final int numProducer = 300;
0:         final int numConsumer = 100;
0:         for (int i=0; i<numLists; i++) {
0:             for (int j=0; j<numProducer; j++) {
1:                 executor.execute(new Job(i, PListTest.TaskType.ADD, iterations));
1:             }
0:             for (int k=0;k<numConsumer; k++) {
0:                 executor.execute(new Job(i, TaskType.ITERATE, iterations*2));
1:             }
1:         }
1: 
1:         executor.shutdown();
1:         LOG.info("wait for parallel work to complete");
0:         boolean shutdown = executor.awaitTermination(60*60, TimeUnit.SECONDS);
1:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
1:         assertTrue("test did not  timeout ", shutdown);
1:         LOG.info("Num dataFiles:" + store.getJournal().getFiles().size());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 if (exceptions.isEmpty()) {
0:                                     plist.addLast ("PL>"  + id + idSeed + "-" + j, payload);
1:                                 } else {
1:                                     break;
1:                                 }
1: 
1:                         if (exceptions.isEmpty()) {
1:                             LOG.info("Job-" + id + ", Add, done: " + iterations);
1:                         }
/////////////////////////////////////////////////////////////////////////
1:                         int iterateCount = 0;
1:                             if (exceptions.isEmpty()) {
1:                                 Iterator<PListEntry> iterator = plist.iterator();
1:                                 while (iterator.hasNext() && exceptions.isEmpty()) {
1:                                     iterator.next();
1:                                     iterateCount++;
1:                                 }
1: 
0:                                 //LOG.info("Job-" + id + " Done iterate: it=" + iterator + ", count:" + iterateCount + ", size:" + plist.size());
1:                                 if (plist.size() != iterateCount) {
1:                                     System.err.println("Count Wrong: " + iterator);
1:                                 }
0:                                 assertEquals("iterate got all " + id + " iterator:" + iterator , plist.size(), iterateCount);
/////////////////////////////////////////////////////////////////////////
1:                                 removeIterator.next();
/////////////////////////////////////////////////////////////////////////
0:                 LOG.warn("Job["+id+"] caught exception: " + e.getMessage());
1:                 if (executor != null) {
1:                     executor.shutdownNow();
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         File directory = new File("/tmp/target/test/PlistDB");
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:32e63dc
/////////////////////////////////////////////////////////////////////////
1:     private PListEntry getFirst(PList plist) throws IOException {
1:         PList.PListIterator iterator = plist.iterator();
1:         try {
0:             if( iterator.hasNext() ) {
1:                 return iterator.next();
1:             } else {
1:                 return null;
1:             }
0:         }finally {
1:             iterator.release();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                             getFirst(candidate);
/////////////////////////////////////////////////////////////////////////
1:                             getFirst(candidate);
commit:d5dd937
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PList;
1: import org.apache.activemq.store.PListEntry;
/////////////////////////////////////////////////////////////////////////
1:     private PListStoreImpl store;
1:     private PListImpl plist;
/////////////////////////////////////////////////////////////////////////
1:         store = new PListStoreImpl();
/////////////////////////////////////////////////////////////////////////
1:         store = new PListStoreImpl();
/////////////////////////////////////////////////////////////////////////
1:         store = new PListStoreImpl();
/////////////////////////////////////////////////////////////////////////
1:         store = new PListStoreImpl();
/////////////////////////////////////////////////////////////////////////
1:         store = new PListStoreImpl();
/////////////////////////////////////////////////////////////////////////
1:         store = new PListStoreImpl();
/////////////////////////////////////////////////////////////////////////
1:                 PListImpl plist = null;
/////////////////////////////////////////////////////////////////////////
1:         store = new PListStoreImpl();
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ByteSequence;
author:Gary Tully
-------------------------------------------------------------------------------
commit:7e20661
/////////////////////////////////////////////////////////////////////////
1:         File directory = new File("target/test/PlistDB");
commit:783ba85
/////////////////////////////////////////////////////////////////////////
1:         boolean finishedInTime = executor.awaitTermination(30, TimeUnit.SECONDS);
1:         assertTrue("finished ok", finishedInTime);
/////////////////////////////////////////////////////////////////////////
0:         boolean finishedInTime = executor.awaitTermination(60*5, TimeUnit.SECONDS);
1:         assertTrue("finished ok", finishedInTime);
/////////////////////////////////////////////////////////////////////////
0:         boolean finishedInTime = executor.awaitTermination(60*5, TimeUnit.SECONDS);
1:         assertTrue("finished ok", finishedInTime);
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("no exceptions: " + exceptions, exceptions.isEmpty());
/////////////////////////////////////////////////////////////////////////
1:         if (executor != null) {
1:             executor.shutdownNow();
1:         }
commit:c709527
/////////////////////////////////////////////////////////////////////////
1:         final int iterations = 1000;
/////////////////////////////////////////////////////////////////////////
0:         final int iterations = 1000;
/////////////////////////////////////////////////////////////////////////
1:         final int iterations = 500;
/////////////////////////////////////////////////////////////////////////
1:         final int iterations = 500;
1:         final int numLists = 10;
/////////////////////////////////////////////////////////////////////////
1:         final int numConsumer = 10;
commit:7d082c3
/////////////////////////////////////////////////////////////////////////
1:         store.setLazyInit(false);
commit:bf59b7d
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     final String idSeed = new String("Seed" + new byte[1024]);
1:     ExecutorService executor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testRemoveSingleEntry() throws Exception {
1:         plist.addLast("First", new ByteSequence("A".getBytes()));
1: 
1:         Iterator<PListEntry> iterator = plist.iterator();
1:         while (iterator.hasNext()) {
0:             PListEntry v = iterator.next();
1:             iterator.remove();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         assertFalse(plist.remove(0));
/////////////////////////////////////////////////////////////////////////
1:         store.setCleanupInterval(400);
0:         final ByteSequence payload = new ByteSequence(new byte[1024*2]);
0:         final int iterations = 5000;
1:         String threadName = Thread.currentThread().getName();
0:             Thread.currentThread().setName("C:"+String.valueOf(i));
1:             lists[i] = store.getPList(String.valueOf(i));
1:         Thread.currentThread().setName(threadName);
1:         executor = Executors.newFixedThreadPool(100);
1:                 final String threadName = Thread.currentThread().getName();
0:                         Thread.currentThread().setName("ALRF:"+candidate.getName());
1:                         synchronized (plistLocks(candidate)) {
0:                             candidate.addLast(String.valueOf(i), payload);
0:                             PListEntry entry = candidate.getFirst();
0:                             assertTrue(candidate.remove(String.valueOf(i)));
1:                         }
1:                     LOG.error("Unexpcted ex", error);
0:                 }  finally {
1:                     Thread.currentThread().setName(threadName);
/////////////////////////////////////////////////////////////////////////
1:                 final String threadName = Thread.currentThread().getName();
0:                         Thread.currentThread().setName("ALRF:"+candidate.getName());
0:                          synchronized (plistLocks(candidate)) {
0:                             candidate.addLast(String.valueOf(i), payload);
0:                             PListEntry entry = candidate.getFirst();
0:                             assertTrue(candidate.remove(String.valueOf(i)));
1:                          }
0:                 }  finally {
1:                     Thread.currentThread().setName(threadName);
/////////////////////////////////////////////////////////////////////////
1:         executor = Executors.newFixedThreadPool(100);
/////////////////////////////////////////////////////////////////////////
0:         executor = Executors.newFixedThreadPool(numLists*2);
/////////////////////////////////////////////////////////////////////////
1:     // for non determinant issues, increasing this may help diagnose
1:     final int numRepeats = 1;
1: 
1:     @Test
1:     public void testRepeatStressWithCache() throws Exception {
0:         for (int i=0; i<numRepeats;i++) {
1:             do_testConcurrentAddIterateRemove(true);
1:         }
1:     }
1: 
1:     @Test
1:     public void testRepeatStressWithOutCache() throws Exception {
0:         for (int i=0; i<numRepeats;i++) {
1:             do_testConcurrentAddIterateRemove(false);
1:         }
1:     }
1: 
1:     public void do_testConcurrentAddIterateRemove(boolean enablePageCache) throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
0:         store = new PListStore();
1:         store.setIndexEnablePageCaching(enablePageCache);
0:         store.setIndexPageSize(2*1024);
1:         store.setDirectory(directory);
1:         store.start();
1: 
0:         final int iterations = 5000;
0:         final int numLists = 50;
1: 
1:         LOG.info("create");
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.CREATE, iterations).run();
1:         }
1: 
1:         LOG.info("fill");
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:         }
1: 
1:         LOG.info("parallel add and remove");
0:         executor = Executors.newFixedThreadPool(400);
1:         final int numProducer = 5;
0:         final int numConsumer = 50;
0:         for (int i=0; i<numLists; i++) {
0:             for (int j=0; j<numProducer; j++) {
0:                 executor.execute(new Job(i, PListTest.TaskType.ADD, iterations*2));
1:             }
0:             for (int k=0;k<numConsumer; k++) {
0:                 executor.execute(new Job(i, TaskType.ITERATE_REMOVE, iterations/4));
1:             }
1:         }
1: 
0:          for (int i=numLists; i<numLists*10; i++) {
1:             executor.execute(new Job(i, PListTest.TaskType.ADD, iterations));
1:          }
1: 
1:         executor.shutdown();
1:         LOG.info("wait for parallel work to complete");
0:         boolean shutdown = executor.awaitTermination(60*60, TimeUnit.SECONDS);
1:         assertTrue("test did not  timeout ", shutdown);
1:         assertTrue("no exceptions", exceptions.isEmpty());
1:     }
1: 
0:     enum TaskType {CREATE, DELETE, ADD, REMOVE, ITERATE, ITERATE_REMOVE}
/////////////////////////////////////////////////////////////////////////
1:             final String threadName = Thread.currentThread().getName();
0:                         Thread.currentThread().setName("C:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1:                         LOG.info("Job-" + id + ", CREATE");
0:                         Thread.currentThread().setName("D:"+id);
1:                         store.removePList(String.valueOf(id));
0:                         Thread.currentThread().setName("A:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1:                             synchronized (plistLocks(plist)) {
0:                                 plist.addLast ("PL>"  + id + idSeed + "-" + j, payload);
0:                         LOG.info("Job-" + id + ", Add, done: " + iterations);
0:                         Thread.currentThread().setName("R:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1:                         synchronized (plistLocks(plist)) {
0:                             for (int j = iterations -1; j >= 0; j--) {
0:                                 plist.remove("PL>"  + id + idSeed + "-" + j);
1:                                 if (j > 0 && j % (iterations / 2) == 0) {
1:                                     LOG.info("Job-" + id + " Done remove: " + j);
1:                                 }
0:                         Thread.currentThread().setName("I:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1:                         synchronized (plistLocks(plist)) {
0:                             Iterator<PListEntry> iterator = plist.iterator();
0:                             PListEntry element = null;
0:                             while (iterator.hasNext()) {
0:                                 element = iterator.next();
1:                             }
1: 
1:                     case ITERATE_REMOVE:
0:                         Thread.currentThread().setName("IRM:"+id);
1:                         plist = store.getPList(String.valueOf(id));
1: 
1:                         int removeCount = 0;
1:                         synchronized (plistLocks(plist)) {
1: 
1:                             Iterator<PListEntry> removeIterator = plist.iterator();
0:                             PListEntry v = null;
1: 
1:                             while (removeIterator.hasNext()) {
0:                                 v = removeIterator.next();
1:                                 removeIterator.remove();
1:                                 if (removeCount++ > iterations) {
1:                                     break;
1:                                 }
1:                             }
1:                         }
1:                         LOG.info("Job-" + id + " Done remove: " + removeCount);
1:                         break;
1: 
0:                 executor.shutdownNow();
1:             } finally {
1:                 Thread.currentThread().setName(threadName);
1:     Map<PList, Object> locks = new HashMap<PList, Object>();
1:     private Object plistLocks(PList plist) {
1:         Object lock = null;
1:         synchronized (locks) {
1:             if (locks.containsKey(plist)) {
1:                 lock = locks.get(plist);
0:              } else {
1:                 lock = new Object();
1:                 locks.put(plist, lock);
1:             }
1:         }
1:         return lock;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         plist = store.getPList("main");
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:         long count = plist.size() - 1;
/////////////////////////////////////////////////////////////////////////
1:             plist.remove(entry.getId());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final int iterations = 5000;
0:         LOG.info("create");
1:         LOG.info("delete");
1:         LOG.info("fill");
1:         LOG.info("remove");
1: 
1:         LOG.info("check empty");
0:         for (int i=0; i<numLists;i++) {
1:             assertEquals("empty " + i, 0, store.getPList("List-" + i).size());
1:         }
1: 
1:         LOG.info("delete again");
1:         LOG.info("fill again");
1:         LOG.info("parallel add and remove");
0:         ExecutorService executor = Executors.newFixedThreadPool(numLists*2);
1:         LOG.info("wait for parallel work to complete");
1:         assertTrue("no exceptions", exceptions.isEmpty());
/////////////////////////////////////////////////////////////////////////
0:                         for (int j = iterations -1; j >= 0; j--) {
/////////////////////////////////////////////////////////////////////////
0:                         Iterator<PListEntry> iterator = plist.iterator();
0:                         PListEntry element = null;
0:                         while (iterator.hasNext()) {
0:                             element = iterator.next();
commit:128a8f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     static final Logger LOG = LoggerFactory.getLogger(PListTest.class);
1:     final ByteSequence payload = new ByteSequence(new byte[400]);
0:     final String idSeed = new String("Seed");
1:     final Vector<Throwable> exceptions = new Vector<Throwable>();
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testConcurrentAddLast() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
0:         store = new PListStore();
1:         store.setDirectory(directory);
0:         //store.setJournalMaxFileLength(1024*5);
1:         store.start();
1: 
1: 
1:         final int numThreads = 20;
0:         final int iterations = 2000;
0:         ExecutorService executor = Executors.newFixedThreadPool(100);
0:         for (int i=0; i<numThreads; i++) {
1:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:         }
1: 
0:         for (int i=0; i<numThreads; i++) {
1:             executor.execute(new Job(i, PListTest.TaskType.ITERATE, iterations));
1:         }
1: 
0:         for (int i=0; i<100; i++) {
0:             executor.execute(new Job(i+20, PListTest.TaskType.ADD, 100));
1:         }
1: 
1:         executor.shutdown();
0:         executor.awaitTermination(60*5, TimeUnit.SECONDS);
1:     }
1: 
1:     @Test
1:     public void testOverFlow() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
0:         store = new PListStore();
1:         store.setDirectory(directory);
1:         store.start();
1: 
0:         for (int i=0;i<2000; i++) {
1:             new Job(i, PListTest.TaskType.ADD, 5).run();
1: 
1:         }
1:         LOG.info("After Load index file: " + store.pageFile.getFile().length());
1:         LOG.info("After remove index file: " + store.pageFile.getFile().length());
1:     }
1: 
1: 
1:     @Test
1:     public void testConcurrentAddRemoveWithPreload() throws Exception {
1:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
0:         store = new PListStore();
1:         store.setDirectory(directory);
0:         store.setJournalMaxFileLength(1024*5);
1:         store.setCleanupInterval(5000);
1:         store.start();
1: 
0:         final int iterations = 500;
1:         final int numLists = 10;
1: 
1:         // prime the store
1: 
1:         // create/delete
0:         for (int i=0; i<numLists;i++) {
0:             new Job(i, PListTest.TaskType.CREATE, iterations).run();
1:         }
1: 
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.DELETE, iterations).run();
1:         }
1: 
0:         // fill
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:         }
0:         // empty
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.REMOVE, iterations).run();
1:         }
0:         // empty
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.DELETE, iterations).run();
1:         }
1: 
0:         // fill
0:         for (int i=0; i<numLists;i++) {
1:             new Job(i, PListTest.TaskType.ADD, iterations).run();
1:         }
1: 
0:         // parallel
0:         ExecutorService executor = Executors.newFixedThreadPool(100);
0:         for (int i=0; i<numLists*2; i++) {
0:             executor.execute(new Job(i, i>=numLists ? PListTest.TaskType.ADD : PListTest.TaskType.REMOVE, iterations));
1:         }
1: 
1:         executor.shutdown();
0:         executor.awaitTermination(60*5, TimeUnit.SECONDS);
0:         assertTrue("no excepitons", exceptions.isEmpty());
1:     }
1: 
0:     enum TaskType {CREATE, DELETE, ADD, REMOVE, ITERATE}
1: 
1:     class Job implements Runnable {
1: 
1:         int id;
1:         TaskType task;
1:         int iterations;
1: 
1:         public Job(int id, TaskType t, int iterations) {
1:             this.id = id;
1:             this.task = t;
1:             this.iterations = iterations;
1:         }
1: 
1:         @Override
1:         public void run() {
1:             try {
0:                 PList plist = null;
1:                 switch (task) {
1:                     case CREATE:
0:                         plist = store.getPList("List-" + id);
1:                         break;
1:                     case DELETE:
0:                         store.removePList("List-" + id);
1:                         break;
1:                     case ADD:
0:                         plist = store.getPList("List-" + id);
1: 
1:                         for (int j = 0; j < iterations; j++) {
0:                             plist.addLast(idSeed + "id" + j, payload);
0:                             if (j > 0 && j % (iterations / 2) == 0) {
0:                                 LOG.info("Job-" + id + ", Done: " + j);
1:                             }
1:                         }
1:                         break;
1:                     case REMOVE:
0:                         plist = store.getPList("List-" + id);
1: 
0:                         for (int j = iterations; j > 0; j--) {
0:                             plist.remove(idSeed + "id" + j);
0:                             if (j > 0 && j % (iterations / 2) == 0) {
0:                                 LOG.info("Job-" + id + " Done remove: " + j);
1:                             }
1:                         }
1:                         break;
1:                     case ITERATE:
0:                         plist = store.getPList("List-" + id);
1: 
0:                         PListEntry element = plist.getFirst();
0:                         while (element != null) {
0:                             element = plist.getNext(element);
1:                         }
1:                         break;
1:                     default:
1:                 }
1: 
1:             } catch (Exception e) {
1:                 e.printStackTrace();
1:                 exceptions.add(e);
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         exceptions.clear();
commit:0619a87
/////////////////////////////////////////////////////////////////////////
1: import java.util.Vector;
0: import java.util.concurrent.Executor;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     @Test
1:     public void testConcurrentAddRemove() throws Exception {
0:         File directory = store.getDirectory();
1:         store.stop();
1:         IOHelper.mkdirs(directory);
1:         IOHelper.deleteChildren(directory);
0:         store = new PListStore();
1:         store.setDirectory(directory);
0:         store.setJournalMaxFileLength(1024*5);
1:         store.start();
1: 
0:         final ByteSequence payload = new ByteSequence(new byte[1024*4]);
1: 
1: 
1:         final Vector<Throwable> exceptions = new Vector<Throwable>();
0:         final int iterations = 1000;
1:         final int numLists = 10;
1: 
1:         final PList[] lists = new PList[numLists];
0:         for (int i=0; i<numLists; i++) {
0:             lists[i] = store.getPList("List" + i);
1:         }
1: 
0:         ExecutorService executor = Executors.newFixedThreadPool(100);
1:         class A implements Runnable {
1:             @Override
1:             public void run() {
1:                 try {
0:                     for (int i=0; i<iterations; i++) {
0:                         PList candidate = lists[i%numLists];
0:                         candidate.addLast(String.valueOf(i), payload);
0:                         PListEntry entry = candidate.getFirst();
0:                         assertTrue(candidate.remove(String.valueOf(i)));
1:                     }
1:                 } catch (Exception error) {
1:                     error.printStackTrace();
1:                     exceptions.add(error);
1:                 }
1:             }
1:         };
1: 
0:         class B implements  Runnable {
1:             @Override
1:             public void run() {
1:                 try {
0:                     for (int i=0; i<iterations; i++) {
0:                         PList candidate = lists[i%numLists];
0:                         candidate.addLast(String.valueOf(i), payload);
0:                         PListEntry entry = candidate.getFirst();
0:                         assertTrue(candidate.remove(String.valueOf(i)));
1:                     }
1:                 } catch (Exception error) {
1:                     error.printStackTrace();
1:                     exceptions.add(error);
1:                 }
1:             }
1:         };
1: 
1:         executor.execute(new A());
1:         executor.execute(new A());
1:         executor.execute(new A());
1:         executor.execute(new B());
1:         executor.execute(new B());
1:         executor.execute(new B());
1: 
1:         executor.shutdown();
0:         executor.awaitTermination(30, TimeUnit.SECONDS);
1: 
0:         assertTrue("no exceptions", exceptions.isEmpty());
1:     }
commit:f24edca
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertFalse;
1: import static org.junit.Assert.assertTrue;
/////////////////////////////////////////////////////////////////////////
0:     
1:     @Test
1:     public void testRemoveSecond() throws Exception {
1:         plist.addLast("First", new ByteSequence("A".getBytes()));
1:         plist.addLast("Second", new ByteSequence("B".getBytes()));
0:         
1:         assertTrue(plist.remove("Second"));
1:         assertTrue(plist.remove("First"));
1:         assertFalse(plist.remove("doesNotExist"));
1:     }
0:     
0:     
1:     @Test
1:     public void testRemoveSecondPosition() throws Exception {
1:         plist.addLast("First", new ByteSequence("A".getBytes()));
1:         plist.addLast("Second", new ByteSequence("B".getBytes()));
0:         
1:         assertTrue(plist.remove(1));
1:         assertTrue(plist.remove(0));
0:         assertFalse(plist.remove(3));
1:     }
0:     
commit:af31f2d
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertNull;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         doTestRemove(2000);
1:     }
0:     
0:     protected void doTestRemove(final int COUNT) throws IOException {            
/////////////////////////////////////////////////////////////////////////
1:     @Test
1:     public void testDestroy() throws Exception {
1:         doTestRemove(1);
1:         plist.destroy();
0:         assertEquals(0,plist.size());
1:     }
0:     
1:     @Test
1:     public void testDestroyNonEmpty() throws Exception {
1:         final int COUNT = 1000;
1:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             map.put(test, bs);
1:             plist.addLast(test, bs);
1:         }
1:         plist.destroy();
0:         assertEquals(0,plist.size());
0:         assertNull("no first entry", plist.getFirst());
author:Robert Davies
-------------------------------------------------------------------------------
commit:799c033
/////////////////////////////////////////////////////////////////////////
1:         final int COUNT = 1000;
/////////////////////////////////////////////////////////////////////////
1:         final int COUNT = 1000;
/////////////////////////////////////////////////////////////////////////
0:         final int COUNT = 2000;
commit:dad4f49
/////////////////////////////////////////////////////////////////////////
0:    
commit:ee55abb
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.kahadb.plist;
0: 
1: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.fail;
1: import java.io.File;
1: import java.io.IOException;
1: import java.util.LinkedHashMap;
1: import java.util.Map;
0: import org.apache.activemq.util.IOHelper;
0: import org.apache.kahadb.util.ByteSequence;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
0: 
1: public class PListTest {
0: 
0:     private PListStore store;
0:     private PList plist;
0:     
0: 
1:     @Test
0:     public void testIterator() throws Exception {
0:         final int COUNT = 10;
1:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             map.put(test, bs);
1:             plist.addLast(test, bs);
1:         }
1:         assertEquals(plist.size(), COUNT);
0:         int number = 0;
1:         PListEntry entry = plist.getFirst();
1:         while (entry != null) {
0:             entry = plist.getNext(entry);
0:             number++;
0:             if (entry != null) {
0:             plist.remove(entry.copy());
1:             }
1:         }
0:         assertEquals(COUNT, number);
1:     }
0: 
1:     @Test
1:     public void testAddLast() throws Exception {
0:         final int COUNT = 100;
1:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             map.put(test, bs);
1:             plist.addLast(test, bs);
1:         }
1:         assertEquals(plist.size(), COUNT);
1:         int count = 0;
1:         for (ByteSequence bs : map.values()) {
1:             String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:             PListEntry entry = plist.get(count);
0:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(),
0:                     entry.getByteSequence().getLength());
1:             assertEquals(origStr, plistString);
1:             count++;
1:         }
1:     }
0: 
1:    @Test
1:     public void testAddFirst() throws Exception {
0:         final int COUNT = 100;
1:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             map.put(test, bs);
1:             plist.addFirst(test, bs);
1:         }
1:         assertEquals(plist.size(), COUNT);
0:         int count = plist.size() - 1;
1:         for (ByteSequence bs : map.values()) {
1:             String origStr = new String(bs.getData(), bs.getOffset(), bs.getLength());
1:             PListEntry entry = plist.get(count);
0:             String plistString = new String(entry.getByteSequence().getData(), entry.getByteSequence().getOffset(),
0:                     entry.getByteSequence().getLength());
1:             assertEquals(origStr, plistString);
1:             count--;
1:         }
1:     }
0: 
1:     @Test
1:     public void testRemove() throws IOException {
0:         final int COUNT = 200;
1:         Map<String, ByteSequence> map = new LinkedHashMap<String, ByteSequence>();
1:         for (int i = 0; i < COUNT; i++) {
1:             String test = new String("test" + i);
1:             ByteSequence bs = new ByteSequence(test.getBytes());
1:             map.put(test, bs);
1:             plist.addLast(test, bs);
1:         }
1:         assertEquals(plist.size(), COUNT);
1:         PListEntry entry = plist.getFirst();
1:         while (entry != null) {
0:             plist.remove(entry.copy());
1:             entry = plist.getFirst();
1:         }
0:         assertEquals(0,plist.size());
0: 
1:     }
0: 
0:     //@Test
0:     public void testDestroy() {
0:         fail("Not yet implemented");
1:     }
0: 
1:     @Before
1:     public void setUp() throws Exception {
0:         File directory = new File("target/test/PlistDB");
0:         IOHelper.mkdirs(directory);
0:         IOHelper.deleteChildren(directory);
1:         startStore(directory);
0: 
1:     }
0: 
1:     protected void startStore(File directory) throws Exception {
0:         store = new PListStore();
0:         store.setDirectory(directory);
0:         store.start();
0:         plist = store.getPList("test");
1:     }
0: 
1:     @After
1:     public void tearDown() throws Exception {
0:         store.stop();
1:     }
0: 
1: }
============================================================================