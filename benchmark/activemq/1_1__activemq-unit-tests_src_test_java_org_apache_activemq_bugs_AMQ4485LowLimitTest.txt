1:54e2e3b: /**
1:54e2e3b:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:54e2e3b:  * contributor license agreements.  See the NOTICE file distributed with
1:54e2e3b:  * this work for additional information regarding copyright ownership.
1:54e2e3b:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:54e2e3b:  * (the "License"); you may not use this file except in compliance with
1:54e2e3b:  * the License.  You may obtain a copy of the License at
1:54e2e3b:  *
1:54e2e3b:  *      http://www.apache.org/licenses/LICENSE-2.0
1:54e2e3b:  *
1:54e2e3b:  * Unless required by applicable law or agreed to in writing, software
1:54e2e3b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:54e2e3b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:54e2e3b:  * See the License for the specific language governing permissions and
1:54e2e3b:  * limitations under the License.
1:54e2e3b:  */
1:54e2e3b: package org.apache.activemq.bugs;
1:54e2e3b: 
1:54e2e3b: import java.io.IOException;
1:54e2e3b: import java.net.URI;
1:54e2e3b: import java.util.ArrayList;
1:54e2e3b: import java.util.Arrays;
1:54e2e3b: import java.util.Collection;
1:54e2e3b: import java.util.HashMap;
1:54e2e3b: import java.util.Iterator;
1:54e2e3b: import java.util.LinkedList;
1:54e2e3b: import java.util.List;
1:54e2e3b: import java.util.concurrent.ConcurrentLinkedQueue;
1:54e2e3b: import java.util.concurrent.ExecutorService;
1:54e2e3b: import java.util.concurrent.Executors;
1:54e2e3b: import java.util.concurrent.TimeUnit;
1:54e2e3b: import java.util.concurrent.atomic.AtomicInteger;
1:54e2e3b: import javax.jms.JMSException;
1:54e2e3b: import javax.jms.Message;
1:54e2e3b: import javax.jms.MessageListener;
1:54e2e3b: import javax.jms.MessageProducer;
1:54e2e3b: import javax.jms.QueueConnection;
1:54e2e3b: import javax.jms.QueueReceiver;
1:54e2e3b: import javax.jms.QueueSession;
1:54e2e3b: import javax.jms.Session;
1:54e2e3b: import javax.jms.TextMessage;
1:54e2e3b: import javax.management.ObjectName;
1:54e2e3b: import org.apache.activemq.ActiveMQConnection;
1:54e2e3b: import org.apache.activemq.ActiveMQConnectionFactory;
1:54e2e3b: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1:54e2e3b: import org.apache.activemq.broker.BrokerService;
1:54e2e3b: import org.apache.activemq.broker.jmx.QueueViewMBean;
1:54e2e3b: import org.apache.activemq.broker.region.RegionBroker;
1:54e2e3b: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:54e2e3b: import org.apache.activemq.broker.region.policy.PolicyMap;
1:54e2e3b: import org.apache.activemq.command.ActiveMQDestination;
1:54e2e3b: import org.apache.activemq.command.ActiveMQMessage;
1:54e2e3b: import org.apache.activemq.command.ActiveMQQueue;
1:54e2e3b: import org.apache.activemq.command.BrokerInfo;
1:54e2e3b: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:54e2e3b: import org.apache.activemq.network.NetworkConnector;
1:54e2e3b: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:54e2e3b: import org.apache.activemq.util.TimeUtils;
1:54e2e3b: import org.apache.activemq.util.Wait;
1:54e2e3b: import org.slf4j.Logger;
1:54e2e3b: import org.slf4j.LoggerFactory;
1:54e2e3b: 
1:54e2e3b: public class AMQ4485LowLimitTest extends JmsMultipleBrokersTestSupport {
1:54e2e3b:     static final String payload = new String(new byte[10 * 1024]);
1:54e2e3b:     private static final Logger LOG = LoggerFactory.getLogger(AMQ4485LowLimitTest.class);
1:54e2e3b:     final int portBase = 61600;
1:1a0bd45:     int numBrokers = 8;
1:54e2e3b:     final int numProducers = 30;
1:54e2e3b:     final int numMessages = 1000;
1:54e2e3b:     final int consumerSleepTime = 40;
1:54e2e3b:     StringBuilder brokersUrl = new StringBuilder();
1:54e2e3b:     HashMap<ActiveMQQueue, AtomicInteger> accumulators = new HashMap<ActiveMQQueue, AtomicInteger>();
1:54e2e3b:     private ArrayList<Throwable> exceptions = new ArrayList<Throwable>();
1:54e2e3b: 
1:54e2e3b:     protected void buildUrlList() throws Exception {
1:54e2e3b:         for (int i = 0; i < numBrokers; i++) {
1:54e2e3b:             brokersUrl.append("tcp://localhost:" + (portBase + i));
1:54e2e3b:             if (i != numBrokers - 1) {
1:54e2e3b:                 brokersUrl.append(',');
1:54e2e3b:             }
1:54e2e3b:         }
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     protected BrokerService createBroker(int brokerid) throws Exception {
1:54e2e3b:         return createBroker(brokerid, true);
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     protected BrokerService createBroker(int brokerid, boolean addToNetwork) throws Exception {
1:54e2e3b: 
1:54e2e3b:         BrokerService broker = new BrokerService();
1:54e2e3b:         broker.setPersistent(true);
1:54e2e3b:         broker.setDeleteAllMessagesOnStartup(true);
1:54e2e3b:         broker.getManagementContext().setCreateConnector(false);
1:54e2e3b: 
1:54e2e3b: 
1:54e2e3b:         broker.setUseJmx(true);
1:54e2e3b:         broker.setBrokerName("B" + brokerid);
1:54e2e3b:         broker.addConnector(new URI("tcp://localhost:" + (portBase + brokerid)));
1:54e2e3b: 
1:54e2e3b:         if (addToNetwork) {
1:54e2e3b:             addNetworkConnector(broker);
1:54e2e3b:         }
1:54e2e3b:         broker.setSchedulePeriodForDestinationPurge(0);
1:54e2e3b:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024l);
1:54e2e3b: 
1:54e2e3b: 
1:54e2e3b:         PolicyMap policyMap = new PolicyMap();
1:54e2e3b:         PolicyEntry policyEntry = new PolicyEntry();
1:54e2e3b:         policyEntry.setExpireMessagesPeriod(0);
1:54e2e3b:         policyEntry.setQueuePrefetch(1000);
1:54e2e3b:         policyEntry.setMemoryLimit(2 * 1024 * 1024l);
1:54e2e3b:         policyEntry.setProducerFlowControl(false);
1:54e2e3b:         policyEntry.setEnableAudit(true);
1:54e2e3b:         policyEntry.setUseCache(true);
1:54e2e3b:         policyMap.put(new ActiveMQQueue("GW.>"), policyEntry);
1:54e2e3b: 
1:54e2e3b:         PolicyEntry inPolicyEntry = new PolicyEntry();
1:54e2e3b:         inPolicyEntry.setExpireMessagesPeriod(0);
1:54e2e3b:         inPolicyEntry.setQueuePrefetch(1000);
1:54e2e3b:         inPolicyEntry.setMemoryLimit(5 * 1024 * 1024l);
1:54e2e3b:         inPolicyEntry.setProducerFlowControl(true);
1:54e2e3b:         inPolicyEntry.setEnableAudit(true);
1:54e2e3b:         inPolicyEntry.setUseCache(true);
1:54e2e3b:         policyMap.put(new ActiveMQQueue("IN"), inPolicyEntry);
1:54e2e3b: 
1:54e2e3b:         broker.setDestinationPolicy(policyMap);
1:54e2e3b: 
1:54e2e3b:         KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
1:54e2e3b:         kahaDBPersistenceAdapter.setConcurrentStoreAndDispatchQueues(true);
1:54e2e3b: 
1:54e2e3b:         brokers.put(broker.getBrokerName(), new BrokerItem(broker));
1:54e2e3b:         return broker;
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     private void addNetworkConnector(BrokerService broker) throws Exception {
1:54e2e3b:         StringBuilder networkConnectorUrl = new StringBuilder("static:(").append(brokersUrl.toString());
1:54e2e3b:         networkConnectorUrl.append(')');
1:54e2e3b: 
1:54e2e3b:         for (int i = 0; i < 2; i++) {
1:54e2e3b:             NetworkConnector nc = new DiscoveryNetworkConnector(new URI(networkConnectorUrl.toString()));
1:54e2e3b:             nc.setName("Bridge-" + i);
1:54e2e3b:             nc.setNetworkTTL(1);
1:54e2e3b:             nc.setDecreaseNetworkConsumerPriority(true);
1:54e2e3b:             nc.setDynamicOnly(true);
1:54e2e3b:             nc.setPrefetchSize(100);
1:54e2e3b:             nc.setDynamicallyIncludedDestinations(
1:54e2e3b:                     Arrays.asList(new ActiveMQDestination[]{new ActiveMQQueue("GW.*")}));
1:54e2e3b:             broker.addNetworkConnector(nc);
1:54e2e3b:         }
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     // used to explore contention with concurrentStoreandDispatch - sync commit and task queue reversing
1:54e2e3b:     // order of cursor add and sequence assignment
1:54e2e3b:     public void x_testInterleavedSend() throws Exception {
1:54e2e3b: 
1:54e2e3b:         BrokerService b = createBroker(0, false);
1:54e2e3b:         b.start();
1:54e2e3b: 
1:54e2e3b:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:" + (portBase + 0));
1:54e2e3b:         connectionFactory.setWatchTopicAdvisories(false);
1:54e2e3b: 
1:54e2e3b:         QueueConnection c1 = connectionFactory.createQueueConnection();
1:54e2e3b:         QueueConnection c2 = connectionFactory.createQueueConnection();
1:54e2e3b:         QueueConnection c3 = connectionFactory.createQueueConnection();
1:54e2e3b: 
1:54e2e3b:         c1.start();
1:54e2e3b:         c2.start();
1:54e2e3b:         c3.start();
1:54e2e3b: 
1:54e2e3b:         ActiveMQQueue dest = new ActiveMQQueue("IN");
1:54e2e3b:         final Session s1 = c1.createQueueSession(true, Session.SESSION_TRANSACTED);
1:54e2e3b:         final TextMessage txMessage = s1.createTextMessage("TX");
1:54e2e3b:         final TextMessage noTxMessage = s1.createTextMessage("NO_TX");
1:54e2e3b: 
1:54e2e3b:         final MessageProducer txProducer = s1.createProducer(dest);
1:54e2e3b:         final MessageProducer nonTxProducer = c2.createQueueSession(false, Session.AUTO_ACKNOWLEDGE).createProducer(dest);
1:54e2e3b: 
1:54e2e3b:         txProducer.send(txMessage);
1:54e2e3b: 
1:54e2e3b:         ExecutorService executorService = Executors.newFixedThreadPool(2);
1:54e2e3b:         executorService.execute(new Runnable() {
1:54e2e3b:             @Override
1:54e2e3b:             public void run() {
1:54e2e3b:                 try {
1:54e2e3b:                     s1.commit();
1:54e2e3b:                 } catch (JMSException e) {
1:54e2e3b:                     e.printStackTrace();
1:54e2e3b:                 }
1:54e2e3b:             }
1:54e2e3b:         });
1:54e2e3b: 
1:54e2e3b:         executorService.execute(new Runnable() {
1:54e2e3b:             @Override
1:54e2e3b:             public void run() {
1:54e2e3b:                 try {
1:54e2e3b:                     nonTxProducer.send(noTxMessage);
1:54e2e3b:                 } catch (JMSException e) {
1:54e2e3b:                     e.printStackTrace();
1:54e2e3b:                 }
1:54e2e3b:             }
1:54e2e3b:         });
1:54e2e3b: 
1:54e2e3b:         executorService.shutdown();
1:54e2e3b:         executorService.awaitTermination(10, TimeUnit.MINUTES);
1:54e2e3b: 
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     public void testBrokers() throws Exception {
1:54e2e3b: 
1:54e2e3b:         buildUrlList();
1:54e2e3b: 
1:54e2e3b:         for (int i = 0; i < numBrokers; i++) {
1:54e2e3b:             createBroker(i);
1:54e2e3b:         }
1:54e2e3b: 
1:54e2e3b:         startAllBrokers();
1:54e2e3b:         waitForBridgeFormation(numBrokers - 1);
1:54e2e3b: 
1:54e2e3b:         verifyPeerBrokerInfos(numBrokers - 1);
1:54e2e3b: 
1:54e2e3b: 
1:54e2e3b:         final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);
1:54e2e3b: 
1:54e2e3b:         startAllGWFanoutConsumers(numBrokers);
1:54e2e3b: 
1:54e2e3b:         LOG.info("Waiting for percolation of consumers..");
1:54e2e3b:         TimeUnit.SECONDS.sleep(5);
1:54e2e3b: 
1:54e2e3b:         LOG.info("Produce mesages..");
1:54e2e3b:         long startTime = System.currentTimeMillis();
1:54e2e3b: 
1:54e2e3b:         // produce
1:54e2e3b:         produce(numMessages);
1:54e2e3b: 
1:54e2e3b:         assertTrue("Got all sent", Wait.waitFor(new Wait.Condition() {
1:54e2e3b:             @Override
1:54e2e3b:             public boolean isSatisified() throws Exception {
1:54e2e3b:                 for (ConsumerState tally : consumerStates) {
1:54e2e3b:                     final int expected = numMessages * (tally.destination.isComposite() ? tally.destination.getCompositeDestinations().length : 1);
1:54e2e3b:                     LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get());
1:54e2e3b:                     if (tally.accumulator.get() != expected) {
1:54e2e3b:                         LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get() + " != " + expected + ", " + tally.expected);
1:54e2e3b:                         if (tally.accumulator.get() > expected - 50) {
1:140ce1b:                             dumpQueueStat(null);
1:54e2e3b:                         }
1:54e2e3b:                         if (tally.expected.size() == 1) {
1:54e2e3b:                             startConsumer(tally.brokerName, tally.destination);
1:54e2e3b:                         };
1:54e2e3b:                         return false;
1:54e2e3b:                     }
1:54e2e3b:                     LOG.info("got tally on " + tally.brokerName);
1:54e2e3b:                 }
1:54e2e3b:                 return true;
1:54e2e3b:             }
1:54e2e3b:         }, 1000 * 60 * 1000l, 20*1000));
1:54e2e3b: 
1:54e2e3b:         assertTrue("No exceptions:" + exceptions, exceptions.isEmpty());
1:54e2e3b: 
1:54e2e3b:         LOG.info("done");
1:54e2e3b:         long duration = System.currentTimeMillis() - startTime;
1:54e2e3b:         LOG.info("Duration:" + TimeUtils.printDuration(duration));
1:140ce1b: 
1:140ce1b:         assertEquals("nothing in the dlq's", 0, dumpQueueStat(new ActiveMQQueue("ActiveMQ.DLQ")));
1:140ce1b: 
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     private void startConsumer(String brokerName, ActiveMQDestination destination) throws Exception {
1:54e2e3b:         int id = Integer.parseInt(brokerName.substring(1));
1:54e2e3b:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:" + (portBase + id));
1:54e2e3b:         connectionFactory.setWatchTopicAdvisories(false);
1:54e2e3b:         QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:54e2e3b:         queueConnection.start();
1:54e2e3b: 
1:54e2e3b:         queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(destination);
1:54e2e3b:         queueConnection.close();
1:54e2e3b:     }
1:54e2e3b: 
1:140ce1b:     private long dumpQueueStat(ActiveMQDestination destination) throws Exception {
1:140ce1b:         long sumTotal = 0;
1:54e2e3b:         Collection<BrokerItem> brokerList = brokers.values();
1:54e2e3b:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext(); ) {
1:54e2e3b:             BrokerService brokerService = i.next().broker;
1:54e2e3b:             for (ObjectName objectName : brokerService.getAdminView().getQueues()) {
1:140ce1b:                 if (destination != null && objectName.toString().contains(destination.getPhysicalName())) {
1:54e2e3b:                     QueueViewMBean qViewMBean = (QueueViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, QueueViewMBean.class, false);
1:140ce1b:                     LOG.info(brokerService.getBrokerName() + ", " + qViewMBean.getName() + ", Enqueue:"  + qViewMBean.getEnqueueCount() + ", Size: " + qViewMBean.getQueueSize());
1:140ce1b:                     sumTotal += qViewMBean.getQueueSize();
1:140ce1b:                 }
1:54e2e3b:             }
1:54e2e3b:         }
1:140ce1b:         return sumTotal;
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     private void startAllGWFanoutConsumers(int nBrokers) throws Exception {
1:54e2e3b: 
1:54e2e3b:         StringBuffer compositeDest = new StringBuffer();
1:54e2e3b:         for (int k = 0; k < nBrokers; k++) {
1:54e2e3b:             compositeDest.append("GW." + k);
1:54e2e3b:             if (k + 1 != nBrokers) {
1:54e2e3b:                 compositeDest.append(',');
1:54e2e3b:             }
1:54e2e3b:         }
1:54e2e3b:         ActiveMQQueue compositeQ = new ActiveMQQueue(compositeDest.toString());
1:54e2e3b: 
1:54e2e3b:         for (int id = 0; id < nBrokers; id++) {
1:54e2e3b:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:" + (portBase + id) + ")");
1:54e2e3b:             connectionFactory.setWatchTopicAdvisories(false);
1:54e2e3b: 
1:54e2e3b:             QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:54e2e3b:             queueConnection.start();
1:54e2e3b: 
1:54e2e3b:             final QueueSession queueSession = queueConnection.createQueueSession(true, Session.SESSION_TRANSACTED);
1:54e2e3b: 
1:54e2e3b:             final MessageProducer producer = queueSession.createProducer(compositeQ);
1:54e2e3b:             queueSession.createReceiver(new ActiveMQQueue("IN")).setMessageListener(new MessageListener() {
1:54e2e3b:                 @Override
1:54e2e3b:                 public void onMessage(Message message) {
1:54e2e3b:                     try {
1:54e2e3b:                         producer.send(message);
1:54e2e3b:                         queueSession.commit();
1:54e2e3b:                     } catch (Exception e) {
1:54e2e3b:                         LOG.error("Failed to fanout to GW: " + message, e);
1:54e2e3b:                     }
1:54e2e3b: 
1:54e2e3b:                 }
1:54e2e3b:             });
1:54e2e3b:         }
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     private List<ConsumerState> startAllGWConsumers(int nBrokers) throws Exception {
1:54e2e3b:         List<ConsumerState> consumerStates = new LinkedList<ConsumerState>();
1:54e2e3b:         for (int id = 0; id < nBrokers; id++) {
1:54e2e3b:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:" + (portBase + id) + ")");
1:54e2e3b:             connectionFactory.setWatchTopicAdvisories(false);
1:54e2e3b: 
1:54e2e3b:             QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:54e2e3b:             queueConnection.start();
1:54e2e3b: 
1:54e2e3b:             final QueueSession queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:54e2e3b: 
1:54e2e3b:             ActiveMQQueue destination = new ActiveMQQueue("GW." + id);
1:54e2e3b:             QueueReceiver queueReceiver = queueSession.createReceiver(destination);
1:54e2e3b: 
1:54e2e3b:             final ConsumerState consumerState = new ConsumerState();
1:54e2e3b:             consumerState.brokerName = ((ActiveMQConnection) queueConnection).getBrokerName();
1:54e2e3b:             consumerState.receiver = queueReceiver;
1:54e2e3b:             consumerState.destination = destination;
1:54e2e3b:             for (int j = 0; j < numMessages * (consumerState.destination.isComposite() ? consumerState.destination.getCompositeDestinations().length : 1); j++) {
1:54e2e3b:                 consumerState.expected.add(j);
1:54e2e3b:             }
1:54e2e3b: 
1:54e2e3b:             if (!accumulators.containsKey(destination)) {
1:54e2e3b:                 accumulators.put(destination, new AtomicInteger(0));
1:54e2e3b:             }
1:54e2e3b:             consumerState.accumulator = accumulators.get(destination);
1:54e2e3b: 
1:54e2e3b:             queueReceiver.setMessageListener(new MessageListener() {
1:54e2e3b:                 @Override
1:54e2e3b:                 public void onMessage(Message message) {
1:54e2e3b:                     try {
1:54e2e3b:                         if (consumerSleepTime > 0) {
1:54e2e3b:                             TimeUnit.MILLISECONDS.sleep(consumerSleepTime);
1:54e2e3b:                         }
1:54e2e3b:                     } catch (InterruptedException e) {
1:54e2e3b:                         e.printStackTrace();
1:54e2e3b:                     }
1:54e2e3b:                     try {
1:54e2e3b:                         consumerState.accumulator.incrementAndGet();
1:54e2e3b:                         try {
1:54e2e3b:                             consumerState.expected.remove(((ActiveMQMessage) message).getProperty("NUM"));
1:54e2e3b:                         } catch (IOException e) {
1:54e2e3b:                             e.printStackTrace();
1:54e2e3b:                         }
1:54e2e3b:                         //queueSession.commit();
1:54e2e3b:                     } catch (Exception e) {
1:54e2e3b:                         LOG.error("Failed to commit slow receipt of " + message, e);
1:54e2e3b:                     }
1:54e2e3b:                 }
1:54e2e3b:             });
1:54e2e3b: 
1:54e2e3b:             consumerStates.add(consumerState);
1:54e2e3b: 
1:54e2e3b:         }
1:54e2e3b:         return consumerStates;
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     private void produce(final int numMessages) throws Exception {
1:54e2e3b:         ExecutorService executorService = Executors.newFixedThreadPool(numProducers);
1:54e2e3b:         final AtomicInteger toSend = new AtomicInteger(numMessages);
1:54e2e3b:         for (int i = 1; i <= numProducers; i++) {
1:54e2e3b:             final int id = i % numBrokers;
1:54e2e3b:             executorService.execute(new Runnable() {
1:54e2e3b:                 @Override
1:54e2e3b:                 public void run() {
1:54e2e3b:                     try {
1:54e2e3b:                         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:" + (portBase + id) + ")");
1:54e2e3b:                         connectionFactory.setWatchTopicAdvisories(false);
1:54e2e3b:                         QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:54e2e3b:                         queueConnection.start();
1:54e2e3b:                         QueueSession queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:54e2e3b:                         MessageProducer producer = queueSession.createProducer(null);
1:54e2e3b:                         int val = 0;
1:54e2e3b:                         while ((val = toSend.decrementAndGet()) >= 0) {
1:54e2e3b: 
1:54e2e3b:                             int id = numMessages - val - 1;
1:54e2e3b: 
1:54e2e3b:                             ActiveMQQueue compositeQ = new ActiveMQQueue("IN");
1:54e2e3b:                             Message textMessage = queueSession.createTextMessage(((ActiveMQConnection) queueConnection).getBrokerName() + "->" + id + " payload:" + payload);
1:54e2e3b:                             textMessage.setIntProperty("NUM", id);
1:54e2e3b:                             producer.send(compositeQ, textMessage);
1:54e2e3b:                         }
1:54e2e3b:                         queueConnection.close();
1:54e2e3b: 
1:54e2e3b:                     } catch (Throwable throwable) {
1:54e2e3b:                         throwable.printStackTrace();
1:54e2e3b:                         exceptions.add(throwable);
1:54e2e3b:                     }
1:54e2e3b:                 }
1:54e2e3b:             });
1:54e2e3b:         }
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {
1:54e2e3b:         final BrokerService broker = brokerItem.broker;
1:54e2e3b:         final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:54e2e3b:         Wait.waitFor(new Wait.Condition() {
1:54e2e3b:             @Override
1:54e2e3b:             public boolean isSatisified() throws Exception {
1:54e2e3b:                 LOG.info("verify infos " + broker.getBrokerName() + ", len: " + regionBroker.getPeerBrokerInfos().length);
1:54e2e3b:                 return max == regionBroker.getPeerBrokerInfos().length;
1:54e2e3b:             }
1:54e2e3b:         });
1:54e2e3b:         LOG.info("verify infos " + broker.getBrokerName() + ", len: " + regionBroker.getPeerBrokerInfos().length);
1:54e2e3b:         List<String> missing = new ArrayList<String>();
1:54e2e3b:         for (int i = 0; i < max; i++) {
1:54e2e3b:             missing.add("B" + i);
1:54e2e3b:         }
1:54e2e3b:         if (max != regionBroker.getPeerBrokerInfos().length) {
1:54e2e3b:             for (BrokerInfo info : regionBroker.getPeerBrokerInfos()) {
1:54e2e3b:                 LOG.info(info.getBrokerName());
1:54e2e3b:                 missing.remove(info.getBrokerName());
1:54e2e3b:             }
1:54e2e3b:             LOG.info("Broker infos off.." + missing);
1:54e2e3b:         }
1:54e2e3b:         assertEquals(broker.getBrokerName(), max, regionBroker.getPeerBrokerInfos().length);
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     private void verifyPeerBrokerInfos(final int max) throws Exception {
1:54e2e3b:         Collection<BrokerItem> brokerList = brokers.values();
1:54e2e3b:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext(); ) {
1:54e2e3b:             verifyPeerBrokerInfo(i.next(), max);
1:54e2e3b:         }
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     protected void tearDown() throws Exception {
1:54e2e3b:         super.tearDown();
1:54e2e3b:     }
1:54e2e3b: 
1:54e2e3b:     class ConsumerState {
1:54e2e3b:         AtomicInteger accumulator;
1:54e2e3b:         String brokerName;
1:54e2e3b:         QueueReceiver receiver;
1:54e2e3b:         ActiveMQDestination destination;
1:54e2e3b:         ConcurrentLinkedQueue<Integer> expected = new ConcurrentLinkedQueue<Integer>();
1:54e2e3b:     }
1:54e2e3b: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:1a0bd45
/////////////////////////////////////////////////////////////////////////
1:     int numBrokers = 8;
commit:97c127d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:140ce1b
/////////////////////////////////////////////////////////////////////////
1:                             dumpQueueStat(null);
/////////////////////////////////////////////////////////////////////////
1: 
1:         assertEquals("nothing in the dlq's", 0, dumpQueueStat(new ActiveMQQueue("ActiveMQ.DLQ")));
1: 
/////////////////////////////////////////////////////////////////////////
1:     private long dumpQueueStat(ActiveMQDestination destination) throws Exception {
1:         long sumTotal = 0;
1:                 if (destination != null && objectName.toString().contains(destination.getPhysicalName())) {
1:                     LOG.info(brokerService.getBrokerName() + ", " + qViewMBean.getName() + ", Enqueue:"  + qViewMBean.getEnqueueCount() + ", Size: " + qViewMBean.getQueueSize());
1:                     sumTotal += qViewMBean.getQueueSize();
1:                 }
1:         return sumTotal;
commit:54e2e3b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.bugs;
1: 
1: import java.io.IOException;
1: import java.net.URI;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.concurrent.ConcurrentLinkedQueue;
1: import java.util.concurrent.ExecutorService;
1: import java.util.concurrent.Executors;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.QueueConnection;
1: import javax.jms.QueueReceiver;
1: import javax.jms.QueueSession;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import javax.management.ObjectName;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.jmx.QueueViewMBean;
1: import org.apache.activemq.broker.region.RegionBroker;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.BrokerInfo;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1: import org.apache.activemq.util.TimeUtils;
1: import org.apache.activemq.util.Wait;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: public class AMQ4485LowLimitTest extends JmsMultipleBrokersTestSupport {
1:     static final String payload = new String(new byte[10 * 1024]);
1:     private static final Logger LOG = LoggerFactory.getLogger(AMQ4485LowLimitTest.class);
1:     final int portBase = 61600;
0:     final int numBrokers = 8;
1:     final int numProducers = 30;
1:     final int numMessages = 1000;
1:     final int consumerSleepTime = 40;
1:     StringBuilder brokersUrl = new StringBuilder();
1:     HashMap<ActiveMQQueue, AtomicInteger> accumulators = new HashMap<ActiveMQQueue, AtomicInteger>();
1:     private ArrayList<Throwable> exceptions = new ArrayList<Throwable>();
1: 
1:     protected void buildUrlList() throws Exception {
1:         for (int i = 0; i < numBrokers; i++) {
1:             brokersUrl.append("tcp://localhost:" + (portBase + i));
1:             if (i != numBrokers - 1) {
1:                 brokersUrl.append(',');
1:             }
1:         }
1:     }
1: 
1:     protected BrokerService createBroker(int brokerid) throws Exception {
1:         return createBroker(brokerid, true);
1:     }
1: 
1:     protected BrokerService createBroker(int brokerid, boolean addToNetwork) throws Exception {
1: 
1:         BrokerService broker = new BrokerService();
1:         broker.setPersistent(true);
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.getManagementContext().setCreateConnector(false);
1: 
1: 
1:         broker.setUseJmx(true);
1:         broker.setBrokerName("B" + brokerid);
1:         broker.addConnector(new URI("tcp://localhost:" + (portBase + brokerid)));
1: 
1:         if (addToNetwork) {
1:             addNetworkConnector(broker);
1:         }
1:         broker.setSchedulePeriodForDestinationPurge(0);
0:         //broker.getSystemUsage().setSendFailIfNoSpace(true);
1:         broker.getSystemUsage().getMemoryUsage().setLimit(256 * 1024 * 1024l);
1: 
1: 
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setExpireMessagesPeriod(0);
1:         policyEntry.setQueuePrefetch(1000);
1:         policyEntry.setMemoryLimit(2 * 1024 * 1024l);
1:         policyEntry.setProducerFlowControl(false);
1:         policyEntry.setEnableAudit(true);
1:         policyEntry.setUseCache(true);
1:         policyMap.put(new ActiveMQQueue("GW.>"), policyEntry);
1: 
1:         PolicyEntry inPolicyEntry = new PolicyEntry();
1:         inPolicyEntry.setExpireMessagesPeriod(0);
1:         inPolicyEntry.setQueuePrefetch(1000);
1:         inPolicyEntry.setMemoryLimit(5 * 1024 * 1024l);
1:         inPolicyEntry.setProducerFlowControl(true);
1:         inPolicyEntry.setEnableAudit(true);
1:         inPolicyEntry.setUseCache(true);
1:         policyMap.put(new ActiveMQQueue("IN"), inPolicyEntry);
1: 
1:         broker.setDestinationPolicy(policyMap);
1: 
1:         KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter) broker.getPersistenceAdapter();
1:         kahaDBPersistenceAdapter.setConcurrentStoreAndDispatchQueues(true);
1: 
1:         brokers.put(broker.getBrokerName(), new BrokerItem(broker));
1:         return broker;
1:     }
1: 
1:     private void addNetworkConnector(BrokerService broker) throws Exception {
1:         StringBuilder networkConnectorUrl = new StringBuilder("static:(").append(brokersUrl.toString());
1:         networkConnectorUrl.append(')');
1: 
1:         for (int i = 0; i < 2; i++) {
1:             NetworkConnector nc = new DiscoveryNetworkConnector(new URI(networkConnectorUrl.toString()));
1:             nc.setName("Bridge-" + i);
1:             nc.setNetworkTTL(1);
1:             nc.setDecreaseNetworkConsumerPriority(true);
1:             nc.setDynamicOnly(true);
1:             nc.setPrefetchSize(100);
1:             nc.setDynamicallyIncludedDestinations(
1:                     Arrays.asList(new ActiveMQDestination[]{new ActiveMQQueue("GW.*")}));
1:             broker.addNetworkConnector(nc);
1:         }
1:     }
1: 
1:     // used to explore contention with concurrentStoreandDispatch - sync commit and task queue reversing
1:     // order of cursor add and sequence assignment
1:     public void x_testInterleavedSend() throws Exception {
1: 
1:         BrokerService b = createBroker(0, false);
1:         b.start();
1: 
1:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:" + (portBase + 0));
1:         connectionFactory.setWatchTopicAdvisories(false);
1: 
1:         QueueConnection c1 = connectionFactory.createQueueConnection();
1:         QueueConnection c2 = connectionFactory.createQueueConnection();
1:         QueueConnection c3 = connectionFactory.createQueueConnection();
1: 
1:         c1.start();
1:         c2.start();
1:         c3.start();
1: 
1:         ActiveMQQueue dest = new ActiveMQQueue("IN");
1:         final Session s1 = c1.createQueueSession(true, Session.SESSION_TRANSACTED);
1:         final TextMessage txMessage = s1.createTextMessage("TX");
1:         final TextMessage noTxMessage = s1.createTextMessage("NO_TX");
1: 
1:         final MessageProducer txProducer = s1.createProducer(dest);
1:         final MessageProducer nonTxProducer = c2.createQueueSession(false, Session.AUTO_ACKNOWLEDGE).createProducer(dest);
1: 
1:         txProducer.send(txMessage);
1: 
1:         ExecutorService executorService = Executors.newFixedThreadPool(2);
1:         executorService.execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     s1.commit();
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
1:         executorService.execute(new Runnable() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     nonTxProducer.send(noTxMessage);
1:                 } catch (JMSException e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1:         });
1: 
1:         executorService.shutdown();
1:         executorService.awaitTermination(10, TimeUnit.MINUTES);
1: 
1:     }
1: 
1:     public void testBrokers() throws Exception {
1: 
1:         buildUrlList();
1: 
1:         for (int i = 0; i < numBrokers; i++) {
1:             createBroker(i);
1:         }
1: 
1:         startAllBrokers();
1:         waitForBridgeFormation(numBrokers - 1);
1: 
1:         verifyPeerBrokerInfos(numBrokers - 1);
1: 
1: 
1:         final List<ConsumerState> consumerStates = startAllGWConsumers(numBrokers);
1: 
1:         startAllGWFanoutConsumers(numBrokers);
1: 
1:         LOG.info("Waiting for percolation of consumers..");
1:         TimeUnit.SECONDS.sleep(5);
1: 
1:         LOG.info("Produce mesages..");
1:         long startTime = System.currentTimeMillis();
1: 
1:         // produce
1:         produce(numMessages);
1: 
1:         assertTrue("Got all sent", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 for (ConsumerState tally : consumerStates) {
1:                     final int expected = numMessages * (tally.destination.isComposite() ? tally.destination.getCompositeDestinations().length : 1);
1:                     LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get());
1:                     if (tally.accumulator.get() != expected) {
1:                         LOG.info("Tally for: " + tally.brokerName + ", dest: " + tally.destination + " - " + tally.accumulator.get() + " != " + expected + ", " + tally.expected);
1:                         if (tally.accumulator.get() > expected - 50) {
0:                             dumpQueueStat(tally.destination);
1:                         }
1:                         if (tally.expected.size() == 1) {
1:                             startConsumer(tally.brokerName, tally.destination);
1:                         };
1:                         return false;
1:                     }
1:                     LOG.info("got tally on " + tally.brokerName);
1:                 }
1:                 return true;
1:             }
1:         }, 1000 * 60 * 1000l, 20*1000));
1: 
1:         assertTrue("No exceptions:" + exceptions, exceptions.isEmpty());
1: 
1:         LOG.info("done");
1:         long duration = System.currentTimeMillis() - startTime;
1:         LOG.info("Duration:" + TimeUtils.printDuration(duration));
1:     }
1: 
1:     private void startConsumer(String brokerName, ActiveMQDestination destination) throws Exception {
1:         int id = Integer.parseInt(brokerName.substring(1));
1:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://localhost:" + (portBase + id));
1:         connectionFactory.setWatchTopicAdvisories(false);
1:         QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:         queueConnection.start();
1: 
1:         queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE).createConsumer(destination);
1:         queueConnection.close();
1:     }
1: 
0:     private void dumpQueueStat(ActiveMQDestination destination) throws Exception {
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext(); ) {
1:             BrokerService brokerService = i.next().broker;
1:             for (ObjectName objectName : brokerService.getAdminView().getQueues()) {
0:                 //if (objectName.toString().contains(destination.getQualifiedName())) {
1:                     QueueViewMBean qViewMBean = (QueueViewMBean) brokerService.getManagementContext().newProxyInstance(objectName, QueueViewMBean.class, false);
0:                     LOG.info(brokerService.getBrokerName() + ", " + qViewMBean.getName() + " Size: " + qViewMBean.getEnqueueCount());
0:                 //}
1:             }
1:         }
1:     }
1: 
1:     private void startAllGWFanoutConsumers(int nBrokers) throws Exception {
1: 
1:         StringBuffer compositeDest = new StringBuffer();
1:         for (int k = 0; k < nBrokers; k++) {
1:             compositeDest.append("GW." + k);
1:             if (k + 1 != nBrokers) {
1:                 compositeDest.append(',');
1:             }
1:         }
1:         ActiveMQQueue compositeQ = new ActiveMQQueue(compositeDest.toString());
1: 
1:         for (int id = 0; id < nBrokers; id++) {
1:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:" + (portBase + id) + ")");
1:             connectionFactory.setWatchTopicAdvisories(false);
1: 
1:             QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:             queueConnection.start();
1: 
1:             final QueueSession queueSession = queueConnection.createQueueSession(true, Session.SESSION_TRANSACTED);
1: 
1:             final MessageProducer producer = queueSession.createProducer(compositeQ);
1:             queueSession.createReceiver(new ActiveMQQueue("IN")).setMessageListener(new MessageListener() {
1:                 @Override
1:                 public void onMessage(Message message) {
1:                     try {
1:                         producer.send(message);
1:                         queueSession.commit();
1:                     } catch (Exception e) {
1:                         LOG.error("Failed to fanout to GW: " + message, e);
1:                     }
1: 
1:                 }
1:             });
1:         }
1:     }
1: 
1:     private List<ConsumerState> startAllGWConsumers(int nBrokers) throws Exception {
1:         List<ConsumerState> consumerStates = new LinkedList<ConsumerState>();
1:         for (int id = 0; id < nBrokers; id++) {
1:             ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:" + (portBase + id) + ")");
1:             connectionFactory.setWatchTopicAdvisories(false);
1: 
1:             QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:             queueConnection.start();
1: 
1:             final QueueSession queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:             ActiveMQQueue destination = new ActiveMQQueue("GW." + id);
1:             QueueReceiver queueReceiver = queueSession.createReceiver(destination);
1: 
1:             final ConsumerState consumerState = new ConsumerState();
1:             consumerState.brokerName = ((ActiveMQConnection) queueConnection).getBrokerName();
1:             consumerState.receiver = queueReceiver;
1:             consumerState.destination = destination;
1:             for (int j = 0; j < numMessages * (consumerState.destination.isComposite() ? consumerState.destination.getCompositeDestinations().length : 1); j++) {
1:                 consumerState.expected.add(j);
1:             }
1: 
1:             if (!accumulators.containsKey(destination)) {
1:                 accumulators.put(destination, new AtomicInteger(0));
1:             }
1:             consumerState.accumulator = accumulators.get(destination);
1: 
1:             queueReceiver.setMessageListener(new MessageListener() {
1:                 @Override
1:                 public void onMessage(Message message) {
1:                     try {
1:                         if (consumerSleepTime > 0) {
1:                             TimeUnit.MILLISECONDS.sleep(consumerSleepTime);
1:                         }
1:                     } catch (InterruptedException e) {
1:                         e.printStackTrace();
1:                     }
1:                     try {
1:                         consumerState.accumulator.incrementAndGet();
1:                         try {
1:                             consumerState.expected.remove(((ActiveMQMessage) message).getProperty("NUM"));
1:                         } catch (IOException e) {
1:                             e.printStackTrace();
1:                         }
1:                         //queueSession.commit();
1:                     } catch (Exception e) {
1:                         LOG.error("Failed to commit slow receipt of " + message, e);
1:                     }
1:                 }
1:             });
1: 
1:             consumerStates.add(consumerState);
1: 
1:         }
1:         return consumerStates;
1:     }
1: 
1:     private void produce(final int numMessages) throws Exception {
1:         ExecutorService executorService = Executors.newFixedThreadPool(numProducers);
1:         final AtomicInteger toSend = new AtomicInteger(numMessages);
1:         for (int i = 1; i <= numProducers; i++) {
1:             final int id = i % numBrokers;
1:             executorService.execute(new Runnable() {
1:                 @Override
1:                 public void run() {
1:                     try {
1:                         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("failover:(tcp://localhost:" + (portBase + id) + ")");
1:                         connectionFactory.setWatchTopicAdvisories(false);
1:                         QueueConnection queueConnection = connectionFactory.createQueueConnection();
1:                         queueConnection.start();
1:                         QueueSession queueSession = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
1:                         MessageProducer producer = queueSession.createProducer(null);
1:                         int val = 0;
1:                         while ((val = toSend.decrementAndGet()) >= 0) {
1: 
1:                             int id = numMessages - val - 1;
1: 
1:                             ActiveMQQueue compositeQ = new ActiveMQQueue("IN");
0:                             //LOG.info("Send to: " + ((ActiveMQConnection) queueConnection).getBrokerName() + ", " + val + ", dest:" + compositeQ);
1:                             Message textMessage = queueSession.createTextMessage(((ActiveMQConnection) queueConnection).getBrokerName() + "->" + id + " payload:" + payload);
1:                             textMessage.setIntProperty("NUM", id);
1:                             producer.send(compositeQ, textMessage);
1:                         }
1:                         queueConnection.close();
1: 
1:                     } catch (Throwable throwable) {
1:                         throwable.printStackTrace();
1:                         exceptions.add(throwable);
1:                     }
1:                 }
1:             });
1:         }
1:     }
1: 
1:     private void verifyPeerBrokerInfo(BrokerItem brokerItem, final int max) throws Exception {
1:         final BrokerService broker = brokerItem.broker;
1:         final RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 LOG.info("verify infos " + broker.getBrokerName() + ", len: " + regionBroker.getPeerBrokerInfos().length);
1:                 return max == regionBroker.getPeerBrokerInfos().length;
1:             }
1:         });
1:         LOG.info("verify infos " + broker.getBrokerName() + ", len: " + regionBroker.getPeerBrokerInfos().length);
1:         List<String> missing = new ArrayList<String>();
1:         for (int i = 0; i < max; i++) {
1:             missing.add("B" + i);
1:         }
1:         if (max != regionBroker.getPeerBrokerInfos().length) {
1:             for (BrokerInfo info : regionBroker.getPeerBrokerInfos()) {
1:                 LOG.info(info.getBrokerName());
1:                 missing.remove(info.getBrokerName());
1:             }
1:             LOG.info("Broker infos off.." + missing);
1:         }
1:         assertEquals(broker.getBrokerName(), max, regionBroker.getPeerBrokerInfos().length);
1:     }
1: 
1:     private void verifyPeerBrokerInfos(final int max) throws Exception {
1:         Collection<BrokerItem> brokerList = brokers.values();
1:         for (Iterator<BrokerItem> i = brokerList.iterator(); i.hasNext(); ) {
1:             verifyPeerBrokerInfo(i.next(), max);
1:         }
1:     }
1: 
1:     protected void tearDown() throws Exception {
1:         super.tearDown();
1:     }
1: 
1:     class ConsumerState {
1:         AtomicInteger accumulator;
1:         String brokerName;
1:         QueueReceiver receiver;
1:         ActiveMQDestination destination;
1:         ConcurrentLinkedQueue<Integer> expected = new ConcurrentLinkedQueue<Integer>();
1:     }
1: }
============================================================================