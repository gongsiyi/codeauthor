1:3601e81: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
2:3601e81:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3601e81:  *
1:3601e81:  * Unless required by applicable law or agreed to in writing, software
1:3601e81:  * distributed under the License is distributed on an "AS IS" BASIS,
1:3601e81:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3601e81:  * See the License for the specific language governing permissions and
1:3601e81:  * limitations under the License.
1:3601e81:  */
1:3601e81: package org.apache.activemq.broker.jmx;
1:3601e81: 
1:686bfcf: import java.io.IOException;
1:686bfcf: import java.util.Set;
1:3601e81: 
1:686bfcf: import javax.jms.InvalidSelectorException;
1:686bfcf: import javax.management.ObjectName;
1:686bfcf: 
1:686bfcf: import org.apache.activemq.broker.BrokerService;
1:686bfcf: import org.apache.activemq.broker.ConnectionContext;
1:3601e81: import org.apache.activemq.broker.region.Subscription;
1:3601e81: import org.apache.activemq.command.ActiveMQDestination;
1:52e15a4: import org.apache.activemq.command.ActiveMQQueue;
1:52e15a4: import org.apache.activemq.command.ActiveMQTopic;
1:f5dcc9d: import org.apache.activemq.command.ConsumerInfo;
1:52e15a4: import org.apache.activemq.filter.DestinationFilter;
1:686bfcf: import org.apache.activemq.util.IOExceptionSupport;
1:3601e81: 
1:3601e81: /**
1:f5dcc9d:  *
1:3601e81:  */
1:3601e81: public class SubscriptionView implements SubscriptionViewMBean {
1:3601e81: 
1:3601e81:     protected final Subscription subscription;
1:c82f6f3:     protected final String clientId;
1:f5dcc9d:     protected final String userName;
1:3601e81: 
1:3601e81:     /**
1:6272ddc:      * Constructor
1:f5dcc9d:      *
1:3601e81:      * @param subs
1:3601e81:      */
1:f5dcc9d:     public SubscriptionView(String clientId, String userName, Subscription subs) {
1:c82f6f3:         this.clientId = clientId;
1:3601e81:         this.subscription = subs;
1:f5dcc9d:         this.userName = userName;
1:3601e81:     }
1:686bfcf: 
1:c82f6f3:     /**
1:c82f6f3:      * @return the clientId
1:c82f6f3:      */
1:63a660a:     @Override
1:f812e34:     public String getClientId() {
1:c82f6f3:         return clientId;
1:38ab4b1:     }
1:38ab4b1: 
1:38ab4b1:     /**
1:686bfcf:      * @returns the ObjectName of the Connection that created this subscription
1:686bfcf:      */
1:63a660a:     @Override
1:686bfcf:     public ObjectName getConnection() {
1:686bfcf:         ObjectName result = null;
1:38ab4b1: 
1:686bfcf:         if (clientId != null && subscription != null) {
1:686bfcf:             ConnectionContext ctx = subscription.getContext();
1:686bfcf:             if (ctx != null && ctx.getBroker() != null && ctx.getBroker().getBrokerService() != null) {
1:686bfcf:                 BrokerService service = ctx.getBroker().getBrokerService();
1:686bfcf:                 ManagementContext managementCtx = service.getManagementContext();
1:686bfcf:                 if (managementCtx != null) {
1:686bfcf: 
1:686bfcf:                     try {
1:c37859a:                         ObjectName query = createConnectionQuery(managementCtx, service.getBrokerName());
1:686bfcf:                         Set<ObjectName> names = managementCtx.queryNames(query, null);
1:686bfcf:                         if (names.size() == 1) {
1:686bfcf:                             result = names.iterator().next();
1:38ab4b1:                         }
1:686bfcf:                     } catch (Exception e) {
1:686bfcf:                     }
1:686bfcf:                 }
1:686bfcf:             }
1:686bfcf:         }
1:686bfcf:         return result;
1:686bfcf:     }
1:07ec890: 
1:07ec890: 
1:686bfcf: 
1:c37859a:     private ObjectName createConnectionQuery(ManagementContext ctx, String brokerName) throws IOException {
1:686bfcf:         try {
1:7d7d6fa:             return BrokerMBeanSupport.createConnectionQuery(ctx.getJmxDomainName(), brokerName, clientId);
1:686bfcf:         } catch (Throwable e) {
1:686bfcf:             throw IOExceptionSupport.create(e);
1:686bfcf:         }
1:686bfcf:     }
1:686bfcf: 
1:38ab4b1:     /**
1:3601e81:      * @return the id of the Connection the Subscription is on
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public String getConnectionId() {
1:c82f6f3:         ConsumerInfo info = getConsumerInfo();
1:f812e34:         if (info != null) {
1:3601e81:             return info.getConsumerId().getConnectionId();
1:686bfcf:         }
1:3601e81:         return "NOTSET";
1:c82f6f3:     }
1:9899dff: 
1:686bfcf:     /**
1:3601e81:      * @return the id of the Session the subscription is on
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public long getSessionId() {
1:c82f6f3:         ConsumerInfo info = getConsumerInfo();
1:f812e34:         if (info != null) {
1:3601e81:             return info.getConsumerId().getSessionId();
1:3601e81:         }
1:3601e81:         return 0;
1:3601e81:     }
1:c82f6f3: 
1:3601e81:     /**
1:38ab4b1:      * @return the id of the Subscription
1:38ab4b1:      */
1:38ab4b1:     @Override
1:38ab4b1:     public long getSubscriptionId() {
1:c82f6f3:         ConsumerInfo info = getConsumerInfo();
1:f812e34:         if (info != null) {
1:3601e81:             return info.getConsumerId().getValue();
1:3601e81:         }
1:3601e81:         return 0;
1:3601e81:     }
1:3601e81: 
1:3601e81:     /**
1:3601e81:      * @return the destination name
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public String getDestinationName() {
1:c82f6f3:         ConsumerInfo info = getConsumerInfo();
1:f812e34:         if (info != null) {
1:3601e81:             ActiveMQDestination dest = info.getDestination();
1:3601e81:             return dest.getPhysicalName();
1:3601e81:         }
1:3601e81:         return "NOTSET";
1:3601e81:     }
1:3601e81: 
1:63a660a:     @Override
1:5371cf5:     public String getSelector() {
1:5371cf5:         if (subscription != null) {
1:5371cf5:             return subscription.getSelector();
1:3601e81:         }
1:5371cf5:         return null;
1:3601e81:     }
1:3601e81: 
1:63a660a:     @Override
1:5371cf5:     public void setSelector(String selector) throws InvalidSelectorException, UnsupportedOperationException {
1:5371cf5:         if (subscription != null) {
1:5371cf5:             subscription.setSelector(selector);
1:f812e34:         } else {
1:5371cf5:             throw new UnsupportedOperationException("No subscription object");
1:b695b49:         }
5:5371cf5:     }
1:3601e81: 
1:3601e81:     /**
1:3601e81:      * @return true if the destination is a Queue
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public boolean isDestinationQueue() {
1:c82f6f3:         ConsumerInfo info = getConsumerInfo();
1:f812e34:         if (info != null) {
1:3601e81:             ActiveMQDestination dest = info.getDestination();
1:3601e81:             return dest.isQueue();
1:3601e81:         }
1:3601e81:         return false;
1:3601e81:     }
1:3601e81: 
1:3601e81:     /**
1:3601e81:      * @return true of the destination is a Topic
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public boolean isDestinationTopic() {
1:c82f6f3:         ConsumerInfo info = getConsumerInfo();
1:f812e34:         if (info != null) {
1:3601e81:             ActiveMQDestination dest = info.getDestination();
1:3601e81:             return dest.isTopic();
1:3601e81:         }
1:3601e81:         return false;
1:3601e81:     }
1:3601e81: 
1:3601e81:     /**
1:3601e81:      * @return true if the destination is temporary
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public boolean isDestinationTemporary() {
1:c82f6f3:         ConsumerInfo info = getConsumerInfo();
1:f812e34:         if (info != null) {
1:3601e81:             ActiveMQDestination dest = info.getDestination();
1:3601e81:             return dest.isTemporary();
1:3601e81:         }
1:3601e81:         return false;
1:3601e81:     }
1:c82f6f3: 
1:c82f6f3:     /**
1:c82f6f3:      * @return true if the subscriber is active
1:c82f6f3:      */
1:63a660a:     @Override
1:f812e34:     public boolean isActive() {
1:c82f6f3:         return true;
1:c82f6f3:     }
1:3601e81: 
1:0bfa0cd:     @Override
1:0bfa0cd:     public boolean isNetwork() {
1:0bfa0cd:         ConsumerInfo info = getConsumerInfo();
1:0bfa0cd:         if (info != null) {
1:0bfa0cd:             return info.isNetworkSubscription();
1:0bfa0cd:         }
1:0bfa0cd:         return false;
1:0bfa0cd:     }
1:0bfa0cd: 
1:3601e81:     /**
1:f812e34:      * The subscription should release as may references as it can to help the
1:f812e34:      * garbage collector reclaim memory.
1:3601e81:      */
1:f812e34:     public void gc() {
1:f812e34:         if (subscription != null) {
1:3601e81:             subscription.gc();
1:c82f6f3:         }
1:3601e81:     }
1:3601e81: 
1:3601e81:     /**
1:b695b49:      * @return whether or not the subscriber is retroactive or not
1:3601e81:      */
1:63a660a:     @Override
1:b695b49:     public boolean isRetroactive() {
1:b695b49:         ConsumerInfo info = getConsumerInfo();
1:b695b49:         return info != null ? info.isRetroactive() : false;
1:52e15a4:     }
1:3601e81: 
1:3601e81:     /**
1:b695b49:      * @return whether or not the subscriber is an exclusive consumer
1:f5f1366:      */
1:63a660a:     @Override
1:b695b49:     public boolean isExclusive() {
1:b695b49:         ConsumerInfo info = getConsumerInfo();
1:b695b49:         return info != null ? info.isExclusive() : false;
1:b695b49:     }
1:3601e81: 
1:3601e81:     /**
1:b695b49:      * @return whether or not the subscriber is durable (persistent)
3:b695b49:      */
1:63a660a:     @Override
1:b695b49:     public boolean isDurable() {
1:b695b49:         ConsumerInfo info = getConsumerInfo();
1:b695b49:         return info != null ? info.isDurable() : false;
1:b695b49:     }
1:3601e81: 
1:f5f1366:     /**
1:b695b49:      * @return whether or not the subscriber ignores local messages
1:b695b49:      */
1:63a660a:     @Override
1:b695b49:     public boolean isNoLocal() {
1:b695b49:         ConsumerInfo info = getConsumerInfo();
1:b695b49:         return info != null ? info.isNoLocal() : false;
1:b695b49:     }
1:3601e81: 
3:b695b49:     /**
1:c2ad0c3:      * @return whether or not the subscriber is configured for async dispatch
1:c2ad0c3:      */
1:c2ad0c3:     @Override
1:c2ad0c3:     public boolean isDispatchAsync() {
1:c2ad0c3:         ConsumerInfo info = getConsumerInfo();
1:c2ad0c3:         return info != null ? info.isDispatchAsync() : false;
1:c2ad0c3:     }
1:c2ad0c3: 
1:c2ad0c3:     /**
1:f812e34:      * @return the maximum number of pending messages allowed in addition to the
1:f812e34:      *         prefetch size. If enabled to a non-zero value then this will
1:f812e34:      *         perform eviction of messages for slow consumers on non-durable
1:f812e34:      *         topics.
1:b695b49:      */
1:63a660a:     @Override
1:b695b49:     public int getMaximumPendingMessageLimit() {
1:b695b49:         ConsumerInfo info = getConsumerInfo();
1:b695b49:         return info != null ? info.getMaximumPendingMessageLimit() : 0;
1:b695b49:     }
1:3601e81: 
1:b695b49:     /**
1:b695b49:      * @return the consumer priority
1:b695b49:      */
1:63a660a:     @Override
1:b695b49:     public byte getPriority() {
1:b695b49:         ConsumerInfo info = getConsumerInfo();
1:b695b49:         return info != null ? info.getPriority() : 0;
1:b695b49:     }
1:3601e81: 
1:b695b49:     /**
1:38ab4b1:      * @return the name of the consumer which is only used for durable
1:38ab4b1:      *         consumers.
1:38ab4b1:      */
1:38ab4b1:     @Override
1:38ab4b1:     public String getSubscriptionName() {
1:b695b49:         ConsumerInfo info = getConsumerInfo();
1:333158a:         return info != null ? info.getSubscriptionName() : null;
1:b695b49:     }
1:74a7a8b: 
1:b695b49:     /**
1:3601e81:      * @return number of messages pending delivery
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public int getPendingQueueSize() {
1:07d4e8c:         return subscription != null ? subscription.getPendingQueueSize() : 0;
1:3601e81:     }
1:3601e81: 
1:3601e81:     /**
1:3601e81:      * @return number of messages dispatched
1:3601e81:      */
1:63a660a:     @Override
1:f812e34:     public int getDispatchedQueueSize() {
1:07d4e8c:         return subscription != null ? subscription.getDispatchedQueueSize() : 0;
1:c82f6f3:     }
1:f5dcc9d: 
1:63a660a:     @Override
1:9899dff:     public int getMessageCountAwaitingAcknowledge() {
1:9899dff:         return getDispatchedQueueSize();
1:9899dff:     }
1:c82f6f3: 
1:3601e81:     /**
1:07d4e8c:      * @return number of messages that matched the subscription
1:3601e81:      */
1:63a660a:     @Override
1:c75ff7f:     public long getDispatchedCounter() {
1:07d4e8c:         return subscription != null ? subscription.getDispatchedCounter() : 0;
1:3601e81:     }
1:3601e81: 
1:07d4e8c:     /**
1:07d4e8c:      * @return number of messages that matched the subscription
1:07d4e8c:      */
1:63a660a:     @Override
1:07d4e8c:     public long getEnqueueCounter() {
1:07d4e8c:         return subscription != null ? subscription.getEnqueueCounter() : 0;
1:3601e81:     }
1:3601e81: 
1:07d4e8c:     /**
1:07d4e8c:      * @return number of messages queued by the client
1:07d4e8c:      */
1:63a660a:     @Override
1:07d4e8c:     public long getDequeueCounter() {
1:07d4e8c:         return subscription != null ? subscription.getDequeueCounter() : 0;
1:3601e81:     }
1:f812e34: 
1:f812e34:     protected ConsumerInfo getConsumerInfo() {
1:c82f6f3:         return subscription != null ? subscription.getConsumerInfo() : null;
1:c717221:     }
1:c717221: 
1:c717221:     /**
1:f812e34:      * @return pretty print
1:c717221:      */
1:63a660a:     @Override
1:f812e34:     public String toString() {
1:f812e34:         return "SubscriptionView: " + getClientId() + ":" + getConnectionId();
1:07d4e8c:     }
1:f812e34: 
1:b695b49:     /**
1:b695b49:      */
1:63a660a:     @Override
1:f5f1366:     public int getPrefetchSize() {
1:f5f1366:         return subscription != null ? subscription.getPrefetchSize() : 0;
1:f5f1366:     }
1:f812e34: 
1:63a660a:     @Override
1:52e15a4:     public boolean isMatchingQueue(String queueName) {
1:52e15a4:         if (isDestinationQueue()) {
1:52e15a4:             return matchesDestination(new ActiveMQQueue(queueName));
1:07d4e8c:         }
1:52e15a4:         return false;
1:52e15a4:     }
1:f812e34: 
1:63a660a:     @Override
1:52e15a4:     public boolean isMatchingTopic(String topicName) {
1:52e15a4:         if (isDestinationTopic()) {
1:52e15a4:             return matchesDestination(new ActiveMQTopic(topicName));
1:52e15a4:         }
1:52e15a4:         return false;
1:52e15a4:     }
1:f812e34: 
1:52e15a4:     /**
1:52e15a4:      * Return true if this subscription matches the given destination
1:3601e81:      *
1:52e15a4:      * @param destination the destination to compare against
1:52e15a4:      * @return true if this subscription matches the given destination
1:52e15a4:      */
1:52e15a4:     public boolean matchesDestination(ActiveMQDestination destination) {
1:52e15a4:         ActiveMQDestination subscriptionDestination = subscription.getActiveMQDestination();
1:52e15a4:         DestinationFilter filter = DestinationFilter.parseFilter(subscriptionDestination);
1:52e15a4:         return filter.matches(destination);
1:52e15a4:     }
1:f812e34: 
1:63a660a:     @Override
1:e085ed4:     public boolean isSlowConsumer() {
1:e085ed4:         return subscription.isSlowConsumer();
1:e085ed4:     }
1:f5dcc9d: 
1:63a660a:     @Override
1:f5dcc9d:     public String getUserName() {
1:f5dcc9d:         return userName;
1:f5dcc9d:     }
1:07ec890: 
1:07ec890:     @Override
1:07ec890:     public void resetStatistics() {
1:564d550:         if (subscription != null && subscription.getSubscriptionStatistics() != null){
1:564d550:             subscription.getSubscriptionStatistics().reset();
1:07ec890:         }
1:07ec890:     }
1:07ec890: 
1:07ec890:     @Override
1:07ec890:     public long getConsumedCount() {
1:6683eb6:         return subscription != null ? subscription.getConsumedCount() : 0;
1:07ec890:     }
1:b695b49: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:c2ad0c3
/////////////////////////////////////////////////////////////////////////
1:      * @return whether or not the subscriber is configured for async dispatch
1:      */
1:     @Override
1:     public boolean isDispatchAsync() {
1:         ConsumerInfo info = getConsumerInfo();
1:         return info != null ? info.isDispatchAsync() : false;
1:     }
1: 
1:     /**
commit:8906a53
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:564d550
/////////////////////////////////////////////////////////////////////////
1:         if (subscription != null && subscription.getSubscriptionStatistics() != null){
1:             subscription.getSubscriptionStatistics().reset();
commit:38ab4b1
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
0:         return getSubscriptionId();
1:     }
1: 
1:     /**
1:      * @return the id of the Subscription
1:      */
1:     @Override
1:     public long getSubscriptionId() {
/////////////////////////////////////////////////////////////////////////
0:     @Deprecated
0:         return getSubscriptionName();
1:     }
1: 
1:     /**
1:      * @return the name of the consumer which is only used for durable
1:      *         consumers.
1:      */
1:     @Override
1:     public String getSubscriptionName() {
author:rajdavies
-------------------------------------------------------------------------------
commit:6683eb6
/////////////////////////////////////////////////////////////////////////
0:             subscription.resetConsumedCount();
1:         return subscription != null ? subscription.getConsumedCount() : 0;
author:Rob Davies
-------------------------------------------------------------------------------
commit:07ec890
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public void resetStatistics() {
0:         if (subscription != null){
0:             subscription.getConsumedCount().reset();
1:         }
1:     }
1: 
1:     @Override
1:     public long getConsumedCount() {
0:         return subscription != null ? subscription.getConsumedCount().getCount() : 0;
1:     }
author:Christian Posta
-------------------------------------------------------------------------------
commit:0bfa0cd
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean isNetwork() {
1:         ConsumerInfo info = getConsumerInfo();
1:         if (info != null) {
1:             return info.isNetworkSubscription();
1:         }
1:         return false;
1:     }
1: 
author:Gary Tully
-------------------------------------------------------------------------------
commit:7d7d6fa
/////////////////////////////////////////////////////////////////////////
1:             return BrokerMBeanSupport.createConnectionQuery(ctx.getJmxDomainName(), brokerName, clientId);
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:63a660a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:             return BrokerMBeanSuppurt.createConnectionQuery(ctx.getJmxDomainName(), brokerName, clientId);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:686bfcf
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.Set;
1: import javax.jms.InvalidSelectorException;
1: import javax.management.ObjectName;
1: 
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.activemq.util.JMXSupport;
/////////////////////////////////////////////////////////////////////////
1:      * @returns the ObjectName of the Connection that created this subscription
1:      */
1:     public ObjectName getConnection() {
1:         ObjectName result = null;
1: 
1:         if (clientId != null && subscription != null) {
1:             ConnectionContext ctx = subscription.getContext();
1:             if (ctx != null && ctx.getBroker() != null && ctx.getBroker().getBrokerService() != null) {
1:                 BrokerService service = ctx.getBroker().getBrokerService();
1:                 ManagementContext managementCtx = service.getManagementContext();
1:                 if (managementCtx != null) {
1: 
1:                     try {
0:                         ObjectName query = createConnectionQueury(managementCtx, service.getBrokerName());
1:                         Set<ObjectName> names = managementCtx.queryNames(query, null);
1:                         if (names.size() == 1) {
1:                             result = names.iterator().next();
1:                         }
1:                     } catch (Exception e) {
1:                     }
1:                 }
1:             }
1:         }
1:         return result;
1:     }
1: 
0:     private ObjectName createConnectionQueury(ManagementContext ctx, String brokerName) throws IOException {
1:         try {
0:             return new ObjectName(ctx.getJmxDomainName() + ":" + "BrokerName="
0:                                   + JMXSupport.encodeObjectNamePart(brokerName) + ","
0:                                   + "Type=Connection," + "ConnectorName=*,"
0:                                   + "Connection=" + JMXSupport.encodeObjectNamePart(clientId));
1:         } catch (Throwable e) {
1:             throw IOExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     /**
commit:f5dcc9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerInfo;
1:  *
1:     protected final String userName;
1:      *
1:     public SubscriptionView(String clientId, String userName, Subscription subs) {
1:         this.userName = userName;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Override
1:     public String getUserName() {
1:         return userName;
1:     }
author:Robert Davies
-------------------------------------------------------------------------------
commit:c37859a
/////////////////////////////////////////////////////////////////////////
1:                         ObjectName query = createConnectionQuery(managementCtx, service.getBrokerName());
/////////////////////////////////////////////////////////////////////////
1:     private ObjectName createConnectionQuery(ManagementContext ctx, String brokerName) throws IOException {
0:             return new ObjectName(ctx.getJmxDomainName() + ":type=Broker,brokerName="
0:                                   + "connector=*," + "connectorName=*,"
0:                                   + "connectionName=" + JMXSupport.encodeObjectNamePart(clientId));
commit:9899dff
/////////////////////////////////////////////////////////////////////////
1:     
1:     public int getMessageCountAwaitingAcknowledge() {
1:         return getDispatchedQueueSize();
1:     }
commit:c717221
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      *@return pretty print
1:      */
0:     public String toString(){
0:         return "SubscriptionView: " + getClientId()  + ":" +  getConnectionId();
1:     }
commit:c82f6f3
/////////////////////////////////////////////////////////////////////////
1:     protected final String clientId;
0:     public SubscriptionView(String clientId,Subscription subs){
1:         this.clientId = clientId;
1:      * @return the clientId
1:      */
0:     public String getClientId(){
1:         return clientId;
1:     }
1:     
1:     /**
1:         ConsumerInfo info = getConsumerInfo();
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo info = getConsumerInfo();
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo info = getConsumerInfo();
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo info = getConsumerInfo();
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo info = getConsumerInfo();
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo info = getConsumerInfo();
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo info = getConsumerInfo();
1:     
1:     /**
1:      * @return true if the subscriber is active
1:      */
0:     public boolean isActive(){
1:         return true;
1:     }
0:         if (subscription != null){
1:         }
0:         return subscription != null ? subscription.pending() : 0;
0:         return subscription != null ? subscription.dispatched() : 0;
0:         return subscription != null ? subscription.delivered() : 0;
1:     }
1:     
0:     protected ConsumerInfo getConsumerInfo(){
1:         return subscription != null ? subscription.getConsumerInfo() : null;
commit:3601e81
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.jmx;
1: 
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ConsumerInfo;
1: 
1: 
1: 
1: /**
0:  * @version $Revision: 1.5 $
1:  */
1: public class SubscriptionView implements SubscriptionViewMBean {
1:     
1:     
1:     protected final Subscription subscription;
1:     
1:     
1:     
1:     /**
0:      * Constructior
1:      * @param subs
1:      */
0:     public SubscriptionView(Subscription subs){
1:         this.subscription = subs;
1:     }
1:     
1:     /**
1:      * @return the id of the Connection the Subscription is on
1:      */
0:     public String getConnectionId(){
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null){
1:             return info.getConsumerId().getConnectionId();
1:         }
1:         return "NOTSET";
1:     }
1: 
1:     /**
1:      * @return the id of the Session the subscription is on
1:      */
0:     public long getSessionId(){
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null){
1:             return info.getConsumerId().getSessionId();
1:         }
1:         return 0;
1:     }
1: 
1:     /**
0:      * @return the id of the Subscription
1:      */
0:     public long getSubcriptionId(){
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null){
1:             return info.getConsumerId().getValue();
1:         }
1:         return 0;
1:     }
1: 
1:     /**
1:      * @return the destination name
1:      */
0:     public String getDestinationName(){
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null){
1:             ActiveMQDestination dest = info.getDestination();
1:             return dest.getPhysicalName();
1:         }
1:         return "NOTSET";
1:        
1:     }
1: 
1:     /**
1:      * @return true if the destination is a Queue
1:      */
0:     public boolean isDestinationQueue(){
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null){
1:             ActiveMQDestination dest = info.getDestination();
1:             return dest.isQueue();
1:         }
1:         return false;
1:     }
1: 
1:     /**
1:      * @return true of the destination is a Topic
1:      */
0:     public boolean isDestinationTopic(){
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null){
1:             ActiveMQDestination dest = info.getDestination();
1:             return dest.isTopic();
1:         }
1:         return false;
1:     }
1: 
1:     /**
1:      * @return true if the destination is temporary
1:      */
0:     public boolean isDestinationTemporary(){
0:         ConsumerInfo info = subscription.getConsumerInfo();
0:         if (info != null){
1:             ActiveMQDestination dest = info.getDestination();
1:             return dest.isTemporary();
1:         }
1:         return false;
1:     }
1: 
1:     /**
0:      * The subscription should release as may references as it can to help the garbage collector
0:      * reclaim memory.
1:      */
0:     public void gc(){
1:         subscription.gc();
1:     }
1:     
1:     /**
1:      * @return number of messages pending delivery
1:      */
0:     public int getPending(){
0:         return subscription.pending();
1:     }
1:     
1:     /**
1:      * @return number of messages dispatched
1:      */
0:     public int getDispatched(){
0:         return subscription.dispatched();
1:     }
1:     
1:     /**
0:      * @return number of messages delivered
1:      */
0:     public int getDelivered(){
0:         return subscription.delivered();
1:     }
1: 
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidSelectorException;
1: 
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:      * 
0:     public SubscriptionView(String clientId, Subscription subs) {
1: 
1:     public String getClientId() {
1: 
1:     public String getConnectionId() {
1:         if (info != null) {
/////////////////////////////////////////////////////////////////////////
1:     public long getSessionId() {
1:         if (info != null) {
/////////////////////////////////////////////////////////////////////////
0:     public long getSubcriptionId() {
1:         if (info != null) {
/////////////////////////////////////////////////////////////////////////
1:     public String getDestinationName() {
1:         if (info != null) {
/////////////////////////////////////////////////////////////////////////
1:         } else {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDestinationQueue() {
1:         if (info != null) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDestinationTopic() {
1:         if (info != null) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isDestinationTemporary() {
1:         if (info != null) {
1: 
1:     public boolean isActive() {
1:      * The subscription should release as may references as it can to help the
1:      * garbage collector reclaim memory.
1:     public void gc() {
1:         if (subscription != null) {
0:             subscription.gc();
1: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:      * @return the maximum number of pending messages allowed in addition to the
1:      *         prefetch size. If enabled to a non-zero value then this will
1:      *         perform eviction of messages for slow consumers on non-durable
1:      *         topics.
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:      * @return the name of the consumer which is only used for durable
0:      *         consumers.
0: 
1:     public int getPendingQueueSize() {
0: 
1:     public int getDispatchedQueueSize() {
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected ConsumerInfo getConsumerInfo() {
0: 
1:      * @return pretty print
1:     public String toString() {
1:         return "SubscriptionView: " + getClientId() + ":" + getConnectionId();
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:333158a
/////////////////////////////////////////////////////////////////////////
1:         return info != null ? info.getSubscriptionName() : null;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f5f1366
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      */
1:     public int getPrefetchSize() {
1:         return subscription != null ? subscription.getPrefetchSize() : 0;
1:     }
0: 
commit:07d4e8c
/////////////////////////////////////////////////////////////////////////
0:     public int getPendingQueueSize(){
1:         return subscription != null ? subscription.getPendingQueueSize() : 0;
0:     public int getDispatchedQueueSize(){
1:         return subscription != null ? subscription.getDispatchedQueueSize() : 0;
0:         
1:      * @return number of messages that matched the subscription
0:     public long getDispachedCounter() {
1:         return subscription != null ? subscription.getDispatchedCounter() : 0;
0: 
1:     /**
1:      * @return number of messages that matched the subscription
1:      */
1:     public long getEnqueueCounter() {
1:         return subscription != null ? subscription.getEnqueueCounter() : 0;
1:     }
0: 
1:     /**
1:      * @return number of messages queued by the client
1:      */
1:     public long getDequeueCounter() {
1:         return subscription != null ? subscription.getDequeueCounter() : 0;
1:     }
0: 
commit:6272ddc
/////////////////////////////////////////////////////////////////////////
1:      * Constructor
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e085ed4
/////////////////////////////////////////////////////////////////////////
0:     @Override
1:     public boolean isSlowConsumer() {
1:         return subscription.isSlowConsumer();
1:     }
commit:c75ff7f
/////////////////////////////////////////////////////////////////////////
1:     public long getDispatchedCounter() {
author:James Strachan
-------------------------------------------------------------------------------
commit:52e15a4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
1: import org.apache.activemq.filter.DestinationFilter;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isMatchingQueue(String queueName) {
1:         if (isDestinationQueue()) {
1:             return matchesDestination(new ActiveMQQueue(queueName));
1:         }
1:         return false;
1:     }
0: 
1:     public boolean isMatchingTopic(String topicName) {
1:         if (isDestinationTopic()) {
1:             return matchesDestination(new ActiveMQTopic(topicName));
1:         }
1:         return false;
1:     }
0: 
1:     /**
1:      * Return true if this subscription matches the given destination
0:      *
1:      * @param destination the destination to compare against
1:      * @return true if this subscription matches the given destination
1:      */
1:     public boolean matchesDestination(ActiveMQDestination destination) {
1:         ActiveMQDestination subscriptionDestination = subscription.getActiveMQDestination();
1:         DestinationFilter filter = DestinationFilter.parseFilter(subscriptionDestination);
1:         return filter.matches(destination);
1:     }
0: 
commit:b695b49
/////////////////////////////////////////////////////////////////////////
1:      * @return whether or not the subscriber is retroactive or not
1:      */
1:     public boolean isRetroactive() {
1:         ConsumerInfo info = getConsumerInfo();
1:         return info != null ? info.isRetroactive() : false;
1:     }
0:     
1:     /**
1:      * @return whether or not the subscriber is an exclusive consumer
1:      */
1:     public boolean isExclusive() {
1:         ConsumerInfo info = getConsumerInfo();
1:         return info != null ? info.isExclusive() : false;
1:     }
0:     
0:     
1:     /**
1:      * @return whether or not the subscriber is durable (persistent)
1:      */
1:     public boolean isDurable() {
1:         ConsumerInfo info = getConsumerInfo();
1:         return info != null ? info.isDurable() : false;
1:     }
0:     
1:     /**
1:      * @return whether or not the subscriber ignores local messages
1:      */
1:     public boolean isNoLocal() {
1:         ConsumerInfo info = getConsumerInfo();
1:         return info != null ? info.isNoLocal() : false;
1:     }
0:     
0:     
1:     /**
0:      * @return the maximum number of pending messages allowed in addition to the prefetch size. If enabled
0:      * to a non-zero value then this will perform eviction of messages for slow consumers on non-durable topics.
1:      */
1:     public int getMaximumPendingMessageLimit() {
1:         ConsumerInfo info = getConsumerInfo();
1:         return info != null ? info.getMaximumPendingMessageLimit() : 0;
1:     }
0:     
1:     /**
1:      * @return the consumer priority
1:      */
1:     public byte getPriority() {
1:         ConsumerInfo info = getConsumerInfo();
1:         return info != null ? info.getPriority() : 0;
1:     }
0:     
1:     /**
0:      * @return the name of the consumer which is only used for durable consumers.
1:      */
0:     public String getSubcriptionName() {
1:         ConsumerInfo info = getConsumerInfo();
0:         return info != null ? info.getSubcriptionName() : null;
1:     }
0:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1: }
commit:5371cf5
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidSelectorException;
0: 
/////////////////////////////////////////////////////////////////////////
1:     }
0: 
1:     public String getSelector() {
1:         if (subscription != null) {
1:             return subscription.getSelector();
1:         }
1:         return null;
1:     }
0: 
1:     public void setSelector(String selector) throws InvalidSelectorException, UnsupportedOperationException {
1:         if (subscription != null) {
1:             subscription.setSelector(selector);
1:         }
0:         else {
1:             throw new UnsupportedOperationException("No subscription object");
1:         }
============================================================================