1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
2:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.command;
6:d29ca2a: 
1:712254d: import java.util.ArrayList;
1:4993475: import java.util.HashMap;
1:712254d: import java.util.List;
1:5d697cf: import java.util.Map;
1:5d697cf: import java.util.concurrent.ConcurrentHashMap;
1:5d697cf: import java.util.concurrent.atomic.AtomicLong;
1:d29ca2a: 
1:d29ca2a: import org.apache.activemq.filter.BooleanExpression;
1:d29ca2a: import org.apache.activemq.state.CommandVisitor;
1:d29ca2a: 
1:d29ca2a: /**
1:4afa5d6:  * @openwire:marshaller code="5"
1:b0c2a40:  *
1:d29ca2a:  */
1:b9dcb01: public class ConsumerInfo extends BaseCommand implements TransientInitializer {
1:230a86c: 
1:230a86c:     public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONSUMER_INFO;
1:230a86c: 
1:230a86c:     public static final byte HIGH_PRIORITY = 10;
1:230a86c:     public static final byte NORMAL_PRIORITY = 0;
1:230a86c:     public static final byte NETWORK_CONSUMER_PRIORITY = -5;
1:230a86c:     public static final byte LOW_PRIORITY = -10;
1:230a86c: 
1:d29ca2a:     protected ConsumerId consumerId;
1:d29ca2a:     protected ActiveMQDestination destination;
1:d29ca2a:     protected int prefetchSize;
1:bed10aa:     protected int maximumPendingMessageLimit;
1:d29ca2a:     protected boolean browser;
1:d29ca2a:     protected boolean dispatchAsync;
1:d29ca2a:     protected String selector;
1:620523a:     protected String clientId;
1:333158a:     protected String subscriptionName;
1:d29ca2a:     protected boolean noLocal;
1:d29ca2a:     protected boolean exclusive;
1:d29ca2a:     protected boolean retroactive;
1:d29ca2a:     protected byte priority;
1:d29ca2a:     protected BrokerId[] brokerPath;
1:ef0734b:     protected boolean optimizedAcknowledge;
1:f812e34:     // used by the broker
1:f812e34:     protected transient int currentPrefetchSize;
1:f812e34:     // if true, the consumer will not send range
1:f812e34:     protected boolean noRangeAcks;
1:f812e34:     // acks.
1:230a86c: 
1:446629b:     protected BooleanExpression additionalPredicate;
1:230a86c:     protected transient boolean networkSubscription; // this subscription
1:712254d:     protected transient List<ConsumerId> networkConsumerIds; // the original consumerId
1:f812e34: 
1:3b08860:     // not marshalled, populated from RemoveInfo, the last message delivered, used
1:3b08860:     // to suppress redelivery on prefetched messages after close
1:eb6c082:     private transient long lastDeliveredSequenceId = RemoveInfo.LAST_DELIVERED_UNSET;
1:5d697cf:     private transient Map<ActiveMQDestination, AtomicLong> assignedGroupCount = new ConcurrentHashMap<>();
1:f812e34:     // originated from a
1:f812e34:     // network connection
1:230a86c: 
1:d29ca2a:     public ConsumerInfo() {
1:d29ca2a:     }
1:d25c52c: 
1:d29ca2a:     public ConsumerInfo(ConsumerId consumerId) {
1:230a86c:         this.consumerId = consumerId;
1:d25c52c:     }
1:230a86c: 
1:d29ca2a:     public ConsumerInfo(SessionInfo sessionInfo, long consumerId) {
1:d29ca2a:         this.consumerId = new ConsumerId(sessionInfo.getSessionId(), consumerId);
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public ConsumerInfo copy() {
1:d29ca2a:         ConsumerInfo info = new ConsumerInfo();
1:d29ca2a:         copy(info);
1:d29ca2a:         return info;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void copy(ConsumerInfo info) {
1:d29ca2a:         super.copy(info);
1:d29ca2a:         info.consumerId = consumerId;
1:d29ca2a:         info.destination = destination;
1:d29ca2a:         info.prefetchSize = prefetchSize;
1:bed10aa:         info.maximumPendingMessageLimit = maximumPendingMessageLimit;
1:d29ca2a:         info.browser = browser;
1:d29ca2a:         info.dispatchAsync = dispatchAsync;
1:d29ca2a:         info.selector = selector;
1:620523a:         info.clientId = clientId;
1:230a86c:         info.subscriptionName = subscriptionName;
1:d29ca2a:         info.noLocal = noLocal;
1:d29ca2a:         info.exclusive = exclusive;
1:d29ca2a:         info.retroactive = retroactive;
1:d29ca2a:         info.priority = priority;
1:230a86c:         info.brokerPath = brokerPath;
1:712254d:         info.networkSubscription = networkSubscription;
1:712254d:         if (networkConsumerIds != null) {
1:712254d:             if (info.networkConsumerIds==null){
1:712254d:                 info.networkConsumerIds=new ArrayList<ConsumerId>();
1:d29ca2a:             }
1:712254d:             info.networkConsumerIds.addAll(networkConsumerIds);
1:d29ca2a:         }
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public boolean isDurable() {
1:230a86c:         return subscriptionName != null;
1:d29ca2a:     }
1:230a86c: 
1:8f078a3:     @Override
1:d29ca2a:     public byte getDataStructureType() {
1:d29ca2a:         return DATA_STRUCTURE_TYPE;
1:d29ca2a:     }
1:230a86c: 
1:f1a0614:     /**
1:d29ca2a:      * Is used to uniquely identify the consumer to the broker.
1:f1a0614:      *
1:d29ca2a:      * @openwire:property version=1 cache=true
1:d29ca2a:      */
1:d29ca2a:     public ConsumerId getConsumerId() {
1:d29ca2a:         return consumerId;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setConsumerId(ConsumerId consumerId) {
1:d29ca2a:         this.consumerId = consumerId;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Is this consumer a queue browser?
1:d29ca2a:      *
1:620523a:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public boolean isBrowser() {
1:d29ca2a:         return browser;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setBrowser(boolean browser) {
1:d29ca2a:         this.browser = browser;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * The destination that the consumer is interested in receiving messages
1:230a86c:      * from. This destination could be a composite destination.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1 cache=true
1:d29ca2a:      */
1:d29ca2a:     public ActiveMQDestination getDestination() {
1:d29ca2a:         return destination;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setDestination(ActiveMQDestination destination) {
1:d29ca2a:         this.destination = destination;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     /**
1:230a86c:      * How many messages a broker will send to the client without receiving an
1:230a86c:      * ack before he stops dispatching messages to the client.
1:d29ca2a:      *
1:446629b:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public int getPrefetchSize() {
1:d29ca2a:         return prefetchSize;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     public void setPrefetchSize(int prefetchSize) {
1:d29ca2a:         this.prefetchSize = prefetchSize;
1:6eaea6f:         this.currentPrefetchSize = prefetchSize;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * How many messages a broker will keep around, above the prefetch limit,
1:230a86c:      * for non-durable topics before starting to discard older messages.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:bed10aa:     public int getMaximumPendingMessageLimit() {
1:bed10aa:         return maximumPendingMessageLimit;
1:d29ca2a:     }
1:d29ca2a: 
1:bed10aa:     public void setMaximumPendingMessageLimit(int maximumPendingMessageLimit) {
1:bed10aa:         this.maximumPendingMessageLimit = maximumPendingMessageLimit;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * Should the broker dispatch a message to the consumer async? If he does it
1:230a86c:      * async, then he uses a more SEDA style of processing while if it is not
1:230a86c:      * done async, then he broker use a STP style of processing. STP is more
1:230a86c:      * appropriate in high bandwidth situations or when being used by and in vm
1:230a86c:      * transport.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public boolean isDispatchAsync() {
1:d29ca2a:         return dispatchAsync;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setDispatchAsync(boolean dispatchAsync) {
1:d29ca2a:         this.dispatchAsync = dispatchAsync;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * The JMS selector used to filter out messages that this consumer is
1:230a86c:      * interested in.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public String getSelector() {
1:d29ca2a:         return selector;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setSelector(String selector) {
1:d29ca2a:         this.selector = selector;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:620523a:      * Used to identify the id of a client connection.
1:620523a:      *
1:2dd1335:      * @openwire:property version=10
1:620523a:      */
1:620523a:     public String getClientId() {
1:620523a:         return clientId;
1:620523a:     }
1:620523a: 
1:620523a:     public void setClientId(String clientId) {
1:620523a:         this.clientId = clientId;
1:620523a:     }
1:620523a: 
1:620523a:     /**
1:d29ca2a:      * Used to identify the name of a durable subscription.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:333158a:     public String getSubscriptionName() {
2:333158a:         return subscriptionName;
1:333158a:     }
1:230a86c: 
1:333158a:     public void setSubscriptionName(String durableSubscriptionId) {
2:333158a:         this.subscriptionName = durableSubscriptionId;
1:230a86c:     }
1:230a86c: 
1:333158a:     /**
1:230a86c:      * Set noLocal to true to avoid receiving messages that were published
1:230a86c:      * locally on the same connection.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:333158a:      */
1:d29ca2a:     public boolean isNoLocal() {
1:d29ca2a:         return noLocal;
1:333158a:     }
1:230a86c: 
1:d29ca2a:     public void setNoLocal(boolean noLocal) {
1:d29ca2a:         this.noLocal = noLocal;
1:333158a:     }
1:230a86c: 
1:333158a:     /**
1:230a86c:      * An exclusive consumer locks out other consumers from being able to
1:230a86c:      * receive messages from the destination. If there are multiple exclusive
1:230a86c:      * consumers for a destination, the first one created will be the exclusive
1:230a86c:      * consumer of the destination.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:333158a:      */
1:d29ca2a:     public boolean isExclusive() {
1:d29ca2a:         return exclusive;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setExclusive(boolean exclusive) {
1:d29ca2a:         this.exclusive = exclusive;
1:d29ca2a:     }
1:333158a: 
1:d29ca2a:     /**
1:230a86c:      * A retroactive consumer only has meaning for Topics. It allows a consumer
1:230a86c:      * to retroactively see messages sent prior to the consumer being created.
1:230a86c:      * If the consumer is not durable, it will be delivered the last message
1:230a86c:      * published to the topic. If the consumer is durable then it will receive
1:230a86c:      * all persistent messages that are still stored in persistent storage for
1:230a86c:      * that topic.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public boolean isRetroactive() {
1:d29ca2a:         return retroactive;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setRetroactive(boolean retroactive) {
1:d29ca2a:         this.retroactive = retroactive;
1:d29ca2a:     }
1:333158a: 
1:d29ca2a:     public RemoveInfo createRemoveCommand() {
1:d29ca2a:         RemoveInfo command = new RemoveInfo(getConsumerId());
1:d29ca2a:         command.setResponseRequired(isResponseRequired());
1:d29ca2a:         return command;
1:d29ca2a:     }
1:333158a: 
1:d29ca2a:     /**
1:230a86c:      * The broker will avoid dispatching to a lower priority consumer if there
1:230a86c:      * are other higher priority consumers available to dispatch to. This allows
1:230a86c:      * letting the broker to have an affinity to higher priority consumers.
1:230a86c:      * Default priority is 0.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public byte getPriority() {
1:d29ca2a:         return priority;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setPriority(byte priority) {
1:d29ca2a:         this.priority = priority;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * The route of brokers the command has moved through.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1 cache=true
1:d29ca2a:      */
1:d29ca2a:     public BrokerId[] getBrokerPath() {
1:d29ca2a:         return brokerPath;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setBrokerPath(BrokerId[] brokerPath) {
1:d29ca2a:         this.brokerPath = brokerPath;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * A transient additional predicate that can be used it inject additional
1:230a86c:      * predicates into the selector on the fly. Handy if if say a Security
1:230a86c:      * Broker interceptor wants to filter out messages based on security level
1:230a86c:      * of the consumer.
1:d29ca2a:      *
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      */
1:d29ca2a:     public BooleanExpression getAdditionalPredicate() {
1:d29ca2a:         return additionalPredicate;
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public void setAdditionalPredicate(BooleanExpression additionalPredicate) {
1:d29ca2a:         this.additionalPredicate = additionalPredicate;
1:d29ca2a:     }
1:d29ca2a: 
1:8f078a3:     @Override
1:7f5213b:     public Response visit(CommandVisitor visitor) throws Exception {
1:230a86c:         return visitor.processAddConsumer(this);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @openwire:property version=1
1:d29ca2a:      * @return Returns the networkSubscription.
1:d29ca2a:      */
1:230a86c:     public boolean isNetworkSubscription() {
1:d29ca2a:         return networkSubscription;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param networkSubscription The networkSubscription to set.
1:d29ca2a:      */
1:230a86c:     public void setNetworkSubscription(boolean networkSubscription) {
1:230a86c:         this.networkSubscription = networkSubscription;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * @openwire:property version=1
1:ef0734b:      * @return Returns the optimizedAcknowledge.
1:d29ca2a:      */
1:230a86c:     public boolean isOptimizedAcknowledge() {
1:ef0734b:         return optimizedAcknowledge;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:ef0734b:      * @param optimizedAcknowledge The optimizedAcknowledge to set.
2:ef0734b:      */
1:230a86c:     public void setOptimizedAcknowledge(boolean optimizedAcknowledge) {
1:230a86c:         this.optimizedAcknowledge = optimizedAcknowledge;
1:d29ca2a:     }
1:d29ca2a: 
1:6eaea6f:     /**
1:6eaea6f:      * @return Returns the currentPrefetchSize.
1:6eaea6f:      */
1:230a86c:     public int getCurrentPrefetchSize() {
1:6eaea6f:         return currentPrefetchSize;
1:712254d:     }
1:d29ca2a: 
1:6eaea6f:     /**
1:6eaea6f:      * @param currentPrefetchSize The currentPrefetchSize to set.
1:6eaea6f:      */
1:230a86c:     public void setCurrentPrefetchSize(int currentPrefetchSize) {
1:230a86c:         this.currentPrefetchSize = currentPrefetchSize;
1:712254d:     }
1:d29ca2a: 
2:ef0734b:     /**
1:230a86c:      * The broker may be able to optimize it's processing or provides better QOS
1:230a86c:      * if it knows the consumer will not be sending ranged acks.
1:d29ca2a:      *
1:f1a0614:      * @return true if the consumer will not send range acks.
1:f1a0614:      * @openwire:property version=1
1:f1a0614:      */
1:f1a0614:     public boolean isNoRangeAcks() {
1:f1a0614:         return noRangeAcks;
1:f1a0614:     }
1:f1a0614: 
1:f1a0614:     public void setNoRangeAcks(boolean noRangeAcks) {
1:f1a0614:         this.noRangeAcks = noRangeAcks;
1:f1a0614:     }
1:f1a0614: 
1:712254d:     public synchronized void addNetworkConsumerId(ConsumerId networkConsumerId) {
1:712254d:         if (networkConsumerIds == null) {
1:712254d:             networkConsumerIds = new ArrayList<ConsumerId>();
1:712254d:         }
1:712254d:         networkConsumerIds.add(networkConsumerId);
1:712254d:     }
1:d29ca2a: 
1:712254d:     public synchronized void removeNetworkConsumerId(ConsumerId networkConsumerId) {
1:712254d:         if (networkConsumerIds != null) {
1:712254d:             networkConsumerIds.remove(networkConsumerId);
1:712254d:             if (networkConsumerIds.isEmpty()) {
1:712254d:                 networkConsumerIds=null;
1:712254d:             }
1:712254d:         }
1:712254d:     }
1:d29ca2a: 
1:712254d:     public synchronized boolean isNetworkConsumersEmpty() {
1:712254d:         return networkConsumerIds == null || networkConsumerIds.isEmpty();
1:712254d:     }
1:d29ca2a: 
1:712254d:     public synchronized List<ConsumerId> getNetworkConsumerIds(){
1:712254d:         List<ConsumerId> result = new ArrayList<ConsumerId>();
1:712254d:         if (networkConsumerIds != null) {
1:712254d:             result.addAll(networkConsumerIds);
1:712254d:         }
1:712254d:         return result;
1:712254d:     }
1:d29ca2a: 
1:b9dcb01:     @Override
1:8f078a3:     public int hashCode() {
1:8f078a3:         return (consumerId == null) ? 0 : consumerId.hashCode();
1:8f078a3:     }
1:8f078a3: 
1:8f078a3:     @Override
1:8f078a3:     public boolean equals(Object obj) {
1:8f078a3:         if (this == obj) {
1:8f078a3:             return true;
1:8f078a3:         }
1:8f078a3:         if (obj == null) {
1:8f078a3:             return false;
1:8f078a3:         }
1:8f078a3:         if (getClass() != obj.getClass()) {
1:8f078a3:             return false;
1:8f078a3:         }
1:8f078a3: 
1:8f078a3:         ConsumerInfo other = (ConsumerInfo) obj;
1:8f078a3: 
1:8f078a3:         if (consumerId == null && other.consumerId != null) {
1:8f078a3:             return false;
1:8f078a3:         } else if (!consumerId.equals(other.consumerId)) {
1:8f078a3:             return false;
1:8f078a3:         }
1:8f078a3:         return true;
1:8f078a3:     }
1:8f078a3: 
1:301203e:     /**
1:301203e:      * Tracks the original subscription id that causes a subscription to
1:301203e:      * percolate through a network when networkTTL > 1. Tracking the original
1:301203e:      * subscription allows duplicate suppression.
1:d29ca2a:      *
1:301203e:      * @return array of the current subscription path
1:301203e:      * @openwire:property version=4
1:301203e:      */
1:301203e:     public ConsumerId[] getNetworkConsumerPath() {
1:301203e:         ConsumerId[] result = null;
1:301203e:         if (networkConsumerIds != null) {
1:301203e:             result = networkConsumerIds.toArray(new ConsumerId[0]);
1:301203e:         }
1:301203e:         return result;
1:301203e:     }
1:d29ca2a: 
1:301203e:     public void setNetworkConsumerPath(ConsumerId[] consumerPath) {
1:301203e:         if (consumerPath != null) {
1:301203e:             for (int i=0; i<consumerPath.length; i++) {
1:301203e:                 addNetworkConsumerId(consumerPath[i]);
1:301203e:             }
1:301203e:         }
1:301203e:     }
1:d29ca2a: 
1:3b08860:     public void setLastDeliveredSequenceId(long lastDeliveredSequenceId) {
1:3b08860:         this.lastDeliveredSequenceId  = lastDeliveredSequenceId;
1:3b08860:     }
1:d29ca2a: 
1:3b08860:     public long getLastDeliveredSequenceId() {
1:3b08860:         return lastDeliveredSequenceId;
1:60ad053:     }
1:60ad053: 
1:5d697cf:     public void incrementAssignedGroupCount(final ActiveMQDestination dest) {
1:5d697cf:         AtomicLong value = assignedGroupCount.get(dest);
1:5d697cf:         if (value == null) {
1:5d697cf:             value = new AtomicLong(0);
1:5d697cf:             assignedGroupCount.put(dest, value);
1:5d697cf:         }
1:5d697cf:         value.incrementAndGet();
1:60ad053:     }
1:60ad053: 
1:5d697cf:     public void clearAssignedGroupCount(final ActiveMQDestination dest) {
1:5d697cf:         assignedGroupCount.remove(dest);
1:60ad053:     }
1:60ad053: 
1:5d697cf:     public void decrementAssignedGroupCount(final ActiveMQDestination dest) {
1:5d697cf:         AtomicLong value = assignedGroupCount.get(dest);
1:5d697cf:         if (value != null) {
1:5d697cf:             value.decrementAndGet();
1:5d697cf:         }
1:3b08860:     }
1:d29ca2a: 
1:5d697cf:     public long getAssignedGroupCount(final ActiveMQDestination dest) {
1:5d697cf:         long result = 0l;
1:5d697cf:         AtomicLong value = assignedGroupCount.get(dest);
1:5d697cf:         if (value != null) {
1:5d697cf:             result = value.longValue();
1:5d697cf:         }
1:5d697cf:         return result;
1:6eaea6f:     }
1:d29ca2a: 
1:8f078a3:     @Override
1:8136e67:     public void initTransients() {
1:8136e67:         assignedGroupCount = new ConcurrentHashMap<>();
1:8136e67:         lastDeliveredSequenceId = RemoveInfo.LAST_DELIVERED_UNSET;
1:8136e67:     }
1:8136e67: 
1:4993475:     @Override
1:4993475:     public String toString() {
1:4993475:         HashMap<String, Object> overrideFields = new HashMap<String, Object>();
1:4993475:         overrideFields.put("networkConsumerIds", networkConsumerIds);
1:4993475:         return super.toString(overrideFields);
1:4993475:     }
1:4993475: 
1:6eaea6f: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:4993475
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString() {
1:         HashMap<String, Object> overrideFields = new HashMap<String, Object>();
1:         overrideFields.put("networkConsumerIds", networkConsumerIds);
1:         return super.toString(overrideFields);
1:     }
1: 
commit:8136e67
/////////////////////////////////////////////////////////////////////////
1:     public void initTransients() {
1:         assignedGroupCount = new ConcurrentHashMap<>();
1:         lastDeliveredSequenceId = RemoveInfo.LAST_DELIVERED_UNSET;
1:     }
1: 
commit:5d697cf
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.atomic.AtomicLong;
/////////////////////////////////////////////////////////////////////////
1:     private transient Map<ActiveMQDestination, AtomicLong> assignedGroupCount = new ConcurrentHashMap<>();
/////////////////////////////////////////////////////////////////////////
1:     public void incrementAssignedGroupCount(final ActiveMQDestination dest) {
1:         AtomicLong value = assignedGroupCount.get(dest);
1:         if (value == null) {
1:             value = new AtomicLong(0);
1:             assignedGroupCount.put(dest, value);
1:         }
1:         value.incrementAndGet();
1:     public void clearAssignedGroupCount(final ActiveMQDestination dest) {
1:         assignedGroupCount.remove(dest);
1:     public void decrementAssignedGroupCount(final ActiveMQDestination dest) {
1:         AtomicLong value = assignedGroupCount.get(dest);
1:         if (value != null) {
1:             value.decrementAndGet();
1:         }
1:     public long getAssignedGroupCount(final ActiveMQDestination dest) {
1:         long result = 0l;
1:         AtomicLong value = assignedGroupCount.get(dest);
1:         if (value != null) {
1:             result = value.longValue();
1:         }
1:         return result;
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1:     private transient long lastDeliveredSequenceId = RemoveInfo.LAST_DELIVERED_UNSET;
commit:d25c52c
/////////////////////////////////////////////////////////////////////////
0:     public void clearAssignedGroupCount() {
0:         this.assignedGroupCount=0;
1:     }
1: 
commit:60ad053
/////////////////////////////////////////////////////////////////////////
0:     private transient long assignedGroupCount;
/////////////////////////////////////////////////////////////////////////
0:     public void incrementAssignedGroupCount() {
0:         this.assignedGroupCount++;
1:     }
1: 
0:     public void decrementAssignedGroupCount() {
0:         this.assignedGroupCount--;
1:     }
1: 
0:     public long getAssignedGroupCount() {
0:         return assignedGroupCount;
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:b9dcb01
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class ConsumerInfo extends BaseCommand implements TransientInitializer {
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Timothy Bish
-------------------------------------------------------------------------------
commit:8f078a3
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public int hashCode() {
1:         return (consumerId == null) ? 0 : consumerId.hashCode();
1:     }
1: 
1:     @Override
1:     public boolean equals(Object obj) {
1:         if (this == obj) {
1:             return true;
1:         }
1:         if (obj == null) {
1:             return false;
1:         }
1:         if (getClass() != obj.getClass()) {
1:             return false;
1:         }
1: 
1:         ConsumerInfo other = (ConsumerInfo) obj;
1: 
1:         if (consumerId == null && other.consumerId != null) {
1:             return false;
1:         } else if (!consumerId.equals(other.consumerId)) {
1:             return false;
1:         }
1:         return true;
1:     }
1: 
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:2dd1335
/////////////////////////////////////////////////////////////////////////
1:      * @openwire:property version=10
commit:620523a
/////////////////////////////////////////////////////////////////////////
1:     protected String clientId;
/////////////////////////////////////////////////////////////////////////
1:         info.clientId = clientId;
/////////////////////////////////////////////////////////////////////////
1:      * Used to identify the id of a client connection.
1:      *
1:      * @openwire:property version=1
1:      */
1:     public String getClientId() {
1:         return clientId;
1:     }
1: 
1:     public void setClientId(String clientId) {
1:         this.clientId = clientId;
1:     }
1: 
1:     /**
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:     // used by the broker
1:     protected transient int currentPrefetchSize;
1:     // if true, the consumer will not send range
1:     protected boolean noRangeAcks;
1:     // acks.
1: 
1:     // originated from a
1:     // network connection
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONSUMER_INFO;
1: 
1:     public static final byte HIGH_PRIORITY = 10;
1:     public static final byte NORMAL_PRIORITY = 0;
1:     public static final byte NETWORK_CONSUMER_PRIORITY = -5;
1:     public static final byte LOW_PRIORITY = -10;
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected transient int currentPrefetchSize;// used by the broker
0:     protected boolean noRangeAcks; // if true, the consumer will not send range
0:                                     // acks.
1: 
1:     protected transient boolean networkSubscription; // this subscription
0:                                                         // originated from a
0:                                                         // network connection
1: 
1: 
1:         this.consumerId = consumerId;
1: 
/////////////////////////////////////////////////////////////////////////
1:         info.subscriptionName = subscriptionName;
1:         info.brokerPath = brokerPath;
1: 
1:         return subscriptionName != null;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      * The destination that the consumer is interested in receiving messages
1:      * from. This destination could be a composite destination.
1: 
1: 
1:      * How many messages a broker will send to the client without receiving an
1:      * ack before he stops dispatching messages to the client.
/////////////////////////////////////////////////////////////////////////
1:      * How many messages a broker will keep around, above the prefetch limit,
1:      * for non-durable topics before starting to discard older messages.
/////////////////////////////////////////////////////////////////////////
1:      * Should the broker dispatch a message to the consumer async? If he does it
1:      * async, then he uses a more SEDA style of processing while if it is not
1:      * done async, then he broker use a STP style of processing. STP is more
1:      * appropriate in high bandwidth situations or when being used by and in vm
1:      * transport.
1: 
1:      * The JMS selector used to filter out messages that this consumer is
1:      * interested in.
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:      * @return
0:      * @see getSubscriptionName
1: 
0:      * @param durableSubscriptionId
1:     }
1: 
1:      * Set noLocal to true to avoid receiving messages that were published
1:      * locally on the same connection.
1: 
1:      * An exclusive consumer locks out other consumers from being able to
1:      * receive messages from the destination. If there are multiple exclusive
1:      * consumers for a destination, the first one created will be the exclusive
1:      * consumer of the destination.
1: 
1:      * A retroactive consumer only has meaning for Topics. It allows a consumer
1:      * to retroactively see messages sent prior to the consumer being created.
1:      * If the consumer is not durable, it will be delivered the last message
1:      * published to the topic. If the consumer is durable then it will receive
1:      * all persistent messages that are still stored in persistent storage for
1:      * that topic.
1: 
/////////////////////////////////////////////////////////////////////////
1:      * The broker will avoid dispatching to a lower priority consumer if there
1:      * are other higher priority consumers available to dispatch to. This allows
1:      * letting the broker to have an affinity to higher priority consumers.
1:      * Default priority is 0.
1: 
1:      * The route of brokers the command has moved through.
1: 
1:      * A transient additional predicate that can be used it inject additional
1:      * predicates into the selector on the fly. Handy if if say a Security
1:      * Broker interceptor wants to filter out messages based on security level
1:      * of the consumer.
1: 
1:         return visitor.processAddConsumer(this);
1:     public boolean isNetworkSubscription() {
1:     public void setNetworkSubscription(boolean networkSubscription) {
1:         this.networkSubscription = networkSubscription;
1:      * @openwire:property version=1
1:     public boolean isOptimizedAcknowledge() {
1:     public void setOptimizedAcknowledge(boolean optimizedAcknowledge) {
1:         this.optimizedAcknowledge = optimizedAcknowledge;
1:     public int getCurrentPrefetchSize() {
1:     public void setCurrentPrefetchSize(int currentPrefetchSize) {
1:         this.currentPrefetchSize = currentPrefetchSize;
1:      * The broker may be able to optimize it's processing or provides better QOS
1:      * if it knows the consumer will not be sending ranged acks.
commit:333158a
/////////////////////////////////////////////////////////////////////////
1:     protected String subscriptionName;
/////////////////////////////////////////////////////////////////////////
0:         info.subscriptionName=subscriptionName;
/////////////////////////////////////////////////////////////////////////
0:         return subscriptionName!=null;
/////////////////////////////////////////////////////////////////////////
1:     public String getSubscriptionName() {
1:         return subscriptionName;
1:     }
1:     public void setSubscriptionName(String durableSubscriptionId) {
1:         this.subscriptionName = durableSubscriptionId;
1:     }
1:     
1:     /**
0:      * @deprecated
0:      * @return @see getSubscriptionName
1:      */
1:         return subscriptionName;
1:     
1:     /**
0:      * @deprecated
0:      * @see setSubscriptionName
0:      * @param durableSubscriptionId 
1:      */
1:         this.subscriptionName = durableSubscriptionId;
1:     }    
1:     
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f1a0614
/////////////////////////////////////////////////////////////////////////
0:     protected boolean noRangeAcks;  // if true, the consumer will not send range acks.
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * The broker may be able to optimize it's processing or provides better
0:      * QOS if it knows the consumer will not be sending ranged acks.
1:      * 
1:      * @return true if the consumer will not send range acks.
1:      * @openwire:property version=1
1:      */
1:     public boolean isNoRangeAcks() {
1:         return noRangeAcks;
1:     }
1: 
1:     public void setNoRangeAcks(boolean noRangeAcks) {
1:         this.noRangeAcks = noRangeAcks;
1:     }
1: 
commit:446629b
/////////////////////////////////////////////////////////////////////////
1:     protected BooleanExpression additionalPredicate;
/////////////////////////////////////////////////////////////////////////
1:      * @openwire:property version=1
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public Response visit(CommandVisitor visitor) throws Exception {
commit:c59246d
/////////////////////////////////////////////////////////////////////////
0:     protected transient boolean networkSubscription; //this subscription originated from a network connection
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.command;
1: 
1: import org.apache.activemq.filter.BooleanExpression;
1: import org.apache.activemq.state.CommandVisitor;
1: 
1: 
1: /**
1:  * 
0:  * @openwire:marshaller
0:  * @version $Revision: 1.20 $
1:  */
0: public class ConsumerInfo extends BaseCommand {
1:     
0:     public static final byte DATA_STRUCTURE_TYPE=CommandTypes.CONSUMER_INFO;
1:     
0:     public static final byte HIGH_PRIORITY                = 10;
0:     public static final byte NORMAL_PRIORITY              = 0;
0:     public static final byte NETWORK_CONSUMER_PRIORITY    = -5;
0:     public static final byte LOW_PRIORITY                 = -10;
1:     
1:     
1:     protected ConsumerId consumerId;
1:     protected ActiveMQDestination destination;
1:     protected int prefetchSize;
1:     protected boolean browser;
1:     protected boolean dispatchAsync;
1:     protected String selector;
0:     protected String subcriptionName;
1:     protected boolean noLocal;
1:     protected boolean exclusive;
1:     protected boolean retroactive;
1:     protected byte priority;
1:     protected BrokerId[] brokerPath;
1:     
0:     protected transient BooleanExpression additionalPredicate;
0:     protected transient boolean networkSubscription; //this subscription orginated from a network connection
1:     
1:     public ConsumerInfo() {
1:     }
1:     
1:     public ConsumerInfo(ConsumerId consumerId) {
0:         this.consumerId=consumerId;
1:     }
1:     
1:     public ConsumerInfo(SessionInfo sessionInfo, long consumerId) {
1:         this.consumerId = new ConsumerId(sessionInfo.getSessionId(), consumerId);
1:     }
1: 
1:     public ConsumerInfo copy() {
1:         ConsumerInfo info = new ConsumerInfo();
1:         copy(info);
1:         return info;
1:     }
1: 
1:     public void copy(ConsumerInfo info) {
1:         super.copy(info);
1:         info.consumerId = consumerId;
1:         info.destination = destination;
1:         info.prefetchSize = prefetchSize;
1:         info.browser = browser;
1:         info.dispatchAsync = dispatchAsync;
1:         info.selector = selector;
0:         info.subcriptionName=subcriptionName;
1:         info.noLocal = noLocal;
1:         info.exclusive = exclusive;
1:         info.retroactive = retroactive;
1:         info.priority = priority;
0:         info.brokerPath=brokerPath;
1:     }
1:     
1:     public boolean isDurable() {
0:         return subcriptionName!=null;
1:     }
1:  
1:     public byte getDataStructureType() {
1:         return DATA_STRUCTURE_TYPE;
1:     }
1:     
1:     /**
1:      * Is used to uniquely identify the consumer to the broker.
1:      * 
1:      * @openwire:property version=1 cache=true
1:      */
1:     public ConsumerId getConsumerId() {
1:         return consumerId;
1:     }
1:     public void setConsumerId(ConsumerId consumerId) {
1:         this.consumerId = consumerId;
1:     }
1: 
1:     /**
1:      * Is this consumer a queue browser?
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public boolean isBrowser() {
1:         return browser;
1:     }
1:     public void setBrowser(boolean browser) {
1:         this.browser = browser;
1:     }
1:        
1:     /**
0:      * The destination that the consumer is interested in receiving messages from.
0:      * This destination could be a composite destination.
1:      * 
1:      * @openwire:property version=1 cache=true
1:      */
1:     public ActiveMQDestination getDestination() {
1:         return destination;
1:     }
1:     public void setDestination(ActiveMQDestination destination) {
1:         this.destination = destination;
1:     }
1:     
1:     /**
0:      * How many messages a broker will send to the client without receiving an ack before
0:      * he stops dispatching messages to the client.
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public int getPrefetchSize() {
1:         return prefetchSize;
1:     }
1: 
1:     public void setPrefetchSize(int prefetchSize) {
1:         this.prefetchSize = prefetchSize;
1:     }
1: 
1:     /**
0:      * Should the broker dispatch a message to the consumer async?  If he does it async, then 
0:      * he uses a more SEDA style of processing while if it is not done async, then he broker 
0:      * use a STP style of processing.  STP is more appropriate in high bandwidth situations or when
0:      * being used by and in vm transport.
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public boolean isDispatchAsync() {
1:         return dispatchAsync;
1:     }
1:     public void setDispatchAsync(boolean dispatchAsync) {
1:         this.dispatchAsync = dispatchAsync;
1:     }
1: 
1:     /**
0:      * The JMS selector used to filter out messages that this consumer
0:      * is interested in.
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public String getSelector() {
1:         return selector;
1:     }
1:     public void setSelector(String selector) {
1:         this.selector = selector;
1:     }
1: 
1:     /**
1:      * Used to identify the name of a durable subscription.
1:      * 
1:      * @openwire:property version=1
1:      */
0:     public String getSubcriptionName() {
0:         return subcriptionName;
1:     }
0:     public void setSubcriptionName(String durableSubscriptionId) {
0:         this.subcriptionName = durableSubscriptionId;
1:     }
1: 
1:     /**
0:      * Set noLocal to true to avoid receiving messages that were published locally on the same connection.
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public boolean isNoLocal() {
1:         return noLocal;
1:     }
1:     public void setNoLocal(boolean noLocal) {
1:         this.noLocal = noLocal;
1:     }
1: 
1:     /**
0:      * An exclusive consumer locks out other consumers from being able to receive messages
0:      * from the destination.  If there are multiple exclusive consumers for a destination, the first one
0:      * created will be the exclusive consumer of the destination.
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public boolean isExclusive() {
1:         return exclusive;
1:     }
1:     public void setExclusive(boolean exclusive) {
1:         this.exclusive = exclusive;
1:     }
1: 
1:     /**
0:      * A retroactive consumer only has meaning for Topics.  It allows a consumer
0:      * to retroactively see messages sent prior to the consumer being created.  If the 
0:      * consumer is not durable, it will be delivered the last message published to the topic.
0:      * If the consumer is durable then it will receive all persistent messages that are 
0:      * still stored in persistent storage for that topic.
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public boolean isRetroactive() {
1:         return retroactive;
1:     }
1:     public void setRetroactive(boolean retroactive) {
1:         this.retroactive = retroactive;
1:     }
1: 
1:     public RemoveInfo createRemoveCommand() {
1:         RemoveInfo command = new RemoveInfo(getConsumerId());
1:         command.setResponseRequired(isResponseRequired());
1:         return command;
1:     }
1: 
1:     /**
0:      * The broker will avoid dispatching to a lower priority consumer if there are other higher priority 
0:      * consumers available to dispatch to.  This allows letting the broker to have an affinity to 
0:      * higher priority consumers.  Default priority is 0.
1:      * 
1:      * @openwire:property version=1
1:      */
1:     public byte getPriority() {
1:         return priority;
1:     }
1:     public void setPriority(byte priority) {
1:         this.priority = priority;
1:     }
1: 
1:     /**
0:      * The route of brokers the command has moved through. 
1:      * 
1:      * @openwire:property version=1 cache=true
1:      */
1:     public BrokerId[] getBrokerPath() {
1:         return brokerPath;
1:     }
1:     public void setBrokerPath(BrokerId[] brokerPath) {
1:         this.brokerPath = brokerPath;
1:     }
1: 
1:     /**
0:      * A transient additional predicate that can be used it inject additional predicates
0:      * into the selector on the fly.  Handy if if say a Security Broker interceptor wants to 
0:      * filter out messages based on security level of the consumer.
1:      * 
0:      * @return
1:      */
1:     public BooleanExpression getAdditionalPredicate() {
1:         return additionalPredicate;
1:     }
1:     public void setAdditionalPredicate(BooleanExpression additionalPredicate) {
1:         this.additionalPredicate = additionalPredicate;
1:     }
1: 
0:     public Response visit(CommandVisitor visitor) throws Throwable {
0:         return visitor.processAddConsumer( this );
1:     }
1: 
1:     /**
1:      * @openwire:property version=1
1:      * @return Returns the networkSubscription.
1:      */
0:     public boolean isNetworkSubscription(){
1:         return networkSubscription;
1:     }
1: 
1:     /**
1:      * @param networkSubscription The networkSubscription to set.
1:      */
0:     public void setNetworkSubscription(boolean networkSubscription){
0:         this.networkSubscription=networkSubscription;
1:     }
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:0a7c5dc
/////////////////////////////////////////////////////////////////////////
0:     // overload; also used at runtime to track assignment of message groups
commit:3b08860
/////////////////////////////////////////////////////////////////////////
1:     // not marshalled, populated from RemoveInfo, the last message delivered, used
1:     // to suppress redelivery on prefetched messages after close
0:     private transient long lastDeliveredSequenceId;
0: 
/////////////////////////////////////////////////////////////////////////
1:     public void setLastDeliveredSequenceId(long lastDeliveredSequenceId) {
1:         this.lastDeliveredSequenceId  = lastDeliveredSequenceId;
1:     }
0:     
1:     public long getLastDeliveredSequenceId() {
1:         return lastDeliveredSequenceId;
1:     }
0: 
commit:301203e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tracks the original subscription id that causes a subscription to 
1:      * percolate through a network when networkTTL > 1. Tracking the original
1:      * subscription allows duplicate suppression.
0:      * 
1:      * @return array of the current subscription path
1:      * @openwire:property version=4
1:      */
1:     public ConsumerId[] getNetworkConsumerPath() {
1:         ConsumerId[] result = null;
1:         if (networkConsumerIds != null) {
1:             result = networkConsumerIds.toArray(new ConsumerId[0]);
1:         }
1:         return result;
1:     }
0:     
1:     public void setNetworkConsumerPath(ConsumerId[] consumerPath) {
1:         if (consumerPath != null) {
1:             for (int i=0; i<consumerPath.length; i++) {
1:                 addNetworkConsumerId(consumerPath[i]);
1:             }
1:         }
1:     }
0: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:6f2ac63
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0:      * Tracks the original subscription id that causes a subscription to
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:712254d
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected transient List<ConsumerId> networkConsumerIds; // the original consumerId
/////////////////////////////////////////////////////////////////////////
1:         info.networkSubscription = networkSubscription;
1:         if (networkConsumerIds != null) {
1:             if (info.networkConsumerIds==null){
1:                 info.networkConsumerIds=new ArrayList<ConsumerId>();
1:             }
1:             info.networkConsumerIds.addAll(networkConsumerIds);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public synchronized void addNetworkConsumerId(ConsumerId networkConsumerId) {
1:         if (networkConsumerIds == null) {
1:             networkConsumerIds = new ArrayList<ConsumerId>();
1:         }
1:         networkConsumerIds.add(networkConsumerId);
1:     }
0: 
1:     public synchronized void removeNetworkConsumerId(ConsumerId networkConsumerId) {
1:         if (networkConsumerIds != null) {
1:             networkConsumerIds.remove(networkConsumerId);
1:             if (networkConsumerIds.isEmpty()) {
1:                 networkConsumerIds=null;
1:             }
1:         }
1:     }
0:     
1:     public synchronized boolean isNetworkConsumersEmpty() {
1:         return networkConsumerIds == null || networkConsumerIds.isEmpty();
1:     }
0:     
1:     public synchronized List<ConsumerId> getNetworkConsumerIds(){
1:         List<ConsumerId> result = new ArrayList<ConsumerId>();
1:         if (networkConsumerIds != null) {
1:             result.addAll(networkConsumerIds);
1:         }
1:         return result;
1:     }
0: 
commit:6eaea6f
/////////////////////////////////////////////////////////////////////////
0:     protected transient int currentPrefetchSize;//used by the broker
/////////////////////////////////////////////////////////////////////////
1:         this.currentPrefetchSize = prefetchSize;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return Returns the currentPrefetchSize.
1:      */
0:     public int getCurrentPrefetchSize(){
1:         return currentPrefetchSize;
1:     }
0: 
1:     /**
1:      * @param currentPrefetchSize The currentPrefetchSize to set.
1:      */
0:     public void setCurrentPrefetchSize(int currentPrefetchSize){
0:         this.currentPrefetchSize=currentPrefetchSize;
1:     }
0: 
commit:ef0734b
/////////////////////////////////////////////////////////////////////////
1:     protected boolean optimizedAcknowledge;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      *  @openwire:property version=1
1:      * @return Returns the optimizedAcknowledge.
1:      */
0:     public boolean isOptimizedAcknowledge(){
1:         return optimizedAcknowledge;
0:     }
0: 
1:     /**
1:      * @param optimizedAcknowledge The optimizedAcknowledge to set.
1:      */
0:     public void setOptimizedAcknowledge(boolean optimizedAcknowledge){
0:         this.optimizedAcknowledge=optimizedAcknowledge;
0:     }
0: 
author:James Strachan
-------------------------------------------------------------------------------
commit:bed10aa
/////////////////////////////////////////////////////////////////////////
1:     protected int maximumPendingMessageLimit;
/////////////////////////////////////////////////////////////////////////
1:         info.maximumPendingMessageLimit = maximumPendingMessageLimit;
/////////////////////////////////////////////////////////////////////////
0:      * How many messages a broker will keep around, above the prefetch limit, for non-durable
0:      * topics before starting to discard older messages.
0:      * 
0:      * @openwire:property version=1
0:      */
1:     public int getMaximumPendingMessageLimit() {
1:         return maximumPendingMessageLimit;
0:     }
0: 
1:     public void setMaximumPendingMessageLimit(int maximumPendingMessageLimit) {
1:         this.maximumPendingMessageLimit = maximumPendingMessageLimit;
0:     }
0: 
0:     /**
commit:4afa5d6
/////////////////////////////////////////////////////////////////////////
1:  * @openwire:marshaller code="5"
============================================================================