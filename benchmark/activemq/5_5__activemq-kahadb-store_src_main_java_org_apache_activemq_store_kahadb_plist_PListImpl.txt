6:ee55abb: /**
1:ee55abb:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:ee55abb:  * contributor license agreements.  See the NOTICE file distributed with
1:ee55abb:  * this work for additional information regarding copyright ownership.
1:ee55abb:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:ee55abb:  * (the "License"); you may not use this file except in compliance with
1:ee55abb:  * the License.  You may obtain a copy of the License at
1:ee55abb:  *
1:ee55abb:  *      http://www.apache.org/licenses/LICENSE-2.0
1:ee55abb:  *
1:ee55abb:  * Unless required by applicable law or agreed to in writing, software
1:ee55abb:  * distributed under the License is distributed on an "AS IS" BASIS,
1:ee55abb:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ee55abb:  * See the License for the specific language governing permissions and
1:ee55abb:  * limitations under the License.
7:ee55abb:  */
1:ee55abb: package org.apache.activemq.store.kahadb.plist;
41:ee55abb: 
1:ee55abb: import java.io.DataInput;
1:ee55abb: import java.io.DataOutput;
1:ee55abb: import java.io.IOException;
1:2b10259: import java.util.Iterator;
1:2b10259: import java.util.Map;
1:734fb7d: import java.util.Map.Entry;
1:2b10259: import java.util.NoSuchElementException;
1:128a8f7: import java.util.Set;
1:ee55abb: import java.util.concurrent.atomic.AtomicBoolean;
1:ee55abb: import java.util.concurrent.atomic.AtomicReference;
1:030d09b: 
1:734fb7d: import org.apache.activemq.management.SizeStatisticImpl;
1:d5dd937: import org.apache.activemq.store.PList;
1:d5dd937: import org.apache.activemq.store.PListEntry;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.index.ListIndex;
1:734fb7d: import org.apache.activemq.store.kahadb.disk.index.ListNode;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.journal.Location;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.LocationMarshaller;
1:1aab71b: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
1:734fb7d: import org.apache.activemq.util.ByteSequence;
1:128a8f7: import org.slf4j.Logger;
1:128a8f7: import org.slf4j.LoggerFactory;
1:ee55abb: 
1:d5dd937: public class PListImpl extends ListIndex<String, Location> implements PList {
1:d5dd937:     static final Logger LOG = LoggerFactory.getLogger(PListImpl.class);
1:d5dd937:     final PListStoreImpl store;
1:ee55abb:     private String name;
1:cf7a935:     Object indexLock;
1:734fb7d:     private final SizeStatisticImpl messageSize;
1:ee55abb: 
1:d5dd937:     PListImpl(PListStoreImpl store) {
1:ee55abb:         this.store = store;
1:cf7a935:         this.indexLock = store.getIndexLock();
1:2b10259:         setPageFile(store.getPageFile());
1:2b10259:         setKeyMarshaller(StringMarshaller.INSTANCE);
1:2b10259:         setValueMarshaller(LocationMarshaller.INSTANCE);
1:734fb7d: 
1:734fb7d:         messageSize = new SizeStatisticImpl("messageSize", "The size in bytes of the pending messages");
1:734fb7d:         messageSize.setEnabled(true);
1:cf7a935:     }
1:cf7a935: 
1:ee55abb:     public void setName(String name) {
1:ee55abb:         this.name = name;
1:cf7a935:     }
1:ee55abb: 
1:734fb7d:     @Override
1:ee55abb:     public String getName() {
1:ee55abb:         return this.name;
1:cf7a935:     }
1:ee55abb: 
1:ee55abb:     void read(DataInput in) throws IOException {
1:bf59b7d:         setHeadPageId(in.readLong());
1:cf7a935:     }
1:ee55abb: 
1:ee55abb:     public void write(DataOutput out) throws IOException {
1:bf59b7d:         out.writeLong(getHeadPageId());
1:cf7a935:     }
1:ee55abb: 
1:d5dd937:     @Override
1:ee55abb:     public synchronized void destroy() throws IOException {
1:030d09b:         synchronized (indexLock) {
1:128a8f7:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                 @Override
1:128a8f7:                 public void execute(Transaction tx) throws IOException {
1:2b10259:                     clear(tx);
1:2b10259:                     unload(tx);
1:cf7a935:                 }
1:cf7a935:             });
1:cf7a935:         }
1:cf7a935:     }
1:cf7a935: 
1:32e63dc:     class Locator {
1:32e63dc:         final String id;
1:32e63dc: 
1:32e63dc:         Locator(String id) {
1:32e63dc:             this.id = id;
1:32e63dc:         }
1:32e63dc: 
1:32e63dc:         PListImpl plist() {
1:32e63dc:             return PListImpl.this;
1:32e63dc:         }
1:32e63dc:     }
1:32e63dc: 
1:d5dd937:     @Override
1:32e63dc:     public Object addLast(final String id, final ByteSequence bs) throws IOException {
1:2b10259:         final Location location = this.store.write(bs, false);
1:2b10259:         synchronized (indexLock) {
1:2b10259:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                 @Override
1:2b10259:                 public void execute(Transaction tx) throws IOException {
1:2b10259:                     add(tx, id, location);
1:2b10259:                 }
1:2b10259:             });
1:cf7a935:         }
1:32e63dc:         return new Locator(id);
1:cf7a935:     }
1:ee55abb: 
1:734fb7d:     @Override
1:32e63dc:     public Object addFirst(final String id, final ByteSequence bs) throws IOException {
1:2b10259:         final Location location = this.store.write(bs, false);
1:2b10259:         synchronized (indexLock) {
1:2b10259:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:d5dd937:                 @Override
1:2b10259:                 public void execute(Transaction tx) throws IOException {
1:2b10259:                     addFirst(tx, id, location);
1:2b10259:                 }
1:2b10259:             });
1:2b10259:         }
1:32e63dc:         return new Locator(id);
1:2b10259:     }
1:ee55abb: 
1:d5dd937:     @Override
1:32e63dc:     public boolean remove(final Object l) throws IOException {
1:32e63dc:         Locator locator = (Locator) l;
1:32e63dc:         assert locator!=null;
1:32e63dc:         assert locator.plist()==this;
1:32e63dc:         return remove(locator.id);
1:32e63dc:     }
1:32e63dc: 
1:2b10259:     public boolean remove(final String id) throws IOException {
1:2b10259:         final AtomicBoolean result = new AtomicBoolean();
1:2b10259:         synchronized (indexLock) {
1:2b10259:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                 @Override
1:2b10259:                 public void execute(Transaction tx) throws IOException {
1:2b10259:                     result.set(remove(tx, id) != null);
1:2b10259:                 }
1:2b10259:             });
1:2b10259:         }
1:2b10259:         return result.get();
1:2b10259:     }
1:2b10259: 
1:2b10259:     public boolean remove(final long position) throws IOException {
1:2b10259:         final AtomicBoolean result = new AtomicBoolean();
1:2b10259:         synchronized (indexLock) {
1:2b10259:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                 @Override
1:2b10259:                 public void execute(Transaction tx) throws IOException {
1:2b10259:                     Iterator<Map.Entry<String, Location>> iterator = iterator(tx, position);
1:2b10259:                     if (iterator.hasNext()) {
1:2b10259:                         iterator.next();
1:2b10259:                         iterator.remove();
1:2b10259:                         result.set(true);
1:2b10259:                     } else {
1:2b10259:                         result.set(false);
1:cf7a935:                     }
1:cf7a935:                 }
1:cf7a935:             });
1:cf7a935:         }
3:ee55abb:         return result.get();
1:cf7a935:     }
1:ee55abb: 
1:2b10259:     public PListEntry get(final long position) throws IOException {
5:ee55abb:         PListEntry result = null;
1:2b10259:         final AtomicReference<Map.Entry<String, Location>> ref = new AtomicReference<Map.Entry<String, Location>>();
1:cf7a935:         synchronized (indexLock) {
1:cf7a935:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                 @Override
1:cf7a935:                 public void execute(Transaction tx) throws IOException {
1:2b10259:                     Iterator<Map.Entry<String, Location>> iterator = iterator(tx, position);
1:2b10259:                     ref.set(iterator.next());
1:cf7a935:                 }
1:cf7a935:             });
1:cf7a935:         }
3:cf7a935:         if (ref.get() != null) {
1:2b10259:             ByteSequence bs = this.store.getPayload(ref.get().getValue());
1:32e63dc:             result = new PListEntry(ref.get().getKey(), bs, new Locator(ref.get().getKey()));
1:cf7a935:         }
1:cf7a935:         return result;
1:128a8f7:     }
1:128a8f7: 
1:2b10259:     public PListEntry getFirst() throws IOException {
1:cf7a935:         PListEntry result = null;
1:2b10259:         final AtomicReference<Map.Entry<String, Location>> ref = new AtomicReference<Map.Entry<String, Location>>();
1:128a8f7:         synchronized (indexLock) {
1:cf7a935:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                 @Override
1:cf7a935:                 public void execute(Transaction tx) throws IOException {
1:cf7a935:                     ref.set(getFirst(tx));
1:2b10259:                 }
1:128a8f7:             });
1:128a8f7:         }
1:2b10259:         if (ref.get() != null) {
1:2b10259:             ByteSequence bs = this.store.getPayload(ref.get().getValue());
1:32e63dc:             result = new PListEntry(ref.get().getKey(), bs, new Locator(ref.get().getKey()));
1:128a8f7:         }
1:cf7a935:         return result;
1:128a8f7:     }
1:cf7a935: 
1:2b10259:     public PListEntry getLast() throws IOException {
1:cf7a935:         PListEntry result = null;
1:2b10259:         final AtomicReference<Map.Entry<String, Location>> ref = new AtomicReference<Map.Entry<String, Location>>();
1:cf7a935:         synchronized (indexLock) {
1:cf7a935:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                 @Override
1:cf7a935:                 public void execute(Transaction tx) throws IOException {
1:cf7a935:                     ref.set(getLast(tx));
1:2b10259:                 }
4:cf7a935:             });
1:2b10259:         }
1:2b10259:         if (ref.get() != null) {
1:2b10259:             ByteSequence bs = this.store.getPayload(ref.get().getValue());
1:32e63dc:             result = new PListEntry(ref.get().getKey(), bs, new Locator(ref.get().getKey()));
1:128a8f7:         }
14:ee55abb:         return result;
1:cf7a935:     }
1:ee55abb: 
1:d5dd937:     @Override
1:2b10259:     public boolean isEmpty() {
1:2b10259:         return size() == 0;
1:2b10259:     }
1:2b10259: 
1:d5dd937:     @Override
1:bf59b7d:     public PListIterator iterator() throws IOException {
1:d5dd937:         return new PListIteratorImpl();
1:2b10259:     }
1:2b10259: 
1:d5dd937:     final class PListIteratorImpl implements PListIterator {
1:2b10259:         final Iterator<Map.Entry<String, Location>> iterator;
1:2b10259:         final Transaction tx;
1:2b10259: 
1:d5dd937:         PListIteratorImpl() throws IOException {
1:2b10259:             tx = store.pageFile.tx();
1:bf59b7d:             synchronized (indexLock) {
1:bf59b7d:                 this.iterator = iterator(tx);
1:bf59b7d:             }
1:2b10259:         }
1:2b10259: 
1:d5dd937:         @Override
1:2b10259:         public boolean hasNext() {
1:4bace21:             return iterator.hasNext();
1:030d09b:         }
1:2b10259: 
1:d5dd937:         @Override
1:2b10259:         public PListEntry next() {
1:2b10259:             Map.Entry<String, Location> entry = iterator.next();
1:2b10259:             ByteSequence bs = null;
1:2b10259:             try {
1:2b10259:                 bs = store.getPayload(entry.getValue());
1:2b10259:             } catch (IOException unexpected) {
1:2b10259:                 NoSuchElementException e = new NoSuchElementException(unexpected.getLocalizedMessage());
1:2b10259:                 e.initCause(unexpected);
1:2b10259:                 throw e;
1:2b10259:             }
1:32e63dc:             return new PListEntry(entry.getKey(), bs, new Locator(entry.getKey()));
1:2b10259:         }
1:bf59b7d: 
1:d5dd937:         @Override
1:2b10259:         public void remove() {
1:2b10259:             try {
1:2b10259:                 synchronized (indexLock) {
1:2b10259:                     tx.execute(new Transaction.Closure<IOException>() {
1:d5dd937:                         @Override
1:2b10259:                         public void execute(Transaction tx) throws IOException {
1:2b10259:                             iterator.remove();
1:2b10259:                         }
1:2b10259:                     });
1:2b10259:                 }
1:2b10259:             } catch (IOException unexpected) {
1:2b10259:                 IllegalStateException e = new IllegalStateException(unexpected);
1:2b10259:                 e.initCause(unexpected);
1:2b10259:                 throw e;
1:2b10259:             }
1:2b10259:         }
1:2b10259: 
1:d5dd937:         @Override
1:bf59b7d:         public void release() {
1:bf59b7d:             try {
1:bf59b7d:                 tx.rollback();
1:bf59b7d:             } catch (IOException unexpected) {
1:bf59b7d:                 IllegalStateException e = new IllegalStateException(unexpected);
1:bf59b7d:                 e.initCause(unexpected);
1:bf59b7d:                 throw e;
1:bf59b7d:             }
1:bf59b7d:         }
1:2b10259:     }
1:2b10259: 
1:2b10259:     public void claimFileLocations(final Set<Integer> candidates) throws IOException {
1:2b10259:         synchronized (indexLock) {
1:2b10259:             if (loaded.get()) {
4:cf7a935:                 this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:734fb7d:                     @Override
4:cf7a935:                     public void execute(Transaction tx) throws IOException {
1:2b10259:                         Iterator<Map.Entry<String,Location>> iterator = iterator(tx);
1:2b10259:                         while (iterator.hasNext()) {
1:2b10259:                             Location location = iterator.next().getValue();
1:2b10259:                             candidates.remove(location.getDataFileId());
1:cf7a935:                         }
1:cf7a935:                     }
1:2b10259:                 });
1:cf7a935:             }
1:cf7a935:         }
1:cf7a935:     }
1:ee55abb: 
1:d5dd937:     @Override
1:734fb7d:     public long messageSize() {
1:734fb7d:         return messageSize.getTotalSize();
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     public synchronized Location add(Transaction tx, String key, Location value)
1:734fb7d:             throws IOException {
1:734fb7d:         Location location = super.add(tx, key, value);
1:734fb7d:         messageSize.addSize(value.getSize());
1:734fb7d:         return location;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     public synchronized Location addFirst(Transaction tx, String key,
1:734fb7d:             Location value) throws IOException {
1:734fb7d:         Location location = super.addFirst(tx, key, value);
1:734fb7d:         messageSize.addSize(value.getSize());
1:734fb7d:         return location;
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     public synchronized void clear(Transaction tx) throws IOException {
1:734fb7d:         messageSize.reset();
1:734fb7d:         super.clear(tx);
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     protected synchronized void onLoad(ListNode<String, Location> node, Transaction tx) {
1:734fb7d:         try {
1:734fb7d:             Iterator<Entry<String, Location>> i = node.iterator(tx);
1:734fb7d:             while (i.hasNext()) {
1:734fb7d:                 messageSize.addSize(i.next().getValue().getSize());
1:734fb7d:             }
1:734fb7d:         } catch (IOException e) {
1:734fb7d:             LOG.warn("could not increment message size", e);
1:734fb7d:         }
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:734fb7d:     public void onRemove(Entry<String, Location> removed) {
1:734fb7d:         super.onRemove(removed);
1:d1dface:         if (removed != null) {
1:d1dface:             messageSize.addSize(-removed.getValue().getSize());
1:d1dface:         }
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:2b10259:     public String toString() {
1:bf59b7d:         return name + "[headPageId=" + getHeadPageId()  + ",tailPageId=" + getTailPageId() + ", size=" + size() + "]";
1:cf7a935:     }
1:f24edca: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:d1dface
/////////////////////////////////////////////////////////////////////////
1:         if (removed != null) {
1:             messageSize.addSize(-removed.getValue().getSize());
1:         }
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map.Entry;
1: import org.apache.activemq.management.SizeStatisticImpl;
1: import org.apache.activemq.store.kahadb.disk.index.ListNode;
1: import org.apache.activemq.util.ByteSequence;
/////////////////////////////////////////////////////////////////////////
1:     private final SizeStatisticImpl messageSize;
/////////////////////////////////////////////////////////////////////////
1: 
1:         messageSize = new SizeStatisticImpl("messageSize", "The size in bytes of the pending messages");
1:         messageSize.setEnabled(true);
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:     public long messageSize() {
1:         return messageSize.getTotalSize();
1:     }
1: 
1:     @Override
1:     public synchronized Location add(Transaction tx, String key, Location value)
1:             throws IOException {
1:         Location location = super.add(tx, key, value);
1:         messageSize.addSize(value.getSize());
1:         return location;
1:     }
1: 
1:     @Override
1:     public synchronized Location addFirst(Transaction tx, String key,
1:             Location value) throws IOException {
1:         Location location = super.addFirst(tx, key, value);
1:         messageSize.addSize(value.getSize());
1:         return location;
1:     }
1: 
1:     @Override
1:     public synchronized void clear(Transaction tx) throws IOException {
1:         messageSize.reset();
1:         super.clear(tx);
1:     }
1: 
1:     @Override
1:     protected synchronized void onLoad(ListNode<String, Location> node, Transaction tx) {
1:         try {
1:             Iterator<Entry<String, Location>> i = node.iterator(tx);
1:             while (i.hasNext()) {
1:                 messageSize.addSize(i.next().getValue().getSize());
1:             }
1:         } catch (IOException e) {
1:             LOG.warn("could not increment message size", e);
1:         }
1:     }
1: 
1:     @Override
1:     public void onRemove(Entry<String, Location> removed) {
1:         super.onRemove(removed);
0:         messageSize.addSize(-removed.getValue().getSize());
1:     }
1: 
1:     @Override
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:32e63dc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.MessageReference;
0: import org.apache.activemq.command.Message;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     class Locator {
1:         final String id;
1: 
1:         Locator(String id) {
1:             this.id = id;
1:         }
1: 
1:         PListImpl plist() {
1:             return PListImpl.this;
1:         }
1:     }
1: 
1:     public Object addLast(final String id, final ByteSequence bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         return new Locator(id);
1:     public Object addFirst(final String id, final ByteSequence bs) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         return new Locator(id);
1:     public boolean remove(final Object l) throws IOException {
1:         Locator locator = (Locator) l;
1:         assert locator!=null;
1:         assert locator.plist()==this;
1:         return remove(locator.id);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             result = new PListEntry(ref.get().getKey(), bs, new Locator(ref.get().getKey()));
/////////////////////////////////////////////////////////////////////////
1:             result = new PListEntry(ref.get().getKey(), bs, new Locator(ref.get().getKey()));
/////////////////////////////////////////////////////////////////////////
1:             result = new PListEntry(ref.get().getKey(), bs, new Locator(ref.get().getKey()));
/////////////////////////////////////////////////////////////////////////
1:             return new PListEntry(entry.getKey(), bs, new Locator(entry.getKey()));
commit:c5cf038
commit:d5dd937
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.PList;
1: import org.apache.activemq.store.PListEntry;
/////////////////////////////////////////////////////////////////////////
1: public class PListImpl extends ListIndex<String, Location> implements PList {
1:     static final Logger LOG = LoggerFactory.getLogger(PListImpl.class);
1:     final PListStoreImpl store;
1:     PListImpl(PListStoreImpl store) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:         return new PListIteratorImpl();
1:     final class PListIteratorImpl implements PListIterator {
1:         PListIteratorImpl() throws IOException {
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.index.ListIndex;
1: import org.apache.activemq.store.kahadb.disk.journal.Location;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
0: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.store.kahadb.disk.util.LocationMarshaller;
1: import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4bace21
/////////////////////////////////////////////////////////////////////////
1:             return iterator.hasNext();
commit:030d09b
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             synchronized (indexLock) {
0:                 return iterator.hasNext();
1:             }
author:Gary Tully
-------------------------------------------------------------------------------
commit:bf59b7d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         setHeadPageId(in.readLong());
1:         out.writeLong(getHeadPageId());
/////////////////////////////////////////////////////////////////////////
1:     public PListIterator iterator() throws IOException {
0:     public final class PListIterator implements Iterator<PListEntry> {
1:             synchronized (indexLock) {
1:                 this.iterator = iterator(tx);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1:         public void release() {
1:             try {
1:                 tx.rollback();
1:             } catch (IOException unexpected) {
1:                 IllegalStateException e = new IllegalStateException(unexpected);
1:                 e.initCause(unexpected);
1:                 throw e;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return name + "[headPageId=" + getHeadPageId()  + ",tailPageId=" + getTailPageId() + ", size=" + size() + "]";
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
1: import java.util.Map;
1: import java.util.NoSuchElementException;
0: import org.apache.kahadb.index.ListIndex;
0: import org.apache.kahadb.index.ListNode;
0: import org.apache.kahadb.util.LocationMarshaller;
0: import org.apache.kahadb.util.StringMarshaller;
0: public class PList extends ListIndex<String, Location> {
1:         setPageFile(store.getPageFile());
1:         setKeyMarshaller(StringMarshaller.INSTANCE);
1:         setValueMarshaller(LocationMarshaller.INSTANCE);
0:         this.headPageId = in.readLong();
0:         out.writeLong(this.headPageId);
1:                     clear(tx);
1:                     unload(tx);
0:     public void addLast(final String id, final ByteSequence bs) throws IOException {
1:         final Location location = this.store.write(bs, false);
1:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     add(tx, id, location);
1:                 }
1:             });
0:     public void addFirst(final String id, final ByteSequence bs) throws IOException {
1:         final Location location = this.store.write(bs, false);
1:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     addFirst(tx, id, location);
1:                 }
1:             });
1:         }
1:     }
1:     public boolean remove(final String id) throws IOException {
1:         final AtomicBoolean result = new AtomicBoolean();
1:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     result.set(remove(tx, id) != null);
1:                 }
1:             });
1:         }
1:         return result.get();
1:     }
1: 
1:     public boolean remove(final long position) throws IOException {
1:         final AtomicBoolean result = new AtomicBoolean();
1:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
1:                     Iterator<Map.Entry<String, Location>> iterator = iterator(tx, position);
1:                     if (iterator.hasNext()) {
1:                         iterator.next();
1:                         iterator.remove();
1:                         result.set(true);
1:                     } else {
1:                         result.set(false);
1:     public PListEntry get(final long position) throws IOException {
1:         final AtomicReference<Map.Entry<String, Location>> ref = new AtomicReference<Map.Entry<String, Location>>();
1:                     Iterator<Map.Entry<String, Location>> iterator = iterator(tx, position);
1:                     ref.set(iterator.next());
1:             ByteSequence bs = this.store.getPayload(ref.get().getValue());
0:             result = new PListEntry(ref.get().getKey(), bs);
1:     public PListEntry getFirst() throws IOException {
1:         final AtomicReference<Map.Entry<String, Location>> ref = new AtomicReference<Map.Entry<String, Location>>();
1:         }
1:         if (ref.get() != null) {
1:             ByteSequence bs = this.store.getPayload(ref.get().getValue());
0:             result = new PListEntry(ref.get().getKey(), bs);
1:     public PListEntry getLast() throws IOException {
1:         final AtomicReference<Map.Entry<String, Location>> ref = new AtomicReference<Map.Entry<String, Location>>();
1:         }
1:         if (ref.get() != null) {
1:             ByteSequence bs = this.store.getPayload(ref.get().getValue());
0:             result = new PListEntry(ref.get().getKey(), bs);
1:     public boolean isEmpty() {
1:         return size() == 0;
1:     }
1: 
0:     synchronized public Iterator<PListEntry> iterator() throws IOException {
0:         return new PListIterator();
1:     }
1: 
0:     private final class PListIterator implements Iterator<PListEntry> {
1:         final Iterator<Map.Entry<String, Location>> iterator;
1:         final Transaction tx;
1: 
0:         PListIterator() throws IOException {
1:             tx = store.pageFile.tx();
0:             this.iterator = iterator(tx);
1:         }
1: 
0:         @Override
1:         public boolean hasNext() {
0:             return iterator.hasNext();
1:         }
1: 
0:         @Override
1:         public PListEntry next() {
1:             Map.Entry<String, Location> entry = iterator.next();
1:             ByteSequence bs = null;
1:             try {
1:                 bs = store.getPayload(entry.getValue());
1:             } catch (IOException unexpected) {
1:                 NoSuchElementException e = new NoSuchElementException(unexpected.getLocalizedMessage());
1:                 e.initCause(unexpected);
1:                 throw e;
1:             }
0:             return new PListEntry(entry.getKey(), bs);
1:         }
1: 
0:         @Override
1:         public void remove() {
1:             try {
1:                 synchronized (indexLock) {
1:                     tx.execute(new Transaction.Closure<IOException>() {
0:                         @Override
1:                         public void execute(Transaction tx) throws IOException {
1:                             iterator.remove();
1:                         }
1:                     });
1:                 }
1:             } catch (IOException unexpected) {
1:                 IllegalStateException e = new IllegalStateException(unexpected);
1:                 e.initCause(unexpected);
1:                 throw e;
1:             }
1:         }
1:     }
1: 
1:     public void claimFileLocations(final Set<Integer> candidates) throws IOException {
1:         synchronized (indexLock) {
1:             if (loaded.get()) {
1:                         Iterator<Map.Entry<String,Location>> iterator = iterator(tx);
1:                         while (iterator.hasNext()) {
1:                             Location location = iterator.next().getValue();
1:                             candidates.remove(location.getDataFileId());
1:                 });
0:     @Override
1:     public String toString() {
0:         return "" + name + ",[headPageId=" + headPageId  + ",tailPageId=" + tailPageId + ", size=" + size() + "]";
commit:128a8f7
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0:     static final Logger LOG = LoggerFactory.getLogger(PList.class);
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void claimFileLocations(final Set<Integer> candidates) throws IOException {
1:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     long nextId = rootId;
0:                     while (nextId != EntryLocation.NOT_SET) {
0:                         EntryLocation entry = getNext(tx, nextId);
0:                         if (entry != null) {
0:                             candidates.remove(entry.getLocation().getDataFileId());
0:                             nextId = entry.getNext();
0:                         } else {
0:                             break;
1:                         }
1:                     }
1:                 }
1:             });
1:         }
1:     }
1: 
commit:0619a87
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cf7a935
/////////////////////////////////////////////////////////////////////////
1:     Object indexLock;
1:         this.indexLock = store.getIndexLock();
/////////////////////////////////////////////////////////////////////////
1:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     destroy(tx);
1:                 }
1:             });
1:         }
/////////////////////////////////////////////////////////////////////////
0:         final Location location = this.store.write(bs, false);
1:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     addLast(tx, id, bs, location);
1:                 }
1:             });
1:         }
0:     private void addLast(Transaction tx, String id, ByteSequence bs, Location location) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         final Location location = this.store.write(bs, false);
0:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     addFirst(tx, id, bs, location);
1:                 }
1:             });
1:         }
0:     private void addFirst(Transaction tx, String id, ByteSequence bs, Location location) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     result.set(remove(tx, id));
1:                 }
1:             });
1:         }
0:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     result.set(remove(tx, position));
1:                 }
1:             });
1:         }
0:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     result.set(doRemove(tx, entry.getEntry()));
1:                 }
1:             });
1:         }
0:         synchronized (indexLock) {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 public void execute(Transaction tx) throws IOException {
0:                     ref.set(get(tx, position));
1:                 }
1:             });
1:         }
/////////////////////////////////////////////////////////////////////////
0:         synchronized (indexLock) {
1:                     ref.set(getFirst(tx));
/////////////////////////////////////////////////////////////////////////
0:     synchronized public PListEntry getLast() throws IOException {
1:         PListEntry result = null;
0:         final AtomicReference<EntryLocation> ref = new AtomicReference<EntryLocation>();
0:         synchronized (indexLock) {
0:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:                 public void execute(Transaction tx) throws IOException {
1:                     ref.set(getLast(tx));
1:                 }
0:             });
1:             if (ref.get() != null) {
0:                 ByteSequence bs = this.store.getPayload(ref.get().getLocation());
0:                 result = new PListEntry(ref.get(), bs);
1:             }
1:         }
1:         return result;
1:     }
1: 
0:     synchronized public PListEntry getNext(PListEntry entry) throws IOException {
1:         PListEntry result = null;
0:         final long nextId = entry != null ? entry.getEntry().getNext() : this.rootId;
0:         if (nextId != EntryLocation.NOT_SET) {
0:             final AtomicReference<EntryLocation> ref = new AtomicReference<EntryLocation>();
0:             synchronized (indexLock) {
0:                 this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:                     public void execute(Transaction tx) throws IOException {
0:                         ref.set(getNext(tx, nextId));
1:                     }
0:                 });
1:                 if (ref.get() != null) {
0:                     ByteSequence bs = this.store.getPayload(ref.get().getLocation());
0:                     result = new PListEntry(ref.get(), bs);
1:                 }
1:             }
1:         }
1:         return result;
1:     }
1: 
0:         synchronized (indexLock) {
0:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:                 public void execute(Transaction tx) throws IOException {
0:                     ref.set(loadEntry(tx, entry.getEntry().getPage().getPageId()));
1:                 }
0:             });
1:             if (ref.get() != null) {
0:                 result = new PListEntry(ref.get(), entry.getByteSequence());
/////////////////////////////////////////////////////////////////////////
0:     private boolean doRemove(Transaction tx, EntryLocation entry) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     
commit:f24edca
/////////////////////////////////////////////////////////////////////////
0:                 nextId = entry.getNext();
0:             } else {
0:                 // not found
0:                 break;
/////////////////////////////////////////////////////////////////////////
0:                 nextId = entry.getNext();
0:             } else {
0:                 // not found
0:                 break;
/////////////////////////////////////////////////////////////////////////
0:         if (entry != null) {
0:             entry.setPage(page);
1:         }
commit:af31f2d
/////////////////////////////////////////////////////////////////////////
0:         EntryLocation entry = getFirst(tx);
0:             entry = getNext(tx, entry.getNext());
author:Robert Davies
-------------------------------------------------------------------------------
commit:d71eefc
/////////////////////////////////////////////////////////////////////////
0:             this.rootId = EntryLocation.NOT_SET;
0:             this.lastId = EntryLocation.NOT_SET;
0:             this.size=0;
commit:ee55abb
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.store.kahadb.plist;
1: 
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicReference;
0: import org.apache.activemq.store.kahadb.plist.EntryLocation.EntryLocationMarshaller;
0: import org.apache.kahadb.journal.Location;
0: import org.apache.kahadb.page.Page;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.util.ByteSequence;
1: 
0: public class PList {
0:     final PListStore store;
1:     private String name;
0:     private long rootId = EntryLocation.NOT_SET;
0:     private long lastId = EntryLocation.NOT_SET;
0:     private final AtomicBoolean loaded = new AtomicBoolean();
0:     private int size = 0;
1: 
0:     PList(PListStore store) {
1: 
1:         this.store = store;
0:     }
1: 
1:     public void setName(String name) {
1:         this.name = name;
0:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see org.apache.activemq.beanstalk.JobScheduler#getName()
1:      */
1:     public String getName() {
1:         return this.name;
0:     }
1: 
0:     public synchronized int size() {
0:         return this.size;
0:     }
1: 
0:     public synchronized boolean isEmpty() {
0:         return size == 0;
0:     }
1: 
1:     /**
0:      * @return the rootId
1:      */
0:     public long getRootId() {
0:         return this.rootId;
0:     }
1: 
1:     /**
0:      * @param rootId
0:      *            the rootId to set
1:      */
0:     public void setRootId(long rootId) {
0:         this.rootId = rootId;
0:     }
1: 
1:     /**
0:      * @return the lastId
1:      */
0:     public long getLastId() {
0:         return this.lastId;
0:     }
1: 
1:     /**
0:      * @param lastId
0:      *            the lastId to set
1:      */
0:     public void setLastId(long lastId) {
0:         this.lastId = lastId;
0:     }
1: 
1:     /**
0:      * @return the loaded
1:      */
0:     public boolean isLoaded() {
0:         return this.loaded.get();
0:     }
1: 
1:     void read(DataInput in) throws IOException {
0:         this.rootId = in.readLong();
0:         this.name = in.readUTF();
0:     }
1: 
1:     public void write(DataOutput out) throws IOException {
0:         out.writeLong(this.rootId);
0:         out.writeUTF(name);
0:     }
1: 
1:     public synchronized void destroy() throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 destroy(tx);
0:             }
0:         });
0:     }
1: 
0:     void destroy(Transaction tx) throws IOException {
0:         // start from the first
0:         EntryLocation entry = loadEntry(tx, getRoot(tx).getNext());
0:         while (entry != null) {
0:             EntryLocation toRemove = entry.copy();
0:             entry = loadEntry(tx, entry.getNext());
0:             doRemove(tx, toRemove);
0:         }
0:     }
1: 
0:     synchronized void load(Transaction tx) throws IOException {
0:         if (loaded.compareAndSet(false, true)) {
0:             final Page<EntryLocation> p = tx.load(this.rootId, null);
0:             if (p.getType() == Page.PAGE_FREE_TYPE) {
0:                 // Need to initialize it..
0:                 EntryLocation root = createEntry(p, "root", EntryLocation.NOT_SET, EntryLocation.NOT_SET);
1: 
0:                 storeEntry(tx, root);
0:                 this.lastId = root.getPage().getPageId();
0:             } else {
0:                 // find last id
0:                 long nextId = this.rootId;
0:                 while (nextId != EntryLocation.NOT_SET) {
0:                     EntryLocation next = getNext(tx, nextId);
0:                     if (next != null) {
0:                         this.lastId = next.getPage().getPageId();
0:                         nextId = next.getNext();
0:                         this.size++;
0:                     }
0:                 }
0:             }
0:         }
0:     }
1: 
0:     synchronized public void unload() {
0:         if (loaded.compareAndSet(true, false)) {
0:         }
0:     }
1: 
0:     synchronized public void addLast(final String id, final ByteSequence bs) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 addLast(tx, id, bs);
0:             }
0:         });
0:     }
1: 
0:     void addLast(Transaction tx, String id, ByteSequence bs) throws IOException {
0:         Location location = this.store.write(bs, false);
0:         EntryLocation entry = createEntry(tx, id, this.lastId, EntryLocation.NOT_SET);
0:         entry.setLocation(location);
0:         storeEntry(tx, entry);
0:         this.store.incrementJournalCount(tx, location);
1: 
0:         EntryLocation last = loadEntry(tx, this.lastId);
0:         last.setNext(entry.getPage().getPageId());
0:         storeEntry(tx, last);
0:         this.lastId = entry.getPage().getPageId();
0:         this.size++;
0:     }
1: 
0:     synchronized public void addFirst(final String id, final ByteSequence bs) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 addFirst(tx, id, bs);
0:             }
0:         });
0:     }
1: 
0:     void addFirst(Transaction tx, String id, ByteSequence bs) throws IOException {
0:         Location location = this.store.write(bs, false);
0:         EntryLocation entry = createEntry(tx, id, EntryLocation.NOT_SET, EntryLocation.NOT_SET);
0:         entry.setLocation(location);
0:         EntryLocation oldFirst = getFirst(tx);
0:         if (oldFirst != null) {
0:             oldFirst.setPrev(entry.getPage().getPageId());
0:             storeEntry(tx, oldFirst);
0:             entry.setNext(oldFirst.getPage().getPageId());
1: 
0:         }
0:         EntryLocation root = getRoot(tx);
0:         root.setNext(entry.getPage().getPageId());
0:         storeEntry(tx, root);
0:         storeEntry(tx, entry);
1: 
0:         this.store.incrementJournalCount(tx, location);
0:         this.size++;
0:     }
1: 
0:     synchronized public boolean remove(final String id) throws IOException {
0:         final AtomicBoolean result = new AtomicBoolean();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 result.set(remove(tx, id));
0:             }
0:         });
1:         return result.get();
0:     }
1: 
0:     synchronized public boolean remove(final int position) throws IOException {
0:         final AtomicBoolean result = new AtomicBoolean();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 result.set(remove(tx, position));
0:             }
0:         });
1:         return result.get();
0:     }
1: 
0:     synchronized public boolean remove(final PListEntry entry) throws IOException {
0:         final AtomicBoolean result = new AtomicBoolean();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 result.set(doRemove(tx, entry.getEntry()));
0:             }
0:         });
1:         return result.get();
0:     }
1: 
0:     synchronized public PListEntry get(final int position) throws IOException {
1:         PListEntry result = null;
0:         final AtomicReference<EntryLocation> ref = new AtomicReference<EntryLocation>();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 ref.set(get(tx, position));
0:             }
0:         });
0:         if (ref.get() != null) {
0:             ByteSequence bs = this.store.getPayload(ref.get().getLocation());
0:             result = new PListEntry(ref.get(), bs);
0:         }
1:         return result;
0:     }
1: 
0:     synchronized public PListEntry getFirst() throws IOException {
1:         PListEntry result = null;
0:         final AtomicReference<EntryLocation> ref = new AtomicReference<EntryLocation>();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 ref.set(getFirst(tx));
0:             }
0:         });
0:         if (ref.get() != null) {
0:             ByteSequence bs = this.store.getPayload(ref.get().getLocation());
0:             result = new PListEntry(ref.get(), bs);
0:         }
1:         return result;
0:     }
1: 
0:     synchronized public PListEntry getLast() throws IOException {
1:         PListEntry result = null;
0:         final AtomicReference<EntryLocation> ref = new AtomicReference<EntryLocation>();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 ref.set(getLast(tx));
0:             }
0:         });
0:         if (ref.get() != null) {
0:             ByteSequence bs = this.store.getPayload(ref.get().getLocation());
0:             result = new PListEntry(ref.get(), bs);
0:         }
1:         return result;
0:     }
1: 
0:     synchronized public PListEntry getNext(PListEntry entry) throws IOException {
1:         PListEntry result = null;
0:         final long nextId = entry != null ? entry.getEntry().getNext() : this.rootId;
0:         if (nextId != EntryLocation.NOT_SET) {
0:             final AtomicReference<EntryLocation> ref = new AtomicReference<EntryLocation>();
0:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:                 public void execute(Transaction tx) throws IOException {
0:                     ref.set(getNext(tx, nextId));
0:                 }
0:             });
0:             if (ref.get() != null) {
0:                 ByteSequence bs = this.store.getPayload(ref.get().getLocation());
0:                 result = new PListEntry(ref.get(), bs);
0:             }
0:         }
1:         return result;
0:     }
1: 
0:     synchronized public PListEntry refresh(final PListEntry entry) throws IOException {
1:         PListEntry result = null;
0:         final AtomicReference<EntryLocation> ref = new AtomicReference<EntryLocation>();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 ref.set(loadEntry(tx, entry.getEntry().getPage().getPageId()));
0:             }
0:         });
0:         if (ref.get() != null) {
1: 
0:             result = new PListEntry(ref.get(), entry.getByteSequence());
0:         }
1:         return result;
0:     }
1: 
0:     boolean remove(Transaction tx, String id) throws IOException {
0:         boolean result = false;
0:         long nextId = this.rootId;
0:         while (nextId != EntryLocation.NOT_SET) {
0:             EntryLocation entry = getNext(tx, nextId);
0:             if (entry != null) {
0:                 if (entry.getId().equals(id)) {
0:                     result = doRemove(tx, entry);
0:                     break;
0:                 }
0:             }
0:         }
1:         return result;
0:     }
1: 
0:     boolean remove(Transaction tx, int position) throws IOException {
0:         boolean result = false;
0:         long nextId = this.rootId;
0:         int count = 0;
0:         while (nextId != EntryLocation.NOT_SET) {
0:             EntryLocation entry = getNext(tx, nextId);
0:             if (entry != null) {
0:                 if (count == position) {
0:                     result = doRemove(tx, entry);
0:                     break;
0:                 }
0:             }
0:             count++;
0:         }
1:         return result;
0:     }
1: 
0:     EntryLocation get(Transaction tx, int position) throws IOException {
0:         EntryLocation result = null;
0:         long nextId = this.rootId;
0:         int count = -1;
0:         while (nextId != EntryLocation.NOT_SET) {
0:             EntryLocation entry = getNext(tx, nextId);
0:             if (entry != null) {
0:                 if (count == position) {
0:                     result = entry;
0:                     break;
0:                 }
0:                 nextId = entry.getNext();
0:             } else {
0:                 break;
0:             }
0:             count++;
0:         }
1:         return result;
0:     }
1: 
0:     EntryLocation getFirst(Transaction tx) throws IOException {
0:         long offset = getRoot(tx).getNext();
0:         if (offset != EntryLocation.NOT_SET) {
0:             return loadEntry(tx, offset);
0:         }
0:         return null;
0:     }
1: 
0:     EntryLocation getLast(Transaction tx) throws IOException {
0:         if (this.lastId != EntryLocation.NOT_SET) {
0:             return loadEntry(tx, this.lastId);
0:         }
0:         return null;
0:     }
1: 
0:     boolean doRemove(Transaction tx, EntryLocation entry) throws IOException {
0:         boolean result = false;
0:         if (entry != null) {
1: 
0:             EntryLocation prev = getPrevious(tx, entry.getPrev());
0:             EntryLocation next = getNext(tx, entry.getNext());
0:             long prevId = prev != null ? prev.getPage().getPageId() : this.rootId;
0:             long nextId = next != null ? next.getPage().getPageId() : EntryLocation.NOT_SET;
1: 
0:             if (next != null) {
0:                 next.setPrev(prevId);
0:                 storeEntry(tx, next);
0:             } else {
0:                 // we are deleting the last one in the list
0:                 this.lastId = prevId;
0:             }
0:             if (prev != null) {
0:                 prev.setNext(nextId);
0:                 storeEntry(tx, prev);
0:             }
1: 
0:             this.store.decrementJournalCount(tx, entry.getLocation());
0:             entry.reset();
0:             storeEntry(tx, entry);
0:             tx.free(entry.getPage().getPageId());
0:             result = true;
0:             this.size--;
0:         }
1:         return result;
0:     }
1: 
0:     private EntryLocation createEntry(Transaction tx, String id, long previous, long next) throws IOException {
0:         Page<EntryLocation> p = tx.allocate();
0:         EntryLocation result = new EntryLocation();
0:         result.setPage(p);
0:         p.set(result);
0:         result.setId(id);
0:         result.setPrev(previous);
0:         result.setNext(next);
1:         return result;
0:     }
1: 
0:     private EntryLocation createEntry(Page<EntryLocation> p, String id, long previous, long next) throws IOException {
0:         EntryLocation result = new EntryLocation();
0:         result.setPage(p);
0:         p.set(result);
0:         result.setId(id);
0:         result.setPrev(previous);
0:         result.setNext(next);
1:         return result;
0:     }
1: 
0:     EntryLocation loadEntry(Transaction tx, long pageId) throws IOException {
0:         Page<EntryLocation> page = tx.load(pageId, EntryLocationMarshaller.INSTANCE);
0:         EntryLocation entry = page.get();
0:         entry.setPage(page);
0:         return entry;
0:     }
0:     private void storeEntry(Transaction tx, EntryLocation entry) throws IOException {
0:         tx.store(entry.getPage(), EntryLocationMarshaller.INSTANCE, true);
0:     }
1: 
0:     EntryLocation getNext(Transaction tx, long next) throws IOException {
0:         EntryLocation result = null;
0:         if (next != EntryLocation.NOT_SET) {
0:             result = loadEntry(tx, next);
0:         }
1:         return result;
0:     }
1: 
0:     private EntryLocation getPrevious(Transaction tx, long previous) throws IOException {
0:         EntryLocation result = null;
0:         if (previous != EntryLocation.NOT_SET) {
0:             result = loadEntry(tx, previous);
0:         }
1:         return result;
0:     }
1: 
0:     private EntryLocation getRoot(Transaction tx) throws IOException {
0:         EntryLocation result = loadEntry(tx, this.rootId);
1:         return result;
0:     }
1: 
0:     ByteSequence getPayload(EntryLocation entry) throws IOException {
0:         return this.store.getPayload(entry.getLocation());
0:     }
0: }
============================================================================