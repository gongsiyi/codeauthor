1:da3b138: /*
1:da3b138:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:da3b138:  * contributor license agreements.  See the NOTICE file distributed with
1:da3b138:  * this work for additional information regarding copyright ownership.
1:da3b138:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:da3b138:  * (the "License"); you may not use this file except in compliance with
1:da3b138:  * the License.  You may obtain a copy of the License at
4:da3b138:  *
1:da3b138:  *      http://www.apache.org/licenses/LICENSE-2.0
1:da3b138:  *
1:da3b138:  * Unless required by applicable law or agreed to in writing, software
1:da3b138:  * distributed under the License is distributed on an "AS IS" BASIS,
1:da3b138:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:da3b138:  * See the License for the specific language governing permissions and
1:da3b138:  * limitations under the License.
1:da3b138:  */
1:da3b138: package org.apache.activemq.junit;
4:da3b138: 
1:44a318b: import static org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE;
1:44a318b: 
1:bab4a92: import java.io.Serializable;
1:da3b138: import java.net.URI;
1:bab4a92: import java.net.URISyntaxException;
1:bab4a92: import java.util.Map;
1:44a318b: 
1:bab4a92: import javax.jms.BytesMessage;
1:bab4a92: import javax.jms.Connection;
1:bab4a92: import javax.jms.JMSException;
1:bab4a92: import javax.jms.MapMessage;
1:bab4a92: import javax.jms.Message;
1:bab4a92: import javax.jms.MessageProducer;
1:bab4a92: import javax.jms.ObjectMessage;
1:bab4a92: import javax.jms.Session;
1:bab4a92: import javax.jms.StreamMessage;
1:bab4a92: import javax.jms.TextMessage;
1:da3b138: 
1:da3b138: import org.apache.activemq.ActiveMQConnectionFactory;
1:da3b138: import org.apache.activemq.broker.BrokerFactory;
1:da3b138: import org.apache.activemq.broker.BrokerPlugin;
1:da3b138: import org.apache.activemq.broker.BrokerService;
1:da3b138: import org.apache.activemq.broker.region.Destination;
1:da3b138: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:da3b138: import org.apache.activemq.broker.region.policy.PolicyMap;
1:bab4a92: import org.apache.activemq.command.ActiveMQDestination;
1:da3b138: import org.apache.activemq.plugin.StatisticsBrokerPlugin;
1:da3b138: import org.apache.activemq.pool.PooledConnectionFactory;
1:da3b138: import org.junit.rules.ExternalResource;
1:da3b138: import org.slf4j.Logger;
1:da3b138: import org.slf4j.LoggerFactory;
1:bab4a92: 
1:da3b138: /**
1:da3b138:  * A JUnit Rule that embeds an ActiveMQ broker into a test.
1:da3b138:  */
1:da3b138: public class EmbeddedActiveMQBroker extends ExternalResource {
1:da3b138:     Logger log = LoggerFactory.getLogger(this.getClass());
1:da3b138: 
1:da3b138:     BrokerService brokerService;
1:bab4a92:     InternalClient internalClient;
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Create an embedded ActiveMQ broker using defaults
1:bab4a92:      * <p>
1:da3b138:      * The defaults are:
1:bab4a92:      * - the broker name is 'embedded-broker'
1:44a318b:      * - JMX is enable but no management connector is created.
1:bab4a92:      * - Persistence is disabled
1:da3b138:      */
1:da3b138:     public EmbeddedActiveMQBroker() {
1:da3b138:         brokerService = new BrokerService();
1:44a318b:         brokerService.setUseJmx(true);
1:44a318b:         brokerService.getManagementContext().setCreateConnector(false);
1:da3b138:         brokerService.setUseShutdownHook(false);
1:da3b138:         brokerService.setPersistent(false);
1:da3b138:         brokerService.setBrokerName("embedded-broker");
6:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Create an embedded ActiveMQ broker using a configuration URI
1:da3b138:      */
1:bab4a92:     public EmbeddedActiveMQBroker(String configurationURI) {
1:da3b138:         try {
1:da3b138:             brokerService = BrokerFactory.createBroker(configurationURI);
1:da3b138:         } catch (Exception ex) {
1:da3b138:             throw new RuntimeException("Exception encountered creating embedded ActiveMQ broker from configuration URI: " + configurationURI, ex);
1:da3b138:         }
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Create an embedded ActiveMQ broker using a configuration URI
1:da3b138:      */
1:bab4a92:     public EmbeddedActiveMQBroker(URI configurationURI) {
1:da3b138:         try {
1:da3b138:             brokerService = BrokerFactory.createBroker(configurationURI);
1:da3b138:         } catch (Exception ex) {
1:da3b138:             throw new RuntimeException("Exception encountered creating embedded ActiveMQ broker from configuration URI: " + configurationURI, ex);
1:da3b138:         }
1:da3b138:     }
1:da3b138: 
1:bab4a92:     public static void setMessageProperties(Message message, Map<String, Object> properties) {
1:bab4a92:         if (properties != null && properties.size() > 0) {
1:bab4a92:             for (Map.Entry<String, Object> property : properties.entrySet()) {
1:bab4a92:                 try {
1:bab4a92:                     message.setObjectProperty(property.getKey(), property.getValue());
1:bab4a92:                 } catch (JMSException jmsEx) {
1:bab4a92:                     throw new EmbeddedActiveMQBrokerException(String.format("Failed to set property {%s = %s}", property.getKey(), property.getValue().toString()), jmsEx);
1:bab4a92:                 }
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92:     }
1:bab4a92: 
1:da3b138:     /**
1:da3b138:      * Customize the configuration of the embedded ActiveMQ broker
1:bab4a92:      * <p>
1:da3b138:      * This method is called before the embedded ActiveMQ broker is started, and can
1:da3b138:      * be overridden to this method to customize the broker configuration.
1:da3b138:      */
1:bab4a92:     protected void configure() {
1:bab4a92:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Start the embedded ActiveMQ broker, blocking until the broker has successfully started.
1:da3b138:      * <p/>
1:da3b138:      * The broker will normally be started by JUnit using the before() method.  This method allows the broker to
1:da3b138:      * be started manually to support advanced testing scenarios.
1:da3b138:      */
1:da3b138:     public void start() {
1:da3b138:         try {
1:da3b138:             this.configure();
1:da3b138:             brokerService.start();
1:bab4a92:             internalClient = new InternalClient();
1:bab4a92:             internalClient.start();
1:da3b138:         } catch (Exception ex) {
1:da3b138:             throw new RuntimeException("Exception encountered starting embedded ActiveMQ broker: {}" + this.getBrokerName(), ex);
1:da3b138:         }
1:da3b138: 
1:da3b138:         brokerService.waitUntilStarted();
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Stop the embedded ActiveMQ broker, blocking until the broker has stopped.
1:da3b138:      * <p/>
1:da3b138:      * The broker will normally be stopped by JUnit using the after() method.  This method allows the broker to
1:da3b138:      * be stopped manually to support advanced testing scenarios.
1:da3b138:      */
1:da3b138:     public void stop() {
1:bab4a92:         if (internalClient != null) {
1:bab4a92:             internalClient.stop();
1:bab4a92:             internalClient = null;
1:bab4a92:         }
1:da3b138:         if (!brokerService.isStopped()) {
1:da3b138:             try {
1:da3b138:                 brokerService.stop();
1:da3b138:             } catch (Exception ex) {
1:da3b138:                 log.warn("Exception encountered stopping embedded ActiveMQ broker: {}" + this.getBrokerName(), ex);
1:da3b138:             }
1:da3b138:         }
1:da3b138: 
1:da3b138:         brokerService.waitUntilStopped();
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Start the embedded ActiveMQ Broker
1:da3b138:      * <p/>
1:da3b138:      * Invoked by JUnit to setup the resource
1:da3b138:      */
1:da3b138:     @Override
1:da3b138:     protected void before() throws Throwable {
1:da3b138:         log.info("Starting embedded ActiveMQ broker: {}", this.getBrokerName());
1:da3b138: 
1:da3b138:         this.start();
1:da3b138: 
1:da3b138:         super.before();
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Stop the embedded ActiveMQ Broker
1:da3b138:      * <p/>
1:da3b138:      * Invoked by JUnit to tear down the resource
1:da3b138:      */
1:da3b138:     @Override
1:da3b138:     protected void after() {
1:da3b138:         log.info("Stopping Embedded ActiveMQ Broker: {}", this.getBrokerName());
1:da3b138: 
1:da3b138:         super.after();
1:da3b138: 
1:da3b138:         this.stop();
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Create an ActiveMQConnectionFactory for the embedded ActiveMQ Broker
1:da3b138:      *
1:da3b138:      * @return a new ActiveMQConnectionFactory
1:da3b138:      */
1:da3b138:     public ActiveMQConnectionFactory createConnectionFactory() {
1:da3b138:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
1:bab4a92:         connectionFactory.setBrokerURL(getVmURL());
1:da3b138:         return connectionFactory;
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Create an PooledConnectionFactory for the embedded ActiveMQ Broker
1:da3b138:      *
1:da3b138:      * @return a new PooledConnectionFactory
1:da3b138:      */
1:da3b138:     public PooledConnectionFactory createPooledConnectionFactory() {
1:da3b138:         ActiveMQConnectionFactory connectionFactory = createConnectionFactory();
1:da3b138: 
1:da3b138:         PooledConnectionFactory pooledConnectionFactory = new PooledConnectionFactory(connectionFactory);
1:da3b138: 
1:da3b138:         return pooledConnectionFactory;
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Get the BrokerService for the embedded ActiveMQ broker.
1:da3b138:      * <p/>
1:da3b138:      * This may be required for advanced configuration of the BrokerService.
1:da3b138:      *
1:da3b138:      * @return the embedded ActiveMQ broker
1:da3b138:      */
1:da3b138:     public BrokerService getBrokerService() {
1:da3b138:         return brokerService;
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:bab4a92:      * Get the failover VM URL for the embedded ActiveMQ Broker
1:da3b138:      * <p/>
1:bab4a92:      * NOTE:  The create=false option is appended to the URL to avoid the automatic creation of brokers
1:da3b138:      * and the resulting duplicate broker errors
1:da3b138:      *
1:da3b138:      * @return the VM URL for the embedded broker
1:da3b138:      */
1:da3b138:     public String getVmURL() {
1:bab4a92:         return getVmURL(true);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     /**
1:bab4a92:      * Get the VM URL for the embedded ActiveMQ Broker
1:bab4a92:      * <p/>
1:bab4a92:      * NOTE:  The create=false option is appended to the URL to avoid the automatic creation of brokers
1:bab4a92:      * and the resulting duplicate broker errors
1:bab4a92:      *
1:bab4a92:      * @param failoverURL if true a failover URL will be returned
1:bab4a92:      * @return the VM URL for the embedded broker
1:bab4a92:      */
1:bab4a92:     public String getVmURL(boolean failoverURL) {
1:bab4a92:         if (failoverURL) {
1:bab4a92:             return String.format("failover:(%s?create=false)", brokerService.getVmConnectorURI().toString());
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         return brokerService.getVmConnectorURI().toString() + "?create=false";
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     /**
1:bab4a92:      * Get the failover VM URI for the embedded ActiveMQ Broker
1:bab4a92:      * <p/>
1:bab4a92:      * NOTE:  The create=false option is appended to the URI to avoid the automatic creation of brokers
1:bab4a92:      * and the resulting duplicate broker errors
1:bab4a92:      *
1:bab4a92:      * @return the VM URI for the embedded broker
1:bab4a92:      */
1:bab4a92:     public URI getVmURI() {
1:bab4a92:         return getVmURI(true);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     /**
1:bab4a92:      * Get the VM URI for the embedded ActiveMQ Broker
1:bab4a92:      * <p/>
1:bab4a92:      * NOTE:  The create=false option is appended to the URI to avoid the automatic creation of brokers
1:bab4a92:      * and the resulting duplicate broker errors
1:bab4a92:      *
1:bab4a92:      * @param failoverURI if true a failover URI will be returned
1:bab4a92:      * @return the VM URI for the embedded broker
1:bab4a92:      */
1:bab4a92:     public URI getVmURI(boolean failoverURI) {
1:bab4a92:         URI result;
1:bab4a92:         try {
1:bab4a92:             result = new URI(getVmURL(failoverURI));
1:bab4a92:         } catch (URISyntaxException uriEx) {
1:bab4a92:             throw new RuntimeException("Unable to create failover URI", uriEx);
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         return result;
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Get the name of the embedded ActiveMQ Broker
1:da3b138:      *
1:da3b138:      * @return name of the embedded broker
1:da3b138:      */
1:da3b138:     public String getBrokerName() {
1:da3b138:         return brokerService.getBrokerName();
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void setBrokerName(String brokerName) {
1:da3b138:         brokerService.setBrokerName(brokerName);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public boolean isStatisticsPluginEnabled() {
1:da3b138:         BrokerPlugin[] plugins = brokerService.getPlugins();
1:da3b138: 
1:da3b138:         if (null != plugins) {
1:da3b138:             for (BrokerPlugin plugin : plugins) {
1:da3b138:                 if (plugin instanceof StatisticsBrokerPlugin) {
1:da3b138:                     return true;
1:da3b138:                 }
1:da3b138:             }
1:da3b138:         }
1:da3b138: 
1:da3b138:         return false;
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void enableStatisticsPlugin() {
1:da3b138:         if (!isStatisticsPluginEnabled()) {
1:da3b138:             BrokerPlugin[] newPlugins;
1:da3b138:             BrokerPlugin[] currentPlugins = brokerService.getPlugins();
1:da3b138:             if (null != currentPlugins && 0 < currentPlugins.length) {
1:da3b138:                 newPlugins = new BrokerPlugin[currentPlugins.length + 1];
1:da3b138: 
1:da3b138:                 System.arraycopy(currentPlugins, 0, newPlugins, 0, currentPlugins.length);
1:da3b138:             } else {
1:da3b138:                 newPlugins = new BrokerPlugin[1];
1:da3b138:             }
1:da3b138: 
1:da3b138:             newPlugins[newPlugins.length - 1] = new StatisticsBrokerPlugin();
1:da3b138: 
1:da3b138:             brokerService.setPlugins(newPlugins);
1:da3b138:         }
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void disableStatisticsPlugin() {
1:da3b138:         if (isStatisticsPluginEnabled()) {
1:da3b138:             BrokerPlugin[] currentPlugins = brokerService.getPlugins();
1:da3b138:             if (1 < currentPlugins.length) {
1:da3b138:                 BrokerPlugin[] newPlugins = new BrokerPlugin[currentPlugins.length - 1];
1:da3b138: 
1:da3b138:                 int i = 0;
1:da3b138:                 for (BrokerPlugin plugin : currentPlugins) {
1:da3b138:                     if (!(plugin instanceof StatisticsBrokerPlugin)) {
1:da3b138:                         newPlugins[i++] = plugin;
1:da3b138:                     }
1:da3b138:                 }
1:da3b138:                 brokerService.setPlugins(newPlugins);
1:da3b138:             } else {
1:da3b138:                 brokerService.setPlugins(null);
1:da3b138:             }
1:da3b138: 
1:da3b138:         }
1:da3b138:     }
1:da3b138: 
1:da3b138:     public boolean isAdvisoryForDeliveryEnabled() {
1:da3b138:         return getDefaultPolicyEntry().isAdvisoryForDelivery();
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void enableAdvisoryForDelivery() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForDelivery(true);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void disableAdvisoryForDelivery() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForDelivery(false);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public boolean isAdvisoryForConsumedEnabled() {
1:da3b138:         return getDefaultPolicyEntry().isAdvisoryForConsumed();
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void enableAdvisoryForConsumed() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForConsumed(true);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void disableAdvisoryForConsumed() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForConsumed(false);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public boolean isAdvisoryForDiscardingMessagesEnabled() {
1:da3b138:         return getDefaultPolicyEntry().isAdvisoryForDiscardingMessages();
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void enableAdvisoryForDiscardingMessages() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForDiscardingMessages(true);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void disableAdvisoryForDiscardingMessages() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForDiscardingMessages(false);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public boolean isAdvisoryForFastProducersEnabled() {
1:da3b138:         return getDefaultPolicyEntry().isAdvisoryForFastProducers();
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void enableAdvisoryForFastProducers() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForFastProducers(true);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void disableAdvisoryForFastProducers() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForFastProducers(false);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public boolean isAdvisoryForSlowConsumersEnabled() {
1:da3b138:         return getDefaultPolicyEntry().isAdvisoryForSlowConsumers();
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void enableAdvisoryForSlowConsumers() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForSlowConsumers(true);
1:da3b138:     }
1:da3b138: 
1:da3b138:     public void disableAdvisoryForSlowConsumers() {
1:da3b138:         getDefaultPolicyEntry().setAdvisoryForSlowConsumers(false);
1:da3b138:     }
1:da3b138: 
1:da3b138:     /**
1:da3b138:      * Get the number of messages in a specific JMS Destination.
1:da3b138:      * <p/>
1:bab4a92:      * The full name of the JMS destination including the prefix should be provided - i.e. queue://myQueue
1:bab4a92:      * or topic://myTopic.  If the destination type prefix is not included in the destination name, a prefix
1:bab4a92:      * of "queue://" is assumed.
1:da3b138:      *
1:bab4a92:      * @param destinationName the full name of the JMS Destination
1:da3b138:      * @return the number of messages in the JMS Destination
1:da3b138:      */
1:bab4a92:     public long getMessageCount(String destinationName) {
1:da3b138:         if (null == brokerService) {
1:da3b138:             throw new IllegalStateException("BrokerService has not yet been created - was before() called?");
1:da3b138:         }
1:da3b138: 
1:bab4a92:         // TODO: Figure out how to do this for Topics
1:bab4a92:         Destination destination = getDestination(destinationName);
1:bab4a92:         if (destination == null) {
1:bab4a92:             throw new RuntimeException("Failed to find destination: " + destinationName);
1:da3b138:         }
1:da3b138: 
1:bab4a92:         // return destination.getMessageStore().getMessageCount();
1:bab4a92:         return destination.getDestinationStatistics().getMessages().getCount();
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     /**
1:bab4a92:      * Get the ActiveMQ destination
1:bab4a92:      * <p/>
1:bab4a92:      * The full name of the JMS destination including the prefix should be provided - i.e. queue://myQueue
1:bab4a92:      * or topic://myTopic.  If the destination type prefix is not included in the destination name, a prefix
1:bab4a92:      * of "queue://" is assumed.
1:bab4a92:      *
1:bab4a92:      * @param destinationName the full name of the JMS Destination
1:bab4a92:      * @return the ActiveMQ destination, null if not found
1:bab4a92:      */
1:bab4a92:     public Destination getDestination(String destinationName) {
1:bab4a92:         if (null == brokerService) {
1:bab4a92:             throw new IllegalStateException("BrokerService has not yet been created - was before() called?");
1:da3b138:         }
1:da3b138: 
1:bab4a92:         Destination destination = null;
1:bab4a92:         try {
1:bab4a92:             destination = brokerService.getDestination(ActiveMQDestination.createDestination(destinationName, QUEUE_TYPE));
1:bab4a92:         } catch (RuntimeException runtimeEx) {
1:bab4a92:             throw runtimeEx;
1:bab4a92:         } catch (Exception ex) {
1:bab4a92:             throw new EmbeddedActiveMQBrokerException("Unexpected exception getting destination from broker", ex);
1:da3b138:         }
1:da3b138: 
1:bab4a92:         return destination;
1:da3b138:     }
1:da3b138: 
1:da3b138:     private PolicyEntry getDefaultPolicyEntry() {
1:da3b138:         PolicyMap destinationPolicy = brokerService.getDestinationPolicy();
1:da3b138:         if (null == destinationPolicy) {
1:da3b138:             destinationPolicy = new PolicyMap();
1:da3b138:             brokerService.setDestinationPolicy(destinationPolicy);
1:da3b138:         }
1:da3b138: 
1:da3b138:         PolicyEntry defaultEntry = destinationPolicy.getDefaultEntry();
1:da3b138:         if (null == defaultEntry) {
1:da3b138:             defaultEntry = new PolicyEntry();
1:da3b138:             destinationPolicy.setDefaultEntry(defaultEntry);
1:da3b138:         }
1:da3b138: 
1:da3b138:         return defaultEntry;
1:da3b138:     }
1:bab4a92: 
1:bab4a92:     public BytesMessage createBytesMessage() {
1:bab4a92:         return internalClient.createBytesMessage();
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public TextMessage createTextMessage() {
1:bab4a92:         return internalClient.createTextMessage();
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public MapMessage createMapMessage() {
1:bab4a92:         return internalClient.createMapMessage();
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public ObjectMessage createObjectMessage() {
1:bab4a92:         return internalClient.createObjectMessage();
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public StreamMessage createStreamMessage() {
1:bab4a92:         return internalClient.createStreamMessage();
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public BytesMessage createMessage(byte[] body) {
1:bab4a92:         return this.createMessage(body, null);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public TextMessage createMessage(String body) {
1:bab4a92:         return this.createMessage(body, null);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public MapMessage createMessage(Map<String, Object> body) {
1:bab4a92:         return this.createMessage(body, null);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public ObjectMessage createMessage(Serializable body) {
1:bab4a92:         return this.createMessage(body, null);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public BytesMessage createMessage(byte[] body, Map<String, Object> properties) {
1:bab4a92:         BytesMessage message = this.createBytesMessage();
1:bab4a92:         if (body != null) {
1:bab4a92:             try {
1:bab4a92:                 message.writeBytes(body);
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body {%s} on BytesMessage", new String(body)), jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         setMessageProperties(message, properties);
1:bab4a92: 
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public TextMessage createMessage(String body, Map<String, Object> properties) {
1:bab4a92:         TextMessage message = this.createTextMessage();
1:bab4a92:         if (body != null) {
1:bab4a92:             try {
1:bab4a92:                 message.setText(body);
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body {%s} on TextMessage", body), jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         setMessageProperties(message, properties);
1:bab4a92: 
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public MapMessage createMessage(Map<String, Object> body, Map<String, Object> properties) {
1:bab4a92:         MapMessage message = this.createMapMessage();
1:bab4a92: 
1:bab4a92:         if (body != null) {
1:bab4a92:             for (Map.Entry<String, Object> entry : body.entrySet()) {
1:bab4a92:                 try {
1:bab4a92:                     message.setObject(entry.getKey(), entry.getValue());
1:bab4a92:                 } catch (JMSException jmsEx) {
1:bab4a92:                     throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body entry {%s = %s} on MapMessage", entry.getKey(), entry.getValue().toString()), jmsEx);
1:bab4a92:                 }
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         setMessageProperties(message, properties);
1:bab4a92: 
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public ObjectMessage createMessage(Serializable body, Map<String, Object> properties) {
1:bab4a92:         ObjectMessage message = this.createObjectMessage();
1:bab4a92: 
1:bab4a92:         if (body != null) {
1:bab4a92:             try {
1:bab4a92:                 message.setObject(body);
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body {%s} on ObjectMessage", body.toString()), jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         setMessageProperties(message, properties);
1:bab4a92: 
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public void pushMessage(String destinationName, Message message) {
1:bab4a92:         if (destinationName == null) {
1:bab4a92:             throw new IllegalArgumentException("pushMessage failure - destination name is required");
1:bab4a92:         } else if (message == null) {
1:bab4a92:             throw new IllegalArgumentException("pushMessage failure - a Message is required");
1:bab4a92:         }
1:bab4a92:         ActiveMQDestination destination = ActiveMQDestination.createDestination(destinationName, ActiveMQDestination.QUEUE_TYPE);
1:bab4a92: 
1:bab4a92:         internalClient.pushMessage(destination, message);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public BytesMessage pushMessage(String destinationName, byte[] body) {
1:bab4a92:         BytesMessage message = createMessage(body, null);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public TextMessage pushMessage(String destinationName, String body) {
1:bab4a92:         TextMessage message = createMessage(body, null);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public MapMessage pushMessage(String destinationName, Map<String, Object> body) {
1:bab4a92:         MapMessage message = createMessage(body, null);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public ObjectMessage pushMessage(String destinationName, Serializable body) {
1:bab4a92:         ObjectMessage message = createMessage(body, null);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public BytesMessage pushMessageWithProperties(String destinationName, byte[] body, Map<String, Object> properties) {
1:bab4a92:         BytesMessage message = createMessage(body, properties);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public TextMessage pushMessageWithProperties(String destinationName, String body, Map<String, Object> properties) {
1:bab4a92:         TextMessage message = createMessage(body, properties);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public MapMessage pushMessageWithProperties(String destinationName, Map<String, Object> body, Map<String, Object> properties) {
1:bab4a92:         MapMessage message = createMessage(body, properties);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public ObjectMessage pushMessageWithProperties(String destinationName, Serializable body, Map<String, Object> properties) {
1:bab4a92:         ObjectMessage message = createMessage(body, properties);
1:bab4a92:         pushMessage(destinationName, message);
1:bab4a92:         return message;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92: 
1:bab4a92:     public Message peekMessage(String destinationName) {
1:bab4a92:         if (null == brokerService) {
1:bab4a92:             throw new NullPointerException("peekMessage failure  - BrokerService is null");
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         if (destinationName == null) {
1:bab4a92:             throw new IllegalArgumentException("peekMessage failure - destination name is required");
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         ActiveMQDestination destination = ActiveMQDestination.createDestination(destinationName, ActiveMQDestination.QUEUE_TYPE);
1:bab4a92:         Destination brokerDestination = null;
1:bab4a92: 
1:bab4a92:         try {
1:bab4a92:             brokerDestination = brokerService.getDestination(destination);
1:bab4a92:         } catch (Exception ex) {
1:bab4a92:             throw new EmbeddedActiveMQBrokerException("peekMessage failure - unexpected exception getting destination from BrokerService", ex);
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         if (brokerDestination == null) {
1:bab4a92:             throw new IllegalStateException(String.format("peekMessage failure - destination %s not found in broker %s", destination.toString(), brokerService.getBrokerName()));
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         org.apache.activemq.command.Message[] messages = brokerDestination.browse();
1:bab4a92:         if (messages != null && messages.length > 0) {
1:bab4a92:             return (Message) messages[0];
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         return null;
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public BytesMessage peekBytesMessage(String destinationName) {
1:bab4a92:         return (BytesMessage) peekMessage(destinationName);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public TextMessage peekTextMessage(String destinationName) {
1:bab4a92:         return (TextMessage) peekMessage(destinationName);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public MapMessage peekMapMessage(String destinationName) {
1:bab4a92:         return (MapMessage) peekMessage(destinationName);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public ObjectMessage peekObjectMessage(String destinationName) {
1:bab4a92:         return (ObjectMessage) peekMessage(destinationName);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public StreamMessage peekStreamMessage(String destinationName) {
1:bab4a92:         return (StreamMessage) peekMessage(destinationName);
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     public static class EmbeddedActiveMQBrokerException extends RuntimeException {
1:bab4a92:         public EmbeddedActiveMQBrokerException(String message) {
1:bab4a92:             super(message);
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         public EmbeddedActiveMQBrokerException(String message, Exception cause) {
1:bab4a92:             super(message, cause);
1:bab4a92:         }
1:bab4a92:     }
1:bab4a92: 
1:bab4a92:     private class InternalClient {
1:bab4a92:         ActiveMQConnectionFactory connectionFactory;
1:bab4a92:         Connection connection;
1:bab4a92:         Session session;
1:bab4a92:         MessageProducer producer;
1:bab4a92: 
1:bab4a92:         public InternalClient() {
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         void start() {
1:bab4a92:             connectionFactory = createConnectionFactory();
1:bab4a92:             try {
1:bab4a92:                 connection = connectionFactory.createConnection();
1:bab4a92:                 session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:bab4a92:                 producer = session.createProducer(null);
1:bab4a92:                 connection.start();
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException("Internal Client creation failure", jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         void stop() {
1:bab4a92:             if (null != connection) {
1:bab4a92:                 try {
1:bab4a92:                     connection.close();
1:bab4a92:                 } catch (JMSException jmsEx) {
1:bab4a92:                     log.warn("JMSException encounter closing InternalClient connection - ignoring", jmsEx);
1:bab4a92:                 }
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         public BytesMessage createBytesMessage() {
1:bab4a92:             checkSession();
1:bab4a92: 
1:bab4a92:             try {
1:bab4a92:                 return session.createBytesMessage();
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException("Failed to create BytesMessage", jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         public TextMessage createTextMessage() {
1:bab4a92:             checkSession();
1:bab4a92: 
1:bab4a92:             try {
1:bab4a92:                 return session.createTextMessage();
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException("Failed to create TextMessage", jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         public MapMessage createMapMessage() {
1:bab4a92:             checkSession();
1:bab4a92: 
1:bab4a92:             try {
1:bab4a92:                 return session.createMapMessage();
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException("Failed to create MapMessage", jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         public ObjectMessage createObjectMessage() {
1:bab4a92:             checkSession();
1:bab4a92: 
1:bab4a92:             try {
1:bab4a92:                 return session.createObjectMessage();
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException("Failed to create ObjectMessage", jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         public StreamMessage createStreamMessage() {
1:bab4a92:             checkSession();
1:bab4a92:             try {
1:bab4a92:                 return session.createStreamMessage();
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException("Failed to create StreamMessage", jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         public void pushMessage(ActiveMQDestination destination, Message message) {
1:bab4a92:             if (producer == null) {
1:bab4a92:                 throw new IllegalStateException("JMS MessageProducer is null - has the InternalClient been started?");
1:bab4a92:             }
1:bab4a92: 
1:bab4a92:             try {
1:bab4a92:                 producer.send(destination, message);
1:bab4a92:             } catch (JMSException jmsEx) {
1:bab4a92:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to push %s to %s", message.getClass().getSimpleName(), destination.toString()), jmsEx);
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92: 
1:bab4a92:         void checkSession() {
1:bab4a92:             if (session == null) {
1:bab4a92:                 throw new IllegalStateException("JMS Session is null - has the InternalClient been started?");
1:bab4a92:             }
1:bab4a92:         }
1:bab4a92:     }
1:da3b138: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:44a318b
/////////////////////////////////////////////////////////////////////////
1: import static org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * - JMX is enable but no management connector is created.
1:         brokerService.setUseJmx(true);
1:         brokerService.getManagementContext().setCreateConnector(false);
author:Quinn Stevenson
-------------------------------------------------------------------------------
commit:bab4a92
/////////////////////////////////////////////////////////////////////////
1: import java.io.Serializable;
1: import java.net.URISyntaxException;
1: import java.util.Map;
1: import javax.jms.BytesMessage;
1: import javax.jms.Connection;
1: import javax.jms.JMSException;
1: import javax.jms.MapMessage;
1: import javax.jms.Message;
1: import javax.jms.MessageProducer;
1: import javax.jms.ObjectMessage;
1: import javax.jms.Session;
1: import javax.jms.StreamMessage;
1: import javax.jms.TextMessage;
1: import org.apache.activemq.command.ActiveMQDestination;
0: import static org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE;
1: 
/////////////////////////////////////////////////////////////////////////
1:     InternalClient internalClient;
1:      * <p>
1:      * - the broker name is 'embedded-broker'
0:      * - JMX is disabled
1:      * - Persistence is disabled
/////////////////////////////////////////////////////////////////////////
1:     public EmbeddedActiveMQBroker(String configurationURI) {
/////////////////////////////////////////////////////////////////////////
1:     public EmbeddedActiveMQBroker(URI configurationURI) {
/////////////////////////////////////////////////////////////////////////
1:     public static void setMessageProperties(Message message, Map<String, Object> properties) {
1:         if (properties != null && properties.size() > 0) {
1:             for (Map.Entry<String, Object> property : properties.entrySet()) {
1:                 try {
1:                     message.setObjectProperty(property.getKey(), property.getValue());
1:                 } catch (JMSException jmsEx) {
1:                     throw new EmbeddedActiveMQBrokerException(String.format("Failed to set property {%s = %s}", property.getKey(), property.getValue().toString()), jmsEx);
1:                 }
1:             }
1:         }
1:     }
1: 
1:      * <p>
1:     protected void configure() {
1:     }
/////////////////////////////////////////////////////////////////////////
1:             internalClient = new InternalClient();
1:             internalClient.start();
/////////////////////////////////////////////////////////////////////////
1:         if (internalClient != null) {
1:             internalClient.stop();
1:             internalClient = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         connectionFactory.setBrokerURL(getVmURL());
/////////////////////////////////////////////////////////////////////////
1:      * Get the failover VM URL for the embedded ActiveMQ Broker
1:      * NOTE:  The create=false option is appended to the URL to avoid the automatic creation of brokers
1:         return getVmURL(true);
1:     }
1: 
1:     /**
1:      * Get the VM URL for the embedded ActiveMQ Broker
1:      * <p/>
1:      * NOTE:  The create=false option is appended to the URL to avoid the automatic creation of brokers
1:      * and the resulting duplicate broker errors
1:      *
1:      * @param failoverURL if true a failover URL will be returned
1:      * @return the VM URL for the embedded broker
1:      */
1:     public String getVmURL(boolean failoverURL) {
1:         if (failoverURL) {
1:             return String.format("failover:(%s?create=false)", brokerService.getVmConnectorURI().toString());
1:         }
1: 
1:         return brokerService.getVmConnectorURI().toString() + "?create=false";
1:     }
1: 
1:     /**
1:      * Get the failover VM URI for the embedded ActiveMQ Broker
1:      * <p/>
1:      * NOTE:  The create=false option is appended to the URI to avoid the automatic creation of brokers
1:      * and the resulting duplicate broker errors
1:      *
1:      * @return the VM URI for the embedded broker
1:      */
1:     public URI getVmURI() {
1:         return getVmURI(true);
1:     }
1: 
1:     /**
1:      * Get the VM URI for the embedded ActiveMQ Broker
1:      * <p/>
1:      * NOTE:  The create=false option is appended to the URI to avoid the automatic creation of brokers
1:      * and the resulting duplicate broker errors
1:      *
1:      * @param failoverURI if true a failover URI will be returned
1:      * @return the VM URI for the embedded broker
1:      */
1:     public URI getVmURI(boolean failoverURI) {
1:         URI result;
1:         try {
1:             result = new URI(getVmURL(failoverURI));
1:         } catch (URISyntaxException uriEx) {
1:             throw new RuntimeException("Unable to create failover URI", uriEx);
1:         }
1: 
1:         return result;
/////////////////////////////////////////////////////////////////////////
1:      * The full name of the JMS destination including the prefix should be provided - i.e. queue://myQueue
1:      * or topic://myTopic.  If the destination type prefix is not included in the destination name, a prefix
1:      * of "queue://" is assumed.
1:      * @param destinationName the full name of the JMS Destination
1:     public long getMessageCount(String destinationName) {
1:         // TODO: Figure out how to do this for Topics
1:         Destination destination = getDestination(destinationName);
1:         if (destination == null) {
1:             throw new RuntimeException("Failed to find destination: " + destinationName);
1:         // return destination.getMessageStore().getMessageCount();
1:         return destination.getDestinationStatistics().getMessages().getCount();
1:     }
1: 
1:     /**
1:      * Get the ActiveMQ destination
1:      * <p/>
1:      * The full name of the JMS destination including the prefix should be provided - i.e. queue://myQueue
1:      * or topic://myTopic.  If the destination type prefix is not included in the destination name, a prefix
1:      * of "queue://" is assumed.
1:      *
1:      * @param destinationName the full name of the JMS Destination
1:      * @return the ActiveMQ destination, null if not found
1:      */
1:     public Destination getDestination(String destinationName) {
1:         if (null == brokerService) {
1:             throw new IllegalStateException("BrokerService has not yet been created - was before() called?");
1:         Destination destination = null;
1:         try {
1:             destination = brokerService.getDestination(ActiveMQDestination.createDestination(destinationName, QUEUE_TYPE));
1:         } catch (RuntimeException runtimeEx) {
1:             throw runtimeEx;
1:         } catch (Exception ex) {
1:             throw new EmbeddedActiveMQBrokerException("Unexpected exception getting destination from broker", ex);
1:         return destination;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public BytesMessage createBytesMessage() {
1:         return internalClient.createBytesMessage();
1:     }
1: 
1:     public TextMessage createTextMessage() {
1:         return internalClient.createTextMessage();
1:     }
1: 
1:     public MapMessage createMapMessage() {
1:         return internalClient.createMapMessage();
1:     }
1: 
1:     public ObjectMessage createObjectMessage() {
1:         return internalClient.createObjectMessage();
1:     }
1: 
1:     public StreamMessage createStreamMessage() {
1:         return internalClient.createStreamMessage();
1:     }
1: 
1:     public BytesMessage createMessage(byte[] body) {
1:         return this.createMessage(body, null);
1:     }
1: 
1:     public TextMessage createMessage(String body) {
1:         return this.createMessage(body, null);
1:     }
1: 
1:     public MapMessage createMessage(Map<String, Object> body) {
1:         return this.createMessage(body, null);
1:     }
1: 
1:     public ObjectMessage createMessage(Serializable body) {
1:         return this.createMessage(body, null);
1:     }
1: 
1:     public BytesMessage createMessage(byte[] body, Map<String, Object> properties) {
1:         BytesMessage message = this.createBytesMessage();
1:         if (body != null) {
1:             try {
1:                 message.writeBytes(body);
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body {%s} on BytesMessage", new String(body)), jmsEx);
1:             }
1:         }
1: 
1:         setMessageProperties(message, properties);
1: 
1:         return message;
1:     }
1: 
1:     public TextMessage createMessage(String body, Map<String, Object> properties) {
1:         TextMessage message = this.createTextMessage();
1:         if (body != null) {
1:             try {
1:                 message.setText(body);
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body {%s} on TextMessage", body), jmsEx);
1:             }
1:         }
1: 
1:         setMessageProperties(message, properties);
1: 
1:         return message;
1:     }
1: 
1:     public MapMessage createMessage(Map<String, Object> body, Map<String, Object> properties) {
1:         MapMessage message = this.createMapMessage();
1: 
1:         if (body != null) {
1:             for (Map.Entry<String, Object> entry : body.entrySet()) {
1:                 try {
1:                     message.setObject(entry.getKey(), entry.getValue());
1:                 } catch (JMSException jmsEx) {
1:                     throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body entry {%s = %s} on MapMessage", entry.getKey(), entry.getValue().toString()), jmsEx);
1:                 }
1:             }
1:         }
1: 
1:         setMessageProperties(message, properties);
1: 
1:         return message;
1:     }
1: 
1:     public ObjectMessage createMessage(Serializable body, Map<String, Object> properties) {
1:         ObjectMessage message = this.createObjectMessage();
1: 
1:         if (body != null) {
1:             try {
1:                 message.setObject(body);
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to set body {%s} on ObjectMessage", body.toString()), jmsEx);
1:             }
1:         }
1: 
1:         setMessageProperties(message, properties);
1: 
1:         return message;
1:     }
1: 
1:     public void pushMessage(String destinationName, Message message) {
1:         if (destinationName == null) {
1:             throw new IllegalArgumentException("pushMessage failure - destination name is required");
1:         } else if (message == null) {
1:             throw new IllegalArgumentException("pushMessage failure - a Message is required");
1:         }
1:         ActiveMQDestination destination = ActiveMQDestination.createDestination(destinationName, ActiveMQDestination.QUEUE_TYPE);
1: 
1:         internalClient.pushMessage(destination, message);
1:     }
1: 
1:     public BytesMessage pushMessage(String destinationName, byte[] body) {
1:         BytesMessage message = createMessage(body, null);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1:     public TextMessage pushMessage(String destinationName, String body) {
1:         TextMessage message = createMessage(body, null);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1:     public MapMessage pushMessage(String destinationName, Map<String, Object> body) {
1:         MapMessage message = createMessage(body, null);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1:     public ObjectMessage pushMessage(String destinationName, Serializable body) {
1:         ObjectMessage message = createMessage(body, null);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1:     public BytesMessage pushMessageWithProperties(String destinationName, byte[] body, Map<String, Object> properties) {
1:         BytesMessage message = createMessage(body, properties);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1:     public TextMessage pushMessageWithProperties(String destinationName, String body, Map<String, Object> properties) {
1:         TextMessage message = createMessage(body, properties);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1:     public MapMessage pushMessageWithProperties(String destinationName, Map<String, Object> body, Map<String, Object> properties) {
1:         MapMessage message = createMessage(body, properties);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1:     public ObjectMessage pushMessageWithProperties(String destinationName, Serializable body, Map<String, Object> properties) {
1:         ObjectMessage message = createMessage(body, properties);
1:         pushMessage(destinationName, message);
1:         return message;
1:     }
1: 
1: 
1:     public Message peekMessage(String destinationName) {
1:         if (null == brokerService) {
1:             throw new NullPointerException("peekMessage failure  - BrokerService is null");
1:         }
1: 
1:         if (destinationName == null) {
1:             throw new IllegalArgumentException("peekMessage failure - destination name is required");
1:         }
1: 
1:         ActiveMQDestination destination = ActiveMQDestination.createDestination(destinationName, ActiveMQDestination.QUEUE_TYPE);
1:         Destination brokerDestination = null;
1: 
1:         try {
1:             brokerDestination = brokerService.getDestination(destination);
1:         } catch (Exception ex) {
1:             throw new EmbeddedActiveMQBrokerException("peekMessage failure - unexpected exception getting destination from BrokerService", ex);
1:         }
1: 
1:         if (brokerDestination == null) {
1:             throw new IllegalStateException(String.format("peekMessage failure - destination %s not found in broker %s", destination.toString(), brokerService.getBrokerName()));
1:         }
1: 
1:         org.apache.activemq.command.Message[] messages = brokerDestination.browse();
1:         if (messages != null && messages.length > 0) {
1:             return (Message) messages[0];
1:         }
1: 
1:         return null;
1:     }
1: 
1:     public BytesMessage peekBytesMessage(String destinationName) {
1:         return (BytesMessage) peekMessage(destinationName);
1:     }
1: 
1:     public TextMessage peekTextMessage(String destinationName) {
1:         return (TextMessage) peekMessage(destinationName);
1:     }
1: 
1:     public MapMessage peekMapMessage(String destinationName) {
1:         return (MapMessage) peekMessage(destinationName);
1:     }
1: 
1:     public ObjectMessage peekObjectMessage(String destinationName) {
1:         return (ObjectMessage) peekMessage(destinationName);
1:     }
1: 
1:     public StreamMessage peekStreamMessage(String destinationName) {
1:         return (StreamMessage) peekMessage(destinationName);
1:     }
1: 
1:     public static class EmbeddedActiveMQBrokerException extends RuntimeException {
1:         public EmbeddedActiveMQBrokerException(String message) {
1:             super(message);
1:         }
1: 
1:         public EmbeddedActiveMQBrokerException(String message, Exception cause) {
1:             super(message, cause);
1:         }
1:     }
1: 
1:     private class InternalClient {
1:         ActiveMQConnectionFactory connectionFactory;
1:         Connection connection;
1:         Session session;
1:         MessageProducer producer;
1: 
1:         public InternalClient() {
1:         }
1: 
1:         void start() {
1:             connectionFactory = createConnectionFactory();
1:             try {
1:                 connection = connectionFactory.createConnection();
1:                 session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:                 producer = session.createProducer(null);
1:                 connection.start();
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException("Internal Client creation failure", jmsEx);
1:             }
1:         }
1: 
1:         void stop() {
1:             if (null != connection) {
1:                 try {
1:                     connection.close();
1:                 } catch (JMSException jmsEx) {
1:                     log.warn("JMSException encounter closing InternalClient connection - ignoring", jmsEx);
1:                 }
1:             }
1:         }
1: 
1:         public BytesMessage createBytesMessage() {
1:             checkSession();
1: 
1:             try {
1:                 return session.createBytesMessage();
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException("Failed to create BytesMessage", jmsEx);
1:             }
1:         }
1: 
1:         public TextMessage createTextMessage() {
1:             checkSession();
1: 
1:             try {
1:                 return session.createTextMessage();
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException("Failed to create TextMessage", jmsEx);
1:             }
1:         }
1: 
1:         public MapMessage createMapMessage() {
1:             checkSession();
1: 
1:             try {
1:                 return session.createMapMessage();
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException("Failed to create MapMessage", jmsEx);
1:             }
1:         }
1: 
1:         public ObjectMessage createObjectMessage() {
1:             checkSession();
1: 
1:             try {
1:                 return session.createObjectMessage();
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException("Failed to create ObjectMessage", jmsEx);
1:             }
1:         }
1: 
1:         public StreamMessage createStreamMessage() {
1:             checkSession();
1:             try {
1:                 return session.createStreamMessage();
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException("Failed to create StreamMessage", jmsEx);
1:             }
1:         }
1: 
1:         public void pushMessage(ActiveMQDestination destination, Message message) {
1:             if (producer == null) {
1:                 throw new IllegalStateException("JMS MessageProducer is null - has the InternalClient been started?");
1:             }
1: 
1:             try {
1:                 producer.send(destination, message);
1:             } catch (JMSException jmsEx) {
1:                 throw new EmbeddedActiveMQBrokerException(String.format("Failed to push %s to %s", message.getClass().getSimpleName(), destination.toString()), jmsEx);
1:             }
1:         }
1: 
1:         void checkSession() {
1:             if (session == null) {
1:                 throw new IllegalStateException("JMS Session is null - has the InternalClient been started?");
1:             }
1:         }
1:     }
commit:da3b138
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.junit;
1: 
1: import java.net.URI;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.Destination;
0: import org.apache.activemq.broker.region.Queue;
0: import org.apache.activemq.broker.region.Topic;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.plugin.StatisticsBrokerPlugin;
1: import org.apache.activemq.pool.PooledConnectionFactory;
1: import org.junit.rules.ExternalResource;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * A JUnit Rule that embeds an ActiveMQ broker into a test.
1:  */
1: public class EmbeddedActiveMQBroker extends ExternalResource {
1:     Logger log = LoggerFactory.getLogger(this.getClass());
1: 
1:     BrokerService brokerService;
1: 
1:     /**
1:      * Create an embedded ActiveMQ broker using defaults
1:      *
1:      * The defaults are:
0:      *  - the broker name is 'embedded-broker'
0:      *  - JMX is disabled
0:      *  - Persistence is disabled
1:      *
1:      */
1:     public EmbeddedActiveMQBroker() {
1:         brokerService = new BrokerService();
0:         brokerService.setUseJmx(false);
1:         brokerService.setUseShutdownHook(false);
1:         brokerService.setPersistent(false);
1:         brokerService.setBrokerName("embedded-broker");
1:     }
1: 
1:     /**
1:      * Create an embedded ActiveMQ broker using a configuration URI
1:      */
0:     public EmbeddedActiveMQBroker(String configurationURI ) {
1:         try {
1:             brokerService = BrokerFactory.createBroker(configurationURI);
1:         } catch (Exception ex) {
1:             throw new RuntimeException("Exception encountered creating embedded ActiveMQ broker from configuration URI: " + configurationURI, ex);
1:         }
1:     }
1: 
1:     /**
1:      * Create an embedded ActiveMQ broker using a configuration URI
1:      */
0:     public EmbeddedActiveMQBroker(URI configurationURI ) {
1:         try {
1:             brokerService = BrokerFactory.createBroker(configurationURI);
1:         } catch (Exception ex) {
1:             throw new RuntimeException("Exception encountered creating embedded ActiveMQ broker from configuration URI: " + configurationURI, ex);
1:         }
1:     }
1: 
1:     /**
1:      * Customize the configuration of the embedded ActiveMQ broker
1:      *
1:      * This method is called before the embedded ActiveMQ broker is started, and can
1:      * be overridden to this method to customize the broker configuration.
1:      */
0:     protected void configure() {}
1: 
1:     /**
1:      * Start the embedded ActiveMQ broker, blocking until the broker has successfully started.
1:      * <p/>
1:      * The broker will normally be started by JUnit using the before() method.  This method allows the broker to
1:      * be started manually to support advanced testing scenarios.
1:      */
1:     public void start() {
1:         try {
1:             this.configure();
1:             brokerService.start();
1:         } catch (Exception ex) {
1:             throw new RuntimeException("Exception encountered starting embedded ActiveMQ broker: {}" + this.getBrokerName(), ex);
1:         }
1: 
1:         brokerService.waitUntilStarted();
1:     }
1: 
1:     /**
1:      * Stop the embedded ActiveMQ broker, blocking until the broker has stopped.
1:      * <p/>
1:      * The broker will normally be stopped by JUnit using the after() method.  This method allows the broker to
1:      * be stopped manually to support advanced testing scenarios.
1:      */
1:     public void stop() {
1:         if (!brokerService.isStopped()) {
1:             try {
1:                 brokerService.stop();
1:             } catch (Exception ex) {
1:                 log.warn("Exception encountered stopping embedded ActiveMQ broker: {}" + this.getBrokerName(), ex);
1:             }
1:         }
1: 
1:         brokerService.waitUntilStopped();
1:     }
1: 
1:     /**
1:      * Start the embedded ActiveMQ Broker
1:      * <p/>
1:      * Invoked by JUnit to setup the resource
1:      */
1:     @Override
1:     protected void before() throws Throwable {
1:         log.info("Starting embedded ActiveMQ broker: {}", this.getBrokerName());
1: 
1:         this.start();
1: 
1:         super.before();
1:     }
1: 
1:     /**
1:      * Stop the embedded ActiveMQ Broker
1:      * <p/>
1:      * Invoked by JUnit to tear down the resource
1:      */
1:     @Override
1:     protected void after() {
1:         log.info("Stopping Embedded ActiveMQ Broker: {}", this.getBrokerName());
1: 
1:         super.after();
1: 
1:         this.stop();
1:     }
1: 
1:     /**
1:      * Create an ActiveMQConnectionFactory for the embedded ActiveMQ Broker
1:      *
1:      * @return a new ActiveMQConnectionFactory
1:      */
1:     public ActiveMQConnectionFactory createConnectionFactory() {
1:         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
0:         connectionFactory.setBrokerURL(brokerService.getVmConnectorURI().toString());
1:         return connectionFactory;
1:     }
1: 
1:     /**
1:      * Create an PooledConnectionFactory for the embedded ActiveMQ Broker
1:      *
1:      * @return a new PooledConnectionFactory
1:      */
1:     public PooledConnectionFactory createPooledConnectionFactory() {
1:         ActiveMQConnectionFactory connectionFactory = createConnectionFactory();
1: 
1:         PooledConnectionFactory pooledConnectionFactory = new PooledConnectionFactory(connectionFactory);
1: 
1:         return pooledConnectionFactory;
1:     }
1: 
1:     /**
1:      * Get the BrokerService for the embedded ActiveMQ broker.
1:      * <p/>
1:      * This may be required for advanced configuration of the BrokerService.
1:      *
1:      * @return the embedded ActiveMQ broker
1:      */
1:     public BrokerService getBrokerService() {
1:         return brokerService;
1:     }
1: 
1:     /**
0:      * Get the VM URL for the embedded ActiveMQ Broker
1:      * <p/>
0:      * NOTE:  The option is precreate=false option is appended to the URL to avoid the automatic creation of brokers
1:      * and the resulting duplicate broker errors
1:      *
1:      * @return the VM URL for the embedded broker
1:      */
1:     public String getVmURL() {
0:         return String.format("failover:(%s?create=false)", brokerService.getVmConnectorURI().toString());
1:     }
1: 
1:     /**
1:      * Get the name of the embedded ActiveMQ Broker
1:      *
1:      * @return name of the embedded broker
1:      */
1:     public String getBrokerName() {
1:         return brokerService.getBrokerName();
1:     }
1: 
1:     public void setBrokerName(String brokerName) {
1:         brokerService.setBrokerName(brokerName);
1:     }
1: 
1:     public boolean isStatisticsPluginEnabled() {
1:         BrokerPlugin[] plugins = brokerService.getPlugins();
1: 
1:         if (null != plugins) {
1:             for (BrokerPlugin plugin : plugins) {
1:                 if (plugin instanceof StatisticsBrokerPlugin) {
1:                     return true;
1:                 }
1:             }
1:         }
1: 
1:         return false;
1:     }
1: 
1:     public void enableStatisticsPlugin() {
1:         if (!isStatisticsPluginEnabled()) {
1:             BrokerPlugin[] newPlugins;
1:             BrokerPlugin[] currentPlugins = brokerService.getPlugins();
1:             if (null != currentPlugins && 0 < currentPlugins.length) {
1:                 newPlugins = new BrokerPlugin[currentPlugins.length + 1];
1: 
1:                 System.arraycopy(currentPlugins, 0, newPlugins, 0, currentPlugins.length);
1:             } else {
1:                 newPlugins = new BrokerPlugin[1];
1:             }
1: 
1:             newPlugins[newPlugins.length - 1] = new StatisticsBrokerPlugin();
1: 
1:             brokerService.setPlugins(newPlugins);
1:         }
1:     }
1: 
1:     public void disableStatisticsPlugin() {
1:         if (isStatisticsPluginEnabled()) {
1:             BrokerPlugin[] currentPlugins = brokerService.getPlugins();
1:             if (1 < currentPlugins.length) {
1:                 BrokerPlugin[] newPlugins = new BrokerPlugin[currentPlugins.length - 1];
1: 
1:                 int i = 0;
1:                 for (BrokerPlugin plugin : currentPlugins) {
1:                     if (!(plugin instanceof StatisticsBrokerPlugin)) {
1:                         newPlugins[i++] = plugin;
1:                     }
1:                 }
1:                 brokerService.setPlugins(newPlugins);
1:             } else {
1:                 brokerService.setPlugins(null);
1:             }
1: 
1:         }
1:     }
1: 
1:     public boolean isAdvisoryForDeliveryEnabled() {
1:         return getDefaultPolicyEntry().isAdvisoryForDelivery();
1:     }
1: 
1:     public void enableAdvisoryForDelivery() {
1:         getDefaultPolicyEntry().setAdvisoryForDelivery(true);
1:     }
1: 
1:     public void disableAdvisoryForDelivery() {
1:         getDefaultPolicyEntry().setAdvisoryForDelivery(false);
1:     }
1: 
1:     public boolean isAdvisoryForConsumedEnabled() {
1:         return getDefaultPolicyEntry().isAdvisoryForConsumed();
1:     }
1: 
1:     public void enableAdvisoryForConsumed() {
1:         getDefaultPolicyEntry().setAdvisoryForConsumed(true);
1:     }
1: 
1:     public void disableAdvisoryForConsumed() {
1:         getDefaultPolicyEntry().setAdvisoryForConsumed(false);
1:     }
1: 
1:     public boolean isAdvisoryForDiscardingMessagesEnabled() {
1:         return getDefaultPolicyEntry().isAdvisoryForDiscardingMessages();
1:     }
1: 
1:     public void enableAdvisoryForDiscardingMessages() {
1:         getDefaultPolicyEntry().setAdvisoryForDiscardingMessages(true);
1:     }
1: 
1:     public void disableAdvisoryForDiscardingMessages() {
1:         getDefaultPolicyEntry().setAdvisoryForDiscardingMessages(false);
1:     }
1: 
1:     public boolean isAdvisoryForFastProducersEnabled() {
1:         return getDefaultPolicyEntry().isAdvisoryForFastProducers();
1:     }
1: 
1:     public void enableAdvisoryForFastProducers() {
1:         getDefaultPolicyEntry().setAdvisoryForFastProducers(true);
1:     }
1: 
1:     public void disableAdvisoryForFastProducers() {
1:         getDefaultPolicyEntry().setAdvisoryForFastProducers(false);
1:     }
1: 
1:     public boolean isAdvisoryForSlowConsumersEnabled() {
1:         return getDefaultPolicyEntry().isAdvisoryForSlowConsumers();
1:     }
1: 
1:     public void enableAdvisoryForSlowConsumers() {
1:         getDefaultPolicyEntry().setAdvisoryForSlowConsumers(true);
1:     }
1: 
1:     public void disableAdvisoryForSlowConsumers() {
1:         getDefaultPolicyEntry().setAdvisoryForSlowConsumers(false);
1:     }
1: 
1:     /**
1:      * Get the number of messages in a specific JMS Destination.
1:      * <p/>
0:      * The full name of the JMS destination including the prefix should be provided - i.e. queue:myQueue
0:      * or topic:myTopic.  If the destination type prefix is not included in the destination name, a prefix
0:      * of "queue:" is assumed.
1:      *
0:      * @param fullDestinationName the full name of the JMS Destination
1:      * @return the number of messages in the JMS Destination
1:      */
0:     public int getMessageCount(String fullDestinationName) throws Exception {
0:         final int QUEUE_TYPE = 1;
0:         final int TOPIC_TYPE = 2;
1: 
1:         if (null == brokerService) {
1:             throw new IllegalStateException("BrokerService has not yet been created - was before() called?");
1:         }
1: 
0:         int destinationType = QUEUE_TYPE;
0:         String destinationName = fullDestinationName;
1: 
0:         if (fullDestinationName.startsWith("queue:")) {
0:             destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);
0:         } else if (fullDestinationName.startsWith("topic:")) {
0:             destinationType = TOPIC_TYPE;
0:             destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);
1:         }
1: 
0:         int messageCount = -1;
0:         boolean foundDestination = false;
0:         for (Destination destination : brokerService.getBroker().getDestinationMap().values()) {
0:             String tmpName = destination.getName();
0:             if (tmpName.equalsIgnoreCase(destinationName)) {
0:                 switch (destinationType) {
0:                     case QUEUE_TYPE:
0:                         if (destination instanceof Queue) {
0:                             messageCount = destination.getMessageStore().getMessageCount();
0:                             foundDestination = true;
1:                         }
0:                         break;
0:                     case TOPIC_TYPE:
0:                         if (destination instanceof Topic) {
0:                             messageCount = destination.getMessageStore().getMessageCount();
0:                             foundDestination = true;
1:                         }
0:                         break;
0:                     default:
0:                         // Should never see this
0:                         log.error("Type didn't match: {}", destination.getClass().getName());
1:                 }
1:             }
0:             if (foundDestination) {
0:                 break;
1:             }
1:         }
1: 
0:         if (!foundDestination) {
0:             log.warn("Didn't find destination {} in broker {}", fullDestinationName, getBrokerName());
1:         }
1: 
0:         return messageCount;
1:     }
1: 
1:     private PolicyEntry getDefaultPolicyEntry() {
1:         PolicyMap destinationPolicy = brokerService.getDestinationPolicy();
1:         if (null == destinationPolicy) {
1:             destinationPolicy = new PolicyMap();
1:             brokerService.setDestinationPolicy(destinationPolicy);
1:         }
1: 
1:         PolicyEntry defaultEntry = destinationPolicy.getDefaultEntry();
1:         if (null == defaultEntry) {
1:             defaultEntry = new PolicyEntry();
1:             destinationPolicy.setDefaultEntry(defaultEntry);
1:         }
1: 
1:         return defaultEntry;
1:     }
1: }
============================================================================