1:746585e: /**
1:746585e:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:746585e:  * contributor license agreements.  See the NOTICE file distributed with
1:746585e:  * this work for additional information regarding copyright ownership.
1:746585e:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:746585e:  * (the "License"); you may not use this file except in compliance with
1:746585e:  * the License.  You may obtain a copy of the License at
1:746585e:  *
1:746585e:  *      http://www.apache.org/licenses/LICENSE-2.0
1:746585e:  *
1:746585e:  * Unless required by applicable law or agreed to in writing, software
1:746585e:  * distributed under the License is distributed on an "AS IS" BASIS,
1:746585e:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:746585e:  * See the License for the specific language governing permissions and
1:746585e:  * limitations under the License.
1:746585e:  */
37:746585e: 
1:746585e: package org.apache.activemq.usecases;
1:746585e: 
1:4743a20: import static org.junit.Assert.assertTrue;
1:4743a20: 
1:746585e: import java.net.URI;
1:746585e: import java.net.URISyntaxException;
1:746585e: import java.util.ArrayList;
1:746585e: import java.util.Enumeration;
1:746585e: import java.util.concurrent.ArrayBlockingQueue;
1:746585e: import java.util.concurrent.CountDownLatch;
1:746585e: import java.util.concurrent.ThreadPoolExecutor;
1:746585e: import java.util.concurrent.TimeUnit;
1:4743a20: 
1:746585e: import javax.jms.Connection;
1:746585e: import javax.jms.Destination;
1:746585e: import javax.jms.JMSException;
1:746585e: import javax.jms.Message;
1:746585e: import javax.jms.MessageConsumer;
1:746585e: import javax.jms.MessageProducer;
1:746585e: import javax.jms.Session;
1:746585e: import javax.jms.TextMessage;
1:4743a20: 
1:746585e: import org.apache.activemq.ActiveMQConnection;
1:746585e: import org.apache.activemq.ActiveMQSession;
1:746585e: import org.apache.activemq.broker.BrokerService;
1:746585e: import org.apache.activemq.command.ActiveMQDestination;
1:746585e: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:746585e: import org.apache.activemq.network.NetworkConnector;
1:746585e: import org.apache.commons.logging.Log;
1:746585e: import org.apache.commons.logging.LogFactory;
1:746585e: import org.junit.Test;
1:746585e: 
1:746585e: public class RequestReplyToTopicViaThreeNetworkHopsTest {
1:746585e:     protected static final int CONCURRENT_CLIENT_COUNT = 5;
1:746585e:     protected static final int CONCURRENT_SERVER_COUNT = 5;
1:746585e:     protected static final int TOTAL_CLIENT_ITER = 10;
1:746585e: 
1:746585e:     protected static int Next_broker_num = 0;
1:746585e:     protected EmbeddedTcpBroker edge1;
1:746585e:     protected EmbeddedTcpBroker edge2;
1:746585e:     protected EmbeddedTcpBroker core1;
1:746585e:     protected EmbeddedTcpBroker core2;
1:746585e: 
1:746585e:     protected boolean testError = false;
1:746585e:     protected boolean fatalTestError = false;
1:746585e: 
1:4743a20:     protected int echoResponseFill = 0; // Number of "filler" response messages per request
1:746585e: 
1:746585e:     protected static Log LOG;
1:a8b6f8b:     public boolean duplex = true;
1:746585e: 
1:746585e:     static {
1:746585e:         LOG = LogFactory.getLog(RequestReplyToTopicViaThreeNetworkHopsTest.class);
1:746585e:     }
1:746585e: 
1:4743a20:     public RequestReplyToTopicViaThreeNetworkHopsTest() throws Exception {
1:746585e:         edge1 = new EmbeddedTcpBroker("edge", 1);
1:746585e:         edge2 = new EmbeddedTcpBroker("edge", 2);
1:746585e:         core1 = new EmbeddedTcpBroker("core", 1);
1:746585e:         core2 = new EmbeddedTcpBroker("core", 2);
1:746585e: 
1:746585e:         // duplex is necessary to serialise sends with consumer/destination creation
1:a8b6f8b:         edge1.coreConnectTo(core1, duplex);
1:a8b6f8b:         edge2.coreConnectTo(core2, duplex);
1:a8b6f8b:         core1.coreConnectTo(core2, duplex);
1:746585e:     }
1:746585e: 
1:746585e:     public void logMessage(String msg) {
1:746585e:         System.out.println(msg);
1:746585e:         System.out.flush();
1:746585e:     }
1:746585e: 
1:4743a20:     public void testMessages(Session sess, MessageProducer req_prod, Destination resp_dest, int num_msg) throws Exception {
1:746585e:         MessageConsumer resp_cons;
1:746585e:         TextMessage msg;
1:746585e:         MessageClient cons_client;
1:746585e:         int cur;
1:746585e:         int tot_expected;
1:746585e: 
1:746585e:         resp_cons = sess.createConsumer(resp_dest);
1:746585e: 
1:746585e:         cons_client = new MessageClient(resp_cons, num_msg);
1:746585e:         cons_client.start();
1:746585e: 
1:746585e:         cur = 0;
1:746585e:         while ((cur < num_msg) && (!fatalTestError)) {
1:746585e:             msg = sess.createTextMessage("MSG AAAA " + cur);
1:746585e:             msg.setIntProperty("SEQ", 100 + cur);
1:746585e:             msg.setStringProperty("TEST", "TOPO");
1:746585e:             msg.setJMSReplyTo(resp_dest);
1:746585e: 
1:746585e:             if (cur == (num_msg - 1))
1:746585e:                 msg.setBooleanProperty("end-of-response", true);
1:746585e: 
1:746585e:             sendWithRetryOnDeletedDest(req_prod, msg);
1:746585e:             LOG.debug("Sent:" + msg);
1:746585e: 
1:746585e:             cur++;
1:746585e:         }
1:746585e: 
1:746585e:         //
1:746585e:         // Give the consumer some time to receive the response.
1:746585e:         //
1:746585e:         cons_client.waitShutdown(5000);
1:746585e: 
1:746585e:         //
1:746585e:         // Now shutdown the consumer if it's still running.
1:746585e:         //
1:746585e:         if (cons_client.shutdown())
1:746585e:             LOG.debug("Consumer client shutdown complete");
1:746585e:         else
1:746585e:             LOG.debug("Consumer client shutdown incomplete!!!");
1:746585e: 
1:746585e:         //
1:746585e:         // Check that the correct number of messages was received.
1:746585e:         //
1:746585e:         tot_expected = num_msg * (echoResponseFill + 1);
1:746585e: 
1:746585e:         if (cons_client.getNumMsgReceived() == tot_expected) {
1:746585e:             LOG.debug("Have " + tot_expected + " messages, as-expected");
1:746585e:         } else {
1:746585e:             testError = true;
1:746585e: 
1:746585e:             if (cons_client.getNumMsgReceived() == 0)
1:746585e:                 fatalTestError = true;
1:746585e: 
1:4743a20:             LOG.error("Have " + cons_client.getNumMsgReceived() + " messages; expected " + tot_expected + " on destination " + resp_dest);
1:746585e:         }
1:746585e: 
1:746585e:         resp_cons.close();
1:746585e:     }
1:746585e: 
1:4743a20:     protected void sendWithRetryOnDeletedDest(MessageProducer prod, Message msg) throws JMSException {
1:746585e:         try {
1:746585e:             if (LOG.isDebugEnabled())
1:746585e:                 LOG.debug("SENDING REQUEST message " + msg);
1:746585e: 
1:746585e:             prod.send(msg);
1:746585e:         } catch (JMSException jms_exc) {
1:746585e:             System.out.println("AAA: " + jms_exc.getMessage());
1:746585e:             throw jms_exc;
1:746585e:         }
1:746585e:     }
1:746585e: 
1:746585e:     /**
1:746585e:      * Test one destination between the given "producer broker" and "consumer broker" specified.
1:746585e:      */
1:4743a20:     public void testOneDest(Connection conn, Session sess, Destination cons_dest, int num_msg) throws Exception {
1:746585e:         Destination prod_dest;
1:746585e:         MessageProducer msg_prod;
1:746585e: 
1:746585e:         //
1:746585e:         // Create the Producer to the echo request Queue
1:746585e:         //
1:746585e:         LOG.trace("Creating echo queue and producer");
1:746585e:         prod_dest = sess.createQueue("echo");
1:746585e:         msg_prod = sess.createProducer(prod_dest);
1:746585e: 
1:746585e:         //
1:746585e:         // Pass messages around.
1:746585e:         //
1:746585e:         testMessages(sess, msg_prod, cons_dest, num_msg);
1:746585e: 
1:746585e:         msg_prod.close();
1:746585e:     }
1:746585e: 
1:746585e:     /**
1:746585e:      * TEST TEMPORARY TOPICS
1:746585e:      */
1:4743a20:     public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {
1:746585e:         Connection conn;
1:746585e:         Session sess;
1:746585e:         Destination cons_dest;
1:746585e:         int num_msg;
1:746585e: 
1:746585e:         num_msg = 5;
1:746585e: 
1:4743a20:         LOG.debug("TESTING TEMP TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:746585e: 
1:746585e:         //
1:746585e:         // Connect to the bus.
1:746585e:         //
1:746585e:         conn = createConnection(cons_broker_url);
1:746585e:         conn.start();
1:746585e:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:746585e: 
1:746585e:         //
1:746585e:         // Create the destination on which messages are being tested.
1:746585e:         //
1:746585e:         LOG.trace("Creating destination");
1:746585e:         cons_dest = sess.createTemporaryTopic();
1:746585e: 
1:746585e:         testOneDest(conn, sess, cons_dest, num_msg);
1:746585e: 
1:746585e:         //
1:746585e:         // Cleanup
1:746585e:         //
1:746585e:         sess.close();
1:746585e:         conn.close();
1:746585e:     }
1:746585e: 
1:746585e:     /**
1:746585e:      * TEST TOPICS
1:746585e:      */
1:4743a20:     public void testTopic(String prod_broker_url, String cons_broker_url) throws Exception {
1:746585e:         int num_msg;
1:746585e: 
1:746585e:         Connection conn;
1:746585e:         Session sess;
1:746585e:         String topic_name;
1:746585e: 
1:746585e:         Destination cons_dest;
1:746585e: 
1:746585e:         num_msg = 5;
1:746585e: 
1:4743a20:         LOG.info("TESTING TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:746585e: 
1:746585e:         conn = createConnection(cons_broker_url);
1:746585e:         conn.start();
1:746585e:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:746585e: 
1:746585e:         //
1:746585e:         // Create the destination on which messages are being tested.
1:746585e:         //
1:746585e:         topic_name = "topotest2.perm.topic";
1:746585e:         LOG.trace("Removing existing Topic");
1:746585e:         removeTopic(conn, topic_name);
1:746585e:         LOG.trace("Creating Topic, " + topic_name);
1:746585e:         cons_dest = sess.createTopic(topic_name);
1:746585e: 
1:746585e:         testOneDest(conn, sess, cons_dest, num_msg);
1:746585e: 
1:746585e:         //
1:746585e:         // Cleanup
1:746585e:         //
1:746585e:         removeTopic(conn, topic_name);
1:746585e:         sess.close();
1:746585e:         conn.close();
1:746585e:     }
1:746585e: 
1:746585e:     /**
1:746585e:      * TEST TEMPORARY QUEUES
1:746585e:      */
1:4743a20:     public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {
1:746585e:         int num_msg;
1:746585e: 
1:746585e:         Connection conn;
1:746585e:         Session sess;
1:746585e: 
1:746585e:         Destination cons_dest;
1:746585e: 
1:746585e:         num_msg = 5;
1:746585e: 
1:4743a20:         LOG.info("TESTING TEMP QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:746585e: 
1:746585e:         //
1:746585e:         // Connect to the bus.
1:746585e:         //
1:746585e:         conn = createConnection(cons_broker_url);
1:746585e:         conn.start();
1:746585e:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:746585e: 
1:746585e:         //
1:746585e:         // Create the destination on which messages are being tested.
1:746585e:         //
1:746585e:         LOG.trace("Creating destination");
1:746585e:         cons_dest = sess.createTemporaryQueue();
1:746585e: 
1:746585e:         testOneDest(conn, sess, cons_dest, num_msg);
1:746585e: 
1:746585e:         //
1:746585e:         // Cleanup
1:746585e:         //
1:746585e:         sess.close();
1:746585e:         conn.close();
1:746585e:     }
1:746585e: 
1:746585e:     /**
1:746585e:      * TEST QUEUES
1:746585e:      */
1:4743a20:     public void testQueue(String prod_broker_url, String cons_broker_url) throws Exception {
1:746585e:         int num_msg;
1:746585e: 
1:746585e:         Connection conn;
1:746585e:         Session sess;
1:746585e:         String queue_name;
1:746585e: 
1:746585e:         Destination cons_dest;
1:746585e: 
1:746585e:         num_msg = 5;
1:746585e: 
1:4743a20:         LOG.info("TESTING QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:746585e: 
1:746585e:         conn = createConnection(cons_broker_url);
1:746585e:         conn.start();
1:746585e:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:746585e: 
1:746585e:         //
1:746585e:         // Create the destination on which messages are being tested.
1:746585e:         //
1:746585e:         queue_name = "topotest2.perm.queue";
1:746585e:         LOG.trace("Removing existing Queue");
1:746585e:         removeQueue(conn, queue_name);
1:746585e:         LOG.trace("Creating Queue, " + queue_name);
1:746585e:         cons_dest = sess.createQueue(queue_name);
1:746585e: 
1:746585e:         testOneDest(conn, sess, cons_dest, num_msg);
1:746585e: 
1:746585e:         removeQueue(conn, queue_name);
1:746585e:         sess.close();
1:746585e:         conn.close();
1:746585e:     }
1:746585e: 
1:746585e:     @Test
1:4743a20:     public void runWithTempTopicReplyTo() throws Exception {
1:746585e:         EchoService echo_svc;
1:746585e:         TopicTrafficGenerator traffic_gen;
1:746585e:         Thread start1;
1:746585e:         Thread start2;
1:746585e:         Thread start3;
1:746585e:         Thread start4;
1:746585e:         ThreadPoolExecutor clientExecPool;
1:746585e:         final CountDownLatch clientCompletionLatch;
1:746585e:         int iter;
1:746585e: 
1:746585e:         fatalTestError = false;
1:746585e:         testError = false;
1:746585e: 
1:746585e:         //
1:746585e:         // Execute up to 20 clients at a time to simulate that load.
1:746585e:         //
1:746585e: 
1:4743a20:         clientExecPool = new ThreadPoolExecutor(CONCURRENT_CLIENT_COUNT, CONCURRENT_CLIENT_COUNT, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10000));
1:746585e:         clientCompletionLatch = new CountDownLatch(TOTAL_CLIENT_ITER);
1:746585e: 
1:746585e:         // Use threads to avoid startup deadlock since the first broker started waits until
1:4743a20:         // it knows the name of the remote broker before finishing its startup, which means
1:4743a20:         // the remote must already be running.
1:746585e: 
1:746585e:         start1 = new Thread() {
1:4743a20:             @Override
1:746585e:             public void run() {
1:746585e:                 try {
1:746585e:                     edge1.start();
1:746585e:                 } catch (Exception ex) {
1:746585e:                     LOG.error(null, ex);
1:746585e:                 }
1:746585e:             }
1:746585e:         };
1:746585e: 
1:746585e:         start2 = new Thread() {
1:4743a20:             @Override
1:746585e:             public void run() {
1:746585e:                 try {
1:746585e:                     edge2.start();
1:746585e:                 } catch (Exception ex) {
1:746585e:                     LOG.error(null, ex);
1:746585e:                 }
1:746585e:             }
1:746585e:         };
1:746585e: 
1:746585e:         start3 = new Thread() {
1:4743a20:             @Override
1:746585e:             public void run() {
1:746585e:                 try {
1:746585e:                     core1.start();
1:746585e:                 } catch (Exception ex) {
1:746585e:                     LOG.error(null, ex);
1:746585e:                 }
1:746585e:             }
1:746585e:         };
1:746585e: 
1:746585e:         start4 = new Thread() {
1:4743a20:             @Override
1:746585e:             public void run() {
1:746585e:                 try {
1:746585e:                     core2.start();
1:746585e:                 } catch (Exception ex) {
1:746585e:                     LOG.error(null, ex);
1:746585e:                 }
1:746585e:             }
1:746585e:         };
1:746585e: 
1:746585e:         start1.start();
1:746585e:         start2.start();
1:746585e:         start3.start();
1:746585e:         start4.start();
1:746585e: 
1:746585e:         start1.join();
1:746585e:         start2.join();
1:746585e:         start3.join();
1:746585e:         start4.join();
1:746585e: 
1:746585e:         traffic_gen = new TopicTrafficGenerator(edge1.getConnectionUrl(), edge2.getConnectionUrl());
1:746585e:         traffic_gen.start();
1:746585e: 
1:746585e:         //
1:746585e:         // Now start the echo service with that queue.
1:746585e:         //
1:746585e:         echo_svc = new EchoService("echo", edge1.getConnectionUrl());
1:746585e:         echo_svc.start();
1:746585e: 
1:746585e:         //
1:746585e:         // Run the tests on Temp Topics.
1:746585e:         //
1:746585e: 
1:746585e:         LOG.info("** STARTING TEMP TOPIC TESTS");
1:746585e:         iter = 0;
1:746585e:         while ((iter < TOTAL_CLIENT_ITER) && (!fatalTestError)) {
1:746585e:             clientExecPool.execute(new Runnable() {
1:4743a20:                 @Override
1:746585e:                 public void run() {
1:746585e:                     try {
1:4743a20:                         RequestReplyToTopicViaThreeNetworkHopsTest.this.testTempTopic(edge1.getConnectionUrl(), edge2.getConnectionUrl());
1:746585e:                     } catch (Exception exc) {
1:746585e:                         LOG.error("test exception", exc);
1:746585e:                         fatalTestError = true;
1:746585e:                         testError = true;
1:746585e:                     }
1:746585e: 
1:746585e:                     clientCompletionLatch.countDown();
1:746585e:                 }
1:746585e:             });
1:746585e: 
1:746585e:             iter++;
1:746585e:         }
1:746585e: 
1:746585e:         boolean allDoneOnTime = clientCompletionLatch.await(20, TimeUnit.MINUTES);
1:746585e: 
1:4743a20:         LOG.info("** FINISHED TEMP TOPIC TESTS AFTER " + iter + " ITERATIONS, testError:" + testError + ", fatal: " + fatalTestError + ", onTime:"
1:4743a20:             + allDoneOnTime);
1:746585e: 
1:746585e:         Thread.sleep(100);
1:746585e: 
1:746585e:         echo_svc.shutdown();
1:746585e:         traffic_gen.shutdown();
1:746585e: 
1:746585e:         shutdown();
1:746585e: 
1:746585e:         assertTrue("test completed in time", allDoneOnTime);
1:746585e:         assertTrue("no errors", !testError);
1:746585e:     }
1:746585e: 
1:4743a20:     public void shutdown() throws Exception {
1:746585e:         edge1.stop();
1:746585e:         edge2.stop();
1:746585e:         core1.stop();
1:746585e:         core2.stop();
1:746585e:     }
1:746585e: 
1:4743a20:     protected Connection createConnection(String url) throws Exception {
1:746585e:         return org.apache.activemq.ActiveMQConnection.makeConnection(url);
1:746585e:     }
1:746585e: 
1:4743a20:     protected static void removeQueue(Connection conn, String dest_name) throws java.lang.Exception {
1:746585e:         org.apache.activemq.command.ActiveMQDestination dest;
1:746585e: 
1:746585e:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
1:4743a20:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name, org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE);
1:746585e:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:746585e:         }
1:746585e:     }
1:746585e: 
1:4743a20:     protected static void removeTopic(Connection conn, String dest_name) throws java.lang.Exception {
1:746585e:         org.apache.activemq.command.ActiveMQDestination dest;
1:746585e: 
1:746585e:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
1:4743a20:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name, org.apache.activemq.command.ActiveMQDestination.TOPIC_TYPE);
1:746585e:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:746585e:         }
1:746585e:     }
1:746585e: 
1:4743a20:     public static String fmtMsgInfo(Message msg) throws Exception {
1:746585e:         StringBuilder msg_desc;
1:746585e:         String prop;
1:4743a20:         Enumeration<?> prop_enum;
1:746585e: 
1:746585e:         msg_desc = new StringBuilder();
1:746585e:         msg_desc = new StringBuilder();
1:746585e: 
1:746585e:         if (msg instanceof TextMessage) {
1:746585e:             msg_desc.append(((TextMessage) msg).getText());
1:746585e:         } else {
1:746585e:             msg_desc.append("[");
1:746585e:             msg_desc.append(msg.getClass().getName());
1:746585e:             msg_desc.append("]");
1:746585e:         }
1:746585e: 
1:746585e:         prop_enum = msg.getPropertyNames();
1:746585e:         while (prop_enum.hasMoreElements()) {
1:746585e:             prop = (String) prop_enum.nextElement();
1:746585e:             msg_desc.append("; ");
1:746585e:             msg_desc.append(prop);
1:746585e:             msg_desc.append("=");
1:746585e:             msg_desc.append(msg.getStringProperty(prop));
1:746585e:         }
1:746585e: 
1:746585e:         return msg_desc.toString();
1:746585e:     }
1:746585e: 
1:746585e:     protected class EmbeddedTcpBroker {
1:746585e:         protected BrokerService brokerSvc;
1:746585e:         protected int brokerNum;
1:746585e:         protected String brokerName;
1:746585e:         protected String brokerId;
1:746585e:         protected int port;
1:746585e:         protected String tcpUrl;
1:746585e:         protected String fullUrl;
1:746585e: 
1:4743a20:         public EmbeddedTcpBroker(String name, int number) throws Exception {
1:746585e:             brokerSvc = new BrokerService();
1:746585e: 
1:746585e:             synchronized (this.getClass()) {
1:746585e:                 brokerNum = Next_broker_num;
1:746585e:                 Next_broker_num++;
1:746585e:             }
1:746585e: 
1:746585e:             brokerName = name + number;
1:746585e:             brokerId = brokerName;
1:746585e: 
1:746585e:             brokerSvc.setBrokerName(brokerName);
1:746585e:             brokerSvc.setBrokerId(brokerId);
1:746585e: 
1:746585e:             brokerSvc.setPersistent(false);
1:746585e:             brokerSvc.setUseJmx(false);
1:746585e: 
1:746585e:             port = 60000 + (brokerNum * 10);
1:746585e: 
1:746585e:             tcpUrl = "tcp://127.0.0.1:" + Integer.toString(port);
1:746585e:             fullUrl = tcpUrl + "?jms.watchTopicAdvisories=false";
1:746585e: 
1:746585e:             brokerSvc.addConnector(tcpUrl);
1:746585e:         }
1:746585e: 
1:4743a20:         public Connection createConnection() throws URISyntaxException, JMSException {
1:746585e:             Connection result;
1:746585e: 
1:746585e:             result = org.apache.activemq.ActiveMQConnection.makeConnection(this.fullUrl);
1:746585e: 
1:746585e:             return result;
1:746585e:         }
1:746585e: 
1:746585e:         public String getConnectionUrl() {
1:746585e:             return this.fullUrl;
1:746585e:         }
1:746585e: 
1:4743a20:         public void coreConnectTo(EmbeddedTcpBroker other, boolean duplex_f) throws Exception {
1:746585e:             this.makeConnectionTo(other, duplex_f, true);
1:746585e:             this.makeConnectionTo(other, duplex_f, false);
1:a8b6f8b:             if (!duplex_f) {
1:a8b6f8b:                 other.makeConnectionTo(this, duplex_f, true);
1:a8b6f8b:                 other.makeConnectionTo(this, duplex_f, false);
1:a8b6f8b:             }
1:746585e:         }
1:746585e: 
1:4743a20:         public void start() throws Exception {
1:746585e:             brokerSvc.start();
1:746585e:             brokerSvc.waitUntilStarted();
1:746585e:         }
1:746585e: 
1:4743a20:         public void stop() throws Exception {
1:746585e:             brokerSvc.stop();
1:746585e:         }
1:746585e: 
1:4743a20:         protected void makeConnectionTo(EmbeddedTcpBroker other, boolean duplex_f, boolean queue_f) throws Exception {
1:746585e:             NetworkConnector nw_conn;
1:746585e:             String prefix;
1:746585e:             ActiveMQDestination excl_dest;
1:4743a20:             ArrayList<ActiveMQDestination> excludes;
1:746585e: 
1:746585e:             nw_conn = new DiscoveryNetworkConnector(new URI("static:(" + other.tcpUrl + ")"));
1:746585e:             nw_conn.setDuplex(duplex_f);
1:746585e: 
1:746585e:             if (queue_f)
1:746585e:                 nw_conn.setConduitSubscriptions(false);
1:746585e:             else
1:746585e:                 nw_conn.setConduitSubscriptions(true);
1:746585e: 
1:746585e:             nw_conn.setNetworkTTL(3);
1:746585e:             nw_conn.setSuppressDuplicateQueueSubscriptions(true);
1:746585e:             nw_conn.setDecreaseNetworkConsumerPriority(true);
1:746585e:             nw_conn.setBridgeTempDestinations(queue_f);
1:746585e: 
1:746585e:             if (queue_f) {
1:746585e:                 prefix = "queue";
1:746585e:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.TOPIC_TYPE);
1:746585e:             } else {
1:746585e:                 prefix = "topic";
1:746585e:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.QUEUE_TYPE);
1:746585e:             }
1:746585e: 
1:4743a20:             excludes = new ArrayList<ActiveMQDestination>();
1:746585e:             excludes.add(excl_dest);
1:746585e:             nw_conn.setExcludedDestinations(excludes);
1:746585e: 
1:746585e:             if (duplex_f)
1:746585e:                 nw_conn.setName(this.brokerId + "<-" + prefix + "->" + other.brokerId);
1:746585e:             else
1:746585e:                 nw_conn.setName(this.brokerId + "-" + prefix + "->" + other.brokerId);
1:746585e: 
1:746585e:             brokerSvc.addNetworkConnector(nw_conn);
1:746585e:         }
1:746585e:     }
1:746585e: 
1:746585e:     protected class MessageClient extends java.lang.Thread {
1:746585e:         protected MessageConsumer msgCons;
1:746585e:         protected boolean shutdownInd;
1:746585e:         protected int expectedCount;
1:746585e:         protected int lastSeq = 0;
1:746585e:         protected int msgCount = 0;
1:746585e:         protected boolean haveFirstSeq;
1:746585e:         protected CountDownLatch shutdownLatch;
1:746585e: 
1:746585e:         public MessageClient(MessageConsumer cons, int num_to_expect) {
1:746585e:             msgCons = cons;
1:746585e:             expectedCount = (num_to_expect * (echoResponseFill + 1));
1:746585e:             shutdownLatch = new CountDownLatch(1);
1:746585e:         }
1:746585e: 
1:4743a20:         @Override
1:746585e:         public void run() {
1:746585e:             CountDownLatch latch;
1:746585e: 
1:746585e:             try {
1:746585e:                 synchronized (this) {
1:746585e:                     latch = shutdownLatch;
1:746585e:                 }
1:746585e: 
1:746585e:                 shutdownInd = false;
1:746585e:                 processMessages();
1:746585e: 
1:746585e:                 latch.countDown();
1:746585e:             } catch (Exception exc) {
1:746585e:                 LOG.error("message client error", exc);
1:746585e:             }
1:746585e:         }
1:746585e: 
1:746585e:         public void waitShutdown(long timeout) {
1:746585e:             CountDownLatch latch;
1:746585e: 
1:746585e:             try {
1:746585e:                 synchronized (this) {
1:746585e:                     latch = shutdownLatch;
1:746585e:                 }
1:746585e: 
1:746585e:                 if (latch != null)
1:746585e:                     latch.await(timeout, TimeUnit.MILLISECONDS);
1:746585e:                 else
1:746585e:                     LOG.info("echo client shutdown: client does not appear to be active");
1:746585e:             } catch (InterruptedException int_exc) {
1:746585e:                 LOG.warn("wait for message client shutdown interrupted", int_exc);
1:746585e:             }
1:746585e:         }
1:746585e: 
1:746585e:         public boolean shutdown() {
1:746585e:             boolean down_ind;
1:746585e: 
1:746585e:             if (!shutdownInd) {
1:746585e:                 shutdownInd = true;
1:746585e:             }
1:746585e: 
1:746585e:             waitShutdown(200);
1:746585e: 
1:746585e:             synchronized (this) {
1:746585e:                 if ((shutdownLatch == null) || (shutdownLatch.getCount() == 0))
1:746585e:                     down_ind = true;
1:746585e:                 else
1:746585e:                     down_ind = false;
1:746585e:             }
1:746585e: 
1:746585e:             return down_ind;
1:746585e:         }
1:746585e: 
1:746585e:         public int getNumMsgReceived() {
1:746585e:             return msgCount;
1:746585e:         }
1:746585e: 
1:4743a20:         protected void processMessages() throws Exception {
1:746585e:             Message in_msg;
1:746585e: 
1:746585e:             haveFirstSeq = false;
1:746585e: 
1:746585e:             //
1:746585e:             // Stop at shutdown time or after any test error is detected.
1:746585e:             //
1:746585e: 
1:746585e:             while ((!shutdownInd) && (!fatalTestError)) {
1:746585e:                 in_msg = msgCons.receive(100);
1:746585e: 
1:746585e:                 if (in_msg != null) {
1:746585e:                     msgCount++;
1:746585e:                     checkMessage(in_msg);
1:746585e:                 }
1:746585e:             }
1:746585e: 
1:746585e:             msgCons.close();
1:746585e:         }
1:746585e: 
1:4743a20:         protected void checkMessage(Message in_msg) throws Exception {
1:746585e:             int seq;
1:746585e: 
1:746585e:             LOG.debug("received message " + fmtMsgInfo(in_msg) + " from " + in_msg.getJMSDestination());
1:746585e: 
1:746585e:             //
1:746585e:             // Only check messages with a sequence number.
1:746585e:             //
1:746585e: 
1:746585e:             if (in_msg.propertyExists("SEQ")) {
1:746585e:                 seq = in_msg.getIntProperty("SEQ");
1:746585e: 
1:746585e:                 if ((haveFirstSeq) && (seq != (lastSeq + 1))) {
1:4743a20:                     LOG.error("***ERROR*** incorrect sequence number; expected " + Integer.toString(lastSeq + 1) + " but have " + Integer.toString(seq));
1:746585e: 
1:746585e:                     testError = true;
1:746585e:                 }
1:746585e: 
1:746585e:                 lastSeq = seq;
1:746585e: 
1:746585e:                 if (msgCount > expectedCount) {
1:4743a20:                     LOG.error("*** have more messages than expected; have " + msgCount + "; expect " + expectedCount);
1:746585e: 
1:746585e:                     testError = true;
1:746585e:                 }
1:746585e:             }
1:746585e: 
1:746585e:             if (in_msg.propertyExists("end-of-response")) {
1:746585e:                 LOG.trace("received end-of-response message");
1:746585e:             }
1:746585e:         }
1:746585e:     }
1:746585e: 
1:746585e:     /**
1:746585e:      *
1:746585e:      */
1:746585e:     protected class EchoService extends java.lang.Thread {
1:746585e:         protected String destName;
1:746585e:         protected Connection jmsConn;
1:746585e:         protected Session sess;
1:746585e:         protected MessageConsumer msg_cons;
1:746585e:         protected boolean Shutdown_ind;
1:746585e: 
1:746585e:         protected Destination req_dest;
1:746585e: 
1:746585e:         protected CountDownLatch waitShutdown;
1:746585e: 
1:746585e:         protected ThreadPoolExecutor processorPool;
1:746585e: 
1:4743a20:         public EchoService(String dest, Connection broker_conn) throws Exception {
1:746585e:             destName = dest;
1:746585e:             jmsConn = broker_conn;
1:746585e: 
1:746585e:             Shutdown_ind = false;
1:746585e: 
1:746585e:             sess = jmsConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:746585e:             req_dest = sess.createQueue(destName);
1:746585e:             msg_cons = sess.createConsumer(req_dest);
1:746585e: 
1:746585e:             jmsConn.start();
1:746585e: 
1:746585e:             waitShutdown = new CountDownLatch(1);
1:746585e: 
1:4743a20:             processorPool = new ThreadPoolExecutor(CONCURRENT_SERVER_COUNT, CONCURRENT_SERVER_COUNT, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(
1:4743a20:                 10000));
1:746585e:         }
1:746585e: 
1:4743a20:         public EchoService(String dest, String broker_url) throws Exception {
1:746585e:             this(dest, ActiveMQConnection.makeConnection(broker_url));
1:746585e:         }
1:746585e: 
1:4743a20:         @Override
1:746585e:         public void run() {
1:746585e:             Message req;
1:746585e: 
1:746585e:             try {
1:746585e:                 LOG.info("STARTING ECHO SERVICE");
1:746585e: 
1:746585e:                 while (!Shutdown_ind) {
1:746585e:                     req = msg_cons.receive(100);
1:746585e:                     if (req != null) {
1:746585e:                         processorPool.execute(new EchoRequestProcessor(sess, req));
1:746585e:                     }
1:746585e:                 }
1:746585e:             } catch (Exception ex) {
1:746585e:                 LOG.error("error processing echo service requests", ex);
1:746585e:             } finally {
1:746585e:                 LOG.info("shutting down test echo service");
1:746585e: 
1:746585e:                 try {
1:746585e:                     jmsConn.stop();
1:746585e:                 } catch (javax.jms.JMSException jms_exc) {
1:746585e:                     LOG.warn("error on shutting down JMS connection", jms_exc);
1:746585e:                 }
1:746585e: 
1:746585e:                 synchronized (this) {
1:746585e:                     waitShutdown.countDown();
1:746585e:                 }
1:746585e:             }
1:746585e:         }
1:746585e: 
1:746585e:         /**
1:746585e:          * Shut down the service, waiting up to 3 seconds for the service to terminate.
1:746585e:          */
1:746585e:         public void shutdown() {
1:746585e:             CountDownLatch wait_l;
1:746585e: 
1:746585e:             synchronized (this) {
1:746585e:                 wait_l = waitShutdown;
1:746585e:             }
1:746585e: 
1:746585e:             Shutdown_ind = true;
1:746585e: 
1:746585e:             try {
1:746585e:                 if (wait_l != null) {
1:746585e:                     if (wait_l.await(3000, TimeUnit.MILLISECONDS))
1:746585e:                         LOG.info("echo service shutdown complete");
1:746585e:                     else
1:746585e:                         LOG.warn("timeout waiting for echo service shutdown");
1:746585e:                 } else {
1:746585e:                     LOG.info("echo service shutdown: service does not appear to be active");
1:746585e:                 }
1:746585e:             } catch (InterruptedException int_exc) {
1:746585e:                 LOG.warn("interrupted while waiting for echo service shutdown");
1:746585e:             }
1:746585e:         }
1:746585e:     }
1:746585e: 
1:746585e:     /**
1:746585e:      *
1:746585e:      */
1:746585e:     protected class EchoRequestProcessor implements Runnable {
1:746585e:         protected Session session;
1:746585e: 
1:746585e:         protected Destination resp_dest;
1:746585e:         protected MessageProducer msg_prod;
1:746585e: 
1:746585e:         protected Message request;
1:746585e: 
1:4743a20:         public EchoRequestProcessor(Session sess, Message req) throws Exception {
1:746585e:             this.session = sess;
1:746585e:             this.request = req;
1:746585e: 
1:746585e:             this.resp_dest = req.getJMSReplyTo();
1:746585e: 
1:746585e:             if (resp_dest == null) {
1:746585e:                 throw new Exception("invalid request: no reply-to destination given");
1:746585e:             }
1:746585e: 
1:746585e:             this.msg_prod = session.createProducer(this.resp_dest);
1:746585e:         }
1:746585e: 
1:4743a20:         @Override
1:746585e:         public void run() {
1:746585e:             try {
1:746585e:                 this.processRequest(this.request);
1:746585e:             } catch (Exception ex) {
1:746585e:                 LOG.error("Failed to process request", ex);
1:746585e:             }
1:746585e:         }
1:746585e: 
1:746585e:         /**
1:746585e:          * Process one request for the Echo Service.
1:746585e:          */
1:4743a20:         protected void processRequest(Message req) throws Exception {
1:746585e:             if (LOG.isDebugEnabled())
1:746585e:                 LOG.debug("ECHO request message " + req.toString());
1:746585e: 
1:746585e:             resp_dest = req.getJMSReplyTo();
1:746585e:             if (resp_dest != null) {
1:746585e:                 msg_prod = session.createProducer(resp_dest);
1:746585e: 
1:746585e:                 LOG.debug("SENDING ECHO RESPONSE to:" + resp_dest);
1:746585e: 
1:746585e:                 msg_prod.send(req);
1:746585e: 
1:746585e:                 LOG.debug((((ActiveMQSession) session).getConnection()).getBrokerName() + " SENT ECHO RESPONSE to " + resp_dest);
1:746585e: 
1:746585e:                 msg_prod.close();
1:746585e:                 msg_prod = null;
1:746585e:             } else {
1:746585e:                 LOG.warn("invalid request: no reply-to destination given");
1:746585e:             }
1:746585e:         }
1:746585e:     }
1:746585e: 
1:746585e:     protected class TopicTrafficGenerator extends java.lang.Thread {
1:746585e:         protected Connection conn1;
1:746585e:         protected Connection conn2;
1:746585e:         protected Session sess1;
1:746585e:         protected Session sess2;
1:746585e:         protected Destination dest;
1:746585e:         protected MessageProducer prod;
1:746585e:         protected MessageConsumer cons;
1:746585e:         protected boolean Shutdown_ind;
1:746585e:         protected int send_count;
1:746585e: 
1:4743a20:         public TopicTrafficGenerator(String url1, String url2) throws Exception {
1:746585e:             conn1 = createConnection(url1);
1:746585e:             conn2 = createConnection(url2);
1:746585e: 
1:746585e:             sess1 = conn1.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:746585e:             sess2 = conn2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:746585e: 
1:746585e:             conn1.start();
1:746585e:             conn2.start();
1:746585e: 
1:746585e:             dest = sess1.createTopic("traffic");
1:746585e:             prod = sess1.createProducer(dest);
1:746585e: 
1:746585e:             dest = sess2.createTopic("traffic");
1:746585e:             cons = sess2.createConsumer(dest);
1:746585e:         }
1:746585e: 
1:746585e:         public void shutdown() {
1:746585e:             Shutdown_ind = true;
1:746585e:         }
1:746585e: 
1:4743a20:         @Override
1:746585e:         public void run() {
1:746585e:             Message msg;
1:746585e: 
1:746585e:             try {
1:746585e:                 LOG.info("Starting Topic Traffic Generator");
1:746585e: 
1:746585e:                 while (!Shutdown_ind) {
1:746585e:                     msg = sess1.createTextMessage("TRAFFIC");
1:746585e: 
1:746585e:                     prod.send(msg);
1:746585e: 
1:746585e:                     send_count++;
1:746585e: 
1:746585e:                     //
1:746585e:                     // Time out the receipt; early messages may not make it.
1:746585e:                     //
1:746585e: 
1:746585e:                     msg = cons.receive(250);
1:746585e:                 }
1:746585e:             } catch (JMSException jms_exc) {
1:746585e:                 LOG.warn("traffic generator failed on jms exception", jms_exc);
1:746585e:             } finally {
1:746585e:                 LOG.info("Shutdown of Topic Traffic Generator; send count = " + send_count);
1:746585e: 
1:746585e:                 if (conn1 != null) {
1:746585e:                     try {
1:746585e:                         conn1.stop();
1:746585e:                     } catch (JMSException jms_exc) {
1:746585e:                         LOG.warn("failed to shutdown connection", jms_exc);
1:746585e:                     }
1:746585e:                 }
1:746585e: 
1:746585e:                 if (conn2 != null) {
1:746585e:                     try {
1:746585e:                         conn2.stop();
1:746585e:                     } catch (JMSException jms_exc) {
1:746585e:                         LOG.warn("failed to shutdown connection", jms_exc);
1:746585e:                     }
1:746585e:                 }
1:746585e:             }
1:746585e:         }
1:746585e:     }
1:746585e: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:4743a20
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertTrue;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected int echoResponseFill = 0; // Number of "filler" response messages per request
/////////////////////////////////////////////////////////////////////////
1:     public RequestReplyToTopicViaThreeNetworkHopsTest() throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testMessages(Session sess, MessageProducer req_prod, Destination resp_dest, int num_msg) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Have " + cons_client.getNumMsgReceived() + " messages; expected " + tot_expected + " on destination " + resp_dest);
1:     protected void sendWithRetryOnDeletedDest(MessageProducer prod, Message msg) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:     public void testOneDest(Connection conn, Session sess, Destination cons_dest, int num_msg) throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testTempTopic(String prod_broker_url, String cons_broker_url) throws Exception {
1:         LOG.debug("TESTING TEMP TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:     public void testTopic(String prod_broker_url, String cons_broker_url) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("TESTING TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
/////////////////////////////////////////////////////////////////////////
1:     public void testTempQueue(String prod_broker_url, String cons_broker_url) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("TESTING TEMP QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
1:     public void testQueue(String prod_broker_url, String cons_broker_url) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("TESTING QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg + " messages)");
/////////////////////////////////////////////////////////////////////////
1:     public void runWithTempTopicReplyTo() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         clientExecPool = new ThreadPoolExecutor(CONCURRENT_CLIENT_COUNT, CONCURRENT_CLIENT_COUNT, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10000));
1:         // it knows the name of the remote broker before finishing its startup, which means
1:         // the remote must already be running.
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                         RequestReplyToTopicViaThreeNetworkHopsTest.this.testTempTopic(edge1.getConnectionUrl(), edge2.getConnectionUrl());
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("** FINISHED TEMP TOPIC TESTS AFTER " + iter + " ITERATIONS, testError:" + testError + ", fatal: " + fatalTestError + ", onTime:"
1:             + allDoneOnTime);
/////////////////////////////////////////////////////////////////////////
1:     public void shutdown() throws Exception {
1:     protected Connection createConnection(String url) throws Exception {
1:     protected static void removeQueue(Connection conn, String dest_name) throws java.lang.Exception {
1:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name, org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE);
1:     protected static void removeTopic(Connection conn, String dest_name) throws java.lang.Exception {
1:             dest = org.apache.activemq.command.ActiveMQDestination.createDestination(dest_name, org.apache.activemq.command.ActiveMQDestination.TOPIC_TYPE);
1:     public static String fmtMsgInfo(Message msg) throws Exception {
1:         Enumeration<?> prop_enum;
/////////////////////////////////////////////////////////////////////////
1:         public EmbeddedTcpBroker(String name, int number) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         public Connection createConnection() throws URISyntaxException, JMSException {
/////////////////////////////////////////////////////////////////////////
1:         public void coreConnectTo(EmbeddedTcpBroker other, boolean duplex_f) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         public void start() throws Exception {
1:         public void stop() throws Exception {
1:         protected void makeConnectionTo(EmbeddedTcpBroker other, boolean duplex_f, boolean queue_f) throws Exception {
1:             ArrayList<ActiveMQDestination> excludes;
/////////////////////////////////////////////////////////////////////////
1:             excludes = new ArrayList<ActiveMQDestination>();
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         protected void processMessages() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         protected void checkMessage(Message in_msg) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("***ERROR*** incorrect sequence number; expected " + Integer.toString(lastSeq + 1) + " but have " + Integer.toString(seq));
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("*** have more messages than expected; have " + msgCount + "; expect " + expectedCount);
/////////////////////////////////////////////////////////////////////////
1:         public EchoService(String dest, Connection broker_conn) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             processorPool = new ThreadPoolExecutor(CONCURRENT_SERVER_COUNT, CONCURRENT_SERVER_COUNT, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(
1:                 10000));
1:         public EchoService(String dest, String broker_url) throws Exception {
1:         @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         public EchoRequestProcessor(Session sess, Message req) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:         protected void processRequest(Message req) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         public TopicTrafficGenerator(String url1, String url2) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         @Override
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:a8b6f8b
/////////////////////////////////////////////////////////////////////////
1:     public boolean duplex = true;
/////////////////////////////////////////////////////////////////////////
1:         edge1.coreConnectTo(core1, duplex);
1:         edge2.coreConnectTo(core2, duplex);
1:         core1.coreConnectTo(core2, duplex);
/////////////////////////////////////////////////////////////////////////
1:             if (!duplex_f) {
1:                 other.makeConnectionTo(this, duplex_f, true);
1:                 other.makeConnectionTo(this, duplex_f, false);
1:             }
commit:746585e
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.usecases;
1: 
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.concurrent.ArrayBlockingQueue;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import javax.jms.Connection;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQSession;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.commons.logging.Log;
1: import org.apache.commons.logging.LogFactory;
1: import org.junit.Test;
1: 
0: import static org.junit.Assert.assertTrue;
1: 
1: 
1: public class RequestReplyToTopicViaThreeNetworkHopsTest {
1:     protected static final int CONCURRENT_CLIENT_COUNT = 5;
1:     protected static final int CONCURRENT_SERVER_COUNT = 5;
1:     protected static final int TOTAL_CLIENT_ITER = 10;
1: 
1:     protected static int Next_broker_num = 0;
1:     protected EmbeddedTcpBroker edge1;
1:     protected EmbeddedTcpBroker edge2;
1:     protected EmbeddedTcpBroker core1;
1:     protected EmbeddedTcpBroker core2;
1: 
1:     protected boolean testError = false;
1:     protected boolean fatalTestError = false;
1: 
0:     protected int echoResponseFill = 0;   // Number of "filler" response messages per request
1: 
1:     protected static Log LOG;
1: 
1:     static {
1:         LOG = LogFactory.getLog(RequestReplyToTopicViaThreeNetworkHopsTest.class);
1:     }
1: 
0:     public RequestReplyToTopicViaThreeNetworkHopsTest()
0:             throws Exception {
1:         edge1 = new EmbeddedTcpBroker("edge", 1);
1:         edge2 = new EmbeddedTcpBroker("edge", 2);
1:         core1 = new EmbeddedTcpBroker("core", 1);
1:         core2 = new EmbeddedTcpBroker("core", 2);
1: 
1:         // duplex is necessary to serialise sends with consumer/destination creation
0:         edge1.coreConnectTo(core1, true);
0:         edge2.coreConnectTo(core2, true);
0:         core1.coreConnectTo(core2, true);
1: 
1:     }
1: 
1:     public void logMessage(String msg) {
1:         System.out.println(msg);
1:         System.out.flush();
1:     }
1: 
0:     public void testMessages(Session sess, MessageProducer req_prod, Destination resp_dest, int num_msg)
0:             throws Exception {
1:         MessageConsumer resp_cons;
1:         TextMessage msg;
1:         MessageClient cons_client;
1:         int cur;
1:         int tot_expected;
1: 
1:         resp_cons = sess.createConsumer(resp_dest);
1: 
1:         cons_client = new MessageClient(resp_cons, num_msg);
1:         cons_client.start();
1: 
1:         cur = 0;
1:         while ((cur < num_msg) && (!fatalTestError)) {
1:             msg = sess.createTextMessage("MSG AAAA " + cur);
1:             msg.setIntProperty("SEQ", 100 + cur);
1:             msg.setStringProperty("TEST", "TOPO");
1:             msg.setJMSReplyTo(resp_dest);
1: 
1:             if (cur == (num_msg - 1))
1:                 msg.setBooleanProperty("end-of-response", true);
1: 
1:             sendWithRetryOnDeletedDest(req_prod, msg);
1:             LOG.debug("Sent:" + msg);
1: 
1:             cur++;
1:         }
1: 
1:         //
1:         // Give the consumer some time to receive the response.
1:         //
1:         cons_client.waitShutdown(5000);
1: 
1:         //
1:         // Now shutdown the consumer if it's still running.
1:         //
1:         if (cons_client.shutdown())
1:             LOG.debug("Consumer client shutdown complete");
1:         else
1:             LOG.debug("Consumer client shutdown incomplete!!!");
1: 
1: 
1:         //
1:         // Check that the correct number of messages was received.
1:         //
1:         tot_expected = num_msg * (echoResponseFill + 1);
1: 
1:         if (cons_client.getNumMsgReceived() == tot_expected) {
1:             LOG.debug("Have " + tot_expected + " messages, as-expected");
1:         } else {
1:             testError = true;
1: 
1:             if (cons_client.getNumMsgReceived() == 0)
1:                 fatalTestError = true;
1: 
0:             LOG.error("Have " + cons_client.getNumMsgReceived() + " messages; expected " + tot_expected +
0:                     " on destination " + resp_dest);
1:         }
1: 
1:         resp_cons.close();
1:     }
1: 
0:     protected void sendWithRetryOnDeletedDest(MessageProducer prod, Message msg)
0:             throws JMSException {
1:         try {
1:             if (LOG.isDebugEnabled())
1:                 LOG.debug("SENDING REQUEST message " + msg);
1: 
1:             prod.send(msg);
1:         } catch (JMSException jms_exc) {
1:             System.out.println("AAA: " + jms_exc.getMessage());
1:             throw jms_exc;
1:         }
1:     }
1: 
1:     /**
1:      * Test one destination between the given "producer broker" and "consumer broker" specified.
1:      */
0:     public void testOneDest(Connection conn, Session sess, Destination cons_dest, int num_msg)
0:             throws Exception {
1:         Destination prod_dest;
1:         MessageProducer msg_prod;
1: 
1: 
1:         //
1:         // Create the Producer to the echo request Queue
1:         //
1:         LOG.trace("Creating echo queue and producer");
1:         prod_dest = sess.createQueue("echo");
1:         msg_prod = sess.createProducer(prod_dest);
1: 
1: 
1:         //
1:         // Pass messages around.
1:         //
1:         testMessages(sess, msg_prod, cons_dest, num_msg);
1: 
1:         msg_prod.close();
1:     }
1: 
1: 
1:     /**
1:      * TEST TEMPORARY TOPICS
1:      */
0:     public void testTempTopic(String prod_broker_url, String cons_broker_url)
0:             throws Exception {
1:         Connection conn;
1:         Session sess;
1:         Destination cons_dest;
0:         int echo_id;
1:         int num_msg;
1: 
1:         num_msg = 5;
1: 
0:         LOG.debug("TESTING TEMP TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0:                 " messages)");
1: 
1: 
1:         //
1:         // Connect to the bus.
1:         //
1: 
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
1:         //
1:         // Create the destination on which messages are being tested.
1:         //
1: 
1:         LOG.trace("Creating destination");
1:         cons_dest = sess.createTemporaryTopic();
1: 
1:         testOneDest(conn, sess, cons_dest, num_msg);
1: 
1: 
1:         //
1:         // Cleanup
1:         //
1: 
1:         sess.close();
1:         conn.close();
1:     }
1: 
1: 
1:     /**
1:      * TEST TOPICS
1:      */
0:     public void testTopic(String prod_broker_url, String cons_broker_url)
0:             throws Exception {
1:         int num_msg;
1: 
1:         Connection conn;
1:         Session sess;
1:         String topic_name;
1: 
1:         Destination cons_dest;
1: 
1:         num_msg = 5;
1: 
0:         LOG.info("TESTING TOPICS " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0:                 " messages)");
1: 
1: 
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
1:         //
1:         // Create the destination on which messages are being tested.
1:         //
1: 
1:         topic_name = "topotest2.perm.topic";
1:         LOG.trace("Removing existing Topic");
1:         removeTopic(conn, topic_name);
1:         LOG.trace("Creating Topic, " + topic_name);
1:         cons_dest = sess.createTopic(topic_name);
1: 
1:         testOneDest(conn, sess, cons_dest, num_msg);
1: 
1: 
1:         //
1:         // Cleanup
1:         //
1: 
1:         removeTopic(conn, topic_name);
1:         sess.close();
1:         conn.close();
1:     }
1: 
1: 
1:     /**
1:      * TEST TEMPORARY QUEUES
1:      */
0:     public void testTempQueue(String prod_broker_url, String cons_broker_url)
0:             throws Exception {
0:         int echo_id;
1:         int num_msg;
1: 
1:         Connection conn;
1:         Session sess;
1: 
1:         Destination cons_dest;
1: 
1:         num_msg = 5;
1: 
0:         LOG.info("TESTING TEMP QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0:                 " messages)");
1: 
1: 
1:         //
1:         // Connect to the bus.
1:         //
1: 
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
1:         //
1:         // Create the destination on which messages are being tested.
1:         //
1: 
1:         LOG.trace("Creating destination");
1:         cons_dest = sess.createTemporaryQueue();
1: 
1:         testOneDest(conn, sess, cons_dest, num_msg);
1: 
1: 
1:         //
1:         // Cleanup
1:         //
1: 
1:         sess.close();
1:         conn.close();
1:     }
1: 
1: 
1:     /**
1:      * TEST QUEUES
1:      */
0:     public void testQueue(String prod_broker_url, String cons_broker_url)
0:             throws Exception {
1:         int num_msg;
1: 
1:         Connection conn;
1:         Session sess;
1:         String queue_name;
1: 
1:         Destination cons_dest;
1: 
1:         num_msg = 5;
1: 
0:         LOG.info("TESTING QUEUES " + prod_broker_url + " -> " + cons_broker_url + " (" + num_msg +
0:                 " messages)");
1: 
1: 
1:         conn = createConnection(cons_broker_url);
1:         conn.start();
1:         sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1: 
1:         //
1:         // Create the destination on which messages are being tested.
1:         //
1:         queue_name = "topotest2.perm.queue";
1:         LOG.trace("Removing existing Queue");
1:         removeQueue(conn, queue_name);
1:         LOG.trace("Creating Queue, " + queue_name);
1:         cons_dest = sess.createQueue(queue_name);
1: 
1:         testOneDest(conn, sess, cons_dest, num_msg);
1: 
1: 
1:         removeQueue(conn, queue_name);
1:         sess.close();
1:         conn.close();
1:     }
1: 
1:     @Test
0:     public void runWithTempTopicReplyTo()
0:             throws Exception {
1:         EchoService echo_svc;
1:         TopicTrafficGenerator traffic_gen;
1:         Thread start1;
1:         Thread start2;
1:         Thread start3;
1:         Thread start4;
1:         ThreadPoolExecutor clientExecPool;
1:         final CountDownLatch clientCompletionLatch;
1:         int iter;
1: 
1:         fatalTestError = false;
1:         testError = false;
1: 
1:         //
1:         // Execute up to 20 clients at a time to simulate that load.
1:         //
1: 
0:         clientExecPool = new ThreadPoolExecutor(CONCURRENT_CLIENT_COUNT, CONCURRENT_CLIENT_COUNT,
0:                 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10000));
1:         clientCompletionLatch = new CountDownLatch(TOTAL_CLIENT_ITER);
1: 
1: 
1:         // Use threads to avoid startup deadlock since the first broker started waits until
0:         //	it knows the name of the remote broker before finishing its startup, which means
0:         //	the remote must already be running.
1: 
1:         start1 = new Thread() {
1:             public void run() {
1:                 try {
1:                     edge1.start();
1:                 } catch (Exception ex) {
1:                     LOG.error(null, ex);
1:                 }
1:             }
1:         };
1: 
1:         start2 = new Thread() {
1:             public void run() {
1:                 try {
1:                     edge2.start();
1:                 } catch (Exception ex) {
1:                     LOG.error(null, ex);
1:                 }
1:             }
1:         };
1: 
1:         start3 = new Thread() {
1:             public void run() {
1:                 try {
1:                     core1.start();
1:                 } catch (Exception ex) {
1:                     LOG.error(null, ex);
1:                 }
1:             }
1:         };
1: 
1:         start4 = new Thread() {
1:             public void run() {
1:                 try {
1:                     core2.start();
1:                 } catch (Exception ex) {
1:                     LOG.error(null, ex);
1:                 }
1:             }
1:         };
1: 
1:         start1.start();
1:         start2.start();
1:         start3.start();
1:         start4.start();
1: 
1:         start1.join();
1:         start2.join();
1:         start3.join();
1:         start4.join();
1: 
1:         traffic_gen = new TopicTrafficGenerator(edge1.getConnectionUrl(), edge2.getConnectionUrl());
1:         traffic_gen.start();
1: 
1: 
1:         //
1:         // Now start the echo service with that queue.
1:         //
1:         echo_svc = new EchoService("echo", edge1.getConnectionUrl());
1:         echo_svc.start();
1: 
1: 
1:         //
1:         // Run the tests on Temp Topics.
1:         //
1: 
1:         LOG.info("** STARTING TEMP TOPIC TESTS");
1:         iter = 0;
1:         while ((iter < TOTAL_CLIENT_ITER) && (!fatalTestError)) {
1:             clientExecPool.execute(new Runnable() {
1:                 public void run() {
1:                     try {
0:                         RequestReplyToTopicViaThreeNetworkHopsTest.this.testTempTopic(edge1.getConnectionUrl(),
0:                                 edge2.getConnectionUrl());
1:                     } catch (Exception exc) {
1:                         LOG.error("test exception", exc);
1:                         fatalTestError = true;
1:                         testError = true;
1:                     }
1: 
1:                     clientCompletionLatch.countDown();
1:                 }
1:             });
1: 
1:             iter++;
1:         }
1: 
1:         boolean allDoneOnTime = clientCompletionLatch.await(20, TimeUnit.MINUTES);
1: 
0:         LOG.info("** FINISHED TEMP TOPIC TESTS AFTER " + iter + " ITERATIONS, testError:" + testError + ", fatal: " + fatalTestError + ", onTime:" + allDoneOnTime);
1: 
1:         Thread.sleep(100);
1: 
1:         echo_svc.shutdown();
1:         traffic_gen.shutdown();
1: 
1:         shutdown();
1: 
1:         assertTrue("test completed in time", allDoneOnTime);
1:         assertTrue("no errors", !testError);
1:     }
1: 
0:     public void shutdown()
0:             throws Exception {
1:         edge1.stop();
1:         edge2.stop();
1:         core1.stop();
1:         core2.stop();
1:     }
1: 
0:     protected Connection createConnection(String url)
0:             throws Exception {
1:         return org.apache.activemq.ActiveMQConnection.makeConnection(url);
1:     }
1: 
0:     protected static void removeQueue(Connection conn, String dest_name)
0:             throws java.lang.Exception {
1:         org.apache.activemq.command.ActiveMQDestination dest;
1: 
1:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
0:             dest = org.apache.activemq.command.ActiveMQDestination.
0:                     createDestination(dest_name, (byte) org.apache.activemq.command.ActiveMQDestination.QUEUE_TYPE);
1:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:         }
1:     }
1: 
0:     protected static void removeTopic(Connection conn, String dest_name)
0:             throws java.lang.Exception {
1:         org.apache.activemq.command.ActiveMQDestination dest;
1: 
1:         if (conn instanceof org.apache.activemq.ActiveMQConnection) {
0:             dest = org.apache.activemq.command.ActiveMQDestination.
0:                     createDestination(dest_name, (byte) org.apache.activemq.command.ActiveMQDestination.TOPIC_TYPE);
1:             ((org.apache.activemq.ActiveMQConnection) conn).destroyDestination(dest);
1:         }
1:     }
1: 
0:     public static String fmtMsgInfo(Message msg)
0:             throws Exception {
1:         StringBuilder msg_desc;
1:         String prop;
0:         Enumeration prop_enum;
1: 
1:         msg_desc = new StringBuilder();
1:         msg_desc = new StringBuilder();
1: 
1:         if (msg instanceof TextMessage) {
1:             msg_desc.append(((TextMessage) msg).getText());
1:         } else {
1:             msg_desc.append("[");
1:             msg_desc.append(msg.getClass().getName());
1:             msg_desc.append("]");
1:         }
1: 
1:         prop_enum = msg.getPropertyNames();
1:         while (prop_enum.hasMoreElements()) {
1:             prop = (String) prop_enum.nextElement();
1:             msg_desc.append("; ");
1:             msg_desc.append(prop);
1:             msg_desc.append("=");
1:             msg_desc.append(msg.getStringProperty(prop));
1:         }
1: 
1:         return msg_desc.toString();
1:     }
1: 
1:     protected class EmbeddedTcpBroker {
1:         protected BrokerService brokerSvc;
1:         protected int brokerNum;
1:         protected String brokerName;
1:         protected String brokerId;
1:         protected int port;
1:         protected String tcpUrl;
1:         protected String fullUrl;
1: 
0:         public EmbeddedTcpBroker(String name, int number)
0:                 throws Exception {
1:             brokerSvc = new BrokerService();
1: 
1:             synchronized (this.getClass()) {
1:                 brokerNum = Next_broker_num;
1:                 Next_broker_num++;
1:             }
1: 
1:             brokerName = name + number;
1:             brokerId = brokerName;
1: 
1:             brokerSvc.setBrokerName(brokerName);
1:             brokerSvc.setBrokerId(brokerId);
1: 
1:             brokerSvc.setPersistent(false);
1:             brokerSvc.setUseJmx(false);
1: 
1:             port = 60000 + (brokerNum * 10);
1: 
1:             tcpUrl = "tcp://127.0.0.1:" + Integer.toString(port);
1:             fullUrl = tcpUrl + "?jms.watchTopicAdvisories=false";
1: 
1:             brokerSvc.addConnector(tcpUrl);
1:         }
1: 
0:         public Connection createConnection()
0:                 throws URISyntaxException, JMSException {
1:             Connection result;
1: 
1:             result = org.apache.activemq.ActiveMQConnection.makeConnection(this.fullUrl);
1: 
1:             return result;
1:         }
1: 
1:         public String getConnectionUrl() {
1:             return this.fullUrl;
1:         }
1: 
1: 
0:         public void coreConnectTo(EmbeddedTcpBroker other, boolean duplex_f)
0:                 throws Exception {
1:             this.makeConnectionTo(other, duplex_f, true);
1:             this.makeConnectionTo(other, duplex_f, false);
1:         }
1: 
0:         public void start()
0:                 throws Exception {
1:             brokerSvc.start();
1:             brokerSvc.waitUntilStarted();
1:         }
1: 
0:         public void stop()
0:                 throws Exception {
1:             brokerSvc.stop();
1:         }
1: 
1: 
0:         protected void makeConnectionTo(EmbeddedTcpBroker other, boolean duplex_f, boolean queue_f)
0:                 throws Exception {
1:             NetworkConnector nw_conn;
1:             String prefix;
1:             ActiveMQDestination excl_dest;
0:             ArrayList excludes;
1: 
1:             nw_conn = new DiscoveryNetworkConnector(new URI("static:(" + other.tcpUrl + ")"));
1:             nw_conn.setDuplex(duplex_f);
1: 
1:             if (queue_f)
1:                 nw_conn.setConduitSubscriptions(false);
1:             else
1:                 nw_conn.setConduitSubscriptions(true);
1: 
1:             nw_conn.setNetworkTTL(3);
1:             nw_conn.setSuppressDuplicateQueueSubscriptions(true);
1:             nw_conn.setDecreaseNetworkConsumerPriority(true);
1:             nw_conn.setBridgeTempDestinations(queue_f);
1: 
1:             if (queue_f) {
1:                 prefix = "queue";
1:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.TOPIC_TYPE);
1:             } else {
1:                 prefix = "topic";
1:                 excl_dest = ActiveMQDestination.createDestination(">", ActiveMQDestination.QUEUE_TYPE);
1:             }
1: 
0:             excludes = new ArrayList();
1:             excludes.add(excl_dest);
1:             nw_conn.setExcludedDestinations(excludes);
1: 
1:             if (duplex_f)
1:                 nw_conn.setName(this.brokerId + "<-" + prefix + "->" + other.brokerId);
1:             else
1:                 nw_conn.setName(this.brokerId + "-" + prefix + "->" + other.brokerId);
1: 
1:             brokerSvc.addNetworkConnector(nw_conn);
1:         }
1:     }
1: 
1:     protected class MessageClient extends java.lang.Thread {
1:         protected MessageConsumer msgCons;
1:         protected boolean shutdownInd;
1:         protected int expectedCount;
1:         protected int lastSeq = 0;
1:         protected int msgCount = 0;
1:         protected boolean haveFirstSeq;
1:         protected CountDownLatch shutdownLatch;
1: 
1:         public MessageClient(MessageConsumer cons, int num_to_expect) {
1:             msgCons = cons;
1:             expectedCount = (num_to_expect * (echoResponseFill + 1));
1:             shutdownLatch = new CountDownLatch(1);
1:         }
1: 
1:         public void run() {
1:             CountDownLatch latch;
1: 
1:             try {
1:                 synchronized (this) {
1:                     latch = shutdownLatch;
1:                 }
1: 
1:                 shutdownInd = false;
1:                 processMessages();
1: 
1:                 latch.countDown();
1:             } catch (Exception exc) {
1:                 LOG.error("message client error", exc);
1:             }
1:         }
1: 
1:         public void waitShutdown(long timeout) {
1:             CountDownLatch latch;
1: 
1:             try {
1:                 synchronized (this) {
1:                     latch = shutdownLatch;
1:                 }
1: 
1:                 if (latch != null)
1:                     latch.await(timeout, TimeUnit.MILLISECONDS);
1:                 else
1:                     LOG.info("echo client shutdown: client does not appear to be active");
1:             } catch (InterruptedException int_exc) {
1:                 LOG.warn("wait for message client shutdown interrupted", int_exc);
1:             }
1:         }
1: 
1:         public boolean shutdown() {
1:             boolean down_ind;
1: 
1:             if (!shutdownInd) {
1:                 shutdownInd = true;
1:             }
1: 
1:             waitShutdown(200);
1: 
1:             synchronized (this) {
1:                 if ((shutdownLatch == null) || (shutdownLatch.getCount() == 0))
1:                     down_ind = true;
1:                 else
1:                     down_ind = false;
1:             }
1: 
1:             return down_ind;
1:         }
1: 
1:         public int getNumMsgReceived() {
1:             return msgCount;
1:         }
1: 
0:         protected void processMessages()
0:                 throws Exception {
1:             Message in_msg;
1: 
1:             haveFirstSeq = false;
1: 
1:             //
1:             // Stop at shutdown time or after any test error is detected.
1:             //
1: 
1:             while ((!shutdownInd) && (!fatalTestError)) {
1:                 in_msg = msgCons.receive(100);
1: 
1:                 if (in_msg != null) {
1:                     msgCount++;
1:                     checkMessage(in_msg);
1:                 }
1:             }
1: 
1:             msgCons.close();
1:         }
1: 
0:         protected void checkMessage(Message in_msg)
0:                 throws Exception {
1:             int seq;
1: 
1:             LOG.debug("received message " + fmtMsgInfo(in_msg) + " from " + in_msg.getJMSDestination());
1: 
1:             //
1:             // Only check messages with a sequence number.
1:             //
1: 
1:             if (in_msg.propertyExists("SEQ")) {
1:                 seq = in_msg.getIntProperty("SEQ");
1: 
1:                 if ((haveFirstSeq) && (seq != (lastSeq + 1))) {
0:                     LOG.error("***ERROR*** incorrect sequence number; expected " +
0:                             Integer.toString(lastSeq + 1) + " but have " +
0:                             Integer.toString(seq));
1: 
1:                     testError = true;
1:                 }
1: 
1:                 lastSeq = seq;
1: 
1:                 if (msgCount > expectedCount) {
0:                     LOG.error("*** have more messages than expected; have " + msgCount +
0:                             "; expect " + expectedCount);
1: 
1:                     testError = true;
1:                 }
1:             }
1: 
1:             if (in_msg.propertyExists("end-of-response")) {
1:                 LOG.trace("received end-of-response message");
1:             }
1:         }
1:     }
1: 
1:     /**
1:      *
1:      */
1:     protected class EchoService extends java.lang.Thread {
1:         protected String destName;
1:         protected Connection jmsConn;
1:         protected Session sess;
1:         protected MessageConsumer msg_cons;
1:         protected boolean Shutdown_ind;
1: 
1:         protected Destination req_dest;
1: 
1:         protected CountDownLatch waitShutdown;
1: 
1:         protected ThreadPoolExecutor processorPool;
1: 
0:         public EchoService(String dest, Connection broker_conn)
0:                 throws Exception {
1:             destName = dest;
1:             jmsConn = broker_conn;
1: 
1:             Shutdown_ind = false;
1: 
1:             sess = jmsConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             req_dest = sess.createQueue(destName);
1:             msg_cons = sess.createConsumer(req_dest);
1: 
1:             jmsConn.start();
1: 
1:             waitShutdown = new CountDownLatch(1);
1: 
0:             processorPool = new ThreadPoolExecutor(CONCURRENT_SERVER_COUNT, CONCURRENT_SERVER_COUNT,
0:                     0, TimeUnit.SECONDS,
0:                     new ArrayBlockingQueue<Runnable>(10000));
1:         }
1: 
0:         public EchoService(String dest, String broker_url)
0:                 throws Exception {
1:             this(dest, ActiveMQConnection.makeConnection(broker_url));
1:         }
1: 
1:         public void run() {
1:             Message req;
1: 
1:             try {
1:                 LOG.info("STARTING ECHO SERVICE");
1: 
1:                 while (!Shutdown_ind) {
1:                     req = msg_cons.receive(100);
1:                     if (req != null) {
1:                         processorPool.execute(new EchoRequestProcessor(sess, req));
1:                     }
1:                 }
1:             } catch (Exception ex) {
1:                 LOG.error("error processing echo service requests", ex);
1:             } finally {
1:                 LOG.info("shutting down test echo service");
1: 
1:                 try {
1:                     jmsConn.stop();
1:                 } catch (javax.jms.JMSException jms_exc) {
1:                     LOG.warn("error on shutting down JMS connection", jms_exc);
1:                 }
1: 
1:                 synchronized (this) {
1:                     waitShutdown.countDown();
1:                 }
1:             }
1:         }
1: 
1: 
1:         /**
1:          * Shut down the service, waiting up to 3 seconds for the service to terminate.
1:          */
1:         public void shutdown() {
1:             CountDownLatch wait_l;
1: 
1:             synchronized (this) {
1:                 wait_l = waitShutdown;
1:             }
1: 
1:             Shutdown_ind = true;
1: 
1:             try {
1:                 if (wait_l != null) {
1:                     if (wait_l.await(3000, TimeUnit.MILLISECONDS))
1:                         LOG.info("echo service shutdown complete");
1:                     else
1:                         LOG.warn("timeout waiting for echo service shutdown");
1:                 } else {
1:                     LOG.info("echo service shutdown: service does not appear to be active");
1:                 }
1:             } catch (InterruptedException int_exc) {
1:                 LOG.warn("interrupted while waiting for echo service shutdown");
1:             }
1:         }
1:     }
1: 
1:     /**
1:      *
1:      */
1:     protected class EchoRequestProcessor implements Runnable {
1:         protected Session session;
1: 
1:         protected Destination resp_dest;
1:         protected MessageProducer msg_prod;
1: 
1:         protected Message request;
1: 
0:         public EchoRequestProcessor(Session sess, Message req)
0:                 throws Exception {
1:             this.session = sess;
1:             this.request = req;
1: 
1:             this.resp_dest = req.getJMSReplyTo();
1: 
1:             if (resp_dest == null) {
1:                 throw new Exception("invalid request: no reply-to destination given");
1:             }
1: 
1:             this.msg_prod = session.createProducer(this.resp_dest);
1:         }
1: 
1:         public void run() {
1:             try {
1:                 this.processRequest(this.request);
1:             } catch (Exception ex) {
1:                 LOG.error("Failed to process request", ex);
1:             }
1:         }
1: 
1:         /**
1:          * Process one request for the Echo Service.
1:          */
0:         protected void processRequest(Message req)
0:                 throws Exception {
1:             if (LOG.isDebugEnabled())
1:                 LOG.debug("ECHO request message " + req.toString());
1: 
1:             resp_dest = req.getJMSReplyTo();
1:             if (resp_dest != null) {
1:                 msg_prod = session.createProducer(resp_dest);
1: 
1:                 LOG.debug("SENDING ECHO RESPONSE to:" + resp_dest);
1: 
1:                 msg_prod.send(req);
1: 
1:                 LOG.debug((((ActiveMQSession) session).getConnection()).getBrokerName() + " SENT ECHO RESPONSE to " + resp_dest);
1: 
1:                 msg_prod.close();
1:                 msg_prod = null;
1:             } else {
1:                 LOG.warn("invalid request: no reply-to destination given");
1:             }
1:         }
1:     }
1: 
1:     protected class TopicTrafficGenerator extends java.lang.Thread {
1:         protected Connection conn1;
1:         protected Connection conn2;
1:         protected Session sess1;
1:         protected Session sess2;
1:         protected Destination dest;
1:         protected MessageProducer prod;
1:         protected MessageConsumer cons;
1:         protected boolean Shutdown_ind;
1:         protected int send_count;
1: 
0:         public TopicTrafficGenerator(String url1, String url2)
0:                 throws Exception {
1:             conn1 = createConnection(url1);
1:             conn2 = createConnection(url2);
1: 
1:             sess1 = conn1.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:             sess2 = conn2.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:             conn1.start();
1:             conn2.start();
1: 
1:             dest = sess1.createTopic("traffic");
1:             prod = sess1.createProducer(dest);
1: 
1:             dest = sess2.createTopic("traffic");
1:             cons = sess2.createConsumer(dest);
1:         }
1: 
1:         public void shutdown() {
1:             Shutdown_ind = true;
1:         }
1: 
1:         public void run() {
1:             Message msg;
1: 
1:             try {
1:                 LOG.info("Starting Topic Traffic Generator");
1: 
1:                 while (!Shutdown_ind) {
1:                     msg = sess1.createTextMessage("TRAFFIC");
1: 
1:                     prod.send(msg);
1: 
1:                     send_count++;
1: 
1:                     //
1:                     // Time out the receipt; early messages may not make it.
1:                     //
1: 
1:                     msg = cons.receive(250);
1:                 }
1:             } catch (JMSException jms_exc) {
1:                 LOG.warn("traffic generator failed on jms exception", jms_exc);
1:             } finally {
1:                 LOG.info("Shutdown of Topic Traffic Generator; send count = " + send_count);
1: 
1:                 if (conn1 != null) {
1:                     try {
1:                         conn1.stop();
1:                     } catch (JMSException jms_exc) {
1:                         LOG.warn("failed to shutdown connection", jms_exc);
1:                     }
1:                 }
1: 
1:                 if (conn2 != null) {
1:                     try {
1:                         conn2.stop();
1:                     } catch (JMSException jms_exc) {
1:                         LOG.warn("failed to shutdown connection", jms_exc);
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: }
============================================================================