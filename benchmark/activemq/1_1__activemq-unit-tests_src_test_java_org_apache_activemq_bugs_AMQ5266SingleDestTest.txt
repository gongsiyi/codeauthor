1:1d39f08: /**
1:1d39f08:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:1d39f08:  * contributor license agreements.  See the NOTICE file distributed with
1:1d39f08:  * this work for additional information regarding copyright ownership.
1:1d39f08:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:1d39f08:  * (the "License"); you may not use this file except in compliance with
1:1d39f08:  * the License.  You may obtain a copy of the License at
1:1d39f08:  *
1:1d39f08:  *      http://www.apache.org/licenses/LICENSE-2.0
1:1d39f08:  *
1:1d39f08:  * Unless required by applicable law or agreed to in writing, software
1:1d39f08:  * distributed under the License is distributed on an "AS IS" BASIS,
1:1d39f08:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:1d39f08:  * See the License for the specific language governing permissions and
1:1d39f08:  * limitations under the License.
1:1d39f08:  */
1:1d39f08: package org.apache.activemq.bugs;
3:1d39f08: 
1:1d39f08: import java.util.ArrayList;
1:1d39f08: import java.util.Arrays;
1:1d39f08: import java.util.Collections;
1:1d39f08: import java.util.HashMap;
1:1d39f08: import java.util.List;
1:1d39f08: import java.util.Map;
1:1d39f08: import java.util.TreeSet;
1:1d39f08: import java.util.UUID;
1:1d39f08: import java.util.concurrent.TimeUnit;
1:1d39f08: import javax.jms.Message;
1:1d39f08: import javax.jms.MessageConsumer;
1:1d39f08: import javax.jms.MessageProducer;
1:1d39f08: import javax.jms.Queue;
1:1d39f08: import javax.jms.QueueConnection;
1:1d39f08: import javax.jms.Session;
1:1d39f08: import javax.jms.TextMessage;
1:1d39f08: import org.apache.activemq.ActiveMQConnection;
1:1d39f08: import org.apache.activemq.ActiveMQConnectionFactory;
1:1d39f08: import org.apache.activemq.RedeliveryPolicy;
1:67ead20: import org.apache.activemq.TestSupport;
1:1d39f08: import org.apache.activemq.broker.BrokerService;
1:1d39f08: import org.apache.activemq.broker.TransportConnector;
1:67ead20: import org.apache.activemq.broker.region.RegionBroker;
1:1d39f08: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:1d39f08: import org.apache.activemq.broker.region.policy.PolicyMap;
1:1d39f08: import org.apache.activemq.command.ActiveMQQueue;
1:1d39f08: import org.junit.After;
1:1d39f08: import org.junit.Before;
1:25376af: import org.junit.BeforeClass;
1:1d39f08: import org.junit.Test;
1:1d39f08: import org.junit.runner.RunWith;
1:1d39f08: import org.junit.runners.Parameterized;
1:1d39f08: import org.slf4j.Logger;
1:1d39f08: import org.slf4j.LoggerFactory;
1:1d39f08: 
1:1d39f08: 
1:1d39f08: import static org.junit.Assert.assertEquals;
1:1d39f08: 
1:1d39f08: /**
1:1d39f08:  Non transactional concurrent producer/consumer to single dest
1:1d39f08:  */
1:1d39f08: @RunWith(Parameterized.class)
1:1d39f08: public class AMQ5266SingleDestTest {
1:1d39f08:     static Logger LOG = LoggerFactory.getLogger(AMQ5266SingleDestTest.class);
1:1d39f08:     String activemqURL;
1:1d39f08:     BrokerService brokerService;
1:1d39f08: 
1:1d39f08:     public int numDests = 1;
1:1d39f08:     public int messageSize = 10*1000;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameter(0)
1:1d39f08:     public int publisherMessagesPerThread = 1000;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameter(1)
1:1d39f08:     public int publisherThreadCount = 20;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameter(2)
1:1d39f08:     public int consumerThreadsPerQueue = 5;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameter(3)
1:1d39f08:     public int destMemoryLimit = 50 * 1024;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameter(4)
1:1d39f08:     public boolean useCache = true;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameter(5)
1:67ead20:     public TestSupport.PersistenceAdapterChoice persistenceAdapterChoice = TestSupport.PersistenceAdapterChoice.KahaDB;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameter(6)
1:1d39f08:     public boolean optimizeDispatch = false;
1:1d39f08: 
1:1d39f08:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},useDefaultStore:{5},optimizedDispatch:{6}")
1:1d39f08:     public static Iterable<Object[]> parameters() {
1:1d39f08:         return Arrays.asList(new Object[][]{
1:3042797:                {1000,  40,  40,   1024*1024*1,  true, TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:3042797:                {1000,  40,  40,   1024*1024*1,  true, TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:3042797:                {1000,  40,  40,   1024*1024*1,  true, TestSupport.PersistenceAdapterChoice.JDBC, false},
1:1d39f08:         });
4:1d39f08:     }
1:1d39f08: 
1:1d39f08:     public int consumerBatchSize = 25;
1:1d39f08: 
1:25376af:     @BeforeClass
1:25376af:     public static void derbyTestMode() throws Exception {
1:25376af:         System.setProperty("derby.system.durability","test");
1:25376af:     }
1:25376af: 
1:1d39f08:     @Before
1:1d39f08:     public void startBroker() throws Exception {
1:1d39f08:         brokerService = new BrokerService();
1:1d39f08: 
1:67ead20:         TestSupport.setPersistenceAdapter(brokerService, persistenceAdapterChoice);
1:1d39f08:         brokerService.setDeleteAllMessagesOnStartup(true);
1:1d39f08:         brokerService.setUseJmx(false);
1:67ead20:         brokerService.setAdvisorySupport(false);
1:1d39f08: 
1:1d39f08: 
1:1d39f08:         PolicyMap policyMap = new PolicyMap();
1:1d39f08:         PolicyEntry defaultEntry = new PolicyEntry();
1:1d39f08:         defaultEntry.setUseConsumerPriority(false); // java.lang.IllegalArgumentException: Comparison method violates its general contract!
1:1d39f08:         defaultEntry.setMaxProducersToAudit(publisherThreadCount);
1:1d39f08:         defaultEntry.setEnableAudit(true);
1:1d39f08:         defaultEntry.setUseCache(useCache);
1:1d39f08:         defaultEntry.setMaxPageSize(1000);
1:1d39f08:         defaultEntry.setOptimizedDispatch(optimizeDispatch);
1:1d39f08:         defaultEntry.setMemoryLimit(destMemoryLimit);
1:1d39f08:         defaultEntry.setExpireMessagesPeriod(0);
1:1d39f08:         policyMap.setDefaultEntry(defaultEntry);
1:1d39f08:         brokerService.setDestinationPolicy(policyMap);
1:1d39f08: 
1:67ead20:         brokerService.getSystemUsage().getMemoryUsage().setLimit(64 * 1024 * 1024);
1:1d39f08: 
1:1d39f08:         TransportConnector transportConnector = brokerService.addConnector("tcp://0.0.0.0:0");
1:1d39f08:         brokerService.start();
1:1d39f08:         activemqURL = transportConnector.getPublishableConnectString();
1:67ead20:         activemqURL += "?jms.watchTopicAdvisories=false"; // ensure all messages are queue or dlq messages
1:1d39f08:     }
1:1d39f08: 
1:1d39f08:     @After
1:1d39f08:     public void stopBroker() throws Exception {
1:1d39f08:         if (brokerService != null) {
1:1d39f08:             brokerService.stop();
1:1d39f08:         }
1:1d39f08:     }
1:1d39f08: 
1:1d39f08:     @Test
1:1d39f08:     public void test() throws Exception {
1:1d39f08: 
1:1d39f08:         String activemqQueues = "activemq";
1:1d39f08:         for (int i=1;i<numDests;i++) {
1:1d39f08:             activemqQueues +=",activemq"+i;
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         int consumerWaitForConsumption = 5 * 60 * 1000;
1:1d39f08: 
1:1d39f08:         ExportQueuePublisher publisher = null;
1:1d39f08:         ExportQueueConsumer consumer = null;
1:1d39f08: 
1:1d39f08:         LOG.info("Publisher will publish " + (publisherMessagesPerThread * publisherThreadCount) + " messages to each queue specified.");
1:1d39f08:         LOG.info("\nBuilding Publisher...");
1:1d39f08: 
1:1d39f08:         publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);
1:1d39f08: 
1:1d39f08:         LOG.info("Building Consumer...");
1:1d39f08: 
1:1d39f08:         consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);
1:1d39f08: 
1:1d39f08:         long totalStart = System.currentTimeMillis();
1:1d39f08: 
1:1d39f08:         LOG.info("Starting Publisher...");
1:1d39f08: 
1:1d39f08:         publisher.start();
1:1d39f08: 
1:1d39f08:         LOG.info("Starting Consumer...");
1:1d39f08: 
1:1d39f08:         consumer.start();
1:1d39f08: 
1:1d39f08:         int distinctPublishedCount = 0;
1:1d39f08: 
1:1d39f08: 
1:1d39f08:         LOG.info("Waiting For Publisher Completion...");
1:1d39f08: 
1:1d39f08:         publisher.waitForCompletion();
1:1d39f08: 
1:1d39f08:         List publishedIds = publisher.getIDs();
1:1d39f08:         distinctPublishedCount = new TreeSet(publishedIds).size();
1:1d39f08: 
1:1d39f08:         LOG.info("Publisher Complete. Published: " + publishedIds.size() + ", Distinct IDs Published: " + distinctPublishedCount);
1:1d39f08:         LOG.info("Publisher duration: {}", TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - totalStart));
1:1d39f08: 
1:1d39f08: 
1:1d39f08:         long endWait = System.currentTimeMillis() + consumerWaitForConsumption;
1:1d39f08:         while (!consumer.completed() && System.currentTimeMillis() < endWait) {
2:1d39f08:             try {
1:1d39f08:                 int secs = (int) (endWait - System.currentTimeMillis()) / 1000;
1:1d39f08:                 LOG.info("Waiting For Consumer Completion. Time left: " + secs + " secs");
1:1d39f08:                 Thread.sleep(1000);
1:1d39f08:             } catch (Exception e) {
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         LOG.info("\nConsumer Complete: " + consumer.completed() +", Shutting Down.");
1:1d39f08: 
1:1d39f08:         LOG.info("Total duration: {}", TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - totalStart));
1:1d39f08: 
1:1d39f08:         consumer.shutdown();
1:1d39f08: 
1:1d39f08:         TimeUnit.SECONDS.sleep(2);
1:1d39f08: 
1:1d39f08:         LOG.info("Consumer Stats:");
1:1d39f08: 
1:1d39f08:         for (Map.Entry<String, List<String>> entry : consumer.getIDs().entrySet()) {
1:1d39f08: 
1:1d39f08:             List<String> idList = entry.getValue();
1:1d39f08: 
1:1d39f08:             int distinctConsumed = new TreeSet<String>(idList).size();
1:1d39f08: 
1:1d39f08:             StringBuilder sb = new StringBuilder();
1:1d39f08:             sb.append("   Queue: " + entry.getKey() +
1:1d39f08:                     " -> Total Messages Consumed: " + idList.size() +
1:1d39f08:                     ", Distinct IDs Consumed: " + distinctConsumed);
1:1d39f08: 
1:1d39f08:             int diff = distinctPublishedCount - distinctConsumed;
1:1d39f08:             sb.append(" ( " + (diff > 0 ? diff : "NO") + " STUCK MESSAGES " + " ) ");
1:1d39f08:             LOG.info(sb.toString());
1:1d39f08: 
1:1d39f08:             assertEquals("expect to get all messages!", 0, diff);
1:67ead20: 
1:1d39f08:         }
1:1d39f08: 
1:67ead20:         // verify empty dlq
1:67ead20:         assertEquals("No pending messages", 0l, ((RegionBroker) brokerService.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
1:1d39f08:     }
1:1d39f08: 
1:1d39f08:     public class ExportQueuePublisher {
1:1d39f08: 
1:1d39f08:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:1d39f08:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:1d39f08:         private ActiveMQConnectionFactory connectionFactory = null;
1:1d39f08:         private String activemqURL = null;
1:1d39f08:         private String activemqQueues = null;
1:1d39f08:         // Collection of distinct IDs that the publisher has published.
1:1d39f08:         // After a message is published, its UUID will be written to this list for tracking.
1:1d39f08:         // This list of IDs (or distinct count) will be used to compare to the consumed list of IDs.
1:1d39f08:         //private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
1:1d39f08:         private List<String> ids = Collections.synchronizedList(new ArrayList<String>());
1:1d39f08:         private List<PublisherThread> threads;
1:1d39f08: 
1:1d39f08:         public ExportQueuePublisher(String activemqURL, String activemqQueues, int messagesPerThread, int threadCount) throws Exception {
1:1d39f08: 
1:1d39f08:             this.activemqURL = activemqURL;
1:1d39f08:             this.activemqQueues = activemqQueues;
1:1d39f08: 
1:1d39f08:             threads = new ArrayList<PublisherThread>();
1:1d39f08: 
1:1d39f08:             // Build the threads and tell them how many messages to publish
1:1d39f08:             for (int i = 0; i < threadCount; i++) {
1:1d39f08:                 PublisherThread pt = new PublisherThread(messagesPerThread);
1:1d39f08:                 threads.add(pt);
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         public List<String> getIDs() {
1:1d39f08:             return ids;
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         // Kick off threads
1:1d39f08:         public void start() throws Exception {
1:1d39f08: 
1:1d39f08:             for (PublisherThread pt : threads) {
1:1d39f08:                 pt.start();
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         // Wait for threads to complete. They will complete once they've published all of their messages.
1:1d39f08:         public void waitForCompletion() throws Exception {
1:1d39f08: 
1:1d39f08:             for (PublisherThread pt : threads) {
1:1d39f08:                 pt.join();
1:1d39f08:                 pt.close();
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:1d39f08:             return queueConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         private synchronized QueueConnection newQueueConnection() throws Exception {
1:1d39f08: 
1:1d39f08:             if (connectionFactory == null) {
1:1d39f08:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:1d39f08:             // after the queue has had a certain number of failures (default is 6)
1:1d39f08:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:1d39f08:             policy.setMaximumRedeliveries(-1);
1:1d39f08: 
1:1d39f08:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:1d39f08:             amqConnection.start();
1:1d39f08:             return amqConnection;
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         private class PublisherThread extends Thread {
1:1d39f08: 
1:1d39f08:             private int count;
1:1d39f08:             private QueueConnection qc;
1:1d39f08:             private Session session;
1:1d39f08:             private MessageProducer mp;
1:1d39f08: 
1:1d39f08:             private PublisherThread(int count) throws Exception {
1:1d39f08: 
1:1d39f08:                 this.count = count;
1:1d39f08: 
1:1d39f08:                 // Each Thread has its own Connection and Session, so no sync worries
1:1d39f08:                 qc = newQueueConnection();
1:1d39f08:                 session = newSession(qc);
1:1d39f08: 
1:1d39f08:                 // In our code, when publishing to multiple queues,
1:1d39f08:                 // we're using composite destinations like below
1:1d39f08:                 Queue q = new ActiveMQQueue(activemqQueues);
1:1d39f08:                 mp = session.createProducer(q);
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             public void run() {
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08: 
1:1d39f08:                     // Loop until we've published enough messages
1:1d39f08:                     while (count-- > 0) {
1:1d39f08: 
1:1d39f08:                         TextMessage tm = session.createTextMessage(getMessageText());
1:1d39f08:                         String id = UUID.randomUUID().toString();
1:1d39f08:                         tm.setStringProperty("KEY", id);
1:1d39f08:                         ids.add(id);                            // keep track of the key to compare against consumer
1:1d39f08: 
1:1d39f08:                         mp.send(tm);
1:1d39f08:                     }
1:1d39f08:                 } catch (Exception e) {
1:1d39f08:                     e.printStackTrace();
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             // Called by waitForCompletion
1:1d39f08:             public void close() {
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08:                     mp.close();
1:1d39f08:                 } catch (Exception e) {
1:1d39f08:                 }
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08:                     session.close();
1:1d39f08:                 } catch (Exception e) {
1:1d39f08:                 }
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08:                     qc.close();
1:1d39f08:                 } catch (Exception e) {
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:     }
1:1d39f08: 
1:1d39f08:     String messageText;
1:1d39f08:     private String getMessageText() {
1:1d39f08: 
1:1d39f08:         if (messageText == null) {
1:1d39f08: 
1:1d39f08:             synchronized (this) {
1:1d39f08: 
1:1d39f08:                 if (messageText == null) {
1:1d39f08: 
1:1d39f08:                     StringBuilder sb = new StringBuilder();
1:1d39f08:                     for (int i = 0; i < messageSize; i++) {
1:1d39f08:                         sb.append("X");
1:1d39f08:                     }
1:1d39f08:                     messageText = sb.toString();
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         return messageText;
1:1d39f08:     }
1:1d39f08: 
1:1d39f08: 
1:1d39f08:     public class ExportQueueConsumer {
1:1d39f08: 
1:1d39f08:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:1d39f08:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:1d39f08:         private final int totalToExpect;
1:1d39f08:         private ActiveMQConnectionFactory connectionFactory = null;
1:1d39f08:         private String activemqURL = null;
1:1d39f08:         private String activemqQueues = null;
1:1d39f08:         private String[] queues = null;
1:1d39f08:         // Map of IDs that were consumed, keyed by queue name.
1:1d39f08:         // We'll compare these against what was published to know if any got stuck or dropped.
1:1d39f08:         private Map<String, List<String>> idsByQueue = new HashMap<String, List<String>>();
1:1d39f08:         private Map<String, List<ConsumerThread>> threads;
1:1d39f08: 
1:1d39f08:         public ExportQueueConsumer(String activemqURL, String activemqQueues, int threadsPerQueue, int batchSize, int totalToExpect) throws Exception {
1:1d39f08: 
1:1d39f08:             this.activemqURL = activemqURL;
1:1d39f08:             this.activemqQueues = activemqQueues;
1:1d39f08:             this.totalToExpect = totalToExpect;
1:1d39f08: 
1:1d39f08:             queues = this.activemqQueues.split(",");
1:1d39f08: 
1:1d39f08:             for (int i = 0; i < queues.length; i++) {
1:1d39f08:                 queues[i] = queues[i].trim();
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             threads = new HashMap<String, List<ConsumerThread>>();
1:1d39f08: 
1:1d39f08:             // For each queue, create a list of threads and set up the list of ids
1:1d39f08:             for (String q : queues) {
1:1d39f08: 
1:1d39f08:                 List<ConsumerThread> list = new ArrayList<ConsumerThread>();
1:1d39f08: 
1:1d39f08:                 idsByQueue.put(q, Collections.synchronizedList(new ArrayList<String>()));
1:1d39f08: 
1:1d39f08:                 for (int i = 0; i < threadsPerQueue; i++) {
1:1d39f08:                     list.add(new ConsumerThread(q, batchSize));
1:1d39f08:                 }
1:1d39f08: 
1:1d39f08:                 threads.put(q, list);
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         public Map<String, List<String>> getIDs() {
1:1d39f08:             return idsByQueue;
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         // Start the threads
1:1d39f08:         public void start() throws Exception {
1:1d39f08: 
1:1d39f08:             for (List<ConsumerThread> list : threads.values()) {
1:1d39f08: 
1:1d39f08:                 for (ConsumerThread ct : list) {
1:1d39f08: 
1:1d39f08:                     ct.start();
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         // Tell the threads to stop
1:1d39f08:         // Then wait for them to stop
1:1d39f08:         public void shutdown() throws Exception {
1:1d39f08: 
1:1d39f08:             for (List<ConsumerThread> list : threads.values()) {
1:1d39f08: 
1:1d39f08:                 for (ConsumerThread ct : list) {
1:1d39f08: 
1:1d39f08:                     ct.shutdown();
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             for (List<ConsumerThread> list : threads.values()) {
1:1d39f08: 
1:1d39f08:                 for (ConsumerThread ct : list) {
1:1d39f08: 
1:1d39f08:                     ct.join();
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:1d39f08:             return queueConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         private synchronized QueueConnection newQueueConnection() throws Exception {
1:1d39f08: 
1:1d39f08:             if (connectionFactory == null) {
1:1d39f08:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:1d39f08:             // after the queue has had a certain number of failures (default is 6)
1:1d39f08:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:1d39f08:             policy.setMaximumRedeliveries(-1);
1:1d39f08: 
1:1d39f08:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:1d39f08:             amqConnection.start();
1:1d39f08:             return amqConnection;
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         public boolean completed() {
1:1d39f08:             for (List<ConsumerThread> list : threads.values()) {
1:1d39f08: 
1:1d39f08:                 for (ConsumerThread ct : list) {
1:1d39f08: 
1:1d39f08:                     if (ct.isAlive()) {
1:1d39f08:                         LOG.info("thread for {} is still alive.", ct.qName);
1:1d39f08:                         return false;
1:1d39f08:                     }
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08:             return true;
1:1d39f08:         }
1:1d39f08: 
1:1d39f08:         private class ConsumerThread extends Thread {
1:1d39f08: 
1:1d39f08:             private int batchSize;
1:1d39f08:             private QueueConnection qc;
1:1d39f08:             private Session session;
1:1d39f08:             private MessageConsumer mc;
1:1d39f08:             private List<String> idList;
1:1d39f08:             private boolean shutdown = false;
1:1d39f08:             private String qName;
1:1d39f08: 
1:1d39f08:             private ConsumerThread(String queueName, int batchSize) throws Exception {
1:1d39f08: 
1:1d39f08:                 this.batchSize = batchSize;
1:1d39f08: 
1:1d39f08:                 // Each thread has its own connection and session
1:1d39f08:                 qName = queueName;
1:1d39f08:                 qc = newQueueConnection();
1:1d39f08:                 session = newSession(qc);
1:1d39f08:                 Queue q = session.createQueue(queueName + "?consumer.prefetchSize=" + batchSize);
1:1d39f08:                 mc = session.createConsumer(q);
1:1d39f08: 
1:1d39f08:                 idList = idsByQueue.get(queueName);
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             public void run() {
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08: 
1:1d39f08:                     int count = 0;
1:1d39f08: 
1:1d39f08:                     // Keep reading as long as it hasn't been told to shutdown
1:1d39f08:                     while (!shutdown) {
1:1d39f08: 
1:1d39f08:                         if (idList.size() >= totalToExpect) {
1:1d39f08:                             LOG.info("Got {} for q: {}", +idList.size(), qName);
1:1d39f08:                             break;
1:1d39f08:                         }
1:1d39f08:                         Message m = mc.receive(4000);
1:1d39f08: 
1:1d39f08:                         if (m != null) {
1:1d39f08: 
1:1d39f08:                             // We received a non-null message, add the ID to our list
1:1d39f08: 
1:1d39f08:                             idList.add(m.getStringProperty("KEY"));
1:1d39f08: 
1:1d39f08:                             count++;
1:1d39f08: 
1:1d39f08:                             // If we've reached our batch size, commit the batch and reset the count
1:1d39f08: 
1:1d39f08:                             if (count == batchSize) {
1:1d39f08:                                 count = 0;
1:1d39f08:                             }
2:1d39f08:                         } else {
1:1d39f08: 
1:1d39f08:                             // We didn't receive anything this time, commit any current batch and reset the count
1:1d39f08: 
1:1d39f08:                             count = 0;
1:1d39f08: 
1:1d39f08:                             // Sleep a little before trying to read after not getting a message
1:1d39f08: 
1:1d39f08:                             try {
1:1d39f08:                                 if (idList.size() < totalToExpect) {
1:1d39f08:                                     LOG.info("did not receive on {}, current count: {}", qName, idList.size());
1:1d39f08:                                 }
1:1d39f08:                                 //sleep(3000);
1:1d39f08:                             } catch (Exception e) {
1:1d39f08:                             }
1:1d39f08:                         }
1:1d39f08:                     }
1:1d39f08:                 } catch (Exception e) {
1:1d39f08:                     e.printStackTrace();
1:1d39f08:                 } finally {
1:1d39f08: 
1:1d39f08:                     // Once we exit, close everything
1:1d39f08:                     close();
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             public void shutdown() {
1:1d39f08:                 shutdown = true;
1:1d39f08:             }
1:1d39f08: 
1:1d39f08:             public void close() {
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08:                     mc.close();
1:1d39f08:                 } catch (Exception e) {
1:1d39f08:                 }
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08:                     session.close();
1:1d39f08:                 } catch (Exception e) {
1:1d39f08:                 }
1:1d39f08: 
1:1d39f08:                 try {
1:1d39f08:                     qc.close();
1:1d39f08:                 } catch (Exception e) {
1:1d39f08: 
1:1d39f08:                 }
1:1d39f08:             }
1:1d39f08:         }
1:1d39f08:     }
1:1d39f08: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:25376af
/////////////////////////////////////////////////////////////////////////
1: import org.junit.BeforeClass;
/////////////////////////////////////////////////////////////////////////
1:     @BeforeClass
1:     public static void derbyTestMode() throws Exception {
1:         System.setProperty("derby.system.durability","test");
1:     }
1: 
commit:3042797
/////////////////////////////////////////////////////////////////////////
1:                {1000,  40,  40,   1024*1024*1,  true, TestSupport.PersistenceAdapterChoice.KahaDB, false},
1:                {1000,  40,  40,   1024*1024*1,  true, TestSupport.PersistenceAdapterChoice.LevelDB, false},
1:                {1000,  40,  40,   1024*1024*1,  true, TestSupport.PersistenceAdapterChoice.JDBC, false},
commit:67ead20
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.TestSupport;
1: import org.apache.activemq.broker.region.RegionBroker;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public TestSupport.PersistenceAdapterChoice persistenceAdapterChoice = TestSupport.PersistenceAdapterChoice.KahaDB;
/////////////////////////////////////////////////////////////////////////
0:                 {1000,  80,  80,   1024*1024*1,  true, TestSupport.PersistenceAdapterChoice.KahaDB, false},
/////////////////////////////////////////////////////////////////////////
1:         TestSupport.setPersistenceAdapter(brokerService, persistenceAdapterChoice);
1:         brokerService.setAdvisorySupport(false);
/////////////////////////////////////////////////////////////////////////
1:         brokerService.getSystemUsage().getMemoryUsage().setLimit(64 * 1024 * 1024);
1:         activemqURL += "?jms.watchTopicAdvisories=false"; // ensure all messages are queue or dlq messages
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify empty dlq
1:         assertEquals("No pending messages", 0l, ((RegionBroker) brokerService.getRegionBroker()).getDestinationStatistics().getMessages().getCount());
commit:1d39f08
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.bugs;
1: 
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Collections;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.TreeSet;
1: import java.util.UUID;
1: import java.util.concurrent.TimeUnit;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.QueueConnection;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.RedeliveryPolicy;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
0: import org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter;
0: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
0: import org.apache.derby.jdbc.EmbeddedDataSource;
1: import org.junit.After;
1: import org.junit.Before;
1: import org.junit.Test;
1: import org.junit.runner.RunWith;
1: import org.junit.runners.Parameterized;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: 
1: import static org.junit.Assert.assertEquals;
1: 
1: /**
1:  Non transactional concurrent producer/consumer to single dest
1:  */
1: @RunWith(Parameterized.class)
1: public class AMQ5266SingleDestTest {
1:     static Logger LOG = LoggerFactory.getLogger(AMQ5266SingleDestTest.class);
1:     String activemqURL;
1:     BrokerService brokerService;
0:     private EmbeddedDataSource dataSource;
1: 
1:     public int numDests = 1;
1:     public int messageSize = 10*1000;
1: 
1:     @Parameterized.Parameter(0)
1:     public int publisherMessagesPerThread = 1000;
1: 
1:     @Parameterized.Parameter(1)
1:     public int publisherThreadCount = 20;
1: 
1:     @Parameterized.Parameter(2)
1:     public int consumerThreadsPerQueue = 5;
1: 
1:     @Parameterized.Parameter(3)
1:     public int destMemoryLimit = 50 * 1024;
1: 
1:     @Parameterized.Parameter(4)
1:     public boolean useCache = true;
1: 
1:     @Parameterized.Parameter(5)
0:     public boolean useDefaultStore = false;
1: 
1:     @Parameterized.Parameter(6)
1:     public boolean optimizeDispatch = false;
1: 
1:     @Parameterized.Parameters(name="#{0},producerThreads:{1},consumerThreads:{2},mL:{3},useCache:{4},useDefaultStore:{5},optimizedDispatch:{6}")
1:     public static Iterable<Object[]> parameters() {
1:         return Arrays.asList(new Object[][]{
0:                 {1000,  80,  80,   1024*1024*5,  true, true, false},
1:         });
1:     }
1: 
1:     public int consumerBatchSize = 25;
1: 
1:     @Before
1:     public void startBroker() throws Exception {
1:         brokerService = new BrokerService();
1: 
0:         dataSource = new EmbeddedDataSource();
0:         dataSource.setDatabaseName("target/derbyDb");
0:         dataSource.setCreateDatabase("create");
1: 
0:         JDBCPersistenceAdapter jdbcPersistenceAdapter = new JDBCPersistenceAdapter();
0:         jdbcPersistenceAdapter.setDataSource(dataSource);
0:         jdbcPersistenceAdapter.setUseLock(false);
1: 
0:         if (!useDefaultStore) {
0:             brokerService.setPersistenceAdapter(jdbcPersistenceAdapter);
1:         } else {
0:             KahaDBPersistenceAdapter kahaDBPersistenceAdapter = (KahaDBPersistenceAdapter) brokerService.getPersistenceAdapter();
0:             kahaDBPersistenceAdapter.setConcurrentStoreAndDispatchQueues(true);
1:         }
1:         brokerService.setDeleteAllMessagesOnStartup(true);
1:         brokerService.setUseJmx(false);
1: 
1: 
1:         PolicyMap policyMap = new PolicyMap();
1:         PolicyEntry defaultEntry = new PolicyEntry();
1:         defaultEntry.setUseConsumerPriority(false); // java.lang.IllegalArgumentException: Comparison method violates its general contract!
1:         defaultEntry.setMaxProducersToAudit(publisherThreadCount);
1:         defaultEntry.setEnableAudit(true);
1:         defaultEntry.setUseCache(useCache);
1:         defaultEntry.setMaxPageSize(1000);
1:         defaultEntry.setOptimizedDispatch(optimizeDispatch);
1:         defaultEntry.setMemoryLimit(destMemoryLimit);
1:         defaultEntry.setExpireMessagesPeriod(0);
1:         policyMap.setDefaultEntry(defaultEntry);
1:         brokerService.setDestinationPolicy(policyMap);
1: 
0:         brokerService.getSystemUsage().getMemoryUsage().setLimit(512 * 1024 * 1024);
1: 
1:         TransportConnector transportConnector = brokerService.addConnector("tcp://0.0.0.0:0");
1:         brokerService.start();
1:         activemqURL = transportConnector.getPublishableConnectString();
1:     }
1: 
1:     @After
1:     public void stopBroker() throws Exception {
1:         if (brokerService != null) {
1:             brokerService.stop();
1:         }
1:         try {
0:             dataSource.setShutdownDatabase("shutdown");
0:             dataSource.getConnection();
0:         } catch (Exception ignored) {}
1:     }
1: 
1:     @Test
1:     public void test() throws Exception {
1: 
1:         String activemqQueues = "activemq";
1:         for (int i=1;i<numDests;i++) {
1:             activemqQueues +=",activemq"+i;
1:         }
1: 
1:         int consumerWaitForConsumption = 5 * 60 * 1000;
1: 
1:         ExportQueuePublisher publisher = null;
1:         ExportQueueConsumer consumer = null;
1: 
1:         LOG.info("Publisher will publish " + (publisherMessagesPerThread * publisherThreadCount) + " messages to each queue specified.");
1:         LOG.info("\nBuilding Publisher...");
1: 
1:         publisher = new ExportQueuePublisher(activemqURL, activemqQueues, publisherMessagesPerThread, publisherThreadCount);
1: 
1:         LOG.info("Building Consumer...");
1: 
1:         consumer = new ExportQueueConsumer(activemqURL, activemqQueues, consumerThreadsPerQueue, consumerBatchSize, publisherMessagesPerThread * publisherThreadCount);
1: 
1:         long totalStart = System.currentTimeMillis();
1: 
1:         LOG.info("Starting Publisher...");
1: 
1:         publisher.start();
1: 
1:         LOG.info("Starting Consumer...");
1: 
1:         consumer.start();
1: 
1:         int distinctPublishedCount = 0;
1: 
1: 
1:         LOG.info("Waiting For Publisher Completion...");
1: 
1:         publisher.waitForCompletion();
1: 
1:         List publishedIds = publisher.getIDs();
1:         distinctPublishedCount = new TreeSet(publishedIds).size();
1: 
1:         LOG.info("Publisher Complete. Published: " + publishedIds.size() + ", Distinct IDs Published: " + distinctPublishedCount);
1:         LOG.info("Publisher duration: {}", TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - totalStart));
1: 
1: 
1:         long endWait = System.currentTimeMillis() + consumerWaitForConsumption;
1:         while (!consumer.completed() && System.currentTimeMillis() < endWait) {
1:             try {
1:                 int secs = (int) (endWait - System.currentTimeMillis()) / 1000;
1:                 LOG.info("Waiting For Consumer Completion. Time left: " + secs + " secs");
0:                 if (!useDefaultStore) {
0:                     DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
1:                 }
1:                 Thread.sleep(1000);
1:             } catch (Exception e) {
1:             }
1:         }
1: 
1:         LOG.info("\nConsumer Complete: " + consumer.completed() +", Shutting Down.");
1: 
1:         LOG.info("Total duration: {}", TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - totalStart));
1: 
1:         consumer.shutdown();
1: 
1:         TimeUnit.SECONDS.sleep(2);
0:         LOG.info("DB Contents START");
0:         if (!useDefaultStore) {
0:             DefaultJDBCAdapter.dumpTables(dataSource.getConnection());
1:         }
0:         LOG.info("DB Contents END");
1: 
1:         LOG.info("Consumer Stats:");
1: 
1:         for (Map.Entry<String, List<String>> entry : consumer.getIDs().entrySet()) {
1: 
1:             List<String> idList = entry.getValue();
1: 
1:             int distinctConsumed = new TreeSet<String>(idList).size();
1: 
1:             StringBuilder sb = new StringBuilder();
1:             sb.append("   Queue: " + entry.getKey() +
1:                     " -> Total Messages Consumed: " + idList.size() +
1:                     ", Distinct IDs Consumed: " + distinctConsumed);
1: 
1:             int diff = distinctPublishedCount - distinctConsumed;
1:             sb.append(" ( " + (diff > 0 ? diff : "NO") + " STUCK MESSAGES " + " ) ");
1:             LOG.info(sb.toString());
1: 
1:             assertEquals("expect to get all messages!", 0, diff);
1: 
1:         }
1:     }
1: 
1:     public class ExportQueuePublisher {
1: 
1:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:         private ActiveMQConnectionFactory connectionFactory = null;
1:         private String activemqURL = null;
1:         private String activemqQueues = null;
1:         // Collection of distinct IDs that the publisher has published.
1:         // After a message is published, its UUID will be written to this list for tracking.
1:         // This list of IDs (or distinct count) will be used to compare to the consumed list of IDs.
1:         //private Set<String> ids = Collections.synchronizedSet(new TreeSet<String>());
1:         private List<String> ids = Collections.synchronizedList(new ArrayList<String>());
1:         private List<PublisherThread> threads;
1: 
1:         public ExportQueuePublisher(String activemqURL, String activemqQueues, int messagesPerThread, int threadCount) throws Exception {
1: 
1:             this.activemqURL = activemqURL;
1:             this.activemqQueues = activemqQueues;
1: 
1:             threads = new ArrayList<PublisherThread>();
1: 
1:             // Build the threads and tell them how many messages to publish
1:             for (int i = 0; i < threadCount; i++) {
1:                 PublisherThread pt = new PublisherThread(messagesPerThread);
1:                 threads.add(pt);
1:             }
1:         }
1: 
1:         public List<String> getIDs() {
1:             return ids;
1:         }
1: 
1:         // Kick off threads
1:         public void start() throws Exception {
1: 
1:             for (PublisherThread pt : threads) {
1:                 pt.start();
1:             }
1:         }
1: 
1:         // Wait for threads to complete. They will complete once they've published all of their messages.
1:         public void waitForCompletion() throws Exception {
1: 
1:             for (PublisherThread pt : threads) {
1:                 pt.join();
1:                 pt.close();
1:             }
1:         }
1: 
1:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:             return queueConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         }
1: 
1:         private synchronized QueueConnection newQueueConnection() throws Exception {
1: 
1:             if (connectionFactory == null) {
1:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:             }
1: 
1:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:             // after the queue has had a certain number of failures (default is 6)
1:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:             policy.setMaximumRedeliveries(-1);
1: 
1:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:             amqConnection.start();
1:             return amqConnection;
1:         }
1: 
1:         private class PublisherThread extends Thread {
1: 
1:             private int count;
1:             private QueueConnection qc;
1:             private Session session;
1:             private MessageProducer mp;
1: 
1:             private PublisherThread(int count) throws Exception {
1: 
1:                 this.count = count;
1: 
1:                 // Each Thread has its own Connection and Session, so no sync worries
1:                 qc = newQueueConnection();
1:                 session = newSession(qc);
1: 
1:                 // In our code, when publishing to multiple queues,
1:                 // we're using composite destinations like below
1:                 Queue q = new ActiveMQQueue(activemqQueues);
1:                 mp = session.createProducer(q);
1:             }
1: 
1:             public void run() {
1: 
1:                 try {
1: 
1:                     // Loop until we've published enough messages
1:                     while (count-- > 0) {
1: 
1:                         TextMessage tm = session.createTextMessage(getMessageText());
1:                         String id = UUID.randomUUID().toString();
1:                         tm.setStringProperty("KEY", id);
1:                         ids.add(id);                            // keep track of the key to compare against consumer
1: 
1:                         mp.send(tm);
1:                     }
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 }
1:             }
1: 
1:             // Called by waitForCompletion
1:             public void close() {
1: 
1:                 try {
1:                     mp.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     session.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     qc.close();
1:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1: 
1:     }
1: 
1:     String messageText;
1:     private String getMessageText() {
1: 
1:         if (messageText == null) {
1: 
1:             synchronized (this) {
1: 
1:                 if (messageText == null) {
1: 
1:                     StringBuilder sb = new StringBuilder();
1:                     for (int i = 0; i < messageSize; i++) {
1:                         sb.append("X");
1:                     }
1:                     messageText = sb.toString();
1:                 }
1:             }
1:         }
1: 
1:         return messageText;
1:     }
1: 
1: 
1:     public class ExportQueueConsumer {
1: 
1:         private final String amqUser = ActiveMQConnection.DEFAULT_USER;
1:         private final String amqPassword = ActiveMQConnection.DEFAULT_PASSWORD;
1:         private final int totalToExpect;
1:         private ActiveMQConnectionFactory connectionFactory = null;
1:         private String activemqURL = null;
1:         private String activemqQueues = null;
1:         private String[] queues = null;
1:         // Map of IDs that were consumed, keyed by queue name.
1:         // We'll compare these against what was published to know if any got stuck or dropped.
1:         private Map<String, List<String>> idsByQueue = new HashMap<String, List<String>>();
1:         private Map<String, List<ConsumerThread>> threads;
1: 
1:         public ExportQueueConsumer(String activemqURL, String activemqQueues, int threadsPerQueue, int batchSize, int totalToExpect) throws Exception {
1: 
1:             this.activemqURL = activemqURL;
1:             this.activemqQueues = activemqQueues;
1:             this.totalToExpect = totalToExpect;
1: 
1:             queues = this.activemqQueues.split(",");
1: 
1:             for (int i = 0; i < queues.length; i++) {
1:                 queues[i] = queues[i].trim();
1:             }
1: 
1:             threads = new HashMap<String, List<ConsumerThread>>();
1: 
1:             // For each queue, create a list of threads and set up the list of ids
1:             for (String q : queues) {
1: 
1:                 List<ConsumerThread> list = new ArrayList<ConsumerThread>();
1: 
1:                 idsByQueue.put(q, Collections.synchronizedList(new ArrayList<String>()));
1: 
1:                 for (int i = 0; i < threadsPerQueue; i++) {
1:                     list.add(new ConsumerThread(q, batchSize));
1:                 }
1: 
1:                 threads.put(q, list);
1:             }
1:         }
1: 
1:         public Map<String, List<String>> getIDs() {
1:             return idsByQueue;
1:         }
1: 
1:         // Start the threads
1:         public void start() throws Exception {
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.start();
1:                 }
1:             }
1:         }
1: 
1:         // Tell the threads to stop
1:         // Then wait for them to stop
1:         public void shutdown() throws Exception {
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.shutdown();
1:                 }
1:             }
1: 
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     ct.join();
1:                 }
1:             }
1:         }
1: 
1:         private Session newSession(QueueConnection queueConnection) throws Exception {
1:             return queueConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         }
1: 
1:         private synchronized QueueConnection newQueueConnection() throws Exception {
1: 
1:             if (connectionFactory == null) {
1:                 connectionFactory = new ActiveMQConnectionFactory(amqUser, amqPassword, activemqURL);
1:             }
1: 
1:             // Set the redelivery count to -1 (infinite), or else messages will start dropping
1:             // after the queue has had a certain number of failures (default is 6)
1:             RedeliveryPolicy policy = connectionFactory.getRedeliveryPolicy();
1:             policy.setMaximumRedeliveries(-1);
1: 
1:             QueueConnection amqConnection = connectionFactory.createQueueConnection();
1:             amqConnection.start();
1:             return amqConnection;
1:         }
1: 
1:         public boolean completed() {
1:             for (List<ConsumerThread> list : threads.values()) {
1: 
1:                 for (ConsumerThread ct : list) {
1: 
1:                     if (ct.isAlive()) {
1:                         LOG.info("thread for {} is still alive.", ct.qName);
1:                         return false;
1:                     }
1:                 }
1:             }
1:             return true;
1:         }
1: 
1:         private class ConsumerThread extends Thread {
1: 
1:             private int batchSize;
1:             private QueueConnection qc;
1:             private Session session;
1:             private MessageConsumer mc;
1:             private List<String> idList;
1:             private boolean shutdown = false;
1:             private String qName;
1: 
1:             private ConsumerThread(String queueName, int batchSize) throws Exception {
1: 
1:                 this.batchSize = batchSize;
1: 
1:                 // Each thread has its own connection and session
1:                 qName = queueName;
1:                 qc = newQueueConnection();
1:                 session = newSession(qc);
1:                 Queue q = session.createQueue(queueName + "?consumer.prefetchSize=" + batchSize);
1:                 mc = session.createConsumer(q);
1: 
1:                 idList = idsByQueue.get(queueName);
1:             }
1: 
1:             public void run() {
1: 
1:                 try {
1: 
1:                     int count = 0;
1: 
1:                     // Keep reading as long as it hasn't been told to shutdown
1:                     while (!shutdown) {
1: 
1:                         if (idList.size() >= totalToExpect) {
1:                             LOG.info("Got {} for q: {}", +idList.size(), qName);
1:                             break;
1:                         }
1:                         Message m = mc.receive(4000);
1: 
1:                         if (m != null) {
1: 
1:                             // We received a non-null message, add the ID to our list
1: 
1:                             idList.add(m.getStringProperty("KEY"));
1: 
1:                             count++;
1: 
1:                             // If we've reached our batch size, commit the batch and reset the count
1: 
1:                             if (count == batchSize) {
1:                                 count = 0;
1:                             }
1:                         } else {
1: 
1:                             // We didn't receive anything this time, commit any current batch and reset the count
1: 
1:                             count = 0;
1: 
1:                             // Sleep a little before trying to read after not getting a message
1: 
1:                             try {
1:                                 if (idList.size() < totalToExpect) {
1:                                     LOG.info("did not receive on {}, current count: {}", qName, idList.size());
1:                                 }
1:                                 //sleep(3000);
1:                             } catch (Exception e) {
1:                             }
1:                         }
1:                     }
1:                 } catch (Exception e) {
1:                     e.printStackTrace();
1:                 } finally {
1: 
1:                     // Once we exit, close everything
1:                     close();
1:                 }
1:             }
1: 
1:             public void shutdown() {
1:                 shutdown = true;
1:             }
1: 
1:             public void close() {
1: 
1:                 try {
1:                     mc.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     session.close();
1:                 } catch (Exception e) {
1:                 }
1: 
1:                 try {
1:                     qc.close();
1:                 } catch (Exception e) {
1: 
1:                 }
1:             }
1:         }
1:     }
1: }
============================================================================