1:a88906f: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:a88906f:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a88906f:  *
1:a88906f:  * Unless required by applicable law or agreed to in writing, software
1:a88906f:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a88906f:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a88906f:  * See the License for the specific language governing permissions and
1:a88906f:  * limitations under the License.
1:a88906f:  */
7:a88906f: 
1:a88906f: package org.apache.activemq.tool;
1:a88906f: 
1:540dd5c: import java.util.Properties;
1:540dd5c: 
1:540dd5c: import javax.jms.BytesMessage;
1:540dd5c: import javax.jms.Connection;
1:540dd5c: import javax.jms.ConnectionFactory;
1:540dd5c: import javax.jms.DeliveryMode;
1:540dd5c: import javax.jms.Destination;
1:540dd5c: import javax.jms.JMSException;
1:540dd5c: import javax.jms.Message;
1:540dd5c: import javax.jms.Session;
1:540dd5c: 
1:a88906f: import org.apache.activemq.ActiveMQConnectionFactory;
1:a88906f: import org.apache.activemq.broker.BrokerService;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:a88906f: 
1:a88906f: 
1:a88906f: public class JMSMemtest {
1:a88906f: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JMSMemtest.class);
1:a88906f:     private static final int DEFAULT_MESSAGECOUNT = 5000;
1:540dd5c:     
1:a88906f:     protected BrokerService broker;
1:a88906f:     protected boolean topic = true;
1:540dd5c:     protected boolean durable;
1:540dd5c:     protected long messageCount;
1:a88906f: 
1:a88906f:     //  how large the message in kb before we close/start the producer/consumer with a new connection.  -1 means no connectionCheckpointSize
1:a88906f:     protected int connectionCheckpointSize;
1:a88906f:     protected long connectionInterval;
1:a88906f: 
1:a88906f: 
1:a88906f:     protected int consumerCount;
1:a88906f:     protected int producerCount;
1:a88906f:     protected int checkpointInterval;
1:a88906f:     protected int prefetchSize;
1:a88906f:     //set 10 kb of payload as default
1:a88906f:     protected int messageSize;
1:a88906f: 
1:a88906f:     protected String reportDirectory;
1:a88906f:     protected String reportName;
1:a88906f: 
1:a88906f: 
1:a88906f:     protected String url = "";
1:a88906f:     protected MemProducer[] producers;
1:a88906f:     protected MemConsumer[] consumers;
1:a88906f:     protected String destinationName;
1:a88906f:     protected boolean allMessagesConsumed = true;
1:a88906f:     protected MemConsumer allMessagesList = new MemConsumer();
1:a88906f: 
1:a88906f:     protected Message payload;
1:a88906f: 
1:a88906f:     protected ActiveMQConnectionFactory connectionFactory;
1:a88906f:     protected Connection connection;
1:a88906f:     protected Destination destination;
1:a88906f: 
1:a88906f: 
1:a88906f:     protected boolean createConnectionPerClient = true;
1:a88906f: 
1:540dd5c:     protected boolean transacted;
1:a88906f:     protected boolean useEmbeddedBroker = true;
1:a88906f:     protected MemoryMonitoringTool memoryMonitoringTool;
1:a88906f: 
1:540dd5c:     public JMSMemtest(Properties settings) {
1:540dd5c:         url = settings.getProperty("url");
1:540dd5c:         topic = new Boolean(settings.getProperty("topic")).booleanValue();
1:540dd5c:         durable = new Boolean(settings.getProperty("durable")).booleanValue();
1:540dd5c:         connectionCheckpointSize = new Integer(settings.getProperty("connectionCheckpointSize")).intValue();
1:540dd5c:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
1:540dd5c:         consumerCount = new Integer(settings.getProperty("consumerCount")).intValue();
1:540dd5c:         messageCount = new Integer(settings.getProperty("messageCount")).intValue();
1:540dd5c:         messageSize = new Integer(settings.getProperty("messageSize")).intValue();
1:540dd5c:         prefetchSize = new Integer(settings.getProperty("prefetchSize")).intValue();
1:540dd5c:         checkpointInterval = new Integer(settings.getProperty("checkpointInterval")).intValue() * 1000;
1:540dd5c:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
1:540dd5c:         reportName = settings.getProperty("reportName");
1:540dd5c:         destinationName = settings.getProperty("destinationName");
1:540dd5c:         reportDirectory = settings.getProperty("reportDirectory");
1:540dd5c:         connectionInterval = connectionCheckpointSize * 1024;
1:540dd5c:     }
1:a88906f: 
1:a88906f:     public static void main(String[] args) {
1:a88906f: 
1:a88906f: 
1:a88906f:         Properties sysSettings = new Properties();
1:a88906f: 
1:a88906f:         for (int i = 0; i < args.length; i++) {
1:a88906f: 
1:a88906f:             int index = args[i].indexOf("=");
1:a88906f:             String key = args[i].substring(0, index);
1:a88906f:             String val = args[i].substring(index + 1);
1:a88906f:             sysSettings.setProperty(key, val);
1:a88906f: 
2:a88906f:         }
1:a88906f: 
1:a88906f: 
1:a88906f:         JMSMemtest memtest = new JMSMemtest(sysSettings);
1:a88906f:         try {
1:a88906f:             memtest.start();
1:a88906f:         } catch (Exception e) {
1:a88906f: 
1:a88906f:             e.printStackTrace();
1:a88906f:         }
1:a88906f: 
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected void start() throws Exception {
1:540dd5c:         LOG.info("Starting Monitor");
1:a88906f:         memoryMonitoringTool = new MemoryMonitoringTool();
1:a88906f:         memoryMonitoringTool.setTestSettings(getSysTestSettings());
1:a88906f:         Thread monitorThread = memoryMonitoringTool.startMonitor();
1:a88906f: 
1:a88906f:         if (messageCount == 0) {
1:a88906f:             messageCount = DEFAULT_MESSAGECOUNT;
1:a88906f:         }
1:a88906f: 
1:a88906f: 
1:a88906f:         if (useEmbeddedBroker) {
1:a88906f:             if (broker == null) {
1:a88906f:                 broker = createBroker();
1:a88906f:             }
1:a88906f:         }
1:a88906f: 
1:a88906f: 
1:a88906f:         connectionFactory = (ActiveMQConnectionFactory) createConnectionFactory();
1:a88906f:         if (prefetchSize > 0) {
1:a88906f:             connectionFactory.getPrefetchPolicy().setTopicPrefetch(prefetchSize);
1:a88906f:             connectionFactory.getPrefetchPolicy().setQueuePrefetch(prefetchSize);
1:a88906f:         }
1:a88906f: 
1:a88906f:         connection = connectionFactory.createConnection();
1:a88906f:         Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1:a88906f: 
1:a88906f:         if (topic) {
1:a88906f:             destination = session.createTopic(destinationName);
1:a88906f:         } else {
1:a88906f:             destination = session.createQueue(destinationName);
1:a88906f:         }
1:a88906f: 
1:a88906f:         createPayload(session);
1:a88906f: 
1:a88906f:         publishAndConsume();
1:a88906f: 
1:540dd5c:         LOG.info("Closing resources");
1:a88906f:         this.close();
1:a88906f: 
1:a88906f:         monitorThread.join();
1:a88906f: 
1:a88906f: 
1:a88906f:     }
1:a88906f: 
1:a88906f: 
1:a88906f:     protected boolean resetConnection(int counter) {
1:a88906f:         if (connectionInterval > 0) {
1:a88906f:             long totalMsgSizeConsumed = counter * 1024;
1:a88906f:             if (connectionInterval < totalMsgSizeConsumed) {
1:a88906f:                 return true;
1:a88906f:             }
1:a88906f:         }
1:a88906f:         return false;
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected void publishAndConsume() throws Exception {
1:a88906f: 
1:a88906f:         createConsumers();
1:a88906f:         createProducers();
1:a88906f:         int counter = 0;
1:a88906f:         boolean resetCon = false;
1:540dd5c:         LOG.info("Start sending messages ");
1:a88906f:         for (int i = 0; i < messageCount; i++) {
1:540dd5c:             if (resetCon) {
1:a88906f:                 closeConsumers();
1:a88906f:                 closeProducers();
1:a88906f:                 createConsumers();
1:a88906f:                 createProducers();
1:a88906f:                 resetCon = false;
1:a88906f:             }
1:a88906f: 
1:a88906f:             for (int k = 0; k < producers.length; k++) {
1:a88906f:                 producers[k].sendMessage(payload, "counter", counter);
1:a88906f:                 counter++;
1:a88906f:                 if (resetConnection(counter)) {
1:a88906f:                     resetCon = true;
1:a88906f:                     break;
1:a88906f:                 }
1:a88906f:             }
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f: 
1:a88906f:     protected void close() throws Exception {
1:a88906f:         connection.close();
1:a88906f:         broker.stop();
1:a88906f: 
1:a88906f:         memoryMonitoringTool.stopMonitor();
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected void createPayload(Session session) throws JMSException {
1:a88906f: 
1:a88906f:         byte[] array = new byte[messageSize];
1:a88906f:         for (int i = 0; i < array.length; i++) {
1:a88906f:             array[i] = (byte) i;
1:a88906f:         }
1:a88906f: 
1:a88906f:         BytesMessage bystePayload = session.createBytesMessage();
1:a88906f:         bystePayload.writeBytes(array);
1:a88906f:         payload = (Message) bystePayload;
1:a88906f:     }
1:a88906f: 
1:a88906f: 
1:a88906f:     protected void createProducers() throws JMSException {
1:a88906f:         producers = new MemProducer[producerCount];
1:a88906f:         for (int i = 0; i < producerCount; i++) {
1:a88906f:             producers[i] = new MemProducer(connectionFactory, destination);
1:a88906f:             if (durable) {
1:a88906f:                 producers[i].setDeliveryMode(DeliveryMode.PERSISTENT);
1:a88906f:             } else {
1:a88906f:                 producers[i].setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:a88906f:             }
1:a88906f:             producers[i].start();
1:a88906f:         }
1:a88906f: 
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected void createConsumers() throws JMSException {
1:a88906f:         consumers = new MemConsumer[consumerCount];
1:a88906f:         for (int i = 0; i < consumerCount; i++) {
1:a88906f:             consumers[i] = new MemConsumer(connectionFactory, destination);
1:a88906f:             consumers[i].setParent(allMessagesList);
1:a88906f:             consumers[i].start();
1:a88906f: 
1:a88906f: 
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected void closeProducers() throws JMSException {
1:a88906f:         for (int i = 0; i < producerCount; i++) {
1:a88906f:             producers[i].shutDown();
1:a88906f:         }
1:a88906f: 
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected void closeConsumers() throws JMSException {
1:a88906f:         for (int i = 0; i < consumerCount; i++) {
1:a88906f:             consumers[i].shutDown();
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected ConnectionFactory createConnectionFactory() throws JMSException {
1:a88906f: 
1:a88906f:         if (url == null || url.trim().equals("") || url.trim().equals("null")) {
1:a88906f:             return new ActiveMQConnectionFactory("vm://localhost");
1:a88906f:         } else {
1:a88906f:             return new ActiveMQConnectionFactory(url);
1:a88906f:         }
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected BrokerService createBroker() throws Exception {
1:a88906f:         BrokerService broker = new BrokerService();
1:a88906f:         configureBroker(broker);
1:a88906f:         broker.start();
1:a88906f:         return broker;
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected void configureBroker(BrokerService broker) throws Exception {
1:a88906f:         broker.addConnector("vm://localhost");
1:a88906f:         broker.setDeleteAllMessagesOnStartup(true);
1:a88906f:     }
1:a88906f: 
1:a88906f:     protected Properties getSysTestSettings() {
1:a88906f:         Properties settings = new Properties();
1:540dd5c:         settings.setProperty("domain", topic ? "topic" : "queue");
1:540dd5c:         settings.setProperty("durable", durable ? "durable" : "non-durable");
1:a88906f:         settings.setProperty("connection_checkpoint_size_kb", new Integer(connectionCheckpointSize).toString());
1:a88906f:         settings.setProperty("producer_count", new Integer(producerCount).toString());
1:a88906f:         settings.setProperty("consumer_count", new Integer(consumerCount).toString());
1:a88906f:         settings.setProperty("message_count", new Long(messageCount).toString());
1:a88906f:         settings.setProperty("message_size", new Integer(messageSize).toString());
1:a88906f:         settings.setProperty("prefetchSize", new Integer(prefetchSize).toString());
1:a88906f:         settings.setProperty("checkpoint_interval", new Integer(checkpointInterval).toString());
1:a88906f:         settings.setProperty("destination_name", destinationName);
1:a88906f:         settings.setProperty("report_name", reportName);
1:a88906f:         settings.setProperty("report_directory", reportDirectory);
1:a88906f:         settings.setProperty("connection_checkpoint_size", new Integer(connectionCheckpointSize).toString());
1:a88906f:         return settings;
1:a88906f:     }
1:a88906f: 
1:a88906f: 
1:a88906f: }
============================================================================
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:87e878b
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JMSMemtest.class);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: 
1: import javax.jms.BytesMessage;
1: import javax.jms.Connection;
1: import javax.jms.ConnectionFactory;
1: import javax.jms.DeliveryMode;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.Session;
1: 
0:     private static final Log LOG = LogFactory.getLog(JMSMemtest.class);
1:     
1:     protected boolean durable;
1:     protected long messageCount;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean transacted;
1:     public JMSMemtest(Properties settings) {
1:         url = settings.getProperty("url");
1:         topic = new Boolean(settings.getProperty("topic")).booleanValue();
1:         durable = new Boolean(settings.getProperty("durable")).booleanValue();
1:         connectionCheckpointSize = new Integer(settings.getProperty("connectionCheckpointSize")).intValue();
1:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
1:         consumerCount = new Integer(settings.getProperty("consumerCount")).intValue();
1:         messageCount = new Integer(settings.getProperty("messageCount")).intValue();
1:         messageSize = new Integer(settings.getProperty("messageSize")).intValue();
1:         prefetchSize = new Integer(settings.getProperty("prefetchSize")).intValue();
1:         checkpointInterval = new Integer(settings.getProperty("checkpointInterval")).intValue() * 1000;
1:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
1:         reportName = settings.getProperty("reportName");
1:         destinationName = settings.getProperty("destinationName");
1:         reportDirectory = settings.getProperty("reportDirectory");
1:         connectionInterval = connectionCheckpointSize * 1024;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Starting Monitor");
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Closing resources");
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("Start sending messages ");
1:             if (resetCon) {
/////////////////////////////////////////////////////////////////////////
1:         settings.setProperty("domain", topic ? "topic" : "queue");
1:         settings.setProperty("durable", durable ? "durable" : "non-durable");
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a88906f
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.tool;
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.tool.MemProducer;
0: import org.apache.activemq.tool.MemConsumer;
0: import org.apache.activemq.tool.MemoryMonitoringTool;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import javax.jms.*;
1: 
1: 
0: import java.util.Properties;
1: 
1: 
1: public class JMSMemtest {
1: 
0:     private static final Log log = LogFactory.getLog(JMSMemtest.class);
1:     private static final int DEFAULT_MESSAGECOUNT = 5000;
1:     protected BrokerService broker;
1:     protected boolean topic = true;
0:     protected boolean durable = false;
1: 
0:     protected long messageCount = 0;
1: 
1:     //  how large the message in kb before we close/start the producer/consumer with a new connection.  -1 means no connectionCheckpointSize
1:     protected int connectionCheckpointSize;
1:     protected long connectionInterval;
1: 
1: 
1:     protected int consumerCount;
1:     protected int producerCount;
1:     protected int checkpointInterval;
1:     protected int prefetchSize;
1:     //set 10 kb of payload as default
1:     protected int messageSize;
1: 
1:     protected String reportDirectory;
1:     protected String reportName;
1: 
1: 
1:     protected String url = "";
1:     protected MemProducer[] producers;
1:     protected MemConsumer[] consumers;
1:     protected String destinationName;
1:     protected boolean allMessagesConsumed = true;
1:     protected MemConsumer allMessagesList = new MemConsumer();
1: 
1:     protected Message payload;
1: 
1:     protected ActiveMQConnectionFactory connectionFactory;
1:     protected Connection connection;
1:     protected Destination destination;
1: 
1: 
1:     protected boolean createConnectionPerClient = true;
1: 
0:     protected boolean transacted = false;
1:     protected boolean useEmbeddedBroker = true;
1:     protected MemoryMonitoringTool memoryMonitoringTool;
1: 
1: 
1:     public static void main(String[] args) {
1: 
1: 
1:         Properties sysSettings = new Properties();
1: 
1:         for (int i = 0; i < args.length; i++) {
1: 
1:             int index = args[i].indexOf("=");
1:             String key = args[i].substring(0, index);
1:             String val = args[i].substring(index + 1);
1:             sysSettings.setProperty(key, val);
1: 
1:         }
1: 
1: 
1:         JMSMemtest memtest = new JMSMemtest(sysSettings);
1:         try {
1:             memtest.start();
1:         } catch (Exception e) {
1: 
1:             e.printStackTrace();
1:         }
1: 
1:     }
1: 
1: 
0:     public JMSMemtest(Properties settings) {
0:         url = settings.getProperty("url");
0:         topic = new Boolean(settings.getProperty("topic")).booleanValue();
0:         durable = new Boolean(settings.getProperty("durable")).booleanValue();
0:         connectionCheckpointSize = new Integer(settings.getProperty("connectionCheckpointSize")).intValue();
0:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
0:         consumerCount = new Integer(settings.getProperty("consumerCount")).intValue();
0:         messageCount = new Integer(settings.getProperty("messageCount")).intValue();
0:         messageSize = new Integer(settings.getProperty("messageSize")).intValue();
0:         prefetchSize = new Integer(settings.getProperty("prefetchSize")).intValue();
0:         checkpointInterval = new Integer(settings.getProperty("checkpointInterval")).intValue() * 1000;
0:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
0:         reportName = settings.getProperty("reportName");
0:         destinationName = settings.getProperty("destinationName");
0:         reportDirectory = settings.getProperty("reportDirectory");
0:         connectionInterval = connectionCheckpointSize * 1024;
1:     }
1: 
1:     protected void start() throws Exception {
0:         log.info("Starting Monitor");
1:         memoryMonitoringTool = new MemoryMonitoringTool();
1:         memoryMonitoringTool.setTestSettings(getSysTestSettings());
1:         Thread monitorThread = memoryMonitoringTool.startMonitor();
1: 
1:         if (messageCount == 0) {
1:             messageCount = DEFAULT_MESSAGECOUNT;
1:         }
1: 
1: 
1:         if (useEmbeddedBroker) {
1:             if (broker == null) {
1:                 broker = createBroker();
1:             }
1:         }
1: 
1: 
1:         connectionFactory = (ActiveMQConnectionFactory) createConnectionFactory();
1:         if (prefetchSize > 0) {
1:             connectionFactory.getPrefetchPolicy().setTopicPrefetch(prefetchSize);
1:             connectionFactory.getPrefetchPolicy().setQueuePrefetch(prefetchSize);
1:         }
1: 
1:         connection = connectionFactory.createConnection();
1:         Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
1: 
1:         if (topic) {
1:             destination = session.createTopic(destinationName);
1:         } else {
1:             destination = session.createQueue(destinationName);
1:         }
1: 
1:         createPayload(session);
1: 
1:         publishAndConsume();
1: 
0:         log.info("Closing resources");
1:         this.close();
1: 
1:         monitorThread.join();
1: 
1: 
1:     }
1: 
1: 
1:     protected boolean resetConnection(int counter) {
1:         if (connectionInterval > 0) {
1:             long totalMsgSizeConsumed = counter * 1024;
1:             if (connectionInterval < totalMsgSizeConsumed) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     protected void publishAndConsume() throws Exception {
1: 
1:         createConsumers();
1:         createProducers();
1:         int counter = 0;
1:         boolean resetCon = false;
0:         log.info("Start sending messages ");
1:         for (int i = 0; i < messageCount; i++) {
0:             if (resetCon == true) {
1:                 closeConsumers();
1:                 closeProducers();
1:                 createConsumers();
1:                 createProducers();
1:                 resetCon = false;
1:             }
1: 
1:             for (int k = 0; k < producers.length; k++) {
1:                 producers[k].sendMessage(payload, "counter", counter);
1:                 counter++;
1:                 if (resetConnection(counter)) {
1:                     resetCon = true;
1:                     break;
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
1:     protected void close() throws Exception {
1:         connection.close();
1:         broker.stop();
1: 
1:         memoryMonitoringTool.stopMonitor();
1:     }
1: 
1:     protected void createPayload(Session session) throws JMSException {
1: 
1:         byte[] array = new byte[messageSize];
1:         for (int i = 0; i < array.length; i++) {
1:             array[i] = (byte) i;
1:         }
1: 
1:         BytesMessage bystePayload = session.createBytesMessage();
1:         bystePayload.writeBytes(array);
1:         payload = (Message) bystePayload;
1:     }
1: 
1: 
1:     protected void createProducers() throws JMSException {
1:         producers = new MemProducer[producerCount];
1:         for (int i = 0; i < producerCount; i++) {
1:             producers[i] = new MemProducer(connectionFactory, destination);
1:             if (durable) {
1:                 producers[i].setDeliveryMode(DeliveryMode.PERSISTENT);
1:             } else {
1:                 producers[i].setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:             }
1:             producers[i].start();
1:         }
1: 
1:     }
1: 
1:     protected void createConsumers() throws JMSException {
1:         consumers = new MemConsumer[consumerCount];
1:         for (int i = 0; i < consumerCount; i++) {
1:             consumers[i] = new MemConsumer(connectionFactory, destination);
1:             consumers[i].setParent(allMessagesList);
1:             consumers[i].start();
1: 
1: 
1:         }
1:     }
1: 
1:     protected void closeProducers() throws JMSException {
1:         for (int i = 0; i < producerCount; i++) {
1:             producers[i].shutDown();
1:         }
1: 
1:     }
1: 
1:     protected void closeConsumers() throws JMSException {
1:         for (int i = 0; i < consumerCount; i++) {
1:             consumers[i].shutDown();
1:         }
1:     }
1: 
1:     protected ConnectionFactory createConnectionFactory() throws JMSException {
1: 
1:         if (url == null || url.trim().equals("") || url.trim().equals("null")) {
1:             return new ActiveMQConnectionFactory("vm://localhost");
1:         } else {
1:             return new ActiveMQConnectionFactory(url);
1:         }
1:     }
1: 
1:     protected BrokerService createBroker() throws Exception {
1:         BrokerService broker = new BrokerService();
1:         configureBroker(broker);
1:         broker.start();
1:         return broker;
1:     }
1: 
1:     protected void configureBroker(BrokerService broker) throws Exception {
1:         broker.addConnector("vm://localhost");
1:         broker.setDeleteAllMessagesOnStartup(true);
1:     }
1: 
1:     protected Properties getSysTestSettings() {
1:         Properties settings = new Properties();
0:         settings.setProperty("domain", topic == true ? "topic" : "queue");
0:         settings.setProperty("durable", durable == true ? "durable" : "non-durable");
1:         settings.setProperty("connection_checkpoint_size_kb", new Integer(connectionCheckpointSize).toString());
1:         settings.setProperty("producer_count", new Integer(producerCount).toString());
1:         settings.setProperty("consumer_count", new Integer(consumerCount).toString());
1:         settings.setProperty("message_count", new Long(messageCount).toString());
1:         settings.setProperty("message_size", new Integer(messageSize).toString());
1:         settings.setProperty("prefetchSize", new Integer(prefetchSize).toString());
1:         settings.setProperty("checkpoint_interval", new Integer(checkpointInterval).toString());
1:         settings.setProperty("destination_name", destinationName);
1:         settings.setProperty("report_name", reportName);
1:         settings.setProperty("report_directory", reportDirectory);
1:         settings.setProperty("connection_checkpoint_size", new Integer(connectionCheckpointSize).toString());
1:         return settings;
1:     }
1: 
1: 
1: }
author:James Strachan
-------------------------------------------------------------------------------
commit:dd55c21
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:2054392
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: 
0: package org.apache.activemq.tool;
0: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.tool.MemProducer;
0: import org.apache.activemq.tool.MemConsumer;
0: import org.apache.activemq.tool.MemoryMonitoringTool;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import javax.jms.*;
0: 
0: 
0: import java.util.Properties;
0: 
0: 
0: public class JMSMemtest {
0: 
0:     private static final Log log = LogFactory.getLog(JMSMemtest.class);
0:     private static final int DEFAULT_MESSAGECOUNT = 5000;
0:     protected BrokerService broker;
0:     protected boolean topic = true;
0:     protected boolean durable = false;
0: 
0:     protected long messageCount = 0;
0: 
0:     //  how large the message in kb before we close/start the producer/consumer with a new connection.  -1 means no connectionCheckpointSize
0:     protected int connectionCheckpointSize;
0:     protected long connectionInterval;
0: 
0: 
0:     protected int consumerCount;
0:     protected int producerCount;
0:     protected int checkpointInterval;
0:     protected int prefetchSize;
0:     //set 10 kb of payload as default
0:     protected int messageSize;
0: 
0:     protected String reportDirectory;
0:     protected String reportName;
0: 
0: 
0:     protected String url = "";
0:     protected MemProducer[] producers;
0:     protected MemConsumer[] consumers;
0:     protected String destinationName;
0:     protected boolean allMessagesConsumed = true;
0:     protected MemConsumer allMessagesList = new MemConsumer();
0: 
0:     protected Message payload;
0: 
0:     protected ActiveMQConnectionFactory connectionFactory;
0:     protected Connection connection;
0:     protected Destination destination;
0: 
0: 
0:     protected boolean createConnectionPerClient = true;
0: 
0:     protected boolean transacted = false;
0:     protected boolean useEmbeddedBroker = true;
0:     protected MemoryMonitoringTool memoryMonitoringTool;
0: 
0: 
0:     public static void main(String[] args) {
0: 
0: 
0:         Properties sysSettings = new Properties();
0: 
0:         for (int i = 0; i < args.length; i++) {
0: 
0:             int index = args[i].indexOf("=");
0:             String key = args[i].substring(0, index);
0:             String val = args[i].substring(index + 1);
0:             sysSettings.setProperty(key, val);
0: 
0:         }
0: 
0: 
0:         JMSMemtest memtest = new JMSMemtest(sysSettings);
0:         try {
0:             memtest.start();
0:         } catch (Exception e) {
0: 
0:             e.printStackTrace();
0:         }
0: 
0:     }
0: 
0: 
0:     public JMSMemtest(Properties settings) {
0:         url = settings.getProperty("url");
0:         topic = new Boolean(settings.getProperty("topic")).booleanValue();
0:         durable = new Boolean(settings.getProperty("durable")).booleanValue();
0:         connectionCheckpointSize = new Integer(settings.getProperty("connectionCheckpointSize")).intValue();
0:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
0:         consumerCount = new Integer(settings.getProperty("consumerCount")).intValue();
0:         messageCount = new Integer(settings.getProperty("messageCount")).intValue();
0:         messageSize = new Integer(settings.getProperty("messageSize")).intValue();
0:         prefetchSize = new Integer(settings.getProperty("prefetchSize")).intValue();
0:         checkpointInterval = new Integer(settings.getProperty("checkpointInterval")).intValue() * 1000;
0:         producerCount = new Integer(settings.getProperty("producerCount")).intValue();
0:         reportName = settings.getProperty("reportName");
0:         destinationName = settings.getProperty("destinationName");
0:         reportDirectory = settings.getProperty("reportDirectory");
0:         connectionInterval = connectionCheckpointSize * 1024;
0:     }
0: 
0:     protected void start() throws Exception {
0:         log.info("Starting Monitor");
0:         memoryMonitoringTool = new MemoryMonitoringTool();
0:         memoryMonitoringTool.setTestSettings(getSysTestSettings());
0:         Thread monitorThread = memoryMonitoringTool.startMonitor();
0: 
0:         if (messageCount == 0) {
0:             messageCount = DEFAULT_MESSAGECOUNT;
0:         }
0: 
0: 
0:         if (useEmbeddedBroker) {
0:             if (broker == null) {
0:                 broker = createBroker();
0:             }
0:         }
0: 
0: 
0:         connectionFactory = (ActiveMQConnectionFactory) createConnectionFactory();
0:         if (prefetchSize > 0) {
0:             connectionFactory.getPrefetchPolicy().setTopicPrefetch(prefetchSize);
0:             connectionFactory.getPrefetchPolicy().setQueuePrefetch(prefetchSize);
0:         }
0: 
0:         connection = connectionFactory.createConnection();
0:         Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
0: 
0:         if (topic) {
0:             destination = session.createTopic(destinationName);
0:         } else {
0:             destination = session.createQueue(destinationName);
0:         }
0: 
0:         createPayload(session);
0: 
0:         publishAndConsume();
0: 
0:         log.info("Closing resources");
0:         this.close();
0: 
0:         monitorThread.join();
0: 
0: 
0:     }
0: 
0: 
0:     protected boolean resetConnection(int counter) {
0:         if (connectionInterval > 0) {
0:             long totalMsgSizeConsumed = counter * 1024;
0:             if (connectionInterval < totalMsgSizeConsumed) {
0:                 return true;
0:             }
0:         }
0:         return false;
0:     }
0: 
0:     protected void publishAndConsume() throws Exception {
0: 
0:         createConsumers();
0:         createProducers();
0:         int counter = 0;
0:         boolean resetCon = false;
0:         log.info("Start sending messages ");
0:         for (int i = 0; i < messageCount; i++) {
0:             if (resetCon == true) {
0:                 closeConsumers();
0:                 closeProducers();
0:                 createConsumers();
0:                 createProducers();
0:                 resetCon = false;
0:             }
0: 
0:             for (int k = 0; k < producers.length; k++) {
0:                 producers[k].sendMessage(payload, "counter", counter);
0:                 counter++;
0:                 if (resetConnection(counter)) {
0:                     resetCon = true;
0:                     break;
0:                 }
0:             }
0:         }
0:     }
0: 
0: 
0:     protected void close() throws Exception {
0:         connection.close();
0:         broker.stop();
0: 
0:         memoryMonitoringTool.stopMonitor();
0:     }
0: 
0:     protected void createPayload(Session session) throws JMSException {
0: 
0:         byte[] array = new byte[messageSize];
0:         for (int i = 0; i < array.length; i++) {
0:             array[i] = (byte) i;
0:         }
0: 
0:         BytesMessage bystePayload = session.createBytesMessage();
0:         bystePayload.writeBytes(array);
0:         payload = (Message) bystePayload;
0:     }
0: 
0: 
0:     protected void createProducers() throws JMSException {
0:         producers = new MemProducer[producerCount];
0:         for (int i = 0; i < producerCount; i++) {
0:             producers[i] = new MemProducer(connectionFactory, destination);
0:             if (durable) {
0:                 producers[i].setDeliveryMode(DeliveryMode.PERSISTENT);
0:             } else {
0:                 producers[i].setDeliveryMode(DeliveryMode.NON_PERSISTENT);
0:             }
0:             producers[i].start();
0:         }
0: 
0:     }
0: 
0:     protected void createConsumers() throws JMSException {
0:         consumers = new MemConsumer[consumerCount];
0:         for (int i = 0; i < consumerCount; i++) {
0:             consumers[i] = new MemConsumer(connectionFactory, destination);
0:             consumers[i].setParent(allMessagesList);
0:             consumers[i].start();
0: 
0: 
0:         }
0:     }
0: 
0:     protected void closeProducers() throws JMSException {
0:         for (int i = 0; i < producerCount; i++) {
0:             producers[i].shutDown();
0:         }
0: 
0:     }
0: 
0:     protected void closeConsumers() throws JMSException {
0:         for (int i = 0; i < consumerCount; i++) {
0:             consumers[i].shutDown();
0:         }
0:     }
0: 
0:     protected ConnectionFactory createConnectionFactory() throws JMSException {
0: 
0:         if (url == null || url.trim().equals("") || url.trim().equals("null")) {
0:             return new ActiveMQConnectionFactory("vm://localhost");
0:         } else {
0:             return new ActiveMQConnectionFactory(url);
0:         }
0:     }
0: 
0:     protected BrokerService createBroker() throws Exception {
0:         BrokerService broker = new BrokerService();
0:         configureBroker(broker);
0:         broker.start();
0:         return broker;
0:     }
0: 
0:     protected void configureBroker(BrokerService broker) throws Exception {
0:         broker.addConnector("vm://localhost");
0:         broker.setDeleteAllMessagesOnStartup(true);
0:     }
0: 
0:     protected Properties getSysTestSettings() {
0:         Properties settings = new Properties();
0:         settings.setProperty("domain", topic == true ? "topic" : "queue");
0:         settings.setProperty("durable", durable == true ? "durable" : "non-durable");
0:         settings.setProperty("connection_checkpoint_size_kb", new Integer(connectionCheckpointSize).toString());
0:         settings.setProperty("producer_count", new Integer(producerCount).toString());
0:         settings.setProperty("consumer_count", new Integer(consumerCount).toString());
0:         settings.setProperty("message_count", new Long(messageCount).toString());
0:         settings.setProperty("message_size", new Integer(messageSize).toString());
0:         settings.setProperty("prefetchSize", new Integer(prefetchSize).toString());
0:         settings.setProperty("checkpoint_interval", new Integer(checkpointInterval).toString());
0:         settings.setProperty("destination_name", destinationName);
0:         settings.setProperty("report_name", reportName);
0:         settings.setProperty("report_directory", reportDirectory);
0:         settings.setProperty("connection_checkpoint_size", new Integer(connectionCheckpointSize).toString());
0:         return settings;
0:     }
0: 
0: 
0: }
============================================================================