1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f812e34:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
31:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.command;
2:d29ca2a: 
1:d29ca2a: import java.io.DataInputStream;
1:d29ca2a: import java.io.DataOutputStream;
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.io.InputStream;
1:d75bb6d: import java.io.ObjectStreamException;
1:d29ca2a: import java.io.OutputStream;
1:d29ca2a: import java.util.Collections;
1:d29ca2a: import java.util.Enumeration;
1:d29ca2a: import java.util.HashMap;
1:e6f5d30: import java.util.Map;
1:d29ca2a: import java.util.zip.DeflaterOutputStream;
1:d29ca2a: import java.util.zip.InflaterInputStream;
1:d29ca2a: 
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.MapMessage;
1:d29ca2a: import javax.jms.MessageFormatException;
1:d29ca2a: import javax.jms.MessageNotWriteableException;
1:d29ca2a: 
1:d29ca2a: import org.apache.activemq.ActiveMQConnection;
1:88acb0e: import org.apache.activemq.util.ByteArrayInputStream;
1:88acb0e: import org.apache.activemq.util.ByteArrayOutputStream;
1:88acb0e: import org.apache.activemq.util.ByteSequence;
1:d29ca2a: import org.apache.activemq.util.JMSExceptionSupport;
1:d29ca2a: import org.apache.activemq.util.MarshallingSupport;
1:88acb0e: import org.apache.activemq.wireformat.WireFormat;
1:543935b: import org.fusesource.hawtbuf.UTF8Buffer;
1:d29ca2a: 
1:d29ca2a: /**
1:f812e34:  * A <CODE>MapMessage</CODE> object is used to send a set of name-value pairs.
1:f812e34:  * The names are <CODE>String</CODE> objects, and the values are primitive
1:f812e34:  * data types in the Java programming language. The names must have a value that
1:f812e34:  * is not null, and not an empty string. The entries can be accessed
1:f812e34:  * sequentially or randomly by name. The order of the entries is undefined.
1:f812e34:  * <CODE>MapMessage</CODE> inherits from the <CODE>Message</CODE> interface
1:f812e34:  * and adds a message body that contains a Map.
1:f812e34:  * <P>
1:f812e34:  * The primitive types can be read or written explicitly using methods for each
1:f812e34:  * type. They may also be read or written generically as objects. For instance,
1:f812e34:  * a call to <CODE>MapMessage.setInt("foo", 6)</CODE> is equivalent to
1:f812e34:  * <CODE> MapMessage.setObject("foo", new Integer(6))</CODE>. Both forms are
1:f812e34:  * provided, because the explicit form is convenient for static programming, and
1:f812e34:  * the object form is needed when types are not known at compile time.
1:f812e34:  * <P>
1:f812e34:  * When a client receives a <CODE>MapMessage</CODE>, it is in read-only mode.
1:f812e34:  * If a client attempts to write to the message at this point, a
1:f812e34:  * <CODE>MessageNotWriteableException</CODE> is thrown. If
1:f812e34:  * <CODE>clearBody</CODE> is called, the message can now be both read from and
1:f812e34:  * written to.
1:f812e34:  * <P>
1:f812e34:  * <CODE>MapMessage</CODE> objects support the following conversion table. The
1:f812e34:  * marked cases must be supported. The unmarked cases must throw a
1:f812e34:  * <CODE>JMSException</CODE>. The <CODE>String</CODE> -to-primitive
1:f812e34:  * conversions may throw a runtime exception if the primitive's
1:f812e34:  * <CODE>valueOf()</CODE> method does not accept it as a valid
1:f812e34:  * <CODE> String</CODE> representation of the primitive.
1:f812e34:  * <P>
1:f812e34:  * A value written as the row type can be read as the column type. <p/>
1:f812e34:  *
1:f812e34:  * <PRE>
1:f812e34:  * | | boolean byte short char int long float double String byte[] |----------------------------------------------------------------------
1:d29ca2a:  * |boolean | X X |byte | X X X X X |short | X X X X |char | X X |int | X X X |long | X X |float | X X X |double | X X
1:d29ca2a:  * |String | X X X X X X X X |byte[] | X |----------------------------------------------------------------------
1:f812e34:  * &lt;p/&gt;
1:d29ca2a:  * </PRE>
1:f812e34:  *
3:d29ca2a:  * <p/>
1:f812e34:  * <P>
1:f812e34:  * Attempting to read a null value as a primitive type must be treated as
1:f812e34:  * calling the primitive's corresponding <code>valueOf(String)</code>
1:f812e34:  * conversion method with a null value. Since <code>char</code> does not
1:f812e34:  * support a <code>String</code> conversion, attempting to read a null value
1:f812e34:  * as a <code>char</code> must throw a <code>NullPointerException</code>.
1:f812e34:  *
1:4afa5d6:  * @openwire:marshaller code="25"
1:d29ca2a:  * @see javax.jms.Session#createMapMessage()
1:d29ca2a:  * @see javax.jms.BytesMessage
1:d29ca2a:  * @see javax.jms.Message
1:d29ca2a:  * @see javax.jms.ObjectMessage
1:d29ca2a:  * @see javax.jms.StreamMessage
1:d29ca2a:  * @see javax.jms.TextMessage
1:d29ca2a:  */
1:d29ca2a: public class ActiveMQMapMessage extends ActiveMQMessage implements MapMessage {
1:d29ca2a: 
1:d29ca2a:     public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_MAP_MESSAGE;
1:d29ca2a: 
1:ecf89a6:     protected transient Map<String, Object> map = new HashMap<String, Object>();
1:d29ca2a: 
1:d75bb6d:     private Object readResolve() throws ObjectStreamException {
1:543935b:         if (this.map == null) {
1:d75bb6d:             this.map = new HashMap<String, Object>();
1:543935b:         }
1:d75bb6d:         return this;
1:543935b:     }
1:e6f5d30: 
1:f82993d:     @Override
1:d29ca2a:     public Message copy() {
1:d29ca2a:         ActiveMQMapMessage copy = new ActiveMQMapMessage();
1:d29ca2a:         copy(copy);
1:d29ca2a:         return copy;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     private void copy(ActiveMQMapMessage copy) {
1:d29ca2a:         storeContent();
1:d29ca2a:         super.copy(copy);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // We only need to marshal the content if we are hitting the wire.
1:543935b:     @Override
1:d29ca2a:     public void beforeMarshall(WireFormat wireFormat) throws IOException {
1:d29ca2a:         super.beforeMarshall(wireFormat);
1:d29ca2a:         storeContent();
1:d29ca2a:     }
1:f812e34: 
1:543935b:     @Override
1:7c3bb40:     public void clearUnMarshalledState() throws JMSException {
1:7c3bb40:         super.clearUnMarshalledState();
1:c1da3ac:         map.clear();
1:543935b:     }
1:d29ca2a: 
1:543935b:     @Override
1:3003895:     public void storeContentAndClear() {
1:3003895:         storeContent();
1:3003895:         map.clear();
1:3003895:     }
1:3003895: 
1:3003895:     @Override
1:41c9366:     public void storeContent() {
1:d29ca2a:         try {
1:f812e34:             if (getContent() == null && !map.isEmpty()) {
1:d29ca2a:                 ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
1:d29ca2a:                 OutputStream os = bytesOut;
1:d29ca2a:                 ActiveMQConnection connection = getConnection();
1:f812e34:                 if (connection != null && connection.isUseCompression()) {
1:d29ca2a:                     compressed = true;
1:d29ca2a:                     os = new DeflaterOutputStream(os);
1:d29ca2a:                 }
1:d29ca2a:                 DataOutputStream dataOut = new DataOutputStream(os);
1:d29ca2a:                 MarshallingSupport.marshalPrimitiveMap(map, dataOut);
1:d29ca2a:                 dataOut.close();
1:d29ca2a:                 setContent(bytesOut.toByteSequence());
1:d29ca2a:             }
1:d29ca2a:         } catch (IOException e) {
1:d29ca2a:             throw new RuntimeException(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:543935b:     @Override
1:f82993d:     public boolean isContentMarshalled() {
1:f82993d:         return content != null || map == null || map.isEmpty();
1:f82993d:     }
1:f82993d: 
1:d29ca2a:     /**
1:d29ca2a:      * Builds the message body from data
1:f812e34:      *
1:f812e34:      * @throws JMSException
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:d29ca2a:     private void loadContent() throws JMSException {
1:d29ca2a:         try {
1:f812e34:             if (getContent() != null && map.isEmpty()) {
1:d29ca2a:                 ByteSequence content = getContent();
1:d29ca2a:                 InputStream is = new ByteArrayInputStream(content);
1:f812e34:                 if (isCompressed()) {
1:d29ca2a:                     is = new InflaterInputStream(is);
1:d29ca2a:                 }
1:d29ca2a:                 DataInputStream dataIn = new DataInputStream(is);
1:d29ca2a:                 map = MarshallingSupport.unmarshalPrimitiveMap(dataIn);
1:d29ca2a:                 dataIn.close();
1:d29ca2a:             }
1:d29ca2a:         } catch (IOException e) {
1:d29ca2a:             throw JMSExceptionSupport.create(e);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:41c9366:     @Override
1:d29ca2a:     public byte getDataStructureType() {
1:d29ca2a:         return DATA_STRUCTURE_TYPE;
1:d29ca2a:     }
1:f812e34: 
1:543935b:     @Override
1:05a8cba:     public String getJMSXMimeType() {
1:05a8cba:         return "jms/map-message";
1:543935b:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * Clears out the message body. Clearing a message's body does not clear its
1:f812e34:      * header values or property entries.
1:f812e34:      * <P>
1:f812e34:      * If this message body was read-only, calling this method leaves the
1:f812e34:      * message body in the same state as an empty body in a newly created
1:f812e34:      * message.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void clearBody() throws JMSException {
1:d29ca2a:         super.clearBody();
1:d29ca2a:         map.clear();
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>boolean</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>boolean</CODE>
1:d29ca2a:      * @return the <CODE>boolean</CODE> value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public boolean getBoolean(String name) throws JMSException {
1:e6f5d30:         initializeReading();
2:d29ca2a:         Object value = map.get(name);
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return false;
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Boolean) {
1:f812e34:             return ((Boolean)value).booleanValue();
1:d29ca2a:         }
1:543935b:         if (value instanceof UTF8Buffer) {
1:543935b:             return Boolean.valueOf(value.toString()).booleanValue();
1:543935b:         }
2:d29ca2a:         if (value instanceof String) {
1:d29ca2a:             return Boolean.valueOf(value.toString()).booleanValue();
2:d29ca2a:         } else {
1:d29ca2a:             throw new MessageFormatException(" cannot read a boolean from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>byte</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>byte</CODE>
1:d29ca2a:      * @return the <CODE>byte</CODE> value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public byte getByte(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return 0;
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Byte) {
1:f812e34:             return ((Byte)value).byteValue();
1:d29ca2a:         }
1:543935b:         if (value instanceof UTF8Buffer) {
1:d29ca2a:             return Byte.valueOf(value.toString()).byteValue();
1:543935b:         }
1:d29ca2a:         if (value instanceof String) {
1:543935b:             return Byte.valueOf(value.toString()).byteValue();
1:d29ca2a:         } else {
1:d29ca2a:             throw new MessageFormatException(" cannot read a byte from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>short</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>short</CODE>
1:d29ca2a:      * @return the <CODE>short</CODE> value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public short getShort(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return 0;
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Short) {
1:f812e34:             return ((Short)value).shortValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Byte) {
1:f812e34:             return ((Byte)value).shortValue();
1:d29ca2a:         }
1:543935b:         if (value instanceof UTF8Buffer) {
1:d29ca2a:             return Short.valueOf(value.toString()).shortValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof String) {
1:543935b:             return Short.valueOf(value.toString()).shortValue();
1:d29ca2a:         } else {
2:d29ca2a:             throw new MessageFormatException(" cannot read a short from " + value.getClass().getName());
1:d29ca2a:         }
1:543935b:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the Unicode character value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the Unicode character
1:d29ca2a:      * @return the Unicode character value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public char getChar(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:4d5bb4a: 
1:d29ca2a:         if (value == null) {
1:d29ca2a:             throw new NullPointerException();
1:4d5bb4a:         } else if (value instanceof Character) {
1:f812e34:             return ((Character)value).charValue();
1:d29ca2a:         } else {
1:4d5bb4a:             throw new MessageFormatException(" cannot read a char from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>int</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>int</CODE>
1:d29ca2a:      * @return the <CODE>int</CODE> value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public int getInt(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return 0;
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Integer) {
1:f812e34:             return ((Integer)value).intValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Short) {
1:f812e34:             return ((Short)value).intValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Byte) {
1:f812e34:             return ((Byte)value).intValue();
1:d29ca2a:         }
1:543935b:         if (value instanceof UTF8Buffer) {
1:d29ca2a:             return Integer.valueOf(value.toString()).intValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof String) {
1:543935b:             return Integer.valueOf(value.toString()).intValue();
1:d29ca2a:         } else {
1:d29ca2a:             throw new MessageFormatException(" cannot read an int from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>long</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>long</CODE>
1:d29ca2a:      * @return the <CODE>long</CODE> value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public long getLong(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return 0;
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Long) {
1:f812e34:             return ((Long)value).longValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Integer) {
1:f812e34:             return ((Integer)value).longValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Short) {
1:f812e34:             return ((Short)value).longValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof Byte) {
1:f812e34:             return ((Byte)value).longValue();
1:d29ca2a:         }
1:543935b:         if (value instanceof UTF8Buffer) {
1:d29ca2a:             return Long.valueOf(value.toString()).longValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof String) {
1:543935b:             return Long.valueOf(value.toString()).longValue();
1:d29ca2a:         } else {
1:d29ca2a:             throw new MessageFormatException(" cannot read a long from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>float</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>float</CODE>
1:d29ca2a:      * @return the <CODE>float</CODE> value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public float getFloat(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return 0;
1:d29ca2a:         }
2:d29ca2a:         if (value instanceof Float) {
1:f812e34:             return ((Float)value).floatValue();
1:d29ca2a:         }
1:543935b:         if (value instanceof UTF8Buffer) {
1:d29ca2a:             return Float.valueOf(value.toString()).floatValue();
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof String) {
1:d29ca2a:             return Float.valueOf(value.toString()).floatValue();
1:d29ca2a:         } else {
1:d29ca2a:             throw new MessageFormatException(" cannot read a float from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>double</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>double</CODE>
1:d29ca2a:      * @return the <CODE>double</CODE> value with the specified name
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public double getDouble(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:4b34636: 
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return 0;
1:4b34636:         } else if (value instanceof Double) {
1:f812e34:             return ((Double)value).doubleValue();
1:4b34636:         } else if (value instanceof Float) {
1:f812e34:             return ((Float)value).floatValue();
1:4b34636:         } else if (value instanceof UTF8Buffer) {
1:4b34636:             return Double.valueOf(value.toString()).doubleValue();
1:4b34636:         } else if (value instanceof String) {
1:4b34636:             return Double.valueOf(value.toString()).doubleValue();
1:d29ca2a:         } else {
1:4b34636:             throw new MessageFormatException("Cannot read a double from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the <CODE>String</CODE> value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the <CODE>String</CODE>
1:f812e34:      * @return the <CODE>String</CODE> value with the specified name; if there
1:f812e34:      *         is no item by this name, a null value is returned
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public String getString(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         Object value = map.get(name);
1:d29ca2a:         if (value == null) {
1:d29ca2a:             return null;
1:d29ca2a:         }
1:d29ca2a:         if (value instanceof byte[]) {
1:d29ca2a:             throw new MessageFormatException("Use getBytes to read a byte array");
1:d29ca2a:         } else {
1:d29ca2a:             return value.toString();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Returns the byte array value with the specified name.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the byte array
1:f812e34:      * @return a copy of the byte array value with the specified name; if there
1:f812e34:      *         is no item by this name, a null value is returned.
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      * @throws MessageFormatException if this type conversion is invalid.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public byte[] getBytes(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:f812e34:         Object value = map.get(name);
1:6e038d5:         if (value == null) {
1:6e038d5:             return null;
1:6e038d5:         }
1:6e038d5: 
1:f812e34:         if (value instanceof byte[]) {
1:f812e34:             return (byte[])value;
1:d29ca2a:         } else {
1:d29ca2a:             throw new MessageFormatException(" cannot read a byte[] from " + value.getClass().getName());
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * Returns the value of the object with the specified name.
1:f812e34:      * <P>
1:f812e34:      * This method can be used to return, in objectified format, an object in
1:f812e34:      * the Java programming language ("Java object") that had been stored in the
1:f812e34:      * Map with the equivalent <CODE>setObject</CODE> method call, or its
1:f812e34:      * equivalent primitive <CODE>set <I>type </I></CODE> method.
1:f812e34:      * <P>
1:f812e34:      * Note that byte values are returned as <CODE>byte[]</CODE>, not
1:f812e34:      * <CODE>Byte[]</CODE>.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the Java object
1:f812e34:      * @return a copy of the Java object value with the specified name, in
1:f812e34:      *         objectified format (for example, if the object was set as an
1:f812e34:      *         <CODE>int</CODE>, an <CODE>Integer</CODE> is returned); if
1:f812e34:      *         there is no item by this name, a null value is returned
1:f812e34:      * @throws JMSException if the JMS provider fails to read the message due to
1:f812e34:      *                 some internal error.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public Object getObject(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:543935b:         Object result = map.get(name);
1:543935b:         if (result instanceof UTF8Buffer) {
1:543935b:             result = result.toString();
1:d29ca2a:         }
1:d29ca2a: 
1:543935b:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * Returns an <CODE>Enumeration</CODE> of all the names in the
1:f812e34:      * <CODE>MapMessage</CODE> object.
1:f812e34:      *
1:d29ca2a:      * @return an enumeration of all the names in this <CODE>MapMessage</CODE>
2:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:543935b:     @Override
1:ecf89a6:     public Enumeration<String> getMapNames() throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         return Collections.enumeration(map.keySet());
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     protected void put(String name, Object value) throws JMSException {
1:d29ca2a:         if (name == null) {
1:d29ca2a:             throw new IllegalArgumentException("The name of the property cannot be null.");
1:d29ca2a:         }
1:d29ca2a:         if (name.length() == 0) {
1:d29ca2a:             throw new IllegalArgumentException("The name of the property cannot be an emprty string.");
1:d29ca2a:         }
1:d29ca2a:         map.put(name, value);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a <CODE>boolean</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>boolean</CODE>
1:d29ca2a:      * @param value the <CODE>boolean</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setBoolean(String name, boolean value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:74a7a8b:         put(name, value ? Boolean.TRUE : Boolean.FALSE);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a <CODE>byte</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>byte</CODE>
1:d29ca2a:      * @param value the <CODE>byte</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setByte(String name, byte value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d36c0d4:         put(name, Byte.valueOf(value));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a <CODE>short</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>short</CODE>
1:d29ca2a:      * @param value the <CODE>short</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setShort(String name, short value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d36c0d4:         put(name, Short.valueOf(value));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a Unicode character value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the Unicode character
1:d29ca2a:      * @param value the Unicode character value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setChar(String name, char value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d36c0d4:         put(name, Character.valueOf(value));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets an <CODE>int</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>int</CODE>
1:d29ca2a:      * @param value the <CODE>int</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setInt(String name, int value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d36c0d4:         put(name, Integer.valueOf(value));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a <CODE>long</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>long</CODE>
1:d29ca2a:      * @param value the <CODE>long</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setLong(String name, long value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d36c0d4:         put(name, Long.valueOf(value));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a <CODE>float</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>float</CODE>
1:d29ca2a:      * @param value the <CODE>float</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setFloat(String name, float value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d29ca2a:         put(name, new Float(value));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a <CODE>double</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>double</CODE>
1:d29ca2a:      * @param value the <CODE>double</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setDouble(String name, double value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d29ca2a:         put(name, new Double(value));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a <CODE>String</CODE> value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the <CODE>String</CODE>
1:d29ca2a:      * @param value the <CODE>String</CODE> value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setString(String name, String value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d29ca2a:         put(name, value);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Sets a byte array value with the specified name into the Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the byte array
1:f812e34:      * @param value the byte array value to set in the Map; the array is copied
1:f812e34:      *                so that the value for <CODE>name </CODE> will not be
1:f812e34:      *                altered by future modifications
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws NullPointerException if the name is null, or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setBytes(String name, byte[] value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d29ca2a:         if (value != null) {
1:d29ca2a:             put(name, value);
1:d29ca2a:         } else {
1:d29ca2a:             map.remove(name);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * Sets a portion of the byte array value with the specified name into the
1:f812e34:      * Map.
1:f812e34:      *
1:f812e34:      * @param name the name of the byte array
1:f812e34:      * @param value the byte array value to set in the Map
1:d29ca2a:      * @param offset the initial offset within the byte array
1:d29ca2a:      * @param length the number of bytes to use
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setBytes(String name, byte[] value, int offset, int length) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d29ca2a:         byte[] data = new byte[length];
1:d29ca2a:         System.arraycopy(value, offset, data, 0, length);
1:d29ca2a:         put(name, data);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * Sets an object value with the specified name into the Map.
1:f812e34:      * <P>
1:f812e34:      * This method works only for the objectified primitive object types (<code>Integer</code>,<code>Double</code>,
1:f812e34:      * <code>Long</code> &nbsp;...), <code>String</code> objects, and byte
1:f812e34:      * arrays.
1:f812e34:      *
1:f812e34:      * @param name the name of the Java object
1:d29ca2a:      * @param value the Java object value to set in the Map
1:f812e34:      * @throws JMSException if the JMS provider fails to write the message due
1:f812e34:      *                 to some internal error.
1:f812e34:      * @throws IllegalArgumentException if the name is null or if the name is an
1:f812e34:      *                 empty string.
1:f812e34:      * @throws MessageFormatException if the object is invalid.
1:d29ca2a:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public void setObject(String name, Object value) throws JMSException {
1:d29ca2a:         initializeWriting();
1:d29ca2a:         if (value != null) {
1:ca067a6:             // byte[] not allowed on properties
1:ca067a6:             if (!(value instanceof byte[])) {
1:ca067a6:                 checkValidObject(value);
1:d29ca2a:             }
1:d29ca2a:             put(name, value);
1:d29ca2a:         } else {
1:d29ca2a:             put(name, null);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:f812e34:      * Indicates whether an item exists in this <CODE>MapMessage</CODE>
1:f812e34:      * object.
1:f812e34:      *
1:d29ca2a:      * @param name the name of the item to test
1:d29ca2a:      * @return true if the item exists
1:f812e34:      * @throws JMSException if the JMS provider fails to determine if the item
1:f812e34:      *                 exists due to some internal error.
1:d29ca2a:      */
1:543935b:     @Override
1:d29ca2a:     public boolean itemExists(String name) throws JMSException {
1:d29ca2a:         initializeReading();
1:d29ca2a:         return map.containsKey(name);
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     private void initializeReading() throws JMSException {
1:d29ca2a:         loadContent();
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     private void initializeWriting() throws MessageNotWriteableException {
1:d29ca2a:         checkReadOnlyBody();
1:d29ca2a:         setContent(null);
1:d29ca2a:     }
1:d29ca2a: 
1:41c9366:     @Override
1:41c9366:     public void compress() throws IOException {
1:41c9366:         storeContent();
1:41c9366:         super.compress();
1:d29ca2a:     }
1:d29ca2a: 
1:543935b:     @Override
1:d29ca2a:     public String toString() {
1:f812e34:         return super.toString() + " ActiveMQMapMessage{ " + "theTable = " + map + " }";
1:d29ca2a:     }
1:f812e34: 
1:ecf89a6:     public Map<String, Object> getContentMap() throws JMSException {
1:d29ca2a:         initializeReading();
1:e6f5d30:         return map;
1:e6f5d30:     }
1:543935b: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:f82993d
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean isContentMarshalled() {
1:         return content != null || map == null || map.isEmpty();
1:     }
1: 
commit:7c3bb40
/////////////////////////////////////////////////////////////////////////
1:     public void clearUnMarshalledState() throws JMSException {
1:         super.clearUnMarshalledState();
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:4d5bb4a
/////////////////////////////////////////////////////////////////////////
1: 
1:         } else if (value instanceof Character) {
1:             throw new MessageFormatException(" cannot read a char from " + value.getClass().getName());
commit:4b34636
/////////////////////////////////////////////////////////////////////////
1: 
1:         } else if (value instanceof Double) {
1:         } else if (value instanceof Float) {
1:         } else if (value instanceof UTF8Buffer) {
1:             return Double.valueOf(value.toString()).doubleValue();
1:         } else if (value instanceof String) {
1:             return Double.valueOf(value.toString()).doubleValue();
1:             throw new MessageFormatException("Cannot read a double from " + value.getClass().getName());
commit:6e038d5
/////////////////////////////////////////////////////////////////////////
1:         if (value == null) {
1:             return null;
1:         }
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:3003895
/////////////////////////////////////////////////////////////////////////
1:     public void storeContentAndClear() {
1:         storeContent();
1:         map.clear();
1:     }
1: 
1:     @Override
commit:9a8f6e4
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
1:     protected transient Map<String, Object> map = new HashMap<String, Object>();
/////////////////////////////////////////////////////////////////////////
1:     public Enumeration<String> getMapNames() throws JMSException {
/////////////////////////////////////////////////////////////////////////
1:     public Map<String, Object> getContentMap() throws JMSException {
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     protected transient Map map = new HashMap();
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         put(name, value ? Boolean.TRUE : Boolean.FALSE);
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:  * A <CODE>MapMessage</CODE> object is used to send a set of name-value pairs.
1:  * The names are <CODE>String</CODE> objects, and the values are primitive
1:  * data types in the Java programming language. The names must have a value that
1:  * is not null, and not an empty string. The entries can be accessed
1:  * sequentially or randomly by name. The order of the entries is undefined.
1:  * <CODE>MapMessage</CODE> inherits from the <CODE>Message</CODE> interface
1:  * and adds a message body that contains a Map.
1:  * <P>
1:  * The primitive types can be read or written explicitly using methods for each
1:  * type. They may also be read or written generically as objects. For instance,
1:  * a call to <CODE>MapMessage.setInt("foo", 6)</CODE> is equivalent to
1:  * <CODE> MapMessage.setObject("foo", new Integer(6))</CODE>. Both forms are
1:  * provided, because the explicit form is convenient for static programming, and
1:  * the object form is needed when types are not known at compile time.
1:  * <P>
1:  * When a client receives a <CODE>MapMessage</CODE>, it is in read-only mode.
1:  * If a client attempts to write to the message at this point, a
1:  * <CODE>MessageNotWriteableException</CODE> is thrown. If
1:  * <CODE>clearBody</CODE> is called, the message can now be both read from and
1:  * written to.
1:  * <P>
1:  * <CODE>MapMessage</CODE> objects support the following conversion table. The
1:  * marked cases must be supported. The unmarked cases must throw a
1:  * <CODE>JMSException</CODE>. The <CODE>String</CODE> -to-primitive
1:  * conversions may throw a runtime exception if the primitive's
1:  * <CODE>valueOf()</CODE> method does not accept it as a valid
1:  * <CODE> String</CODE> representation of the primitive.
1:  * <P>
1:  * A value written as the row type can be read as the column type. <p/>
1:  * 
1:  * <PRE>
1:  * | | boolean byte short char int long float double String byte[] |----------------------------------------------------------------------
1:  * &lt;p/&gt;
1:  * 
1:  * <P>
1:  * Attempting to read a null value as a primitive type must be treated as
1:  * calling the primitive's corresponding <code>valueOf(String)</code>
1:  * conversion method with a null value. Since <code>char</code> does not
1:  * support a <code>String</code> conversion, attempting to read a null value
1:  * as a <code>char</code> must throw a <code>NullPointerException</code>.
1:  * 
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (getContent() == null && !map.isEmpty()) {
1:                 if (connection != null && connection.isUseCompression()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:      * 
1:      * @throws JMSException
1:      * 
1:             if (getContent() != null && map.isEmpty()) {
1:                 if (isCompressed()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Clears out the message body. Clearing a message's body does not clear its
1:      * header values or property entries.
1:      * <P>
1:      * If this message body was read-only, calling this method leaves the
1:      * message body in the same state as an empty body in a newly created
1:      * message.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Boolean)value).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Byte)value).byteValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Short)value).shortValue();
1:             return ((Byte)value).shortValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Character)value).charValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Integer)value).intValue();
1:             return ((Short)value).intValue();
1:             return ((Byte)value).intValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Long)value).longValue();
1:             return ((Integer)value).longValue();
1:             return ((Short)value).longValue();
1:             return ((Byte)value).longValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Float)value).floatValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:             return ((Double)value).doubleValue();
1:             return ((Float)value).floatValue();
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @return the <CODE>String</CODE> value with the specified name; if there
1:      *         is no item by this name, a null value is returned
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @return a copy of the byte array value with the specified name; if there
1:      *         is no item by this name, a null value is returned.
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
1:         Object value = map.get(name);
1:         if (value instanceof byte[]) {
1:             return (byte[])value;
1:      * Returns the value of the object with the specified name.
1:      * <P>
1:      * This method can be used to return, in objectified format, an object in
1:      * the Java programming language ("Java object") that had been stored in the
1:      * Map with the equivalent <CODE>setObject</CODE> method call, or its
1:      * equivalent primitive <CODE>set <I>type </I></CODE> method.
1:      * <P>
1:      * Note that byte values are returned as <CODE>byte[]</CODE>, not
1:      * <CODE>Byte[]</CODE>.
1:      * 
1:      * @return a copy of the Java object value with the specified name, in
1:      *         objectified format (for example, if the object was set as an
1:      *         <CODE>int</CODE>, an <CODE>Integer</CODE> is returned); if
1:      *         there is no item by this name, a null value is returned
1:      * @throws JMSException if the JMS provider fails to read the message due to
1:      *                 some internal error.
/////////////////////////////////////////////////////////////////////////
1:      * Returns an <CODE>Enumeration</CODE> of all the names in the
1:      * <CODE>MapMessage</CODE> object.
1:      * 
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>boolean</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>byte</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>short</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the Unicode character
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>int</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>long</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>float</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>double</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the <CODE>String</CODE>
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param name the name of the byte array
1:      * @param value the byte array value to set in the Map; the array is copied
1:      *                so that the value for <CODE>name </CODE> will not be
1:      *                altered by future modifications
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws NullPointerException if the name is null, or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * Sets a portion of the byte array value with the specified name into the
1:      * Map.
1:      * 
1:      * @param name the name of the byte array
1:      * @param value the byte array value to set in the Map
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
/////////////////////////////////////////////////////////////////////////
1:      * Sets an object value with the specified name into the Map.
1:      * <P>
1:      * This method works only for the objectified primitive object types (<code>Integer</code>,<code>Double</code>,
1:      * <code>Long</code> &nbsp;...), <code>String</code> objects, and byte
1:      * arrays.
1:      * 
1:      * @param name the name of the Java object
1:      * @throws JMSException if the JMS provider fails to write the message due
1:      *                 to some internal error.
1:      * @throws IllegalArgumentException if the name is null or if the name is an
1:      *                 empty string.
1:      * @throws MessageFormatException if the object is invalid.
/////////////////////////////////////////////////////////////////////////
1:      * Indicates whether an item exists in this <CODE>MapMessage</CODE>
1:      * object.
1:      * 
1:      * @throws JMSException if the JMS provider fails to determine if the item
1:      *                 exists due to some internal error.
1: 
1: 
1:         return super.toString() + " ActiveMQMapMessage{ " + "theTable = " + map + " }";
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:88acb0e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ByteArrayInputStream;
1: import org.apache.activemq.util.ByteArrayOutputStream;
1: import org.apache.activemq.util.ByteSequence;
1: import org.apache.activemq.wireformat.WireFormat;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:f451ad0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activeio.command.WireFormat;
0: import org.apache.activeio.packet.ByteSequence;
0: import org.apache.activeio.util.ByteArrayInputStream;
0: import org.apache.activeio.util.ByteArrayOutputStream;
commit:e6f5d30
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     
0:     public Map getContentMap() throws JMSException {
1:         initializeReading();
1:         return map;
1:     }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.command;
1: 
1: import java.io.DataInputStream;
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.util.Collections;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.zip.DeflaterOutputStream;
1: import java.util.zip.InflaterInputStream;
1: 
1: import javax.jms.JMSException;
1: import javax.jms.MapMessage;
1: import javax.jms.MessageFormatException;
1: import javax.jms.MessageNotWriteableException;
1: 
0: import org.activeio.ByteArrayInputStream;
0: import org.activeio.ByteArrayOutputStream;
0: import org.activeio.ByteSequence;
0: import org.activeio.command.WireFormat;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.util.JMSExceptionSupport;
1: import org.apache.activemq.util.MarshallingSupport;
1: 
1: /**
0:  * A <CODE>MapMessage</CODE> object is used to send a set of name-value pairs. The names are <CODE>String</CODE>
0:  * objects, and the values are primitive data types in the Java programming language. The names must have a value that
0:  * is not null, and not an empty string. The entries can be accessed sequentially or randomly by name. The order of the
0:  * entries is undefined. <CODE>MapMessage</CODE> inherits from the <CODE>Message</CODE> interface and adds a message
0:  * body that contains a Map. <P> The primitive types can be read or written explicitly using methods for each type. They
0:  * may also be read or written generically as objects. For instance, a call to <CODE>MapMessage.setInt("foo", 6)</CODE>
0:  * is equivalent to <CODE> MapMessage.setObject("foo", new Integer(6))</CODE>. Both forms are provided, because the
0:  * explicit form is convenient for static programming, and the object form is needed when types are not known at compile
0:  * time. <P> When a client receives a <CODE>MapMessage</CODE>, it is in read-only mode. If a client attempts to write to
0:  * the message at this point, a <CODE>MessageNotWriteableException</CODE> is thrown. If <CODE>clearBody</CODE> is
0:  * called, the message can now be both read from and written to. <P> <CODE>MapMessage</CODE> objects support the
0:  * following conversion table. The marked cases must be supported. The unmarked cases must throw a
0:  * <CODE>JMSException</CODE>. The <CODE>String</CODE> -to-primitive conversions may throw a runtime exception if the
0:  * primitive's <CODE>valueOf()</CODE> method does not accept it as a valid <CODE> String</CODE> representation of the
0:  * primitive. <P> A value written as the row type can be read as the column type.
1:  * <p/>
0:  * <PRE>| | boolean byte short char int long float double String byte[] |----------------------------------------------------------------------
1:  * |boolean | X X |byte | X X X X X |short | X X X X |char | X X |int | X X X |long | X X |float | X X X |double | X X
1:  * |String | X X X X X X X X |byte[] | X |----------------------------------------------------------------------
1:  * <p/>
1:  * </PRE>
1:  * <p/>
0:  * <P> Attempting to read a null value as a primitive type must be treated as calling the primitive's corresponding
0:  * <code>valueOf(String)</code> conversion method with a null value. Since <code>char</code> does not support a
0:  * <code>String</code> conversion, attempting to read a null value as a <code>char</code> must throw a
0:  * <code>NullPointerException</code>.
1:  *
0:  * @openwire:marshaller
1:  * @see javax.jms.Session#createMapMessage()
1:  * @see javax.jms.BytesMessage
1:  * @see javax.jms.Message
1:  * @see javax.jms.ObjectMessage
1:  * @see javax.jms.StreamMessage
1:  * @see javax.jms.TextMessage
1:  */
1: public class ActiveMQMapMessage extends ActiveMQMessage implements MapMessage {
1: 
1:     public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_MAP_MESSAGE;
1: 
0:     transient protected HashMap map = new HashMap();
1: 
1:     public Message copy() {
1:         ActiveMQMapMessage copy = new ActiveMQMapMessage();
1:         copy(copy);
1:         return copy;
1:     }
1: 
1:     private void copy(ActiveMQMapMessage copy) {
1:         storeContent();
1:         super.copy(copy);
1:     }
1: 
1:     // We only need to marshal the content if we are hitting the wire.
1:     public void beforeMarshall(WireFormat wireFormat) throws IOException {
1:         super.beforeMarshall(wireFormat);
1:         storeContent();
1:     }
1:     
0:     private void storeContent() {
1:         try {
0:             if( getContent()==null && !map.isEmpty()) {
1:                 ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
1:                 OutputStream os = bytesOut;
1:                 ActiveMQConnection connection = getConnection();
0:                 if( connection!= null && connection.isUseCompression() ) { 
1:                     compressed = true;
1:                     os = new DeflaterOutputStream(os);
1:                 }
1:                 DataOutputStream dataOut = new DataOutputStream(os);
1:                 MarshallingSupport.marshalPrimitiveMap(map, dataOut);
1:                 dataOut.close();
1:                 setContent(bytesOut.toByteSequence());
1:             }
1:         } catch (IOException e) {
1:             throw new RuntimeException(e);
1:         }
1:     }
1:     
1:     /**
1:      * Builds the message body from data
1:      * @throws JMSException 
1:      *
1:      * @throws IOException
1:      */
1:     private void loadContent() throws JMSException {
1:         try {
0:             if( getContent()!=null && map.isEmpty() ) {
1:                 ByteSequence content = getContent();
1:                 InputStream is = new ByteArrayInputStream(content);
0:                 if( isCompressed() ) {
1:                     is = new InflaterInputStream(is);
1:                 }
1:                 DataInputStream dataIn = new DataInputStream(is);
1:                 map = MarshallingSupport.unmarshalPrimitiveMap(dataIn);
1:                 dataIn.close();
1:             }
1:         } catch (IOException e) {
1:             throw JMSExceptionSupport.create(e);
1:         }
1:     }
1: 
1:     public byte getDataStructureType() {
1:         return DATA_STRUCTURE_TYPE;
1:     }
1: 
1:     /**
0:      * Clears out the message body. Clearing a message's body does not clear its header values or property entries. <P>
0:      * If this message body was read-only, calling this method leaves the message body in the same state as an empty
0:      * body in a newly created message.
1:      */
1:     public void clearBody() throws JMSException {
1:         super.clearBody();
1:         map.clear();
1:     }
1: 
1:     /**
1:      * Returns the <CODE>boolean</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>boolean</CODE>
1:      * @return the <CODE>boolean</CODE> value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public boolean getBoolean(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return false;
1:         }
1:         if (value instanceof Boolean) {
0:             return ((Boolean) value).booleanValue();
1:         }
1:         if (value instanceof String) {
1:             return Boolean.valueOf(value.toString()).booleanValue();
1:         } else {
1:             throw new MessageFormatException(" cannot read a boolean from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the <CODE>byte</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>byte</CODE>
1:      * @return the <CODE>byte</CODE> value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public byte getByte(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return 0;
1:         }
1:         if (value instanceof Byte) {
0:             return ((Byte) value).byteValue();
1:         }
1:         if (value instanceof String) {
1:             return Byte.valueOf(value.toString()).byteValue();
1:         } else {
1:             throw new MessageFormatException(" cannot read a byte from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the <CODE>short</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>short</CODE>
1:      * @return the <CODE>short</CODE> value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public short getShort(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return 0;
1:         }
1:         if (value instanceof Short) {
0:             return ((Short) value).shortValue();
1:         }
1:         if (value instanceof Byte) {
0:             return ((Byte) value).shortValue();
1:         }
1:         if (value instanceof String) {
1:             return Short.valueOf(value.toString()).shortValue();
1:         } else {
1:             throw new MessageFormatException(" cannot read a short from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the Unicode character value with the specified name.
1:      *
1:      * @param name the name of the Unicode character
1:      * @return the Unicode character value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public char getChar(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             throw new NullPointerException();
1:         }
0:         if (value instanceof Character) {
0:             return ((Character) value).charValue();
1:         } else {
1:             throw new MessageFormatException(" cannot read a short from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the <CODE>int</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>int</CODE>
1:      * @return the <CODE>int</CODE> value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public int getInt(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return 0;
1:         }
1:         if (value instanceof Integer) {
0:             return ((Integer) value).intValue();
1:         }
1:         if (value instanceof Short) {
0:             return ((Short) value).intValue();
1:         }
1:         if (value instanceof Byte) {
0:             return ((Byte) value).intValue();
1:         }
1:         if (value instanceof String) {
1:             return Integer.valueOf(value.toString()).intValue();
1:         } else {
1:             throw new MessageFormatException(" cannot read an int from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the <CODE>long</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>long</CODE>
1:      * @return the <CODE>long</CODE> value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public long getLong(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return 0;
1:         }
1:         if (value instanceof Long) {
0:             return ((Long) value).longValue();
1:         }
1:         if (value instanceof Integer) {
0:             return ((Integer) value).longValue();
1:         }
1:         if (value instanceof Short) {
0:             return ((Short) value).longValue();
1:         }
1:         if (value instanceof Byte) {
0:             return ((Byte) value).longValue();
1:         }
1:         if (value instanceof String) {
1:             return Long.valueOf(value.toString()).longValue();
1:         } else {
1:             throw new MessageFormatException(" cannot read a long from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the <CODE>float</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>float</CODE>
1:      * @return the <CODE>float</CODE> value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public float getFloat(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return 0;
1:         }
1:         if (value instanceof Float) {
0:             return ((Float) value).floatValue();
1:         }
1:         if (value instanceof String) {
1:             return Float.valueOf(value.toString()).floatValue();
1:         } else {
1:             throw new MessageFormatException(" cannot read a float from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the <CODE>double</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>double</CODE>
1:      * @return the <CODE>double</CODE> value with the specified name
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public double getDouble(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return 0;
1:         }
0:         if (value instanceof Double) {
0:             return ((Double) value).doubleValue();
1:         }
1:         if (value instanceof Float) {
0:             return ((Float) value).floatValue();
1:         }
1:         if (value instanceof String) {
1:             return Float.valueOf(value.toString()).floatValue();
1:         } else {
0:             throw new MessageFormatException(" cannot read a double from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
1:      * Returns the <CODE>String</CODE> value with the specified name.
1:      *
1:      * @param name the name of the <CODE>String</CODE>
0:      * @return the <CODE>String</CODE> value with the specified name; if there is no item by this name, a null value is
0:      *         returned
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public String getString(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);
1:         if (value == null) {
1:             return null;
1:         }
1:         if (value instanceof byte[]) {
1:             throw new MessageFormatException("Use getBytes to read a byte array");
1:         } else {
1:             return value.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Returns the byte array value with the specified name.
1:      *
1:      * @param name the name of the byte array
0:      * @return a copy of the byte array value with the specified name; if there is no item by this name, a null value is
0:      *         returned.
0:      * @throws JMSException           if the JMS provider fails to read the message due to some internal error.
1:      * @throws MessageFormatException if this type conversion is invalid.
1:      */
1:     public byte[] getBytes(String name) throws JMSException {
1:         initializeReading();
1:         Object value = map.get(name);            
0:         if ( value instanceof byte[] ) { 
0:             return (byte[]) value;
1:         } else {
1:             throw new MessageFormatException(" cannot read a byte[] from " + value.getClass().getName());
1:         }
1:     }
1: 
1:     /**
0:      * Returns the value of the object with the specified name. <P> This method can be used to return, in objectified
0:      * format, an object in the Java programming language ("Java object") that had been stored in the Map with the
0:      * equivalent <CODE>setObject</CODE> method call, or its equivalent primitive <CODE>set <I>type </I></CODE> method.
0:      * <P> Note that byte values are returned as <CODE>byte[]</CODE>, not <CODE>Byte[]</CODE>.
1:      *
1:      * @param name the name of the Java object
0:      * @return a copy of the Java object value with the specified name, in objectified format (for example, if the
0:      *         object was set as an <CODE>int</CODE>, an <CODE>Integer</CODE> is returned); if there is no item by this
0:      *         name, a null value is returned
0:      * @throws JMSException if the JMS provider fails to read the message due to some internal error.
1:      */
1:     public Object getObject(String name) throws JMSException {
1:         initializeReading();
0:         return map.get(name);
1:     }
1: 
1:     /**
0:      * Returns an <CODE>Enumeration</CODE> of all the names in the <CODE>MapMessage</CODE> object.
1:      *
1:      * @return an enumeration of all the names in this <CODE>MapMessage</CODE>
1:      * @throws JMSException
1:      */
0:     public Enumeration getMapNames() throws JMSException {
1:         initializeReading();
1:         return Collections.enumeration(map.keySet());
1:     }
1: 
1:     protected void put(String name, Object value) throws JMSException {
1:         if (name == null) {
1:             throw new IllegalArgumentException("The name of the property cannot be null.");
1:         }
1:         if (name.length() == 0) {
1:             throw new IllegalArgumentException("The name of the property cannot be an emprty string.");
1:         }
1:         map.put(name, value);
1:     }
1: 
1:     /**
1:      * Sets a <CODE>boolean</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>boolean</CODE>
1:      * @param value the <CODE>boolean</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setBoolean(String name, boolean value) throws JMSException {
1:         initializeWriting();
0:         put(name, (value) ? Boolean.TRUE : Boolean.FALSE);
1:     }
1: 
1:     /**
1:      * Sets a <CODE>byte</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>byte</CODE>
1:      * @param value the <CODE>byte</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setByte(String name, byte value) throws JMSException {
1:         initializeWriting();
0:         put(name, new Byte(value));
1:     }
1: 
1:     /**
1:      * Sets a <CODE>short</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>short</CODE>
1:      * @param value the <CODE>short</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setShort(String name, short value) throws JMSException {
1:         initializeWriting();
0:         put(name, new Short(value));
1:     }
1: 
1:     /**
1:      * Sets a Unicode character value with the specified name into the Map.
1:      *
0:      * @param name  the name of the Unicode character
1:      * @param value the Unicode character value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setChar(String name, char value) throws JMSException {
1:         initializeWriting();
0:         put(name, new Character(value));
1:     }
1: 
1:     /**
1:      * Sets an <CODE>int</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>int</CODE>
1:      * @param value the <CODE>int</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setInt(String name, int value) throws JMSException {
1:         initializeWriting();
0:         put(name, new Integer(value));
1:     }
1: 
1:     /**
1:      * Sets a <CODE>long</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>long</CODE>
1:      * @param value the <CODE>long</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setLong(String name, long value) throws JMSException {
1:         initializeWriting();
0:         put(name, new Long(value));
1:     }
1: 
1:     /**
1:      * Sets a <CODE>float</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>float</CODE>
1:      * @param value the <CODE>float</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setFloat(String name, float value) throws JMSException {
1:         initializeWriting();
1:         put(name, new Float(value));
1:     }
1: 
1:     /**
1:      * Sets a <CODE>double</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>double</CODE>
1:      * @param value the <CODE>double</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setDouble(String name, double value) throws JMSException {
1:         initializeWriting();
1:         put(name, new Double(value));
1:     }
1: 
1:     /**
1:      * Sets a <CODE>String</CODE> value with the specified name into the Map.
1:      *
0:      * @param name  the name of the <CODE>String</CODE>
1:      * @param value the <CODE>String</CODE> value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setString(String name, String value) throws JMSException {
1:         initializeWriting();
1:         put(name, value);
1:     }
1: 
1:     /**
1:      * Sets a byte array value with the specified name into the Map.
1:      *
0:      * @param name  the name of the byte array
0:      * @param value the byte array value to set in the Map; the array is copied so that the value for <CODE>name </CODE>
0:      *              will not be altered by future modifications
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws NullPointerException         if the name is null, or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setBytes(String name, byte[] value) throws JMSException {
1:         initializeWriting();
1:         if (value != null) {
1:             put(name, value);
1:         } else {
1:             map.remove(name);
1:         }
1:     }
1: 
1:     /**
0:      * Sets a portion of the byte array value with the specified name into the Map.
1:      *
0:      * @param name   the name of the byte array
0:      * @param value  the byte array value to set in the Map
1:      * @param offset the initial offset within the byte array
1:      * @param length the number of bytes to use
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setBytes(String name, byte[] value, int offset, int length) throws JMSException {
1:         initializeWriting();
1:         byte[] data = new byte[length];
1:         System.arraycopy(value, offset, data, 0, length);
1:         put(name, data);
1:     }
1: 
1:     /**
0:      * Sets an object value with the specified name into the Map. <P> This method works only for the objectified
0:      * primitive object types (<code>Integer</code>,<code>Double</code>, <code>Long</code> &nbsp;...),
0:      * <code>String</code> objects, and byte arrays.
1:      *
0:      * @param name  the name of the Java object
1:      * @param value the Java object value to set in the Map
0:      * @throws JMSException                 if the JMS provider fails to write the message due to some internal error.
0:      * @throws IllegalArgumentException     if the name is null or if the name is an empty string.
0:      * @throws MessageFormatException       if the object is invalid.
1:      * @throws MessageNotWriteableException if the message is in read-only mode.
1:      */
1:     public void setObject(String name, Object value) throws JMSException {
1:         initializeWriting();
1:         if (value != null) {
0:             if (value instanceof Number || value instanceof String || value instanceof Boolean ||
0:                     value instanceof Byte
0:                     || value instanceof Character || value instanceof byte[]) {
1:                 put(name, value);
1:             } else {
0:                 throw new MessageFormatException(value.getClass() + " is not a primitive type");
1:             }
1:         } else {
1:             put(name, null);
1:         }
1:     }
1: 
1:     /**
0:      * Indicates whether an item exists in this <CODE>MapMessage</CODE> object.
1:      *
1:      * @param name the name of the item to test
1:      * @return true if the item exists
0:      * @throws JMSException if the JMS provider fails to determine if the item exists due to some internal error.
1:      */
1:     public boolean itemExists(String name) throws JMSException {
1:         initializeReading();
1:         return map.containsKey(name);
1:     }
1:     
1:     private void initializeReading() throws JMSException {
1:         loadContent();
1:     }
1:     
1:     private void initializeWriting() throws MessageNotWriteableException {
1:         checkReadOnlyBody();
1:         setContent(null);
1:     }
1: 
1:     public String toString() {
0:         return super.toString() + " ActiveMQMapMessage{ " +
0:                 "theTable = " + map +
0:                 " }";
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:543935b
/////////////////////////////////////////////////////////////////////////
1: import org.fusesource.hawtbuf.UTF8Buffer;
/////////////////////////////////////////////////////////////////////////
1:         if (this.map == null) {
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (value instanceof UTF8Buffer) {
1:             return Boolean.valueOf(value.toString()).booleanValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (value instanceof UTF8Buffer) {
1:             return Byte.valueOf(value.toString()).byteValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (value instanceof UTF8Buffer) {
1:             return Short.valueOf(value.toString()).shortValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (value instanceof UTF8Buffer) {
1:             return Integer.valueOf(value.toString()).intValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (value instanceof UTF8Buffer) {
1:             return Long.valueOf(value.toString()).longValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (value instanceof UTF8Buffer) {
0:             return Float.valueOf(value.toString()).floatValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         if (value instanceof UTF8Buffer) {
0:             return Float.valueOf(value.toString()).floatValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         Object result = map.get(name);
1:         if (result instanceof UTF8Buffer) {
1:             result = result.toString();
1:         }
0: 
1:         return result;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:41c9366
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void storeContent() {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void compress() throws IOException {
1:         storeContent();
1:         super.compress();
0:     }
0: 
commit:d75bb6d
/////////////////////////////////////////////////////////////////////////
1: import java.io.ObjectStreamException;
/////////////////////////////////////////////////////////////////////////
0:  *
0:  *
/////////////////////////////////////////////////////////////////////////
0:  *
/////////////////////////////////////////////////////////////////////////
1:     private Object readResolve() throws ObjectStreamException {
0:         if(this.map == null) {
1:             this.map = new HashMap<String, Object>();
0:         }
1:         return this;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
author:Gary Tully
-------------------------------------------------------------------------------
commit:c1da3ac
/////////////////////////////////////////////////////////////////////////
0:     public void clearMarshalledState() throws JMSException {
0:         super.clearMarshalledState();
1:         map.clear();
0:     }
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
1:         put(name, Byte.valueOf(value));
/////////////////////////////////////////////////////////////////////////
1:         put(name, Short.valueOf(value));
/////////////////////////////////////////////////////////////////////////
1:         put(name, Character.valueOf(value));
/////////////////////////////////////////////////////////////////////////
1:         put(name, Integer.valueOf(value));
/////////////////////////////////////////////////////////////////////////
1:         put(name, Long.valueOf(value));
author:James Strachan
-------------------------------------------------------------------------------
commit:05a8cba
/////////////////////////////////////////////////////////////////////////
0:     
1:     public String getJMSXMimeType() {
1:         return "jms/map-message";
0:     }
0: 
commit:ca067a6
/////////////////////////////////////////////////////////////////////////
0:     transient protected Map map = new HashMap();
/////////////////////////////////////////////////////////////////////////
1:             // byte[] not allowed on properties
1:             if (!(value instanceof byte[])) {
1:                 checkValidObject(value);
0:             put(name, value);
commit:4afa5d6
/////////////////////////////////////////////////////////////////////////
1:  * @openwire:marshaller code="25"
============================================================================