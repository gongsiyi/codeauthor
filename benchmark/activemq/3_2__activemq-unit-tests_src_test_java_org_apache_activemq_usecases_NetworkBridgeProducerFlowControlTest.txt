1:6d077dc: /**
1:6d077dc:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6d077dc:  * contributor license agreements.  See the NOTICE file distributed with
1:6d077dc:  * this work for additional information regarding copyright ownership.
1:6d077dc:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:6d077dc:  * (the "License"); you may not use this file except in compliance with
1:6d077dc:  * the License.  You may obtain a copy of the License at
1:6d077dc:  *
1:6d077dc:  *      http://www.apache.org/licenses/LICENSE-2.0
1:6d077dc:  *
1:6d077dc:  * Unless required by applicable law or agreed to in writing, software
1:6d077dc:  * distributed under the License is distributed on an "AS IS" BASIS,
1:6d077dc:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6d077dc:  * See the License for the specific language governing permissions and
1:6d077dc:  * limitations under the License.
1:6d077dc:  */
3:6d077dc: 
1:6d077dc: package org.apache.activemq.usecases;
1:6d077dc: 
1:3100909: import java.io.IOException;
1:6d077dc: import java.net.URI;
1:6d077dc: import java.util.Vector;
1:6d077dc: import java.util.concurrent.CountDownLatch;
1:8ce0778: import java.util.concurrent.TimeUnit;
1:6d077dc: import java.util.concurrent.atomic.AtomicLong;
1:6d077dc: import javax.jms.MessageConsumer;
1:6d077dc: import junit.framework.Test;
1:6d077dc: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1:6d077dc: import org.apache.activemq.broker.BrokerService;
1:6d077dc: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:6d077dc: import org.apache.activemq.broker.region.policy.PolicyMap;
1:8ce0778: import org.apache.activemq.command.ActiveMQDestination;
1:6d077dc: import org.apache.activemq.command.ActiveMQQueue;
1:8ce0778: import org.apache.activemq.command.ActiveMQTopic;
1:3100909: import org.apache.activemq.command.DiscoveryEvent;
1:3100909: import org.apache.activemq.network.DiscoveryNetworkConnector;
1:6d077dc: import org.apache.activemq.network.NetworkConnector;
1:3100909: import org.apache.activemq.transport.discovery.simple.SimpleDiscoveryAgent;
1:6d077dc: import org.apache.activemq.util.MessageIdList;
1:6d077dc: import org.apache.commons.logging.Log;
1:6d077dc: import org.apache.commons.logging.LogFactory;
1:6d077dc: import org.junit.Assert;
1:6d077dc: 
1:6d077dc: /**
1:6d077dc:  * This test demonstrates and verifies the behaviour of a network bridge when it
1:6d077dc:  * forwards a message to a queue that is full and producer flow control is
1:6d077dc:  * enabled.
1:6d077dc:  * <p/>
1:6d077dc:  * The expected behaviour is that the bridge will stop forwarding messages to
1:6d077dc:  * the full queue once the associated demand consumer's prefetch is full, but
1:6d077dc:  * will continue to forward messages to the other queues that are not full.
1:6d077dc:  * <p/>
1:6d077dc:  * In actuality, a message that is sent <b>asynchronously</b> to a local queue,
1:6d077dc:  * but blocked by producer flow control on the remote queue, will stop the
1:6d077dc:  * bridge from forwarding all subsequent messages, even those destined for
1:6d077dc:  * remote queues that are not full. In the same scenario, but with a message
1:6d077dc:  * that is sent <b>synchronously</b> to the local queue, the bridge continues
1:6d077dc:  * forwarding messages to remote queues that are not full.
1:6d077dc:  * <p/>
1:6d077dc:  * This test demonstrates the differing behaviour via the following scenario:
1:6d077dc:  * <ul>
1:6d077dc:  * <li>broker0, designated as the local broker, produces messages to two shared
1:6d077dc:  * queues
1:6d077dc:  * <li>broker1, designated as the remote broker, has two consumers: the first
1:6d077dc:  * consumes from one of the shared queues as fast as possible, the second
1:6d077dc:  * consumes from the other shared queue with an artificial processing delay for
1:6d077dc:  * each message
1:6d077dc:  * <li>broker0 forwards messages to broker1 over a TCP-based network bridge
1:6d077dc:  * with a demand consumer prefetch of 1
1:6d077dc:  * <li>broker1's consumers have a prefetch of 1
1:6d077dc:  * <li>broker1's "slow consumer" queue has a memory limit that triggers
1:6d077dc:  * producer flow control once the queue contains a small number of messages
1:6d077dc:  * </ul>
1:6d077dc:  * In this scenario, since broker1's consumers have a prefetch of 1, the "slow
1:6d077dc:  * consumer" queue will quickly become full and trigger producer flow control.
1:6d077dc:  * The "fast consumer" queue is unlikely to become full. Since producer flow
1:6d077dc:  * control on the "slow consumer" queue should not affect the "fast consumer"
1:6d077dc:  * queue, the expectation is that the fast consumer in broker1 will finish
1:6d077dc:  * processing all its messages well ahead of the slow consumer.
1:6d077dc:  * <p/>
1:6d077dc:  * The difference between expected and actual behaviour is demonstrated by
1:6d077dc:  * changing the messages produced by broker0 from persistent to non-persistent.
1:6d077dc:  * With persistent messages, broker0 dispatches synchronously and the expected
1:6d077dc:  * behaviour is observed (i.e., the fast consumer on broker1 is much faster than
1:6d077dc:  * the slow consumer). With non-persistent messages, broker0 dispatches
1:6d077dc:  * asynchronously and the expected behaviour is <b>not</b> observed (i.e., the
1:6d077dc:  * fast consumer is only marginally faster than the slow consumer).
1:6d077dc:  * <p/>
1:6d077dc:  * Since the expected behaviour may be desirable for both persistent and
1:6d077dc:  * non-persistent messages, this test also demonstrates an enhancement to the
1:6d077dc:  * network bridge configuration: <tt>isAlwaysSendSync</tt>. When false the
1:6d077dc:  * bridge operates as originally observed. When <tt>true</tt>, the bridge
1:6d077dc:  * operates with the same behaviour as was originally observed with persistent
1:6d077dc:  * messages, for both persistent and non-persistent messages.
1:6d077dc:  * <p/>
1:6d077dc:  * https://issues.apache.org/jira/browse/AMQ-3331
1:6d077dc:  *
1:6d077dc:  * @author schow
1:6d077dc:  */
1:6d077dc: public class NetworkBridgeProducerFlowControlTest extends
1:6d077dc:         JmsMultipleBrokersTestSupport {
1:6d077dc: 
1:6d077dc:     // Protect against hanging test.
1:6d077dc:     private static final long MAX_TEST_TIME = 120000;
1:6d077dc: 
1:6d077dc:     private static final Log LOG = LogFactory
1:6d077dc:             .getLog(NetworkBridgeProducerFlowControlTest.class);
1:6d077dc: 
1:6d077dc:     // Combo flag set to true/false by the test framework.
1:6d077dc:     public boolean persistentTestMessages;
1:6d077dc:     public boolean networkIsAlwaysSendSync;
1:6d077dc: 
1:6d077dc:     private Vector<Throwable> exceptions = new Vector<Throwable>();
1:6d077dc: 
1:6d077dc:     public static Test suite() {
1:6d077dc:         return suite(NetworkBridgeProducerFlowControlTest.class);
2:6d077dc:     }
1:6d077dc: 
1:6d077dc:     public void initCombosForTestFastAndSlowRemoteConsumers() {
1:6d077dc:         addCombinationValues("persistentTestMessages", new Object[]{
1:6d077dc:                 new Boolean(true), new Boolean(false)});
1:6d077dc:         addCombinationValues("networkIsAlwaysSendSync", new Object[]{
1:6d077dc:                 new Boolean(true), new Boolean(false)});
1:6d077dc:     }
1:6d077dc: 
1:6d077dc:     @Override
1:6d077dc:     protected void setUp() throws Exception {
1:6d077dc:         setAutoFail(true);
1:6d077dc:         setMaxTestTime(MAX_TEST_TIME);
1:6d077dc:         super.setUp();
1:6d077dc:     }
1:6d077dc: 
1:6d077dc:     /**
1:6d077dc:      * This test is parameterized by {@link #persistentTestMessages}, which
1:6d077dc:      * determines whether the producer on broker0 sends persistent or
1:6d077dc:      * non-persistent messages, and {@link #networkIsAlwaysSendSync}, which
1:6d077dc:      * determines how the bridge will forward both persistent and non-persistent
1:6d077dc:      * messages to broker1.
1:6d077dc:      *
1:6d077dc:      * @see #initCombosForTestFastAndSlowRemoteConsumers()
1:6d077dc:      */
1:6d077dc:     public void testFastAndSlowRemoteConsumers() throws Exception {
1:6d077dc:         final int NUM_MESSAGES = 100;
1:6d077dc:         final long TEST_MESSAGE_SIZE = 1024;
1:6d077dc:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1:6d077dc: 
1:8ce0778:         // Consumer prefetch is disabled for broker1's consumers.
1:8ce0778:         final ActiveMQQueue SLOW_SHARED_QUEUE = new ActiveMQQueue(
1:8ce0778:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:8ce0778:                     + ".slow.shared?consumer.prefetchSize=1");
1:8ce0778: 
1:8ce0778:         final ActiveMQQueue FAST_SHARED_QUEUE = new ActiveMQQueue(
1:8ce0778:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:8ce0778:                     + ".fast.shared?consumer.prefetchSize=1");
1:8ce0778: 
1:6d077dc:         // Start a local and a remote broker.
1:6d077dc:         createBroker(new URI("broker:(tcp://localhost:0"
1:6d077dc:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1:6d077dc:         BrokerService remoteBroker = createBroker(new URI(
1:6d077dc:                 "broker:(tcp://localhost:0"
1:6d077dc:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1:6d077dc: 
1:6d077dc:         // Set a policy on the remote broker that limits the maximum size of the
1:6d077dc:         // slow shared queue.
1:6d077dc:         PolicyEntry policyEntry = new PolicyEntry();
1:6d077dc:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:6d077dc:         PolicyMap policyMap = new PolicyMap();
1:6d077dc:         policyMap.put(SLOW_SHARED_QUEUE, policyEntry);
1:6d077dc:         remoteBroker.setDestinationPolicy(policyMap);
1:6d077dc: 
1:6d077dc:         // Create an outbound bridge from the local broker to the remote broker.
1:6d077dc:         // The bridge is configured with the remoteDispatchType enhancement.
1:6d077dc:         NetworkConnector nc = bridgeBrokers("broker0", "broker1");
1:6d077dc:         nc.setAlwaysSyncSend(networkIsAlwaysSendSync);
1:6d077dc:         nc.setPrefetchSize(1);
1:6d077dc: 
1:6d077dc:         startAllBrokers();
1:6d077dc:         waitForBridgeFormation();
1:6d077dc: 
1:6d077dc:         // Send the test messages to the local broker's shared queues. The
1:6d077dc:         // messages are either persistent or non-persistent to demonstrate the
1:6d077dc:         // difference between synchronous and asynchronous dispatch.
1:6d077dc:         persistentDelivery = persistentTestMessages;
1:6d077dc:         sendMessages("broker0", FAST_SHARED_QUEUE, NUM_MESSAGES);
1:6d077dc:         sendMessages("broker0", SLOW_SHARED_QUEUE, NUM_MESSAGES);
1:6d077dc: 
1:6d077dc:         // Start two asynchronous consumers on the remote broker, one for each
1:6d077dc:         // of the two shared queues, and keep track of how long it takes for
1:6d077dc:         // each of the consumers to receive all the messages.
1:6d077dc:         final CountDownLatch fastConsumerLatch = new CountDownLatch(
1:6d077dc:                 NUM_MESSAGES);
1:6d077dc:         final CountDownLatch slowConsumerLatch = new CountDownLatch(
1:6d077dc:                 NUM_MESSAGES);
1:6d077dc: 
1:6d077dc:         final long startTimeMillis = System.currentTimeMillis();
1:6d077dc:         final AtomicLong fastConsumerTime = new AtomicLong();
1:6d077dc:         final AtomicLong slowConsumerTime = new AtomicLong();
1:6d077dc: 
1:6d077dc:         Thread fastWaitThread = new Thread() {
1:6d077dc:             @Override
1:6d077dc:             public void run() {
1:6d077dc:                 try {
1:6d077dc:                     fastConsumerLatch.await();
1:6d077dc:                     fastConsumerTime.set(System.currentTimeMillis()
1:6d077dc:                             - startTimeMillis);
1:6d077dc:                 } catch (InterruptedException ex) {
1:6d077dc:                     exceptions.add(ex);
1:6d077dc:                     Assert.fail(ex.getMessage());
1:6d077dc:                 }
1:6d077dc:             }
1:8ce0778:         };
1:6d077dc: 
1:6d077dc:         Thread slowWaitThread = new Thread() {
1:6d077dc:             @Override
1:6d077dc:             public void run() {
1:6d077dc:                 try {
1:6d077dc:                     slowConsumerLatch.await();
1:6d077dc:                     slowConsumerTime.set(System.currentTimeMillis()
1:6d077dc:                             - startTimeMillis);
1:6d077dc:                 } catch (InterruptedException ex) {
1:6d077dc:                     exceptions.add(ex);
1:6d077dc:                     Assert.fail(ex.getMessage());
1:6d077dc:                 }
1:6d077dc:             }
1:6d077dc:         };
1:6d077dc: 
1:6d077dc:         fastWaitThread.start();
1:6d077dc:         slowWaitThread.start();
1:6d077dc: 
1:6d077dc:         createConsumer("broker1", FAST_SHARED_QUEUE, fastConsumerLatch);
1:6d077dc:         MessageConsumer slowConsumer = createConsumer("broker1",
1:6d077dc:                 SLOW_SHARED_QUEUE, slowConsumerLatch);
1:6d077dc:         MessageIdList messageIdList = brokers.get("broker1").consumers
1:6d077dc:                 .get(slowConsumer);
1:6d077dc:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1:6d077dc: 
1:6d077dc:         fastWaitThread.join();
1:6d077dc:         slowWaitThread.join();
1:6d077dc: 
1:6d077dc:         assertTrue("no exceptions on the wait threads:" + exceptions,
1:6d077dc:                 exceptions.isEmpty());
1:6d077dc: 
1:6d077dc:         LOG.info("Fast consumer duration (ms): " + fastConsumerTime.get());
1:6d077dc:         LOG.info("Slow consumer duration (ms): " + slowConsumerTime.get());
1:6d077dc: 
1:6d077dc:         // Verify the behaviour as described in the description of this class.
1:6d077dc:         if (networkIsAlwaysSendSync) {
1:6d077dc:             Assert
1:3100909:                     .assertTrue(fastConsumerTime.get() < slowConsumerTime.get() / 20);
1:3100909: 
1:6d077dc:         } else {
1:6d077dc:             Assert.assertEquals(persistentTestMessages,
1:6d077dc:                     fastConsumerTime.get() < slowConsumerTime.get() / 10);
1:6d077dc:         }
1:6d077dc:     }
1:8ce0778: 
1:8ce0778:     public void testSendFailIfNoSpaceDoesNotBlockQueueNetwork() throws Exception {
1:8ce0778:         // Consumer prefetch is disabled for broker1's consumers.
1:8ce0778:         final ActiveMQQueue SLOW_SHARED_QUEUE = new ActiveMQQueue(
1:8ce0778:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:8ce0778:                     + ".slow.shared?consumer.prefetchSize=1");
1:8ce0778: 
1:8ce0778:         final ActiveMQQueue FAST_SHARED_QUEUE = new ActiveMQQueue(
1:8ce0778:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:8ce0778:                     + ".fast.shared?consumer.prefetchSize=1");
1:8ce0778: 
1:8ce0778:         doTestSendFailIfNoSpaceDoesNotBlockNetwork(
1:8ce0778:                 SLOW_SHARED_QUEUE,
1:8ce0778:                 FAST_SHARED_QUEUE);
1:8ce0778:     }
1:8ce0778: 
1:8ce0778:     public void testSendFailIfNoSpaceDoesNotBlockTopicNetwork() throws Exception {
1:8ce0778:         // Consumer prefetch is disabled for broker1's consumers.
1:8ce0778:         final ActiveMQTopic SLOW_SHARED_TOPIC = new ActiveMQTopic(
1:8ce0778:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:8ce0778:                     + ".slow.shared?consumer.prefetchSize=1");
1:8ce0778: 
1:8ce0778:         final ActiveMQTopic FAST_SHARED_TOPIC = new ActiveMQTopic(
1:8ce0778:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:8ce0778:                     + ".fast.shared?consumer.prefetchSize=1");
1:8ce0778: 
1:8ce0778:         doTestSendFailIfNoSpaceDoesNotBlockNetwork(
1:8ce0778:                 SLOW_SHARED_TOPIC,
1:8ce0778:                 FAST_SHARED_TOPIC);
1:8ce0778:     }
1:8ce0778: 
1:8ce0778:     public void doTestSendFailIfNoSpaceDoesNotBlockNetwork(
1:8ce0778:             ActiveMQDestination slowDestination, ActiveMQDestination fastDestination) throws Exception {
1:8ce0778: 
1:8ce0778:         final int NUM_MESSAGES = 100;
1:8ce0778:         final long TEST_MESSAGE_SIZE = 1024;
1:8ce0778:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1:8ce0778: 
1:8ce0778:         // Start a local and a remote broker.
1:8ce0778:         createBroker(new URI("broker:(tcp://localhost:0"
1:8ce0778:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1:8ce0778:         BrokerService remoteBroker = createBroker(new URI(
1:8ce0778:                 "broker:(tcp://localhost:0"
1:8ce0778:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1:8ce0778:         remoteBroker.getSystemUsage().setSendFailIfNoSpace(true);
1:8ce0778: 
1:8ce0778:         // Set a policy on the remote broker that limits the maximum size of the
1:8ce0778:         // slow shared queue.
1:8ce0778:         PolicyEntry policyEntry = new PolicyEntry();
1:8ce0778:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:8ce0778:         PolicyMap policyMap = new PolicyMap();
1:8ce0778:         policyMap.put(slowDestination, policyEntry);
1:8ce0778:         remoteBroker.setDestinationPolicy(policyMap);
1:8ce0778: 
1:8ce0778:         // Create an outbound bridge from the local broker to the remote broker.
1:8ce0778:         // The bridge is configured with the remoteDispatchType enhancement.
1:8ce0778:         NetworkConnector nc = bridgeBrokers("broker0", "broker1");
1:8ce0778:         nc.setAlwaysSyncSend(true);
1:8ce0778:         nc.setPrefetchSize(1);
1:3100909: 
1:8ce0778:         startAllBrokers();
1:8ce0778:         waitForBridgeFormation();
1:8ce0778: 
1:8ce0778:         // Start two asynchronous consumers on the remote broker, one for each
1:8ce0778:         // of the two shared queues, and keep track of how long it takes for
1:8ce0778:         // each of the consumers to receive all the messages.
1:8ce0778:         final CountDownLatch fastConsumerLatch = new CountDownLatch(
1:8ce0778:                 NUM_MESSAGES);
1:8ce0778:         final CountDownLatch slowConsumerLatch = new CountDownLatch(
1:8ce0778:                 NUM_MESSAGES);
1:8ce0778: 
1:8ce0778:         final long startTimeMillis = System.currentTimeMillis();
1:8ce0778:         final AtomicLong fastConsumerTime = new AtomicLong();
1:8ce0778:         final AtomicLong slowConsumerTime = new AtomicLong();
1:8ce0778: 
1:8ce0778:         Thread fastWaitThread = new Thread() {
1:8ce0778:             @Override
1:8ce0778:             public void run() {
1:8ce0778:                 try {
1:8ce0778:                     fastConsumerLatch.await();
1:8ce0778:                     fastConsumerTime.set(System.currentTimeMillis()
1:8ce0778:                             - startTimeMillis);
1:8ce0778:                 } catch (InterruptedException ex) {
1:8ce0778:                     exceptions.add(ex);
1:8ce0778:                     Assert.fail(ex.getMessage());
1:8ce0778:                 }
1:8ce0778:             }
1:3100909:         };
1:8ce0778: 
1:8ce0778:         Thread slowWaitThread = new Thread() {
1:8ce0778:             @Override
1:8ce0778:             public void run() {
1:8ce0778:                 try {
1:8ce0778:                     slowConsumerLatch.await();
1:8ce0778:                     slowConsumerTime.set(System.currentTimeMillis()
1:8ce0778:                             - startTimeMillis);
1:8ce0778:                 } catch (InterruptedException ex) {
1:8ce0778:                     exceptions.add(ex);
1:8ce0778:                     Assert.fail(ex.getMessage());
1:8ce0778:                 }
1:8ce0778:             }
1:8ce0778:         };
1:8ce0778: 
1:8ce0778:         fastWaitThread.start();
1:8ce0778:         slowWaitThread.start();
1:8ce0778: 
1:8ce0778:         createConsumer("broker1", fastDestination, fastConsumerLatch);
1:8ce0778:         MessageConsumer slowConsumer = createConsumer("broker1",
1:8ce0778:                 slowDestination, slowConsumerLatch);
1:8ce0778:         MessageIdList messageIdList = brokers.get("broker1").consumers
1:8ce0778:                 .get(slowConsumer);
1:8ce0778:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1:8ce0778: 
1:8ce0778:         // Send the test messages to the local broker's shared queues. The
1:8ce0778:         // messages are either persistent or non-persistent to demonstrate the
1:8ce0778:         // difference between synchronous and asynchronous dispatch.
1:8ce0778:         persistentDelivery = false;
1:8ce0778:         sendMessages("broker0", fastDestination, NUM_MESSAGES);
1:8ce0778:         sendMessages("broker0", slowDestination, NUM_MESSAGES);
1:8ce0778: 
1:8ce0778:         fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1:8ce0778:         slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1:8ce0778: 
1:8ce0778:         assertTrue("no exceptions on the wait threads:" + exceptions,
1:8ce0778:                 exceptions.isEmpty());
1:8ce0778: 
1:8ce0778:         LOG.info("Fast consumer duration (ms): " + fastConsumerTime.get());
1:8ce0778:         LOG.info("Slow consumer duration (ms): " + slowConsumerTime.get());
1:8ce0778: 
1:8ce0778:         assertTrue("fast time set", fastConsumerTime.get() > 0);
1:8ce0778:         assertTrue("slow time set", slowConsumerTime.get() > 0);
1:8ce0778: 
1:8ce0778:         // Verify the behaviour as described in the description of this class.
1:8ce0778:         Assert.assertTrue(fastConsumerTime.get() < slowConsumerTime.get() / 10);
1:8ce0778:     }
1:3100909: 
1:3100909:     public void testSendFailIfNoSpaceReverseDoesNotBlockQueueNetwork() throws Exception {
1:3100909:         final int NUM_MESSAGES = 100;
1:3100909:         final long TEST_MESSAGE_SIZE = 1024;
1:3100909:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1:3100909: 
1:3100909:         final ActiveMQQueue slowDestination = new ActiveMQQueue(
1:3100909:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:3100909:                     + ".slow.shared?consumer.prefetchSize=1");
1:3100909: 
1:3100909:         final ActiveMQQueue fastDestination = new ActiveMQQueue(
1:3100909:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:3100909:                     + ".fast.shared?consumer.prefetchSize=1");
1:3100909: 
1:3100909: 
1:3100909:         // Start a local and a remote broker.
1:3100909:         BrokerService localBroker = createBroker(new URI("broker:(tcp://localhost:0"
1:3100909:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1:3100909:         createBroker(new URI(
1:3100909:                 "broker:(tcp://localhost:0"
1:3100909:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1:3100909:         localBroker.getSystemUsage().setSendFailIfNoSpace(true);
1:3100909: 
1:3100909:         // Set a policy on the local broker that limits the maximum size of the
1:3100909:         // slow shared queue.
1:3100909:         PolicyEntry policyEntry = new PolicyEntry();
1:3100909:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:3100909:         PolicyMap policyMap = new PolicyMap();
1:3100909:         policyMap.put(slowDestination, policyEntry);
1:3100909:         localBroker.setDestinationPolicy(policyMap);
1:3100909: 
1:3100909:         // Create an outbound bridge from the local broker to the remote broker.
1:3100909:         // The bridge is configured with the remoteDispatchType enhancement.
1:3100909:         NetworkConnector nc = bridgeBrokers("broker0", "broker1");
1:3100909:         nc.setAlwaysSyncSend(true);
1:3100909:         nc.setPrefetchSize(1);
1:3100909:         nc.setDuplex(true);
1:3100909: 
1:3100909:         startAllBrokers();
1:3100909:         waitForBridgeFormation();
1:3100909: 
1:3100909:         // Start two asynchronous consumers on the local broker, one for each
1:3100909:         // of the two shared queues, and keep track of how long it takes for
1:3100909:         // each of the consumers to receive all the messages.
1:3100909:         final CountDownLatch fastConsumerLatch = new CountDownLatch(
1:3100909:                 NUM_MESSAGES);
1:3100909:         final CountDownLatch slowConsumerLatch = new CountDownLatch(
1:3100909:                 NUM_MESSAGES);
1:3100909: 
1:3100909:         final long startTimeMillis = System.currentTimeMillis();
1:3100909:         final AtomicLong fastConsumerTime = new AtomicLong();
1:3100909:         final AtomicLong slowConsumerTime = new AtomicLong();
1:3100909: 
1:3100909:         Thread fastWaitThread = new Thread() {
1:3100909:             @Override
1:3100909:             public void run() {
1:3100909:                 try {
1:3100909:                     fastConsumerLatch.await();
1:3100909:                     fastConsumerTime.set(System.currentTimeMillis()
1:3100909:                             - startTimeMillis);
1:3100909:                 } catch (InterruptedException ex) {
1:3100909:                     exceptions.add(ex);
1:3100909:                     Assert.fail(ex.getMessage());
1:3100909:                 }
1:3100909:             }
1:3100909:         };
1:3100909: 
1:3100909:         Thread slowWaitThread = new Thread() {
1:3100909:             @Override
1:3100909:             public void run() {
1:3100909:                 try {
1:3100909:                     slowConsumerLatch.await();
1:3100909:                     slowConsumerTime.set(System.currentTimeMillis()
1:3100909:                             - startTimeMillis);
1:3100909:                 } catch (InterruptedException ex) {
1:3100909:                     exceptions.add(ex);
1:3100909:                     Assert.fail(ex.getMessage());
1:3100909:                 }
1:3100909:             }
1:6d077dc:         };
1:3100909: 
1:3100909:         fastWaitThread.start();
1:3100909:         slowWaitThread.start();
1:8ce0778: 
1:3100909:         createConsumer("broker0", fastDestination, fastConsumerLatch);
1:3100909:         MessageConsumer slowConsumer = createConsumer("broker0",
1:3100909:                 slowDestination, slowConsumerLatch);
1:3100909:         MessageIdList messageIdList = brokers.get("broker0").consumers
1:3100909:                 .get(slowConsumer);
1:3100909:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1:3100909: 
1:3100909:         // Send the test messages to the local broker's shared queues. The
1:3100909:         // messages are either persistent or non-persistent to demonstrate the
1:3100909:         // difference between synchronous and asynchronous dispatch.
1:3100909:         persistentDelivery = false;
1:3100909:         sendMessages("broker1", fastDestination, NUM_MESSAGES);
1:3100909:         sendMessages("broker1", slowDestination, NUM_MESSAGES);
1:3100909: 
1:3100909:         fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1:3100909:         slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1:3100909: 
1:3100909:         assertTrue("no exceptions on the wait threads:" + exceptions,
1:3100909:                 exceptions.isEmpty());
1:3100909: 
1:3100909:         LOG.info("Fast consumer duration (ms): " + fastConsumerTime.get());
1:3100909:         LOG.info("Slow consumer duration (ms): " + slowConsumerTime.get());
1:3100909: 
1:3100909:         assertTrue("fast time set", fastConsumerTime.get() > 0);
1:3100909:         assertTrue("slow time set", slowConsumerTime.get() > 0);
1:3100909: 
1:3100909:         // Verify the behaviour as described in the description of this class.
1:3100909:         Assert.assertTrue(fastConsumerTime.get() < slowConsumerTime.get() / 10);
1:3100909:     }
1:3100909: 
1:6d077dc: 
1:3100909:     /**
1:3100909:      * create a duplex network bridge from broker0 to broker1
1:3100909:      * add a topic consumer on broker0
1:3100909:      * set the setSendFailIfNoSpace() on the local broker.
1:3100909:      * create a SimpleDiscoveryAgent impl that tracks a network reconnect
1:3100909:      *
1:3100909:      * producer connects to broker1 and messages should be sent across the network to broker0
1:3100909:      *
1:3100909:      * Ensure broker0 will not send the  javax.jms.ResourceAllocationException (when broker0 runs out of space).
1:3100909:      * If the javax.jms.ResourceAllocationException is sent across the wire it will force the network connector
1:3100909:      * to shutdown
1:3100909:      *
1:3100909:      *
1:3100909:      * @throws Exception
1:3100909:      */
1:3100909: 
1:3100909:     public void testDuplexSendFailIfNoSpaceDoesNotBlockNetwork() throws Exception {
1:3100909: 
1:3100909:         // Consumer prefetch is disabled for broker1's consumers.
1:3100909:         final ActiveMQTopic destination = new ActiveMQTopic(
1:3100909:                 NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:3100909:                         + ".duplexTest?consumer.prefetchSize=1");
1:3100909: 
1:3100909:         final int NUM_MESSAGES = 100;
1:3100909:         final long TEST_MESSAGE_SIZE = 1024;
1:3100909:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1:3100909: 
1:3100909:         // Start a local and a remote broker.
1:3100909:         BrokerService localBroker = createBroker(new URI("broker:(tcp://localhost:0"
1:3100909:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1:3100909: 
1:3100909:         BrokerService remoteBroker = createBroker(new URI(
1:3100909:                 "broker:(tcp://localhost:0"
1:3100909:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1:3100909: 
1:3100909:         localBroker.getSystemUsage().setSendFailIfNoSpace(true);
1:3100909: 
1:3100909:         // Set a policy on the remote broker that limits the maximum size of the
1:3100909:         // slow shared queue.
1:3100909:         PolicyEntry policyEntry = new PolicyEntry();
1:3100909:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:3100909:         PolicyMap policyMap = new PolicyMap();
1:3100909:         policyMap.put(destination, policyEntry);
1:3100909:         localBroker.setDestinationPolicy(policyMap);
1:3100909: 
1:3100909:         // Create a duplex network bridge from the local broker to the remote broker
1:3100909:         // create a SimpleDiscoveryAgent impl that tracks a reconnect
1:3100909:         DiscoveryNetworkConnector discoveryNetworkConnector =  (DiscoveryNetworkConnector)bridgeBrokers("broker0", "broker1");
1:3100909:         URI originURI = discoveryNetworkConnector.getUri();
1:3100909:         discoveryNetworkConnector.setAlwaysSyncSend(true);
1:3100909:         discoveryNetworkConnector.setPrefetchSize(1);
1:3100909:         discoveryNetworkConnector.setDuplex(true);
1:3100909: 
1:3100909:         DummySimpleDiscoveryAgent dummySimpleDiscoveryAgent = new DummySimpleDiscoveryAgent();
1:3100909:         dummySimpleDiscoveryAgent.setServices(originURI.toString().substring(8,originURI.toString().lastIndexOf(')')));
1:3100909: 
1:3100909:         discoveryNetworkConnector.setDiscoveryAgent(dummySimpleDiscoveryAgent);
1:3100909: 
1:3100909:         startAllBrokers();
1:3100909:         waitForBridgeFormation();
1:3100909: 
1:3100909: 
1:3100909:         final CountDownLatch consumerLatch = new CountDownLatch(
1:3100909:                 NUM_MESSAGES);
1:3100909: 
1:3100909: 
1:3100909:         //createConsumer("broker0", fastDestination, fastConsumerLatch);
1:3100909: 
1:3100909:         MessageConsumer consumer = createConsumer("broker0",
1:3100909:                 destination, consumerLatch);
1:3100909: 
1:3100909:         MessageIdList messageIdList = brokers.get("broker0").consumers
1:3100909:                 .get(consumer);
1:3100909: 
1:3100909:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1:3100909: 
1:3100909:         // Send the test messages to the local broker's shared queues. The
1:3100909:         // messages are either persistent or non-persistent to demonstrate the
1:3100909:         // difference between synchronous and asynchronous dispatch.
1:3100909:         persistentDelivery = false;
1:3100909:         sendMessages("broker1", destination, NUM_MESSAGES);
1:3100909: 
1:3100909:         //wait for 5 seconds for the consumer to complete
1:3100909:         consumerLatch.await(5, TimeUnit.SECONDS);
1:3100909: 
1:3100909:         assertFalse("dummySimpleDiscoveryAgent.serviceFail has been invoked - should not have been",
1:3100909:                 dummySimpleDiscoveryAgent.isServiceFailed);
1:3100909: 
1:3100909:     }
1:3100909: 
1:3100909:     /**
1:3100909:      * When the network connector fails it records the failure and delegates to real SimpleDiscoveryAgent
1:3100909:      */
1:3100909:     class DummySimpleDiscoveryAgent extends SimpleDiscoveryAgent {
1:3100909: 
1:3100909:         boolean isServiceFailed = false;
1:3100909: 
1:3100909:         public void serviceFailed(DiscoveryEvent devent) throws IOException {
1:3100909: 
1:3100909:             //should never get in here
1:3100909:             LOG.info("!!!!! DummySimpleDiscoveryAgent.serviceFailed() invoked with event:"+devent+"!!!!!!");
1:3100909:             isServiceFailed = true;
1:3100909:             super.serviceFailed(devent);
1:3100909: 
1:3100909:         }
1:3100909: 
1:3100909:     }
1:3100909: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:3100909
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.DiscoveryEvent;
1: import org.apache.activemq.network.DiscoveryNetworkConnector;
1: import org.apache.activemq.transport.discovery.simple.SimpleDiscoveryAgent;
/////////////////////////////////////////////////////////////////////////
1:                     .assertTrue(fastConsumerTime.get() < slowConsumerTime.get() / 20);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testSendFailIfNoSpaceReverseDoesNotBlockQueueNetwork() throws Exception {
1:         final int NUM_MESSAGES = 100;
1:         final long TEST_MESSAGE_SIZE = 1024;
1:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1: 
1:         final ActiveMQQueue slowDestination = new ActiveMQQueue(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".slow.shared?consumer.prefetchSize=1");
1: 
1:         final ActiveMQQueue fastDestination = new ActiveMQQueue(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".fast.shared?consumer.prefetchSize=1");
1: 
1: 
1:         // Start a local and a remote broker.
1:         BrokerService localBroker = createBroker(new URI("broker:(tcp://localhost:0"
1:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1:         createBroker(new URI(
1:                 "broker:(tcp://localhost:0"
1:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1:         localBroker.getSystemUsage().setSendFailIfNoSpace(true);
1: 
1:         // Set a policy on the local broker that limits the maximum size of the
1:         // slow shared queue.
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.put(slowDestination, policyEntry);
1:         localBroker.setDestinationPolicy(policyMap);
1: 
1:         // Create an outbound bridge from the local broker to the remote broker.
1:         // The bridge is configured with the remoteDispatchType enhancement.
1:         NetworkConnector nc = bridgeBrokers("broker0", "broker1");
1:         nc.setAlwaysSyncSend(true);
1:         nc.setPrefetchSize(1);
1:         nc.setDuplex(true);
1: 
1:         startAllBrokers();
1:         waitForBridgeFormation();
1: 
1:         // Start two asynchronous consumers on the local broker, one for each
1:         // of the two shared queues, and keep track of how long it takes for
1:         // each of the consumers to receive all the messages.
1:         final CountDownLatch fastConsumerLatch = new CountDownLatch(
1:                 NUM_MESSAGES);
1:         final CountDownLatch slowConsumerLatch = new CountDownLatch(
1:                 NUM_MESSAGES);
1: 
1:         final long startTimeMillis = System.currentTimeMillis();
1:         final AtomicLong fastConsumerTime = new AtomicLong();
1:         final AtomicLong slowConsumerTime = new AtomicLong();
1: 
1:         Thread fastWaitThread = new Thread() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     fastConsumerLatch.await();
1:                     fastConsumerTime.set(System.currentTimeMillis()
1:                             - startTimeMillis);
1:                 } catch (InterruptedException ex) {
1:                     exceptions.add(ex);
1:                     Assert.fail(ex.getMessage());
1:                 }
1:             }
1:         };
1: 
1:         Thread slowWaitThread = new Thread() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     slowConsumerLatch.await();
1:                     slowConsumerTime.set(System.currentTimeMillis()
1:                             - startTimeMillis);
1:                 } catch (InterruptedException ex) {
1:                     exceptions.add(ex);
1:                     Assert.fail(ex.getMessage());
1:                 }
1:             }
1:         };
1: 
1:         fastWaitThread.start();
1:         slowWaitThread.start();
1: 
1:         createConsumer("broker0", fastDestination, fastConsumerLatch);
1:         MessageConsumer slowConsumer = createConsumer("broker0",
1:                 slowDestination, slowConsumerLatch);
1:         MessageIdList messageIdList = brokers.get("broker0").consumers
1:                 .get(slowConsumer);
1:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1: 
1:         // Send the test messages to the local broker's shared queues. The
1:         // messages are either persistent or non-persistent to demonstrate the
1:         // difference between synchronous and asynchronous dispatch.
1:         persistentDelivery = false;
1:         sendMessages("broker1", fastDestination, NUM_MESSAGES);
1:         sendMessages("broker1", slowDestination, NUM_MESSAGES);
1: 
1:         fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1:         slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1: 
1:         assertTrue("no exceptions on the wait threads:" + exceptions,
1:                 exceptions.isEmpty());
1: 
1:         LOG.info("Fast consumer duration (ms): " + fastConsumerTime.get());
1:         LOG.info("Slow consumer duration (ms): " + slowConsumerTime.get());
1: 
1:         assertTrue("fast time set", fastConsumerTime.get() > 0);
1:         assertTrue("slow time set", slowConsumerTime.get() > 0);
1: 
1:         // Verify the behaviour as described in the description of this class.
1:         Assert.assertTrue(fastConsumerTime.get() < slowConsumerTime.get() / 10);
1:     }
1: 
1: 
1:     /**
1:      * create a duplex network bridge from broker0 to broker1
1:      * add a topic consumer on broker0
1:      * set the setSendFailIfNoSpace() on the local broker.
1:      * create a SimpleDiscoveryAgent impl that tracks a network reconnect
1:      *
1:      * producer connects to broker1 and messages should be sent across the network to broker0
1:      *
1:      * Ensure broker0 will not send the  javax.jms.ResourceAllocationException (when broker0 runs out of space).
1:      * If the javax.jms.ResourceAllocationException is sent across the wire it will force the network connector
1:      * to shutdown
1:      *
1:      *
1:      * @throws Exception
1:      */
1: 
1:     public void testDuplexSendFailIfNoSpaceDoesNotBlockNetwork() throws Exception {
1: 
1:         // Consumer prefetch is disabled for broker1's consumers.
1:         final ActiveMQTopic destination = new ActiveMQTopic(
1:                 NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                         + ".duplexTest?consumer.prefetchSize=1");
1: 
1:         final int NUM_MESSAGES = 100;
1:         final long TEST_MESSAGE_SIZE = 1024;
1:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1: 
1:         // Start a local and a remote broker.
1:         BrokerService localBroker = createBroker(new URI("broker:(tcp://localhost:0"
1:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1: 
1:         BrokerService remoteBroker = createBroker(new URI(
1:                 "broker:(tcp://localhost:0"
1:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1: 
1:         localBroker.getSystemUsage().setSendFailIfNoSpace(true);
1: 
1:         // Set a policy on the remote broker that limits the maximum size of the
1:         // slow shared queue.
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.put(destination, policyEntry);
1:         localBroker.setDestinationPolicy(policyMap);
1: 
1:         // Create a duplex network bridge from the local broker to the remote broker
1:         // create a SimpleDiscoveryAgent impl that tracks a reconnect
1:         DiscoveryNetworkConnector discoveryNetworkConnector =  (DiscoveryNetworkConnector)bridgeBrokers("broker0", "broker1");
1:         URI originURI = discoveryNetworkConnector.getUri();
1:         discoveryNetworkConnector.setAlwaysSyncSend(true);
1:         discoveryNetworkConnector.setPrefetchSize(1);
1:         discoveryNetworkConnector.setDuplex(true);
1: 
1:         DummySimpleDiscoveryAgent dummySimpleDiscoveryAgent = new DummySimpleDiscoveryAgent();
1:         dummySimpleDiscoveryAgent.setServices(originURI.toString().substring(8,originURI.toString().lastIndexOf(')')));
1: 
1:         discoveryNetworkConnector.setDiscoveryAgent(dummySimpleDiscoveryAgent);
1: 
1:         startAllBrokers();
1:         waitForBridgeFormation();
1: 
1: 
1:         final CountDownLatch consumerLatch = new CountDownLatch(
1:                 NUM_MESSAGES);
1: 
1: 
1:         //createConsumer("broker0", fastDestination, fastConsumerLatch);
1: 
1:         MessageConsumer consumer = createConsumer("broker0",
1:                 destination, consumerLatch);
1: 
1:         MessageIdList messageIdList = brokers.get("broker0").consumers
1:                 .get(consumer);
1: 
1:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1: 
1:         // Send the test messages to the local broker's shared queues. The
1:         // messages are either persistent or non-persistent to demonstrate the
1:         // difference between synchronous and asynchronous dispatch.
1:         persistentDelivery = false;
1:         sendMessages("broker1", destination, NUM_MESSAGES);
1: 
1:         //wait for 5 seconds for the consumer to complete
1:         consumerLatch.await(5, TimeUnit.SECONDS);
1: 
1:         assertFalse("dummySimpleDiscoveryAgent.serviceFail has been invoked - should not have been",
1:                 dummySimpleDiscoveryAgent.isServiceFailed);
1: 
1:     }
1: 
1:     /**
1:      * When the network connector fails it records the failure and delegates to real SimpleDiscoveryAgent
1:      */
1:     class DummySimpleDiscoveryAgent extends SimpleDiscoveryAgent {
1: 
1:         boolean isServiceFailed = false;
1: 
1:         public void serviceFailed(DiscoveryEvent devent) throws IOException {
1: 
1:             //should never get in here
1:             LOG.info("!!!!! DummySimpleDiscoveryAgent.serviceFailed() invoked with event:"+devent+"!!!!!!");
1:             isServiceFailed = true;
1:             super.serviceFailed(devent);
1: 
1:         }
1: 
1:     }
1: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Gary Tully
-------------------------------------------------------------------------------
commit:8ce0778
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Consumer prefetch is disabled for broker1's consumers.
1:         final ActiveMQQueue SLOW_SHARED_QUEUE = new ActiveMQQueue(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".slow.shared?consumer.prefetchSize=1");
1: 
1:         final ActiveMQQueue FAST_SHARED_QUEUE = new ActiveMQQueue(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".fast.shared?consumer.prefetchSize=1");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testSendFailIfNoSpaceDoesNotBlockQueueNetwork() throws Exception {
1:         // Consumer prefetch is disabled for broker1's consumers.
1:         final ActiveMQQueue SLOW_SHARED_QUEUE = new ActiveMQQueue(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".slow.shared?consumer.prefetchSize=1");
1: 
1:         final ActiveMQQueue FAST_SHARED_QUEUE = new ActiveMQQueue(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".fast.shared?consumer.prefetchSize=1");
1: 
1:         doTestSendFailIfNoSpaceDoesNotBlockNetwork(
1:                 SLOW_SHARED_QUEUE,
1:                 FAST_SHARED_QUEUE);
1:     }
1: 
1:     public void testSendFailIfNoSpaceDoesNotBlockTopicNetwork() throws Exception {
1:         // Consumer prefetch is disabled for broker1's consumers.
1:         final ActiveMQTopic SLOW_SHARED_TOPIC = new ActiveMQTopic(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".slow.shared?consumer.prefetchSize=1");
1: 
1:         final ActiveMQTopic FAST_SHARED_TOPIC = new ActiveMQTopic(
1:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
1:                     + ".fast.shared?consumer.prefetchSize=1");
1: 
1:         doTestSendFailIfNoSpaceDoesNotBlockNetwork(
1:                 SLOW_SHARED_TOPIC,
1:                 FAST_SHARED_TOPIC);
1:     }
1: 
1:     public void doTestSendFailIfNoSpaceDoesNotBlockNetwork(
1:             ActiveMQDestination slowDestination, ActiveMQDestination fastDestination) throws Exception {
1: 
1:         final int NUM_MESSAGES = 100;
1:         final long TEST_MESSAGE_SIZE = 1024;
1:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1: 
1:         // Start a local and a remote broker.
1:         createBroker(new URI("broker:(tcp://localhost:0"
1:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1:         BrokerService remoteBroker = createBroker(new URI(
1:                 "broker:(tcp://localhost:0"
1:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1:         remoteBroker.getSystemUsage().setSendFailIfNoSpace(true);
1: 
1:         // Set a policy on the remote broker that limits the maximum size of the
1:         // slow shared queue.
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.put(slowDestination, policyEntry);
1:         remoteBroker.setDestinationPolicy(policyMap);
1: 
1:         // Create an outbound bridge from the local broker to the remote broker.
1:         // The bridge is configured with the remoteDispatchType enhancement.
1:         NetworkConnector nc = bridgeBrokers("broker0", "broker1");
1:         nc.setAlwaysSyncSend(true);
1:         nc.setPrefetchSize(1);
1: 
1:         startAllBrokers();
1:         waitForBridgeFormation();
1: 
1:         // Start two asynchronous consumers on the remote broker, one for each
1:         // of the two shared queues, and keep track of how long it takes for
1:         // each of the consumers to receive all the messages.
1:         final CountDownLatch fastConsumerLatch = new CountDownLatch(
1:                 NUM_MESSAGES);
1:         final CountDownLatch slowConsumerLatch = new CountDownLatch(
1:                 NUM_MESSAGES);
1: 
1:         final long startTimeMillis = System.currentTimeMillis();
1:         final AtomicLong fastConsumerTime = new AtomicLong();
1:         final AtomicLong slowConsumerTime = new AtomicLong();
1: 
1:         Thread fastWaitThread = new Thread() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     fastConsumerLatch.await();
1:                     fastConsumerTime.set(System.currentTimeMillis()
1:                             - startTimeMillis);
1:                 } catch (InterruptedException ex) {
1:                     exceptions.add(ex);
1:                     Assert.fail(ex.getMessage());
1:                 }
1:             }
1:         };
1: 
1:         Thread slowWaitThread = new Thread() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     slowConsumerLatch.await();
1:                     slowConsumerTime.set(System.currentTimeMillis()
1:                             - startTimeMillis);
1:                 } catch (InterruptedException ex) {
1:                     exceptions.add(ex);
1:                     Assert.fail(ex.getMessage());
1:                 }
1:             }
1:         };
1: 
1:         fastWaitThread.start();
1:         slowWaitThread.start();
1: 
1:         createConsumer("broker1", fastDestination, fastConsumerLatch);
1:         MessageConsumer slowConsumer = createConsumer("broker1",
1:                 slowDestination, slowConsumerLatch);
1:         MessageIdList messageIdList = brokers.get("broker1").consumers
1:                 .get(slowConsumer);
1:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1: 
1:         // Send the test messages to the local broker's shared queues. The
1:         // messages are either persistent or non-persistent to demonstrate the
1:         // difference between synchronous and asynchronous dispatch.
1:         persistentDelivery = false;
1:         sendMessages("broker0", fastDestination, NUM_MESSAGES);
1:         sendMessages("broker0", slowDestination, NUM_MESSAGES);
1: 
1:         fastWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1:         slowWaitThread.join(TimeUnit.SECONDS.toMillis(60));
1: 
1:         assertTrue("no exceptions on the wait threads:" + exceptions,
1:                 exceptions.isEmpty());
1: 
1:         LOG.info("Fast consumer duration (ms): " + fastConsumerTime.get());
1:         LOG.info("Slow consumer duration (ms): " + slowConsumerTime.get());
1: 
1:         assertTrue("fast time set", fastConsumerTime.get() > 0);
1:         assertTrue("slow time set", slowConsumerTime.get() > 0);
1: 
1:         // Verify the behaviour as described in the description of this class.
1:         Assert.assertTrue(fastConsumerTime.get() < slowConsumerTime.get() / 10);
1:     }
commit:6d077dc
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.usecases;
1: 
1: import java.net.URI;
1: import java.util.Vector;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.atomic.AtomicLong;
1: import javax.jms.MessageConsumer;
1: import junit.framework.Test;
1: import org.apache.activemq.JmsMultipleBrokersTestSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.network.NetworkConnector;
1: import org.apache.activemq.util.MessageIdList;
1: import org.apache.commons.logging.Log;
1: import org.apache.commons.logging.LogFactory;
1: import org.junit.Assert;
1: 
1: /**
1:  * This test demonstrates and verifies the behaviour of a network bridge when it
1:  * forwards a message to a queue that is full and producer flow control is
1:  * enabled.
1:  * <p/>
1:  * The expected behaviour is that the bridge will stop forwarding messages to
1:  * the full queue once the associated demand consumer's prefetch is full, but
1:  * will continue to forward messages to the other queues that are not full.
1:  * <p/>
1:  * In actuality, a message that is sent <b>asynchronously</b> to a local queue,
1:  * but blocked by producer flow control on the remote queue, will stop the
1:  * bridge from forwarding all subsequent messages, even those destined for
1:  * remote queues that are not full. In the same scenario, but with a message
1:  * that is sent <b>synchronously</b> to the local queue, the bridge continues
1:  * forwarding messages to remote queues that are not full.
1:  * <p/>
1:  * This test demonstrates the differing behaviour via the following scenario:
1:  * <ul>
1:  * <li>broker0, designated as the local broker, produces messages to two shared
1:  * queues
1:  * <li>broker1, designated as the remote broker, has two consumers: the first
1:  * consumes from one of the shared queues as fast as possible, the second
1:  * consumes from the other shared queue with an artificial processing delay for
1:  * each message
1:  * <li>broker0 forwards messages to broker1 over a TCP-based network bridge
1:  * with a demand consumer prefetch of 1
1:  * <li>broker1's consumers have a prefetch of 1
1:  * <li>broker1's "slow consumer" queue has a memory limit that triggers
1:  * producer flow control once the queue contains a small number of messages
1:  * </ul>
1:  * In this scenario, since broker1's consumers have a prefetch of 1, the "slow
1:  * consumer" queue will quickly become full and trigger producer flow control.
1:  * The "fast consumer" queue is unlikely to become full. Since producer flow
1:  * control on the "slow consumer" queue should not affect the "fast consumer"
1:  * queue, the expectation is that the fast consumer in broker1 will finish
1:  * processing all its messages well ahead of the slow consumer.
1:  * <p/>
1:  * The difference between expected and actual behaviour is demonstrated by
1:  * changing the messages produced by broker0 from persistent to non-persistent.
1:  * With persistent messages, broker0 dispatches synchronously and the expected
1:  * behaviour is observed (i.e., the fast consumer on broker1 is much faster than
1:  * the slow consumer). With non-persistent messages, broker0 dispatches
1:  * asynchronously and the expected behaviour is <b>not</b> observed (i.e., the
1:  * fast consumer is only marginally faster than the slow consumer).
1:  * <p/>
1:  * Since the expected behaviour may be desirable for both persistent and
1:  * non-persistent messages, this test also demonstrates an enhancement to the
1:  * network bridge configuration: <tt>isAlwaysSendSync</tt>. When false the
1:  * bridge operates as originally observed. When <tt>true</tt>, the bridge
1:  * operates with the same behaviour as was originally observed with persistent
1:  * messages, for both persistent and non-persistent messages.
1:  * <p/>
1:  * https://issues.apache.org/jira/browse/AMQ-3331
1:  *
1:  * @author schow
1:  */
1: public class NetworkBridgeProducerFlowControlTest extends
1:         JmsMultipleBrokersTestSupport {
1: 
1:     // Protect against hanging test.
1:     private static final long MAX_TEST_TIME = 120000;
1: 
1:     private static final Log LOG = LogFactory
1:             .getLog(NetworkBridgeProducerFlowControlTest.class);
1: 
0:     // Consumer prefetch is disabled for broker1's consumers.
0:     private static final ActiveMQQueue SLOW_SHARED_QUEUE = new ActiveMQQueue(
0:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
0:                     + ".slow.shared?consumer.prefetchSize=1");
1: 
0:     private static final ActiveMQQueue FAST_SHARED_QUEUE = new ActiveMQQueue(
0:             NetworkBridgeProducerFlowControlTest.class.getSimpleName()
0:                     + ".fast.shared?consumer.prefetchSize=1");
1: 
1:     // Combo flag set to true/false by the test framework.
1:     public boolean persistentTestMessages;
1:     public boolean networkIsAlwaysSendSync;
1: 
1:     private Vector<Throwable> exceptions = new Vector<Throwable>();
1: 
1:     public static Test suite() {
1:         return suite(NetworkBridgeProducerFlowControlTest.class);
1:     }
1: 
1:     public void initCombosForTestFastAndSlowRemoteConsumers() {
1:         addCombinationValues("persistentTestMessages", new Object[]{
1:                 new Boolean(true), new Boolean(false)});
1:         addCombinationValues("networkIsAlwaysSendSync", new Object[]{
1:                 new Boolean(true), new Boolean(false)});
1:     }
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         setAutoFail(true);
1:         setMaxTestTime(MAX_TEST_TIME);
1:         super.setUp();
1:     }
1: 
1:     /**
1:      * This test is parameterized by {@link #persistentTestMessages}, which
1:      * determines whether the producer on broker0 sends persistent or
1:      * non-persistent messages, and {@link #networkIsAlwaysSendSync}, which
1:      * determines how the bridge will forward both persistent and non-persistent
1:      * messages to broker1.
1:      *
1:      * @see #initCombosForTestFastAndSlowRemoteConsumers()
1:      */
1:     public void testFastAndSlowRemoteConsumers() throws Exception {
1:         final int NUM_MESSAGES = 100;
1:         final long TEST_MESSAGE_SIZE = 1024;
1:         final long SLOW_CONSUMER_DELAY_MILLIS = 100;
1: 
1:         // Start a local and a remote broker.
1:         createBroker(new URI("broker:(tcp://localhost:0"
1:                 + ")?brokerName=broker0&persistent=false&useJmx=true"));
1:         BrokerService remoteBroker = createBroker(new URI(
1:                 "broker:(tcp://localhost:0"
1:                         + ")?brokerName=broker1&persistent=false&useJmx=true"));
1: 
1:         // Set a policy on the remote broker that limits the maximum size of the
1:         // slow shared queue.
1:         PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setMemoryLimit(5 * TEST_MESSAGE_SIZE);
1:         PolicyMap policyMap = new PolicyMap();
1:         policyMap.put(SLOW_SHARED_QUEUE, policyEntry);
1:         remoteBroker.setDestinationPolicy(policyMap);
1: 
1:         // Create an outbound bridge from the local broker to the remote broker.
1:         // The bridge is configured with the remoteDispatchType enhancement.
1:         NetworkConnector nc = bridgeBrokers("broker0", "broker1");
1:         nc.setAlwaysSyncSend(networkIsAlwaysSendSync);
1:         nc.setPrefetchSize(1);
1: 
1:         startAllBrokers();
1:         waitForBridgeFormation();
1: 
1:         // Send the test messages to the local broker's shared queues. The
1:         // messages are either persistent or non-persistent to demonstrate the
1:         // difference between synchronous and asynchronous dispatch.
1:         persistentDelivery = persistentTestMessages;
1:         sendMessages("broker0", FAST_SHARED_QUEUE, NUM_MESSAGES);
1:         sendMessages("broker0", SLOW_SHARED_QUEUE, NUM_MESSAGES);
1: 
1:         // Start two asynchronous consumers on the remote broker, one for each
1:         // of the two shared queues, and keep track of how long it takes for
1:         // each of the consumers to receive all the messages.
1:         final CountDownLatch fastConsumerLatch = new CountDownLatch(
1:                 NUM_MESSAGES);
1:         final CountDownLatch slowConsumerLatch = new CountDownLatch(
1:                 NUM_MESSAGES);
1: 
1:         final long startTimeMillis = System.currentTimeMillis();
1:         final AtomicLong fastConsumerTime = new AtomicLong();
1:         final AtomicLong slowConsumerTime = new AtomicLong();
1: 
1:         Thread fastWaitThread = new Thread() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     fastConsumerLatch.await();
1:                     fastConsumerTime.set(System.currentTimeMillis()
1:                             - startTimeMillis);
1:                 } catch (InterruptedException ex) {
1:                     exceptions.add(ex);
1:                     Assert.fail(ex.getMessage());
1:                 }
1:             }
1:         };
1: 
1:         Thread slowWaitThread = new Thread() {
1:             @Override
1:             public void run() {
1:                 try {
1:                     slowConsumerLatch.await();
1:                     slowConsumerTime.set(System.currentTimeMillis()
1:                             - startTimeMillis);
1:                 } catch (InterruptedException ex) {
1:                     exceptions.add(ex);
1:                     Assert.fail(ex.getMessage());
1:                 }
1:             }
1:         };
1: 
1:         fastWaitThread.start();
1:         slowWaitThread.start();
1: 
1:         createConsumer("broker1", FAST_SHARED_QUEUE, fastConsumerLatch);
1:         MessageConsumer slowConsumer = createConsumer("broker1",
1:                 SLOW_SHARED_QUEUE, slowConsumerLatch);
1:         MessageIdList messageIdList = brokers.get("broker1").consumers
1:                 .get(slowConsumer);
1:         messageIdList.setProcessingDelay(SLOW_CONSUMER_DELAY_MILLIS);
1: 
1:         fastWaitThread.join();
1:         slowWaitThread.join();
1: 
1:         assertTrue("no exceptions on the wait threads:" + exceptions,
1:                 exceptions.isEmpty());
1: 
1:         LOG.info("Fast consumer duration (ms): " + fastConsumerTime.get());
1:         LOG.info("Slow consumer duration (ms): " + slowConsumerTime.get());
1: 
1:         // Verify the behaviour as described in the description of this class.
1:         if (networkIsAlwaysSendSync) {
1:             Assert
0:                     .assertTrue(fastConsumerTime.get() < slowConsumerTime.get() / 10);
1: 
1:         } else {
1:             Assert.assertEquals(persistentTestMessages,
1:                     fastConsumerTime.get() < slowConsumerTime.get() / 10);
1:         }
1:     }
1: }
============================================================================