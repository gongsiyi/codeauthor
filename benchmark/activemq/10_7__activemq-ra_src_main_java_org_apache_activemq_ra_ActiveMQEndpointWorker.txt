7:40a7d3b: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:d7355e7:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
7:40a7d3b:  *
1:40a7d3b:  * Unless required by applicable law or agreed to in writing, software
1:40a7d3b:  * distributed under the License is distributed on an "AS IS" BASIS,
1:40a7d3b:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:40a7d3b:  * See the License for the specific language governing permissions and
1:40a7d3b:  * limitations under the License.
6:40a7d3b:  */
1:fd4bb60: package org.apache.activemq.ra;
1:540dd5c: 
1:40a7d3b: import java.lang.reflect.Method;
19:40a7d3b: 
1:58e5b9a: import java.util.concurrent.atomic.AtomicBoolean;
1:40a7d3b: import javax.jms.Connection;
1:40a7d3b: import javax.jms.ConnectionConsumer;
1:40a7d3b: import javax.jms.ExceptionListener;
1:40a7d3b: import javax.jms.JMSException;
1:40a7d3b: import javax.jms.Message;
1:40a7d3b: import javax.jms.MessageListener;
1:40a7d3b: import javax.jms.Session;
1:40a7d3b: import javax.jms.Topic;
1:7bc7178: import javax.naming.InitialContext;
1:7bc7178: import javax.naming.NamingException;
1:40a7d3b: import javax.resource.ResourceException;
1:40a7d3b: import javax.resource.spi.endpoint.MessageEndpointFactory;
1:40a7d3b: import javax.resource.spi.work.Work;
1:40a7d3b: import javax.resource.spi.work.WorkException;
1:40a7d3b: import javax.resource.spi.work.WorkManager;
1:40a7d3b: 
1:fd4bb60: import org.apache.activemq.ActiveMQConnection;
1:757a2f1: import org.apache.activemq.ActiveMQConnectionConsumer;
1:fd4bb60: import org.apache.activemq.command.ActiveMQDestination;
1:fd4bb60: import org.apache.activemq.command.ActiveMQQueue;
1:fd4bb60: import org.apache.activemq.command.ActiveMQTopic;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:40a7d3b: 
1:d7355e7: /**
1:b0c2a40:  *  $Date$
1:d7355e7:  */
1:40a7d3b: public class ActiveMQEndpointWorker {
1:d7355e7: 
1:40a7d3b:     public static final Method ON_MESSAGE_METHOD;
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQEndpointWorker.class);
1:40a7d3b: 
1:40a7d3b:     private static final long INITIAL_RECONNECT_DELAY = 1000; // 1 second.
1:540dd5c:     private static final long MAX_RECONNECT_DELAY = 1000 * 30; // 30 seconds.
1:540dd5c:     private static final ThreadLocal<Session> THREAD_LOCAL = new ThreadLocal<Session>();
1:540dd5c: 
1:40a7d3b:     static {
1:540dd5c:         try {
1:540dd5c:             ON_MESSAGE_METHOD = MessageListener.class.getMethod("onMessage", new Class[] {
1:540dd5c:                 Message.class
1:540dd5c:             });
1:540dd5c:         } catch (Exception e) {
1:40a7d3b:             throw new ExceptionInInitializerError(e);
1:540dd5c:         }
1:d8bdbe7:     }
1:40a7d3b: 
1:58e5b9a:     protected final ActiveMQEndpointActivationKey endpointActivationKey;
1:58e5b9a:     protected final MessageEndpointFactory endpointFactory;
1:58e5b9a:     protected final WorkManager workManager;
1:58e5b9a:     protected final boolean transacted;
1:40a7d3b: 
1:58e5b9a:     private final ActiveMQDestination dest;
1:58e5b9a:     private final Work connectWork;
1:58e5b9a:     private final AtomicBoolean connecting = new AtomicBoolean(false);    
1:5b11c0e:     private final Object shutdownMutex = new String("shutdownMutex");
1:58e5b9a:     
1:58e5b9a:     private ActiveMQConnection connection;
1:757a2f1:     private ActiveMQConnectionConsumer consumer;
1:40a7d3b:     private ServerSessionPoolImpl serverSessionPool;
1:40a7d3b:     private boolean running;
1:40a7d3b: 
1:58e5b9a:     protected ActiveMQEndpointWorker(final MessageResourceAdapter adapter, ActiveMQEndpointActivationKey key) throws ResourceException {
1:40a7d3b:         this.endpointActivationKey = key;
1:40a7d3b:         this.endpointFactory = endpointActivationKey.getMessageEndpointFactory();
1:40a7d3b:         this.workManager = adapter.getBootstrapContext().getWorkManager();
1:540dd5c:         try {
1:40a7d3b:             this.transacted = endpointFactory.isDeliveryTransacted(ON_MESSAGE_METHOD);
1:540dd5c:         } catch (NoSuchMethodException e) {
1:40a7d3b:             throw new ResourceException("Endpoint does not implement the onMessage method.");
1:540dd5c:         }
1:540dd5c: 
1:40a7d3b:         connectWork = new Work() {
1:58e5b9a:             long currentReconnectDelay = INITIAL_RECONNECT_DELAY;
1:40a7d3b: 
1:40a7d3b:             public void release() {
1:540dd5c:                 //
1:540dd5c:             }
1:540dd5c: 
1:e2325f5:             public void run() {
1:58e5b9a:                 currentReconnectDelay = INITIAL_RECONNECT_DELAY;
1:58e5b9a:                 MessageActivationSpec activationSpec = endpointActivationKey.getActivationSpec();
1:ee2069f:                 if (LOG.isInfoEnabled()) {
1:58e5b9a:                     LOG.info("Establishing connection to broker [" + adapter.getInfo().getServerUrl() + "]");
1:540dd5c:                 }
1:40a7d3b: 
1:ee2069f:                 while (connecting.get() && running) {
1:ee2069f:                     try {
1:ee2069f:                         connection = adapter.makeConnection(activationSpec);
1:ee2069f:                         connection.setExceptionListener(new ExceptionListener() {
1:ee2069f:                             public void onException(JMSException error) {
1:ee2069f:                                 if (!serverSessionPool.isClosing()) {
1:58e5b9a:                                     // initiate reconnection only once, i.e. on initial exception
1:58e5b9a:                                     // and only if not already trying to connect
1:58e5b9a:                                     LOG.error("Connection to broker failed: " + error.getMessage(), error);
1:ee2069f:                                     if (connecting.compareAndSet(false, true)) {
1:ee2069f:                                         synchronized (connectWork) {
1:58e5b9a:                                             disconnect();
1:519d8f7:                                             serverSessionPool.closeSessions();
1:58e5b9a:                                             connect();
1:ee2069f:                                         }
1:58e5b9a:                                     } else {
1:58e5b9a:                                         // connection attempt has already been initiated
1:58e5b9a:                                         LOG.info("Connection attempt already in progress, ignoring connection exception");
1:ee2069f:                                     }
1:58e5b9a:                                 }
1:58e5b9a:                             }
1:ee2069f:                         });
1:58e5b9a:                         connection.start();
1:97f2ca1: 
1:ee2069f:                         if (activationSpec.isDurableSubscription()) {
1:757a2f1:                             consumer = (ActiveMQConnectionConsumer) connection.createDurableConnectionConsumer(
1:58e5b9a:                                     (Topic) dest,
1:ee2069f:                                     activationSpec.getSubscriptionName(),
2:58e5b9a:                                     emptyToNull(activationSpec.getMessageSelector()),
1:ee2069f:                                     serverSessionPool,
1:ee2069f:                                     connection.getPrefetchPolicy().getDurableTopicPrefetch(),
1:58e5b9a:                                     activationSpec.getNoLocalBooleanValue());
1:ee2069f:                         } else {
1:757a2f1:                             consumer = (ActiveMQConnectionConsumer) connection.createConnectionConsumer(
1:ee2069f:                                     dest,
1:ee2069f:                                     emptyToNull(activationSpec.getMessageSelector()),
1:ee2069f:                                     serverSessionPool,
1:ee2069f:                                     getPrefetch(activationSpec, connection, dest),
1:ee2069f:                                     activationSpec.getNoLocalBooleanValue());
1:ee2069f:                         }
1:58e5b9a: 
1:40a7d3b: 
1:ee2069f:                         if (connecting.compareAndSet(true, false)) {
1:ee2069f:                             if (LOG.isInfoEnabled()) {
1:58e5b9a:                                 LOG.info("Successfully established connection to broker [" + adapter.getInfo().getServerUrl() + "]");
1:58e5b9a:                             }
1:58e5b9a:                         } else {
1:58e5b9a:                             LOG.error("Could not release connection lock");
1:58e5b9a:                         }
1:757a2f1: 
1:757a2f1:                         if (consumer.getConsumerInfo().getCurrentPrefetchSize() == 0) {
1:757a2f1:                             LOG.error("Endpoint " + endpointActivationKey.getActivationSpec() + " will not receive any messages due to broker 'zero prefetch' configuration for: " + dest);
1:757a2f1:                         }
1:757a2f1: 
1:ee2069f:                     } catch (JMSException error) {
1:ee2069f:                         if (LOG.isDebugEnabled()) {
1:58e5b9a:                             LOG.debug("Failed to connect: " + error.getMessage(), error);
1:ee2069f:                         }
1:58e5b9a:                         disconnect();
1:58e5b9a:                         pause(error);
1:ee2069f:                     }
1:ee2069f:                 }
1:58e5b9a:             }
1:ee2069f: 
1:ee2069f:             private int getPrefetch(MessageActivationSpec activationSpec, ActiveMQConnection connection, ActiveMQDestination destination) {
1:ee2069f:                 if (destination.isTopic()) {
1:ee2069f:                     return connection.getPrefetchPolicy().getTopicPrefetch();
1:ee2069f:                 } else if (destination.isQueue()) {
1:ee2069f:                     return connection.getPrefetchPolicy().getQueuePrefetch();
1:ee2069f:                 } else {
1:ee2069f:                     return activationSpec.getMaxMessagesPerSessionsIntValue() * activationSpec.getMaxSessionsIntValue();
1:58e5b9a:                 }
1:58e5b9a:             }
1:58e5b9a:             
1:58e5b9a:             private void pause(JMSException error) {
1:58e5b9a:                 if (currentReconnectDelay == MAX_RECONNECT_DELAY) {
1:58e5b9a:                     LOG.error("Failed to connect to broker [" + adapter.getInfo().getServerUrl() + "]: " 
1:58e5b9a:                             + error.getMessage(), error);
1:58e5b9a:                     LOG.error("Endpoint will try to reconnect to the JMS broker in " + (MAX_RECONNECT_DELAY / 1000) + " seconds");
1:58e5b9a:                 }
1:58e5b9a:                 try {
1:58e5b9a:                     synchronized ( shutdownMutex ) {
1:58e5b9a:                         // shutdownMutex will be notified by stop() method in
1:58e5b9a:                         // order to accelerate shutdown of endpoint
1:58e5b9a:                         shutdownMutex.wait(currentReconnectDelay);
1:58e5b9a:                     }
1:58e5b9a:                 } catch ( InterruptedException e ) {
1:58e5b9a:                     Thread.interrupted();
1:58e5b9a:                 }
1:58e5b9a:                 currentReconnectDelay *= 2;
1:58e5b9a:                 if (currentReconnectDelay > MAX_RECONNECT_DELAY) {
1:58e5b9a:                     currentReconnectDelay = MAX_RECONNECT_DELAY;
1:540dd5c:                 }                
1:540dd5c:             }
1:40a7d3b:         };
1:40a7d3b: 
1:d7355e7:         MessageActivationSpec activationSpec = endpointActivationKey.getActivationSpec();
1:7bc7178:         if (activationSpec.isUseJndi()) {
1:7bc7178:             try {
1:7bc7178:                 InitialContext initialContext = new InitialContext();
1:7bc7178:                 dest = (ActiveMQDestination) initialContext.lookup(activationSpec.getDestination());
1:7bc7178:             }
1:7bc7178:             catch (NamingException exc) {
1:7bc7178:                 throw new ResourceException("JNDI lookup failed for "
1:7bc7178:                     + activationSpec.getDestination());
1:7bc7178:             }
1:97f2ca1:         }
1:7bc7178:         else {
1:7bc7178:             if ("javax.jms.Queue".equals(activationSpec.getDestinationType())) {
1:7bc7178:                 dest = new ActiveMQQueue(activationSpec.getDestination());
1:7bc7178:             }
1:7bc7178:             else if ("javax.jms.Topic".equals(activationSpec.getDestinationType())) {
1:7bc7178:                 dest = new ActiveMQTopic(activationSpec.getDestination());
1:7bc7178:             }
1:7bc7178:             else {
1:7bc7178:                 throw new ResourceException("Unknown destination type: "
1:7bc7178:                     + activationSpec.getDestinationType());
1:7bc7178:             }
1:7bc7178:         }
1:97f2ca1:     }
1:40a7d3b: 
1:540dd5c:     /**
1:540dd5c:      * @param c
1:540dd5c:      */
1:540dd5c:     public static void safeClose(Connection c) {
8:40a7d3b:         try {
1:540dd5c:             if (c != null) {
1:58e5b9a:                 LOG.debug("Closing connection to broker");
1:540dd5c:                 c.close();
1:540dd5c:             }
2:540dd5c:         } catch (JMSException e) {
1:e8818fa:             LOG.trace("failed to close c {}", c, e);
1:540dd5c:         }
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     /**
1:540dd5c:      * @param cc
1:540dd5c:      */
1:540dd5c:     public static void safeClose(ConnectionConsumer cc) {
1:540dd5c:         try {
1:540dd5c:             if (cc != null) {
1:58e5b9a:                 LOG.debug("Closing ConnectionConsumer");
1:540dd5c:                 cc.close();
1:540dd5c:             }
1:540dd5c:         } catch (JMSException e) {
1:e8818fa:             LOG.trace("failed to close cc {}", cc, e);
1:540dd5c:         }
1:540dd5c:     }
1:40a7d3b: 
1:d7355e7:     /**
1:d7355e7:      * 
1:d7355e7:      */
1:58e5b9a:     public void start() throws ResourceException {
1:58e5b9a:         synchronized (connectWork) {
1:58e5b9a:             if (running)
1:540dd5c:             return;
1:540dd5c:         running = true;
1:540dd5c: 
1:58e5b9a:             if ( connecting.compareAndSet(false, true) ) {
1:58e5b9a:                 LOG.info("Starting");
1:540dd5c:         serverSessionPool = new ServerSessionPoolImpl(this, endpointActivationKey.getActivationSpec().getMaxSessionsIntValue());
1:d8bdbe7:         connect();
1:58e5b9a:             } else {
1:58e5b9a:                 LOG.warn("Ignoring start command, EndpointWorker is already trying to connect");
1:58e5b9a:     }
1:58e5b9a:         }
1:540dd5c:     }
1:540dd5c: 
1:540dd5c:     /**
1:540dd5c:      * 
1:540dd5c:      */
1:58e5b9a:     public void stop() throws InterruptedException {
1:58e5b9a:         synchronized (shutdownMutex) {
1:58e5b9a:             if (!running)
1:2350d8b:                 return;
1:2350d8b:             running = false;
1:58e5b9a:             LOG.info("Stopping");
1:58e5b9a:             // wake up pausing reconnect attempt
1:58e5b9a:             shutdownMutex.notifyAll();
1:5ebee0a:             try {
1:5ebee0a:                 serverSessionPool.close();
1:5ebee0a:             } catch (Throwable ignored) {
1:5ebee0a:                 LOG.debug("Unexpected error on server session pool close", ignored);
1:5ebee0a:             }
1:2350d8b:         }
1:d8bdbe7:         disconnect();
1:58e5b9a:     }
1:40a7d3b: 
1:40a7d3b:     private boolean isRunning() {
1:40a7d3b:         return running;
1:540dd5c:     }
1:40a7d3b: 
1:58e5b9a:     private void connect() {
1:58e5b9a:         synchronized ( connectWork ) {
1:f42d56c:             if (!running) {
1:f42d56c:                 return;
1:f42d56c:             }
1:40a7d3b: 
1:f42d56c:             try {
1:f42d56c:                 workManager.scheduleWork(connectWork, WorkManager.INDEFINITE, null, null);
1:f42d56c:             } catch (WorkException e) {
1:f42d56c:                 running = false;
1:f42d56c:                 LOG.error("Work Manager did not accept work: ", e);
1:f42d56c:             }
1:58e5b9a:         }
1:58e5b9a:     }
1:40a7d3b: 
1:d7355e7:     /**
1:d7355e7:      * 
1:d7355e7:      */
1:58e5b9a:     private void disconnect() {
1:58e5b9a:         synchronized ( connectWork ) {
1:40a7d3b:         safeClose(consumer);
1:540dd5c:         consumer = null;
1:40a7d3b:         safeClose(connection);
1:540dd5c:         connection = null;
1:540dd5c:     }
1:540dd5c:             }
1:540dd5c: 
1:40a7d3b:     protected void registerThreadSession(Session session) {
1:540dd5c:         THREAD_LOCAL.set(session);
1:d7355e7:     }
1:40a7d3b: 
1:40a7d3b:     protected void unregisterThreadSession(Session session) {
1:540dd5c:         THREAD_LOCAL.set(null);
35:40a7d3b:     }
1:40a7d3b: 
1:519d8f7:     // for testing
1:519d8f7:     public void setConnection(ActiveMQConnection activeMQConnection) {
1:519d8f7:         this.connection = activeMQConnection;
1:519d8f7:     }
1:519d8f7: 
1:58e5b9a:     protected ActiveMQConnection getConnection() {
1:58e5b9a:         // make sure we only return a working connection
1:58e5b9a:         // in particular make sure that we do not return null
1:58e5b9a:         // after the resource adapter got disconnected from
1:58e5b9a:         // the broker via the disconnect() method
1:58e5b9a:         synchronized ( connectWork ) {
1:58e5b9a:             return connection;
1:58e5b9a:         }
1:58e5b9a:     }
1:58e5b9a: 
1:40a7d3b:     private String emptyToNull(String value) {
1:40a7d3b:         if (value == null || value.length() == 0) {
1:40a7d3b:             return null;
1:40a7d3b:         }
1:40a7d3b:         return value;
1:40a7d3b:     }
1:40a7d3b: 
1:40a7d3b: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:5ebee0a
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 serverSessionPool.close();
1:             } catch (Throwable ignored) {
1:                 LOG.debug("Unexpected error on server session pool close", ignored);
1:             }
commit:e8818fa
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("failed to close c {}", c, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("failed to close cc {}", cc, e);
commit:f42d56c
/////////////////////////////////////////////////////////////////////////
1:             if (!running) {
1:                 return;
1:             }
1:             try {
1:                 workManager.scheduleWork(connectWork, WorkManager.INDEFINITE, null, null);
1:             } catch (WorkException e) {
1:                 running = false;
1:                 LOG.error("Work Manager did not accept work: ", e);
1:             }
commit:519d8f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                             serverSessionPool.closeSessions();
/////////////////////////////////////////////////////////////////////////
1:     // for testing
1:     public void setConnection(ActiveMQConnection activeMQConnection) {
1:         this.connection = activeMQConnection;
1:     }
1: 
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Christian Posta
-------------------------------------------------------------------------------
commit:7bc7178
/////////////////////////////////////////////////////////////////////////
1: import javax.naming.InitialContext;
1: import javax.naming.NamingException;
/////////////////////////////////////////////////////////////////////////
1:         if (activationSpec.isUseJndi()) {
1:             try {
1:                 InitialContext initialContext = new InitialContext();
1:                 dest = (ActiveMQDestination) initialContext.lookup(activationSpec.getDestination());
1:             }
1:             catch (NamingException exc) {
1:                 throw new ResourceException("JNDI lookup failed for "
1:                     + activationSpec.getDestination());
1:             }
1:         else {
1:             if ("javax.jms.Queue".equals(activationSpec.getDestinationType())) {
1:                 dest = new ActiveMQQueue(activationSpec.getDestination());
1:             }
1:             else if ("javax.jms.Topic".equals(activationSpec.getDestinationType())) {
1:                 dest = new ActiveMQTopic(activationSpec.getDestination());
1:             }
1:             else {
1:                 throw new ResourceException("Unknown destination type: "
1:                     + activationSpec.getDestinationType());
1:             }
1:         }
author:Gary Tully
-------------------------------------------------------------------------------
commit:757a2f1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnectionConsumer;
/////////////////////////////////////////////////////////////////////////
1:     private ActiveMQConnectionConsumer consumer;
/////////////////////////////////////////////////////////////////////////
1:                             consumer = (ActiveMQConnectionConsumer) connection.createDurableConnectionConsumer(
/////////////////////////////////////////////////////////////////////////
1:                             consumer = (ActiveMQConnectionConsumer) connection.createConnectionConsumer(
/////////////////////////////////////////////////////////////////////////
1: 
1:                         if (consumer.getConsumerInfo().getCurrentPrefetchSize() == 0) {
1:                             LOG.error("Endpoint " + endpointActivationKey.getActivationSpec() + " will not receive any messages due to broker 'zero prefetch' configuration for: " + dest);
1:                         }
1: 
commit:5b11c0e
/////////////////////////////////////////////////////////////////////////
1:     private final Object shutdownMutex = new String("shutdownMutex");
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:ee2069f
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.Destination;
/////////////////////////////////////////////////////////////////////////
1:                 if (LOG.isInfoEnabled()) {
1:                 while (connecting.get() && running) {
1:                     try {
1:                         connection = adapter.makeConnection(activationSpec);
1:                         connection.setExceptionListener(new ExceptionListener() {
1:                             public void onException(JMSException error) {
1:                                 if (!serverSessionPool.isClosing()) {
1:                                     if (connecting.compareAndSet(false, true)) {
1:                                         synchronized (connectWork) {
1:                                         }
1:                                     }
1:                         });
1:                         if (activationSpec.isDurableSubscription()) {
1:                                     activationSpec.getSubscriptionName(),
1:                                     serverSessionPool,
1:                                     connection.getPrefetchPolicy().getDurableTopicPrefetch(),
1:                         } else {
1:                                     dest,
1:                                     emptyToNull(activationSpec.getMessageSelector()),
1:                                     serverSessionPool,
1:                                     getPrefetch(activationSpec, connection, dest),
1:                                     activationSpec.getNoLocalBooleanValue());
1:                         }
1:                         if (connecting.compareAndSet(true, false)) {
1:                             if (LOG.isInfoEnabled()) {
1:                     } catch (JMSException error) {
1:                         if (LOG.isDebugEnabled()) {
1:                         }
1:                     }
1:                 }
1: 
1:             private int getPrefetch(MessageActivationSpec activationSpec, ActiveMQConnection connection, ActiveMQDestination destination) {
1:                 if (destination.isTopic()) {
1:                     return connection.getPrefetchPolicy().getTopicPrefetch();
1:                 } else if (destination.isQueue()) {
1:                     return connection.getPrefetchPolicy().getQueuePrefetch();
1:                 } else {
1:                     return activationSpec.getMaxMessagesPerSessionsIntValue() * activationSpec.getMaxSessionsIntValue();
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ActiveMQEndpointWorker.class);
commit:2350d8b
/////////////////////////////////////////////////////////////////////////
1:                 return;
1:             running = false;
0:             serverSessionPool.close();
1:         }
author:Robert Davies
-------------------------------------------------------------------------------
commit:e2325f5
/////////////////////////////////////////////////////////////////////////
1:             public void run() {
commit:58e5b9a
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:     protected final ActiveMQEndpointActivationKey endpointActivationKey;
1:     protected final MessageEndpointFactory endpointFactory;
1:     protected final WorkManager workManager;
1:     protected final boolean transacted;
1:     private final ActiveMQDestination dest;
1:     private final Work connectWork;
1:     private final AtomicBoolean connecting = new AtomicBoolean(false);    
0:     private final String shutdownMutex = "shutdownMutex";
1:     
1:     private ActiveMQConnection connection;
1:     protected ActiveMQEndpointWorker(final MessageResourceAdapter adapter, ActiveMQEndpointActivationKey key) throws ResourceException {
/////////////////////////////////////////////////////////////////////////
1:             long currentReconnectDelay = INITIAL_RECONNECT_DELAY;
1:                 currentReconnectDelay = INITIAL_RECONNECT_DELAY;
1:                 MessageActivationSpec activationSpec = endpointActivationKey.getActivationSpec();
0:                 if ( LOG.isInfoEnabled() ) {
1:                     LOG.info("Establishing connection to broker [" + adapter.getInfo().getServerUrl() + "]");
0:                 while ( connecting.get() && running ) {
1:                                     // initiate reconnection only once, i.e. on initial exception
1:                                     // and only if not already trying to connect
1:                                     LOG.error("Connection to broker failed: " + error.getMessage(), error);
1:                                     if ( connecting.compareAndSet(false, true) ) {
1:                                         synchronized ( connectWork ) {
1:                                             disconnect();
0:                                             serverSessionPool.closeIdleSessions();
1:                                             connect();
1:                                     } else {
1:                                         // connection attempt has already been initiated
1:                                         LOG.info("Connection attempt already in progress, ignoring connection exception");
1:                                 }
1:                             }
1:                         connection.start();
0:                         int prefetchSize = activationSpec.getMaxMessagesPerSessionsIntValue() * activationSpec.getMaxSessionsIntValue();
0:                             consumer = connection.createDurableConnectionConsumer(
1:                                     (Topic) dest,
0:                                     activationSpec.getSubscriptionName(), 
1:                                     emptyToNull(activationSpec.getMessageSelector()),
0:                                     serverSessionPool, 
0:                                     prefetchSize,
1:                                     activationSpec.getNoLocalBooleanValue());
0:                             consumer = connection.createConnectionConsumer(
0:                                     dest, 
1:                                     emptyToNull(activationSpec.getMessageSelector()), 
0:                                     serverSessionPool, 
0:                                     prefetchSize,
1: 
0:                         if ( connecting.compareAndSet(true, false) ) {
0:                             if ( LOG.isInfoEnabled() ) {
1:                                 LOG.info("Successfully established connection to broker [" + adapter.getInfo().getServerUrl() + "]");
1:                             }
1:                         } else {
1:                             LOG.error("Could not release connection lock");
1:                         }
0:                         if ( LOG.isDebugEnabled() ) {
1:                             LOG.debug("Failed to connect: " + error.getMessage(), error);
1:                         disconnect();
1:                         pause(error);
1:             }
1:                 }
1:             }
1:             
1:             private void pause(JMSException error) {
1:                 if (currentReconnectDelay == MAX_RECONNECT_DELAY) {
1:                     LOG.error("Failed to connect to broker [" + adapter.getInfo().getServerUrl() + "]: " 
1:                             + error.getMessage(), error);
1:                     LOG.error("Endpoint will try to reconnect to the JMS broker in " + (MAX_RECONNECT_DELAY / 1000) + " seconds");
1:                 }
1:                 try {
1:                     synchronized ( shutdownMutex ) {
1:                         // shutdownMutex will be notified by stop() method in
1:                         // order to accelerate shutdown of endpoint
1:                         shutdownMutex.wait(currentReconnectDelay);
1:                     }
1:                 } catch ( InterruptedException e ) {
1:                     Thread.interrupted();
1:                 }
1:                 currentReconnectDelay *= 2;
1:                 if (currentReconnectDelay > MAX_RECONNECT_DELAY) {
1:                     currentReconnectDelay = MAX_RECONNECT_DELAY;
1:                 }                
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Closing connection to broker");
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Closing ConnectionConsumer");
/////////////////////////////////////////////////////////////////////////
1:     public void start() throws ResourceException {
1:         synchronized (connectWork) {
1:             if (running)
0:             if ( connecting.compareAndSet(false, true) ) {
1:                 LOG.info("Starting");
1:             } else {
1:                 LOG.warn("Ignoring start command, EndpointWorker is already trying to connect");
1:     }
1:         }
1:     public void stop() throws InterruptedException {
1:         synchronized (shutdownMutex) {
1:             if (!running)
1:             LOG.info("Stopping");
1:             // wake up pausing reconnect attempt
1:             shutdownMutex.notifyAll();
1:     }
1:     private void connect() {
1:         synchronized ( connectWork ) {
/////////////////////////////////////////////////////////////////////////
1:     }
1:     private void disconnect() {
1:         synchronized ( connectWork ) {
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQConnection getConnection() {
1:         // make sure we only return a working connection
1:         // in particular make sure that we do not return null
1:         // after the resource adapter got disconnected from
1:         // the broker via the disconnect() method
0:         synchronized ( connectWork ) {
1:             return connection;
1:         }
1:     }
1: 
commit:d8bdbe7
/////////////////////////////////////////////////////////////////////////
0:     synchronized private void reconnect(JMSException error){
0:         if(!serverSessionPool.isClosing()){
0:             log.debug("Reconnect cause: ",error);
0:             // Only log errors if the server is really down.. And not a temp failure.
0:             if(reconnectDelay==MAX_RECONNECT_DELAY){
0:                 log.info("Endpoint connection to JMS broker failed: "+error.getMessage());
0:                 log.info("Endpoint will try to reconnect to the JMS broker in "+(MAX_RECONNECT_DELAY/1000)+" seconds");
1:             }
0:             try{
1:                 disconnect();
0:                 Thread.sleep(reconnectDelay);
0:                 // Use exponential rollback.
0:                 reconnectDelay*=2;
0:                 if(reconnectDelay>MAX_RECONNECT_DELAY)
0:                     reconnectDelay=MAX_RECONNECT_DELAY;
1:                 connect();
0:             }catch(InterruptedException e){}
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  *  $Date$
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
0:     private static final Log LOG = LogFactory.getLog(ActiveMQEndpointWorker.class);
1:     private static final long MAX_RECONNECT_DELAY = 1000 * 30; // 30 seconds.
1:     private static final ThreadLocal<Session> THREAD_LOCAL = new ThreadLocal<Session>();
1: 
1:             ON_MESSAGE_METHOD = MessageListener.class.getMethod("onMessage", new Class[] {
1:                 Message.class
1:             });
1:         } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQConnection connection;
1: 
0:     private long reconnectDelay = INITIAL_RECONNECT_DELAY;
/////////////////////////////////////////////////////////////////////////
1:         } catch (NoSuchMethodException e) {
1: 
1:                 //
0:             public synchronized void run() {
0:                 if (!isRunning()) {
1:                 }
0:                 if (connection != null) {
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         consumer = connection.createDurableConnectionConsumer((Topic)dest, activationSpec.getSubscriptionName(), emptyToNull(activationSpec.getMessageSelector()), serverSessionPool,
0:                                                                               activationSpec.getMaxMessagesPerSessionsIntValue(), activationSpec.getNoLocalBooleanValue());
0:                         consumer = connection.createConnectionConsumer(dest, emptyToNull(activationSpec.getMessageSelector()), serverSessionPool, activationSpec.getMaxMessagesPerSessionsIntValue(),
0:                                                                        activationSpec.getNoLocalBooleanValue());
0:                     LOG.debug("Fail to to connect: " + error, error);
/////////////////////////////////////////////////////////////////////////
0:      * @param s
0:     public static void safeClose(Session s) {
1:         try {
0:             if (s != null) {
0:                 s.close();
1:             }
1:         } catch (JMSException e) {
0:             //
1:         }
1:     }
1:     /**
1:      * @param c
1:      */
1:     public static void safeClose(Connection c) {
1:         try {
1:             if (c != null) {
1:                 c.close();
1:             }
1:         } catch (JMSException e) {
0:             //
1:         }
1:     }
1: 
1:     /**
1:      * @param cc
1:      */
1:     public static void safeClose(ConnectionConsumer cc) {
1:         try {
1:             if (cc != null) {
1:                 cc.close();
1:             }
1:         } catch (JMSException e) {
0:             //
1:         }
0:     public synchronized void start() throws WorkException, ResourceException {
0:         if (running) {
1:         }
1:         running = true;
1: 
0:         LOG.debug("Starting");
1:         serverSessionPool = new ServerSessionPoolImpl(this, endpointActivationKey.getActivationSpec().getMaxSessionsIntValue());
0:         connect();
0:         LOG.debug("Started");
1:     }
1: 
1:     /**
1:      * 
1:      */
0:     public synchronized void stop() throws InterruptedException {
0:         if (!running) {
1:             return;
1:         }
0:         disconnect();
1:     }
0:     private synchronized void connect() {
0:         if (!running) {
1:         }
0:             LOG.error("Work Manager did not accept work: ", e);
0:     private synchronized void disconnect() {
1:         consumer = null;
1:         connection = null;
0:     private void reconnect(JMSException error) {
0:         LOG.debug("Reconnect cause: ", error);
0:         synchronized (this) {
0:             // Only log errors if the server is really down.. And not a temp
0:             // failure.
0:                 LOG.error("Endpoint connection to JMS broker failed: " + error.getMessage());
0:                 LOG.error("Endpoint will try to reconnect to the JMS broker in " + (MAX_RECONNECT_DELAY / 1000) + " seconds");
1: 
0:             synchronized (this) {
0:                 this.reconnectDelay *= 2;
0:                 if (this.reconnectDelay > MAX_RECONNECT_DELAY) {
0:                     this.reconnectDelay = MAX_RECONNECT_DELAY;
1:                 }
0:         } catch (InterruptedException e) {
0:             //
1:         THREAD_LOCAL.set(session);
1:         THREAD_LOCAL.set(null);
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     private static final ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:97f2ca1
/////////////////////////////////////////////////////////////////////////
0:     private void reconnect(JMSException error){
0:         long reconnectDelay;
0:         synchronized(this) {
0:             reconnectDelay = this.reconnectDelay;
0:             // Only log errors if the server is really down.. And not a temp failure.
0:             if (reconnectDelay == MAX_RECONNECT_DELAY) {
0:                 log.info("Endpoint connection to JMS broker failed: " + error.getMessage());
0:                 log.info("Endpoint will try to reconnect to the JMS broker in "+(MAX_RECONNECT_DELAY/1000)+" seconds");
1:             }
1:             
0:             synchronized(this) {
0:                 // Use exponential rollback.
0:                 this.reconnectDelay*=2;
0:                 if (this.reconnectDelay > MAX_RECONNECT_DELAY)
0:                     this.reconnectDelay=MAX_RECONNECT_DELAY;
1:             }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:fd4bb60
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.ra;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ActiveMQTopic;
author:James Strachan
-------------------------------------------------------------------------------
commit:d7355e7
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * 
1:      */
/////////////////////////////////////////////////////////////////////////
0:     protected MessageResourceAdapter adapter;
/////////////////////////////////////////////////////////////////////////
0:         	//
/////////////////////////////////////////////////////////////////////////
0:         	//
/////////////////////////////////////////////////////////////////////////
0:         	//
1:     /**
1:      * 
1:      */
0:     public ActiveMQEndpointWorker(final MessageResourceAdapter adapter, ActiveMQEndpointActivationKey key) throws ResourceException {
/////////////////////////////////////////////////////////////////////////
0:             	//
/////////////////////////////////////////////////////////////////////////
1:                 MessageActivationSpec activationSpec = endpointActivationKey.getActivationSpec();
/////////////////////////////////////////////////////////////////////////
0:         MessageActivationSpec activationSpec = endpointActivationKey.getActivationSpec();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * 
1:      */
/////////////////////////////////////////////////////////////////////////
0:         } catch(InterruptedException e) {
0:         	//
1:         }
commit:2b6f637
/////////////////////////////////////////////////////////////////////////
0:                 log.error("Endpoint connection to JMS broker failed: " + error.getMessage());
0:                 log.error("Endpoint will try to reconnect to the JMS broker in "+(MAX_RECONNECT_DELAY/1000)+" seconds");
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 Hiram Chirino
0:  * Copyright 2005 LogicBlaze Inc.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  *
0:  **/
0: package org.activemq.ra;
1: 
1: import java.lang.reflect.Method;
1: 
1: import javax.jms.Connection;
1: import javax.jms.ConnectionConsumer;
1: import javax.jms.ExceptionListener;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageListener;
1: import javax.jms.Session;
1: import javax.jms.Topic;
1: import javax.resource.ResourceException;
1: import javax.resource.spi.endpoint.MessageEndpointFactory;
1: import javax.resource.spi.work.Work;
1: import javax.resource.spi.work.WorkException;
1: import javax.resource.spi.work.WorkManager;
1: 
0: import org.activemq.ActiveMQConnection;
0: import org.activemq.command.ActiveMQDestination;
0: import org.activemq.command.ActiveMQQueue;
0: import org.activemq.command.ActiveMQTopic;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
0:  * @version $Revision$ $Date$
1:  */
1: public class ActiveMQEndpointWorker {
1: 
0:     private static final Log log = LogFactory.getLog(ActiveMQEndpointWorker.class);
1:     public static final Method ON_MESSAGE_METHOD;
1: 
1:     private static final long INITIAL_RECONNECT_DELAY = 1000; // 1 second.
0:     private static final long MAX_RECONNECT_DELAY = 1000*30; // 30 seconds.
0:     private static final ThreadLocal threadLocal = new ThreadLocal();
1:     
1:     static {
1:         try {
0:             ON_MESSAGE_METHOD = MessageListener.class.getMethod("onMessage", new Class[]{Message.class});
1:         }
0:         catch (Exception e) {
1:             throw new ExceptionInInitializerError(e);
1:         }
1:     }
1: 
0:     protected ActiveMQResourceAdapter adapter;
0:     protected ActiveMQEndpointActivationKey endpointActivationKey;
0:     protected MessageEndpointFactory endpointFactory;
0:     protected WorkManager workManager;
0:     protected boolean transacted;
1:     
1:     
0:     private ConnectionConsumer consumer;
1:     private ServerSessionPoolImpl serverSessionPool;
0:     private ActiveMQDestination dest;
1:     private boolean running;
0:     private Work connectWork;
0:     protected ActiveMQConnection connection;
1:     
0:     private long reconnectDelay=INITIAL_RECONNECT_DELAY;
1: 
1: 
1:     /**
0:      * @param s
1:      */
0:     public static void safeClose(Session s) {
1:         try {
0:             if (s != null) {
0:                 s.close();
1:             }
1:         }
0:         catch (JMSException e) {
1:         }
1:     }
1: 
1:     /**
0:      * @param c
1:      */
0:     public static void safeClose(Connection c) {
1:         try {
0:             if (c != null) {
0:                 c.close();
1:             }
1:         }
0:         catch (JMSException e) {
1:         }
1:     }
1: 
1:     /**
0:      * @param cc
1:      */
0:     public static void safeClose(ConnectionConsumer cc) {
1:         try {
0:             if (cc != null) {
0:                 cc.close();
1:             }
1:         }
0:         catch (JMSException e) {
1:         }
1:     }
1: 
0:     public ActiveMQEndpointWorker(final ActiveMQResourceAdapter adapter, ActiveMQEndpointActivationKey key) throws ResourceException {
1:         this.endpointActivationKey = key;
0:         this.adapter = adapter;
1:         this.endpointFactory = endpointActivationKey.getMessageEndpointFactory();
1:         this.workManager = adapter.getBootstrapContext().getWorkManager();
1:         try {
1:             this.transacted = endpointFactory.isDeliveryTransacted(ON_MESSAGE_METHOD);
1:         }
0:         catch (NoSuchMethodException e) {
1:             throw new ResourceException("Endpoint does not implement the onMessage method.");
1:         }
1:         
1:         connectWork = new Work() {
1: 
1:             public void release() {
1:             }
1: 
0:             synchronized public void run() {
0:                 if( !isRunning() )
0:                     return;
0:                 if( connection!=null )
0:                     return;
1:                 
0:                 ActiveMQActivationSpec activationSpec = endpointActivationKey.getActivationSpec();
1:                 try {
0:                     connection = adapter.makeConnection(activationSpec);
0:                     connection.start();
0:                     connection.setExceptionListener(new ExceptionListener() {
0:                         public void onException(JMSException error) {
0:                             reconnect(error);
1:                         }
0:                     });
1: 
0:                     if (activationSpec.isDurableSubscription()) {
0:                         consumer = connection.createDurableConnectionConsumer(
0:                                 (Topic) dest,
0:                                 activationSpec.getSubscriptionName(), 
0:                                 emptyToNull(activationSpec.getMessageSelector()),
0:                                 serverSessionPool, 
0:                                 activationSpec.getMaxMessagesPerSessionsIntValue(),
0:                                 activationSpec.getNoLocalBooleanValue());
0:                     } else {
0:                         consumer = connection.createConnectionConsumer(
0:                                 dest, 
0:                                 emptyToNull(activationSpec.getMessageSelector()), 
0:                                 serverSessionPool, 
0:                                 activationSpec.getMaxMessagesPerSessionsIntValue(),
0:                                 activationSpec.getNoLocalBooleanValue());
1:                     }
1: 
0:                 } catch (JMSException error) {
0:                     log.debug("Fail to to connect: "+error, error);
0:                     reconnect(error);
1:                 }
1:             }
1:         };
1: 
0:         ActiveMQActivationSpec activationSpec = endpointActivationKey.getActivationSpec();
0:         if ("javax.jms.Queue".equals(activationSpec.getDestinationType())) {
0:             dest = new ActiveMQQueue(activationSpec.getDestination());
0:         } else if ("javax.jms.Topic".equals(activationSpec.getDestinationType())) {
0:             dest = new ActiveMQTopic(activationSpec.getDestination());
0:         } else {
0:             throw new ResourceException("Unknown destination type: " + activationSpec.getDestinationType());
1:         }
1: 
1:     }
1: 
0:     synchronized public void start() throws WorkException, ResourceException {
0:         if (running)
0:             return;
0:         running = true;
1: 
0:         log.debug("Starting");
0:         serverSessionPool = new ServerSessionPoolImpl(this, endpointActivationKey.getActivationSpec().getMaxSessionsIntValue());
0:         connect();
0:         log.debug("Started");
1:     }
1: 
1:     /**
1:      * 
1:      */
0:     synchronized public void stop() throws InterruptedException {
0:         if (!running)
0:             return;
0:         running = false;
0:         serverSessionPool.close();
0:         disconnect();        
1:     }
1: 
1:     private boolean isRunning() {
1:         return running;
1:     }    
1: 
0:     synchronized private void connect() {
0:         if (!running)
0:             return;
1: 
1:         try {
0:             workManager.scheduleWork(connectWork, WorkManager.INDEFINITE, null, null);
0:         } catch (WorkException e) {
0:             running = false;
0:             log.error("Work Manager did not accept work: ",e);
1:         }
1:     }
1: 
1:     /**
1:      * 
1:      */
0:     synchronized private void disconnect() {
1:         safeClose(consumer);
0:         consumer=null;
1:         safeClose(connection);
0:         connection=null;
1:     }
1: 
0:     synchronized private void reconnect(JMSException error) {
0:         log.debug("Reconnect cause: ", error);
0:         // Only log errors if the server is really down..  And not a temp failure. 
0:         if( reconnectDelay == MAX_RECONNECT_DELAY ) {
0:             log.info("Endpoint connection to JMS broker failed: "+error.getMessage());
0:             log.info("Endpoint will try to reconnect to the JMS broker in "+(MAX_RECONNECT_DELAY/1000)+" seconds");
1:         }
1:         try {
0:             disconnect();
0:             Thread.sleep(reconnectDelay);
1:             
0:             // Use exponential rollback.
0:             reconnectDelay*=2;
0:             if( reconnectDelay > MAX_RECONNECT_DELAY )
0:                 reconnectDelay = MAX_RECONNECT_DELAY;
1:             
0:             connect();
0:         } catch (InterruptedException e) {
1:         }
1:     }
1: 
1:     protected void registerThreadSession(Session session) {
0:         threadLocal.set(session);
1:     }
1: 
1:     protected void unregisterThreadSession(Session session) {
0:         threadLocal.set(null);
1:     }
1: 
1:     private String emptyToNull(String value) {
1:         if (value == null || value.length() == 0) {
1:             return null;
1:         }
1:         return value;
1:     }
1: 
1: }
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:d1b05c4
/////////////////////////////////////////////////////////////////////////
0:                             if (!serverSessionPool.isClosing()) {
0:                                 reconnect(error);
0:                             }
/////////////////////////////////////////////////////////////////////////
0:         log.debug("Reconnect cause: ",error);
0:         // Only log errors if the server is really down.. And not a temp failure.
0:         if (reconnectDelay == MAX_RECONNECT_DELAY) {
0:             log.info("Endpoint connection to JMS broker failed: " + error.getMessage());
0:             log.info("Endpoint will try to reconnect to the JMS broker in "+(MAX_RECONNECT_DELAY/1000)+" seconds");
0:         try {
0:             disconnect();
0:             Thread.sleep(reconnectDelay);
0:             // Use exponential rollback.
0:             reconnectDelay*=2;
0:             if (reconnectDelay > MAX_RECONNECT_DELAY)
0:                 reconnectDelay=MAX_RECONNECT_DELAY;
0:             connect();
0:         } catch(InterruptedException e) {}
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:92a698f
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2004 The Apache Software Foundation
/////////////////////////////////////////////////////////////////////////
0:  */
============================================================================