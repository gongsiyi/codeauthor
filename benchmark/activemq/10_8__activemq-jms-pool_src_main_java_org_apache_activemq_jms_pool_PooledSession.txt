1:5886b66: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:5886b66:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:bfd1be5:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:5886b66:  */
1:b66559e: package org.apache.activemq.jms.pool;
1:74a7a8b: 
1:0bba311: import java.io.Serializable;
1:0bba311: import java.util.Iterator;
1:74a7a8b: import java.util.concurrent.CopyOnWriteArrayList;
1:f395c70: import java.util.concurrent.atomic.AtomicBoolean;
1:c60ac2f: 
1:d29ca2a: import javax.jms.BytesMessage;
1:d29ca2a: import javax.jms.Destination;
1:d29ca2a: import javax.jms.JMSException;
1:d29ca2a: import javax.jms.MapMessage;
1:d29ca2a: import javax.jms.Message;
1:d29ca2a: import javax.jms.MessageConsumer;
1:d29ca2a: import javax.jms.MessageListener;
1:d29ca2a: import javax.jms.MessageProducer;
1:d29ca2a: import javax.jms.ObjectMessage;
1:d29ca2a: import javax.jms.Queue;
1:d29ca2a: import javax.jms.QueueBrowser;
1:d29ca2a: import javax.jms.QueueReceiver;
1:d29ca2a: import javax.jms.QueueSender;
1:d29ca2a: import javax.jms.QueueSession;
1:6687d56: import javax.jms.Session;
1:d29ca2a: import javax.jms.StreamMessage;
1:d29ca2a: import javax.jms.TemporaryQueue;
1:d29ca2a: import javax.jms.TemporaryTopic;
1:d29ca2a: import javax.jms.TextMessage;
1:d29ca2a: import javax.jms.Topic;
1:d29ca2a: import javax.jms.TopicPublisher;
1:d29ca2a: import javax.jms.TopicSession;
1:d29ca2a: import javax.jms.TopicSubscriber;
1:9a1f9c2: import javax.jms.XASession;
1:9a1f9c2: import javax.transaction.xa.XAResource;
1:0bba311: 
1:6d6ed4e: import org.apache.commons.pool2.KeyedObjectPool;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:c60ac2f: 
1:9a1f9c2: public class PooledSession implements Session, TopicSession, QueueSession, XASession {
1:8bf987b:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledSession.class);
1:a59c9ba: 
1:a59c9ba:     private final SessionKey key;
1:f91abd3:     private final KeyedObjectPool<SessionKey, SessionHolder> sessionPool;
1:a59c9ba:     private final CopyOnWriteArrayList<MessageConsumer> consumers = new CopyOnWriteArrayList<MessageConsumer>();
1:a59c9ba:     private final CopyOnWriteArrayList<QueueBrowser> browsers = new CopyOnWriteArrayList<QueueBrowser>();
1:2a7c349:     private final CopyOnWriteArrayList<PooledSessionEventListener> sessionEventListeners = new CopyOnWriteArrayList<PooledSessionEventListener>();
1:f395c70:     private final AtomicBoolean closed = new AtomicBoolean();
1:2a7c349: 
1:f91abd3:     private SessionHolder sessionHolder;
1:d29ca2a:     private boolean transactional = true;
1:933eb2f:     private boolean ignoreClose;
1:628a0cd:     private boolean isXa;
1:2a7c349:     private boolean useAnonymousProducers = true;
1:74a7a8b: 
1:f91abd3:     public PooledSession(SessionKey key, SessionHolder sessionHolder, KeyedObjectPool<SessionKey, SessionHolder> sessionPool, boolean transactional, boolean anonymous) {
1:a59c9ba:         this.key = key;
1:f91abd3:         this.sessionHolder = sessionHolder;
1:d29ca2a:         this.sessionPool = sessionPool;
1:b66559e:         this.transactional = transactional;
1:2a7c349:         this.useAnonymousProducers = anonymous;
1:6687d56:     }
1:628a0cd: 
1:49f16ce:     public void addSessionEventListener(PooledSessionEventListener listener) {
1:b496c0a:         // only add if really needed
1:49f16ce:         if (!sessionEventListeners.contains(listener)) {
1:49f16ce:             this.sessionEventListeners.add(listener);
1:2a7c349:         }
1:b496c0a:     }
1:6687d56: 
1:8704012:     protected boolean isIgnoreClose() {
1:8704012:         return ignoreClose;
1:c60ac2f:     }
1:5886b66: 
1:8704012:     protected void setIgnoreClose(boolean ignoreClose) {
1:8704012:         this.ignoreClose = ignoreClose;
11:d29ca2a:     }
1:74a7a8b: 
1:a59c9ba:     @Override
1:d29ca2a:     public void close() throws JMSException {
1:f395c70:         if (ignoreClose) {
1:f395c70:             return;
1:f395c70:         }
1:f395c70: 
1:f395c70:         if (closed.compareAndSet(false, true)) {
1:101e711:             boolean invalidate = false;
1:101e711:             try {
1:101e711:                 // lets reset the session
1:101e711:                 getInternalSession().setMessageListener(null);
1:74a7a8b: 
1:101e711:                 // Close any consumers and browsers that may have been created.
1:101e711:                 for (Iterator<MessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:101e711:                     MessageConsumer consumer = iter.next();
1:101e711:                     consumer.close();
1:101e711:                 }
1:101e711: 
1:101e711:                 for (Iterator<QueueBrowser> iter = browsers.iterator(); iter.hasNext();) {
1:101e711:                     QueueBrowser browser = iter.next();
1:101e711:                     browser.close();
1:101e711:                 }
1:101e711: 
1:101e711:                 if (transactional && !isXa) {
1:101e711:                     try {
1:101e711:                         getInternalSession().rollback();
1:101e711:                     } catch (JMSException e) {
1:101e711:                         invalidate = true;
1:101e711:                         LOG.warn("Caught exception trying rollback() when putting session back into the pool, will invalidate. " + e, e);
1:101e711:                     }
1:101e711:                 }
1:101e711:             } catch (JMSException ex) {
1:101e711:                 invalidate = true;
1:101e711:                 LOG.warn("Caught exception trying close() when putting session back into the pool, will invalidate. " + ex, ex);
1:101e711:             } finally {
1:101e711:                 consumers.clear();
1:101e711:                 browsers.clear();
1:49f16ce:                 for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:49f16ce:                     listener.onSessionClosed(this);
1:49f16ce:                 }
1:49f16ce:                 sessionEventListeners.clear();
1:c60ac2f:             }
1:6687d56: 
1:101e711:             if (invalidate) {
1:a59c9ba:                 // lets close the session and not put the session back into the pool
1:a59c9ba:                 // instead invalidate it so the pool can create a new one on demand.
1:f91abd3:                 if (sessionHolder != null) {
1:a59c9ba:                     try {
1:f91abd3:                         sessionHolder.close();
1:74a7a8b:                     } catch (JMSException e1) {
1:101e711:                         LOG.trace("Ignoring exception on close as discarding session: " + e1, e1);
1:c60ac2f:                     }
1:d29ca2a:                 }
2:d29ca2a:                 try {
1:f91abd3:                     sessionPool.invalidateObject(key, sessionHolder);
1:a59c9ba:                 } catch (Exception e) {
1:059fd2f:                     LOG.trace("Ignoring exception on invalidateObject as discarding session: " + e, e);
1:a59c9ba:                 }
1:101e711:             } else {
1:a59c9ba:                 try {
1:f91abd3:                     sessionPool.returnObject(key, sessionHolder);
1:a59c9ba:                 } catch (Exception e) {
1:b66559e:                     javax.jms.IllegalStateException illegalStateException = new javax.jms.IllegalStateException(e.toString());
1:b66559e:                     illegalStateException.initCause(e);
1:b66559e:                     throw illegalStateException;
1:a59c9ba:                 }
1:d29ca2a:             }
1:f395c70: 
1:f91abd3:             sessionHolder = null;
1:d29ca2a:         }
1:d29ca2a:     }
1:74a7a8b: 
1:a59c9ba:     @Override
1:d29ca2a:     public void commit() throws JMSException {
1:9a1f9c2:         getInternalSession().commit();
1:d29ca2a:     }
1:74a7a8b: 
1:a59c9ba:     @Override
1:d29ca2a:     public BytesMessage createBytesMessage() throws JMSException {
1:9a1f9c2:         return getInternalSession().createBytesMessage();
1:d29ca2a:     }
1:74a7a8b: 
1:a59c9ba:     @Override
1:d29ca2a:     public MapMessage createMapMessage() throws JMSException {
1:9a1f9c2:         return getInternalSession().createMapMessage();
1:d29ca2a:     }
1:c60ac2f: 
1:a59c9ba:     @Override
1:d29ca2a:     public Message createMessage() throws JMSException {
1:9a1f9c2:         return getInternalSession().createMessage();
1:d29ca2a:     }
1:c60ac2f: 
1:a59c9ba:     @Override
1:d29ca2a:     public ObjectMessage createObjectMessage() throws JMSException {
1:9a1f9c2:         return getInternalSession().createObjectMessage();
1:d29ca2a:     }
22:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public ObjectMessage createObjectMessage(Serializable serializable) throws JMSException {
1:9a1f9c2:         return getInternalSession().createObjectMessage(serializable);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public Queue createQueue(String s) throws JMSException {
1:9a1f9c2:         return getInternalSession().createQueue(s);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public StreamMessage createStreamMessage() throws JMSException {
1:9a1f9c2:         return getInternalSession().createStreamMessage();
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TemporaryQueue createTemporaryQueue() throws JMSException {
1:6687d56:         TemporaryQueue result;
1:6687d56: 
1:6687d56:         result = getInternalSession().createTemporaryQueue();
1:6687d56: 
1:6687d56:         // Notify all of the listeners of the created temporary Queue.
1:49f16ce:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:6687d56:             listener.onTemporaryQueueCreate(result);
1:6687d56:         }
1:6687d56: 
1:6687d56:         return result;
1:2a7c349:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TemporaryTopic createTemporaryTopic() throws JMSException {
1:6687d56:         TemporaryTopic result;
1:6687d56: 
1:6687d56:         result = getInternalSession().createTemporaryTopic();
1:6687d56: 
1:6687d56:         // Notify all of the listeners of the created temporary Topic.
1:49f16ce:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:6687d56:             listener.onTemporaryTopicCreate(result);
1:2a7c349:         }
1:6687d56: 
1:6687d56:         return result;
1:6687d56:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public void unsubscribe(String s) throws JMSException {
1:9a1f9c2:         getInternalSession().unsubscribe(s);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TextMessage createTextMessage() throws JMSException {
1:9a1f9c2:         return getInternalSession().createTextMessage();
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TextMessage createTextMessage(String s) throws JMSException {
1:9a1f9c2:         return getInternalSession().createTextMessage(s);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public Topic createTopic(String s) throws JMSException {
1:9a1f9c2:         return getInternalSession().createTopic(s);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public int getAcknowledgeMode() throws JMSException {
1:9a1f9c2:         return getInternalSession().getAcknowledgeMode();
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public boolean getTransacted() throws JMSException {
1:9a1f9c2:         return getInternalSession().getTransacted();
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public void recover() throws JMSException {
1:9a1f9c2:         getInternalSession().recover();
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public void rollback() throws JMSException {
1:9a1f9c2:         getInternalSession().rollback();
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:9a1f9c2:     public XAResource getXAResource() {
1:f91abd3:         SessionHolder session = safeGetSessionHolder();
1:f91abd3: 
1:f91abd3:         if (session.getSession() instanceof XASession) {
1:f91abd3:             return ((XASession) session.getSession()).getXAResource();
1:d29ca2a:         }
1:f91abd3: 
1:b66559e:         return null;
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:9a1f9c2:     public Session getSession() {
1:9a1f9c2:         return this;
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public void run() {
1:f91abd3:         SessionHolder session = safeGetSessionHolder();
1:101e711:         if (session != null) {
1:f91abd3:             session.getSession().run();
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // Consumer related methods
1:74a7a8b:     // -------------------------------------------------------------------------
1:a59c9ba:     @Override
1:d29ca2a:     public QueueBrowser createBrowser(Queue queue) throws JMSException {
1:9a1f9c2:         return addQueueBrowser(getInternalSession().createBrowser(queue));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public QueueBrowser createBrowser(Queue queue, String selector) throws JMSException {
1:9a1f9c2:         return addQueueBrowser(getInternalSession().createBrowser(queue, selector));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public MessageConsumer createConsumer(Destination destination) throws JMSException {
1:9a1f9c2:         return addConsumer(getInternalSession().createConsumer(destination));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public MessageConsumer createConsumer(Destination destination, String selector) throws JMSException {
1:9a1f9c2:         return addConsumer(getInternalSession().createConsumer(destination, selector));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public MessageConsumer createConsumer(Destination destination, String selector, boolean noLocal) throws JMSException {
1:9a1f9c2:         return addConsumer(getInternalSession().createConsumer(destination, selector, noLocal));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TopicSubscriber createDurableSubscriber(Topic topic, String selector) throws JMSException {
1:9a1f9c2:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, selector));
1:d29ca2a:     }
1:c60ac2f: 
1:a59c9ba:     @Override
1:d29ca2a:     public TopicSubscriber createDurableSubscriber(Topic topic, String name, String selector, boolean noLocal) throws JMSException {
1:9a1f9c2:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, name, selector, noLocal));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public MessageListener getMessageListener() throws JMSException {
1:9a1f9c2:         return getInternalSession().getMessageListener();
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public void setMessageListener(MessageListener messageListener) throws JMSException {
1:9a1f9c2:         getInternalSession().setMessageListener(messageListener);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TopicSubscriber createSubscriber(Topic topic) throws JMSException {
1:2a7c349:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TopicSubscriber createSubscriber(Topic topic, String selector, boolean local) throws JMSException {
1:2a7c349:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic, selector, local));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public QueueReceiver createReceiver(Queue queue) throws JMSException {
1:2a7c349:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue));
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public QueueReceiver createReceiver(Queue queue, String selector) throws JMSException {
1:2a7c349:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue, selector));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     // Producer related methods
1:74a7a8b:     // -------------------------------------------------------------------------
1:a59c9ba:     @Override
1:d29ca2a:     public MessageProducer createProducer(Destination destination) throws JMSException {
1:2a7c349:         return new PooledProducer(getMessageProducer(destination), destination);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public QueueSender createSender(Queue queue) throws JMSException {
1:2a7c349:         return new PooledQueueSender(getQueueSender(queue), queue);
1:d29ca2a:     }
1:d29ca2a: 
1:a59c9ba:     @Override
1:d29ca2a:     public TopicPublisher createPublisher(Topic topic) throws JMSException {
1:2a7c349:         return new PooledTopicPublisher(getTopicPublisher(topic), topic);
1:d29ca2a:     }
1:d29ca2a: 
1:b66559e:     public Session getInternalSession() throws IllegalStateException {
1:f91abd3:         return safeGetSessionHolder().getSession();
1:d29ca2a:     }
1:d29ca2a: 
1:b66559e:     public MessageProducer getMessageProducer() throws JMSException {
1:2a7c349:         return getMessageProducer(null);
1:2a7c349:     }
1:2a7c349: 
1:2a7c349:     public MessageProducer getMessageProducer(Destination destination) throws JMSException {
1:2a7c349:         MessageProducer result = null;
1:2a7c349: 
1:2a7c349:         if (useAnonymousProducers) {
1:f91abd3:             result = safeGetSessionHolder().getOrCreateProducer();
1:2a7c349:         } else {
1:2a7c349:             result = getInternalSession().createProducer(destination);
1:2a7c349:         }
1:2a7c349: 
1:2a7c349:         return result;
1:2a7c349:     }
1:2a7c349: 
1:b66559e:     public QueueSender getQueueSender() throws JMSException {
1:2a7c349:         return getQueueSender(null);
1:2a7c349:     }
1:2a7c349: 
1:2a7c349:     public QueueSender getQueueSender(Queue destination) throws JMSException {
1:2a7c349:         QueueSender result = null;
1:2a7c349: 
1:2a7c349:         if (useAnonymousProducers) {
1:f91abd3:             result = safeGetSessionHolder().getOrCreateSender();
1:2a7c349:         } else {
1:2a7c349:             result = ((QueueSession) getInternalSession()).createSender(destination);
1:2a7c349:         }
1:2a7c349: 
1:2a7c349:         return result;
1:2a7c349:     }
1:2a7c349: 
1:b66559e:     public TopicPublisher getTopicPublisher() throws JMSException {
1:2a7c349:         return getTopicPublisher(null);
1:2a7c349:     }
1:2a7c349: 
1:2a7c349:     public TopicPublisher getTopicPublisher(Topic destination) throws JMSException {
1:2a7c349:         TopicPublisher result = null;
1:2a7c349: 
1:2a7c349:         if (useAnonymousProducers) {
1:f91abd3:             result = safeGetSessionHolder().getOrCreatePublisher();
1:2a7c349:         } else {
1:2a7c349:             result = ((TopicSession) getInternalSession()).createPublisher(destination);
1:2a7c349:         }
1:2a7c349: 
1:2a7c349:         return result;
1:2a7c349:     }
1:2a7c349: 
1:c60ac2f:     private QueueBrowser addQueueBrowser(QueueBrowser browser) {
1:c60ac2f:         browsers.add(browser);
1:c60ac2f:         return browser;
1:c60ac2f:     }
1:74a7a8b: 
1:c60ac2f:     private MessageConsumer addConsumer(MessageConsumer consumer) {
1:c60ac2f:         consumers.add(consumer);
1:2a7c349:         // must wrap in PooledMessageConsumer to ensure the onConsumerClose
1:2a7c349:         // method is invoked when the returned consumer is closed, to avoid memory
1:2a7c349:         // leak in this session class in case many consumers is created
1:5886b66:         return new PooledMessageConsumer(this, consumer);
1:74a7a8b:     }
1:74a7a8b: 
1:c60ac2f:     private TopicSubscriber addTopicSubscriber(TopicSubscriber subscriber) {
1:c60ac2f:         consumers.add(subscriber);
1:c60ac2f:         return subscriber;
1:c60ac2f:     }
1:74a7a8b: 
1:c60ac2f:     private QueueReceiver addQueueReceiver(QueueReceiver receiver) {
1:c60ac2f:         consumers.add(receiver);
1:c60ac2f:         return receiver;
1:c60ac2f:     }
1:c60ac2f: 
1:628a0cd:     public void setIsXa(boolean isXa) {
1:628a0cd:         this.isXa = isXa;
1:5886b66:     }
1:5886b66: 
1:a59c9ba:     @Override
1:5886b66:     public String toString() {
1:f91abd3:         return "PooledSession { " + safeGetSessionHolder() + " }";
1:628a0cd:     }
1:2a7c349: 
1:2a7c349:     /**
1:2a7c349:      * Callback invoked when the consumer is closed.
1:2a7c349:      * <p/>
1:2a7c349:      * This is used to keep track of an explicit closed consumer created by this
1:2a7c349:      * session, by which we know do not need to keep track of the consumer, as
1:2a7c349:      * its already closed.
1:2a7c349:      *
1:2a7c349:      * @param consumer
1:2a7c349:      *            the consumer which is being closed
1:2a7c349:      */
1:2a7c349:     protected void onConsumerClose(MessageConsumer consumer) {
1:2a7c349:         consumers.remove(consumer);
1:2a7c349:     }
1:f91abd3: 
1:f91abd3:     private SessionHolder safeGetSessionHolder() {
1:f91abd3:         SessionHolder sessionHolder = this.sessionHolder;
1:f91abd3:         if (sessionHolder == null) {
1:f91abd3:             throw new IllegalStateException("The session has already been closed");
1:f91abd3:         }
1:f91abd3: 
1:f91abd3:         return sessionHolder;
1:f91abd3:     }
1:5886b66: }
============================================================================
author:Jeff Genender
-------------------------------------------------------------------------------
commit:6d6ed4e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.commons.pool2.KeyedObjectPool;
author:Timothy Bish
-------------------------------------------------------------------------------
commit:f91abd3
/////////////////////////////////////////////////////////////////////////
1:     private final KeyedObjectPool<SessionKey, SessionHolder> sessionPool;
1:     private SessionHolder sessionHolder;
1:     public PooledSession(SessionKey key, SessionHolder sessionHolder, KeyedObjectPool<SessionKey, SessionHolder> sessionPool, boolean transactional, boolean anonymous) {
1:         this.sessionHolder = sessionHolder;
/////////////////////////////////////////////////////////////////////////
1:                 if (sessionHolder != null) {
1:                         sessionHolder.close();
1:                     sessionPool.invalidateObject(key, sessionHolder);
1:                     sessionPool.returnObject(key, sessionHolder);
/////////////////////////////////////////////////////////////////////////
1:             sessionHolder = null;
/////////////////////////////////////////////////////////////////////////
1:         SessionHolder session = safeGetSessionHolder();
1: 
1:         if (session.getSession() instanceof XASession) {
1:             return ((XASession) session.getSession()).getXAResource();
1: 
/////////////////////////////////////////////////////////////////////////
1:         SessionHolder session = safeGetSessionHolder();
1:             session.getSession().run();
/////////////////////////////////////////////////////////////////////////
1:         return safeGetSessionHolder().getSession();
/////////////////////////////////////////////////////////////////////////
1:             result = safeGetSessionHolder().getOrCreateProducer();
/////////////////////////////////////////////////////////////////////////
1:             result = safeGetSessionHolder().getOrCreateSender();
/////////////////////////////////////////////////////////////////////////
1:             result = safeGetSessionHolder().getOrCreatePublisher();
/////////////////////////////////////////////////////////////////////////
1:         return "PooledSession { " + safeGetSessionHolder() + " }";
/////////////////////////////////////////////////////////////////////////
1: 
1:     private SessionHolder safeGetSessionHolder() {
1:         SessionHolder sessionHolder = this.sessionHolder;
1:         if (sessionHolder == null) {
1:             throw new IllegalStateException("The session has already been closed");
1:         }
1: 
1:         return sessionHolder;
1:     }
commit:f395c70
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     private final KeyedObjectPool<SessionKey, Session> sessionPool;
1:     private final AtomicBoolean closed = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0:     public PooledSession(SessionKey key, Session session, KeyedObjectPool<SessionKey, Session> sessionPool, boolean transactional, boolean anonymous) {
/////////////////////////////////////////////////////////////////////////
1:         if (ignoreClose) {
1:             return;
1:         }
1: 
1:         if (closed.compareAndSet(false, true)) {
/////////////////////////////////////////////////////////////////////////
0:                     sessionPool.invalidateObject(key, session);
0:                     sessionPool.returnObject(key, session);
1: 
0:             session = null;
commit:2a7c349
/////////////////////////////////////////////////////////////////////////
1:     private final CopyOnWriteArrayList<PooledSessionEventListener> sessionEventListeners = new CopyOnWriteArrayList<PooledSessionEventListener>();
1: 
0:     private MessageProducer producer;
0:     private TopicPublisher publisher;
0:     private QueueSender sender;
1:     private boolean useAnonymousProducers = true;
0:     public PooledSession(SessionKey key, Session session, KeyedObjectPool<SessionKey, PooledSession> sessionPool, boolean transactional, boolean anonymous) {
1:         this.useAnonymousProducers = anonymous;
/////////////////////////////////////////////////////////////////////////
0:             return ((XASession) session).getXAResource();
/////////////////////////////////////////////////////////////////////////
1:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic));
1:         return addTopicSubscriber(((TopicSession) getInternalSession()).createSubscriber(topic, selector, local));
1:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue));
1:         return addQueueReceiver(((QueueSession) getInternalSession()).createReceiver(queue, selector));
1:         return new PooledProducer(getMessageProducer(destination), destination);
1:         return new PooledQueueSender(getQueueSender(queue), queue);
1:         return new PooledTopicPublisher(getTopicPublisher(topic), topic);
/////////////////////////////////////////////////////////////////////////
1:         return getMessageProducer(null);
1:     }
1: 
1:     public MessageProducer getMessageProducer(Destination destination) throws JMSException {
1:         MessageProducer result = null;
1: 
1:         if (useAnonymousProducers) {
0:             if (producer == null) {
0:                 // Don't allow for duplicate anonymous producers.
0:                 synchronized (this) {
0:                     if (producer == null) {
0:                         producer = getInternalSession().createProducer(null);
1:                     }
1:                 }
1:             }
1: 
0:             result = producer;
1:         } else {
1:             result = getInternalSession().createProducer(destination);
1: 
1:         return result;
1:         return getQueueSender(null);
1:     }
1: 
1:     public QueueSender getQueueSender(Queue destination) throws JMSException {
1:         QueueSender result = null;
1: 
1:         if (useAnonymousProducers) {
0:             if (sender == null) {
0:                 // Don't allow for duplicate anonymous producers.
0:                 synchronized (this) {
0:                     if (sender == null) {
0:                         sender = ((QueueSession) getInternalSession()).createSender(null);
1:                     }
1:                 }
1:             }
1: 
0:             result = sender;
1:         } else {
1:             result = ((QueueSession) getInternalSession()).createSender(destination);
1: 
1:         return result;
1:         return getTopicPublisher(null);
1:     }
1: 
1:     public TopicPublisher getTopicPublisher(Topic destination) throws JMSException {
1:         TopicPublisher result = null;
1: 
1:         if (useAnonymousProducers) {
0:             if (publisher == null) {
0:                 // Don't allow for duplicate anonymous producers.
0:                 synchronized (this) {
0:                     if (publisher == null) {
0:                         publisher = ((TopicSession) getInternalSession()).createPublisher(null);
1:                     }
1:                 }
1:             }
1: 
0:             result = publisher;
1:         } else {
1:             result = ((TopicSession) getInternalSession()).createPublisher(destination);
1: 
1:         return result;
/////////////////////////////////////////////////////////////////////////
1:         // must wrap in PooledMessageConsumer to ensure the onConsumerClose
1:         // method is invoked when the returned consumer is closed, to avoid memory
1:         // leak in this session class in case many consumers is created
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Callback invoked when the consumer is closed.
1:      * <p/>
1:      * This is used to keep track of an explicit closed consumer created by this
1:      * session, by which we know do not need to keep track of the consumer, as
1:      * its already closed.
1:      *
1:      * @param consumer
1:      *            the consumer which is being closed
1:      */
1:     protected void onConsumerClose(MessageConsumer consumer) {
1:         consumers.remove(consumer);
1:     }
author:gtully
-------------------------------------------------------------------------------
commit:b66559e
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.jms.pool;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private Session session;
0:     private MessageProducer messageProducer;
0:     private QueueSender queueSender;
0:     private TopicPublisher topicPublisher;
0:     public PooledSession(SessionKey key, Session session, KeyedObjectPool<SessionKey, PooledSession> sessionPool, boolean transactional) {
1:         this.transactional = transactional;
/////////////////////////////////////////////////////////////////////////
1:                     javax.jms.IllegalStateException illegalStateException = new javax.jms.IllegalStateException(e.toString());
1:                     illegalStateException.initCause(e);
1:                     throw illegalStateException;
/////////////////////////////////////////////////////////////////////////
0:         if (session instanceof XASession) {
0:             return ((XASession)session).getXAResource();
1:         return null;
/////////////////////////////////////////////////////////////////////////
0:         return addTopicSubscriber(((TopicSession)getInternalSession()).createSubscriber(topic));
0:         return addTopicSubscriber(((TopicSession)getInternalSession()).createSubscriber(topic, selector, local));
0:         return addQueueReceiver(((QueueSession)getInternalSession()).createReceiver(queue));
0:         return addQueueReceiver(((QueueSession)getInternalSession()).createReceiver(queue, selector));
/////////////////////////////////////////////////////////////////////////
1:     public Session getInternalSession() throws IllegalStateException {
0:             throw new IllegalStateException("The session has already been closed");
1:     public MessageProducer getMessageProducer() throws JMSException {
0:             messageProducer = getInternalSession().createProducer(null);
1:     public QueueSender getQueueSender() throws JMSException {
0:             queueSender = ((QueueSession)getInternalSession()).createSender(null);
1:     public TopicPublisher getTopicPublisher() throws JMSException {
0:             topicPublisher = ((TopicSession)getInternalSession()).createPublisher(null);
author:Gary Tully
-------------------------------------------------------------------------------
commit:059fd2f
/////////////////////////////////////////////////////////////////////////
1:                     LOG.trace("Ignoring exception on invalidateObject as discarding session: " + e, e);
commit:b496c0a
/////////////////////////////////////////////////////////////////////////
1:         // only add if really needed
0:         if (!tempDestEventListeners.contains(listener)) {
0:             this.tempDestEventListeners.add(listener);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 tempDestEventListeners.clear();
commit:101e711
/////////////////////////////////////////////////////////////////////////
1:             boolean invalidate = false;
1:             try {
1:                 // lets reset the session
1:                 getInternalSession().setMessageListener(null);
1:                 // Close any consumers and browsers that may have been created.
1:                 for (Iterator<MessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
1:                     MessageConsumer consumer = iter.next();
1:                     consumer.close();
1:                 }
1: 
1:                 for (Iterator<QueueBrowser> iter = browsers.iterator(); iter.hasNext();) {
1:                     QueueBrowser browser = iter.next();
1:                     browser.close();
1:                 }
1: 
1:                 if (transactional && !isXa) {
1:                     try {
1:                         getInternalSession().rollback();
1:                     } catch (JMSException e) {
1:                         invalidate = true;
1:                         LOG.warn("Caught exception trying rollback() when putting session back into the pool, will invalidate. " + e, e);
1:                     }
1:                 }
1:             } catch (JMSException ex) {
1:                 invalidate = true;
1:                 LOG.warn("Caught exception trying close() when putting session back into the pool, will invalidate. " + ex, ex);
1:             } finally {
1:                 consumers.clear();
1:                 browsers.clear();
1:             if (invalidate) {
0:                 // lets close the session and not put the session back into
0:                 // the pool
1:                 if (session != null) {
1:                         LOG.trace("Ignoring exception on close as discarding session: " + e1, e1);
0:                 sessionPool.invalidateSession(this);
1:             } else {
0:                 sessionPool.returnSession(this);
commit:628a0cd
/////////////////////////////////////////////////////////////////////////
1:     private boolean isXa;
/////////////////////////////////////////////////////////////////////////
0:             if (transactional && !isXa) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void setIsXa(boolean isXa) {
1:         this.isXa = isXa;
1:     }
commit:1a8fd95
/////////////////////////////////////////////////////////////////////////
0:     public ActiveMQSession getInternalSession() throws AlreadyClosedException {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:49f16ce
/////////////////////////////////////////////////////////////////////////
0:     private final CopyOnWriteArrayList<PooledSessionEventListener> sessionEventListeners =
/////////////////////////////////////////////////////////////////////////
1:     public void addSessionEventListener(PooledSessionEventListener listener) {
1:         if (!sessionEventListeners.contains(listener)) {
1:             this.sessionEventListeners.add(listener);
/////////////////////////////////////////////////////////////////////////
1:                 for (PooledSessionEventListener listener : this.sessionEventListeners) {
1:                     listener.onSessionClosed(this);
1:                 }
1:                 sessionEventListeners.clear();
/////////////////////////////////////////////////////////////////////////
1:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
/////////////////////////////////////////////////////////////////////////
1:         for (PooledSessionEventListener listener : this.sessionEventListeners) {
commit:a59c9ba
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.JMSExceptionSupport;
0: import org.apache.commons.pool.KeyedObjectPool;
1:     private final SessionKey key;
0:     private final KeyedObjectPool<SessionKey, PooledSession> sessionPool;
1:     private final CopyOnWriteArrayList<MessageConsumer> consumers = new CopyOnWriteArrayList<MessageConsumer>();
1:     private final CopyOnWriteArrayList<QueueBrowser> browsers = new CopyOnWriteArrayList<QueueBrowser>();
0:     private final CopyOnWriteArrayList<PooledSessionEventListener> tempDestEventListeners =
0:         new CopyOnWriteArrayList<PooledSessionEventListener>();
1: 
0:     public PooledSession(SessionKey key, ActiveMQSession session, KeyedObjectPool<SessionKey, PooledSession> sessionPool) {
1:         this.key = key;
0:         this.session = session;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 // lets close the session and not put the session back into the pool
1:                 // instead invalidate it so the pool can create a new one on demand.
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                     sessionPool.invalidateObject(key, this);
1:                 } catch (Exception e) {
0:                     throw JMSExceptionSupport.create(e);
1:                 }
1:                 try {
0:                     sessionPool.returnObject(key, this);
1:                 } catch (Exception e) {
0:                     throw JMSExceptionSupport.create(e);
1:                 }
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         // must wrap in PooledMessageConsumer to ensure the onConsumerClose method is
0:         // invoked when the returned consumer is closed, to avoid memory leak in this
0:         // session class in case many consumers is created
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:6687d56
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Session;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private final CopyOnWriteArrayList<PooledSessionEventListener> tempDestEventListeners =
0:         new CopyOnWriteArrayList<PooledSessionEventListener>();
/////////////////////////////////////////////////////////////////////////
0:     public void addTempDestEventListener(PooledSessionEventListener listener) {
0:         this.tempDestEventListeners.add(listener);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         TemporaryQueue result;
1: 
1:         result = getInternalSession().createTemporaryQueue();
1: 
1:         // Notify all of the listeners of the created temporary Queue.
0:         for (PooledSessionEventListener listener : this.tempDestEventListeners) {
1:             listener.onTemporaryQueueCreate(result);
1:         }
1: 
1:         return result;
1:         TemporaryTopic result;
1: 
1:         result = getInternalSession().createTemporaryTopic();
1: 
1:         // Notify all of the listeners of the created temporary Topic.
0:         for (PooledSessionEventListener listener : this.tempDestEventListeners) {
1:             listener.onTemporaryTopicCreate(result);
1:         }
1: 
1:         return result;
/////////////////////////////////////////////////////////////////////////
0:      * This is used to keep track of an explicit closed consumer created by this
0:      * session, by which we know do not need to keep track of the consumer, as
0:      * its already closed.
0:      * @param consumer
0:      *            the consumer which is being closed
/////////////////////////////////////////////////////////////////////////
0:         // must wrap in PooledMessageConsumer to ensure the onConsumerClose
0:         // method is invoked
0:         // when the returned consumer is closed, to avoid memory leak in this
0:         // session class
commit:5886b66
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Callback invoked when the consumer is closed.
0:      * <p/>
0:      * This is used to keep track of an explicit closed consumer created by this session,
0:      * by which we know do not need to keep track of the consumer, as its already closed.
1:      *
0:      * @param consumer the consumer which is being closed
1:      */
0:     protected void onConsumerClose(MessageConsumer consumer) {
0:         consumers.remove(consumer);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         // must wrap in PooledMessageConsumer to ensure the onConsumerClose method is invoked
0:         // when the returned consumer is closed, to avoid memory leak in this session class
0:         // in case many consumers is created
1:         return new PooledMessageConsumer(this, consumer);
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String toString() {
0:         return "PooledSession { " + session + " }";
1:     }
commit:bfd1be5
/////////////////////////////////////////////////////////////////////////
1:  *
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1:     private boolean ignoreClose;
0:     private final CopyOnWriteArrayList<MessageConsumer> consumers = new CopyOnWriteArrayList<MessageConsumer>();
0:     private final CopyOnWriteArrayList<QueueBrowser> browsers = new CopyOnWriteArrayList<QueueBrowser>();
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageConsumer> iter = consumers.iterator(); iter.hasNext();) {
0:                 MessageConsumer consumer = iter.next();
0:             for (Iterator<QueueBrowser> iter = browsers.iterator(); iter.hasNext();) {
0:                 QueueBrowser browser = iter.next();
commit:fc00993
/////////////////////////////////////////////////////////////////////////
0:     private static final transient Log LOG = LogFactory.getLog(PooledSession.class);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Caught exception trying rollback() when putting session back into the pool: " + e, e);
0:                         LOG.trace("Ignoring exception as discarding session: " + e1, e1);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:                 MessageConsumer consumer = (MessageConsumer)iter.next();
1: 
0:                 QueueBrowser browser = (QueueBrowser)iter.next();
1: 
0:                 } catch (JMSException e) {
1: 
0:                     // lets close the session and not put the session back into
0:                     // the pool
1:                     } catch (JMSException e1) {
1: 
/////////////////////////////////////////////////////////////////////////
1:     // -------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // -------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////
0:     // -------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////
0:             messageProducer = (ActiveMQMessageProducer)getSession().createProducer(null);
0:             queueSender = (ActiveMQQueueSender)getSession().createSender(null);
0:             topicPublisher = (ActiveMQTopicPublisher)getSession().createPublisher(null);
/////////////////////////////////////////////////////////////////////////
1: 
1:     }
1: 
1: 
0:         return "PooledSession { " + session + " }";
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CopyOnWriteArrayList;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:0bba311
/////////////////////////////////////////////////////////////////////////
1: import java.io.Serializable;
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQMessageProducer;
0: import org.apache.activemq.ActiveMQQueueSender;
0: import org.apache.activemq.ActiveMQSession;
0: import org.apache.activemq.ActiveMQTopicPublisher;
0: import org.apache.activemq.AlreadyClosedException;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
commit:c60ac2f
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.CopyOnWriteArrayList;
1: 
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     
0:     private final CopyOnWriteArrayList consumers = new CopyOnWriteArrayList();
0:     private final CopyOnWriteArrayList browsers = new CopyOnWriteArrayList();
/////////////////////////////////////////////////////////////////////////
1:         
0:         // Close any consumers and browsers that may have been created.
0:         for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:             MessageConsumer consumer = (MessageConsumer) iter.next();
0:             consumer.close();
1:         }
1:         
0:         for (Iterator iter = browsers.iterator(); iter.hasNext();) {
0:             QueueBrowser browser = (QueueBrowser) iter.next();
0:             browser.close();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         return addQueueBrowser(getSession().createBrowser(queue));
0:         return addQueueBrowser(getSession().createBrowser(queue, selector));
0:         return addConsumer(getSession().createConsumer(destination));
0:         return addConsumer(getSession().createConsumer(destination, selector));
0:         return addConsumer(getSession().createConsumer(destination, selector, noLocal));
0:         return addTopicSubscriber(getSession().createDurableSubscriber(topic, selector));
1: 
0:         return addTopicSubscriber(getSession().createDurableSubscriber(topic, name, selector, noLocal));
/////////////////////////////////////////////////////////////////////////
0:         return addTopicSubscriber(getSession().createSubscriber(topic));
0:         return addTopicSubscriber(getSession().createSubscriber(topic, selector, local));
0:         return addQueueReceiver(getSession().createReceiver(queue));
0:         return addQueueReceiver(getSession().createReceiver(queue, selector));
/////////////////////////////////////////////////////////////////////////
1:     private QueueBrowser addQueueBrowser(QueueBrowser browser) {
1:         browsers.add(browser);
1:         return browser;
1:     }
1:     private MessageConsumer addConsumer(MessageConsumer consumer) {
1:         consumers.add(consumer);
0:         return consumer;
1:     }    
1:     private TopicSubscriber addTopicSubscriber(TopicSubscriber subscriber) {
1:         consumers.add(subscriber);
1:         return subscriber;
1:     }
1:     private QueueReceiver addQueueReceiver(QueueReceiver receiver) {
1:         consumers.add(receiver);
1:         return receiver;
1:     }
1: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
0: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
0: package org.apache.activemq.pool;
1: 
0: import org.apache.activemq.ActiveMQMessageProducer;
0: import org.apache.activemq.ActiveMQQueueSender;
0: import org.apache.activemq.ActiveMQSession;
0: import org.apache.activemq.ActiveMQTopicPublisher;
0: import org.apache.activemq.AlreadyClosedException;
0: import org.apache.activemq.util.JMSExceptionSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.commons.pool.ObjectPool;
1: 
1: import javax.jms.BytesMessage;
1: import javax.jms.Destination;
1: import javax.jms.JMSException;
1: import javax.jms.MapMessage;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageListener;
1: import javax.jms.MessageProducer;
1: import javax.jms.ObjectMessage;
1: import javax.jms.Queue;
1: import javax.jms.QueueBrowser;
1: import javax.jms.QueueReceiver;
1: import javax.jms.QueueSender;
1: import javax.jms.QueueSession;
1: import javax.jms.StreamMessage;
1: import javax.jms.TemporaryQueue;
1: import javax.jms.TemporaryTopic;
1: import javax.jms.TextMessage;
1: import javax.jms.Topic;
1: import javax.jms.TopicPublisher;
1: import javax.jms.TopicSession;
1: import javax.jms.TopicSubscriber;
1: 
0: import java.io.Serializable;
1: 
0: /**
0:  * @version $Revision: 1.1 $
0:  */
0: public class PooledSession implements TopicSession, QueueSession {
0:     private static final transient Log log = LogFactory.getLog(PooledSession.class);
1: 
0:     private ActiveMQSession session;
0:     private SessionPool sessionPool;
0:     private ActiveMQMessageProducer messageProducer;
0:     private ActiveMQQueueSender queueSender;
0:     private ActiveMQTopicPublisher topicPublisher;
1:     private boolean transactional = true;
1: 
0:     public PooledSession(ActiveMQSession aSession, SessionPool sessionPool) {
0:         this.session = aSession;
1:         this.sessionPool = sessionPool;
0:         this.transactional = session.isTransacted();
1:     }
1: 
1: 
1:     public void close() throws JMSException {
0:         // TODO a cleaner way to reset??
1: 
0:         // lets reset the session
0:         getSession().setMessageListener(null);
1: 
0:         // maybe do a rollback?
0:         if (transactional) {
1:             try {
0:                 getSession().rollback();
1:             }
0:             catch (JMSException e) {
0:                 log.warn("Caught exception trying rollback() when putting session back into the pool: " + e, e);
1: 
0:                 // lets close the session and not put the session back into the pool
1:                 try {
0:                     session.close();
1:                 }
0:                 catch (JMSException e1) {
0:                     log.trace("Ignoring exception as discarding session: " + e1, e1);
1:                 }
0:                 session = null;
0:                 return;
1:             }
1:         }
1: 
0:         sessionPool.returnSession(this);
1:     }
1: 
1:     public void commit() throws JMSException {
0:         getSession().commit();
1:     }
1: 
1:     public BytesMessage createBytesMessage() throws JMSException {
0:         return getSession().createBytesMessage();
1:     }
1: 
1:     public MapMessage createMapMessage() throws JMSException {
0:         return getSession().createMapMessage();
1:     }
1: 
1:     public Message createMessage() throws JMSException {
0:         return getSession().createMessage();
1:     }
1: 
1:     public ObjectMessage createObjectMessage() throws JMSException {
0:         return getSession().createObjectMessage();
1:     }
1: 
1:     public ObjectMessage createObjectMessage(Serializable serializable) throws JMSException {
0:         return getSession().createObjectMessage(serializable);
1:     }
1: 
1:     public Queue createQueue(String s) throws JMSException {
0:         return getSession().createQueue(s);
1:     }
1: 
1:     public StreamMessage createStreamMessage() throws JMSException {
0:         return getSession().createStreamMessage();
1:     }
1: 
1:     public TemporaryQueue createTemporaryQueue() throws JMSException {
0:         return getSession().createTemporaryQueue();
1:     }
1: 
1:     public TemporaryTopic createTemporaryTopic() throws JMSException {
0:         return getSession().createTemporaryTopic();
1:     }
1: 
1:     public void unsubscribe(String s) throws JMSException {
0:         getSession().unsubscribe(s);
1:     }
1: 
1:     public TextMessage createTextMessage() throws JMSException {
0:         return getSession().createTextMessage();
1:     }
1: 
1:     public TextMessage createTextMessage(String s) throws JMSException {
0:         return getSession().createTextMessage(s);
1:     }
1: 
1:     public Topic createTopic(String s) throws JMSException {
0:         return getSession().createTopic(s);
1:     }
1: 
1:     public int getAcknowledgeMode() throws JMSException {
0:         return getSession().getAcknowledgeMode();
1:     }
1: 
1:     public boolean getTransacted() throws JMSException {
0:         return getSession().getTransacted();
1:     }
1: 
1:     public void recover() throws JMSException {
0:         getSession().recover();
1:     }
1: 
1:     public void rollback() throws JMSException {
0:         getSession().rollback();
1:     }
1: 
1:     public void run() {
0:         if (session != null) {
0:             session.run();
1:         }
1:     }
1: 
1: 
1:     // Consumer related methods
0:     //-------------------------------------------------------------------------
1:     public QueueBrowser createBrowser(Queue queue) throws JMSException {
0:         return getSession().createBrowser(queue);
1:     }
1: 
1:     public QueueBrowser createBrowser(Queue queue, String selector) throws JMSException {
0:         return getSession().createBrowser(queue, selector);
1:     }
1: 
1:     public MessageConsumer createConsumer(Destination destination) throws JMSException {
0:         return getSession().createConsumer(destination);
1:     }
1: 
1:     public MessageConsumer createConsumer(Destination destination, String selector) throws JMSException {
0:         return getSession().createConsumer(destination, selector);
1:     }
1: 
1:     public MessageConsumer createConsumer(Destination destination, String selector, boolean noLocal) throws JMSException {
0:         return getSession().createConsumer(destination, selector, noLocal);
1:     }
1: 
1:     public TopicSubscriber createDurableSubscriber(Topic topic, String selector) throws JMSException {
0:         return getSession().createDurableSubscriber(topic, selector);
1:     }
1: 
1:     public TopicSubscriber createDurableSubscriber(Topic topic, String name, String selector, boolean noLocal) throws JMSException {
0:         return getSession().createDurableSubscriber(topic, name, selector, noLocal);
1:     }
1: 
1:     public MessageListener getMessageListener() throws JMSException {
0:         return getSession().getMessageListener();
1:     }
1: 
1:     public void setMessageListener(MessageListener messageListener) throws JMSException {
0:         getSession().setMessageListener(messageListener);
1:     }
1: 
1:     public TopicSubscriber createSubscriber(Topic topic) throws JMSException {
0:         return getSession().createSubscriber(topic);
1:     }
1: 
1:     public TopicSubscriber createSubscriber(Topic topic, String selector, boolean local) throws JMSException {
0:         return getSession().createSubscriber(topic, selector, local);
1:     }
1: 
1:     public QueueReceiver createReceiver(Queue queue) throws JMSException {
0:         return getSession().createReceiver(queue);
1:     }
1: 
1:     public QueueReceiver createReceiver(Queue queue, String selector) throws JMSException {
0:         return getSession().createReceiver(queue, selector);
1:     }
1: 
1: 
1:     // Producer related methods
0:     //-------------------------------------------------------------------------
1:     public MessageProducer createProducer(Destination destination) throws JMSException {
0:         return new PooledProducer(getMessageProducer(), destination);
1:     }
1: 
1:     public QueueSender createSender(Queue queue) throws JMSException {
0:         return new PooledQueueSender(getQueueSender(), queue);
1:     }
1: 
1:     public TopicPublisher createPublisher(Topic topic) throws JMSException {
0:         return new PooledTopicPublisher(getTopicPublisher(), topic);
1:     }
1: 
0:     // Implementation methods
0:     //-------------------------------------------------------------------------
0:     protected ActiveMQSession getSession() throws AlreadyClosedException {
0:         if (session == null) {
0:             throw new AlreadyClosedException("The session has already been closed");
1:         }
0:         return session;
1:     }
1: 
0:     public ActiveMQMessageProducer getMessageProducer() throws JMSException {
0:         if (messageProducer == null) {
0:             messageProducer = (ActiveMQMessageProducer) getSession().createProducer(null);
1:         }
0:         return messageProducer;
1:     }
1: 
0:     public ActiveMQQueueSender getQueueSender() throws JMSException {
0:         if (queueSender == null) {
0:             queueSender = (ActiveMQQueueSender) getSession().createSender(null);
1:         }
0:         return queueSender;
1:     }
1: 
0:     public ActiveMQTopicPublisher getTopicPublisher() throws JMSException {
0:         if (topicPublisher == null) {
0:             topicPublisher = (ActiveMQTopicPublisher) getSession().createPublisher(null);
1:         }
0:         return topicPublisher;
1:     }
1: 
0:     public String toString() {
0:         return "PooledSession { "+session+" }";
1:     }
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final transient Logger LOG = LoggerFactory.getLogger(PooledSession.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:eae5aa0
/////////////////////////////////////////////////////////////////////////
0:                     sessionPool.invalidateSession(this);
author:Guillaume Nodet
-------------------------------------------------------------------------------
commit:9a1f9c2
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.XASession;
0: import javax.jms.Session;
1: import javax.transaction.xa.XAResource;
/////////////////////////////////////////////////////////////////////////
1: public class PooledSession implements Session, TopicSession, QueueSession, XASession {
/////////////////////////////////////////////////////////////////////////
0:             getInternalSession().setMessageListener(null);
/////////////////////////////////////////////////////////////////////////
1:                     getInternalSession().rollback();
/////////////////////////////////////////////////////////////////////////
1:         getInternalSession().commit();
1:         return getInternalSession().createBytesMessage();
1:         return getInternalSession().createMapMessage();
1:         return getInternalSession().createMessage();
1:         return getInternalSession().createObjectMessage();
1:         return getInternalSession().createObjectMessage(serializable);
1:         return getInternalSession().createQueue(s);
1:         return getInternalSession().createStreamMessage();
0:         return getInternalSession().createTemporaryQueue();
0:         return getInternalSession().createTemporaryTopic();
1:         getInternalSession().unsubscribe(s);
1:         return getInternalSession().createTextMessage();
1:         return getInternalSession().createTextMessage(s);
1:         return getInternalSession().createTopic(s);
1:         return getInternalSession().getAcknowledgeMode();
1:         return getInternalSession().getTransacted();
1:         getInternalSession().recover();
0:         getInternalSession().rollback();
0:     }
0: 
1:     public XAResource getXAResource() {
0:         if (session == null) {
0:             throw new IllegalStateException("Session is closed");
0:         }
0:         return session.getTransactionContext();
0:     }
0: 
1:     public Session getSession() {
1:         return this;
/////////////////////////////////////////////////////////////////////////
1:         return addQueueBrowser(getInternalSession().createBrowser(queue));
1:         return addQueueBrowser(getInternalSession().createBrowser(queue, selector));
1:         return addConsumer(getInternalSession().createConsumer(destination));
1:         return addConsumer(getInternalSession().createConsumer(destination, selector));
1:         return addConsumer(getInternalSession().createConsumer(destination, selector, noLocal));
1:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, selector));
1:         return addTopicSubscriber(getInternalSession().createDurableSubscriber(topic, name, selector, noLocal));
1:         return getInternalSession().getMessageListener();
1:         getInternalSession().setMessageListener(messageListener);
0:         return addTopicSubscriber(getInternalSession().createSubscriber(topic));
0:         return addTopicSubscriber(getInternalSession().createSubscriber(topic, selector, local));
0:         return addQueueReceiver(getInternalSession().createReceiver(queue));
0:         return addQueueReceiver(getInternalSession().createReceiver(queue, selector));
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQSession getInternalSession() throws AlreadyClosedException {
/////////////////////////////////////////////////////////////////////////
0:             messageProducer = (ActiveMQMessageProducer) getInternalSession().createProducer(null);
0:             queueSender = (ActiveMQQueueSender) getInternalSession().createSender(null);
0:             topicPublisher = (ActiveMQTopicPublisher) getInternalSession().createPublisher(null);
commit:2e57fb5
commit:8704012
/////////////////////////////////////////////////////////////////////////
0:     private boolean ignoreClose = false;
0: 
1:     protected boolean isIgnoreClose() {
1:         return ignoreClose;
0:     }
0: 
1:     protected void setIgnoreClose(boolean ignoreClose) {
1:         this.ignoreClose = ignoreClose;
0:     }
0:         if (!ignoreClose) {
0:             // TODO a cleaner way to reset??
0:     
0:             // lets reset the session
0:             getSession().setMessageListener(null);
0:             
0:             // Close any consumers and browsers that may have been created.
0:             for (Iterator iter = consumers.iterator(); iter.hasNext();) {
0:                 MessageConsumer consumer = (MessageConsumer) iter.next();
0:                 consumer.close();
0:             consumers.clear();
0:             
0:             for (Iterator iter = browsers.iterator(); iter.hasNext();) {
0:                 QueueBrowser browser = (QueueBrowser) iter.next();
0:                 browser.close();
0:             }
0:             browsers.clear();
0:     
0:             // maybe do a rollback?
0:             if (transactional) {
0:                     getSession().rollback();
0:                 catch (JMSException e) {
0:                     log.warn("Caught exception trying rollback() when putting session back into the pool: " + e, e);
0:     
0:                     // lets close the session and not put the session back into the pool
0:                     try {
0:                         session.close();
0:                     }
0:                     catch (JMSException e1) {
0:                         log.trace("Ignoring exception as discarding session: " + e1, e1);
0:                     }
0:                     session = null;
0:                     return;
0:     
0:             sessionPool.returnSession(this);
author:James Strachan
-------------------------------------------------------------------------------
commit:8043380
/////////////////////////////////////////////////////////////////////////
0:         consumers.clear();
0:         browsers.clear();
============================================================================