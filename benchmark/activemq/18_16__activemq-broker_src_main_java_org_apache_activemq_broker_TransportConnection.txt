1:d29ca2a: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:8b0f88a:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:8b0f88a:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
5:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker;
1:4eafccc: 
1:8abb5b6: import java.io.EOFException;
1:74bed6b: import java.io.IOException;
1:2b10259: import java.net.SocketException;
1:74bed6b: import java.net.URI;
1:707940f: import java.util.Collection;
1:707940f: import java.util.HashMap;
1:707940f: import java.util.Iterator;
1:707940f: import java.util.LinkedList;
1:707940f: import java.util.List;
1:707940f: import java.util.Map;
1:707940f: import java.util.Properties;
1:74bed6b: import java.util.concurrent.ConcurrentHashMap;
1:6b4509c: import java.util.concurrent.CopyOnWriteArrayList;
1:74bed6b: import java.util.concurrent.CountDownLatch;
1:74bed6b: import java.util.concurrent.TimeUnit;
1:74bed6b: import java.util.concurrent.atomic.AtomicBoolean;
1:74bed6b: import java.util.concurrent.atomic.AtomicInteger;
1:74bed6b: import java.util.concurrent.atomic.AtomicReference;
1:74bed6b: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:4eafccc: 
1:4eafccc: import javax.transaction.xa.XAResource;
1:707940f: 
1:74bed6b: import org.apache.activemq.advisory.AdvisorySupport;
1:da7478d: import org.apache.activemq.broker.region.ConnectionStatistics;
1:da7478d: import org.apache.activemq.broker.region.RegionBroker;
1:707940f: import org.apache.activemq.command.ActiveMQDestination;
1:707940f: import org.apache.activemq.command.BrokerInfo;
1:3953b9a: import org.apache.activemq.command.BrokerSubscriptionInfo;
1:707940f: import org.apache.activemq.command.Command;
1:707940f: import org.apache.activemq.command.CommandTypes;
1:707940f: import org.apache.activemq.command.ConnectionControl;
1:707940f: import org.apache.activemq.command.ConnectionError;
1:707940f: import org.apache.activemq.command.ConnectionId;
1:707940f: import org.apache.activemq.command.ConnectionInfo;
1:707940f: import org.apache.activemq.command.ConsumerControl;
1:707940f: import org.apache.activemq.command.ConsumerId;
1:707940f: import org.apache.activemq.command.ConsumerInfo;
1:707940f: import org.apache.activemq.command.ControlCommand;
1:707940f: import org.apache.activemq.command.DataArrayResponse;
1:707940f: import org.apache.activemq.command.DestinationInfo;
1:707940f: import org.apache.activemq.command.ExceptionResponse;
1:707940f: import org.apache.activemq.command.FlushCommand;
1:707940f: import org.apache.activemq.command.IntegerResponse;
1:707940f: import org.apache.activemq.command.KeepAliveInfo;
1:707940f: import org.apache.activemq.command.Message;
1:707940f: import org.apache.activemq.command.MessageAck;
1:707940f: import org.apache.activemq.command.MessageDispatch;
1:707940f: import org.apache.activemq.command.MessageDispatchNotification;
1:707940f: import org.apache.activemq.command.MessagePull;
1:707940f: import org.apache.activemq.command.ProducerAck;
1:707940f: import org.apache.activemq.command.ProducerId;
1:707940f: import org.apache.activemq.command.ProducerInfo;
1:eb6c082: import org.apache.activemq.command.RemoveInfo;
1:707940f: import org.apache.activemq.command.RemoveSubscriptionInfo;
1:707940f: import org.apache.activemq.command.Response;
1:707940f: import org.apache.activemq.command.SessionId;
1:707940f: import org.apache.activemq.command.SessionInfo;
1:707940f: import org.apache.activemq.command.ShutdownInfo;
1:707940f: import org.apache.activemq.command.TransactionId;
1:707940f: import org.apache.activemq.command.TransactionInfo;
1:707940f: import org.apache.activemq.command.WireFormatInfo;
1:3a71f8e: import org.apache.activemq.network.DemandForwardingBridge;
1:3a71f8e: import org.apache.activemq.network.MBeanNetworkListener;
1:3a71f8e: import org.apache.activemq.network.NetworkBridgeConfiguration;
1:3a71f8e: import org.apache.activemq.network.NetworkBridgeFactory;
1:9f7d70b: import org.apache.activemq.network.NetworkConnector;
1:da7478d: import org.apache.activemq.security.MessageAuthorizationPolicy;
1:da7478d: import org.apache.activemq.state.CommandVisitor;
1:ea74731: import org.apache.activemq.state.ConnectionState;
1:da7478d: import org.apache.activemq.state.ConsumerState;
1:da7478d: import org.apache.activemq.state.ProducerState;
1:da7478d: import org.apache.activemq.state.SessionState;
1:da7478d: import org.apache.activemq.state.TransactionState;
1:da7478d: import org.apache.activemq.thread.Task;
1:da7478d: import org.apache.activemq.thread.TaskRunner;
1:d29ca2a: import org.apache.activemq.thread.TaskRunnerFactory;
1:933eb2f: import org.apache.activemq.transaction.Transaction;
1:f915da5: import org.apache.activemq.transport.DefaultTransportListener;
1:35ba427: import org.apache.activemq.transport.ResponseCorrelator;
1:ae61847: import org.apache.activemq.transport.TransmitCallback;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:6b4509c: import org.apache.activemq.transport.TransportDisposedIOException;
1:3a71f8e: import org.apache.activemq.util.IntrospectionSupport;
1:3a71f8e: import org.apache.activemq.util.MarshallingSupport;
1:d206621: import org.apache.activemq.util.NetworkBridgeUtils;
1:0f7561e: import org.apache.activemq.util.SubscriptionKey;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2b456dd: import org.slf4j.MDC;
1:74bed6b: 
1:4c481ec: public class TransportConnection implements Connection, Task, CommandVisitor {
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(TransportConnection.class);
1:8bf987b:     private static final Logger TRANSPORTLOG = LoggerFactory.getLogger(TransportConnection.class.getName() + ".Transport");
1:8bf987b:     private static final Logger SERVICELOG = LoggerFactory.getLogger(TransportConnection.class.getName() + ".Service");
1:da7478d:     // Keeps track of the broker and connector that created this connection.
1:da7478d:     protected final Broker broker;
1:fe9d99e:     protected final BrokerService brokerService;
1:da7478d:     protected final TransportConnector connector;
1:da7478d:     // Keeps track of the state of the connections.
1:230a86c:     // protected final ConcurrentHashMap localConnectionStates=new
1:230a86c:     // ConcurrentHashMap();
1:ea74731:     protected final Map<ConnectionId, ConnectionState> brokerConnectionStates;
1:da7478d:     // The broker and wireformat info that was exchanged.
1:da7478d:     protected BrokerInfo brokerInfo;
1:39184e2:     protected final List<Command> dispatchQueue = new LinkedList<>();
1:933eb2f:     protected TaskRunner taskRunner;
1:39184e2:     protected final AtomicReference<Throwable> transportException = new AtomicReference<>();
1:933eb2f:     protected AtomicBoolean dispatchStopped = new AtomicBoolean(false);
1:8b0f88a:     private final Transport transport;
1:933eb2f:     private MessageAuthorizationPolicy messageAuthorizationPolicy;
1:8b0f88a:     private WireFormatInfo wireFormatInfo;
1:230a86c:     // Used to do async dispatch.. this should perhaps be pushed down into the
1:230a86c:     // transport layer..
1:933eb2f:     private boolean inServiceException;
1:f392884:     private final ConnectionStatistics statistics = new ConnectionStatistics();
1:da7478d:     private boolean manageable;
1:d29ca2a:     private boolean slow;
1:d29ca2a:     private boolean markedCandidate;
1:d29ca2a:     private boolean blockedCandidate;
1:d29ca2a:     private boolean blocked;
1:d29ca2a:     private boolean connected;
1:d29ca2a:     private boolean active;
1:bdec3f6:     private final AtomicBoolean starting = new AtomicBoolean();
1:bdec3f6:     private final AtomicBoolean pendingStop = new AtomicBoolean();
1:230a86c:     private long timeStamp;
1:4c481ec:     private final AtomicBoolean stopping = new AtomicBoolean(false);
1:f392884:     private final CountDownLatch stopped = new CountDownLatch(1);
1:230a86c:     private final AtomicBoolean asyncException = new AtomicBoolean(false);
1:39184e2:     private final Map<ProducerId, ProducerBrokerExchange> producerExchanges = new HashMap<>();
1:39184e2:     private final Map<ConsumerId, ConsumerBrokerExchange> consumerExchanges = new HashMap<>();
1:f392884:     private final CountDownLatch dispatchStoppedLatch = new CountDownLatch(1);
1:ea74731:     private ConnectionContext context;
1:49ea0ed:     private boolean networkConnection;
1:25b6812:     private boolean faultTolerantConnection;
1:f392884:     private final AtomicInteger protocolVersion = new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
1:230a86c:     private DemandForwardingBridge duplexBridge;
1:fc00993:     private final TaskRunnerFactory taskRunnerFactory;
1:8a01c5d:     private final TaskRunnerFactory stopTaskRunnerFactory;
1:a9119ec:     private TransportConnectionStateRegister connectionStateRegister = new SingleTransportConnectionStateRegister();
1:4c481ec:     private final ReentrantReadWriteLock serviceLock = new ReentrantReadWriteLock();
1:27d0ff4:     private String duplexNetworkConnectorId;
1:4228281: 
1:da7478d:     /**
1:3a71f8e:      * @param taskRunnerFactory - can be null if you want direct dispatch to the transport
1:3a71f8e:      *                          else commands are sent async.
1:8a01c5d:      * @param stopTaskRunnerFactory - can <b>not</b> be null, used for stopping this connection.
1:da7478d:      */
1:933eb2f:     public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,
1:8a01c5d:                                TaskRunnerFactory taskRunnerFactory, TaskRunnerFactory stopTaskRunnerFactory) {
1:230a86c:         this.connector = connector;
1:230a86c:         this.broker = broker;
1:fe9d99e:         this.brokerService = broker.getBrokerService();
1:fe9d99e: 
1:4228281:         RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);
1:230a86c:         brokerConnectionStates = rb.getConnectionStates();
1:230a86c:         if (connector != null) {
1:da7478d:             this.statistics.setParent(connector.getStatistics());
1:8a01c5d:             this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();
1:39184e2:         }
1:230a86c:         this.taskRunnerFactory = taskRunnerFactory;
1:8a01c5d:         this.stopTaskRunnerFactory = stopTaskRunnerFactory;
1:230a86c:         this.transport = transport;
1:bc4f4e9:         if( this.transport instanceof BrokerServiceAware ) {
1:bc4f4e9:             ((BrokerServiceAware)this.transport).setBrokerService(brokerService);
1:bc4f4e9:         }
1:f915da5:         this.transport.setTransportListener(new DefaultTransportListener() {
1:f392884:             @Override
1:230a86c:             public void onCommand(Object o) {
1:4c481ec:                 serviceLock.readLock().lock();
1:c808beb:                 try {
1:59643ef:                     if (!(o instanceof Command)) {
1:662aee8:                         throw new RuntimeException("Protocol violation - Command corrupted: " + o.toString());
1:4228281:                     }
1:4228281:                     Command command = (Command) o;
1:0f7561e:                     if (!brokerService.isStopping()) {
1:0f7561e:                         Response response = service(command);
1:0f7561e:                         if (response != null && !brokerService.isStopping()) {
1:0f7561e:                             dispatchSync(response);
1:0f7561e:                         }
1:0f7561e:                     } else {
1:0f7561e:                         throw new BrokerStoppedException("Broker " + brokerService + " is being stopped");
1:c6fe94e:                     }
1:4c481ec:                 } finally {
1:4c481ec:                     serviceLock.readLock().unlock();
1:4228281:                 }
1:d14e4ae:             }
1:4228281: 
1:c808beb:             @Override
1:230a86c:             public void onException(IOException exception) {
1:4c481ec:                 serviceLock.readLock().lock();
1:d14e4ae:                 try {
1:4c481ec:                     serviceTransportException(exception);
1:4c481ec:                 } finally {
1:4c481ec:                     serviceLock.readLock().unlock();
1:d14e4ae:                 }
1:d14e4ae:             }
1:d29ca2a:         });
1:230a86c:         connected = true;
1:d14e4ae:     }
1:4228281: 
1:da7478d:     /**
1:da7478d:      * Returns the number of messages to be dispatched to this connection
1:8b0f88a:      *
1:98cd515:      * @return size of dispatch queue
1:da7478d:      */
1:f392884:     @Override
1:230a86c:     public int getDispatchQueueSize() {
1:4228281:         synchronized (dispatchQueue) {
1:372f69a:             return dispatchQueue.size();
1:372f69a:         }
1:a3e3821:     }
1:4228281: 
1:230a86c:     public void serviceTransportException(IOException e) {
1:bdec3f6:         if (!stopping.get() && !pendingStop.get()) {
1:230a86c:             transportException.set(e);
1:b60bfbb:             if (TRANSPORTLOG.isDebugEnabled()) {
1:b60bfbb:                 TRANSPORTLOG.debug(this + " failed: " + e, e);
1:b60bfbb:             } else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {
1:b60bfbb:                 TRANSPORTLOG.warn(this + " failed: " + e);
1:8cf98a0:             }
1:e19293d:             stopAsync(e);
1:4228281:         }
1:4228281:     }
1:d14e4ae: 
1:2b10259:     private boolean expected(IOException e) {
1:ae61847:         return isStomp() && ((e instanceof SocketException && e.getMessage().indexOf("reset") != -1) || e instanceof EOFException);
1:2b10259:     }
1:2b10259: 
1:2b10259:     private boolean isStomp() {
1:2b10259:         URI uri = connector.getUri();
1:2b10259:         return uri != null && uri.getScheme() != null && uri.getScheme().indexOf("stomp") != -1;
1:2b10259:     }
1:2b10259: 
1:da7478d:     /**
1:230a86c:      * Calls the serviceException method in an async thread. Since handling a
1:230a86c:      * service exception closes a socket, we should not tie up broker threads
1:230a86c:      * since client sockets may hang or cause deadlocks.
1:da7478d:      */
1:ae61847:     @Override
1:230a86c:     public void serviceExceptionAsync(final IOException e) {
1:230a86c:         if (asyncException.compareAndSet(false, true)) {
1:230a86c:             new Thread("Async Exception Handler") {
1:f392884:                 @Override
1:c808beb:                 public void run() {
1:c07b233:                     serviceException(e);
1:4228281:                 }
1:c808beb:             }.start();
1:4228281:         }
1:d14e4ae:     }
1:f67415d: 
1:8b0f88a:     /**
1:230a86c:      * Closes a clients connection due to a detected error. Errors are ignored
1:230a86c:      * if: the client is closing or broker is closing. Otherwise, the connection
1:230a86c:      * error transmitted to the client before stopping it's transport.
1:8b0f88a:      */
1:ae61847:     @Override
1:230a86c:     public void serviceException(Throwable e) {
1:da7478d:         // are we a transport exception such as not being able to dispatch
1:da7478d:         // synchronously to a transport
1:230a86c:         if (e instanceof IOException) {
1:4228281:             serviceTransportException((IOException) e);
1:ecf89a6:         } else if (e.getClass() == BrokerStoppedException.class) {
1:8b0f88a:             // Handle the case where the broker is stopped
1:ecf89a6:             // But the client is still connected.
1:4c481ec:             if (!stopping.get()) {
1:e1bbde7:                 SERVICELOG.debug("Broker has been stopped.  Notifying client and closing his connection.");
1:230a86c:                 ConnectionError ce = new ConnectionError();
1:da7478d:                 ce.setException(e);
1:da7478d:                 dispatchSync(ce);
1:5cc1a55:                 // Record the error that caused the transport to stop
1:e19293d:                 transportException.set(e);
1:230a86c:                 // Wait a little bit to try to get the output buffer to flush
1:8012f28:                 // the exception notification to the client.
1:4228281:                 try {
1:da7478d:                     Thread.sleep(500);
1:230a86c:                 } catch (InterruptedException ie) {
1:da7478d:                     Thread.currentThread().interrupt();
1:c07b233:                 }
1:230a86c:                 // Worst case is we just kill the connection before the
1:230a86c:                 // notification gets to him.
1:4c481ec:                 stopAsync();
1:c07b233:             }
1:4c481ec:         } else if (!stopping.get() && !inServiceException) {
1:230a86c:             inServiceException = true;
1:f67415d:             try {
1:b1ea29e:                 if (SERVICELOG.isDebugEnabled()) {
1:b1ea29e:                     SERVICELOG.debug("Async error occurred: " + e, e);
1:b1ea29e:                 } else {
1:b1ea29e:                     SERVICELOG.warn("Async error occurred: " + e);
1:b1ea29e:                 }
1:230a86c:                 ConnectionError ce = new ConnectionError();
1:da7478d:                 ce.setException(e);
1:bdec3f6:                 if (pendingStop.get()) {
1:c856f30:                     dispatchSync(ce);
1:c6fe94e:                 } else {
1:da7478d:                     dispatchAsync(ce);
1:c07b233:                 }
1:230a86c:             } finally {
1:230a86c:                 inServiceException = false;
1:4741136:             }
1:df15551:         }
1:8b0f88a:     }
1:25b6812: 
1:ae61847:     @Override
1:230a86c:     public Response service(Command command) {
1:3da9f1c:         MDC.put("activemq.connector", connector.getUri().toString());
1:230a86c:         Response response = null;
1:01bdc52:         boolean responseRequired = command.isResponseRequired();
1:01bdc52:         int commandId = command.getCommandId();
1:4c481ec:         try {
1:0f7561e:             if (!pendingStop.get()) {
1:01bdc52:                 response = command.visit(this);
1:0302ffd:             } else {
1:0f7561e:                 response = new ExceptionResponse(transportException.get());
1:8b0f88a:             }
1:4c481ec:         } catch (Throwable e) {
1:e53668e:             if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {
1:4228281:                 SERVICELOG.debug("Error occured while processing " + (responseRequired ? "sync" : "async")
1:e53668e:                         + " command: " + command + ", exception: " + e, e);
1:69f5605:             }
1:3a71f8e: 
1:13bbe52:             if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {
1:13bbe52:                 LOG.info("Suppressing reply to: " + command + " on: " + e + ", cause: " + e.getCause());
1:13bbe52:                 responseRequired = false;
1:13bbe52:             }
1:13bbe52: 
2:230a86c:             if (responseRequired) {
1:707940f:                 if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {
1:84737f7:                     SERVICELOG.warn("Security Error occurred on connection to: {}, {}",
1:84737f7:                             transport.getRemoteAddress(), e.getMessage());
1:707940f:                 }
1:01bdc52:                 response = new ExceptionResponse(e);
1:01bdc52:             } else {
1:fe9d99e:                 forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);
1:8b0f88a:                 serviceException(e);
1:e53668e:             }
1:712303e:         }
1:01bdc52:         if (responseRequired) {
1:01bdc52:             if (response == null) {
1:01bdc52:                 response = new Response();
1:8b0f88a:             }
1:c07b233:             response.setCorrelationId(commandId);
1:c07b233:         }
1:01bdc52:         // The context may have been flagged so that the response is not
1:01bdc52:         // sent.
1:01bdc52:         if (context != null) {
1:01bdc52:             if (context.isDontSendReponse()) {
1:c07b233:                 context.setDontSendReponse(false);
1:01bdc52:                 response = null;
1:c07b233:             }
1:01bdc52:             context = null;
1:8b0f88a:         }
1:3da9f1c:         MDC.remove("activemq.connector");
1:da7478d:         return response;
1:8b0f88a:     }
1:3a71f8e: 
1:fe9d99e:     private void forceRollbackOnlyOnFailedAsyncTransactionOp(Throwable e, Command command) {
1:fe9d99e:         if (brokerService.isRollbackOnlyOnAsyncException() && !(e instanceof IOException) && isInTransaction(command)) {
1:fe9d99e:             Transaction transaction = getActiveTransaction(command);
1:fe9d99e:             if (transaction != null && !transaction.isRollbackOnly()) {
1:fe9d99e:                 LOG.debug("on async exception, force rollback of transaction for: " + command, e);
1:fe9d99e:                 transaction.setRollbackOnly(e);
1:fe9d99e:             }
1:fe9d99e:         }
1:fe9d99e:     }
1:fe9d99e: 
1:fe9d99e:     private Transaction getActiveTransaction(Command command) {
1:fe9d99e:         Transaction transaction = null;
1:fe9d99e:         try {
1:fe9d99e:             if (command instanceof Message) {
1:fe9d99e:                 Message messageSend = (Message) command;
1:fe9d99e:                 ProducerId producerId = messageSend.getProducerId();
1:fe9d99e:                 ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
1:fe9d99e:                 transaction = producerExchange.getConnectionContext().getTransactions().get(messageSend.getTransactionId());
1:fe9d99e:             } else if (command instanceof  MessageAck) {
1:fe9d99e:                 MessageAck messageAck = (MessageAck) command;
1:fe9d99e:                 ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(messageAck.getConsumerId());
1:fe9d99e:                 if (consumerExchange != null) {
1:fe9d99e:                     transaction = consumerExchange.getConnectionContext().getTransactions().get(messageAck.getTransactionId());
1:fe9d99e:                 }
1:fe9d99e:             }
1:fe9d99e:         } catch(Exception ignored){
1:fe9d99e:             LOG.trace("failed to find active transaction for command: " + command, ignored);
1:fe9d99e:         }
1:fe9d99e:         return transaction;
1:fe9d99e:     }
1:fe9d99e: 
1:fe9d99e:     private boolean isInTransaction(Command command) {
1:fe9d99e:         return command instanceof Message && ((Message)command).isInTransaction()
1:fe9d99e:                 || command instanceof MessageAck && ((MessageAck)command).isInTransaction();
1:fe9d99e:     }
1:fe9d99e: 
1:ae61847:     @Override
1:230a86c:     public Response processKeepAlive(KeepAliveInfo info) throws Exception {
1:ea74731:         return null;
1:93ca044:     }
1:f392884: 
1:707940f:     @Override
1:230a86c:     public Response processRemoveSubscription(RemoveSubscriptionInfo info) throws Exception {
1:230a86c:         broker.removeSubscription(lookupConnectionState(info.getConnectionId()).getContext(), info);
1:ea74731:         return null;
1:4c481ec:     }
1:4741136: 
1:ae61847:     @Override
1:ceec57a:     public Response processWireFormat(WireFormatInfo info) throws Exception {
1:230a86c:         wireFormatInfo = info;
1:230a86c:         protocolVersion.set(info.getVersion());
1:fb3b6db:         return null;
1:4c481ec:     }
1:4741136: 
1:ae61847:     @Override
1:230a86c:     public Response processShutdown(ShutdownInfo info) throws Exception {
1:4c481ec:         stopAsync();
1:fb3b6db:         return null;
1:4c481ec:     }
1:8b0f88a: 
1:ae61847:     @Override
1:230a86c:     public Response processFlush(FlushCommand command) throws Exception {
1:fb3b6db:         return null;
1:4c481ec:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processBeginTransaction(TransactionInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
2:230a86c:         context = null;
1:230a86c:         if (cs != null) {
1:230a86c:             context = cs.getContext();
1:2984963:         }
1:a3e3821:         if (cs == null) {
1:a3e3821:             throw new NullPointerException("Context is null");
1:a3e3821:         }
1:da7478d:         // Avoid replaying dup commands
1:230a86c:         if (cs.getTransactionState(info.getTransactionId()) == null) {
1:da7478d:             cs.addTransactionState(info.getTransactionId());
1:230a86c:             broker.beginTransaction(context, info.getTransactionId());
1:a3e3821:         }
1:230a86c:         return null;
1:a3e3821:     }
1:5e747b0: 
1:ae61847:     @Override
1:93ca044:     public int getActiveTransactionCount() {
1:93ca044:         int rc = 0;
1:93ca044:         for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {
1:dce2b61:             rc += cs.getTransactionStates().size();
1:93ca044:         }
1:93ca044:         return rc;
1:93ca044:     }
1:93ca044: 
1:707940f:     @Override
1:93ca044:     public Long getOldestActiveTransactionDuration() {
1:93ca044:         TransactionState oldestTX = null;
1:93ca044:         for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {
2:93ca044:             Collection<TransactionState> transactions = cs.getTransactionStates();
2:93ca044:             for (TransactionState transaction : transactions) {
1:93ca044:                 if( oldestTX ==null || oldestTX.getCreatedAt() < transaction.getCreatedAt() ) {
1:93ca044:                     oldestTX = transaction;
1:93ca044:                 }
1:93ca044:             }
1:93ca044:         }
1:93ca044:         if( oldestTX == null ) {
1:93ca044:             return null;
1:93ca044:         }
1:93ca044:         return System.currentTimeMillis() - oldestTX.getCreatedAt();
1:93ca044:     }
1:93ca044: 
1:ae61847:     @Override
1:27ded73:     public Response processEndTransaction(TransactionInfo info) throws Exception {
1:8b0f88a:         // No need to do anything. This packet is just sent by the client
1:da7478d:         // make sure he is synced with the server as commit command could
1:da7478d:         // come from a different connection.
1:fb3b6db:         return null;
1:a3e3821:     }
1:5e747b0: 
1:ae61847:     @Override
1:27ded73:     public Response processPrepareTransaction(TransactionInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         context = null;
1:230a86c:         if (cs != null) {
1:230a86c:             context = cs.getContext();
1:a3e3821:         }
1:a3e3821:         if (cs == null) {
1:a3e3821:             throw new NullPointerException("Context is null");
1:8b0f88a:         }
1:230a86c:         TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
1:ecf89a6:         if (transactionState == null) {
1:4eafccc:             throw new IllegalStateException("Cannot prepare a transaction that had not been started or previously returned XA_RDONLY: "
1:4228281:                     + info.getTransactionId());
1:01bdc52:         }
1:da7478d:         // Avoid dups.
1:230a86c:         if (!transactionState.isPrepared()) {
1:da7478d:             transactionState.setPrepared(true);
1:230a86c:             int result = broker.prepareTransaction(context, info.getTransactionId());
1:da7478d:             transactionState.setPreparedResult(result);
1:4eafccc:             if (result == XAResource.XA_RDONLY) {
1:4eafccc:                 // we are done, no further rollback or commit from TM
1:4eafccc:                 cs.removeTransactionState(info.getTransactionId());
1:4eafccc:             }
1:230a86c:             IntegerResponse response = new IntegerResponse(result);
1:da7478d:             return response;
1:230a86c:         } else {
1:230a86c:             IntegerResponse response = new IntegerResponse(transactionState.getPreparedResult());
1:da7478d:             return response;
1:01bdc52:         }
1:01bdc52:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         context = cs.getContext();
1:8b0f88a:         cs.removeTransactionState(info.getTransactionId());
1:230a86c:         broker.commitTransaction(context, info.getTransactionId(), true);
1:8b0f88a:         return null;
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         context = cs.getContext();
2:da7478d:         cs.removeTransactionState(info.getTransactionId());
1:230a86c:         broker.commitTransaction(context, info.getTransactionId(), false);
1:fb3b6db:         return null;
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processRollbackTransaction(TransactionInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         context = cs.getContext();
1:da7478d:         cs.removeTransactionState(info.getTransactionId());
1:230a86c:         broker.rollbackTransaction(context, info.getTransactionId());
1:ec14f65:         return null;
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         context = cs.getContext();
1:230a86c:         broker.forgetTransaction(context, info.getTransactionId());
11:da7478d:         return null;
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processRecoverTransactions(TransactionInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         context = cs.getContext();
1:230a86c:         TransactionId[] preparedTransactions = broker.getPreparedTransactions(context);
1:da7478d:         return new DataArrayResponse(preparedTransactions);
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:230a86c:     public Response processMessage(Message messageSend) throws Exception {
1:230a86c:         ProducerId producerId = messageSend.getProducerId();
1:230a86c:         ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
1:a6a6a70:         if (producerExchange.canDispatch(messageSend)) {
1:a6a6a70:             broker.send(producerExchange, messageSend);
1:a6a6a70:         }
1:da7478d:         return null;
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:230a86c:     public Response processMessageAck(MessageAck ack) throws Exception {
1:84eb9f8:         ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(ack.getConsumerId());
1:802f6b1:         if (consumerExchange != null) {
1:230a86c:             broker.acknowledge(consumerExchange, ack);
1:e8818fa:         } else if (ack.isInTransaction()) {
1:e8818fa:             LOG.warn("no matching consumer, ignoring ack {}", consumerExchange, ack);
1:ecf89a6:         }
1:da7478d:         return null;
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:230a86c:     public Response processMessagePull(MessagePull pull) throws Exception {
1:230a86c:         return broker.messagePull(lookupConnectionState(pull.getConsumerId()).getContext(), pull);
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:4228281:     public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Exception {
1:da7478d:         broker.processDispatchNotification(notification);
1:da7478d:         return null;
1:230a86c:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processAddDestination(DestinationInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         broker.addDestinationInfo(cs.getContext(), info);
1:230a86c:         if (info.getDestination().isTemporary()) {
1:da7478d:             cs.addTempDestination(info);
1:230a86c:         }
1:da7478d:         return null;
1:230a86c:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processRemoveDestination(DestinationInfo info) throws Exception {
1:230a86c:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:230a86c:         broker.removeDestinationInfo(cs.getContext(), info);
1:230a86c:         if (info.getDestination().isTemporary()) {
1:da7478d:             cs.removeTempDestination(info.getDestination());
1:230a86c:         }
1:da7478d:         return null;
1:230a86c:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processAddProducer(ProducerInfo info) throws Exception {
1:230a86c:         SessionId sessionId = info.getProducerId().getParentId();
1:230a86c:         ConnectionId connectionId = sessionId.getParentId();
1:230a86c:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:a3e3821:         if (cs == null) {
1:c856f30:             throw new IllegalStateException("Cannot add a producer to a connection that had not been registered: "
1:933eb2f:                     + connectionId);
1:230a86c:         }
1:230a86c:         SessionState ss = cs.getSessionState(sessionId);
1:ecf89a6:         if (ss == null) {
1:4228281:             throw new IllegalStateException("Cannot add a producer to a session that had not been registered: "
1:4228281:                     + sessionId);
1:ecf89a6:         }
1:da7478d:         // Avoid replaying dup commands
1:230a86c:         if (!ss.getProducerIds().contains(info.getProducerId())) {
1:74bed6b:             ActiveMQDestination destination = info.getDestination();
1:ec9a92f:             // Do not check for null here as it would cause the count of max producers to exclude
1:ec9a92f:             // anonymous producers.  The isAdvisoryTopic method checks for null so it is safe to
1:ec9a92f:             // call it from here with a null Destination value.
1:ec9a92f:             if (!AdvisorySupport.isAdvisoryTopic(destination)) {
1:74bed6b:                 if (getProducerCount(connectionId) >= connector.getMaximumProducersAllowedPerConnection()){
1:74bed6b:                     throw new IllegalStateException("Can't add producer on connection " + connectionId + ": at maximum limit: " + connector.getMaximumProducersAllowedPerConnection());
1:74bed6b:                 }
1:74bed6b:             }
1:230a86c:             broker.addProducer(cs.getContext(), info);
1:4c481ec:             try {
1:da7478d:                 ss.addProducer(info);
1:230a86c:             } catch (IllegalStateException e) {
1:230a86c:                 broker.removeProducer(cs.getContext(), info);
1:ecf89a6:             }
1:8b0f88a: 
1:ecf89a6:         }
1:da7478d:         return null;
1:ecf89a6:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processRemoveProducer(ProducerId id) throws Exception {
1:230a86c:         SessionId sessionId = id.getParentId();
1:230a86c:         ConnectionId connectionId = sessionId.getParentId();
1:230a86c:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:230a86c:         SessionState ss = cs.getSessionState(sessionId);
1:ecf89a6:         if (ss == null) {
1:4228281:             throw new IllegalStateException("Cannot remove a producer from a session that had not been registered: "
1:4228281:                     + sessionId);
1:230a86c:         }
1:230a86c:         ProducerState ps = ss.removeProducer(id);
1:ecf89a6:         if (ps == null) {
1:230a86c:             throw new IllegalStateException("Cannot remove a producer that had not been registered: " + id);
1:ecf89a6:         }
1:84eb9f8:         removeProducerBrokerExchange(id);
1:230a86c:         broker.removeProducer(cs.getContext(), ps.getInfo());
1:da7478d:         return null;
1:ea74731:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processAddConsumer(ConsumerInfo info) throws Exception {
1:230a86c:         SessionId sessionId = info.getConsumerId().getParentId();
1:230a86c:         ConnectionId connectionId = sessionId.getParentId();
1:230a86c:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:8732f70:         if (cs == null) {
1:c856f30:             throw new IllegalStateException("Cannot add a consumer to a connection that had not been registered: "
1:933eb2f:                     + connectionId);
1:ea74731:         }
1:230a86c:         SessionState ss = cs.getSessionState(sessionId);
1:ecf89a6:         if (ss == null) {
1:4228281:             throw new IllegalStateException(broker.getBrokerName()
1:4228281:                     + " Cannot add a consumer to a session that had not been registered: " + sessionId);
1:ea74731:         }
1:da7478d:         // Avoid replaying dup commands
1:230a86c:         if (!ss.getConsumerIds().contains(info.getConsumerId())) {
1:74bed6b:             ActiveMQDestination destination = info.getDestination();
1:74bed6b:             if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination)) {
1:74bed6b:                 if (getConsumerCount(connectionId) >= connector.getMaximumConsumersAllowedPerConnection()){
1:74bed6b:                     throw new IllegalStateException("Can't add consumer on connection " + connectionId + ": at maximum limit: " + connector.getMaximumConsumersAllowedPerConnection());
1:74bed6b:                 }
1:74bed6b:             }
1:74bed6b: 
1:230a86c:             broker.addConsumer(cs.getContext(), info);
1:01bdc52:             try {
1:da7478d:                 ss.addConsumer(info);
1:98d2000:                 addConsumerBrokerExchange(cs, info.getConsumerId());
1:230a86c:             } catch (IllegalStateException e) {
1:230a86c:                 broker.removeConsumer(cs.getContext(), info);
1:ea74731:             }
1:74bed6b: 
1:ea74731:         }
1:da7478d:         return null;
1:ea74731:     }
1:74bed6b: 
1:ae61847:     @Override
1:3b08860:     public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) throws Exception {
1:230a86c:         SessionId sessionId = id.getParentId();
1:230a86c:         ConnectionId connectionId = sessionId.getParentId();
1:230a86c:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:a3e3821:         if (cs == null) {
1:8732f70:             throw new IllegalStateException("Cannot remove a consumer from a connection that had not been registered: "
1:8732f70:                     + connectionId);
1:8732f70:         }
1:230a86c:         SessionState ss = cs.getSessionState(sessionId);
1:ecf89a6:         if (ss == null) {
1:4228281:             throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: "
1:4228281:                     + sessionId);
1:ea74731:         }
1:230a86c:         ConsumerState consumerState = ss.removeConsumer(id);
1:ecf89a6:         if (consumerState == null) {
1:230a86c:             throw new IllegalStateException("Cannot remove a consumer that had not been registered: " + id);
1:ecf89a6:         }
1:3b08860:         ConsumerInfo info = consumerState.getInfo();
1:3b08860:         info.setLastDeliveredSequenceId(lastDeliveredSequenceId);
1:230a86c:         broker.removeConsumer(cs.getContext(), consumerState.getInfo());
1:84eb9f8:         removeConsumerBrokerExchange(id);
1:da7478d:         return null;
1:ea74731:     }
1:8b0f88a: 
1:ae61847:     @Override
1:27ded73:     public Response processAddSession(SessionInfo info) throws Exception {
1:230a86c:         ConnectionId connectionId = info.getSessionId().getParentId();
1:230a86c:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:da7478d:         // Avoid replaying dup commands
1:0ed0ba5:         if (cs != null && !cs.getSessionIds().contains(info.getSessionId())) {
1:230a86c:             broker.addSession(cs.getContext(), info);
1:230a86c:             try {
1:da7478d:                 cs.addSession(info);
1:230a86c:             } catch (IllegalStateException e) {
1:457dbd8:                 LOG.warn("Failed to add session: {}", info.getSessionId(), e);
1:230a86c:                 broker.removeSession(cs.getContext(), info);
1:ea74731:             }
1:ea74731:         }
1:da7478d:         return null;
1:ea74731:     }
1:8b0f88a: 
1:ae61847:     @Override
1:3b08860:     public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) throws Exception {
1:230a86c:         ConnectionId connectionId = id.getParentId();
1:230a86c:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:8732f70:         if (cs == null) {
1:8732f70:             throw new IllegalStateException("Cannot remove session from connection that had not been registered: " + connectionId);
1:8732f70:         }
1:230a86c:         SessionState session = cs.getSessionState(id);
1:ecf89a6:         if (session == null) {
1:230a86c:             throw new IllegalStateException("Cannot remove session that had not been registered: " + id);
1:ecf89a6:         }
1:230a86c:         // Don't let new consumers or producers get added while we are closing
1:230a86c:         // this down.
1:da7478d:         session.shutdown();
1:da7478d:         // Cascade the connection stop to the consumers and producers.
1:c856f30:         for (ConsumerId consumerId : session.getConsumerIds()) {
1:230a86c:             try {
1:3b08860:                 processRemoveConsumer(consumerId, lastDeliveredSequenceId);
1:01bdc52:             } catch (Throwable e) {
1:e1bbde7:                 LOG.warn("Failed to remove consumer: {}", consumerId, e);
1:ea74731:             }
1:ea74731:         }
1:c856f30:         for (ProducerId producerId : session.getProducerIds()) {
1:230a86c:             try {
1:da7478d:                 processRemoveProducer(producerId);
3:230a86c:             } catch (Throwable e) {
1:e1bbde7:                 LOG.warn("Failed to remove producer: {}", producerId, e);
5:ea74731:             }
1:ea74731:         }
1:da7478d:         cs.removeSession(id);
1:230a86c:         broker.removeSession(cs.getContext(), session.getInfo());
1:da7478d:         return null;
1:8b0f88a:     }
1:43d2ef0: 
1:ae61847:     @Override
1:27ded73:     public Response processAddConnection(ConnectionInfo info) throws Exception {
1:4228281:         // Older clients should have been defaulting this field to true.. but
1:4228281:         // they were not.
1:4228281:         if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {
1:3d024d6:             info.setClientMaster(true);
1:3d024d6:         }
1:ea74731:         TransportConnectionState state;
1:230a86c:         // Make sure 2 concurrent connections by the same ID only generate 1
1:230a86c:         // TransportConnectionState object.
1:230a86c:         synchronized (brokerConnectionStates) {
1:4228281:             state = (TransportConnectionState) brokerConnectionStates.get(info.getConnectionId());
1:230a86c:             if (state == null) {
1:230a86c:                 state = new TransportConnectionState(info, this);
1:230a86c:                 brokerConnectionStates.put(info.getConnectionId(), state);
1:230a86c:             }
1:230a86c:             state.incrementReference();
1:ea74731:         }
1:230a86c:         // If there are 2 concurrent connections for the same connection id,
1:230a86c:         // then last one in wins, we need to sync here
1:ea74731:         // to figure out the winner.
1:a9119ec:         synchronized (state.getConnectionMutex()) {
1:230a86c:             if (state.getConnection() != this) {
1:e1bbde7:                 LOG.debug("Killing previous stale connection: {}", state.getConnection().getRemoteAddress());
1:8b0f88a:                 state.getConnection().stop();
1:e1bbde7:                 LOG.debug("Connection {} taking over previous connection: {}", getRemoteAddress(), state.getConnection().getRemoteAddress());
1:230a86c:                 state.setConnection(this);
1:230a86c:                 state.reset(info);
1:8b0f88a:             }
1:8b0f88a:         }
1:230a86c:         registerConnectionState(info.getConnectionId(), state);
1:e1bbde7:         LOG.debug("Setting up new connection id: {}, address: {}, info: {}", new Object[]{ info.getConnectionId(), getRemoteAddress(), info });
1:3a71f8e:         this.faultTolerantConnection = info.isFaultTolerant();
1:da7478d:         // Setup the context.
1:230a86c:         String clientId = info.getClientId();
1:230a86c:         context = new ConnectionContext();
1:da7478d:         context.setBroker(broker);
1:da7478d:         context.setClientId(clientId);
1:83a6eff:         context.setClientMaster(info.isClientMaster());
1:da7478d:         context.setConnection(this);
1:da7478d:         context.setConnectionId(info.getConnectionId());
1:da7478d:         context.setConnector(connector);
1:a28ccae:         context.setMessageAuthorizationPolicy(getMessageAuthorizationPolicy());
1:49ea0ed:         context.setNetworkConnection(networkConnection);
1:25b6812:         context.setFaultTolerant(faultTolerantConnection);
1:933eb2f:         context.setTransactions(new ConcurrentHashMap<TransactionId, Transaction>());
1:da7478d:         context.setUserName(info.getUserName());
1:da7478d:         context.setWireFormatInfo(wireFormatInfo);
1:a6a6a70:         context.setReconnect(info.isFailoverReconnect());
1:230a86c:         this.manageable = info.isManageable();
1:d4ccc50:         context.setConnectionState(state);
1:ea74731:         state.setContext(context);
1:230a86c:         state.setConnection(this);
1:fd6c731:         if (info.getClientIp() == null) {
1:fd6c731:             info.setClientIp(getRemoteAddress());
1:ea74731:         }
1:f392884: 
1:7b1fd34:         try {
1:4228281:             broker.addConnection(context, info);
1:4228281:         } catch (Exception e) {
1:69f5605:             synchronized (brokerConnectionStates) {
1:69f5605:                 brokerConnectionStates.remove(info.getConnectionId());
1:69f5605:             }
1:f93d05a:             unregisterConnectionState(info.getConnectionId());
1:c29d747:             LOG.warn("Failed to add Connection id={}, clientId={} due to {}", info.getConnectionId(), clientId, e.getLocalizedMessage(), e);
1:d9c74d7:             //AMQ-6561 - stop for all exceptions on addConnection
1:d9c74d7:             // close this down - in case the peer of this transport doesn't play nice
1:d9c74d7:             delayedStop(2000, "Failed with SecurityException: " + e.getLocalizedMessage(), e);
1:4228281:             throw e;
1:c9b49d8:         }
1:f392884:         if (info.isManageable()) {
1:8b0f88a:             // send ConnectionCommand
1:f392884:             ConnectionControl command = this.connector.getConnectionControl();
1:da7478d:             command.setFaultTolerant(broker.isFaultTolerantConfiguration());
1:2280719:             if (info.isFailoverReconnect()) {
1:2280719:                 command.setRebalanceConnection(false);
1:7739a3c:             }
1:da7478d:             dispatchAsync(command);
1:7b1fd34:         }
1:da7478d:         return null;
1:230a86c:     }
1:8b0f88a: 
1:ae61847:     @Override
1:4228281:     public synchronized Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId)
1:4228281:             throws InterruptedException {
1:e1bbde7:         LOG.debug("remove connection id: {}", id);
1:230a86c:         TransportConnectionState cs = lookupConnectionState(id);
1:5e747b0:         if (cs != null) {
1:4228281:             // Don't allow things to be added to the connection state while we
1:802f6b1:             // are shutting down.
1:5e747b0:             cs.shutdown();
1:5e747b0:             // Cascade the connection stop to the sessions.
1:c856f30:             for (SessionId sessionId : cs.getSessionIds()) {
1:5e747b0:                 try {
1:3b08860:                     processRemoveSession(sessionId, lastDeliveredSequenceId);
1:5e747b0:                 } catch (Throwable e) {
1:e1bbde7:                     SERVICELOG.warn("Failed to remove session {}", sessionId, e);
1:5e747b0:                 }
1:ea74731:             }
1:5e747b0:             // Cascade the connection stop to temp destinations.
1:c856f30:             for (Iterator<DestinationInfo> iter = cs.getTempDestinations().iterator(); iter.hasNext(); ) {
1:c856f30:                 DestinationInfo di = iter.next();
1:5e747b0:                 try {
1:5e747b0:                     broker.removeDestination(cs.getContext(), di.getDestination(), 0);
1:5e747b0:                 } catch (Throwable e) {
1:e1bbde7:                     SERVICELOG.warn("Failed to remove tmp destination {}", di.getDestination(), e);
1:5e747b0:                 }
1:5e747b0:                 iter.remove();
1:5e747b0:             }
1:5e747b0:             try {
1:e19293d:                 broker.removeConnection(cs.getContext(), cs.getInfo(), transportException.get());
1:5e747b0:             } catch (Throwable e) {
1:e1bbde7:                 SERVICELOG.warn("Failed to remove connection {}", cs.getInfo(), e);
1:ea74731:             }
1:5e747b0:             TransportConnectionState state = unregisterConnectionState(id);
1:5e747b0:             if (state != null) {
1:5e747b0:                 synchronized (brokerConnectionStates) {
1:5e747b0:                     // If we are the last reference, we should remove the state
1:5e747b0:                     // from the broker.
1:5e747b0:                     if (state.decrementReference() == 0) {
1:5e747b0:                         brokerConnectionStates.remove(id);
1:5e747b0:                     }
1:ea74731:                 }
1:ea74731:             }
1:ea74731:         }
1:da7478d:         return null;
1:ea74731:     }
1:1f521da: 
1:ae61847:     @Override
1:ec14f65:     public Response processProducerAck(ProducerAck ack) throws Exception {
1:230a86c:         // A broker should not get ProducerAck messages.
1:230a86c:         return null;
1:230a86c:     }
1:31a87ac: 
1:ae61847:     @Override
1:230a86c:     public Connector getConnector() {
1:da7478d:         return connector;
1:ea74731:     }
1:31a87ac: 
1:ae61847:     @Override
1:230a86c:     public void dispatchSync(Command message) {
1:230a86c:         try {
1:da7478d:             processDispatch(message);
2:015cd8a:         } catch (IOException e) {
1:cafe4cb:             serviceExceptionAsync(e);
1:230a86c:         }
1:230a86c:     }
1:8b0f88a: 
1:ae61847:     @Override
1:230a86c:     public void dispatchAsync(Command message) {
1:4c481ec:         if (!stopping.get()) {
1:230a86c:             if (taskRunner == null) {
1:8b0f88a:                 dispatchSync(message);
1:230a86c:             } else {
1:4228281:                 synchronized (dispatchQueue) {
1:372f69a:                     dispatchQueue.add(message);
1:372f69a:                 }
1:230a86c:                 try {
1:eccb337:                     taskRunner.wakeup();
1:f67415d:                 } catch (InterruptedException e) {
1:da7478d:                     Thread.currentThread().interrupt();
1:f67415d:                 }
1:8b0f88a:             }
1:230a86c:         } else {
1:230a86c:             if (message.isMessageDispatch()) {
1:4228281:                 MessageDispatch md = (MessageDispatch) message;
1:ae61847:                 TransmitCallback sub = md.getTransmitCallback();
1:a401575:                 broker.postProcessDispatch(md);
1:3953b9a:                 if (sub != null) {
1:ae61847:                     sub.onFailure();
1:3953b9a:                 }
1:3953b9a:             }
1:3953b9a:         }
1:2984963:     }
1:3953b9a: 
1:230a86c:     protected void processDispatch(Command command) throws IOException {
1:ae61847:         MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);
1:230a86c:         try {
1:4c481ec:             if (!stopping.get()) {
1:230a86c:                 if (messageDispatch != null) {
1:52e1a05:                     try {
1:52e1a05:                         broker.preProcessDispatch(messageDispatch);
1:52e1a05:                     } catch (RuntimeException convertToIO) {
1:52e1a05:                         throw new IOException(convertToIO);
1:52e1a05:                     }
1:a401575:                 }
1:a401575:                 dispatch(command);
1:8b0f88a:             }
1:1958aeb:         } catch (IOException e) {
1:230a86c:             if (messageDispatch != null) {
1:ae61847:                 TransmitCallback sub = messageDispatch.getTransmitCallback();
1:a401575:                 broker.postProcessDispatch(messageDispatch);
1:2984963:                 if (sub != null) {
1:ae61847:                     sub.onFailure();
1:a401575:                 }
1:ae61847:                 messageDispatch = null;
1:7b1fd34:                 throw e;
1:b6521e2:             } else {
1:b6521e2:                 if (TRANSPORTLOG.isDebugEnabled()) {
1:b6521e2:                     TRANSPORTLOG.debug("Unexpected exception on asyncDispatch, command of type: " + command.getDataStructureType(), e);
1:b6521e2:                 }
1:2984963:             }
1:4c481ec:         } finally {
1:ae61847:             if (messageDispatch != null) {
1:ae61847:                 TransmitCallback sub = messageDispatch.getTransmitCallback();
1:ae61847:                 broker.postProcessDispatch(messageDispatch);
3:230a86c:                 if (sub != null) {
1:ae61847:                     sub.onSuccess();
1:2984963:                 }
1:230a86c:             }
1:230a86c:         }
1:230a86c:     }
1:8b0f88a: 
1:ae61847:     @Override
1:230a86c:     public boolean iterate() {
1:230a86c:         try {
1:bdec3f6:             if (pendingStop.get() || stopping.get()) {
1:230a86c:                 if (dispatchStopped.compareAndSet(false, true)) {
1:230a86c:                     if (transportException.get() == null) {
1:230a86c:                         try {
1:230a86c:                             dispatch(new ShutdownInfo());
2:230a86c:                         } catch (Throwable ignore) {
1:230a86c:                         }
1:230a86c:                     }
1:230a86c:                     dispatchStoppedLatch.countDown();
1:230a86c:                 }
2:230a86c:                 return false;
1:230a86c:             }
1:230a86c:             if (!dispatchStopped.get()) {
1:372f69a:                 Command command = null;
1:4228281:                 synchronized (dispatchQueue) {
1:372f69a:                     if (dispatchQueue.isEmpty()) {
1:372f69a:                         return false;
1:372f69a:                     }
1:372f69a:                     command = dispatchQueue.remove(0);
1:230a86c:                 }
1:8b0f88a:                 processDispatch(command);
1:98cd515:                 return true;
1:8b0f88a:             }
1:98cd515:             return false;
1:230a86c:         } catch (IOException e) {
1:230a86c:             if (dispatchStopped.compareAndSet(false, true)) {
1:230a86c:                 dispatchStoppedLatch.countDown();
1:230a86c:             }
1:230a86c:             serviceExceptionAsync(e);
1:230a86c:             return false;
1:230a86c:         }
1:230a86c:     }
1:8b0f88a: 
1:da7478d:     /**
1:da7478d:      * Returns the statistics for this connection
1:da7478d:      */
1:ae61847:     @Override
1:230a86c:     public ConnectionStatistics getStatistics() {
1:da7478d:         return statistics;
1:230a86c:     }
1:eccb337: 
1:230a86c:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {
1:da7478d:         return messageAuthorizationPolicy;
1:230a86c:     }
1:8b0f88a: 
1:230a86c:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {
1:230a86c:         this.messageAuthorizationPolicy = messageAuthorizationPolicy;
1:230a86c:     }
1:4c481ec: 
1:ae61847:     @Override
1:230a86c:     public boolean isManageable() {
1:da7478d:         return manageable;
1:230a86c:     }
1:8b0f88a: 
1:ae61847:     @Override
1:0302ffd:     public void start() throws Exception {
1:230a86c:         try {
1:4228281:             synchronized (this) {
1:bdec3f6:                 starting.set(true);
1:4228281:                 if (taskRunnerFactory != null) {
1:4228281:                     taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: "
1:4228281:                             + getRemoteAddress());
1:4228281:                 } else {
1:4228281:                     taskRunner = null;
1:4228281:                 }
1:4228281:                 transport.start();
1:4228281:                 active = true;
1:f392884:                 BrokerInfo info = connector.getBrokerInfo().copy();
1:bf4dd73:                 if (connector.isUpdateClusterClients()) {
1:bf4dd73:                     info.setPeerBrokerInfos(this.broker.getPeerBrokerInfos());
1:bf4dd73:                 } else {
1:bf4dd73:                     info.setPeerBrokerInfos(null);
1:bf4dd73:                 }
1:f392884:                 dispatchAsync(info);
1:f392884: 
1:4228281:                 connector.onStarted(this);
1:4228281:             }
1:ada47fb:         } catch (Exception e) {
1:ada47fb:             // Force clean up on an error starting up.
1:bdec3f6:             pendingStop.set(true);
1:ada47fb:             throw e;
2:230a86c:         } finally {
1:4b595ea:             // stop() can be called from within the above block,
1:4b595ea:             // but we want to be sure start() completes before
1:4b595ea:             // stop() runs, so queue the stop until right now:
1:4cf6dae:             setStarting(false);
1:4cf6dae:             if (isPendingStop()) {
1:e1bbde7:                 LOG.debug("Calling the delayed stop() after start() {}", this);
1:ada47fb:                 stop();
1:0302ffd:             }
1:0302ffd:         }
1:230a86c:     }
1:4c481ec: 
1:ae61847:     @Override
1:230a86c:     public void stop() throws Exception {
1:8a01c5d:         // do not stop task the task runner factories (taskRunnerFactory, stopTaskRunnerFactory)
1:8a01c5d:         // as their lifecycle is handled elsewhere
1:4c481ec: 
1:4c481ec:         stopAsync();
1:4228281:         while (!stopped.await(5, TimeUnit.SECONDS)) {
1:e1bbde7:             LOG.info("The connection to '{}' is taking a long time to shutdown.", transport.getRemoteAddress());
1:4098942:         }
1:0302ffd:     }
1:4228281: 
1:5cc1a55:     public void delayedStop(final int waitTime, final String reason, Throwable cause) {
1:3a71f8e:         if (waitTime > 0) {
1:0302ffd:             synchronized (this) {
1:bdec3f6:                 pendingStop.set(true);
1:e19293d:                 transportException.set(cause);
1:0302ffd:             }
1:3a71f8e:             try {
1:8a01c5d:                 stopTaskRunnerFactory.execute(new Runnable() {
1:ae61847:                     @Override
1:3a71f8e:                     public void run() {
1:3a71f8e:                         try {
1:3a71f8e:                             Thread.sleep(waitTime);
1:3a71f8e:                             stopAsync();
1:e1bbde7:                             LOG.info("Stopping {} because {}", transport.getRemoteAddress(), reason);
1:3a71f8e:                         } catch (InterruptedException e) {
1:3a71f8e:                         }
1:3a71f8e:                     }
1:8a01c5d:                 });
1:3a71f8e:             } catch (Throwable t) {
1:8a01c5d:                 LOG.warn("Cannot create stopAsync. This exception will be ignored.", t);
1:3a71f8e:             }
1:3a71f8e:         }
1:3a71f8e:     }
1:3a71f8e: 
1:e19293d:     public void stopAsync(Throwable cause) {
1:e19293d:         transportException.set(cause);
1:e19293d:         stopAsync();
1:e19293d:     }
1:e19293d: 
1:4c481ec:     public void stopAsync() {
1:4cf6dae:         // If we're in the middle of starting then go no further... for now.
1:4cf6dae:         synchronized (this) {
1:bdec3f6:             pendingStop.set(true);
1:bdec3f6:             if (starting.get()) {
1:4cf6dae:                 LOG.debug("stopAsync() called in the middle of start(). Delaying till start completes..");
1:4cf6dae:                 return;
1:4cf6dae:             }
1:4cf6dae:         }
1:4c481ec:         if (stopping.compareAndSet(false, true)) {
1:31a87ac:             // Let all the connection contexts know we are shutting down
1:31a87ac:             // so that in progress operations can notice and unblock.
1:31a87ac:             List<TransportConnectionState> connectionStates = listConnectionStates();
1:31a87ac:             for (TransportConnectionState cs : connectionStates) {
1:ac54a61:                 ConnectionContext connectionContext = cs.getContext();
1:ac54a61:                 if (connectionContext != null) {
1:ac54a61:                     connectionContext.getStopping().set(true);
1:ac54a61:                 }
1:8b0f88a:             }
1:4c481ec:             try {
1:8a01c5d:                 stopTaskRunnerFactory.execute(new Runnable() {
1:4c481ec:                     @Override
1:4c481ec:                     public void run() {
1:c808beb:                         serviceLock.writeLock().lock();
1:c808beb:                         try {
1:c808beb:                             doStop();
1:c808beb:                         } catch (Throwable e) {
1:e1bbde7:                             LOG.debug("Error occurred while shutting down a connection {}", this, e);
1:c808beb:                         } finally {
1:c808beb:                             stopped.countDown();
1:c808beb:                             serviceLock.writeLock().unlock();
1:c808beb:                         }
1:1987cfa:                     }
1:1f521da:                 });
1:c808beb:             } catch (Throwable t) {
1:8a01c5d:                 LOG.warn("Cannot create async transport stopper thread. This exception is ignored. Not waiting for stop to complete", t);
1:c808beb:                 stopped.countDown();
1:8b0f88a:             }
1:8b0f88a:         }
1:8b0f88a:     }
1:3a71f8e: 
1:4c481ec:     @Override
1:4c481ec:     public String toString() {
1:4228281:         return "Transport Connection to: " + transport.getRemoteAddress();
1:4c481ec:     }
1:4228281: 
1:8a01c5d:     protected void doStop() throws Exception {
1:8a01c5d:         LOG.debug("Stopping connection: {}", transport.getRemoteAddress());
1:8b0f88a:         connector.onStopped(this);
1:230a86c:         try {
2:230a86c:             synchronized (this) {
1:ae73f86:                 if (duplexBridge != null) {
1:a3e3821:                     duplexBridge.stop();
1:a3e3821:                 }
1:a3e3821:             }
1:4098942:         } catch (Exception ignore) {
1:8a01c5d:             LOG.trace("Exception caught stopping. This exception is ignored.", ignore);
1:ae73f86:         }
1:2984963:         try {
1:83a6eff:             transport.stop();
1:e1bbde7:             LOG.debug("Stopped transport: {}", transport.getRemoteAddress());
1:2984963:         } catch (Exception e) {
1:e1bbde7:             LOG.debug("Could not stop transport to {}. This exception is ignored.", transport.getRemoteAddress(), e);
1:83a6eff:         }
2:2984963:         if (taskRunner != null) {
1:0302ffd:             taskRunner.shutdown(1);
1:0302ffd:             taskRunner = null;
1:83a6eff:         }
1:2984963:         active = false;
1:2984963:         // Run the MessageDispatch callbacks so that message references get
1:2984963:         // cleaned up.
1:4228281:         synchronized (dispatchQueue) {
1:3a71f8e:             for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext(); ) {
1:372f69a:                 Command command = iter.next();
1:372f69a:                 if (command.isMessageDispatch()) {
1:4228281:                     MessageDispatch md = (MessageDispatch) command;
1:ae61847:                     TransmitCallback sub = md.getTransmitCallback();
1:372f69a:                     broker.postProcessDispatch(md);
1:372f69a:                     if (sub != null) {
1:ae61847:                         sub.onFailure();
1:372f69a:                     }
1:83a6eff:                 }
1:8b0f88a:             }
1:372f69a:             dispatchQueue.clear();
1:8b0f88a:         }
1:8b0f88a:         //
1:8b0f88a:         // Remove all logical connection associated with this connection
1:8b0f88a:         // from the broker.
1:2984963:         if (!broker.isStopped()) {
1:31a87ac:             List<TransportConnectionState> connectionStates = listConnectionStates();
1:2984963:             connectionStates = listConnectionStates();
1:2984963:             for (TransportConnectionState cs : connectionStates) {
1:31a87ac:                 cs.getContext().getStopping().set(true);
1:2984963:                 try {
1:8a01c5d:                     LOG.debug("Cleaning up connection resources: {}", getRemoteAddress());
1:eb6c082:                     processRemoveConnection(cs.getInfo().getConnectionId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);
1:2984963:                 } catch (Throwable ignore) {
1:457dbd8:                     LOG.debug("Exception caught removing connection {}. This exception is ignored.", cs.getInfo().getConnectionId(), ignore);
1:c808beb:                 }
1:8b0f88a:             }
1:8b0f88a:         }
1:8a01c5d:         LOG.debug("Connection Stopped: {}", getRemoteAddress());
1:8b0f88a:     }
1:83a6eff: 
1:d29ca2a:     /**
1:230a86c:      * @return Returns the blockedCandidate.
1:230a86c:      */
1:230a86c:     public boolean isBlockedCandidate() {
1:d29ca2a:         return blockedCandidate;
1:8b0f88a:     }
1:83a6eff: 
1:d29ca2a:     /**
1:3a71f8e:      * @param blockedCandidate The blockedCandidate to set.
1:230a86c:      */
1:230a86c:     public void setBlockedCandidate(boolean blockedCandidate) {
1:230a86c:         this.blockedCandidate = blockedCandidate;
1:31a87ac:     }
1:a3e3821: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the markedCandidate.
1:ea74731:      */
1:230a86c:     public boolean isMarkedCandidate() {
1:d29ca2a:         return markedCandidate;
1:4c481ec:     }
1:31a87ac: 
1:d29ca2a:     /**
1:3a71f8e:      * @param markedCandidate The markedCandidate to set.
1:ea74731:      */
1:230a86c:     public void setMarkedCandidate(boolean markedCandidate) {
1:230a86c:         this.markedCandidate = markedCandidate;
1:230a86c:         if (!markedCandidate) {
1:230a86c:             timeStamp = 0;
1:230a86c:             blockedCandidate = false;
1:4c481ec:         }
1:2984963:     }
1:4c481ec: 
1:d29ca2a:     /**
1:3a71f8e:      * @param slow The slow to set.
1:d29ca2a:      */
1:230a86c:     public void setSlow(boolean slow) {
1:230a86c:         this.slow = slow;
1:2984963:     }
1:4c481ec: 
1:d29ca2a:     /**
1:d29ca2a:      * @return true if the Connection is slow
1:d29ca2a:      */
1:ae61847:     @Override
1:230a86c:     public boolean isSlow() {
1:d29ca2a:         return slow;
1:2984963:     }
1:2984963: 
1:d29ca2a:     /**
1:d29ca2a:      * @return true if the Connection is potentially blocked
1:d29ca2a:      */
1:230a86c:     public boolean isMarkedBlockedCandidate() {
1:d29ca2a:         return markedCandidate;
1:230a86c:     }
1:2984963: 
1:d29ca2a:     /**
1:d29ca2a:      * Mark the Connection, so we can deem if it's collectable on the next sweep
1:d29ca2a:      */
1:230a86c:     public void doMark() {
1:230a86c:         if (timeStamp == 0) {
1:230a86c:             timeStamp = System.currentTimeMillis();
1:230a86c:         }
1:230a86c:     }
1:2984963: 
1:d29ca2a:     /**
1:d29ca2a:      * @return if after being marked, the Connection is still writing
1:d29ca2a:      */
1:ae61847:     @Override
1:230a86c:     public boolean isBlocked() {
1:d29ca2a:         return blocked;
1:230a86c:     }
1:2984963: 
1:d29ca2a:     /**
1:d29ca2a:      * @return true if the Connection is connected
1:d29ca2a:      */
1:ae61847:     @Override
1:230a86c:     public boolean isConnected() {
1:d29ca2a:         return connected;
1:230a86c:     }
1:2984963: 
1:d29ca2a:     /**
1:3a71f8e:      * @param blocked The blocked to set.
1:d29ca2a:      */
1:230a86c:     public void setBlocked(boolean blocked) {
1:230a86c:         this.blocked = blocked;
1:230a86c:     }
1:2984963: 
1:d29ca2a:     /**
1:3a71f8e:      * @param connected The connected to set.
1:d29ca2a:      */
1:230a86c:     public void setConnected(boolean connected) {
1:230a86c:         this.connected = connected;
1:230a86c:     }
1:2984963: 
1:d29ca2a:     /**
1:d29ca2a:      * @return true if the Connection is active
1:d29ca2a:      */
1:ae61847:     @Override
1:230a86c:     public boolean isActive() {
1:d29ca2a:         return active;
1:ea74731:     }
1:3d024d6: 
1:d29ca2a:     /**
1:3a71f8e:      * @param active The active to set.
1:d29ca2a:      */
1:230a86c:     public void setActive(boolean active) {
1:230a86c:         this.active = active;
1:ea74731:     }
1:933eb2f: 
1:d29ca2a:     /**
1:4b595ea:      * @return true if the Connection is starting
1:d29ca2a:      */
1:bdec3f6:     public boolean isStarting() {
1:bdec3f6:         return starting.get();
1:ea74731:     }
1:933eb2f: 
1:ae61847:     @Override
1:25b6812:     public synchronized boolean isNetworkConnection() {
1:25b6812:         return networkConnection;
1:25b6812:     }
1:f392884: 
1:ae61847:     @Override
1:f392884:     public boolean isFaultTolerantConnection() {
1:3a71f8e:         return this.faultTolerantConnection;
1:f392884:     }
1:933eb2f: 
1:bdec3f6:     protected void setStarting(boolean starting) {
1:bdec3f6:         this.starting.set(starting);
1:ea74731:     }
1:933eb2f: 
1:d29ca2a:     /**
1:4b595ea:      * @return true if the Connection needs to stop
1:d29ca2a:      */
1:bdec3f6:     public boolean isPendingStop() {
1:bdec3f6:         return pendingStop.get();
1:ea74731:     }
1:ecf89a6: 
1:bdec3f6:     protected void setPendingStop(boolean pendingStop) {
1:bdec3f6:         this.pendingStop.set(pendingStop);
1:ea74731:     }
1:ecf89a6: 
1:3953b9a:     private NetworkBridgeConfiguration getNetworkConfiguration(final BrokerInfo info) throws IOException {
1:3953b9a:         Properties properties = MarshallingSupport.stringToProperties(info.getNetworkProperties());
1:3953b9a:         Map<String, String> props = createMap(properties);
1:3953b9a:         NetworkBridgeConfiguration config = new NetworkBridgeConfiguration();
1:3953b9a:         IntrospectionSupport.setProperties(config, props, "");
1:3953b9a:         return config;
1:3953b9a:     }
1:3953b9a: 
1:ae61847:     @Override
1:4098942:     public Response processBrokerInfo(BrokerInfo info) {
1:230a86c:         if (info.isSlaveBroker()) {
1:e1bbde7:             LOG.error(" Slave Brokers are no longer supported - slave trying to attach is: {}", info.getBrokerName());
1:3953b9a:         } else if (info.isNetworkConnection() && !info.isDuplexConnection()) {
1:3953b9a:             try {
1:3953b9a:                 NetworkBridgeConfiguration config = getNetworkConfiguration(info);
1:3953b9a:                 if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {
1:3953b9a:                     LOG.debug("SyncDurableSubs is enabled, Sending BrokerSubscriptionInfo");
1:d206621:                     dispatchSync(NetworkBridgeUtils.getBrokerSubscriptionInfo(this.broker.getBrokerService(), config));
1:3953b9a:                 }
1:3953b9a:             } catch (Exception e) {
1:3953b9a:                 LOG.error("Failed to respond to network bridge creation from broker {}", info.getBrokerId(), e);
1:3953b9a:                 return null;
1:3953b9a:             }
1:230a86c:         } else if (info.isNetworkConnection() && info.isDuplexConnection()) {
1:230a86c:             // so this TransportConnection is the rear end of a network bridge
1:230a86c:             // We have been requested to create a two way pipe ...
1:230a86c:             try {
1:3953b9a:                 NetworkBridgeConfiguration config = getNetworkConfiguration(info);
1:54114cc:                 config.setBrokerName(broker.getBrokerName());
1:3953b9a: 
1:d206621:                 if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {
1:3953b9a:                     LOG.debug("SyncDurableSubs is enabled, Sending BrokerSubscriptionInfo");
1:d206621:                     dispatchSync(NetworkBridgeUtils.getBrokerSubscriptionInfo(this.broker.getBrokerService(), config));
1:3953b9a:                 }
1:27d0ff4: 
1:27d0ff4:                 // check for existing duplex connection hanging about
1:27d0ff4: 
1:27d0ff4:                 // We first look if existing network connection already exists for the same broker Id and network connector name
1:27d0ff4:                 // It's possible in case of brief network fault to have this transport connector side of the connection always active
1:27d0ff4:                 // and the duplex network connector side wanting to open a new one
1:27d0ff4:                 // In this case, the old connection must be broken
1:27d0ff4:                 String duplexNetworkConnectorId = config.getName() + "@" + info.getBrokerId();
1:27d0ff4:                 CopyOnWriteArrayList<TransportConnection> connections = this.connector.getConnections();
1:27d0ff4:                 synchronized (connections) {
1:3a71f8e:                     for (Iterator<TransportConnection> iter = connections.iterator(); iter.hasNext(); ) {
1:27d0ff4:                         TransportConnection c = iter.next();
1:27d0ff4:                         if ((c != this) && (duplexNetworkConnectorId.equals(c.getDuplexNetworkConnectorId()))) {
1:e1bbde7:                             LOG.warn("Stopping an existing active duplex connection [{}] for network connector ({}).", c, duplexNetworkConnectorId);
1:27d0ff4:                             c.stopAsync();
1:27d0ff4:                             // better to wait for a bit rather than get connection id already in use and failure to start new bridge
1:27d0ff4:                             c.getStopped().await(1, TimeUnit.SECONDS);
1:27d0ff4:                         }
1:27d0ff4:                     }
1:27d0ff4:                     setDuplexNetworkConnectorId(duplexNetworkConnectorId);
1:27d0ff4:                 }
1:4ef1fc7:                 Transport localTransport = NetworkBridgeFactory.createLocalTransport(config, broker.getVmConnectorURI());
1:88d85ae:                 Transport remoteBridgeTransport = transport;
1:88d85ae:                 if (! (remoteBridgeTransport instanceof ResponseCorrelator)) {
1:88d85ae:                     // the vm transport case is already wrapped
1:88d85ae:                     remoteBridgeTransport = new ResponseCorrelator(remoteBridgeTransport);
1:88d85ae:                 }
1:2a2dcd5:                 String duplexName = localTransport.toString();
1:2a2dcd5:                 if (duplexName.contains("#")) {
1:2a2dcd5:                     duplexName = duplexName.substring(duplexName.lastIndexOf("#"));
1:6b4509c:                 }
1:fe9d99e:                 MBeanNetworkListener listener = new MBeanNetworkListener(brokerService, config, brokerService.createDuplexNetworkConnectorObjectName(duplexName));
1:2a2dcd5:                 listener.setCreatedByDuplex(true);
1:a8a032a:                 duplexBridge = config.getBridgeFactory().createNetworkBridge(config, localTransport, remoteBridgeTransport, listener);
1:fe9d99e:                 duplexBridge.setBrokerService(brokerService);
1:39184e2:                 //Need to set durableDestinations to properly restart subs when dynamicOnly=false
1:9f7d70b:                 duplexBridge.setDurableDestinations(NetworkConnector.getDurableTopicDestinations(
1:9f7d70b:                         broker.getDurableDestinations()));
1:9f7d70b: 
1:230a86c:                 // now turn duplex off this side
1:35ba427:                 info.setDuplexConnection(false);
1:54114cc:                 duplexBridge.setCreatedByDuplex(true);
1:4228281:                 duplexBridge.duplexStart(this, brokerInfo, info);
1:e1bbde7:                 LOG.info("Started responder end of duplex bridge {}", duplexNetworkConnectorId);
1:6b4509c:                 return null;
1:6b4509c:             } catch (TransportDisposedIOException e) {
1:e1bbde7:                 LOG.warn("Duplex bridge {} was stopped before it was correctly started.", duplexNetworkConnectorId);
1:27d0ff4:                 return null;
1:230a86c:             } catch (Exception e) {
1:e1bbde7:                 LOG.error("Failed to create responder end of duplex network bridge {}", duplexNetworkConnectorId, e);
1:35ba427:                 return null;
1:6b4509c:             }
1:4741136:         }
1:da7478d:         // We only expect to get one broker info command per connection
1:230a86c:         if (this.brokerInfo != null) {
1:e1bbde7:             LOG.warn("Unexpected extra broker info command received: {}", info);
1:4098942:         }
1:ea74731:         this.brokerInfo = info;
1:230a86c:         networkConnection = true;
1:2984963:         List<TransportConnectionState> connectionStates = listConnectionStates();
3:230a86c:         for (TransportConnectionState cs : connectionStates) {
1:230a86c:             cs.getContext().setNetworkConnection(true);
1:4098942:         }
1:230a86c:         return null;
1:230a86c:     }
1:35ba427: 
1:74bed6b:     @SuppressWarnings({"unchecked", "rawtypes"})
1:933eb2f:     private HashMap<String, String> createMap(Properties properties) {
1:933eb2f:         return new HashMap(properties);
1:933eb2f:     }
1:4098942: 
1:230a86c:     protected void dispatch(Command command) throws IOException {
8:230a86c:         try {
1:d29ca2a:             setMarkedCandidate(true);
1:d29ca2a:             transport.oneway(command);
1:230a86c:         } finally {
1:d29ca2a:             setMarkedCandidate(false);
1:75af5fa:         }
1:ea74731:     }
1:4098942: 
1:ae61847:     @Override
1:230a86c:     public String getRemoteAddress() {
1:4b595ea:         return transport.getRemoteAddress();
1:84eb9f8:     }
1:84eb9f8: 
1:7c63788:     public Transport getTransport() {
1:7c63788:         return transport;
1:7c63788:     }
1:7c63788: 
1:ae61847:     @Override
1:015cd8a:     public String getConnectionId() {
3:230a86c:         List<TransportConnectionState> connectionStates = listConnectionStates();
1:230a86c:         for (TransportConnectionState cs : connectionStates) {
1:ecf89a6:             if (cs.getInfo().getClientId() != null) {
1:230a86c:                 return cs.getInfo().getClientId();
1:ecf89a6:             }
1:230a86c:             return cs.getInfo().getConnectionId().toString();
1:230a86c:         }
1:230a86c:         return null;
1:230a86c:     }
1:ecf89a6: 
1:ae61847:     @Override
1:f392884:     public void updateClient(ConnectionControl control) {
1:f392884:         if (isActive() && isBlocked() == false && isFaultTolerantConnection() && this.wireFormatInfo != null
1:f392884:                 && this.wireFormatInfo.getVersion() >= 6) {
1:f392884:             dispatchAsync(control);
1:f392884:         }
1:f392884:     }
1:74a7a8b: 
1:0736953:     public ProducerBrokerExchange getProducerBrokerExchangeIfExists(ProducerInfo producerInfo){
1:0736953:         ProducerBrokerExchange result = null;
1:0736953:         if (producerInfo != null && producerInfo.getProducerId() != null){
1:0736953:             synchronized (producerExchanges){
1:0736953:                 result = producerExchanges.get(producerInfo.getProducerId());
1:0736953:             }
1:0736953:         }
1:0736953:         return result;
1:0736953:     }
1:190a44b: 
1:a6a6a70:     private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {
1:230a86c:         ProducerBrokerExchange result = producerExchanges.get(id);
2:230a86c:         if (result == null) {
1:230a86c:             synchronized (producerExchanges) {
1:230a86c:                 result = new ProducerBrokerExchange();
1:a6a6a70:                 TransportConnectionState state = lookupConnectionState(id);
2:230a86c:                 context = state.getContext();
1:0018f4a:                 result.setConnectionContext(context);
1:0018f4a:                 if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {
1:fe9d99e:                     result.setLastStoredSequenceId(brokerService.getPersistenceAdapter().getLastProducerSequenceId(id));
1:a6a6a70:                 }
2:230a86c:                 SessionState ss = state.getSessionState(id.getParentId());
1:230a86c:                 if (ss != null) {
1:84eb9f8:                     result.setProducerState(ss.getProducerState(id));
1:230a86c:                     ProducerState producerState = ss.getProducerState(id);
1:230a86c:                     if (producerState != null && producerState.getInfo() != null) {
1:230a86c:                         ProducerInfo info = producerState.getInfo();
1:4228281:                         result.setMutable(info.getDestination() == null || info.getDestination().isComposite());
1:a3e3821:                     }
1:84eb9f8:                 }
1:230a86c:                 producerExchanges.put(id, result);
1:84eb9f8:             }
1:230a86c:         } else {
1:230a86c:             context = result.getConnectionContext();
1:84eb9f8:         }
1:84eb9f8:         return result;
1:84eb9f8:     }
1:0736953: 
1:84eb9f8:     private void removeProducerBrokerExchange(ProducerId id) {
1:230a86c:         synchronized (producerExchanges) {
1:84eb9f8:             producerExchanges.remove(id);
1:84eb9f8:         }
1:84eb9f8:     }
1:84eb9f8: 
1:84eb9f8:     private ConsumerBrokerExchange getConsumerBrokerExchange(ConsumerId id) {
1:84eb9f8:         ConsumerBrokerExchange result = consumerExchanges.get(id);
1:802f6b1:         return result;
1:ea74731:     }
1:84eb9f8: 
1:98d2000:     private ConsumerBrokerExchange addConsumerBrokerExchange(TransportConnectionState connectionState, ConsumerId id) {
1:230a86c:         ConsumerBrokerExchange result = consumerExchanges.get(id);
1:84eb9f8:         if (result == null) {
1:230a86c:             synchronized (consumerExchanges) {
1:84eb9f8:                 result = new ConsumerBrokerExchange();
1:98d2000:                 context = connectionState.getContext();
1:241971a:                 result.setConnectionContext(context);
1:98d2000:                 SessionState ss = connectionState.getSessionState(id.getParentId());
1:230a86c:                 if (ss != null) {
1:230a86c:                     ConsumerState cs = ss.getConsumerState(id);
1:230a86c:                     if (cs != null) {
1:230a86c:                         ConsumerInfo info = cs.getInfo();
1:230a86c:                         if (info != null) {
1:933eb2f:                             if (info.getDestination() != null && info.getDestination().isPattern()) {
1:2eaafc0:                                 result.setWildcard(true);
1:2eaafc0:                             }
1:2eaafc0:                         }
1:2eaafc0:                     }
1:2eaafc0:                 }
1:230a86c:                 consumerExchanges.put(id, result);
1:84eb9f8:             }
1:84eb9f8:         }
1:84eb9f8:         return result;
1:84eb9f8:     }
1:84eb9f8: 
1:84eb9f8:     private void removeConsumerBrokerExchange(ConsumerId id) {
1:230a86c:         synchronized (consumerExchanges) {
1:84eb9f8:             consumerExchanges.remove(id);
1:84eb9f8:         }
1:84eb9f8:     }
1:230a86c: 
1:230a86c:     public int getProtocolVersion() {
1:230a86c:         return protocolVersion.get();
1:230a86c:     }
1:230a86c: 
1:ae61847:     @Override
1:230a86c:     public Response processControlCommand(ControlCommand command) throws Exception {
1:98cd515:         return null;
1:ecf89a6:     }
1:230a86c: 
1:ae61847:     @Override
1:230a86c:     public Response processMessageDispatch(MessageDispatch dispatch) throws Exception {
1:230a86c:         return null;
1:230a86c:     }
2:230a86c: 
1:ae61847:     @Override
1:230a86c:     public Response processConnectionControl(ConnectionControl control) throws Exception {
1:4228281:         if (control != null) {
1:4228281:             faultTolerantConnection = control.isFaultTolerant();
1:25b6812:         }
1:230a86c:         return null;
1:230a86c:     }
1:230a86c: 
1:ae61847:     @Override
1:230a86c:     public Response processConnectionError(ConnectionError error) throws Exception {
1:230a86c:         return null;
1:230a86c:     }
1:230a86c: 
1:ae61847:     @Override
1:230a86c:     public Response processConsumerControl(ConsumerControl control) throws Exception {
1:8d3ca90:         ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(control.getConsumerId());
1:8d3ca90:         broker.processConsumerControl(consumerExchange, control);
1:230a86c:         return null;
1:230a86c:     }
1:230a86c: 
1:4228281:     protected synchronized TransportConnectionState registerConnectionState(ConnectionId connectionId,
1:3a71f8e:                                                                             TransportConnectionState state) {
1:a9119ec:         TransportConnectionState cs = null;
1:4228281:         if (!connectionStateRegister.isEmpty() && !connectionStateRegister.doesHandleMultipleConnectionStates()) {
1:4228281:             // swap implementations
1:4228281:             TransportConnectionStateRegister newRegister = new MapTransportConnectionStateRegister();
1:4228281:             newRegister.intialize(connectionStateRegister);
1:4228281:             connectionStateRegister = newRegister;
1:230a86c:         }
1:4228281:         cs = connectionStateRegister.registerConnectionState(connectionId, state);
1:4228281:         return cs;
1:8b0f88a:     }
1:8b0f88a: 
1:a9119ec:     protected synchronized TransportConnectionState unregisterConnectionState(ConnectionId connectionId) {
1:a9119ec:         return connectionStateRegister.unregisterConnectionState(connectionId);
1:8b0f88a:     }
1:8b0f88a: 
1:a9119ec:     protected synchronized List<TransportConnectionState> listConnectionStates() {
1:a9119ec:         return connectionStateRegister.listConnectionStates();
1:ecf89a6:     }
1:8b0f88a: 
1:a9119ec:     protected synchronized TransportConnectionState lookupConnectionState(String connectionId) {
1:4228281:         return connectionStateRegister.lookupConnectionState(connectionId);
1:6b4509c:     }
1:6b4509c: 
1:a9119ec:     protected synchronized TransportConnectionState lookupConnectionState(ConsumerId id) {
1:4228281:         return connectionStateRegister.lookupConnectionState(id);
1:6b4509c:     }
1:6b4509c: 
1:a9119ec:     protected synchronized TransportConnectionState lookupConnectionState(ProducerId id) {
1:4228281:         return connectionStateRegister.lookupConnectionState(id);
1:a9119ec:     }
1:a9119ec: 
1:a9119ec:     protected synchronized TransportConnectionState lookupConnectionState(SessionId id) {
3:a9119ec:         return connectionStateRegister.lookupConnectionState(id);
1:a9119ec:     }
1:a9119ec: 
1:8b3761c:     // public only for testing
1:8b3761c:     public synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {
2:a9119ec:         return connectionStateRegister.lookupConnectionState(connectionId);
1:230a86c:     }
1:8b0f88a: 
1:27d0ff4:     protected synchronized void setDuplexNetworkConnectorId(String duplexNetworkConnectorId) {
1:27d0ff4:         this.duplexNetworkConnectorId = duplexNetworkConnectorId;
1:230a86c:     }
1:8b0f88a: 
1:27d0ff4:     protected synchronized String getDuplexNetworkConnectorId() {
1:27d0ff4:         return this.duplexNetworkConnectorId;
1:27d0ff4:     }
1:27d0ff4: 
1:1ec9905:     public boolean isStopping() {
1:1ec9905:         return stopping.get();
1:230a86c:     }
1:8b0f88a: 
1:27d0ff4:     protected CountDownLatch getStopped() {
1:27d0ff4:         return stopped;
1:230a86c:     }
1:74bed6b: 
1:74bed6b:     private int getProducerCount(ConnectionId connectionId) {
1:74bed6b:         int result = 0;
1:74bed6b:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:74bed6b:         if (cs != null) {
1:74bed6b:             for (SessionId sessionId : cs.getSessionIds()) {
1:74bed6b:                 SessionState sessionState = cs.getSessionState(sessionId);
1:74bed6b:                 if (sessionState != null) {
1:74bed6b:                     result += sessionState.getProducerIds().size();
1:74bed6b:                 }
1:74bed6b:             }
1:74bed6b:         }
1:74bed6b:         return result;
1:74bed6b:     }
1:74bed6b: 
1:74bed6b:     private int getConsumerCount(ConnectionId connectionId) {
1:74bed6b:         int result = 0;
1:74bed6b:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:74bed6b:         if (cs != null) {
1:74bed6b:             for (SessionId sessionId : cs.getSessionIds()) {
1:74bed6b:                 SessionState sessionState = cs.getSessionState(sessionId);
1:74bed6b:                 if (sessionState != null) {
1:74bed6b:                     result += sessionState.getConsumerIds().size();
1:74bed6b:                 }
1:74bed6b:             }
1:74bed6b:         }
1:74bed6b:         return result;
1:74bed6b:     }
1:8b0f88a: 
1:190a44b:     public WireFormatInfo getRemoteWireFormatInfo() {
1:190a44b:         return wireFormatInfo;
1:190a44b:     }
1:3953b9a: 
1:3953b9a:     /* (non-Javadoc)
1:3953b9a:      * @see org.apache.activemq.state.CommandVisitor#processBrokerSubscriptionInfo(org.apache.activemq.command.BrokerSubscriptionInfo)
1:3953b9a:      */
1:3953b9a:     @Override
1:3953b9a:     public Response processBrokerSubscriptionInfo(BrokerSubscriptionInfo info) throws Exception {
1:3953b9a:         return null;
1:3953b9a:     }
1:ea74731: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:c29d747
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Failed to add Connection id={}, clientId={} due to {}", info.getConnectionId(), clientId, e.getLocalizedMessage(), e);
commit:0f7561e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.SubscriptionKey;
/////////////////////////////////////////////////////////////////////////
1:                     if (!brokerService.isStopping()) {
1:                         Response response = service(command);
1:                         if (response != null && !brokerService.isStopping()) {
1:                             dispatchSync(response);
1:                         }
1:                     } else {
1:                         throw new BrokerStoppedException("Broker " + brokerService + " is being stopped");
/////////////////////////////////////////////////////////////////////////
1:             if (!pendingStop.get()) {
1:                 response = new ExceptionResponse(transportException.get());
commit:4ef1fc7
/////////////////////////////////////////////////////////////////////////
1:                 Transport localTransport = NetworkBridgeFactory.createLocalTransport(config, broker.getVmConnectorURI());
commit:d84a586
/////////////////////////////////////////////////////////////////////////
0:                 Transport localTransport = NetworkBridgeFactory.createLocalTransport(broker.getVmConnectorURI());
commit:b6521e2
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 if (TRANSPORTLOG.isDebugEnabled()) {
1:                     TRANSPORTLOG.debug("Unexpected exception on asyncDispatch, command of type: " + command.getDataStructureType(), e);
1:                 }
commit:fe9d99e
/////////////////////////////////////////////////////////////////////////
1:     protected final BrokerService brokerService;
/////////////////////////////////////////////////////////////////////////
1:         this.brokerService = broker.getBrokerService();
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 forceRollbackOnlyOnFailedAsyncTransactionOp(e, command);
/////////////////////////////////////////////////////////////////////////
1:     private void forceRollbackOnlyOnFailedAsyncTransactionOp(Throwable e, Command command) {
1:         if (brokerService.isRollbackOnlyOnAsyncException() && !(e instanceof IOException) && isInTransaction(command)) {
1:             Transaction transaction = getActiveTransaction(command);
1:             if (transaction != null && !transaction.isRollbackOnly()) {
1:                 LOG.debug("on async exception, force rollback of transaction for: " + command, e);
1:                 transaction.setRollbackOnly(e);
1:             }
1:         }
1:     }
1: 
1:     private Transaction getActiveTransaction(Command command) {
1:         Transaction transaction = null;
1:         try {
1:             if (command instanceof Message) {
1:                 Message messageSend = (Message) command;
1:                 ProducerId producerId = messageSend.getProducerId();
1:                 ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
1:                 transaction = producerExchange.getConnectionContext().getTransactions().get(messageSend.getTransactionId());
1:             } else if (command instanceof  MessageAck) {
1:                 MessageAck messageAck = (MessageAck) command;
1:                 ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(messageAck.getConsumerId());
1:                 if (consumerExchange != null) {
1:                     transaction = consumerExchange.getConnectionContext().getTransactions().get(messageAck.getTransactionId());
1:                 }
1:             }
1:         } catch(Exception ignored){
1:             LOG.trace("failed to find active transaction for command: " + command, ignored);
1:         }
1:         return transaction;
1:     }
1: 
1:     private boolean isInTransaction(Command command) {
1:         return command instanceof Message && ((Message)command).isInTransaction()
1:                 || command instanceof MessageAck && ((MessageAck)command).isInTransaction();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 MBeanNetworkListener listener = new MBeanNetworkListener(brokerService, config, brokerService.createDuplexNetworkConnectorObjectName(duplexName));
1:                 duplexBridge.setBrokerService(brokerService);
/////////////////////////////////////////////////////////////////////////
1:                     result.setLastStoredSequenceId(brokerService.getPersistenceAdapter().getLastProducerSequenceId(id));
commit:b1ea29e
/////////////////////////////////////////////////////////////////////////
1:                 if (SERVICELOG.isDebugEnabled()) {
1:                     SERVICELOG.debug("Async error occurred: " + e, e);
1:                 } else {
1:                     SERVICELOG.warn("Async error occurred: " + e);
1:                 }
commit:eb6c082
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.RemoveInfo;
/////////////////////////////////////////////////////////////////////////
1:                     processRemoveConnection(cs.getInfo().getConnectionId(), RemoveInfo.LAST_DELIVERED_UNKNOWN);
commit:5313ad8
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to add Connection {} due to {}", info.getConnectionId(), e);
commit:b60bfbb
/////////////////////////////////////////////////////////////////////////
1:             if (TRANSPORTLOG.isDebugEnabled()) {
1:                 TRANSPORTLOG.debug(this + " failed: " + e, e);
1:             } else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {
1:                 TRANSPORTLOG.warn(this + " failed: " + e);
commit:8cf98a0
/////////////////////////////////////////////////////////////////////////
0:             if (! (e instanceof TransportDisposedIOException)) {
0:                 if (TRANSPORTLOG.isDebugEnabled()) {
0:                     TRANSPORTLOG.debug(this + " failed: " + e, e);
0:                 } else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {
0:                     TRANSPORTLOG.warn(this + " failed: " + e);
1:                 }
commit:a2c5c22
/////////////////////////////////////////////////////////////////////////
0:                     processRemoveConnection(cs.getInfo().getConnectionId(), -1);
commit:52e1a05
/////////////////////////////////////////////////////////////////////////
1:                     try {
1:                         broker.preProcessDispatch(messageDispatch);
1:                     } catch (RuntimeException convertToIO) {
1:                         throw new IOException(convertToIO);
1:                     }
commit:e8818fa
/////////////////////////////////////////////////////////////////////////
1:         } else if (ack.isInTransaction()) {
1:             LOG.warn("no matching consumer, ignoring ack {}", consumerExchange, ack);
author:?ukasz Dywicki
-------------------------------------------------------------------------------
commit:a8a032a
/////////////////////////////////////////////////////////////////////////
1:                 duplexBridge = config.getBridgeFactory().createNetworkBridge(config, localTransport, remoteBridgeTransport, listener);
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9b9e3d3
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to add Connection id={}, clientId={} due to {}", info.getConnectionId(), clientId, e);
commit:98d2000
/////////////////////////////////////////////////////////////////////////
1:                 addConsumerBrokerExchange(cs, info.getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:     private ConsumerBrokerExchange addConsumerBrokerExchange(TransportConnectionState connectionState, ConsumerId id) {
1:                 context = connectionState.getContext();
1:                 SessionState ss = connectionState.getSessionState(id.getParentId());
commit:ec9a92f
/////////////////////////////////////////////////////////////////////////
1:             // Do not check for null here as it would cause the count of max producers to exclude
1:             // anonymous producers.  The isAdvisoryTopic method checks for null so it is safe to
1:             // call it from here with a null Destination value.
1:             if (!AdvisorySupport.isAdvisoryTopic(destination)) {
commit:00921f2
/////////////////////////////////////////////////////////////////////////
commit:707940f
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collection;
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.LinkedList;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.command.ActiveMQDestination;
1: import org.apache.activemq.command.BrokerInfo;
1: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.CommandTypes;
1: import org.apache.activemq.command.ConnectionControl;
1: import org.apache.activemq.command.ConnectionError;
1: import org.apache.activemq.command.ConnectionId;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.command.ConsumerControl;
1: import org.apache.activemq.command.ConsumerId;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.ControlCommand;
1: import org.apache.activemq.command.DataArrayResponse;
1: import org.apache.activemq.command.DestinationInfo;
1: import org.apache.activemq.command.ExceptionResponse;
1: import org.apache.activemq.command.FlushCommand;
1: import org.apache.activemq.command.IntegerResponse;
1: import org.apache.activemq.command.KeepAliveInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageDispatchNotification;
1: import org.apache.activemq.command.MessagePull;
1: import org.apache.activemq.command.ProducerAck;
1: import org.apache.activemq.command.ProducerId;
1: import org.apache.activemq.command.ProducerInfo;
1: import org.apache.activemq.command.RemoveSubscriptionInfo;
1: import org.apache.activemq.command.Response;
1: import org.apache.activemq.command.SessionId;
1: import org.apache.activemq.command.SessionInfo;
1: import org.apache.activemq.command.ShutdownInfo;
1: import org.apache.activemq.command.TransactionId;
1: import org.apache.activemq.command.TransactionInfo;
1: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
1:                 if (e instanceof SecurityException || e.getCause() instanceof SecurityException) {
0:                     SERVICELOG.warn("Security Error occurred: {}", e.getMessage());
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
0:                     LOG.error("Slave has exception: {} shutting down master now.", e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:                 SERVICELOG.debug("Broker has been stopped.  Notifying client and closing his connection.");
/////////////////////////////////////////////////////////////////////////
0:                 SERVICELOG.warn("Async error occurred: ", e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Failed to remove consumer: {}", consumerId, e);
1:                 LOG.warn("Failed to remove producer: {}", producerId, e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Killing previous stale connection: {}", state.getConnection().getRemoteAddress());
1:                 LOG.debug("Connection {} taking over previous connection: {}", getRemoteAddress(), state.getConnection().getRemoteAddress());
1:         LOG.debug("Setting up new connection id: {}, address: {}, info: {}", new Object[]{ info.getConnectionId(), getRemoteAddress(), info });
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to add Connection {}", info.getConnectionId(), e);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("remove connection id: {}", id);
/////////////////////////////////////////////////////////////////////////
1:                     SERVICELOG.warn("Failed to remove session {}", sessionId, e);
/////////////////////////////////////////////////////////////////////////
1:                     SERVICELOG.warn("Failed to remove tmp destination {}", di.getDestination(), e);
1:                 SERVICELOG.warn("Failed to remove connection {}", cs.getInfo(), e);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Calling the delayed stop() after start() {}", this);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("The connection to '{}' is taking a long time to shutdown.", transport.getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.info("Stopping {} because {}", transport.getRemoteAddress(), reason);
/////////////////////////////////////////////////////////////////////////
1:                             LOG.debug("Error occurred while shutting down a connection {}", this, e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Stopped transport: {}", transport.getRemoteAddress());
1:             LOG.debug("Could not stop transport to {}. This exception is ignored.", transport.getRemoteAddress(), e);
/////////////////////////////////////////////////////////////////////////
1:             LOG.error(" Slave Brokers are no longer supported - slave trying to attach is: {}", info.getBrokerName());
/////////////////////////////////////////////////////////////////////////
1:                             LOG.warn("Stopping an existing active duplex connection [{}] for network connector ({}).", c, duplexNetworkConnectorId);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.info("Started responder end of duplex bridge {}", duplexNetworkConnectorId);
1:                 LOG.warn("Duplex bridge {} was stopped before it was correctly started.", duplexNetworkConnectorId);
1:                 LOG.error("Failed to create responder end of duplex network bridge {}", duplexNetworkConnectorId, e);
1:             LOG.warn("Unexpected extra broker info command received: {}", info);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:d9c74d7
/////////////////////////////////////////////////////////////////////////
1:             //AMQ-6561 - stop for all exceptions on addConnection
1:             // close this down - in case the peer of this transport doesn't play nice
1:             delayedStop(2000, "Failed with SecurityException: " + e.getLocalizedMessage(), e);
commit:bdec3f6
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean starting = new AtomicBoolean();
1:     private final AtomicBoolean pendingStop = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
1:         if (!stopping.get() && !pendingStop.get()) {
/////////////////////////////////////////////////////////////////////////
1:                 if (pendingStop.get()) {
/////////////////////////////////////////////////////////////////////////
0:             } else if (!pendingStop.get()) {
/////////////////////////////////////////////////////////////////////////
1:             if (pendingStop.get() || stopping.get()) {
/////////////////////////////////////////////////////////////////////////
1:                 starting.set(true);
/////////////////////////////////////////////////////////////////////////
1:             pendingStop.set(true);
/////////////////////////////////////////////////////////////////////////
1:                 pendingStop.set(true);
/////////////////////////////////////////////////////////////////////////
1:             pendingStop.set(true);
1:             if (starting.get()) {
/////////////////////////////////////////////////////////////////////////
1:     public boolean isStarting() {
1:         return starting.get();
/////////////////////////////////////////////////////////////////////////
1:     protected void setStarting(boolean starting) {
1:         this.starting.set(starting);
1:     public boolean isPendingStop() {
1:         return pendingStop.get();
1:     protected void setPendingStop(boolean pendingStop) {
1:         this.pendingStop.set(pendingStop);
commit:d206621
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashSet;
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.advisory.AdvisoryBroker;
0: import org.apache.activemq.broker.region.Subscription;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.NetworkBridgeUtils;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     dispatchSync(NetworkBridgeUtils.getBrokerSubscriptionInfo(this.broker.getBrokerService(), config));
/////////////////////////////////////////////////////////////////////////
1:                 if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {
1:                     dispatchSync(NetworkBridgeUtils.getBrokerSubscriptionInfo(this.broker.getBrokerService(), config));
commit:e73ab34
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.StringToListOfActiveMQDestinationConverter;
commit:3953b9a
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.DurableTopicSubscription;
0: import org.apache.activemq.broker.region.TopicRegion;
1: import org.apache.activemq.command.BrokerSubscriptionInfo;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.SubscriptionKey;
/////////////////////////////////////////////////////////////////////////
0:     public static BrokerSubscriptionInfo getBrokerSubscriptionInfo(final BrokerService brokerService) {
0:         RegionBroker regionBroker = (RegionBroker) brokerService.getRegionBroker();
0:         TopicRegion topicRegion = (TopicRegion) regionBroker.getTopicRegion();
0:         List<ConsumerInfo> subscriptionInfos = new ArrayList<>();
0:         for (SubscriptionKey key : topicRegion.getDurableSubscriptions().keySet()) {
0:             DurableTopicSubscription sub = topicRegion.getDurableSubscriptions().get(key);
1:             if (sub != null) {
0:                 ConsumerInfo ci = sub.getConsumerInfo().copy();
0:                 ci.setClientId(key.getClientId());
0:                 subscriptionInfos.add(ci);
1:             }
1:         }
0:         BrokerSubscriptionInfo bsi = new BrokerSubscriptionInfo(brokerService.getBrokerName());
0:         bsi.setSubscriptionInfos(subscriptionInfos.toArray(new ConsumerInfo[0]));
0:         return bsi;
1:     }
1: 
1:     private NetworkBridgeConfiguration getNetworkConfiguration(final BrokerInfo info) throws IOException {
1:         Properties properties = MarshallingSupport.stringToProperties(info.getNetworkProperties());
1:         Map<String, String> props = createMap(properties);
1:         NetworkBridgeConfiguration config = new NetworkBridgeConfiguration();
1:         IntrospectionSupport.setProperties(config, props, "");
1:         return config;
1:     }
1: 
1:         } else if (info.isNetworkConnection() && !info.isDuplexConnection()) {
1:             try {
1:                 NetworkBridgeConfiguration config = getNetworkConfiguration(info);
1:                 if (config.isSyncDurableSubs() && protocolVersion.get() >= CommandTypes.PROTOCOL_VERSION_DURABLE_SYNC) {
1:                     LOG.debug("SyncDurableSubs is enabled, Sending BrokerSubscriptionInfo");
0:                     dispatchSync(getBrokerSubscriptionInfo(this.broker.getBrokerService()));
1:                 }
1:             } catch (Exception e) {
1:                 LOG.error("Failed to respond to network bridge creation from broker {}", info.getBrokerId(), e);
1:                 return null;
1:             }
1:                 NetworkBridgeConfiguration config = getNetworkConfiguration(info);
0:                 if (config.isSyncDurableSubs() && protocolVersion.get() >= 12) {
1:                     LOG.debug("SyncDurableSubs is enabled, Sending BrokerSubscriptionInfo");
0:                     dispatchSync(getBrokerSubscriptionInfo(this.broker.getBrokerService()));
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /* (non-Javadoc)
1:      * @see org.apache.activemq.state.CommandVisitor#processBrokerSubscriptionInfo(org.apache.activemq.command.BrokerSubscriptionInfo)
1:      */
1:     @Override
1:     public Response processBrokerSubscriptionInfo(BrokerSubscriptionInfo info) throws Exception {
1:         return null;
1:     }
commit:9f7d70b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.network.NetworkConnector;
/////////////////////////////////////////////////////////////////////////
1:                 duplexBridge.setDurableDestinations(NetworkConnector.getDurableTopicDestinations(
1:                         broker.getDurableDestinations()));
1: 
commit:39184e2
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     protected final List<Command> dispatchQueue = new LinkedList<>();
1:     protected final AtomicReference<Throwable> transportException = new AtomicReference<>();
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ProducerId, ProducerBrokerExchange> producerExchanges = new HashMap<>();
1:     private final Map<ConsumerId, ConsumerBrokerExchange> consumerExchanges = new HashMap<>();
/////////////////////////////////////////////////////////////////////////
0:                 Set<ActiveMQDestination> durableDestinations = broker.getDurableDestinations();
1:                 //Need to set durableDestinations to properly restart subs when dynamicOnly=false
0:                 if (durableDestinations != null) {
0:                     duplexBridge.setDurableDestinations(broker.getDurableDestinations().toArray(new ActiveMQDestination[0]));
1:                 }
commit:04ee70a
/////////////////////////////////////////////////////////////////////////
0:             e.printStackTrace();
commit:457dbd8
/////////////////////////////////////////////////////////////////////////
1:                 LOG.warn("Failed to add session: {}", info.getSessionId(), e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Exception caught removing connection {}. This exception is ignored.", cs.getInfo().getConnectionId(), ignore);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:dce2b61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     Response response = service(command);
0:                     if (response != null) {
0:                         dispatchSync(response);
/////////////////////////////////////////////////////////////////////////
0:             if (brokerService.isStopping()) {
0:                 response = responseRequired ? new ExceptionResponse(
0:                     new BrokerStoppedException("Broker " + brokerService + " is being stopped")) : null;
0:             } else if (!pendingStop) {
0:                 response = responseRequired ? new ExceptionResponse(transportException.get()) : null;
/////////////////////////////////////////////////////////////////////////
1:             rc += cs.getTransactionStates().size();
commit:d54d046
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:a772b0e
/////////////////////////////////////////////////////////////////////////
author:Christopher L. Shannon
-------------------------------------------------------------------------------
commit:84737f7
/////////////////////////////////////////////////////////////////////////
1:                     SERVICELOG.warn("Security Error occurred on connection to: {}, {}",
1:                             transport.getRemoteAddress(), e.getMessage());
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:e19293d
/////////////////////////////////////////////////////////////////////////
0:     protected final AtomicReference<Throwable> transportException = new AtomicReference<Throwable>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             stopAsync(e);
/////////////////////////////////////////////////////////////////////////
1:                 transportException.set(e);
/////////////////////////////////////////////////////////////////////////
0:                 response = new ExceptionResponse(transportException.get());
/////////////////////////////////////////////////////////////////////////
1:                 broker.removeConnection(cs.getContext(), cs.getInfo(), transportException.get());
/////////////////////////////////////////////////////////////////////////
1:                 transportException.set(cause);
/////////////////////////////////////////////////////////////////////////
1:     public void stopAsync(Throwable cause) {
1:         transportException.set(cause);
1:         stopAsync();
1:     }
1: 
commit:c6fe94e
/////////////////////////////////////////////////////////////////////////
0:                     if (!brokerService.isStopping()) {
0:                         Response response = service(command);
0:                         if (response != null && !brokerService.isStopping()) {
0:                             dispatchSync(response);
1:                         }
1:                     } else {
0:                         throw new BrokerStoppedException("Broker " + brokerService + " is being stopped");
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:93ca044
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
1:     public int getActiveTransactionCount() {
1:         int rc = 0;
1:         for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {
1:             Collection<TransactionState> transactions = cs.getTransactionStates();
1:             for (TransactionState transaction : transactions) {
0:                 rc++;
1:             }
1:         }
1:         return rc;
1:     }
1: 
1:     public Long getOldestActiveTransactionDuration() {
1:         TransactionState oldestTX = null;
1:         for (TransportConnectionState cs : connectionStateRegister.listConnectionStates()) {
1:             Collection<TransactionState> transactions = cs.getTransactionStates();
1:             for (TransactionState transaction : transactions) {
1:                 if( oldestTX ==null || oldestTX.getCreatedAt() < transaction.getCreatedAt() ) {
1:                     oldestTX = transaction;
1:                 }
1:             }
1:         }
1:         if( oldestTX == null ) {
1:             return null;
1:         }
1:         return System.currentTimeMillis() - oldestTX.getCreatedAt();
1:     }
1: 
commit:190a44b
/////////////////////////////////////////////////////////////////////////
1: 
1:     public WireFormatInfo getRemoteWireFormatInfo() {
1:         return wireFormatInfo;
1:     }
commit:bc4f4e9
/////////////////////////////////////////////////////////////////////////
1:         if( this.transport instanceof BrokerServiceAware ) {
1:             ((BrokerServiceAware)this.transport).setBrokerService(brokerService);
1:         }
commit:7c63788
/////////////////////////////////////////////////////////////////////////
1:     public Transport getTransport() {
1:         return transport;
1:     }
1: 
author:rajdavies
-------------------------------------------------------------------------------
commit:374cab9
/////////////////////////////////////////////////////////////////////////
0:                 MBeanNetworkListener listener = new MBeanNetworkListener(broker.getBrokerService(), config, broker.getBrokerService().createDuplexNetworkConnectorObjectName(duplexName));
author:Gary Tully
-------------------------------------------------------------------------------
commit:65ba623
/////////////////////////////////////////////////////////////////////////
0:         if (!stopping.get() && !pendingStop) {
commit:13bbe52
/////////////////////////////////////////////////////////////////////////
1:             if (e instanceof SuppressReplyException || (e.getCause() instanceof SuppressReplyException)) {
1:                 LOG.info("Suppressing reply to: " + command + " on: " + e + ", cause: " + e.getCause());
1:                 responseRequired = false;
1:             }
1: 
commit:88d85ae
/////////////////////////////////////////////////////////////////////////
1:                 Transport remoteBridgeTransport = transport;
1:                 if (! (remoteBridgeTransport instanceof ResponseCorrelator)) {
1:                     // the vm transport case is already wrapped
1:                     remoteBridgeTransport = new ResponseCorrelator(remoteBridgeTransport);
1:                 }
commit:8012f28
/////////////////////////////////////////////////////////////////////////
1:                 // the exception notification to the client.
/////////////////////////////////////////////////////////////////////////
0:                 Transport localTransport = NetworkBridgeFactory.createLocalTransport(broker);
commit:c9b49d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (e instanceof SecurityException) {
0:                 // close this down - in case the peer of this transport doesn't play nice
0:                 delayedStop(2000, "Failed with SecurityException: " + e.getLocalizedMessage(), e);
1:             }
commit:ac54a61
/////////////////////////////////////////////////////////////////////////
1:                 ConnectionContext connectionContext = cs.getContext();
1:                 if (connectionContext != null) {
1:                     connectionContext.getStopping().set(true);
1:                 }
commit:d4ccc50
/////////////////////////////////////////////////////////////////////////
1:         context.setConnectionState(state);
commit:0018f4a
/////////////////////////////////////////////////////////////////////////
1:                 result.setConnectionContext(context);
1:                 if (context.isReconnect() || (context.isNetworkConnection() && connector.isAuditNetworkProducers())) {
commit:2711ad1
/////////////////////////////////////////////////////////////////////////
0:                 if (context.isReconnect() && !context.isNetworkConnection()) {
commit:6778a49
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Setting up new connection id: " + info.getConnectionId() + ", address: " + getRemoteAddress() + ", info: " + info);
commit:8abb5b6
/////////////////////////////////////////////////////////////////////////
1: import java.io.EOFException;
/////////////////////////////////////////////////////////////////////////
0:             } else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {
0:                 TRANSPORTLOG.warn("Transport failed: " + e);
0:         return  isStomp() &&
0:                 ((e instanceof SocketException && e.getMessage().indexOf("reset") != -1) || e instanceof EOFException);
commit:24cd2b3
/////////////////////////////////////////////////////////////////////////
0:             pendingStop = true;
commit:4cf6dae
/////////////////////////////////////////////////////////////////////////
0:                 starting  = true;
/////////////////////////////////////////////////////////////////////////
1:             setStarting(false);
1:             if (isPendingStop()) {
0:                 LOG.debug("Calling the delayed stop() after start() " + this);
/////////////////////////////////////////////////////////////////////////
1:         // If we're in the middle of starting then go no further... for now.
1:         synchronized (this) {
0:             pendingStop = true;
0:             if (starting) {
1:                 LOG.debug("stopAsync() called in the middle of start(). Delaying till start completes..");
1:                 return;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:                             LOG.debug("Error occurred while shutting down a connection " + this, e);
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1: import java.net.SocketException;
/////////////////////////////////////////////////////////////////////////
0:             } else if (TRANSPORTLOG.isInfoEnabled() && !expected(e)) {
1:     private boolean expected(IOException e) {
0:         return  e instanceof SocketException && isStomp() && e.getMessage().indexOf("reset") != -1;
1:     }
1: 
1:     private boolean isStomp() {
1:         URI uri = connector.getUri();
1:         return uri != null && uri.getScheme() != null && uri.getScheme().indexOf("stomp") != -1;
1:     }
1: 
commit:8a2892b
/////////////////////////////////////////////////////////////////////////
commit:e10f75c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 DefaultThreadPools.getDefaultTaskRunnerFactory().execute(new Runnable(){
commit:f93d05a
/////////////////////////////////////////////////////////////////////////
1:             unregisterConnectionState(info.getConnectionId());
commit:69f5605
/////////////////////////////////////////////////////////////////////////
1:             synchronized (brokerConnectionStates) {
1:                 brokerConnectionStates.remove(info.getConnectionId());
1:             }
0:             unregisterConnectionState(info.getConnectionId());
0:             LOG.warn("Failed to add Connection " + info.getConnectionId() + ", reason: " +  e.toString());
/////////////////////////////////////////////////////////////////////////
0:                 SERVICELOG.warn("Failed to remove connection " + cs.getInfo() + ", reason: " + e.toString());
0:                 if (LOG.isDebugEnabled()) {
0:                     SERVICELOG.debug("Exception detail:", e);
1:                 }
commit:78f85ed
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Exception detail:", e);
commit:7739a3c
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to add Connection, reason: " +  e.toString());
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("Failure detail", e);
1:             }
commit:bf4dd73
/////////////////////////////////////////////////////////////////////////
1:                 if (connector.isUpdateClusterClients()) {
1:                     info.setPeerBrokerInfos(this.broker.getPeerBrokerInfos());
1:                 } else {
1:                     info.setPeerBrokerInfos(null);
1:                 }
commit:27d0ff4
/////////////////////////////////////////////////////////////////////////
1:     private String duplexNetworkConnectorId;
/////////////////////////////////////////////////////////////////////////
0:                 }, "StopAsync:" + transport.getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // check for existing duplex connection hanging about
1: 
1:                 // We first look if existing network connection already exists for the same broker Id and network connector name
1:                 // It's possible in case of brief network fault to have this transport connector side of the connection always active
1:                 // and the duplex network connector side wanting to open a new one
1:                 // In this case, the old connection must be broken
1:                 String duplexNetworkConnectorId = config.getName() + "@" + info.getBrokerId(); 
1:                 CopyOnWriteArrayList<TransportConnection> connections = this.connector.getConnections();
1:                 synchronized (connections) {
0:                     for (Iterator<TransportConnection> iter = connections.iterator(); iter.hasNext();) {
1:                         TransportConnection c = iter.next();
1:                         if ((c != this) && (duplexNetworkConnectorId.equals(c.getDuplexNetworkConnectorId()))) {
0:                             LOG.warn("Stopping an existing active duplex connection [" + c + "] for network connector (" + duplexNetworkConnectorId + ").");
1:                             c.stopAsync();
1:                             // better to wait for a bit rather than get connection id already in use and failure to start new bridge
1:                             c.getStopped().await(1, TimeUnit.SECONDS);
1:                         }
1:                     }
1:                     setDuplexNetworkConnectorId(duplexNetworkConnectorId);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Started responder end of duplex bridge " + duplexNetworkConnectorId);
0:                 LOG.warn("Duplex bridge " + duplexNetworkConnectorId + " was stopped before it was correctly started.");
0:                 LOG.error("Failed to create responder end of duplex network bridge " + duplexNetworkConnectorId , e);
1:                 return null;
/////////////////////////////////////////////////////////////////////////
1:     protected synchronized void setDuplexNetworkConnectorId(String duplexNetworkConnectorId) {
1:         this.duplexNetworkConnectorId = duplexNetworkConnectorId;
1:     protected synchronized String getDuplexNetworkConnectorId() {
1:         return this.duplexNetworkConnectorId;
1:     }
1:     
1:     protected CountDownLatch getStopped() {
1:         return stopped;
commit:c752230
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 // We first look if existing network connection already exists for the same broker Id and network connector name
/////////////////////////////////////////////////////////////////////////
commit:0ed0ba5
/////////////////////////////////////////////////////////////////////////
1:         if (cs != null && !cs.getSessionIds().contains(info.getSessionId())) {
commit:c4911bd
/////////////////////////////////////////////////////////////////////////
0:             if (TRANSPORTLOG.isDebugEnabled()) {
0:                 TRANSPORTLOG.debug("Transport failed: " + e, e);
0:             } else if (TRANSPORTLOG.isInfoEnabled()) {
0:                 TRANSPORTLOG.info("Transport failed: " + e);
commit:7629eaf
/////////////////////////////////////////////////////////////////////////
0:             if (TRANSPORTLOG.isInfoEnabled()) {
0:                 TRANSPORTLOG.info("Transport failed: " + e, e);
commit:6b4509c
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.BrokerId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransportDisposedIOException;
/////////////////////////////////////////////////////////////////////////
0: import static org.apache.activemq.thread.DefaultThreadPools.getDefaultTaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:     private BrokerId	duplexRemoteBrokerId;
/////////////////////////////////////////////////////////////////////////
0:                 // We first look if existing network connection already exists for the same broker Id
0:                 // It's possible in case of brief network fault to have this transport connector side of the connection always active
0:                 // and the duplex network connector side wanting to open a new one
0:                 // In this case, the old connection must be broken
0:                 BrokerId	remoteBrokerId = info.getBrokerId();
0:                 setDuplexRemoteBrokerId(remoteBrokerId);
0:                 CopyOnWriteArrayList<TransportConnection> connections = this.connector.getConnections();
0:                 for (Iterator<TransportConnection> iter = connections.iterator(); iter.hasNext();) {
0:             		TransportConnection c = iter.next();
0:                     if ((c != this) && (remoteBrokerId.equals(c.getDuplexRemoteBrokerId()))) {
0:                         LOG.warn("An existing duplex active connection already exists for this broker (" + remoteBrokerId + "). Stopping it.");
0:                         c.stop();
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             } catch (TransportDisposedIOException e) {
0:                 LOG.warn("Duplex Bridge back to " + info.getBrokerName() + " was correctly stopped before it was correctly started.");
1:                 return null;
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected synchronized void setDuplexRemoteBrokerId(BrokerId remoteBrokerId) {
0:         this.duplexRemoteBrokerId = remoteBrokerId;
1:     }
1: 
0:     protected synchronized BrokerId getDuplexRemoteBrokerId() {
0:         return this.duplexRemoteBrokerId;
1:     }
commit:a6a6a70
/////////////////////////////////////////////////////////////////////////
1:         if (producerExchange.canDispatch(messageSend)) {
1:             broker.send(producerExchange, messageSend);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         context.setReconnect(info.isFailoverReconnect());
/////////////////////////////////////////////////////////////////////////
1:     private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {
1:                 TransportConnectionState state = lookupConnectionState(id);              
0:                 if (context.isReconnect()) {
0:                     result.setLastStoredSequenceId(broker.getBrokerService().getPersistenceAdapter().getLastProducerSequenceId(id));
1:                 }
commit:4eafccc
/////////////////////////////////////////////////////////////////////////
1: 
1: import javax.transaction.xa.XAResource;
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalStateException("Cannot prepare a transaction that had not been started or previously returned XA_RDONLY: "
/////////////////////////////////////////////////////////////////////////
1:             if (result == XAResource.XA_RDONLY) {
1:                 // we are done, no further rollback or commit from TM
1:                 cs.removeTransactionState(info.getTransactionId());
1:             }
commit:8d3ca90
/////////////////////////////////////////////////////////////////////////
1:         ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(control.getConsumerId());
1:         broker.processConsumerControl(consumerExchange, control);
commit:8732f70
/////////////////////////////////////////////////////////////////////////
1:         if (cs == null) {
1:             throw new IllegalStateException("Cannot remove a consumer from a connection that had not been registered: "
1:                     + connectionId);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (cs == null) {
1:             throw new IllegalStateException("Cannot remove session from connection that had not been registered: " + connectionId);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("Setting up new connection id: " + info.getConnectionId() + ", address: " + getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
0:         LOG.debug("remove connection id: " + id);
commit:c808beb
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 new Thread("ActiveMQ Transport Stopper: " + transport.getRemoteAddress()) {
1:                     @Override
1:                     public void run() {
1:                         serviceLock.writeLock().lock();
1:                         try {
1:                             doStop();
1:                         } catch (Throwable e) {
0:                             LOG.debug("Error occured while shutting down a connection to '" + transport.getRemoteAddress()
0:                                     + "': ", e);
1:                         } finally {
1:                             stopped.countDown();
1:                             serviceLock.writeLock().unlock();
1:                         }
1:                 }.start();
1:             } catch (Throwable t) {
0:                 LOG.warn("cannot create async transport stopper thread.. not waiting for stop to complete, reason:", t);
1:                 stopped.countDown();
1:             }
commit:504bcf0
/////////////////////////////////////////////////////////////////////////
0:                 SERVICELOG.warn("Async error occurred: " + e, e);
commit:3b08860
/////////////////////////////////////////////////////////////////////////
1:     public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo info = consumerState.getInfo();
1:         info.setLastDeliveredSequenceId(lastDeliveredSequenceId);
/////////////////////////////////////////////////////////////////////////
1:     public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:                 processRemoveConsumer(consumerId, lastDeliveredSequenceId);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:                     processRemoveSession(sessionId, lastDeliveredSequenceId);
/////////////////////////////////////////////////////////////////////////
0:                     processRemoveConnection(cs.getInfo().getConnectionId(), 0l);
commit:301203e
/////////////////////////////////////////////////////////////////////////
0:                 duplexBridge.setBrokerService(broker.getBrokerService());
commit:e53668e
/////////////////////////////////////////////////////////////////////////
1:             if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {
0:                 SERVICELOG.debug("Error occured while processing "
0:                         + (responseRequired ? "sync": "async")
1:                         + " command: " + command + ", exception: " + e, e);
1:             }
author:Robert Davies
-------------------------------------------------------------------------------
commit:0736953
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public ProducerBrokerExchange getProducerBrokerExchangeIfExists(ProducerInfo producerInfo){
1:         ProducerBrokerExchange result = null;
1:         if (producerInfo != null && producerInfo.getProducerId() != null){
1:             synchronized (producerExchanges){
1:                 result = producerExchanges.get(producerInfo.getProducerId());
1:             }
1:         }
1:         return result;
1:     }
1: 
commit:39ff4d9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             LOG.error(" Slave Brokers are no longer supported - slave trying to attach is: " + info.getBrokerName());
commit:74bed6b
/////////////////////////////////////////////////////////////////////////
0: import java.io.EOFException;
1: import java.io.IOException;
0: import java.net.SocketException;
1: import java.net.URI;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Properties;
1: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import java.util.concurrent.atomic.AtomicReference;
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
1: 
0: import javax.transaction.xa.XAResource;
1: import org.apache.activemq.advisory.AdvisorySupport;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (e instanceof java.lang.SecurityException) {
/////////////////////////////////////////////////////////////////////////
1:             ActiveMQDestination destination = info.getDestination();
1:             if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination)) {
1:                 if (getProducerCount(connectionId) >= connector.getMaximumProducersAllowedPerConnection()){
1:                     throw new IllegalStateException("Can't add producer on connection " + connectionId + ": at maximum limit: " + connector.getMaximumProducersAllowedPerConnection());
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:             ActiveMQDestination destination = info.getDestination();
0:             if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination)) {
1:                 if (getConsumerCount(connectionId) >= connector.getMaximumConsumersAllowedPerConnection()){
1:                     throw new IllegalStateException("Can't add consumer on connection " + connectionId + ": at maximum limit: " + connector.getMaximumConsumersAllowedPerConnection());
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings({"unchecked", "rawtypes"})
/////////////////////////////////////////////////////////////////////////
1: 
1:     private int getProducerCount(ConnectionId connectionId) {
1:         int result = 0;
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:         if (cs != null) {
1:             for (SessionId sessionId : cs.getSessionIds()) {
1:                 SessionState sessionState = cs.getSessionState(sessionId);
1:                 if (sessionState != null) {
1:                     result += sessionState.getProducerIds().size();
1:                 }
1:             }
1:         }
1:         return result;
1:     }
1: 
1:     private int getConsumerCount(ConnectionId connectionId) {
1:         int result = 0;
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:         if (cs != null) {
1:             for (SessionId sessionId : cs.getSessionIds()) {
1:                 SessionState sessionState = cs.getSessionState(sessionId);
1:                 if (sessionState != null) {
1:                     result += sessionState.getConsumerIds().size();
1:                 }
1:             }
1:         }
1:         return result;
1:     }
commit:712303e
/////////////////////////////////////////////////////////////////////////
0:                 if(e instanceof java.lang.SecurityException){
0:                   //still need to close this down - incase the peer of this transport doesn't play nice
0:                   delayedStop(2000, "Failed with SecurityException: " + e.getLocalizedMessage());
1:                 }
/////////////////////////////////////////////////////////////////////////
0:     public void delayedStop(final int waitTime, final String reason) {
/////////////////////////////////////////////////////////////////////////
0:                             LOG.info("Stopping " + transport.getRemoteAddress() + " because " + reason);
commit:3a71f8e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.*;
1: import org.apache.activemq.network.DemandForwardingBridge;
1: import org.apache.activemq.network.MBeanNetworkListener;
1: import org.apache.activemq.network.NetworkBridgeConfiguration;
1: import org.apache.activemq.network.NetworkBridgeFactory;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.MarshallingSupport;
0: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.activemq.util.URISupport;
/////////////////////////////////////////////////////////////////////////
1:      * @param taskRunnerFactory - can be null if you want direct dispatch to the transport
1:      *                          else commands are sent async.
0:                                TaskRunnerFactory taskRunnerFactory) {
/////////////////////////////////////////////////////////////////////////
0:         return isStomp() &&
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:                 //still need to close this down - incase the peer of this transport doesn't play nice
0:                 delayedStop(2000);
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = session.getConsumerIds().iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:         for (Iterator iter = session.getProducerIds().iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
1:         this.faultTolerantConnection = info.isFaultTolerant();
/////////////////////////////////////////////////////////////////////////
0:             LOG.warn("Failed to add Connection " + info.getConnectionId() + ", reason: " + e.toString());
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator iter = cs.getSessionIds().iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator iter = cs.getTempDestinations().iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:                 starting = true;
/////////////////////////////////////////////////////////////////////////
0:     public void delayedStop(final int waitTime) {
1:         if (waitTime > 0) {
1:             try {
0:                 DefaultThreadPools.getDefaultTaskRunnerFactory().execute(new Runnable() {
1:                     public void run() {
1:                         try {
1:                             Thread.sleep(waitTime);
1:                             stopAsync();
1:                         } catch (InterruptedException e) {
1:                         }
1:                     }
0:                 }, "delayedStop:" + transport.getRemoteAddress());
1:             } catch (Throwable t) {
0:                 LOG.warn("cannot create stopAsync :", t);
1:             }
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                 DefaultThreadPools.getDefaultTaskRunnerFactory().execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
1:      * @param blockedCandidate The blockedCandidate to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param markedCandidate The markedCandidate to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param slow The slow to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param blocked The blocked to set.
1:      * @param connected The connected to set.
/////////////////////////////////////////////////////////////////////////
1:      * @param active The active to set.
/////////////////////////////////////////////////////////////////////////
1:         return this.faultTolerantConnection;
/////////////////////////////////////////////////////////////////////////
0:             LOG.info((passive ? "Passive" : "Active") + " Slave Broker " + info.getBrokerName() + " is attached");
/////////////////////////////////////////////////////////////////////////
1:                     for (Iterator<TransportConnection> iter = connections.iterator(); iter.hasNext(); ) {
/////////////////////////////////////////////////////////////////////////
0:                 LOG.error("Failed to create responder end of duplex network bridge " + duplexNetworkConnectorId, e);
/////////////////////////////////////////////////////////////////////////
1:                                                                             TransportConnectionState state) {
commit:f392884
/////////////////////////////////////////////////////////////////////////
1:     private final ConnectionStatistics statistics = new ConnectionStatistics();
/////////////////////////////////////////////////////////////////////////
1:     private final CountDownLatch stopped = new CountDownLatch(1);
1:     private final CountDownLatch dispatchStoppedLatch = new CountDownLatch(1);
1:     private final AtomicInteger protocolVersion = new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:                 @Override
/////////////////////////////////////////////////////////////////////////
0:         this.faultTolerantConnection=info.isFaultTolerant();
/////////////////////////////////////////////////////////////////////////
1:        
/////////////////////////////////////////////////////////////////////////
1:         if (info.isManageable()) {
1:             ConnectionControl command = this.connector.getConnectionControl();
/////////////////////////////////////////////////////////////////////////
1:                 BrokerInfo info = connector.getBrokerInfo().copy();
0:                 info.setPeerBrokerInfos(this.broker.getPeerBrokerInfos());
1:                 dispatchAsync(info);
1:                 
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isFaultTolerantConnection() {
0:        return this.faultTolerantConnection;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         
1:     public void updateClient(ConnectionControl control) {
1:         if (isActive() && isBlocked() == false && isFaultTolerantConnection() && this.wireFormatInfo != null
1:                 && this.wireFormatInfo.getVersion() >= 6) {
1:             dispatchAsync(control);
1:         }
1:     }
commit:4228281
/////////////////////////////////////////////////////////////////////////
0:     private static final Log TRANSPORTLOG = LogFactory.getLog(TransportConnection.class.getName() + ".Transport");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:      * @param taskRunnerFactory
0:      *            - can be null if you want direct dispatch to the transport
0:      *            else commands are sent async.
0:             TaskRunnerFactory taskRunnerFactory) {
1:         RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);
/////////////////////////////////////////////////////////////////////////
1:                     Command command = (Command) o;
/////////////////////////////////////////////////////////////////////////
1:         synchronized (dispatchQueue) {
0:         BrokerService bService = connector.getBrokerService();
0:         if (bService.isShutdownOnSlaveFailure()) {
0:             if (brokerInfo != null) {
0:                 if (brokerInfo.isSlaveBroker()) {
0:                     LOG.error("Slave has exception: " + e.getMessage() + " shutting down master now.", e);
1:                     try {
0:                         doStop();
0:                         bService.stop();
0:                     } catch (Exception ex) {
0:                         LOG.warn("Failed to stop the master", ex);
1:                     }
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:             serviceTransportException((IOException) e);
0:                     SERVICELOG.debug("Broker has been stopped.  Notifying client and closing his connection.");
/////////////////////////////////////////////////////////////////////////
1:                 SERVICELOG.debug("Error occured while processing " + (responseRequired ? "sync" : "async")
/////////////////////////////////////////////////////////////////////////
1:                     + info.getTransactionId());
/////////////////////////////////////////////////////////////////////////
1:     public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalStateException("Cannot add a producer to a session that had not been registered: "
1:                     + sessionId);
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalStateException("Cannot remove a producer from a session that had not been registered: "
1:                     + sessionId);
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalStateException(broker.getBrokerName()
1:                     + " Cannot add a consumer to a session that had not been registered: " + sessionId);
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: "
1:                     + sessionId);
/////////////////////////////////////////////////////////////////////////
0:                 e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
0:             ConsumerId consumerId = (ConsumerId) iter.next();
/////////////////////////////////////////////////////////////////////////
0:             ProducerId producerId = (ProducerId) iter.next();
/////////////////////////////////////////////////////////////////////////
0:         // if the broker service has slave attached, wait for the slave to be
0:         // attached to allow client connection. slave connection is fine
0:         if (!info.isBrokerMasterConnector() && connector.getBrokerService().isWaitForSlave()
0:                 && connector.getBrokerService().getSlaveStartSignal().getCount() == 1) {
0:             ServiceSupport.dispose(transport);
0:             return new ExceptionResponse(new Exception("Master's slave not attached yet."));
1:         }
1:         // Older clients should have been defaulting this field to true.. but
1:         // they were not.
1:         if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {
1:             state = (TransportConnectionState) brokerConnectionStates.get(info.getConnectionId());
/////////////////////////////////////////////////////////////////////////
0:                         + state.getConnection().getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1:             broker.addConnection(context, info);
1:         } catch (Exception e) {
0:             brokerConnectionStates.remove(info);
0:             LOG.warn("Failed to add Connection", e);
1:             throw e;
/////////////////////////////////////////////////////////////////////////
1:     public synchronized Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId)
1:             throws InterruptedException {
1:             // Don't allow things to be added to the connection state while we
0:             // are
0:                 SessionId sessionId = (SessionId) iter.next();
/////////////////////////////////////////////////////////////////////////
0:                 DestinationInfo di = (DestinationInfo) iter.next();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // getStatistics().getEnqueues().increment();
/////////////////////////////////////////////////////////////////////////
0:             // getStatistics().getEnqueues().increment();
1:                 synchronized (dispatchQueue) {
/////////////////////////////////////////////////////////////////////////
1:                 MessageDispatch md = (MessageDispatch) message;
/////////////////////////////////////////////////////////////////////////
0:         final MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);
/////////////////////////////////////////////////////////////////////////
0:             // getStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:                 synchronized (dispatchQueue) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             synchronized (this) {
1:                 if (taskRunnerFactory != null) {
1:                     taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: "
1:                             + getRemoteAddress());
1:                 } else {
1:                     taskRunner = null;
1:                 }
1:                 transport.start();
1:                 active = true;
0:                 dispatchAsync(connector.getBrokerInfo());
1:                 connector.onStarted(this);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         while (!stopped.await(5, TimeUnit.SECONDS)) {
0:             LOG.info("The connection to '" + transport.getRemoteAddress() + "' is taking a long time to shutdown.");
1: 
0:             new Thread("ActiveMQ Transport Stopper: " + transport.getRemoteAddress()) {
0:                         LOG.debug("Error occured while shutting down a connection to '" + transport.getRemoteAddress()
0:                                 + "': ", e);
/////////////////////////////////////////////////////////////////////////
1:         return "Transport Connection to: " + transport.getRemoteAddress();
1: 
/////////////////////////////////////////////////////////////////////////
1:         synchronized (dispatchQueue) {
1:                     MessageDispatch md = (MessageDispatch) command;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * @param blockedCandidate
0:      *            The blockedCandidate to set.
/////////////////////////////////////////////////////////////////////////
0:      * @param markedCandidate
0:      *            The markedCandidate to set.
/////////////////////////////////////////////////////////////////////////
0:      * @param slow
0:      *            The slow to set.
/////////////////////////////////////////////////////////////////////////
0:      * @param blocked
0:      *            The blocked to set.
0:      * @param connected
0:      *            The connected to set.
/////////////////////////////////////////////////////////////////////////
0:      * @param active
0:      *            The active to set.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             BrokerService bService = connector.getBrokerService();
0:             // Do we only support passive slaves - or does the slave want to be
0:             // passive ?
0:             boolean passive = bService.isPassiveSlave() || info.isPassiveSlave();
0:             if (passive == false) {
1:                 
0:                 // stream messages from this broker (the master) to
0:                 // the slave
0:                 MutableBrokerFilter parent = (MutableBrokerFilter) broker.getAdaptor(MutableBrokerFilter.class);
0:                 masterBroker = new MasterBroker(parent, transport);
0:                 masterBroker.startProcessing();
1:             }
0:             LOG.info((passive?"Passive":"Active")+" Slave Broker " + info.getBrokerName() + " is attached");
/////////////////////////////////////////////////////////////////////////
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config, localTransport, remoteBridgeTransport);
1:                 duplexBridge.duplexStart(this, brokerInfo, info);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         result.setMutable(info.getDestination() == null || info.getDestination().isComposite());
/////////////////////////////////////////////////////////////////////////
1:         if (control != null) {
1:             faultTolerantConnection = control.isFaultTolerant();
/////////////////////////////////////////////////////////////////////////
1:     protected synchronized TransportConnectionState registerConnectionState(ConnectionId connectionId,
0:             TransportConnectionState state) {
1:         if (!connectionStateRegister.isEmpty() && !connectionStateRegister.doesHandleMultipleConnectionStates()) {
1:             // swap implementations
1:             TransportConnectionStateRegister newRegister = new MapTransportConnectionStateRegister();
1:             newRegister.intialize(connectionStateRegister);
1:             connectionStateRegister = newRegister;
1:         cs = connectionStateRegister.registerConnectionState(connectionId, state);
1:         return cs;
/////////////////////////////////////////////////////////////////////////
1:         return connectionStateRegister.lookupConnectionState(connectionId);
1:         return connectionStateRegister.lookupConnectionState(id);
1:         return connectionStateRegister.lookupConnectionState(id);
/////////////////////////////////////////////////////////////////////////
commit:98497b1
/////////////////////////////////////////////////////////////////////////
0: 		                doStop();
commit:d14e4ae
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ServiceSupport;
/////////////////////////////////////////////////////////////////////////
0:     	BrokerService bService=connector.getBrokerService();
0:     	if(bService.isShutdownOnSlaveFailure()){
0: 	    	if(brokerInfo!=null){
0: 		    	if(brokerInfo.isSlaveBroker()){
0: 		        	LOG.error("Slave has exception: " + e.getMessage()+" shutting down master now.", e);
1: 		            try {
0: 		                broker.stop();
0: 		                bService.stop();
0: 		        	}catch(Exception ex){
0: 		                LOG.warn("Failed to stop the master",ex);
1: 		            }
1: 		        }
1: 	    	}
1:     	}
/////////////////////////////////////////////////////////////////////////
0:     	//if the broker service has slave attached, wait for the slave to be attached to allow client connection. slave connection is fine
0:     	if(!info.isBrokerMasterConnector()&&connector.getBrokerService().isWaitForSlave()&&connector.getBrokerService().getSlaveStartSignal().getCount()==1){
0:     			ServiceSupport.dispose(transport);
0:     			return new ExceptionResponse(new Exception("Master's slave not attached yet."));
1:     	}
/////////////////////////////////////////////////////////////////////////
0:             BrokerService bService=connector.getBrokerService();
0:             bService.slaveConnectionEstablished();
1:             
commit:f4012c5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 duplexBridge.duplexStart(this,brokerInfo, info);
commit:4118d02
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Stopped transport: " + transport.getRemoteAddress());
commit:372f69a
/////////////////////////////////////////////////////////////////////////
0:     protected final List<Command> dispatchQueue = new LinkedList<Command>();
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchQueue) {
1:             return dispatchQueue.size();
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 synchronized(dispatchQueue) {
1:                     dispatchQueue.add(message);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:             //getStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:                 Command command = null;
0:                 synchronized(dispatchQueue) {
1:                     if (dispatchQueue.isEmpty()) {
1:                         return false;
1:                     }
1:                     command = dispatchQueue.remove(0);
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatchQueue) {
0:             for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext();) {
1:                 Command command = iter.next();
1:                 if (command.isMessageDispatch()) {
0:                     MessageDispatch md = (MessageDispatch)command;
0:                     Runnable sub = md.getTransmitCallback();
1:                     broker.postProcessDispatch(md);
1:                     if (sub != null) {
0:                         sub.run();
1:                     }
1:             dispatchQueue.clear();
commit:1987cfa
/////////////////////////////////////////////////////////////////////////
0:                     boolean locked = false;
0:                         locked =  serviceLock.writeLock().tryLock(1,TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:                         if (locked) {
0:                             serviceLock.writeLock().unlock();
1:                         }
commit:f67415d
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:                     try {
0:                         //we could be waiting a long time if the network has gone - so only wait 1 second
0:                         serviceLock.writeLock().tryLock(1,TimeUnit.SECONDS);
1:                     } catch (InterruptedException e) {
0:                        LOG.debug("Try get writeLock interrupted ",e);
1:                     }
commit:5e747b0
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRemoveConnection(ConnectionId id) throws InterruptedException {
1:         if (cs != null) {
0:             // Don't allow things to be added to the connection state while we are
0:             // shutting down.
1:             cs.shutdown();
1:             
1:             // Cascade the connection stop to the sessions.
0:             for (Iterator iter = cs.getSessionIds().iterator(); iter.hasNext();) {
0:                 SessionId sessionId = (SessionId)iter.next();
1:                 try {
0:                     processRemoveSession(sessionId);
1:                 } catch (Throwable e) {
0:                     SERVICELOG.warn("Failed to remove session " + sessionId, e);
1:                 }
1:             // Cascade the connection stop to temp destinations.
0:             for (Iterator iter = cs.getTempDesinations().iterator(); iter.hasNext();) {
0:                 DestinationInfo di = (DestinationInfo)iter.next();
1:                 try {
1:                     broker.removeDestination(cs.getContext(), di.getDestination(), 0);
1:                 } catch (Throwable e) {
0:                     SERVICELOG.warn("Failed to remove tmp destination " + di.getDestination(), e);
1:                 }
1:                 iter.remove();
1:             try {
0:                 broker.removeConnection(cs.getContext(), cs.getInfo(), null);
1:             } catch (Throwable e) {
0:                 SERVICELOG.warn("Failed to remove connection " + cs.getInfo(), e);
1:             }
1:     
1:             TransportConnectionState state = unregisterConnectionState(id);
1:             if (state != null) {
1:                 synchronized (brokerConnectionStates) {
1:                     // If we are the last reference, we should remove the state
1:                     // from the broker.
1:                     if (state.decrementReference() == 0) {
1:                         brokerConnectionStates.remove(id);
1:                     }
commit:4ae43a3
/////////////////////////////////////////////////////////////////////////
0:         //getStatistics().getEnqueues().increment();
/////////////////////////////////////////////////////////////////////////
0:             //getStatistics().getEnqueues().increment();
commit:25b6812
/////////////////////////////////////////////////////////////////////////
1:     private boolean faultTolerantConnection;
/////////////////////////////////////////////////////////////////////////
1:         context.setFaultTolerant(faultTolerantConnection);
/////////////////////////////////////////////////////////////////////////
1:     
1:     public synchronized boolean isNetworkConnection() {
1:         return networkConnection;
1:     }
/////////////////////////////////////////////////////////////////////////
0:         if(control != null) {
0:             faultTolerantConnection=control.isFaultTolerant();
1:         }
commit:34378e8
/////////////////////////////////////////////////////////////////////////
0:             stopLatch.await(1, TimeUnit.SECONDS);
commit:a9119ec
/////////////////////////////////////////////////////////////////////////
1:     private TransportConnectionStateRegister connectionStateRegister = new SingleTransportConnectionStateRegister();
/////////////////////////////////////////////////////////////////////////
0:                                             broker.getBrokerName() + " Cannot add a consumer to a session that had not been registered: "
/////////////////////////////////////////////////////////////////////////
0:             	e.printStackTrace();
/////////////////////////////////////////////////////////////////////////
1:         synchronized (state.getConnectionMutex()) {
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized TransportConnectionState registerConnectionState(ConnectionId connectionId,TransportConnectionState state) {
1:         TransportConnectionState cs = null;
0:         if (!connectionStateRegister.isEmpty() && !connectionStateRegister.doesHandleMultipleConnectionStates()){
0:         	//swap implementations
0:         	TransportConnectionStateRegister newRegister = new MapTransportConnectionStateRegister();
0:         	newRegister.intialize(connectionStateRegister);
0:         	connectionStateRegister = newRegister;
0:     	cs= connectionStateRegister.registerConnectionState(connectionId, state);
0:     	return cs;
1:     protected synchronized TransportConnectionState unregisterConnectionState(ConnectionId connectionId) {
1:         return connectionStateRegister.unregisterConnectionState(connectionId);
1:     protected synchronized List<TransportConnectionState> listConnectionStates() {
1:         return connectionStateRegister.listConnectionStates();
1:     protected synchronized TransportConnectionState lookupConnectionState(String connectionId) {
1:     	  return connectionStateRegister.lookupConnectionState(connectionId);
1:     protected synchronized TransportConnectionState lookupConnectionState(ConsumerId id) {
1:     	  return connectionStateRegister.lookupConnectionState(id);
1:     protected synchronized TransportConnectionState lookupConnectionState(ProducerId id) {
1:     	  return connectionStateRegister.lookupConnectionState(id);
1:     }
1: 
1:     protected synchronized TransportConnectionState lookupConnectionState(SessionId id) {
1:         return connectionStateRegister.lookupConnectionState(id);
1:     }
1: 
0:     protected synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {
1:         return connectionStateRegister.lookupConnectionState(connectionId);
commit:7b1fd34
/////////////////////////////////////////////////////////////////////////
1:         try {
0:         }catch(Exception e){
0:         	brokerConnectionStates.remove(info);
0:         	LOG.warn("Failed to add Connection",e);
1:         	throw e;
1:         }
commit:c07b233
/////////////////////////////////////////////////////////////////////////
0:         if(broker.getBrokerService().isStarted()){
0:             boolean responseRequired=command.isResponseRequired();
0:             int commandId=command.getCommandId();
0:             try{
0:                 response=command.visit(this);
0:             }catch(Throwable e){
0:                 if(responseRequired){
0:                     if(serviceLog.isDebugEnabled()&&e.getClass()!=BrokerStoppedException.class)
0:                         serviceLog.debug("Error occured while processing sync command: "+e,e);
0:                     response=new ExceptionResponse(e);
0:                 }else{
1:                     serviceException(e);
1:                 }
1:             }
0:                 if(response==null){
0:                     response=new Response();
1:                 }
1:                 response.setCorrelationId(commandId);
1:             }
0:             // The context may have been flagged so that the response is not sent.
0:             if(context!=null){
0:                 if(context.isDontSendReponse()){
1:                     context.setDontSendReponse(false);
0:                     response=null;
1:                 }
0:                 context=null;
commit:a401575
/////////////////////////////////////////////////////////////////////////
1:                 broker.postProcessDispatch(md);
/////////////////////////////////////////////////////////////////////////
0:     protected void processDispatch(Command command) throws IOException{
0:         final MessageDispatch messageDispatch=(MessageDispatch)(command.isMessageDispatch()?command:null);
0:         try{
0:             if(!disposed.get()){
0:                 if(messageDispatch!=null){
0:                     broker.preProcessDispatch(messageDispatch);
1:                 }
1:                 dispatch(command);
0:         }finally{
0:             if(messageDispatch!=null){
0:                 Runnable sub=messageDispatch.getTransmitCallback();
1:                 broker.postProcessDispatch(messageDispatch);
1:     }   
/////////////////////////////////////////////////////////////////////////
0: 		            broker.postProcessDispatch(md);
commit:35ba427
/////////////////////////////////////////////////////////////////////////
0: import java.net.URI;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.ResponseCorrelator;
0: import org.apache.activemq.util.URISupport;
/////////////////////////////////////////////////////////////////////////
0:             transport.start();
/////////////////////////////////////////////////////////////////////////
0:                 URI uri = broker.getVmConnectorURI();
0:                 HashMap map = new HashMap(URISupport.parseParamters(uri));
0:                 map.put("network", "true");
0:                 map.put("async","false");
0:                 uri = URISupport.createURIWithQuery(uri, URISupport.createQueryString(map));
0:                 Transport localTransport = TransportFactory.connect(uri);
0:                 Transport remoteBridgeTransport = new ResponseCorrelator(transport);
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config,localTransport,remoteBridgeTransport);
1:                 info.setDuplexConnection(false);
0:                 duplexBridge.duplexStart(brokerInfo,info);
1:                 
1:                 return null;
/////////////////////////////////////////////////////////////////////////
commit:83a6eff
/////////////////////////////////////////////////////////////////////////
1:         context.setClientMaster(info.isClientMaster());
/////////////////////////////////////////////////////////////////////////
0: 	protected void disposeTransport(){
0:         if(transportDisposed.compareAndSet(false,true)){
0:             try{
1:                 transport.stop();
0:                 active=false;
0:                 log.debug("Stopped connection: "+transport.getRemoteAddress());
0:             }catch(Exception e){
0:                 log.debug("Could not stop transport: "+e,e);
1:             }
1:         }
1:     }
1:     
1:    	
commit:241971a
/////////////////////////////////////////////////////////////////////////
0:                 context=state.getContext();
1:                 result.setConnectionContext(context);
commit:25a252f
/////////////////////////////////////////////////////////////////////////
0:         broker.send(producerExchange,messageSend);
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processWireFormat(WireFormatInfo info) throws Exception{
/////////////////////////////////////////////////////////////////////////
1:         if (cs == null) {
1:             throw new NullPointerException("Context is null");
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (cs == null) {
1:             throw new NullPointerException("Context is null");
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (cs == null) {
0:             throw new NullPointerException("Context is null");
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (cs == null) {
0:             throw new NullPointerException("Context is null");
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (cs == null) {
0:             throw new NullPointerException("Context is null");
1:         }
/////////////////////////////////////////////////////////////////////////
0:                 synchronized(this){
0:                     if(masterBroker!=null){
0:                         masterBroker.stop();
1:                     }
0:                     if(duplexBridge!=null){
1:                         duplexBridge.stop();
1:                     }
0:                     // If the transport has not failed yet,
0:                     // notify the peer that we are doing a normal shutdown.
0:                     if(transportException==null){
0:                         transport.oneway(new ShutdownInfo());
1:                     }
1:                 
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processBrokerInfo(BrokerInfo info){
/////////////////////////////////////////////////////////////////////////
0:                 synchronized(this){
0:                     context=state.getContext();
0:                     result.setConnectionContext(context);
1:                 }
commit:98cd515
/////////////////////////////////////////////////////////////////////////
0:     protected final List <Command>dispatchQueue=Collections.synchronizedList(new LinkedList<Command>());
/////////////////////////////////////////////////////////////////////////
1:      * @return size of dispatch queue
/////////////////////////////////////////////////////////////////////////
0:                 Command command = dispatchQueue.remove(0);
0:                  processDispatch( command );
1:                  return true;
1:             return false;
/////////////////////////////////////////////////////////////////////////
0:                 log.trace("Exception caught stopping",ignore);
/////////////////////////////////////////////////////////////////////////
0:         String control = command.getCommand();
0: 	    if (control != null && control.equals("shutdown"))
1:          return null;
commit:54114cc
/////////////////////////////////////////////////////////////////////////
0:                 IntrospectionSupport.setProperties(config,props,"");
1:                 config.setBrokerName(broker.getBrokerName());
0:                 //now turn duplex off this side
1:                 duplexBridge.setCreatedByDuplex(true);
0:                 duplexBridge.start();
0:                 log.info("Created Duplex Bridge back to " + info.getBrokerName());
/////////////////////////////////////////////////////////////////////////
0:             Thread.dumpStack();
commit:ae73f86
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.network.NetworkBridgeFactory;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.transport.TransportFactory;
/////////////////////////////////////////////////////////////////////////
1:                 if (duplexBridge != null) {
0:                     duplexBridge.stop();
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 Transport localTransport = TransportFactory.connect(broker.getVmConnectorURI());
0:                 localTransport.start();
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config,localTransport,transport);
0:             }catch(Exception e){
commit:4741136
/////////////////////////////////////////////////////////////////////////
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.network.DemandForwardingBridge;
0: import org.apache.activemq.network.NetworkBridgeConfiguration;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.IntrospectionSupport;
0: import org.apache.activemq.util.MarshallingSupport;
/////////////////////////////////////////////////////////////////////////
0:     private DemandForwardingBridge duplexBridge = null;
/////////////////////////////////////////////////////////////////////////
0:             }else {
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("Discarding duplicate: " + messageSend);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         }else if (info.isNetworkConnection() && info.isDuplexConnection()) {
0:             //so this TransportConnection is the rear end of a network bridge
0:             //We have been requested to create a two way pipe ...
0:             try{
0:                 Properties props = MarshallingSupport.stringToProperties(info.getNetworkProperties());
0:                 NetworkBridgeConfiguration config = new NetworkBridgeConfiguration();
0:                 IntrospectionSupport.setProperties(config,props,null);
0:                 config.setLocalBrokerName(broker.getBrokerName());
1:                 
1:                
0:             }catch(IOException e){
0:                log.error("Creating duplex network bridge",e);
1:             }
commit:df15551
/////////////////////////////////////////////////////////////////////////
0:         ProducerState producerState = null;
0:         if(messageSend.getMessageId().getProducerId().equals(messageSend.getProducerId())){
0:             producerState=producerExchange.getProducerState();
1:         }
commit:2eaafc0
/////////////////////////////////////////////////////////////////////////
0:     private ConsumerBrokerExchange getConsumerBrokerExchange(ConsumerId id){
0:         ConsumerBrokerExchange result=consumerExchanges.get(id);
0:         if(result==null){
0:             synchronized(consumerExchanges){
0:                 result=new ConsumerBrokerExchange();
0:                 ConnectionState state=lookupConnectionState(id);
0:                 ConnectionContext context=state.getContext();
0:                 SessionState ss=state.getSessionState(id.getParentId());
0:                 if(ss!=null){
0:                     ConsumerState cs=ss.getConsumerState(id);
0:                     if(cs!=null){
0:                         ConsumerInfo info=cs.getInfo();
0:                         if(info!=null){
0:                             if(info.getDestination()!=null&&info.getDestination().isPattern()){
1:                                 result.setWildcard(true);
1:                             }
1:                         }
1:                     }
1:                 }
commit:1191d5e
/////////////////////////////////////////////////////////////////////////
0:                         result.setMutable(info.getDestination()==null||info.getDestination().isComposite());
commit:84eb9f8
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean disposed=new AtomicBoolean(false);
0:     private final AtomicBoolean asyncException=new AtomicBoolean(false);
0:     private final Map<ProducerId,ProducerBrokerExchange>producerExchanges = new HashMap<ProducerId,ProducerBrokerExchange>();
0:     private final Map<ConsumerId,ConsumerBrokerExchange>consumerExchanges = new HashMap<ConsumerId,ConsumerBrokerExchange>();
/////////////////////////////////////////////////////////////////////////
0:         ProducerBrokerExchange producerExchange=getProducerBrokerExchange(producerId);
0:         ProducerState producerState=producerExchange.getProducerState();
0:         if(producerState!=null){
0:                 broker.send(producerExchange,messageSend);
0:         }else{
0:             // producer not local to this broker
0:             broker.send(producerExchange,messageSend);
1:         ConsumerBrokerExchange consumerExchange = getConsumerBrokerExchange(ack.getConsumerId());
0:         broker.acknowledge(consumerExchange,ack);
/////////////////////////////////////////////////////////////////////////
1:         removeProducerBrokerExchange(id);
/////////////////////////////////////////////////////////////////////////
1:         removeConsumerBrokerExchange(id);
/////////////////////////////////////////////////////////////////////////
1:     
0:     private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id){
0:         ProducerBrokerExchange result=producerExchanges.get(id);
0:         if(result==null){
0:             synchronized(producerExchanges){
0:                 result=new ProducerBrokerExchange();
0:                 ConnectionState state=lookupConnectionState(id);
0:                 ConnectionContext context=state.getContext();
0:                 result.setConnectionContext(context);
0:                 SessionState ss=state.getSessionState(id.getParentId());
0:                 if(ss!=null){
1:                     result.setProducerState(ss.getProducerState(id));
0:                     ProducerState producerState=ss.getProducerState(id);
0:                     if(producerState!=null&&producerState.getInfo()!=null){
0:                         ProducerInfo info=producerState.getInfo();
0:                         result.setMutable(info.getDestination()==null);
1:                     }
1:                 }
0:                 producerExchanges.put(id,result);
1:             }
1:         }
1:         return result;
1:     }
1:     
1:     private void removeProducerBrokerExchange(ProducerId id) {
0:         synchronized(producerExchanges) {
1:             producerExchanges.remove(id);
1:         }
1:     }
1:     
1:     private ConsumerBrokerExchange getConsumerBrokerExchange(ConsumerId id) {
1:         ConsumerBrokerExchange result = consumerExchanges.get(id);
1:         if (result == null) {
0:             synchronized(consumerExchanges) {
1:                 result = new ConsumerBrokerExchange();
0:                 ConnectionState state = lookupConnectionState(id);
0:                 ConnectionContext context = state.getContext();
0:                 result.setConnectionContext(context);
0:                 consumerExchanges.put(id,result);
1:             }
1:         }
1:         return result;
1:     }
1:     
1:     private void removeConsumerBrokerExchange(ConsumerId id) {
0:         synchronized(consumerExchanges) {
1:             consumerExchanges.remove(id);
1:         }
1:     }
commit:8b0f88a
/////////////////////////////////////////////////////////////////////////
1:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
1:  * 
1:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
1: 
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0: public class TransportConnection implements Service,Connection,Task,CommandVisitor{
1: 
0:     private static final Log log=LogFactory.getLog(TransportConnection.class);
0:     private static final Log transportLog=LogFactory.getLog(TransportConnection.class.getName()+".Transport");
0:     private static final Log serviceLog=LogFactory.getLog(TransportConnection.class.getName()+".Service");
0:     private MasterBroker masterBroker;
1:     private final Transport transport;
0:     protected final ConcurrentHashMap localConnectionStates=new ConcurrentHashMap();
1:     private WireFormatInfo wireFormatInfo;
0:     // Used to do async dispatch.. this should perhaps be pushed down into the transport layer..
0:     protected final List dispatchQueue=Collections.synchronizedList(new LinkedList());
0:     protected IOException transportException;
0:     private ConnectionStatistics statistics=new ConnectionStatistics();
/////////////////////////////////////////////////////////////////////////
0:     private long timeStamp=0;
0:     private AtomicBoolean stopped=new AtomicBoolean(false);
0:     private CountDownLatch stopLatch=new CountDownLatch(1);
0:     protected final AtomicBoolean asyncException=new AtomicBoolean(false);
1: 
0:     static class ConnectionState extends org.apache.activemq.state.ConnectionState{
1: 
0:         public ConnectionState(ConnectionInfo info,ConnectionContext context,TransportConnection connection){
0:             this.context=context;
1: 
0:         public ConnectionContext getContext(){
1: 
0:         public TransportConnection getConnection(){
1: 
0:     public TransportConnection(TransportConnector connector,final Transport transport,Broker broker,
0:             TaskRunnerFactory taskRunnerFactory){
0:         this.connector=connector;
0:         this.broker=broker;
0:         RegionBroker rb=(RegionBroker)broker.getAdaptor(RegionBroker.class);
0:         brokerConnectionStates=rb.getConnectionStates();
0:         if(connector!=null){
0:         if(taskRunnerFactory!=null){
0:             taskRunner=taskRunnerFactory.createTaskRunner(this,"ActiveMQ Connection Dispatcher: "
0:                     +System.identityHashCode(this));
0:         }else{
0:             taskRunner=null;
0:         this.transport=transport;
0:         this.transport.setTransportListener(new DefaultTransportListener(){
1: 
0:             public void onCommand(Object o){
0:                 Command command=(Command)o;
0:                 Response response=service(command);
0:                 if(response!=null){
0:             public void onException(IOException exception){
0:         connected=true;
0:     public int getDispatchQueueSize(){
0:     public void serviceTransportException(IOException e){
0:         if(!disposed.get()){
0:             transportException=e;
0:             if(transportLog.isDebugEnabled())
1: 
0:      * Calls the serviceException method in an async thread. Since handling a service exception closes a socket, we
0:      * should not tie up broker threads since client sockets may hang or cause deadlocks.
0:     public void serviceExceptionAsync(final IOException e){
0:         if(asyncException.compareAndSet(false,true)){
0:             new Thread("Async Exception Handler"){
0:                 public void run(){
1:                     serviceException(e);
1:                 }
0:             }.start();
1:         }
1:     }
1: 
1:     /**
0:      * Closes a clients connection due to a detected error.
0:      * 
0:      * Errors are ignored if: the client is closing or broker is closing. Otherwise, the connection error transmitted to
0:      * the client before stopping it's transport.
1:      */
0:     public void serviceException(Throwable e){
0:         if(e instanceof IOException){
0:             serviceTransportException((IOException)e);
1:         // Handle the case where the broker is stopped
0:         else if(e.getClass()==BrokerStoppedException.class){
0:             if(!disposed.get()){
0:                 if(serviceLog.isDebugEnabled())
0:                 ConnectionError ce=new ConnectionError();
0:                 try{
0:                 }catch(InterruptedException ie){
0:         }else if(!disposed.get()&&!inServiceException){
0:             inServiceException=true;
0:             try{
0:                 ConnectionError ce=new ConnectionError();
0:             }finally{
0:                 inServiceException=false;
1:         }
0:     public Response service(Command command){
0:         boolean responseRequired=command.isResponseRequired();
0:         int commandId=command.getCommandId();
0:         try{
0:             response=command.visit(this);
0:         }catch(Throwable e){
0:             if(responseRequired){
0:                 if(serviceLog.isDebugEnabled()&&e.getClass()!=BrokerStoppedException.class)
0:                 response=new ExceptionResponse(e);
0:             }else{
1:         }
0:         if(responseRequired){
0:             if(response==null){
0:                 response=new Response();
1: 
0:     protected ConnectionState lookupConnectionState(ConsumerId id){
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(id.getParentId().getParentId());
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a consumer from a connection that had not been registered: "
0:                     +id.getParentId().getParentId());
1: 
0:     protected ConnectionState lookupConnectionState(ProducerId id){
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(id.getParentId().getParentId());
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a producer from a connection that had not been registered: "
0:                     +id.getParentId().getParentId());
1: 
0:     protected ConnectionState lookupConnectionState(SessionId id){
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(id.getParentId());
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a session from a connection that had not been registered: "
0:                     +id.getParentId());
1: 
0:     protected ConnectionState lookupConnectionState(ConnectionId connectionId){
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(connectionId);
0:         if(cs==null)
0:     public Response processKeepAlive(KeepAliveInfo info) throws Exception{
0:     public Response processRemoveSubscription(RemoveSubscriptionInfo info) throws Exception{
0:         broker.removeSubscription(lookupConnectionState(info.getConnectionId()).getContext(),info);
1: 
0:     public Response processWireFormat(WireFormatInfo info) throws Exception{
0:         wireFormatInfo=info;
1: 
0:     public Response processShutdown(ShutdownInfo info) throws Exception{
1: 
0:     public Response processFlush(FlushCommand command) throws Exception{
0:     synchronized public Response processBeginTransaction(TransactionInfo info) throws Exception{
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(info.getConnectionId());
0:         if(cs!=null){
0:             context=cs.getContext();
0:         if(cs.getTransactionState(info.getTransactionId())==null){
0:             broker.beginTransaction(context,info.getTransactionId());
1: 
0:     synchronized public Response processEndTransaction(TransactionInfo info) throws Exception{
1:         // No need to do anything. This packet is just sent by the client
0:     synchronized public Response processPrepareTransaction(TransactionInfo info) throws Exception{
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if(cs!=null){
0:             context=cs.getContext();
1:         }
0:         TransactionState transactionState=cs.getTransactionState(info.getTransactionId());
0:         if(transactionState==null)
0:             throw new IllegalStateException("Cannot prepare a transaction that had not been started: "
0:                     +info.getTransactionId());
0:         if(!transactionState.isPrepared()){
0:             int result=broker.prepareTransaction(context,info.getTransactionId());
0:             IntegerResponse response=new IntegerResponse(result);
0:         }else{
0:             IntegerResponse response=new IntegerResponse(transactionState.getPreparedResult());
0:     synchronized public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception{
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(info.getConnectionId());
0:         if(cs!=null){
0:             context=cs.getContext();
0:         broker.commitTransaction(context,info.getTransactionId(),true);
0:     synchronized public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception{
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(info.getConnectionId());
0:         if(cs!=null){
0:             context=cs.getContext();
0:         broker.commitTransaction(context,info.getTransactionId(),false);
1: 
0:     synchronized public Response processRollbackTransaction(TransactionInfo info) throws Exception{
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(info.getConnectionId());
0:         if(cs!=null){
0:             context=cs.getContext();
1:         cs.removeTransactionState(info.getTransactionId());
0:         broker.rollbackTransaction(context,info.getTransactionId());
1: 
0:     synchronized public Response processForgetTransaction(TransactionInfo info) throws Exception{
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(info.getConnectionId());
0:         if(cs!=null){
0:             context=cs.getContext();
0:         broker.forgetTransaction(context,info.getTransactionId());
1:         return null;
1:     }
1: 
0:     synchronized public Response processRecoverTransactions(TransactionInfo info) throws Exception{
0:         ConnectionState cs=(ConnectionState)localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if(cs!=null){
0:             context=cs.getContext();
1:         }
0:         TransactionId[] preparedTransactions=broker.getPreparedTransactions(context);
0:     public Response processMessage(Message messageSend) throws Exception{
0:         ProducerId producerId=messageSend.getProducerId();
0:         ConnectionState state=lookupConnectionState(producerId);
0:         ConnectionContext context=state.getContext();
0:         // If the message originates from this client connection,
0:         ProducerState producerState=null;
0:         if(messageSend.getMessageId().getProducerId().equals(messageSend.getProducerId())){
0:             SessionState ss=state.getSessionState(producerId.getParentId());
0:             if(ss==null)
0:                 throw new IllegalStateException("Cannot send from a session that had not been registered: "
0:                         +producerId.getParentId());
0:             producerState=ss.getProducerState(producerId);
0:         if(producerState==null){
0:             broker.send(context,messageSend);
0:         }else{
0:             long seq=messageSend.getMessageId().getProducerSequenceId();
0:             if(seq>producerState.getLastSequenceId()){
0:                 broker.send(context,messageSend);
0:     public Response processMessageAck(MessageAck ack) throws Exception{
0:         broker.acknowledge(lookupConnectionState(ack.getConsumerId()).getContext(),ack);
1: 
0:     public Response processMessagePull(MessagePull pull) throws Exception{
0:         return broker.messagePull(lookupConnectionState(pull.getConsumerId()).getContext(),pull);
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processAddDestination(DestinationInfo info) throws Exception{
0:         ConnectionState cs=lookupConnectionState(info.getConnectionId());
0:         broker.addDestinationInfo(cs.getContext(),info);
0:         if(info.getDestination().isTemporary()){
0:     synchronized public Response processRemoveDestination(DestinationInfo info) throws Exception{
0:         ConnectionState cs=lookupConnectionState(info.getConnectionId());
0:         broker.removeDestinationInfo(cs.getContext(),info);
0:         if(info.getDestination().isTemporary()){
0:     synchronized public Response processAddProducer(ProducerInfo info) throws Exception{
0:         SessionId sessionId=info.getProducerId().getParentId();
0:         ConnectionId connectionId=sessionId.getParentId();
0:         ConnectionState cs=lookupConnectionState(connectionId);
0:         SessionState ss=cs.getSessionState(sessionId);
0:         if(ss==null)
0:             throw new IllegalStateException("Cannot add a producer to a session that had not been registered: "
0:                     +sessionId);
0:         if(!ss.getProducerIds().contains(info.getProducerId())){
0:             broker.addProducer(cs.getContext(),info);
0:             try{
0:             }catch(IllegalStateException e){
0:                 broker.removeProducer(cs.getContext(),info);
1: 
0:     synchronized public Response processRemoveProducer(ProducerId id) throws Exception{
0:         SessionId sessionId=id.getParentId();
0:         ConnectionId connectionId=sessionId.getParentId();
0:         ConnectionState cs=lookupConnectionState(connectionId);
0:         SessionState ss=cs.getSessionState(sessionId);
0:         if(ss==null)
0:             throw new IllegalStateException("Cannot remove a producer from a session that had not been registered: "
0:                     +sessionId);
0:         ProducerState ps=ss.removeProducer(id);
0:         if(ps==null)
0:         broker.removeProducer(cs.getContext(),ps.getInfo());
0:     synchronized public Response processAddConsumer(ConsumerInfo info) throws Exception{
0:         SessionId sessionId=info.getConsumerId().getParentId();
0:         ConnectionId connectionId=sessionId.getParentId();
0:         ConnectionState cs=lookupConnectionState(connectionId);
0:         SessionState ss=cs.getSessionState(sessionId);
0:         if(ss==null)
0:             throw new IllegalStateException("Cannot add a consumer to a session that had not been registered: "
0:                     +sessionId);
0:         if(!ss.getConsumerIds().contains(info.getConsumerId())){
0:             broker.addConsumer(cs.getContext(),info);
0:             try{
0:             }catch(IllegalStateException e){
0:                 broker.removeConsumer(cs.getContext(),info);
1: 
0:     synchronized public Response processRemoveConsumer(ConsumerId id) throws Exception{
0:         SessionId sessionId=id.getParentId();
0:         ConnectionId connectionId=sessionId.getParentId();
0:         ConnectionState cs=lookupConnectionState(connectionId);
0:         SessionState ss=cs.getSessionState(sessionId);
0:         if(ss==null)
0:             throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: "
0:                     +sessionId);
0:         ConsumerState consumerState=ss.removeConsumer(id);
0:         if(consumerState==null)
0:         broker.removeConsumer(cs.getContext(),consumerState.getInfo());
1: 
0:     synchronized public Response processAddSession(SessionInfo info) throws Exception{
0:         ConnectionId connectionId=info.getSessionId().getParentId();
0:         ConnectionState cs=lookupConnectionState(connectionId);
0:         if(!cs.getSessionIds().contains(info.getSessionId())){
0:             broker.addSession(cs.getContext(),info);
0:             try{
0:             }catch(IllegalStateException e){
0:                 broker.removeSession(cs.getContext(),info);
0:     synchronized public Response processRemoveSession(SessionId id) throws Exception{
0:         ConnectionId connectionId=id.getParentId();
0:         ConnectionState cs=lookupConnectionState(connectionId);
0:         SessionState session=cs.getSessionState(id);
0:         if(session==null)
0:         for(Iterator iter=session.getConsumerIds().iterator();iter.hasNext();){
0:             ConsumerId consumerId=(ConsumerId)iter.next();
0:             try{
0:             }catch(Throwable e){
0:                 log.warn("Failed to remove consumer: "+consumerId+". Reason: "+e,e);
0:         for(Iterator iter=session.getProducerIds().iterator();iter.hasNext();){
0:             ProducerId producerId=(ProducerId)iter.next();
0:             try{
0:             }catch(Throwable e){
0:                 log.warn("Failed to remove producer: "+producerId+". Reason: "+e,e);
0:         broker.removeSession(cs.getContext(),session.getInfo());
0:     synchronized public Response processAddConnection(ConnectionInfo info) throws Exception{
0:         ConnectionState state=(ConnectionState)brokerConnectionStates.get(info.getConnectionId());
0:         if(state!=null){
0:             // ConnectionInfo replay?? Chances are that it's a client reconnecting,
0:             // and we have not detected that that old connection died.. Kill the old connection
0:             // to make sure our state is in sync with the client.
0:             if(this!=state.getConnection()){
0:                 log.debug("Killing previous stale connection: "+state.getConnection());
1:                 state.getConnection().stop();
0:                 if(!state.getConnection().stopLatch.await(15,TimeUnit.SECONDS)){
0:                     throw new Exception("Previous connection could not be clean up.");
1:                 }
1:             }
1:         }
0:         log.debug("Setting up new connection: "+this);
0:         String clientId=info.getClientId();
0:         ConnectionContext context=new ConnectionContext();
/////////////////////////////////////////////////////////////////////////
0:         this.manageable=info.isManageable();
0:         state=new ConnectionState(info,context,this);
0:         brokerConnectionStates.put(info.getConnectionId(),state);
0:         localConnectionStates.put(info.getConnectionId(),state);
0:         broker.addConnection(context,info);
0:         if(info.isManageable()&&broker.isFaultTolerantConfiguration()){
1:             // send ConnectionCommand
0:             ConnectionControl command=new ConnectionControl();
1: 
0:     synchronized public Response processRemoveConnection(ConnectionId id){
0:         ConnectionState cs=lookupConnectionState(id);
0:         for(Iterator iter=cs.getSessionIds().iterator();iter.hasNext();){
0:             SessionId sessionId=(SessionId)iter.next();
0:             try{
0:                 serviceLog.warn("Failed to remove session "+sessionId,e);
0:         for(Iterator iter=cs.getTempDesinations().iterator();iter.hasNext();){
0:             DestinationInfo di=(DestinationInfo)iter.next();
0:                 broker.removeDestination(cs.getContext(),di.getDestination(),0);
0:                 serviceLog.warn("Failed to remove tmp destination "+di.getDestination(),e);
0:             broker.removeConnection(cs.getContext(),cs.getInfo(),null);
0:             serviceLog.warn("Failed to remove connection "+cs.getInfo(),e);
0:         ConnectionState state=(ConnectionState)localConnectionStates.remove(id);
0:         if(state!=null){
0:             if(state.getContext().decrementReference()==0){
0:     public Connector getConnector(){
0:     public void dispatchSync(Command message){
1: 
0:     public void dispatchAsync(Command message){
0:         if(taskRunner==null){
1:             dispatchSync(message);
0:         }else{
0:             try{
0:             }catch(InterruptedException e){
1:         }
1: 
0:             MessageDispatch md=(MessageDispatch)command;
0:             Runnable sub=(Runnable)md.getConsumer();
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
0:     public boolean iterate(){
0:         if(dispatchQueue.isEmpty()||broker.isStopped()){
0:         }else{
0:             Command command=(Command)dispatchQueue.remove(0);
1:             processDispatch(command);
1:     }
1: 
0:     public ConnectionStatistics getStatistics(){
0:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy(){
0:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy){
0:         this.messageAuthorizationPolicy=messageAuthorizationPolicy;
1: 
1: 
0:     public synchronized void start() throws Exception{
0:         starting=true;
0:         try{
0:             active=true;
0:         }finally{
0:             starting=false;
0:             if(pendingStop){
0:     public void stop() throws Exception{
0:         synchronized(this){
0:             pendingStop=true;
0:             if(starting){
0:                 log.debug("stop() called in the middle of start(). Delaying...");
0:                 return;
1:             }
0:         if(stopped.compareAndSet(false,true)){
0:             log.debug("Stopping connection: "+transport.getRemoteAddress());
1:             connector.onStopped(this);
0:             try{
0:                 if(masterBroker!=null){
0:                     masterBroker.stop();
1:                 }
0:                 // If the transport has not failed yet,
0:                 // notify the peer that we are doing a normal shutdown.
0:                 if(transportException==null){
0:                     transport.oneway(new ShutdownInfo());
1:                 }
0:             }catch(Exception ignore){
0:                 // ignore.printStackTrace();
1:             }
0:             transport.stop();
0:             active=false;
0:             if(disposed.compareAndSet(false,true)){
0:                 if(taskRunner!=null)
0:                     taskRunner.shutdown();
0:                 // Clear out the dispatch queue to release any memory that
0:                 // is being held on to.
0:                 dispatchQueue.clear();
1:                 //
1:                 // Remove all logical connection associated with this connection
1:                 // from the broker.
0:                 if(!broker.isStopped()){
0:                     ArrayList l=new ArrayList(localConnectionStates.keySet());
0:                     for(Iterator iter=l.iterator();iter.hasNext();){
0:                         ConnectionId connectionId=(ConnectionId)iter.next();
0:                         try{
0:                             log.debug("Cleaning up connection resources.");
0:                             processRemoveConnection(connectionId);
0:                         }catch(Throwable ignore){
0:                             ignore.printStackTrace();
1:                         }
1:                     }
0:                     if(brokerInfo!=null){
0:                         broker.removeBroker(this,brokerInfo);
1:                     }
1:                 }
0:                 stopLatch.countDown();
1:             }
0:             log.debug("Stopped connection: "+transport.getRemoteAddress());
1:         }
0:     public boolean isBlockedCandidate(){
0:     public void setBlockedCandidate(boolean blockedCandidate){
0:         this.blockedCandidate=blockedCandidate;
0:     public boolean isMarkedCandidate(){
0:     public void setMarkedCandidate(boolean markedCandidate){
0:         this.markedCandidate=markedCandidate;
0:         if(!markedCandidate){
0:             timeStamp=0;
0:             blockedCandidate=false;
0:     public void setSlow(boolean slow){
0:         this.slow=slow;
0:     public boolean isSlow(){
0:     public boolean isMarkedBlockedCandidate(){
0:     public void doMark(){
0:         if(timeStamp==0){
0:             timeStamp=System.currentTimeMillis();
0:     public boolean isBlocked(){
0:     public boolean isConnected(){
0:     public void setBlocked(boolean blocked){
0:         this.blocked=blocked;
0:     public void setConnected(boolean connected){
0:         this.connected=connected;
0:     public boolean isActive(){
0:     public void setActive(boolean active){
0:         this.active=active;
0:     public synchronized boolean isStarting(){
0:     synchronized protected void setStarting(boolean starting){
0:         this.starting=starting;
0:     public synchronized boolean isPendingStop(){
0:     protected synchronized void setPendingStop(boolean pendingStop){
0:         this.pendingStop=pendingStop;
0:     public Response processBrokerInfo(BrokerInfo info){
0:         if(info.isSlaveBroker()){
0:             // stream messages from this broker (the master) to
0:             // the slave
0:             MutableBrokerFilter parent=(MutableBrokerFilter)broker.getAdaptor(MutableBrokerFilter.class);
0:             masterBroker=new MasterBroker(parent,transport);
0:             log.info("Slave Broker "+info.getBrokerName()+" is attached");
0:         if(this.brokerInfo!=null){
0:         this.brokerInfo=info;
0:         broker.addBroker(this,info);
0:     protected void dispatch(Command command){
0:         try{
0:         }catch(IOException e){
0:         }finally{
0:     public String getRemoteAddress(){
commit:27ded73
/////////////////////////////////////////////////////////////////////////
1:     public Response processBeginTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processEndTransaction(TransactionInfo info) throws Exception {
1:     public Response processPrepareTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processRollbackTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processRecoverTransactions(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processAddDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processRemoveDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processAddProducer(ProducerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processRemoveProducer(ProducerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processAddConsumer(ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveConsumer(ConsumerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processAddSession(SessionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveSession(SessionId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public Response processAddConnection(ConnectionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveConnection(ConnectionId id)  {
commit:43d2ef0
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 serviceLog.error("Async error occurred: "+e,e);
commit:75af5fa
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.MessageDispatch;
/////////////////////////////////////////////////////////////////////////
0:     public Response processBrokerInfo(BrokerInfo info){
0:         if(info.isSlaveBroker()){
0:             MutableBrokerFilter parent=(MutableBrokerFilter) broker.getAdaptor(MutableBrokerFilter.class);
0:             masterBroker=new MasterBroker(parent,transport);
0:             log.info("Slave Broker "+info.getBrokerName()+" is attached");
/////////////////////////////////////////////////////////////////////////
1:     }
commit:f915da5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.DefaultTransportListener;
/////////////////////////////////////////////////////////////////////////
1:         this.transport.setTransportListener(new DefaultTransportListener() {
commit:71afa0d
/////////////////////////////////////////////////////////////////////////
commit:4098942
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.ft.MasterBroker;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0:     private static final Log log = LogFactory.getLog(TransportConnection.class);
/////////////////////////////////////////////////////////////////////////
0:     private MasterBroker masterBroker; //used if this connection is used by a Slave
/////////////////////////////////////////////////////////////////////////
0:             if (masterBroker != null){
0:                 masterBroker.stop();
1:             }
0:             Thread.sleep(1000);
1:         } catch (Exception ignore) {
0:             //ignore.printStackTrace();
/////////////////////////////////////////////////////////////////////////
1:     public Response processBrokerInfo(BrokerInfo info) {
0:         if (info.isSlaveBroker()){
0:             //stream messages from this broker (the master) to 
0:             //the slave
0:             MutableBrokerFilter parent = (MutableBrokerFilter)broker.getAdaptor(MutableBrokerFilter.class);
0:             masterBroker = new MasterBroker(parent,transport);  
0:             masterBroker.startProcessing();
0:             log.info("Slave Broker " + info.getBrokerName() + " is attached");
1:         }
1:         
0:         return super.processBrokerInfo(info);
1:     }
1:     
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:34f3329
/////////////////////////////////////////////////////////////////////////
0:         final BrokerService brokerService = this.broker.getBrokerService();
/////////////////////////////////////////////////////////////////////////
0:                     if (response != null && !brokerService.isStopping() ) {
commit:58aca86
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
0:  * 
commit:1f521da
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
1: 
0: import static org.apache.activemq.thread.DefaultThreadPools.*;
/////////////////////////////////////////////////////////////////////////
0:                 getDefaultTaskRunnerFactory().execute(new Runnable(){
/////////////////////////////////////////////////////////////////////////
1:                 });
commit:db2451c
/////////////////////////////////////////////////////////////////////////
0:                    dispatchAsync(connector.getBrokerInfo());
commit:3224ff8
/////////////////////////////////////////////////////////////////////////
0:                    transport.start();
commit:5d99c99
/////////////////////////////////////////////////////////////////////////
commit:0302ffd
/////////////////////////////////////////////////////////////////////////
1:     public void start() throws Exception {
0:                synchronized(this) {
0:                    transport.start();
0:                    if (taskRunnerFactory != null) {
0:                        taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: "
0:                                                                              + getRemoteAddress());
1:                    } else {
1:                        taskRunner = null;
1:                    }
0:                    active = true;
0:                    this.processDispatch(connector.getBrokerInfo());
0:                    connector.onStarted(this);
1:                }
/////////////////////////////////////////////////////////////////////////
1:         synchronized (this) {
0:             pendingStop = true;
0:             if (starting) {
0:                 LOG.debug("stop() called in the middle of start(). Delaying...");
0:                 return;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             taskRunner.shutdown(1);
commit:31a87ac
/////////////////////////////////////////////////////////////////////////
1:             
1:             // Let all the connection contexts know we are shutting down
1:             // so that in progress operations can notice and unblock.
1:             List<TransportConnectionState> connectionStates = listConnectionStates();
1:             for (TransportConnectionState cs : connectionStates) {
1:                 cs.getContext().getStopping().set(true);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             
1:             List<TransportConnectionState> connectionStates = listConnectionStates();
commit:c18b583
/////////////////////////////////////////////////////////////////////////
0:         while( !stopped.await(5, TimeUnit.SECONDS) ) {
0:             LOG.info("The connection to '" + transport.getRemoteAddress()+ "' is taking a long time to shutdown.");
commit:eccb337
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             taskRunner.wakeup();
0:             // Give it a change to stop gracefully.
0:             dispatchStoppedLatch.await(5, TimeUnit.SECONDS);
1:         
commit:4bce5c8
/////////////////////////////////////////////////////////////////////////
0:                     serviceLock.writeLock().lock();
0:                         serviceLock.writeLock().unlock();
commit:4c481ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class TransportConnection implements Connection, Task, CommandVisitor {
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean stopping = new AtomicBoolean(false);
0:     private CountDownLatch stopped = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
1:     
1:     private final ReentrantReadWriteLock serviceLock = new ReentrantReadWriteLock();
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:                 serviceLock.readLock().lock();
1:                 try {
0:                     Command command = (Command)o;
0:                     Response response = service(command);
0:                     if (response != null) {
0:                         dispatchSync(response);
1:                     }
1:                 } finally {
1:                     serviceLock.readLock().unlock();
1:                 serviceLock.readLock().lock();
1:                 try {
1:                     serviceTransportException(exception);
1:                 } finally {
1:                     serviceLock.readLock().unlock();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (!stopping.get()) {
1:             stopAsync();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (!stopping.get()) {
/////////////////////////////////////////////////////////////////////////
1:                 stopAsync();
1:         } else if (!stopping.get() && !inServiceException) {
/////////////////////////////////////////////////////////////////////////
1:         stopAsync();
/////////////////////////////////////////////////////////////////////////
1:         if (!stopping.get()) {
/////////////////////////////////////////////////////////////////////////
0:             if (!stopping.get()) {
/////////////////////////////////////////////////////////////////////////
0:             if (stopping.get()) {
/////////////////////////////////////////////////////////////////////////
0:         stopAsync();
0:         if( !stopped.await(10, TimeUnit.SECONDS) ) {
0:             LOG.info("Could not shutdown the connection to '" + transport.getRemoteAddress()+ "' in a timely manner.");
1:         }
1:     }
1:     
1:     public void stopAsync() {
/////////////////////////////////////////////////////////////////////////
1:         if (stopping.compareAndSet(false, true)) {
0:             new Thread("ActiveMQ Transport Stopper: "+ transport.getRemoteAddress()) {
1:                 @Override
1:                 public void run() {
0:                     // make sure we are not servicing client requests while we are shutting down.
0:                     serviceLock.writeLock().lock();
1:                     try {
0:                         doStop();
1:                     } catch (Throwable e) {
0:                         LOG.info("Error occured while shutting down a connection to '" + transport.getRemoteAddress()+ "': "+e);
0:                         LOG.debug("Error occured while shutting down a connection to '" + transport.getRemoteAddress()+ "': ", e);
1:                     } finally {
0:                         stopped.countDown();
0:                         serviceLock.writeLock().unlock();
1:                     }
1:                 }
0:             }.start();
1:     @Override
1:     public String toString() {
0:         return  "Transport Connection to: "+transport.getRemoteAddress();
1:     }
1:     
commit:2984963
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (!stopped.get()) {
/////////////////////////////////////////////////////////////////////////
0:             if (!stopped.get()) {
/////////////////////////////////////////////////////////////////////////
0:         } else if (!stopped.get() && !inServiceException) {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveConnection(ConnectionId id) throws InterruptedException {
1:         
/////////////////////////////////////////////////////////////////////////
0:         if (!stopped.get()) {
/////////////////////////////////////////////////////////////////////////
0:             if (!stopped.get()) {
/////////////////////////////////////////////////////////////////////////
0:             if (stopped.get()) {
/////////////////////////////////////////////////////////////////////////
0:         // Let all the connection contexts know we are shutting down
0:         // so that in progress operations can notice and unblock.
1:         List<TransportConnectionState> connectionStates = listConnectionStates();
1:         for (TransportConnectionState cs : connectionStates) {
0:             cs.getContext().getStopping().set(true);
1:         }
1: 
1:         if (taskRunner != null) {
0:             taskRunner.wakeup();
0:             // Give it a change to stop gracefully.
0:             dispatchStoppedLatch.await(5, TimeUnit.SECONDS);
1:         }
1:         
1:         try {
0:             transport.stop();
0:             LOG.debug("Stopped connection: " + transport.getRemoteAddress());
1:         } catch (Exception e) {
0:             LOG.debug("Could not stop transport: " + e, e);
1:         }
1: 
1:         if (taskRunner != null) {
0:             taskRunner.shutdown();
1:         }
1: 
1:         active = false;
1: 
1:         // Run the MessageDispatch callbacks so that message references get
1:         // cleaned up.
0:         for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext();) {
0:             Command command = iter.next();
0:             if (command.isMessageDispatch()) {
0:                 MessageDispatch md = (MessageDispatch)command;
0:                 Runnable sub = md.getTransmitCallback();
0:                 broker.postProcessDispatch(md);
1:                 if (sub != null) {
0:                     sub.run();
1:                 }
1:             }
1:         }
0:         //
0:         // Remove all logical connection associated with this connection
0:         // from the broker.
1: 
1:         if (!broker.isStopped()) {
1:             connectionStates = listConnectionStates();
1:                 try {
0:                     LOG.debug("Cleaning up connection resources: " + getRemoteAddress());
0:                     processRemoveConnection(cs.getInfo().getConnectionId());
1:                 } catch (Throwable ignore) {
0:                     ignore.printStackTrace();
0:             if (brokerInfo != null) {
0:                 broker.removeBroker(this, brokerInfo);
0:         LOG.debug("Connection Stopped: " + getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
commit:ada47fb
/////////////////////////////////////////////////////////////////////////
1:         } catch (Exception e) {
1:             // Force clean up on an error starting up.
1:             stop();
1:             throw e;
commit:ceec57a
/////////////////////////////////////////////////////////////////////////
1:     public Response processWireFormat(WireFormatInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processBeginTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processEndTransaction(TransactionInfo info) throws Exception {
0:     public Response processPrepareTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRollbackTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
0:     public Response processRecoverTransactions(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddProducer(ProducerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveProducer(ProducerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddConsumer(ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveConsumer(ConsumerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddSession(SessionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveSession(SessionId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public Response processRemoveConnection(ConnectionId id) {
/////////////////////////////////////////////////////////////////////////
0:     public Response processBrokerInfo(BrokerInfo info) {
commit:3d024d6
/////////////////////////////////////////////////////////////////////////
1:         
0:         // Older clients should have been defaulting this field to true.. but they were not. 
0:         if( wireFormatInfo!=null && wireFormatInfo.getVersion() <= 2 ) {
1:             info.setClientMaster(true);
1:         }
commit:01bdc52
/////////////////////////////////////////////////////////////////////////
1:         boolean responseRequired = command.isResponseRequired();
1:         int commandId = command.getCommandId();
1:         try {
1:             response = command.visit(this);
1:         } catch (Throwable e) {
0:                 if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {
0:                     SERVICELOG.debug("Error occured while processing sync command: " + e, e);
1:                 response = new ExceptionResponse(e);
1:             } else {
0:                 serviceException(e);
1:         }
1:         if (responseRequired) {
1:             if (response == null) {
1:                 response = new Response();
0:             response.setCorrelationId(commandId);
1:         }
1:         // The context may have been flagged so that the response is not
1:         // sent.
1:         if (context != null) {
1:             if (context.isDontSendReponse()) {
0:                 context.setDontSendReponse(false);
1:                 response = null;
1:             }
1:             context = null;
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transaction.Transaction;
/////////////////////////////////////////////////////////////////////////
0:     private static final Log TRANSPORTLOG = LogFactory.getLog(TransportConnection.class.getName()
0:                                                               + ".Transport");
1: 
0:     protected final List<Command> dispatchQueue = Collections.synchronizedList(new LinkedList<Command>());
1:     protected TaskRunner taskRunner;
0:     protected final AtomicReference<IOException> transportException = new AtomicReference<IOException>();
1:     protected AtomicBoolean dispatchStopped = new AtomicBoolean(false);
1: 
0:     private MasterBroker masterBroker;
0:     private final Transport transport;
1:     private MessageAuthorizationPolicy messageAuthorizationPolicy;
1:     private boolean inServiceException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,
0:                                TaskRunnerFactory taskRunnerFactory) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                     SERVICELOG
0:                         .debug("Broker has been stopped.  Notifying client and closing his connection.");
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot prepare a transaction that had not been started: "
0:                                             + info.getTransactionId());
/////////////////////////////////////////////////////////////////////////
0:     public Response processMessageDispatchNotification(MessageDispatchNotification notification)
0:         throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot add a producer to a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot remove a producer from a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot add a consumer to a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot remove a consumer from a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Connection " + getRemoteAddress() + " taking over previous connection: "
0:                           + state.getConnection().getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1:         context.setTransactions(new ConcurrentHashMap<TransactionId, Transaction>());
/////////////////////////////////////////////////////////////////////////
0:         final MessageDispatch messageDispatch = (MessageDispatch)(command.isMessageDispatch()
0:             ? command : null);
/////////////////////////////////////////////////////////////////////////
0:                 taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: "
0:                                                                       + getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext();) {
0:                 Command command = iter.next();
/////////////////////////////////////////////////////////////////////////
0:                 Map<String, String> props = createMap(properties);
0:                 HashMap<String, String> map = new HashMap<String, String>(URISupport.parseParamters(uri));
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config, localTransport,
0:                                                                  remoteBridgeTransport);
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
1:     private HashMap<String, String> createMap(Properties properties) {
1:         return new HashMap(properties);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         result.setMutable(info.getDestination() == null
0:                                           || info.getDestination().isComposite());
/////////////////////////////////////////////////////////////////////////
1:                             if (info.getDestination() != null && info.getDestination().isPattern()) {
/////////////////////////////////////////////////////////////////////////
0:     protected TransportConnectionState registerConnectionState(ConnectionId connectionId,
0:                                                                TransportConnectionState state) {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a connectionId for a connection that had not been registered: "
1:                                                 + connectionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a consumer from a connection that had not been registered: "
0:                                                 + id.getParentId().getParentId());
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a producer from a connection that had not been registered: "
0:                                                 + id.getParentId().getParentId());
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a session from a connection that had not been registered: "
0:                                                 + id.getParentId());
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot lookup a connection that had not been registered: "
1:                                             + connectionId);
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:             if (TRANSPORTLOG.isDebugEnabled()) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         
1:         } else if (e.getClass() == BrokerStoppedException.class) {
0:             // Handle the case where the broker is stopped
1:             // But the client is still connected.
1: 
0:                 if (SERVICELOG.isDebugEnabled()) {
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:                     if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1:         if (transactionState == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (ss == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (ss == null) {
1:         }
1:         if (ps == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (ss == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (ss == null) {
1:         }
1:         if (consumerState == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (session == null) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (taskRunner != null) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:                 Properties properties = MarshallingSupport.stringToProperties(info.getNetworkProperties());
0:                 Map<String, String> props = new HashMap(properties);
0:                 HashMap<String,String> map = new HashMap<String,String>(URISupport.parseParamters(uri));
/////////////////////////////////////////////////////////////////////////
1:             if (cs.getInfo().getClientId() != null) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:                             if (info.getDestination() != null && info.getDestination().isPattern()) { 
/////////////////////////////////////////////////////////////////////////
0:         if (control != null && control.equals("shutdown")) {
1:         }
/////////////////////////////////////////////////////////////////////////
0:         List<TransportConnectionState> rc = new ArrayList<TransportConnectionState>();
/////////////////////////////////////////////////////////////////////////
0:         if (cs == null) {
1:         }
0:         if (cs == null) {
1:         }
0:         if (cs == null) {
1:         }
0:         if (cs == null) {
1:         }
0:         if (cs == null) {
1:         }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
1:     private final TaskRunnerFactory taskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processBeginTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processEndTransaction(TransactionInfo info) throws Exception {
0:     public synchronized Response processPrepareTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRollbackTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processForgetTransaction(TransactionInfo info) throws Exception {
0:     public synchronized Response processRecoverTransactions(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processAddDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRemoveDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processAddProducer(ProducerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRemoveProducer(ProducerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processAddConsumer(ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRemoveConsumer(ConsumerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processAddSession(SessionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRemoveSession(SessionId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized Response processRemoveConnection(ConnectionId id) {
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void setStarting(boolean starting) {
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     private static final Log TRANSPORTLOG = LogFactory.getLog(TransportConnection.class.getName() + ".Transport");
/////////////////////////////////////////////////////////////////////////
0:     public TransportConnection(TransportConnector connector, final Transport transport, Broker broker, TaskRunnerFactory taskRunnerFactory) {
/////////////////////////////////////////////////////////////////////////
0:                     SERVICELOG.debug("Broker has been stopped.  Notifying client and closing his connection.");
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot prepare a transaction that had not been started: " + info.getTransactionId());
/////////////////////////////////////////////////////////////////////////
0:     public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot add a producer to a session that had not been registered: " + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot remove a producer from a session that had not been registered: " + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot add a consumer to a session that had not been registered: " + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: " + sessionId);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Connection " + getRemoteAddress() + " taking over previous connection: " + state.getConnection().getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
0:         final MessageDispatch messageDispatch = (MessageDispatch)(command.isMessageDispatch() ? command : null);
/////////////////////////////////////////////////////////////////////////
0:                 taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: " + getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config, localTransport, remoteBridgeTransport);
/////////////////////////////////////////////////////////////////////////
0:                         result.setMutable(info.getDestination() == null || info.getDestination().isComposite());
/////////////////////////////////////////////////////////////////////////
0:     protected TransportConnectionState registerConnectionState(ConnectionId connectionId, TransportConnectionState state) {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot lookup a connectionId for a connection that had not been registered: " + connectionId);
0:             throw new IllegalStateException("Cannot lookup a consumer from a connection that had not been registered: " + id.getParentId().getParentId());
0:             throw new IllegalStateException("Cannot lookup a producer from a connection that had not been registered: " + id.getParentId().getParentId());
0:             throw new IllegalStateException("Cannot lookup a session from a connection that had not been registered: " + id.getParentId());
0:             throw new IllegalStateException("Cannot lookup a connection that had not been registered: " + connectionId);
commit:f812e34
/////////////////////////////////////////////////////////////////////////
0:     private static final Log TRANSPORTLOG = LogFactory.getLog(TransportConnection.class.getName()
0:                                                               + ".Transport");
/////////////////////////////////////////////////////////////////////////
0:     public TransportConnection(TransportConnector connector, final Transport transport, Broker broker,
0:                                TaskRunnerFactory taskRunnerFactory) {
/////////////////////////////////////////////////////////////////////////
0:                     SERVICELOG
0:                         .debug("Broker has been stopped.  Notifying client and closing his connection.");
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException("Cannot prepare a transaction that had not been started: "
0:                                             + info.getTransactionId());
/////////////////////////////////////////////////////////////////////////
0:     public Response processMessageDispatchNotification(MessageDispatchNotification notification)
0:         throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot add a producer to a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot remove a producer from a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot add a consumer to a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot remove a consumer from a session that had not been registered: "
0:                                                 + sessionId);
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Connection " + getRemoteAddress() + " taking over previous connection: "
0:                           + state.getConnection().getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
0:         final MessageDispatch messageDispatch = (MessageDispatch)(command.isMessageDispatch()
0:             ? command : null);
/////////////////////////////////////////////////////////////////////////
0:                 taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: "
0:                                                                       + getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config, localTransport,
0:                                                                  remoteBridgeTransport);
/////////////////////////////////////////////////////////////////////////
0:                         result.setMutable(info.getDestination() == null
0:                                           || info.getDestination().isComposite());
/////////////////////////////////////////////////////////////////////////
0:     protected TransportConnectionState registerConnectionState(ConnectionId connectionId,
0:                                                                TransportConnectionState state) {
/////////////////////////////////////////////////////////////////////////
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a connectionId for a connection that had not been registered: "
0:                                                 + connectionId);
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a consumer from a connection that had not been registered: "
0:                                                 + id.getParentId().getParentId());
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a producer from a connection that had not been registered: "
0:                                                 + id.getParentId().getParentId());
0:             throw new IllegalStateException(
0:                                             "Cannot lookup a session from a connection that had not been registered: "
0:                                                 + id.getParentId());
0:             throw new IllegalStateException("Cannot lookup a connection that had not been registered: "
0:                                             + connectionId);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
0: public class TransportConnection implements Service, Connection, Task, CommandVisitor {
0:     private static final Log LOG = LogFactory.getLog(TransportConnection.class);
0:     private static final Log TRANSPORTLOG = LogFactory.getLog(TransportConnection.class.getName() + ".Transport");
0:     private static final Log SERVICELOG = LogFactory.getLog(TransportConnection.class.getName() + ".Service");
/////////////////////////////////////////////////////////////////////////
1:     // protected final ConcurrentHashMap localConnectionStates=new
1:     // ConcurrentHashMap();
1:     // Used to do async dispatch.. this should perhaps be pushed down into the
1:     // transport layer..
0:     protected final List<Command> dispatchQueue = Collections.synchronizedList(new LinkedList<Command>());
0:     private boolean inServiceException = false;
0:     private ConnectionStatistics statistics = new ConnectionStatistics();
/////////////////////////////////////////////////////////////////////////
1:     private long timeStamp;
0:     private final AtomicBoolean transportDisposed = new AtomicBoolean();
0:     private final AtomicBoolean disposed = new AtomicBoolean(false);
0:     private CountDownLatch stopLatch = new CountDownLatch(1);
1:     private final AtomicBoolean asyncException = new AtomicBoolean(false);
0:     private final Map<ProducerId, ProducerBrokerExchange> producerExchanges = new HashMap<ProducerId, ProducerBrokerExchange>();
0:     private final Map<ConsumerId, ConsumerBrokerExchange> consumerExchanges = new HashMap<ConsumerId, ConsumerBrokerExchange>();
0:     protected AtomicBoolean dispatchStopped = new AtomicBoolean(false);
0:     private AtomicInteger protocolVersion = new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
1:     private DemandForwardingBridge duplexBridge;
0:     final private TaskRunnerFactory taskRunnerFactory;
0:     private TransportConnectionState connectionState;
1: 
0:     static class TransportConnectionState extends org.apache.activemq.state.ConnectionState {
0:         public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection) {
0:             connection = transportConnection;
0:         public ConnectionContext getContext() {
0:         public TransportConnection getConnection() {
0:         public void setContext(ConnectionContext context) {
0:             this.context = context;
1:         }
0:         public void setConnection(TransportConnection connection) {
0:             this.connection = connection;
1:         }
1: 
0:         public int incrementReference() {
0:             return referenceCounter.incrementAndGet();
1:         }
1: 
0:         public int decrementReference() {
0:             return referenceCounter.decrementAndGet();
1:         }
/////////////////////////////////////////////////////////////////////////
0:      * @param taskRunnerFactory - can be null if you want direct dispatch to the
0:      *                transport else commands are sent async.
0:     public TransportConnection(TransportConnector connector, final Transport transport, Broker broker, TaskRunnerFactory taskRunnerFactory) {
1:         this.connector = connector;
1:         this.broker = broker;
0:         RegionBroker rb = (RegionBroker)broker.getAdaptor(RegionBroker.class);
1:         brokerConnectionStates = rb.getConnectionStates();
1:         if (connector != null) {
1:         this.taskRunnerFactory = taskRunnerFactory;
1:         this.transport = transport;
0:         this.transport.setTransportListener(new DefaultTransportListener() {
1:             public void onCommand(Object o) {
0:                 Command command = (Command)o;
0:                 Response response = service(command);
0:                 if (response != null) {
0:                     dispatchSync(response);
1:             public void onException(IOException exception) {
1:         connected = true;
0:      * 
1:     public int getDispatchQueueSize() {
1:     public void serviceTransportException(IOException e) {
0:         if (!disposed.get()) {
1:             transportException.set(e);
0:             if (TRANSPORTLOG.isDebugEnabled())
0:                 TRANSPORTLOG.debug("Transport failed: " + e, e);
1:      * Calls the serviceException method in an async thread. Since handling a
1:      * service exception closes a socket, we should not tie up broker threads
1:      * since client sockets may hang or cause deadlocks.
1:     public void serviceExceptionAsync(final IOException e) {
1:         if (asyncException.compareAndSet(false, true)) {
1:             new Thread("Async Exception Handler") {
0:                 public void run() {
/////////////////////////////////////////////////////////////////////////
1:      * Closes a clients connection due to a detected error. Errors are ignored
1:      * if: the client is closing or broker is closing. Otherwise, the connection
1:      * error transmitted to the client before stopping it's transport.
1:     public void serviceException(Throwable e) {
1:         if (e instanceof IOException) {
0:         else if (e.getClass() == BrokerStoppedException.class) {
0:             if (!disposed.get()) {
0:                 if (SERVICELOG.isDebugEnabled())
0:                     SERVICELOG.debug("Broker has been stopped.  Notifying client and closing his connection.");
1:                 ConnectionError ce = new ConnectionError();
1:                 // Wait a little bit to try to get the output buffer to flush
0:                 // the exption notification to the client.
1:                 try {
1:                 } catch (InterruptedException ie) {
1:                 // Worst case is we just kill the connection before the
1:                 // notification gets to him.
0:         } else if (!disposed.get() && !inServiceException) {
1:             inServiceException = true;
1:             try {
0:                 SERVICELOG.error("Async error occurred: " + e, e);
1:                 ConnectionError ce = new ConnectionError();
1:             } finally {
1:                 inServiceException = false;
1:     public Response service(Command command) {
1:         Response response = null;
0:         if (broker.getBrokerService().isStarted()) {
0:             boolean responseRequired = command.isResponseRequired();
0:             int commandId = command.getCommandId();
1:             try {
0:                 response = command.visit(this);
1:             } catch (Throwable e) {
1:                 if (responseRequired) {
0:                     if (SERVICELOG.isDebugEnabled() && e.getClass() != BrokerStoppedException.class)
0:                         SERVICELOG.debug("Error occured while processing sync command: " + e, e);
0:                     response = new ExceptionResponse(e);
1:                 } else {
1:             if (responseRequired) {
0:                 if (response == null) {
0:                     response = new Response();
0:             // The context may have been flagged so that the response is not
0:             // sent.
0:             if (context != null) {
0:                 if (context.isDontSendReponse()) {
0:                     response = null;
1:                 context = null;
1:     public Response processKeepAlive(KeepAliveInfo info) throws Exception {
1:     public Response processRemoveSubscription(RemoveSubscriptionInfo info) throws Exception {
1:         broker.removeSubscription(lookupConnectionState(info.getConnectionId()).getContext(), info);
0:     public synchronized Response processWireFormat(WireFormatInfo info) throws Exception {
1:         wireFormatInfo = info;
1:         protocolVersion.set(info.getVersion());
1:     public Response processShutdown(ShutdownInfo info) throws Exception {
0:         new Thread("Async Exception Handler") {
0:             public void run() {
0:                     TransportConnection.this.stop();
1:                 } catch (Exception e) {
0:                     serviceException(e);
1:                 }
1:     public Response processFlush(FlushCommand command) throws Exception {
0:     synchronized public Response processBeginTransaction(TransactionInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         context = null;
1:         if (cs != null) {
1:             context = cs.getContext();
1:         if (cs.getTransactionState(info.getTransactionId()) == null) {
1:             broker.beginTransaction(context, info.getTransactionId());
0:     synchronized public Response processEndTransaction(TransactionInfo info) throws Exception {
0:     synchronized public Response processPrepareTransaction(TransactionInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         context = null;
1:         if (cs != null) {
1:             context = cs.getContext();
1:         TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0:         if (transactionState == null)
0:             throw new IllegalStateException("Cannot prepare a transaction that had not been started: " + info.getTransactionId());
1:         if (!transactionState.isPrepared()) {
1:             int result = broker.prepareTransaction(context, info.getTransactionId());
1:             IntegerResponse response = new IntegerResponse(result);
1:         } else {
1:             IntegerResponse response = new IntegerResponse(transactionState.getPreparedResult());
0:     synchronized public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         context = cs.getContext();
1:         broker.commitTransaction(context, info.getTransactionId(), true);
0:     synchronized public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         context = cs.getContext();
1:         broker.commitTransaction(context, info.getTransactionId(), false);
0:     synchronized public Response processRollbackTransaction(TransactionInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         context = cs.getContext();
1:         broker.rollbackTransaction(context, info.getTransactionId());
0:     synchronized public Response processForgetTransaction(TransactionInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         context = cs.getContext();
1:         broker.forgetTransaction(context, info.getTransactionId());
0:     synchronized public Response processRecoverTransactions(TransactionInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         context = cs.getContext();
1:         TransactionId[] preparedTransactions = broker.getPreparedTransactions(context);
1:     public Response processMessage(Message messageSend) throws Exception {
1:         ProducerId producerId = messageSend.getProducerId();
1:         ProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
0:         broker.send(producerExchange, messageSend);
1:     public Response processMessageAck(MessageAck ack) throws Exception {
1:         broker.acknowledge(consumerExchange, ack);
1:     public Response processMessagePull(MessagePull pull) throws Exception {
1:         return broker.messagePull(lookupConnectionState(pull.getConsumerId()).getContext(), pull);
0:     public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Exception {
0:     synchronized public Response processAddDestination(DestinationInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         broker.addDestinationInfo(cs.getContext(), info);
1:         if (info.getDestination().isTemporary()) {
0:     synchronized public Response processRemoveDestination(DestinationInfo info) throws Exception {
1:         TransportConnectionState cs = lookupConnectionState(info.getConnectionId());
1:         broker.removeDestinationInfo(cs.getContext(), info);
1:         if (info.getDestination().isTemporary()) {
0:     synchronized public Response processAddProducer(ProducerInfo info) throws Exception {
1:         SessionId sessionId = info.getProducerId().getParentId();
1:         ConnectionId connectionId = sessionId.getParentId();
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:         SessionState ss = cs.getSessionState(sessionId);
0:         if (ss == null)
0:             throw new IllegalStateException("Cannot add a producer to a session that had not been registered: " + sessionId);
1:         if (!ss.getProducerIds().contains(info.getProducerId())) {
1:             broker.addProducer(cs.getContext(), info);
1:             try {
1:             } catch (IllegalStateException e) {
1:                 broker.removeProducer(cs.getContext(), info);
0:     synchronized public Response processRemoveProducer(ProducerId id) throws Exception {
1:         SessionId sessionId = id.getParentId();
1:         ConnectionId connectionId = sessionId.getParentId();
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:         SessionState ss = cs.getSessionState(sessionId);
0:         if (ss == null)
0:             throw new IllegalStateException("Cannot remove a producer from a session that had not been registered: " + sessionId);
1:         ProducerState ps = ss.removeProducer(id);
0:         if (ps == null)
1:             throw new IllegalStateException("Cannot remove a producer that had not been registered: " + id);
1:         broker.removeProducer(cs.getContext(), ps.getInfo());
0:     synchronized public Response processAddConsumer(ConsumerInfo info) throws Exception {
1:         SessionId sessionId = info.getConsumerId().getParentId();
1:         ConnectionId connectionId = sessionId.getParentId();
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:         SessionState ss = cs.getSessionState(sessionId);
0:         if (ss == null)
0:             throw new IllegalStateException("Cannot add a consumer to a session that had not been registered: " + sessionId);
1:         if (!ss.getConsumerIds().contains(info.getConsumerId())) {
1:             broker.addConsumer(cs.getContext(), info);
1:             try {
1:             } catch (IllegalStateException e) {
1:                 broker.removeConsumer(cs.getContext(), info);
0:     synchronized public Response processRemoveConsumer(ConsumerId id) throws Exception {
1:         SessionId sessionId = id.getParentId();
1:         ConnectionId connectionId = sessionId.getParentId();
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:         SessionState ss = cs.getSessionState(sessionId);
0:         if (ss == null)
0:             throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: " + sessionId);
1:         ConsumerState consumerState = ss.removeConsumer(id);
0:         if (consumerState == null)
1:             throw new IllegalStateException("Cannot remove a consumer that had not been registered: " + id);
1:         broker.removeConsumer(cs.getContext(), consumerState.getInfo());
0:     synchronized public Response processAddSession(SessionInfo info) throws Exception {
1:         ConnectionId connectionId = info.getSessionId().getParentId();
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
0:         if (!cs.getSessionIds().contains(info.getSessionId())) {
1:             broker.addSession(cs.getContext(), info);
1:             try {
1:             } catch (IllegalStateException e) {
1:                 broker.removeSession(cs.getContext(), info);
0:     synchronized public Response processRemoveSession(SessionId id) throws Exception {
1:         ConnectionId connectionId = id.getParentId();
1:         TransportConnectionState cs = lookupConnectionState(connectionId);
1:         SessionState session = cs.getSessionState(id);
0:         if (session == null)
1:             throw new IllegalStateException("Cannot remove session that had not been registered: " + id);
1:         // Don't let new consumers or producers get added while we are closing
1:         // this down.
0:         for (Iterator iter = session.getConsumerIds().iterator(); iter.hasNext();) {
0:             ConsumerId consumerId = (ConsumerId)iter.next();
1:             try {
1:             } catch (Throwable e) {
0:                 LOG.warn("Failed to remove consumer: " + consumerId + ". Reason: " + e, e);
0:         for (Iterator iter = session.getProducerIds().iterator(); iter.hasNext();) {
0:             ProducerId producerId = (ProducerId)iter.next();
1:             try {
1:             } catch (Throwable e) {
0:                 LOG.warn("Failed to remove producer: " + producerId + ". Reason: " + e, e);
1:         broker.removeSession(cs.getContext(), session.getInfo());
1: 
1: 
1:         // Make sure 2 concurrent connections by the same ID only generate 1
1:         // TransportConnectionState object.
1:         synchronized (brokerConnectionStates) {
0:             state = (TransportConnectionState)brokerConnectionStates.get(info.getConnectionId());
1:             if (state == null) {
1:                 state = new TransportConnectionState(info, this);
1:                 brokerConnectionStates.put(info.getConnectionId(), state);
1:             }
1:             state.incrementReference();
1: 
1:         // If there are 2 concurrent connections for the same connection id,
1:         // then last one in wins, we need to sync here
0:         synchronized (state.connectMutex) {
1:             if (state.getConnection() != this) {
0:                 LOG.debug("Killing previous stale connection: " + state.getConnection().getRemoteAddress());
0:                 state.getConnection().stop();
0:                 LOG.debug("Connection " + getRemoteAddress() + " taking over previous connection: " + state.getConnection().getRemoteAddress());
1:                 state.setConnection(this);
1:                 state.reset(info);
1:             }
1: 
1:         registerConnectionState(info.getConnectionId(), state);
1: 
0:         LOG.debug("Setting up new connection: " + getRemoteAddress());
1:         String clientId = info.getClientId();
1:         context = new ConnectionContext();
/////////////////////////////////////////////////////////////////////////
1:         this.manageable = info.isManageable();
1:         state.setConnection(this);
0:         broker.addConnection(context, info);
0:         if (info.isManageable() && broker.isFaultTolerantConfiguration()) {
0:             ConnectionControl command = new ConnectionControl();
0:     synchronized public Response processRemoveConnection(ConnectionId id) {
1:         TransportConnectionState cs = lookupConnectionState(id);
0:         // Don't allow things to be added to the connection state while we are
0:         // shutting down.
0:         for (Iterator iter = cs.getSessionIds().iterator(); iter.hasNext();) {
0:             SessionId sessionId = (SessionId)iter.next();
1:             try {
0:             } catch (Throwable e) {
0:                 SERVICELOG.warn("Failed to remove session " + sessionId, e);
0:         for (Iterator iter = cs.getTempDesinations().iterator(); iter.hasNext();) {
0:             DestinationInfo di = (DestinationInfo)iter.next();
1:             try {
0:                 broker.removeDestination(cs.getContext(), di.getDestination(), 0);
0:             } catch (Throwable e) {
0:                 SERVICELOG.warn("Failed to remove tmp destination " + di.getDestination(), e);
1:         try {
0:             broker.removeConnection(cs.getContext(), cs.getInfo(), null);
0:         } catch (Throwable e) {
0:             SERVICELOG.warn("Failed to remove connection " + cs.getInfo(), e);
0: 
0:         TransportConnectionState state = unregisterConnectionState(id);
0:         if (state != null) {
0:             synchronized (brokerConnectionStates) {
0:                 if (state.decrementReference() == 0) {
/////////////////////////////////////////////////////////////////////////
1:         // A broker should not get ProducerAck messages.
1:         return null;
1:     }
1:     public Connector getConnector() {
1:     public void dispatchSync(Command message) {
/////////////////////////////////////////////////////////////////////////
1:     public void dispatchAsync(Command message) {
0:         if (!disposed.get()) {
1:             if (taskRunner == null) {
0:                 dispatchSync(message);
/////////////////////////////////////////////////////////////////////////
1:             if (message.isMessageDispatch()) {
0:                 MessageDispatch md = (MessageDispatch)message;
0:                 Runnable sub = md.getTransmitCallback();
1:                 if (sub != null) {
1:             }
1:     protected void processDispatch(Command command) throws IOException {
0:         final MessageDispatch messageDispatch = (MessageDispatch)(command.isMessageDispatch() ? command : null);
1:         try {
0:             if (!disposed.get()) {
1:                 if (messageDispatch != null) {
1:         } finally {
1:             if (messageDispatch != null) {
0:                 Runnable sub = messageDispatch.getTransmitCallback();
1:                 if (sub != null) {
1:     }
1:     public boolean iterate() {
0:             if (disposed.get()) {
1:                 if (dispatchStopped.compareAndSet(false, true)) {
1:                     if (transportException.get() == null) {
1:                         try {
1:                             dispatch(new ShutdownInfo());
1:                         } catch (Throwable ignore) {
1:                         }
1:                     }
1:                     dispatchStoppedLatch.countDown();
1:                 }
1:                 return false;
1:             }
1:             if (!dispatchStopped.get()) {
0:                 if (dispatchQueue.isEmpty()) {
1:                     return false;
1:                 }
0:                 processDispatch(command);
0:                 return true;
1:             }
1:         } catch (IOException e) {
1:             if (dispatchStopped.compareAndSet(false, true)) {
1:                 dispatchStoppedLatch.countDown();
1:             }
1:             serviceExceptionAsync(e);
1:             return false;
1:         }
1:     public ConnectionStatistics getStatistics() {
1:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {
1:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {
1:         this.messageAuthorizationPolicy = messageAuthorizationPolicy;
1:     public boolean isManageable() {
0:     public synchronized void start() throws Exception {
0:         starting = true;
1:         try {
0:             if (taskRunnerFactory != null) {
0:                 taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: " + getRemoteAddress());
1:             } else {
0:                 taskRunner = null;
1:             }
0: 
0:             active = true;
1:         } finally {
0:             starting = false;
0:             if (pendingStop) {
0:                 LOG.debug("Calling the delayed stop()");
1:     public void stop() throws Exception {
1:         synchronized (this) {
0:             pendingStop = true;
0:             if (starting) {
0:                 LOG.debug("stop() called in the middle of start(). Delaying...");
0:         if (stopped.compareAndSet(false, true)) {
0:             stopLatch.countDown();
0:             stopLatch.await();
0:     protected void doStop() throws Exception, InterruptedException {
0:         LOG.debug("Stopping connection: " + transport.getRemoteAddress());
0:         connector.onStopped(this);
1:         try {
1:             synchronized (this) {
0:                 if (masterBroker != null) {
0:                     masterBroker.stop();
1:                 }
0:                 if (duplexBridge != null) {
0:                     duplexBridge.stop();
1:                 }
0:                 // If the transport has not failed yet,
0:                 // notify the peer that we are doing a normal shutdown.
0:                 if (transportException == null) {
0:                     transport.oneway(new ShutdownInfo());
1:                 }
1:             }
0:         } catch (Exception ignore) {
0:             LOG.trace("Exception caught stopping", ignore);
1:         }
0:         if (disposed.compareAndSet(false, true)) {
0:             // Let all the connection contexts know we are shutting down
0:             // so that in progress operations can notice and unblock.
1:             List<TransportConnectionState> connectionStates = listConnectionStates();
1:             for (TransportConnectionState cs : connectionStates) {
0:                 cs.getContext().getStopping().set(true);
1:             }
0:             if (taskRunner != null) {
0:                 taskRunner.wakeup();
0:                 // Give it a change to stop gracefully.
0:                 dispatchStoppedLatch.await(5, TimeUnit.SECONDS);
0:                 disposeTransport();
0:                 taskRunner.shutdown();
1:             } else {
0:                 disposeTransport();
1:             }
0: 
0:             if (taskRunner != null)
0:                 taskRunner.shutdown();
0: 
0:             // Run the MessageDispatch callbacks so that message references get
0:             // cleaned up.
0:             for (Iterator iter = dispatchQueue.iterator(); iter.hasNext();) {
0:                 Command command = (Command)iter.next();
0:                 if (command.isMessageDispatch()) {
0:                     MessageDispatch md = (MessageDispatch)command;
0:                     Runnable sub = md.getTransmitCallback();
0:                     broker.postProcessDispatch(md);
1:                     if (sub != null) {
0:                         sub.run();
1:                     }
1:                 }
1:             }
0:             //
0:             // Remove all logical connection associated with this connection
0:             // from the broker.
0: 
0:             if (!broker.isStopped()) {
0:                 connectionStates = listConnectionStates();
1:                 for (TransportConnectionState cs : connectionStates) {
0:                     cs.getContext().getStopping().set(true);
1:                     try {
0:                         LOG.debug("Cleaning up connection resources: " + getRemoteAddress());
0:                         processRemoveConnection(cs.getInfo().getConnectionId());
1:                     } catch (Throwable ignore) {
0:                         ignore.printStackTrace();
1:                     }
1:                 }
0: 
0:                 if (brokerInfo != null) {
0:                     broker.removeBroker(this, brokerInfo);
1:                 }
1:             }
0:             LOG.debug("Connection Stopped: " + getRemoteAddress());
1:         }
1:     }
1:      * @return Returns the blockedCandidate.
1:      */
1:     public boolean isBlockedCandidate() {
0:      * @param blockedCandidate The blockedCandidate to set.
1:      */
1:     public void setBlockedCandidate(boolean blockedCandidate) {
1:         this.blockedCandidate = blockedCandidate;
1:     public boolean isMarkedCandidate() {
1:     public void setMarkedCandidate(boolean markedCandidate) {
1:         this.markedCandidate = markedCandidate;
1:         if (!markedCandidate) {
1:             timeStamp = 0;
1:             blockedCandidate = false;
1:     public void setSlow(boolean slow) {
1:         this.slow = slow;
1:     public boolean isSlow() {
1:     public boolean isMarkedBlockedCandidate() {
1:     public void doMark() {
1:         if (timeStamp == 0) {
1:             timeStamp = System.currentTimeMillis();
1:     public boolean isBlocked() {
1:     public boolean isConnected() {
1:     public void setBlocked(boolean blocked) {
1:         this.blocked = blocked;
1:     public void setConnected(boolean connected) {
1:         this.connected = connected;
1:     public boolean isActive() {
1:     public void setActive(boolean active) {
1:         this.active = active;
0:     public synchronized boolean isStarting() {
0:     synchronized protected void setStarting(boolean starting) {
0:         this.starting = starting;
0:     public synchronized boolean isPendingStop() {
0:     protected synchronized void setPendingStop(boolean pendingStop) {
0:         this.pendingStop = pendingStop;
0:     public synchronized Response processBrokerInfo(BrokerInfo info) {
1:         if (info.isSlaveBroker()) {
0:             MutableBrokerFilter parent = (MutableBrokerFilter)broker.getAdaptor(MutableBrokerFilter.class);
0:             masterBroker = new MasterBroker(parent, transport);
0:             LOG.info("Slave Broker " + info.getBrokerName() + " is attached");
1:         } else if (info.isNetworkConnection() && info.isDuplexConnection()) {
1:             // so this TransportConnection is the rear end of a network bridge
1:             // We have been requested to create a two way pipe ...
1:             try {
0:                 IntrospectionSupport.setProperties(config, props, "");
0:                 map.put("async", "false");
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config, localTransport, remoteBridgeTransport);
1:                 // now turn duplex off this side
0:                 duplexBridge.duplexStart(brokerInfo, info);
0: 
0:                 LOG.info("Created Duplex Bridge back to " + info.getBrokerName());
0:             } catch (Exception e) {
0:                 LOG.error("Creating duplex network bridge", e);
1:         if (this.brokerInfo != null) {
0:             LOG.warn("Unexpected extra broker info command received: " + info);
0:         broker.addBroker(this, info);
1:         networkConnection = true;
1:         List<TransportConnectionState> connectionStates = listConnectionStates();
1:         for (TransportConnectionState cs : connectionStates) {
1:             cs.getContext().setNetworkConnection(true);
1:         }
1:         return null;
1:     protected void dispatch(Command command) throws IOException {
1:         try {
1:         } finally {
1:     public String getRemoteAddress() {
0: 
1:         List<TransportConnectionState> connectionStates = listConnectionStates();
1:         for (TransportConnectionState cs : connectionStates) {
0:             if (cs.getInfo().getClientId() != null)
1:                 return cs.getInfo().getClientId();
1:             return cs.getInfo().getConnectionId().toString();
1:         }
1:         return null;
1:     }
0: 
0:     private ProducerBrokerExchange getProducerBrokerExchange(ProducerId id) {
1:         ProducerBrokerExchange result = producerExchanges.get(id);
1:         if (result == null) {
1:             synchronized (producerExchanges) {
1:                 result = new ProducerBrokerExchange();
0:                 TransportConnectionState state = lookupConnectionState(id);
1:                 context = state.getContext();
1:                 SessionState ss = state.getSessionState(id.getParentId());
1:                 if (ss != null) {
1:                     ProducerState producerState = ss.getProducerState(id);
1:                     if (producerState != null && producerState.getInfo() != null) {
1:                         ProducerInfo info = producerState.getInfo();
0:                         result.setMutable(info.getDestination() == null || info.getDestination().isComposite());
1:                 producerExchanges.put(id, result);
1:             context = result.getConnectionContext();
0: 
1:         synchronized (producerExchanges) {
0: 
0:     private ConsumerBrokerExchange getConsumerBrokerExchange(ConsumerId id) {
1:         ConsumerBrokerExchange result = consumerExchanges.get(id);
1:         if (result == null) {
1:             synchronized (consumerExchanges) {
0:                 result = new ConsumerBrokerExchange();
0:                 TransportConnectionState state = lookupConnectionState(id);
1:                 context = state.getContext();
1:                 SessionState ss = state.getSessionState(id.getParentId());
1:                 if (ss != null) {
1:                     ConsumerState cs = ss.getConsumerState(id);
1:                     if (cs != null) {
1:                         ConsumerInfo info = cs.getInfo();
1:                         if (info != null) {
0:                             if (info.getDestination() != null && info.getDestination().isPattern()) {
1:                 consumerExchanges.put(id, result);
0: 
1:         synchronized (consumerExchanges) {
0: 
0:     protected void disposeTransport() {
0:         if (transportDisposed.compareAndSet(false, true)) {
1:             try {
0:                 active = false;
0:                 LOG.debug("Stopped connection: " + transport.getRemoteAddress());
0:             } catch (Exception e) {
0:                 LOG.debug("Could not stop transport: " + e, e);
1:     public int getProtocolVersion() {
1:         return protocolVersion.get();
1:     }
0: 
1:     public Response processControlCommand(ControlCommand command) throws Exception {
0:         if (control != null && control.equals("shutdown"))
0:             System.exit(0);
1:         return null;
1:     }
1:     public Response processMessageDispatch(MessageDispatch dispatch) throws Exception {
1:         return null;
1:     }
1:     public Response processConnectionControl(ConnectionControl control) throws Exception {
1:         return null;
1:     }
1:     public Response processConnectionError(ConnectionError error) throws Exception {
1:         return null;
1:     }
1:     public Response processConsumerControl(ConsumerControl control) throws Exception {
1:         return null;
1:     }
0:     // /////////////////////////////////////////////////////////////////
0:     //
0:     // The following methods handle the logical connection state. It is possible
0:     // multiple logical connections multiplexed over a single physical
0:     // connection.
0:     // But have not yet exploited the feature from the clients, so for
0:     // performance
0:     // reasons (to avoid a hash lookup) this class only keeps track of 1
0:     // logical connection state.
0:     //
0:     // A sub class could override these methods to a full multiple logical
0:     // connection
0:     // support.
0:     //
0:     // /////////////////////////////////////////////////////////////////
0:     protected TransportConnectionState registerConnectionState(ConnectionId connectionId, TransportConnectionState state) {
0:         TransportConnectionState rc = connectionState;
0:         connectionState = state;
0:         return rc;
1:     }
0: 
0:     protected TransportConnectionState unregisterConnectionState(ConnectionId connectionId) {
0:         TransportConnectionState rc = connectionState;
0:         connectionState = null;
0:         return rc;
1:     }
0: 
0:     protected List<TransportConnectionState> listConnectionStates() {
0:         ArrayList<TransportConnectionState> rc = new ArrayList<TransportConnectionState>();
0:         if (connectionState != null) {
0:             rc.add(connectionState);
1:         }
0:         return rc;
1:     }
0: 
0:     protected TransportConnectionState lookupConnectionState(String connectionId) {
0:         TransportConnectionState cs = connectionState;
0:         if (cs == null)
0:             throw new IllegalStateException("Cannot lookup a connectionId for a connection that had not been registered: " + connectionId);
0: 
0:     protected TransportConnectionState lookupConnectionState(ConsumerId id) {
0:         TransportConnectionState cs = connectionState;
0:         if (cs == null)
0:             throw new IllegalStateException("Cannot lookup a consumer from a connection that had not been registered: " + id.getParentId().getParentId());
0: 
0:     protected TransportConnectionState lookupConnectionState(ProducerId id) {
0:         TransportConnectionState cs = connectionState;
0:         if (cs == null)
0:             throw new IllegalStateException("Cannot lookup a producer from a connection that had not been registered: " + id.getParentId().getParentId());
0: 
0:     protected TransportConnectionState lookupConnectionState(SessionId id) {
0:         TransportConnectionState cs = connectionState;
0:         if (cs == null)
0:             throw new IllegalStateException("Cannot lookup a session from a connection that had not been registered: " + id.getParentId());
0: 
0:     protected TransportConnectionState lookupConnectionState(ConnectionId connectionId) {
0:         TransportConnectionState cs = connectionState;
0:         if (cs == null)
0:             throw new IllegalStateException("Cannot lookup a connection that had not been registered: " + connectionId);
commit:5ad4732
/////////////////////////////////////////////////////////////////////////
0: 		    	connectionStates=listConnectionStates();
commit:ea74731
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.state.ConnectionState;
/////////////////////////////////////////////////////////////////////////
0: //    protected final ConcurrentHashMap localConnectionStates=new ConcurrentHashMap();
1:     protected final Map<ConnectionId, ConnectionState> brokerConnectionStates;
/////////////////////////////////////////////////////////////////////////
0: 	private TransportConnectionState connectionState;
0:     static class TransportConnectionState extends org.apache.activemq.state.ConnectionState{
1:         private ConnectionContext context;
0:         private TransportConnection connection;
0:         private final Object connectMutex = new Object();
0:         private AtomicInteger referenceCounter = new AtomicInteger();
0:         public TransportConnectionState(ConnectionInfo info, TransportConnection transportConnection){
0:             connection=transportConnection;
/////////////////////////////////////////////////////////////////////////
0: 
0: 		public void setContext(ConnectionContext context) {
0: 			this.context = context;
1: 		}
0: 
0: 		public void setConnection(TransportConnection connection) {
0: 			this.connection = connection;
1: 		}
0: 		
0: 		public int incrementReference() {
0: 			return referenceCounter.incrementAndGet();
1: 		}
0: 		
0: 		public int decrementReference() {
0: 			return referenceCounter.decrementAndGet();
1: 		}
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         new Thread("Async Exception Handler"){
0:             public void run(){
0:                 try {
0: 					TransportConnection.this.stop();
0: 				} catch (Exception e) {
0: 					serviceException(e);
1: 				}
1:             }
0:         }.start();
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
0:         context=cs.getContext();
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
0:         context=cs.getContext();
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
0:         context=cs.getContext();
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
0:         context=cs.getContext();
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
0:         context=cs.getContext();
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(info.getConnectionId());
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(connectionId);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(connectionId);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(connectionId);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(connectionId);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(connectionId);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnectionState cs=lookupConnectionState(connectionId);
/////////////////////////////////////////////////////////////////////////
0:     public Response processAddConnection(ConnectionInfo info) throws Exception {
0:     	
1:         TransportConnectionState state;
0:         
0:         // Make sure 2 concurrent connections by the same ID only generate 1 TransportConnectionState object.
0:         synchronized(brokerConnectionStates) {
0: 	        state=(TransportConnectionState)brokerConnectionStates.get(info.getConnectionId());
0: 	        if( state==null ) {
0: 	            state=new TransportConnectionState(info,this);
0: 	            brokerConnectionStates.put(info.getConnectionId(),state);
1: 	        }
0: 	        state.incrementReference();
0:         
0:         	
0:         // If there are 2 concurrent connections for the same connection id, then last one in wins, we need to sync here 
1:         // to figure out the winner.
0:         synchronized(state.connectMutex) {
0: 	        if( state.getConnection()!=this ) {
0: 	            log.debug("Killing previous stale connection: "+state.getConnection().getRemoteAddress());
0: 	            state.getConnection().stop(); 
0: 	            log.debug("Connection "+getRemoteAddress()+" taking over previous connection: "+state.getConnection().getRemoteAddress());
0: 		        state.setConnection(this);
0: 		        state.reset(info);
1: 	        }
1:         }
0:         
0:         registerConnectionState(info.getConnectionId(),state);
0:         	
0:         log.debug("Setting up new connection: "+getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1:         state.setContext(context);
0:         state.setConnection(this);            
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 	synchronized public Response processRemoveConnection(ConnectionId id){
0:         TransportConnectionState cs=lookupConnectionState(id);
/////////////////////////////////////////////////////////////////////////
0:         
0:         TransportConnectionState state=unregisterConnectionState(id);
0:         if(state!=null) {
0:             synchronized(brokerConnectionStates) {
0:                 // If we are the last reference, we should remove the state
0:                 // from the broker.
0:                 if(state.decrementReference()==0){
0:                     brokerConnectionStates.remove(id);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:         if(stopped.compareAndSet(false,true)) {
0:             doStop();
0: 			stopLatch.countDown();
0:         } else {
0:         	stopLatch.await();
0: 	protected void doStop() throws Exception, InterruptedException {
0: 		log.debug("Stopping connection: "+transport.getRemoteAddress());
0: 		connector.onStopped(this);
0: 		try{
0: 		    synchronized(this){
0: 		        if(masterBroker!=null){
0: 		            masterBroker.stop();
1: 		        }
0: 		        if(duplexBridge!=null){
0: 		            duplexBridge.stop();
1: 		        }
0: 		        // If the transport has not failed yet,
0: 		        // notify the peer that we are doing a normal shutdown.
0: 		        if(transportException==null){
0: 		            transport.oneway(new ShutdownInfo());
1: 		        }
1: 		    }
0: 		    
0: 		}catch(Exception ignore){
0: 		    log.trace("Exception caught stopping",ignore);
1: 		}
0: 		if(disposed.compareAndSet(false,true)){
0: 
0: 		    // Let all the connection contexts know we are shutting down
0: 		    // so that in progress operations can notice and unblock.
0: 			 List<TransportConnectionState> connectionStates=listConnectionStates();
0: 		     for (TransportConnectionState cs : connectionStates) {
0: 		         cs.getContext().getStopping().set(true);
1: 		     }            	
0: 			
0: 		    if( taskRunner!=null ) {
0: 		        taskRunner.wakeup();
0: 		        // Give it a change to stop gracefully.
0: 		        dispatchStoppedLatch.await(5, TimeUnit.SECONDS);
0: 		        disposeTransport();
0: 		        taskRunner.shutdown();
0: 		    } else {
0: 		        disposeTransport();
1: 		    }
0: 
0: 		    if( taskRunner!=null )
0: 		        taskRunner.shutdown();
0: 		    
0: 		    // Run the MessageDispatch callbacks so that message references get cleaned up.
0: 		    for (Iterator iter = dispatchQueue.iterator(); iter.hasNext();) {
0: 		        Command command = (Command) iter.next();
0: 		        if(command.isMessageDispatch()) {
0: 		            MessageDispatch md=(MessageDispatch) command;
0: 		            Runnable sub=md.getTransmitCallback();
0: 		            broker.processDispatch(md);
0: 		            if(sub!=null){
0: 		                sub.run();
1: 		            }
1: 		        }
1: 		    } 
0: 		    //
0: 		    // Remove all logical connection associated with this connection
0: 		    // from the broker.
0: 		    
0: 		    if (!broker.isStopped()) {
0: 				for (TransportConnectionState cs : connectionStates) {
0: 					cs.getContext().getStopping().set(true);
0: 					try {
0: 						log.debug("Cleaning up connection resources: " + getRemoteAddress());
0: 						processRemoveConnection(cs.getInfo().getConnectionId());
0: 					} catch (Throwable ignore) {
0: 						ignore.printStackTrace();
1: 					}
1: 				}
0: 
0: 				if (brokerInfo != null) {
0: 					broker.removeBroker(this, brokerInfo);
1: 				}
1: 			}
0: 			log.debug("Connection Stopped: " + getRemoteAddress());
1: 		}
1: 	}
0: 
0: 	 * @return Returns the blockedCandidate.
1: 	 */
0: 	 * @param blockedCandidate
0: 	 *            The blockedCandidate to set.
1: 	 */
/////////////////////////////////////////////////////////////////////////
1:         this.brokerInfo = info;
0: 		broker.addBroker(this, info);
0: 		networkConnection = true;
0: 
0: 		List<TransportConnectionState> connectionStates = listConnectionStates();
0: 		for (TransportConnectionState cs : connectionStates) {
0: 			cs.getContext().setNetworkConnection(true);
1: 		}
0: 
1: 		return null;
/////////////////////////////////////////////////////////////////////////
0: 		List<TransportConnectionState> connectionStates = listConnectionStates();
0: 		for (TransportConnectionState cs : connectionStates) {
0: 	        if( cs.getInfo().getClientId() !=null )
0: 	            return cs.getInfo().getClientId();
0: 	        return cs.getInfo().getConnectionId().toString();
1: 		}
1: 		return null;
/////////////////////////////////////////////////////////////////////////
0:                 TransportConnectionState state=lookupConnectionState(id);
/////////////////////////////////////////////////////////////////////////
0:                 TransportConnectionState state=lookupConnectionState(id);
/////////////////////////////////////////////////////////////////////////
0: 	///////////////////////////////////////////////////////////////////
0: 	//
0: 	// The following methods handle the logical connection state.  It is possible
0: 	// multiple logical connections multiplexed over a single physical connection.
0: 	// But have not yet exploited the feature from the clients, so for performance
0: 	// reasons (to avoid a hash lookup) this class only keeps track of 1 
0: 	// logical connection state.
0: 	//
0: 	// A sub class could override these methods to a full multiple logical connection
0: 	// support.
0: 	//
0: 	///////////////////////////////////////////////////////////////////
0: 	
0: 	protected TransportConnectionState registerConnectionState(ConnectionId connectionId, TransportConnectionState state) {
0: 		TransportConnectionState rc = connectionState;
0: 		connectionState = state;
0: 		return rc;
1: 	}
0: 	
0: 	protected TransportConnectionState unregisterConnectionState(ConnectionId connectionId) {
0: 		TransportConnectionState rc = connectionState;
0: 		connectionState = null;
0: 		return rc;
1: 	}
0: 	protected List<TransportConnectionState> listConnectionStates() {
0: 		ArrayList<TransportConnectionState> rc = new ArrayList<TransportConnectionState>();
0: 		if( connectionState!=null ) {
0: 			rc.add(connectionState);
1: 		}
0: 		return rc;
1: 	}
0: 
0: 	protected TransportConnectionState lookupConnectionState(String connectionId){
0:         TransportConnectionState cs=connectionState;
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a connectionId for a connection that had not been registered: "
0:                     +connectionId);
0:         return cs;
1:     }
0:     protected TransportConnectionState lookupConnectionState(ConsumerId id){
0:         TransportConnectionState cs=connectionState;
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a consumer from a connection that had not been registered: "
0:                     +id.getParentId().getParentId());
0:         return cs;
1:     }
0:     protected TransportConnectionState lookupConnectionState(ProducerId id){
0:         TransportConnectionState cs=connectionState;
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a producer from a connection that had not been registered: "
0:                     +id.getParentId().getParentId());
0:         return cs;
1:     }
0:     protected TransportConnectionState lookupConnectionState(SessionId id){
0:         TransportConnectionState cs=connectionState;
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a session from a connection that had not been registered: "
0:                     +id.getParentId());
0:         return cs;
1:     }
0:     protected TransportConnectionState lookupConnectionState(ConnectionId connectionId){
0:         TransportConnectionState cs=connectionState;
0:         if(cs==null)
0:             throw new IllegalStateException("Cannot lookup a connection that had not been registered: "+connectionId);
0:         return cs;
1:     }
0: 
commit:8f6fac7
/////////////////////////////////////////////////////////////////////////
0:     protected TaskRunner taskRunner;
/////////////////////////////////////////////////////////////////////////
0: 	final private TaskRunnerFactory taskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:         this.taskRunnerFactory=taskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:         	transport.start();
0:         	
0:         	if (taskRunnerFactory != null) {
0: 				taskRunner = taskRunnerFactory.createTaskRunner(this, "ActiveMQ Connection Dispatcher: " + getRemoteAddress());
0: 			} else {
0: 				taskRunner = null;
0: 			} 
0: 
commit:489f5aa
/////////////////////////////////////////////////////////////////////////
0:         } else {
0:         	context = result.getConnectionContext();
commit:fb3b6db
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ConsumerControl;
0: import org.apache.activemq.command.ControlCommand;
/////////////////////////////////////////////////////////////////////////
0: 	public Response processControlCommand(ControlCommand command) throws Exception {
0: 	    if (command.equals("shutdown"))
0: 	        System.exit(0);
1:         return null;
0: 	}
0: 
0: 	public Response processMessageDispatch(MessageDispatch dispatch) throws Exception {
1: 		return null;
0: 	}
0: 
0: 	public Response processConnectionControl(ConnectionControl control) throws Exception {
1: 		return null;
0: 	}
0: 
0: 	public Response processConnectionError(ConnectionError error) throws Exception {
1: 		return null;
0: 	}
0: 
0: 	public Response processConsumerControl(ConsumerControl control) throws Exception {
1: 		return null;
0: 	}
0: 
commit:4207bd9
/////////////////////////////////////////////////////////////////////////
0:     private ConnectionContext context;
/////////////////////////////////////////////////////////////////////////
0:         
0:         // The context may have been flagged so that the response is not sent.
0:         if( context!=null ) {
0:         	if( context.isDontSendReponse() ) {
0:         		context.setDontSendReponse(false);
0:         		response=null;
0:         	}
0:             context=null;
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:         context=null;
/////////////////////////////////////////////////////////////////////////
0:         context=null;
/////////////////////////////////////////////////////////////////////////
0:         context=null;
/////////////////////////////////////////////////////////////////////////
0:         context=null;
/////////////////////////////////////////////////////////////////////////
0:         context=null;
/////////////////////////////////////////////////////////////////////////
0:         context=null;
/////////////////////////////////////////////////////////////////////////
0:         context=null;
/////////////////////////////////////////////////////////////////////////
0:         context=new ConnectionContext();
/////////////////////////////////////////////////////////////////////////
0:                 context=state.getContext();
/////////////////////////////////////////////////////////////////////////
0:                 context=state.getContext();
commit:1a3f54c
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.CommandTypes;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicInteger protocolVersion=new AtomicInteger(CommandTypes.PROTOCOL_VERSION);
/////////////////////////////////////////////////////////////////////////
0:     	protocolVersion.set(info.getVersion());
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	public int getProtocolVersion() {
0: 		return protocolVersion.get();
0: 	}
commit:ec14f65
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ProducerAck;
/////////////////////////////////////////////////////////////////////////
0:     
1:     public Response processProducerAck(ProducerAck ack) throws Exception {
0: 		// A broker should not get ProducerAck messages.
1: 		return null;
0: 	}    
0: 
/////////////////////////////////////////////////////////////////////////
0: 	}
0: 
commit:f7db42a
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 Runnable sub=md.getTransmitCallback();
/////////////////////////////////////////////////////////////////////////
0:                 Runnable sub=md.getTransmitCallback();
0:                 if(sub!=null){
/////////////////////////////////////////////////////////////////////////
0:                         Runnable sub=md.getTransmitCallback();
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
commit:caa30ff
/////////////////////////////////////////////////////////////////////////
0:     protected final AtomicBoolean asyncException = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0: 		if( asyncException.compareAndSet(false, true) ) {
0: 			new Thread("Async Exception Handler") {
0: 				public void run() {
0: 					serviceException(e);
0: 				}
0: 			}.start();
0: 		}
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processBeginTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processEndTransaction(TransactionInfo info) throws Exception {
0:     synchronized public Response processPrepareTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processRollbackTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processForgetTransaction(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processRecoverTransactions(TransactionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processAddDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processRemoveDestination(DestinationInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processAddProducer(ProducerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processRemoveProducer(ProducerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processAddConsumer(ConsumerInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processRemoveConsumer(ConsumerId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processAddSession(SessionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processRemoveSession(SessionId id) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processAddConnection(ConnectionInfo info) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response processRemoveConnection(ConnectionId id)  {
commit:da7478d
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: 
0: import org.apache.activemq.Service;
1: import org.apache.activemq.broker.region.ConnectionStatistics;
1: import org.apache.activemq.broker.region.RegionBroker;
0: import org.apache.activemq.command.ConnectionControl;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DataArrayResponse;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.FlushCommand;
0: import org.apache.activemq.command.IntegerResponse;
0: import org.apache.activemq.command.KeepAliveInfo;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageDispatchNotification;
0: import org.apache.activemq.command.MessagePull;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.command.TransactionInfo;
0: import org.apache.activemq.command.WireFormatInfo;
1: import org.apache.activemq.security.MessageAuthorizationPolicy;
1: import org.apache.activemq.state.CommandVisitor;
1: import org.apache.activemq.state.ConsumerState;
1: import org.apache.activemq.state.ProducerState;
1: import org.apache.activemq.state.SessionState;
1: import org.apache.activemq.state.TransactionState;
1: import org.apache.activemq.thread.Task;
1: import org.apache.activemq.thread.TaskRunner;
0: import org.apache.activemq.util.ServiceSupport;
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
0: import edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch;
0: import edu.emory.mathcs.backport.java.util.concurrent.TimeUnit;
0: public class TransportConnection implements Service, Connection, Task, CommandVisitor {
0: 	
0:     private static final Log transportLog = LogFactory.getLog(TransportConnection.class.getName() + ".Transport");
0:     private static final Log serviceLog = LogFactory.getLog(TransportConnection.class.getName() + ".Service");
0:     
1:     // Keeps track of the broker and connector that created this connection.
1:     protected final Broker broker;
0:     private MasterBroker masterBroker; 
1:     protected final TransportConnector connector;
0:     private final Transport transport;    
0:     private MessageAuthorizationPolicy messageAuthorizationPolicy;
0:     
1:     // Keeps track of the state of the connections.
0:     protected final ConcurrentHashMap localConnectionStates = new ConcurrentHashMap();
0:     protected final Map brokerConnectionStates;
0:     
1:     // The broker and wireformat info that was exchanged.
1:     protected BrokerInfo brokerInfo;
0:     private WireFormatInfo wireFormatInfo;    
0: 
0:     // Used to do async dispatch..  this should perhaps be pushed down into the transport layer..
0:     protected final List dispatchQueue = Collections.synchronizedList(new LinkedList());
0:     protected final TaskRunner taskRunner;
0:     protected IOException transportException;        
0:     private boolean inServiceException=false;
0: 
0:     private ConnectionStatistics statistics = new ConnectionStatistics();
1:     private boolean manageable;
/////////////////////////////////////////////////////////////////////////
0:     
0:     protected final AtomicBoolean disposed=new AtomicBoolean(false);
0:     private CountDownLatch stopLatch = new CountDownLatch(1);
0:     
0:     static class ConnectionState extends org.apache.activemq.state.ConnectionState {
0:         private final ConnectionContext context;
0:         TransportConnection connection;
0: 
0:         public ConnectionState(ConnectionInfo info, ConnectionContext context, TransportConnection connection) {
0:             super(info);
0:             this.context = context;
0:             this.connection=connection;
0:         }
0:         
0:         public ConnectionContext getContext() {
0:             return context;
0:         }
0:         
0:         public TransportConnection getConnection() {
0:             return connection;
0:         }
0:         
0:     }
/////////////////////////////////////////////////////////////////////////
0: 
0:         this.connector = connector;
0:         this.broker = broker;
0:         
0:         RegionBroker rb = (RegionBroker) broker.getAdaptor(RegionBroker.class);
0:         brokerConnectionStates = rb.getConnectionStates();
0:         
0:         if (connector != null) {
1:             this.statistics.setParent(connector.getStatistics());
0:         }
0:         
0:         if( taskRunnerFactory != null ) {
0:             taskRunner = taskRunnerFactory.createTaskRunner( this, "ActiveMQ Connection Dispatcher: "+System.identityHashCode(this) );
0:         }
0:         else { 
0:             taskRunner = null;
0:         }        
0:         
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0:     
0:     
0:     
1:     /**
1:      * Returns the number of messages to be dispatched to this connection
1:      */
0:     public int getDispatchQueueSize() {
0:         return dispatchQueue.size();
0:     }
0:     
0: 
0:     public void serviceTransportException(IOException e) {
0:         if( !disposed.get() ) {
0:             transportException = e; 
0:             if( transportLog.isDebugEnabled() )
0:                 transportLog.debug("Transport failed: "+e,e);
0:             ServiceSupport.dispose(this);
0:         }
0:     }
0:     
1:     /**
0:      * Calls the serviceException method in an async thread.  Since 
0:      * handling a service exception closes a socket, we should not tie 
0:      * up broker threads since client sockets may hang or cause deadlocks.
0:      * 
0:      * @param e
1:      */
0: 	public void serviceExceptionAsync(final IOException e) {
0: 		new Thread("Async Exception Handler") {
0: 			public void run() {
0: 				serviceException(e);
0: 			}
0: 		}.start();
0: 	}
0: 
1: 	/**
0: 	 * Closes a clients connection due to a detected error.
0: 	 * 
0: 	 * Errors are ignored if: the client is closing or broker is closing.
0: 	 * Otherwise, the connection error transmitted to the client before stopping it's
0: 	 * transport.
1: 	 */
0:     public void serviceException(Throwable e) {
1:         // are we a transport exception such as not being able to dispatch
1:         // synchronously to a transport
0:         if (e instanceof IOException) {
0:             serviceTransportException((IOException) e);
0:         }
0:         
0:         // Handle the case where the broker is stopped 
0:         // But the client is still connected.
0:         else if (e.getClass() == BrokerStoppedException.class ) {
0:             if( !disposed.get() ) {
0:                 if( serviceLog.isDebugEnabled() )
0:                     serviceLog.debug("Broker has been stopped.  Notifying client and closing his connection.");
0:                 
0:                 ConnectionError ce = new ConnectionError();
1:                 ce.setException(e);
1:                 dispatchSync(ce);
0:                 
0:                 // Wait a little bit to try to get the output buffer to flush the exption notification to the client.
0:                 try {
1:                     Thread.sleep(500);
0:                 } catch (InterruptedException ie) {
1:                     Thread.currentThread().interrupt();
0:                 }
0:                 
0:                 // Worst case is we just kill the connection before the notification gets to him.
0:                 ServiceSupport.dispose(this);
0:             }
0:         }
0:         
0:         else if( !disposed.get() && !inServiceException ) {
0:             inServiceException = true;
0:                 try {
0:                 if( serviceLog.isDebugEnabled() )
0:                     serviceLog.debug("Async error occurred: "+e,e);
0:                 ConnectionError ce = new ConnectionError();
1:                 ce.setException(e);
1:                 dispatchAsync(ce);
0:             } finally {
0:                 inServiceException = false;
0:             }
0:         } 
0:     }
0: 
0:     public Response service(Command command) {
0:         
0:         Response response=null;
0:         boolean responseRequired = command.isResponseRequired();
0:         int commandId = command.getCommandId();
0:         try {
0:             response = command.visit(this);
0:         } catch ( Throwable e ) {
0:             if( responseRequired ) {
0:                 if( serviceLog.isDebugEnabled() && e.getClass()!=BrokerStoppedException.class )
0:                     serviceLog.debug("Error occured while processing sync command: "+e,e);
0:                 response = new ExceptionResponse(e);
0:             } else {
0:                 serviceException(e);
0:             }
0:         }        
0:         if( responseRequired ) {
0:             if( response == null ) {
0:                 response = new Response();                
0:             }
0:             response.setCorrelationId(commandId);
0:         }
1:         return response;
0:         
0:     }
0:     
0:     protected ConnectionState lookupConnectionState(ConsumerId id) {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(id.getParentId().getParentId());
0:         if( cs== null )
0:             throw new IllegalStateException("Cannot lookup a consumer from a connection that had not been registered: "+id.getParentId().getParentId());
0:         return cs;
0:     }
0:     protected ConnectionState lookupConnectionState(ProducerId id) {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(id.getParentId().getParentId());
0:         if( cs== null )
0:             throw new IllegalStateException("Cannot lookup a producer from a connection that had not been registered: "+id.getParentId().getParentId());        
0:         return cs;
0:     }
0:     protected ConnectionState lookupConnectionState(SessionId id) {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(id.getParentId());
0:         if( cs== null )
0:             throw new IllegalStateException("Cannot lookup a session from a connection that had not been registered: "+id.getParentId());        
0:         return cs;
0:     }
0:     protected ConnectionState lookupConnectionState(ConnectionId connectionId) {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(connectionId);
0:         if( cs== null )
0:             throw new IllegalStateException("Cannot lookup a connection that had not been registered: "+connectionId);
0:         return cs;
0:     }
0: 
0:     public Response processKeepAlive(KeepAliveInfo info) throws Exception {
1:         return null;
0:     }
0: 
0:     public Response processRemoveSubscription(RemoveSubscriptionInfo info) throws Exception {
0:         broker.removeSubscription(lookupConnectionState(info.getConnectionId()).getContext(), info);
1:         return null;
0:     }
0:     
0:     public Response processWireFormat(WireFormatInfo info) throws Exception {
0:         wireFormatInfo = info;
1:         return null;
0:     }
0:     
0:     public Response processShutdown(ShutdownInfo info) throws Exception {
0:         stop();
1:         return null;
0:     }
0:      
0:     public Response processFlush(FlushCommand command) throws Exception {
1:         return null;
0:     }
0: 
0:     public Response processBeginTransaction(TransactionInfo info) throws Exception {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if( cs!=null ) {
0:            context = cs.getContext();
0:         }
0:         
1:         // Avoid replaying dup commands
0:         if( cs.getTransactionState(info.getTransactionId())==null ) {
1:             cs.addTransactionState(info.getTransactionId());
0:             broker.beginTransaction(context, info.getTransactionId());
0:         }
1:         return null;
0:     }
0:     
0:     public Response processEndTransaction(TransactionInfo info) throws Exception {
0:         // No need to do anything.  This packet is just sent by the client
1:         // make sure he is synced with the server as commit command could
1:         // come from a different connection.
1:         return null;
0:     }
0:     
0:     public Response processPrepareTransaction(TransactionInfo info) throws Exception {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if( cs!=null ) {
0:            context = cs.getContext();
0:         }
0:         
0:         TransactionState transactionState = cs.getTransactionState(info.getTransactionId());
0:         if( transactionState == null )
0:             throw new IllegalStateException("Cannot prepare a transaction that had not been started: "+info.getTransactionId());
0: 
1:         // Avoid dups.
0:         if( !transactionState.isPrepared() ) {
1:             transactionState.setPrepared(true);
0:             int result = broker.prepareTransaction(context, info.getTransactionId());
1:             transactionState.setPreparedResult(result);
0:             IntegerResponse response = new IntegerResponse(result);
1:             return response;
0:         } else {
0:             IntegerResponse response = new IntegerResponse(transactionState.getPreparedResult());
1:             return response;
0:         }
0:     }
0: 
0:     public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if( cs!=null ) {
0:            context = cs.getContext();
0:         }
0:         
1:         cs.removeTransactionState(info.getTransactionId());
0:         broker.commitTransaction(context, info.getTransactionId(), true);
0: 
1:         return null;
0:         
0:     }
0: 
0:     public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if( cs!=null ) {
0:            context = cs.getContext();
0:         }
0:         
1:         cs.removeTransactionState(info.getTransactionId());
0:         broker.commitTransaction(context, info.getTransactionId(), false);
1:         return null;
0:     }
0: 
0:     public Response processRollbackTransaction(TransactionInfo info) throws Exception {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if( cs!=null ) {
0:            context = cs.getContext();
0:         }
0:         
1:         cs.removeTransactionState(info.getTransactionId());
0:         broker.rollbackTransaction(context, info.getTransactionId());
1:         return null;
0:     }
0:     
0:     public Response processForgetTransaction(TransactionInfo info) throws Exception {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if( cs!=null ) {
0:            context = cs.getContext();
0:         }
0:         broker.forgetTransaction(context, info.getTransactionId());
1:         return null;
0:     }
0:     
0:     public Response processRecoverTransactions(TransactionInfo info) throws Exception {
0:         ConnectionState cs = (ConnectionState) localConnectionStates.get(info.getConnectionId());
0:         ConnectionContext context=null;
0:         if( cs!=null ) {
0:            context = cs.getContext();
0:         }
0:         TransactionId[] preparedTransactions = broker.getPreparedTransactions(context);
1:         return new DataArrayResponse(preparedTransactions);
0:     }
0: 
0: 
0:     public Response processMessage(Message messageSend) throws Exception {
0:         
0:         ProducerId producerId = messageSend.getProducerId();
0:         ConnectionState state = lookupConnectionState(producerId);
0:         ConnectionContext context = state.getContext();
0:         
0:         // If the message originates from this client connection, 
0:         // then, finde the associated producer state so we can do some dup detection.
0:         ProducerState producerState=null;        
0:         if( messageSend.getMessageId().getProducerId().equals( messageSend.getProducerId() ) ) {
0:             SessionState ss = state.getSessionState(producerId.getParentId());
0:             if( ss == null )
0:                 throw new IllegalStateException("Cannot send from a session that had not been registered: "+producerId.getParentId());
0:             producerState = ss.getProducerState(producerId); 
0:         }
0:         
0:         if( producerState == null ) {
0:             broker.send(context, messageSend);
0:         } else {
0:             // Avoid Dups.
0:             long seq = messageSend.getMessageId().getProducerSequenceId();
0:             if( seq > producerState.getLastSequenceId() ) {
0:                 producerState.setLastSequenceId(seq);
0:                 broker.send(context, messageSend);
0:             }
0:         }
0:         
1:         return null;
0:     }
0: 
0:     public Response processMessageAck(MessageAck ack) throws Exception {
0:         broker.acknowledge(lookupConnectionState(ack.getConsumerId()).getContext(), ack);
1:         return null;
0:     }
0:     
0:     public Response processMessagePull(MessagePull pull) throws Exception {
0:         return broker.messagePull(lookupConnectionState(pull.getConsumerId()).getContext(), pull);
0:     }
0: 
0:     public Response processMessageDispatchNotification(MessageDispatchNotification notification) throws Exception{
1:         broker.processDispatchNotification(notification);
1:         return null;
0:     }
0: 
0:     public Response processAddDestination(DestinationInfo info) throws Exception {
0:         ConnectionState cs = lookupConnectionState(info.getConnectionId());
0:         broker.addDestinationInfo(cs.getContext(), info);
0:         if( info.getDestination().isTemporary() ) {
1:             cs.addTempDestination(info);
0:         }
1:         return null;
0:     }
0: 
0:     public Response processRemoveDestination(DestinationInfo info) throws Exception {
0:         ConnectionState cs = lookupConnectionState(info.getConnectionId());
0:         broker.removeDestinationInfo(cs.getContext(), info);
0:         if( info.getDestination().isTemporary() ) {
1:             cs.removeTempDestination(info.getDestination());
0:         }
1:         return null;
0:     }
0: 
0: 
0:     public Response processAddProducer(ProducerInfo info) throws Exception {
0:         SessionId sessionId = info.getProducerId().getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();
0:         
0:         ConnectionState cs = lookupConnectionState(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
0:         if( ss == null )
0:             throw new IllegalStateException("Cannot add a producer to a session that had not been registered: "+sessionId);
0: 
1:         // Avoid replaying dup commands
0:         if( !ss.getProducerIds().contains(info.getProducerId()) ) {
0:             broker.addProducer(cs.getContext(), info);
0:             try {
1:                 ss.addProducer(info);
0:             } catch (IllegalStateException e) {
0:                 broker.removeProducer(cs.getContext(), info);
0:             }
0:         }
1:         return null;
0:     }
0:     
0:     public Response processRemoveProducer(ProducerId id) throws Exception {
0:         SessionId sessionId = id.getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();
0:         
0:         ConnectionState cs = lookupConnectionState(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
0:         if( ss == null )
0:             throw new IllegalStateException("Cannot remove a producer from a session that had not been registered: "+sessionId);
0:         ProducerState ps = ss.removeProducer(id);
0:         if( ps == null )
0:             throw new IllegalStateException("Cannot remove a producer that had not been registered: "+id);
0:         
0:         broker.removeProducer(cs.getContext(), ps.getInfo());
1:         return null;
0:     }
0: 
0:     public Response processAddConsumer(ConsumerInfo info) throws Exception {
0:         SessionId sessionId = info.getConsumerId().getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();
0:         
0:         ConnectionState cs = lookupConnectionState(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
0:         if( ss == null )
0:             throw new IllegalStateException("Cannot add a consumer to a session that had not been registered: "+sessionId);
0: 
1:         // Avoid replaying dup commands
0:         if( !ss.getConsumerIds().contains(info.getConsumerId()) ) {
0:             broker.addConsumer(cs.getContext(), info);
0:             try {
1:                 ss.addConsumer(info);
0:             } catch (IllegalStateException e) {
0:                 broker.removeConsumer(cs.getContext(), info);
0:             }
0:         }
0:         
1:         return null;
0:     }
0:     
0:     public Response processRemoveConsumer(ConsumerId id) throws Exception {
0:         
0:         SessionId sessionId = id.getParentId();
0:         ConnectionId connectionId = sessionId.getParentId();
0:         
0:         ConnectionState cs = lookupConnectionState(connectionId);
0:         SessionState ss = cs.getSessionState(sessionId);
0:         if( ss == null )
0:             throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: "+sessionId);
0:         ConsumerState consumerState = ss.removeConsumer(id);
0:         if( consumerState == null )
0:             throw new IllegalStateException("Cannot remove a consumer that had not been registered: "+id);
0:         
0:         broker.removeConsumer(cs.getContext(), consumerState.getInfo());
1:         return null;
0:     }
0:     
0:     public Response processAddSession(SessionInfo info) throws Exception {
0:         ConnectionId connectionId = info.getSessionId().getParentId();
0:         ConnectionState cs = lookupConnectionState(connectionId);
0:         
1:         // Avoid replaying dup commands
0:         if( !cs.getSessionIds().contains(info.getSessionId()) ) {
0:             broker.addSession(cs.getContext(), info);
0:             try {
1:                 cs.addSession(info);
0:             } catch (IllegalStateException e) {
0:                 broker.removeSession(cs.getContext(), info);
0:             }
0:         }
1:         return null;
0:     }
0:     
0:     public Response processRemoveSession(SessionId id) throws Exception {
0:         
0:         ConnectionId connectionId = id.getParentId();
0:         
0:         ConnectionState cs = lookupConnectionState(connectionId);
0:         SessionState session = cs.getSessionState(id);
0: 
0:         if( session == null )
0:             throw new IllegalStateException("Cannot remove session that had not been registered: "+id);
0: 
0:         // Don't let new consumers or producers get added while we are closing this down.
1:         session.shutdown();
0:         
1:         // Cascade the connection stop to the consumers and producers.
0:         for (Iterator iter = session.getConsumerIds().iterator(); iter.hasNext();) {
0:             ConsumerId consumerId = (ConsumerId) iter.next();
0:             try {
0:                 processRemoveConsumer(consumerId);
0:             }
0:             catch (Throwable e) {
0:                 log.warn("Failed to remove consumer: " + consumerId + ". Reason: " + e, e);
0:             }
0:         }
0:         for (Iterator iter = session.getProducerIds().iterator(); iter.hasNext();) {
0:             ProducerId producerId = (ProducerId) iter.next();
0:             try {
1:                 processRemoveProducer(producerId);
0:             }
0:             catch (Throwable e) {
0:                 log.warn("Failed to remove producer: " + producerId + ". Reason: " + e, e);
0:             }
0:         }
1:         cs.removeSession(id);
0:         broker.removeSession(cs.getContext(), session.getInfo());
1:         return null;
0:     }
0:     
0:     public Response processAddConnection(ConnectionInfo info) throws Exception {
0: 
0:     	ConnectionState state = (ConnectionState) brokerConnectionStates.get(info.getConnectionId());
0:     	
0:     	if( state !=null ) {
0:     		// ConnectionInfo replay??  Chances are that it's a client reconnecting,
0:     		// and we have not detected that that old connection died.. Kill the old connection
0:     		// to make sure our state is in sync with the client.
0:     		if( this != state.getConnection() ) {
0:     			log.debug("Killing previous stale connection: "+state.getConnection());
0:     			state.getConnection().stop();
0:     			if( !state.getConnection().stopLatch.await(15, TimeUnit.SECONDS) ) {
0:     				throw new Exception("Previous connection could not be clean up.");
0:     			}
0:     		}
0:     	}
0:     	
0: 		log.debug("Setting up new connection: "+this);
0: 
0:     	
1:         // Setup the context.
0:         String clientId = info.getClientId();
0:         ConnectionContext context = new ConnectionContext();
1:         context.setConnection(this);
1:         context.setBroker(broker);
1:         context.setConnector(connector);
0:         context.setTransactions(new ConcurrentHashMap());
1:         context.setClientId(clientId);
1:         context.setUserName(info.getUserName());
1:         context.setConnectionId(info.getConnectionId());
1:         context.setWireFormatInfo(wireFormatInfo);
0:         context.incrementReference();
0:         this.manageable = info.isManageable();
0:         
0:         state = new ConnectionState(info, context, this);
0:         brokerConnectionStates.put(info.getConnectionId(), state);
0:         localConnectionStates.put(info.getConnectionId(), state);           
0:         
0:         broker.addConnection(context, info);
0:         if (info.isManageable() && broker.isFaultTolerantConfiguration()){
0:             //send ConnectionCommand
0:             ConnectionControl command = new ConnectionControl();
1:             command.setFaultTolerant(broker.isFaultTolerantConfiguration());
1:             dispatchAsync(command);
0:         }
0: 
1:         return null;
0:     }
0:     
0:     public Response processRemoveConnection(ConnectionId id)  {
0:         
0:         ConnectionState cs = lookupConnectionState(id);
0:         
0:         // Don't allow things to be added to the connection state while we are shutting down.
0:         cs.shutdown();
0:         
0:         // Cascade the connection stop to the sessions.
0:         for (Iterator iter = cs.getSessionIds().iterator(); iter.hasNext();) {
0:            
0:                 SessionId sessionId = (SessionId) iter.next();
0:                 try{
0:                 processRemoveSession(sessionId);
0:             }catch(Throwable e){
0:                 serviceLog.warn("Failed to remove session " + sessionId,e);
0:             }
0:         }
0:         
0:         // Cascade the connection stop to temp destinations.
0:         for (Iterator iter = cs.getTempDesinations().iterator(); iter.hasNext();) {
0:             DestinationInfo di = (DestinationInfo) iter.next();
0:             try{
0:                 broker.removeDestination(cs.getContext(), di.getDestination(), 0);
0:             }catch(Throwable e){
0:                serviceLog.warn("Failed to remove tmp destination " + di.getDestination(), e);
0:             }
0:             iter.remove();
0:         }
0:         
0:         try{
0:             broker.removeConnection(cs.getContext(), cs.getInfo(), null);
0:         }catch(Throwable e){
0:             serviceLog.warn("Failed to remove connection " +  cs.getInfo(),e);
0:         }
0:         ConnectionState state = (ConnectionState) localConnectionStates.remove(id);
0:         if( state != null ) {
0:             // If we are the last reference, we should remove the state
0:             // from the broker.
0:             if( state.getContext().decrementReference() == 0 ){ 
0:                 brokerConnectionStates.remove(id);
0:             }
0:         }
1:         return null;
0:     }
0: 
0:     
0:     public Connector getConnector() {
1:         return connector;
0:     }
0: 
0:     public void dispatchSync(Command message) {
1:         processDispatch(message);
0:     }
0:     
0:     
0:     public void dispatchAsync(Command message) {
0:         if( taskRunner==null ) {
0:             dispatchSync( message );
0:         } else {
0:             dispatchQueue.add(message);
0:             try {
0:                 taskRunner.wakeup();
0:             } catch (InterruptedException e) {
1:                 Thread.currentThread().interrupt();
0:             }
0:         }        
0:     }
0:     
0:     protected void processDispatch(Command command){
0:         if(command.isMessageDispatch()){
0:             MessageDispatch md=(MessageDispatch) command;
0:             Runnable sub=(Runnable) md.getConsumer();
0:             broker.processDispatch(md);
0:             try{
0:                 dispatch(command);
0:             }finally{
0:                 if(sub!=null){
0:                     sub.run();
0:                 }
0:             }
0:         }else{
0:             dispatch(command);
0:         }
0:     }       
0:     
0:     public boolean iterate() {
0:         if( dispatchQueue.isEmpty() || broker.isStopped()) {
0:             return false;
0:         } else {
0:             Command command = (Command) dispatchQueue.remove(0);
0:             processDispatch( command );
0:             return true;
0:         }
0:     }    
0:             
1:     /**
1:      * Returns the statistics for this connection
1:      */
0:     public ConnectionStatistics getStatistics() {
1:         return statistics;
0:     }
0: 
0:     public MessageAuthorizationPolicy getMessageAuthorizationPolicy() {
1:         return messageAuthorizationPolicy;
0:     }
0: 
0:     public void setMessageAuthorizationPolicy(MessageAuthorizationPolicy messageAuthorizationPolicy) {
0:         this.messageAuthorizationPolicy = messageAuthorizationPolicy;
0:     }
0:     
0:     public boolean isManageable(){
1:         return manageable;
0:     }
0:     
0:     
0:             this.processDispatch(connector.getBrokerInfo());
/////////////////////////////////////////////////////////////////////////
0: 	       
0: 	        if(disposed.compareAndSet(false, true)) {
0: 		        
0: 		        if( taskRunner!=null )
0: 		            taskRunner.shutdown();
0: 		        
0: 		        // Clear out the dispatch queue to release any memory that
0: 		        // is being held on to.
0: 		        dispatchQueue.clear();
0: 		        
0: 		        //
0: 		        // Remove all logical connection associated with this connection
0: 		        // from the broker.
0: 		        if(!broker.isStopped()){
0: 		            ArrayList l=new ArrayList(localConnectionStates.keySet());
0: 		            for(Iterator iter=l.iterator();iter.hasNext();){
0: 		                ConnectionId connectionId=(ConnectionId) iter.next();
0: 		                try{
0: 		                	log.debug("Cleaning up connection resources.");
0: 		                    processRemoveConnection(connectionId);
0: 		                }catch(Throwable ignore){
0: 		                	ignore.printStackTrace();
0: 		                }
0: 		            }
0: 		            if(brokerInfo!=null){
0: 		                broker.removeBroker(this,brokerInfo);
0: 		            }
0: 		        }
0: 				stopLatch.countDown();
0: 	        }
0: 	        
0: 	        
/////////////////////////////////////////////////////////////////////////
0:         
1:         // We only expect to get one broker info command per connection
0:         if( this.brokerInfo!=null ) {
0:             log.warn("Unexpected extra broker info command received: "+info);
0:         }
0:         
0:         this.brokerInfo = info;
0:         broker.addBroker(this, info);
0:         return null;
commit:cafe4cb
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean stopped = new AtomicBoolean(false);
0:     
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws Exception {
0:         synchronized(this) { 
0: 	        pendingStop = true;
0: 	        if (starting) {
0: 	            log.debug("stop() called in the middle of start(). Delaying...");
0: 	            return;
0: 	        }
0:     	
0:     	if( stopped.compareAndSet(false, true) ) {
0:     		log.debug("Stopping connection: "+transport.getRemoteAddress());
0: 	        connector.onStopped(this);
0: 	        try {
0: 	            if (masterBroker != null){
0: 	                masterBroker.stop();
0: 	            }
0: 	            
0: 	            // If the transport has not failed yet,
0: 	            // notify the peer that we are doing a normal shutdown.
0: 	            if( transportException == null ) {
0: 	            	transport.oneway(new ShutdownInfo());
0: 	            }
0: 	        } catch (Exception ignore) {
0: 	            //ignore.printStackTrace();
0: 	        }
0: 	
0: 	        transport.stop();
0: 	        active = false;
0: 	        super.stop();
0:     		log.debug("Stopped connection: "+transport.getRemoteAddress());
0:     	}
/////////////////////////////////////////////////////////////////////////
1:             serviceExceptionAsync(e);
commit:9ca56a0
/////////////////////////////////////////////////////////////////////////
0:             public void onCommand(Object o) {
0:             	Command command = (Command) o;
commit:57b4941
/////////////////////////////////////////////////////////////////////////
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
commit:d2d1c6d
/////////////////////////////////////////////////////////////////////////
0:         connector.onStarted(this);
0:         connector.onStopped(this);
commit:c59246d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ShutdownInfo;
/////////////////////////////////////////////////////////////////////////
0: 
0:         try {
0:             transport.oneway(new ShutdownInfo());
0:         } catch (IOException ignore) {
0:         }
0: 
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker;
0: 
0: import java.io.IOException;
0: 
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.Response;
1: import org.apache.activemq.thread.TaskRunnerFactory;
1: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportListener;
0: 
1: /**
0:  * 
0:  * @version $Revision: 1.8 $
1:  */
0: public class TransportConnection extends AbstractConnection {
0: 
0:     private final Transport transport;
1:     private boolean slow;
1:     private boolean markedCandidate;
1:     private boolean blockedCandidate;
1:     private boolean blocked;
1:     private boolean connected;
1:     private boolean active;
0:     private long timeStamp=0;
0: 
1:     /**
0:      * @param connector
0:      * @param transport
0:      * @param broker
0:      * @param taskRunnerFactory - can be null if you want direct dispatch to the transport else commands are sent async.
1:      */
0:     public TransportConnection(TransportConnector connector, final Transport transport, Broker broker, TaskRunnerFactory taskRunnerFactory) {
0:         super(connector, broker, taskRunnerFactory);
0:         connector.setBrokerName(broker.getBrokerName());
0:         this.transport = transport;
0:         this.transport.setTransportListener(new TransportListener() {
0:             public void onCommand(Command command) {
0:                 Response response = service(command);
0:                 if( response!=null ) {
0:                     dispatch(response);
0:                 }
0:             }
0:             public void onException(IOException exception) {
0:                 serviceTransportException(exception);
0:             }
1:         });
0:         connected = true;
0:     }
0: 
0:     public void start() throws Exception {
0:         transport.start();
0:         active = true;
0:         super.start();
0:     }
0: 
0:     public void stop() throws Exception {
0:         transport.stop();
0:         active = false;
0:         super.stop();
0:     }
0:     
0:     
1:     /**
0:      * @return Returns the blockedCandidate.
1:      */
0:     public boolean isBlockedCandidate(){
1:         return blockedCandidate;
0:     }
1:     /**
0:      * @param blockedCandidate
0:      *            The blockedCandidate to set.
1:      */
0:     public void setBlockedCandidate(boolean blockedCandidate){
0:         this.blockedCandidate=blockedCandidate;
0:     }
1:     /**
1:      * @return Returns the markedCandidate.
1:      */
0:     public boolean isMarkedCandidate(){
1:         return markedCandidate;
0:     }
1:     /**
0:      * @param markedCandidate
0:      *            The markedCandidate to set.
1:      */
0:     public void setMarkedCandidate(boolean markedCandidate){
0:         this.markedCandidate=markedCandidate;
0:         if(!markedCandidate){
0:             timeStamp=0;
0:             blockedCandidate=false;
0:         }
0:     }
1:     /**
0:      * @param slow
0:      *            The slow to set.
1:      */
0:     public void setSlow(boolean slow){
0:         this.slow=slow;
0:     }
1:     /**
1:      * @return true if the Connection is slow
1:      */
0:     public boolean isSlow(){
1:         return slow;
0:     }
1:     /**
1:      * @return true if the Connection is potentially blocked
1:      */
0:     public boolean isMarkedBlockedCandidate(){
1:         return markedCandidate;
0:     }
0:     
1:     /**
1:      * Mark the Connection, so we can deem if it's collectable on the next sweep
1:      */
0:     public void doMark(){
0:         if(timeStamp==0){
0:             timeStamp=System.currentTimeMillis();
0:         }
0:     }
1:     /**
1:      * @return if after being marked, the Connection is still writing
1:      */
0:     public boolean isBlocked(){
1:         return blocked;
0:     }
1:     /**
1:      * @return true if the Connection is connected
1:      */
0:     public boolean isConnected(){
1:         return connected;
0:     }
1:     /**
0:      * @param blocked
0:      *            The blocked to set.
1:      */
0:     public void setBlocked(boolean blocked){
0:         this.blocked=blocked;
0:     }
1:     /**
0:      * @param connected
0:      *            The connected to set.
1:      */
0:     public void setConnected(boolean connected){
0:         this.connected=connected;
0:     }
1:     /**
1:      * @return true if the Connection is active
1:      */
0:     public boolean isActive(){
1:         return active;
0:     }
1:     /**
0:      * @param active
0:      *            The active to set.
1:      */
0:     public void setActive(boolean active){
0:         this.active=active;
0:     }
0:     
0:     
0: 
0:     protected void dispatch(Command command){
0:         try{
1:             setMarkedCandidate(true);
1:             transport.oneway(command);
0:             getStatistics().onCommand(command);
0:         }catch(IOException e){
0:             serviceException(e);
0:         }finally{
1:             setMarkedCandidate(false);
0:         }
0:     }        
0: 
0: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:8b3761c
/////////////////////////////////////////////////////////////////////////
1:     // public only for testing
1:     public synchronized TransportConnectionState lookupConnectionState(ConnectionId connectionId) {
commit:1958aeb
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
0:                 throw e;
commit:ae61847
/////////////////////////////////////////////////////////////////////////
0: 
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.BrokerInfo;
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.command.CommandTypes;
0: import org.apache.activemq.command.ConnectionControl;
0: import org.apache.activemq.command.ConnectionError;
0: import org.apache.activemq.command.ConnectionId;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerControl;
0: import org.apache.activemq.command.ConsumerId;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.ControlCommand;
0: import org.apache.activemq.command.DataArrayResponse;
0: import org.apache.activemq.command.DestinationInfo;
0: import org.apache.activemq.command.ExceptionResponse;
0: import org.apache.activemq.command.FlushCommand;
0: import org.apache.activemq.command.IntegerResponse;
0: import org.apache.activemq.command.KeepAliveInfo;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.MessageDispatch;
0: import org.apache.activemq.command.MessageDispatchNotification;
0: import org.apache.activemq.command.MessagePull;
0: import org.apache.activemq.command.ProducerAck;
0: import org.apache.activemq.command.ProducerId;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.RemoveSubscriptionInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionId;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.ShutdownInfo;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.command.TransactionInfo;
0: import org.apache.activemq.command.WireFormatInfo;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransmitCallback;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         return isStomp() && ((e instanceof SocketException && e.getMessage().indexOf("reset") != -1) || e instanceof EOFException);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 TransmitCallback sub = md.getTransmitCallback();
1:                     sub.onFailure();
1:         MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);
/////////////////////////////////////////////////////////////////////////
0:         } catch (Throwable e) {
1:                 TransmitCallback sub = messageDispatch.getTransmitCallback();
1:                     sub.onFailure();
0:                 }
1:                 messageDispatch = null;
0:             }
0:         } finally {
1:             if (messageDispatch != null) {
1:                 TransmitCallback sub = messageDispatch.getTransmitCallback();
1:                 broker.postProcessDispatch(messageDispatch);
0:                 if (sub != null) {
1:                     sub.onSuccess();
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:                     TransmitCallback sub = md.getTransmitCallback();
1:                         sub.onFailure();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
commit:5cc1a55
/////////////////////////////////////////////////////////////////////////
0:     private Throwable stopError = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 // Record the error that caused the transport to stop
0:                 this.stopError = e;
/////////////////////////////////////////////////////////////////////////
0:             if (!pendingStop) {
0:                 response = command.visit(this);
0:             } else {
0:                 response = new ExceptionResponse(this.stopError);
0:             }
/////////////////////////////////////////////////////////////////////////
0:                 delayedStop(2000, "Failed with SecurityException: " + e.getLocalizedMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:     public void delayedStop(final int waitTime, final String reason, Throwable cause) {
0:                 stopError = cause;
commit:c856f30
/////////////////////////////////////////////////////////////////////////
0: 
0:                 if (pendingStop) {
0:                     if (LOG.isTraceEnabled()) {
0:                         LOG.trace("Ignoring Command due to pending stop: " + o);
0:                     }
0:                     return;
0:                 }
0: 
/////////////////////////////////////////////////////////////////////////
0:                 if (pendingStop) {
1:                     dispatchSync(ce);
0:                 } else {
0:                     dispatchAsync(ce);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:             if(e instanceof java.lang.SecurityException){
0:                 // still need to close this down - in case the peer of this transport doesn't play nice
0:                 delayedStop(2000, "Failed with SecurityException: " + e.getLocalizedMessage());
0:             }
0:             if (responseRequired) {
/////////////////////////////////////////////////////////////////////////
0:         if (cs == null) {
1:             throw new IllegalStateException("Cannot add a producer to a connection that had not been registered: "
0:                     + connectionId);
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (cs == null) {
1:             throw new IllegalStateException("Cannot add a consumer to a connection that had not been registered: "
0:                     + connectionId);
0:         }
/////////////////////////////////////////////////////////////////////////
1:         for (ConsumerId consumerId : session.getConsumerIds()) {
1:         for (ProducerId producerId : session.getProducerIds()) {
/////////////////////////////////////////////////////////////////////////
1:             for (SessionId sessionId : cs.getSessionIds()) {
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator<DestinationInfo> iter = cs.getTempDestinations().iterator(); iter.hasNext(); ) {
1:                 DestinationInfo di = iter.next();
/////////////////////////////////////////////////////////////////////////
0:             synchronized (this) {
0:                 pendingStop = true;
0:             }
commit:802f6b1
/////////////////////////////////////////////////////////////////////////
1:         if (consumerExchange != null) {
0:             broker.acknowledge(consumerExchange, ack);
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 addConsumerBrokerExchange(info.getConsumerId());
/////////////////////////////////////////////////////////////////////////
1:             // are shutting down.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (pendingStop || stopping.get()) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return result;
0:     }
0: 
0:     private ConsumerBrokerExchange addConsumerBrokerExchange(ConsumerId id) {
0:         ConsumerBrokerExchange result = consumerExchanges.get(id);
commit:cfcd4f7
/////////////////////////////////////////////////////////////////////////
0:                 TRANSPORTLOG.debug(this + " failed: " + e, e);
0:                 TRANSPORTLOG.warn(this + " failed: " + e);
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings({ "unchecked", "rawtypes" })
commit:1ec9905
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0:      *
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 String duplexNetworkConnectorId = config.getName() + "@" + info.getBrokerId();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:                 TransportConnectionState state = lookupConnectionState(id);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public boolean isStopping() {
1:         return stopping.get();
0:     }
0: 
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:8a01c5d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final TaskRunnerFactory stopTaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:      * @param stopTaskRunnerFactory - can <b>not</b> be null, used for stopping this connection.
1:                                TaskRunnerFactory taskRunnerFactory, TaskRunnerFactory stopTaskRunnerFactory) {
1:             this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();
1:         this.stopTaskRunnerFactory = stopTaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:         // do not stop task the task runner factories (taskRunnerFactory, stopTaskRunnerFactory)
1:         // as their lifecycle is handled elsewhere
0: 
/////////////////////////////////////////////////////////////////////////
1:                 stopTaskRunnerFactory.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
1:                 });
1:                 LOG.warn("Cannot create stopAsync. This exception will be ignored.", t);
/////////////////////////////////////////////////////////////////////////
1:                 stopTaskRunnerFactory.execute(new Runnable() {
/////////////////////////////////////////////////////////////////////////
0:                 });
1:                 LOG.warn("Cannot create async transport stopper thread. This exception is ignored. Not waiting for stop to complete", t);
/////////////////////////////////////////////////////////////////////////
1:     protected void doStop() throws Exception {
1:         LOG.debug("Stopping connection: {}", transport.getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("Exception caught stopping. This exception is ignored.", ignore);
0:             LOG.debug("Could not stop transport to " + transport.getRemoteAddress() + ". This exception is ignored.", e);
0:             taskRunner = null;
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Cleaning up connection resources: {}", getRemoteAddress());
1:         LOG.debug("Connection Stopped: {}", getRemoteAddress());
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:2280719
/////////////////////////////////////////////////////////////////////////
1:             if (info.isFailoverReconnect()) {
1:                 command.setRebalanceConnection(false);
0:             }
commit:91059de
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import javax.transaction.xa.XAResource;
0: import java.io.EOFException;
0: import java.io.IOException;
0: import java.net.SocketException;
0: import java.net.URI;
0: import java.util.HashMap;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: import java.util.List;
0: import java.util.Map;
0: import java.util.Properties;
0: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import java.util.concurrent.CountDownLatch;
0: import java.util.concurrent.TimeUnit;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: import java.util.concurrent.atomic.AtomicInteger;
0: import java.util.concurrent.atomic.AtomicReference;
0: import java.util.concurrent.locks.ReentrantReadWriteLock;
0: 
commit:fd6c731
/////////////////////////////////////////////////////////////////////////
1:         if (info.getClientIp() == null) {
1:             info.setClientIp(getRemoteAddress());
0:         }
commit:b5579ac
/////////////////////////////////////////////////////////////////////////
0:         info.setClientIp(getRemoteAddress());
commit:3da9f1c
/////////////////////////////////////////////////////////////////////////
1:         MDC.put("activemq.connector", connector.getUri().toString());
/////////////////////////////////////////////////////////////////////////
1:         MDC.remove("activemq.connector");
commit:2b456dd
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.MDC;
/////////////////////////////////////////////////////////////////////////
0:         MDC.put("connector", connector.getUri().toString());
/////////////////////////////////////////////////////////////////////////
0:         MDC.remove("connector");
commit:f0429be
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.*;
/////////////////////////////////////////////////////////////////////////
0:                 final Map context = MDCHelper.getCopyOfContextMap();
0:                             MDCHelper.setContextMap(context);
commit:8700ab7
/////////////////////////////////////////////////////////////////////////
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(TransportConnection.class);
1:     private static final Logger TRANSPORTLOG = LoggerFactory.getLogger(TransportConnection.class.getName() + ".Transport");
1:     private static final Logger SERVICELOG = LoggerFactory.getLogger(TransportConnection.class.getName() + ".Service");
commit:53ea4ca
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator iter = cs.getTempDestinations().iterator(); iter.hasNext();) {
commit:2a2dcd5
/////////////////////////////////////////////////////////////////////////
0: import javax.management.ObjectName;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.network.*;
/////////////////////////////////////////////////////////////////////////
1:                 String duplexName = localTransport.toString();
1:                 if (duplexName.contains("#")) {
1:                     duplexName = duplexName.substring(duplexName.lastIndexOf("#"));
0:                 }
0:                 MBeanNetworkListener listener = new MBeanNetworkListener(broker.getBrokerService(), broker.getBrokerService().createDuplexNetworkConnectorObjectName(duplexName));
1:                 listener.setCreatedByDuplex(true);
0:                 duplexBridge = NetworkBridgeFactory.createBridge(config, localTransport, remoteBridgeTransport, listener);
commit:784b93d
/////////////////////////////////////////////////////////////////////////
0:                 HashMap<String, String> map = new HashMap<String, String>(URISupport.parseParameters(uri));
commit:662aee8
/////////////////////////////////////////////////////////////////////////
1:                         throw new RuntimeException("Protocol violation - Command corrupted: " + o.toString());
commit:59643ef
/////////////////////////////////////////////////////////////////////////
1:                     if (!(o instanceof Command)) {
0:                         throw new RuntimeException("Protocol violation - Command corrupted");
0:                     }
author:James Strachan
-------------------------------------------------------------------------------
commit:a28ccae
/////////////////////////////////////////////////////////////////////////
0:         this.messageAuthorizationPolicy = connector.getMessageAuthorizationPolicy();
/////////////////////////////////////////////////////////////////////////
0:         context.setConnection(this);
0:         context.setConnectionId(info.getConnectionId());
0:         context.setConnector(connector);
1:         context.setMessageAuthorizationPolicy(getMessageAuthorizationPolicy());
0:         context.setTransactions(new ConcurrentHashMap<TransactionId, Transaction>());
0:         context.setUserName(info.getUserName());
0:         context.setWireFormatInfo(wireFormatInfo);
commit:d57343c
/////////////////////////////////////////////////////////////////////////
0:                 Object consumer = md.getConsumer();
0:                 if (consumer instanceof Runnable) {
0:                     Runnable sub=(Runnable) consumer;
commit:4b595ea
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: 
/////////////////////////////////////////////////////////////////////////
0:     private boolean starting;
0:     private boolean pendingStop;
0:     private long timeStamp = 0;
/////////////////////////////////////////////////////////////////////////
0:                 if (response != null) {
0: 
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void start() throws Exception {
0:         starting = true;
0:         try {
0:             transport.start();
0:             active = true;
0:             super.start();
0:             connector.onStarted(this);
0:         }
0:         finally {
1:             // stop() can be called from within the above block,
1:             // but we want to be sure start() completes before
1:             // stop() runs, so queue the stop until right now:
0:             starting = false;
0:             if (pendingStop) {
0:                 log.debug("Calling the delayed stop()");
0:                 stop();
0:             }
0:         }
0:     public synchronized void stop() throws Exception {
0:         // If we're in the middle of starting
0:         // then go no further... for now.
0:         pendingStop = true;
0:         if (starting) {
0:             log.debug("stop() called in the middle of start(). Delaying...");
0:             return;
0:         }
0: 
0:             if (masterBroker != null) {
0: 
0:             if (transportException == null) {
0:                 transport.oneway(new ShutdownInfo());
0:         }
0:         catch (Exception ignore) {
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     public boolean isBlockedCandidate() {
0: 
0:      * @param blockedCandidate The blockedCandidate to set.
0:     public void setBlockedCandidate(boolean blockedCandidate) {
0:         this.blockedCandidate = blockedCandidate;
0: 
0:     public boolean isMarkedCandidate() {
0: 
0:      * @param markedCandidate The markedCandidate to set.
0:     public void setMarkedCandidate(boolean markedCandidate) {
0:         this.markedCandidate = markedCandidate;
0:         if (!markedCandidate) {
0:             timeStamp = 0;
0:             blockedCandidate = false;
0: 
0:      * @param slow The slow to set.
0:     public void setSlow(boolean slow) {
0:         this.slow = slow;
0: 
0:     public boolean isSlow() {
0: 
0:     public boolean isMarkedBlockedCandidate() {
0: 
0:     public void doMark() {
0:         if (timeStamp == 0) {
0:             timeStamp = System.currentTimeMillis();
0: 
0:     public boolean isBlocked() {
0: 
0:     public boolean isConnected() {
0: 
0:      * @param blocked The blocked to set.
0:     public void setBlocked(boolean blocked) {
0:         this.blocked = blocked;
0: 
0:      * @param connected The connected to set.
0:     public void setConnected(boolean connected) {
0:         this.connected = connected;
0: 
0:     public boolean isActive() {
0: 
0:      * @param active The active to set.
0:     public void setActive(boolean active) {
0:         this.active = active;
0: 
0:     /**
1:      * @return true if the Connection is starting
0:      */
0:     public synchronized boolean isStarting() {
0:         return starting;
0:     }
0: 
0:     synchronized protected void setStarting(boolean starting) {
0:         this.starting = starting;
0:     }
0: 
0:     /**
1:      * @return true if the Connection needs to stop
0:      */
0:     public synchronized boolean isPendingStop() {
0:         return pendingStop;
0:     }
0: 
0:     protected synchronized void setPendingStop(boolean pendingStop) {
0:         this.pendingStop = pendingStop;
0:     }
0: 
0:     public Response processBrokerInfo(BrokerInfo info) {
0:         if (info.isSlaveBroker()) {
0:             MutableBrokerFilter parent = (MutableBrokerFilter) broker.getAdaptor(MutableBrokerFilter.class);
0:             masterBroker = new MasterBroker(parent, transport);
0:             log.info("Slave Broker " + info.getBrokerName() + " is attached");
0:     protected void dispatch(Command command) {
0:         try {
0:         }
0:         catch (IOException e) {
0:         }
0:         finally {
0:     public String getRemoteAddress() {
1:         return transport.getRemoteAddress();
0:     }
commit:0f1dcce
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public String getRemoteAddress() {
0: 		return transport.getRemoteAddress();
0: 	}
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:b743552
/////////////////////////////////////////////////////////////////////////
0:     private final AtomicBoolean stopped = new AtomicBoolean(false);
0: 	private final AtomicBoolean transportDisposed = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0: 
0:                 // Let all the connection contexts know we are shutting down
0:                 // so that in progress operations can notice and unblock.
0:                  ArrayList l=new ArrayList(localConnectionStates.values());
0:                  for(Iterator iter=l.iterator();iter.hasNext();){
0:                      ConnectionState cs=(ConnectionState) iter.next();
0:                      cs.getContext().getStopping().set(true);
0:                  }            	
0:             	
0:  		        if( taskRunner!=null ) {
0:                     taskRunner.wakeup();
0:                     // Give it a change to stop gracefully.
0:                     dispatchStoppedLatch.await(5, TimeUnit.SECONDS);
0:                     disposeTransport();
0: 		            taskRunner.shutdown();
0:                 } else {
0:                     disposeTransport();
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                 	l=new ArrayList(localConnectionStates.keySet());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
0: 	protected void disposeTransport() {
0:     	if( transportDisposed.compareAndSet(false, true) ) {
0:         try {
0: 			transport.stop();
0: 			active = false;
0: 			log.debug("Stopped connection: "+transport.getRemoteAddress());
0: 		} catch (Exception e) {
0: 			log.debug("Could not stop transport: "+e,e);
0: 		}
0:     	}
0: 	}    
commit:49ea0ed
/////////////////////////////////////////////////////////////////////////
1:     private boolean networkConnection;
0:     
/////////////////////////////////////////////////////////////////////////
1:         context.setNetworkConnection(networkConnection);
/////////////////////////////////////////////////////////////////////////
0:         networkConnection = true;
0:         for (Iterator iter = localConnectionStates.values().iterator(); iter.hasNext();) {
0:             ConnectionState cs = (ConnectionState) iter.next();
0:             cs.getContext().setNetworkConnection(true);
0:         }   
0:         
commit:015cd8a
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
0:     protected final AtomicReference transportException = new AtomicReference();
/////////////////////////////////////////////////////////////////////////
0:     private CountDownLatch dispatchStoppedLatch = new CountDownLatch(1);
0:     protected AtomicBoolean dispatchStopped=new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:                 	dispatchSync(response);
/////////////////////////////////////////////////////////////////////////
0:         	transportException.set(e);
/////////////////////////////////////////////////////////////////////////
0:         getStatistics().getEnqueues().increment();
0:         try {
0:             processDispatch(message);
1:         } catch (IOException e) {
0:             serviceExceptionAsync(e);
0:     public void dispatchAsync(Command message){
0:         if( !disposed.get() ) {
0:             getStatistics().getEnqueues().increment();
0:             if( taskRunner==null ) {
0:                 dispatchSync( message );
0:             } else {
0:                 dispatchQueue.add(message);
0:                 try {
0:                     taskRunner.wakeup();
0:                 } catch (InterruptedException e) {
0:                     Thread.currentThread().interrupt();
0:                 }
0:             }
0:         } else {
0:             if(message.isMessageDispatch()) {
0:                 MessageDispatch md=(MessageDispatch) message;
0:                 Runnable sub=(Runnable) md.getConsumer();
0:                 broker.processDispatch(md);
0:                 if(sub!=null){
0:                     sub.run();
0:                 }
0:              }
0:         }
0:     }
0: 
0:     protected void processDispatch(Command command) throws IOException {
0:         try {
0:             if( !disposed.get() ) {
0:                  dispatch(command);
0:             }
0:        } finally {
0: 
0:             if(command.isMessageDispatch()){
0:                 MessageDispatch md=(MessageDispatch) command;
0:                 Runnable sub=(Runnable) md.getConsumer();
0:                 broker.processDispatch(md);
0: 
0:             getStatistics().getDequeues().increment();
0:      }   
0: 
0: 
0:         try {
0:             if( disposed.get() ) {
0:                  if( dispatchStopped.compareAndSet(false, true)) {                                                             
0:                      if( transportException.get()==null ) {
0:                          try {
0:                              dispatch(new ShutdownInfo());
0:                          } catch (Throwable ignore) {
0:                          }
0:                      }
0:                      dispatchStoppedLatch.countDown();
0:                  }
0:                  return false;                           
0:              } 
0: 
0:              if( !dispatchStopped.get() )  {
0: 
0:                  if( dispatchQueue.isEmpty() ) {
0:                      return false;
0:                  } else {
0:                      Command command = (Command) dispatchQueue.remove(0);
0:                      processDispatch( command );
0:                      return true;
0:                  }
0:              } else {
0:                  return false;
0:              }
0: 
1:          } catch (IOException e) {
0:              if( dispatchStopped.compareAndSet(false, true)) {                                                                     
0:                  dispatchStoppedLatch.countDown();
0:              }
0:              serviceExceptionAsync(e);
0:              return false;                           
0:          }
/////////////////////////////////////////////////////////////////////////
0:                 taskRunner.wakeup();
0:                 dispatchStoppedLatch.await();
0: 
0: 		        if( taskRunner!=null )
0: 		            taskRunner.shutdown();
0: 		        
0:                 // Run the MessageDispatch callbacks so that message references get cleaned up.
0:                 for (Iterator iter = dispatchQueue.iterator(); iter.hasNext();) {
0:                     Command command = (Command) iter.next();
0:                     if(command.isMessageDispatch()) {
0:                         MessageDispatch md=(MessageDispatch) command;
0:                         Runnable sub=(Runnable) md.getConsumer();
0:                         broker.processDispatch(md);
0:                         if(sub!=null){
0:                             sub.run();
0:                         }
0:                     }
0:                 } 
/////////////////////////////////////////////////////////////////////////
0:     protected void dispatch(Command command) throws IOException{
/////////////////////////////////////////////////////////////////////////
1:     public String getConnectionId() {
0:         Iterator iterator = localConnectionStates.values().iterator();
0:         ConnectionState object = (ConnectionState) iterator.next();
0:         if( object == null ) {
0:             return null;
0:         }
0:         if( object.getInfo().getClientId() !=null )
0:             return object.getInfo().getClientId();
0:         return object.getInfo().getConnectionId().toString();
0:     }    
0:     
commit:a86a587
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             
0:             // If the transport has not failed yet,
0:             // notify the peer that we are doing a normal shutdown.
0:             if( transportException == null ) {
0:             	transport.oneway(new ShutdownInfo());
0:             }
============================================================================