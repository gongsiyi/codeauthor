1:d29ca2a: /**
1:fc00993:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:fc00993:  * contributor license agreements.  See the NOTICE file distributed with
1:fc00993:  * this work for additional information regarding copyright ownership.
1:fc00993:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:fc00993:  * (the "License"); you may not use this file except in compliance with
1:fc00993:  * the License.  You may obtain a copy of the License at
1:3a5b48a:  *
1:fc00993:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:fc00993:  * Unless required by applicable law or agreed to in writing, software
1:fc00993:  * distributed under the License is distributed on an "AS IS" BASIS,
1:fc00993:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fc00993:  * See the License for the specific language governing permissions and
1:fc00993:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.region;
1:4742c7d: 
1:07d4e8c: import java.io.IOException;
1:f472000: import java.util.ArrayList;
1:07d4e8c: import java.util.Iterator;
1:4e23adf: import java.util.LinkedList;
1:f472000: import java.util.List;
1:132f662: import java.util.concurrent.CountDownLatch;
1:132f662: import java.util.concurrent.TimeUnit;
1:132f662: 
1:07d4e8c: import javax.jms.JMSException;
1:3a5b48a: 
1:4098942: import org.apache.activemq.broker.Broker;
1:d29ca2a: import org.apache.activemq.broker.ConnectionContext;
1:7d1e6bc: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
1:7d1e6bc: import org.apache.activemq.broker.region.cursors.VMPendingMessageCursor;
1:6eaea6f: import org.apache.activemq.command.ConsumerControl;
1:d29ca2a: import org.apache.activemq.command.ConsumerInfo;
1:d29ca2a: import org.apache.activemq.command.Message;
1:d29ca2a: import org.apache.activemq.command.MessageAck;
1:d29ca2a: import org.apache.activemq.command.MessageDispatch;
1:4098942: import org.apache.activemq.command.MessageDispatchNotification;
1:d29ca2a: import org.apache.activemq.command.MessageId;
1:9d671b7: import org.apache.activemq.command.MessagePull;
1:9d671b7: import org.apache.activemq.command.Response;
1:a19bfd4: import org.apache.activemq.thread.Scheduler;
1:d29ca2a: import org.apache.activemq.transaction.Synchronization;
1:ae61847: import org.apache.activemq.transport.TransmitCallback;
1:9dd11cb: import org.apache.activemq.usage.SystemUsage;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:3a5b48a: 
1:d29ca2a: /**
1:d29ca2a:  * A subscription that honors the pre-fetch option of the ConsumerInfo.
1:d29ca2a:  */
1:fc00993: public abstract class PrefetchSubscription extends AbstractSubscription {
1:2b2b35e: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(PrefetchSubscription.class);
1:1a5ad28:     protected final Scheduler scheduler;
1:3a5b48a: 
1:0c0be94:     protected PendingMessageCursor pending;
1:6b4d077:     protected final List<MessageReference> dispatched = new ArrayList<MessageReference>();
1:9dd11cb:     private int maxProducersToAudit=32;
1:9dd11cb:     private int maxAuditDepth=2048;
1:9dd11cb:     protected final SystemUsage usageManager;
1:cb96783:     protected final Object pendingLock = new Object();
1:6b4d077:     protected final Object dispatchLock = new Object();
1:1a5ad28:     private final CountDownLatch okForAckAsDispatchDone = new CountDownLatch(1);
1:3a5b48a: 
1:915333e:     public PrefetchSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, PendingMessageCursor cursor) throws JMSException {
1:16f2d75:         super(broker,context, info);
1:9dd11cb:         this.usageManager=usageManager;
1:230a86c:         pending = cursor;
1:230a86c:         try {
1:915333e:             pending.start();
1:a19bfd4:         } catch (Exception e) {
1:915333e:             throw new JMSException(e.getMessage());
1:fdee6e8:         }
1:1a5ad28:         this.scheduler = broker.getScheduler();
1:7a59d28:     }
1:6a73c40: 
1:915333e:     public PrefetchSubscription(Broker broker,SystemUsage usageManager, ConnectionContext context, ConsumerInfo info) throws JMSException {
1:00879cf:         this(broker,usageManager,context, info, new VMPendingMessageCursor(false));
1:7a59d28:     }
1:7a59d28: 
1:807e18f:     /**
1:9d671b7:      * Allows a message to be pulled on demand by a client
1:c6e0984:      */
1:3039b67:     @Override
1:05ff52d:     public Response pullMessage(ConnectionContext context, final MessagePull pull) throws Exception {
1:3a5b48a:         // The slave should not deliver pull messages.
1:3a5b48a:         // TODO: when the slave becomes a master, He should send a NULL message to all the
1:3a5b48a:         // consumers to 'wake them up' in case they were waiting for a message.
1:8de3bd2:         if (getPrefetchSize() == 0) {
1:05ff52d:             prefetchExtension.set(pull.getQuantity());
1:eece576:             final long dispatchCounterBeforePull = getSubscriptionStatistics().getDispatched().getCount();
1:ae61847: 
1:3a5b48a:             // Have the destination push us some messages.
1:4742c7d:             for (Destination dest : destinations) {
1:3a5b48a:                 dest.iterate();
1:7a59d28:             }
1:3a5b48a:             dispatchPending();
1:ae5bd2e: 
2:2a328ed:             synchronized(this) {
1:3a5b48a:                 // If there was nothing dispatched.. we may need to setup a timeout.
1:eece576:                 if (dispatchCounterBeforePull == getSubscriptionStatistics().getDispatched().getCount() || pull.isAlwaysSignalDone()) {
1:3a5b48a:                     // immediate timeout used by receiveNoWait()
1:3a5b48a:                     if (pull.getTimeout() == -1) {
1:05ff52d:                         // Null message indicates the pull is done or did not have pending.
1:05ff52d:                         prefetchExtension.set(1);
1:3a5b48a:                         add(QueueMessageReference.NULL_MESSAGE);
1:3a5b48a:                         dispatchPending();
1:132f662:                     }
1:3a5b48a:                     if (pull.getTimeout() > 0) {
1:2b2b35e:                         scheduler.executeAfterDelay(new Runnable() {
1:ae61847:                             @Override
1:3a5b48a:                             public void run() {
1:05ff52d:                                 pullTimeout(dispatchCounterBeforePull, pull.isAlwaysSignalDone());
1:3a5b48a:                             }
1:3a5b48a:                         }, pull.getTimeout());
1:3a5b48a:                     }
1:3a5b48a:                 }
1:3a5b48a:             }
1:3a5b48a:         }
1:9d671b7:         return null;
1:3a5b48a:     }
1:3a5b48a: 
1:a19bfd4:     /**
1:230a86c:      * Occurs when a pull times out. If nothing has been dispatched since the
1:230a86c:      * timeout was setup, then send the NULL message.
1:a19bfd4:      */
1:05ff52d:     final void pullTimeout(long dispatchCounterBeforePull, boolean alwaysSignalDone) {
1:3a5b48a:         synchronized (pendingLock) {
1:eece576:             if (dispatchCounterBeforePull == getSubscriptionStatistics().getDispatched().getCount() || alwaysSignalDone) {
1:7a59d28:                 try {
1:05ff52d:                     prefetchExtension.set(1);
1:2a328ed:                     add(QueueMessageReference.NULL_MESSAGE);
1:2a328ed:                     dispatchPending();
1:230a86c:                 } catch (Exception e) {
1:a19bfd4:                     context.getConnection().serviceException(e);
1:05ff52d:                 } finally {
1:05ff52d:                     prefetchExtension.set(0);
1:2a328ed:                 }
1:2a328ed:             }
1:2a328ed:         }
1:2a328ed:     }
1:3a5b48a: 
1:ae61847:     @Override
1:2db7df7:     public void add(MessageReference node) throws Exception {
1:d89abe0:         synchronized (pendingLock) {
1:3a5b48a:             // The destination may have just been removed...
1:05ff52d:             if (!destinations.contains(node.getRegionDestination()) && node != QueueMessageReference.NULL_MESSAGE) {
1:ff46232:                 // perhaps we should inform the caller that we are no longer valid to dispatch to?
1:30f531d:                 return;
1:ff46232:             }
1:6ce59ed: 
1:6ce59ed:             // Don't increment for the pullTimeout control message.
1:6ce59ed:             if (!node.equals(QueueMessageReference.NULL_MESSAGE)) {
1:eece576:                 getSubscriptionStatistics().getEnqueues().increment();
1:6ce59ed:             }
1:3a5b48a:             pending.addMessageLast(node);
1:2a328ed:         }
1:2a328ed:         dispatchPending();
1:2a328ed:     }
1:3a5b48a: 
1:ae61847:     @Override
1:2db7df7:     public void processMessageDispatchNotification(MessageDispatchNotification mdn) throws Exception {
1:30f531d:         synchronized(pendingLock) {
1:30f531d:             try {
1:2db7df7:                 pending.reset();
1:230a86c:                 while (pending.hasNext()) {
1:230a86c:                     MessageReference node = pending.next();
1:5619cd0:                     node.decrementReferenceCount();
1:230a86c:                     if (node.getMessageId().equals(mdn.getMessageId())) {
1:3fe7760:                         // Synchronize between dispatched list and removal of messages from pending list
1:3fe7760:                         // related to remove subscription action
1:3039b67:                         synchronized(dispatchLock) {
1:3fe7760:                             pending.remove();
1:3fe7760:                             createMessageDispatch(node, node.getMessage());
1:2db7df7:                             dispatched.add(node);
1:4605503:                             getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:ae1bb66:                             onDispatch(node, node.getMessage());
1:3fe7760:                         }
1:ff46232:                         return;
1:3fe7760:                     }
1:ecf89a6:                 }
1:230a86c:             } finally {
1:2db7df7:                 pending.release();
1:2728ccb:             }
1:2728ccb:         }
1:2db7df7:         throw new JMSException(
1:2db7df7:                 "Slave broker out of sync with master: Dispatched message ("
1:c7b48c4:                         + mdn.getMessageId() + ") was not in the pending list for "
1:c7b48c4:                         + mdn.getConsumerId() + " on " + mdn.getDestination().getPhysicalName());
1:a58d36b:     }
1:3a5b48a: 
1:ae61847:     @Override
1:16f2d75:     public final void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception {
1:d29ca2a:         // Handle the standard acknowledgment case.
1:230a86c:         boolean callDispatchMatched = false;
1:16f2d75:         Destination destination = null;
1:132f662: 
1:4e0609f:         if (!okForAckAsDispatchDone.await(0l, TimeUnit.MILLISECONDS)) {
1:4e0609f:             // suppress unexpected ack exception in this expected case
1:e1bbde7:             LOG.warn("Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. Ignored ack: {}", ack);
1:4e0609f:             return;
1:132f662:         }
1:3a5b48a: 
1:e1bbde7:         LOG.trace("ack: {}", ack);
1:e1bbde7: 
1:30f531d:         synchronized(dispatchLock) {
1:230a86c:             if (ack.isStandardAck()) {
1:3a5b48a:                 // First check if the ack matches the dispatched. When using failover this might
1:3a5b48a:                 // not be the case. We don't ever want to ack the wrong messages.
1:3a5b48a:                 assertAckMatchesDispatched(ack);
1:3a5b48a: 
4:2db7df7:                 // Acknowledge all dispatched messages up till the message id of
1:9ce91fa:                 // the acknowledgment.
1:c256dcf:                 boolean inAckRange = false;
1:2db7df7:                 List<MessageReference> removeList = new ArrayList<MessageReference>();
1:2db7df7:                 for (final MessageReference node : dispatched) {
1:230a86c:                     MessageId messageId = node.getMessageId();
2:2db7df7:                     if (ack.getFirstMessageId() == null
2:2db7df7:                             || ack.getFirstMessageId().equals(messageId)) {
1:230a86c:                         inAckRange = true;
1:132f662:                     }
1:230a86c:                     if (inAckRange) {
1:6d1f57b:                         // Don't remove the nodes until we are committed.
1:230a86c:                         if (!context.isInTransaction()) {
1:eece576:                             getSubscriptionStatistics().getDequeues().increment();
1:9a8f6e4:                             ((Destination)node.getRegionDestination()).getDestinationStatistics().getInflight().decrement();
1:0bfb28a:                             removeList.add(node);
1:41a1007:                             contractPrefetchExtension(1);
1:80f7e38:                         } else {
1:2030097:                             registerRemoveSync(context, node);
1:e10f75c:                         }
1:230a86c:                         acknowledge(context, ack, node);
1:3a5b48a:                         if (ack.getLastMessageId().equals(messageId)) {
1:9a8f6e4:                             destination = (Destination) node.getRegionDestination();
1:230a86c:                             callDispatchMatched = true;
1:2d9959a:                             break;
1:2d9959a:                         }
1:9cf216c:                     }
1:132f662:                 }
1:2db7df7:                 for (final MessageReference node : removeList) {
1:2030097:                     dispatched.remove(node);
1:4605503:                     getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1:3a5b48a:                 }
1:230a86c:                 // this only happens after a reconnect - get an ack which is not
1:230a86c:                 // valid
1:230a86c:                 if (!callDispatchMatched) {
1:e1bbde7:                     LOG.warn("Could not correlate acknowledgment with dispatched message: {}", ack);
1:3a5b48a:                 }
1:ab3b155:             } else if (ack.isIndividualAck()) {
1:ab3b155:                 // Message was delivered and acknowledge - but only delete the
1:ab3b155:                 // individual message
1:ab3b155:                 for (final MessageReference node : dispatched) {
1:c256dcf:                     MessageId messageId = node.getMessageId();
2:230a86c:                     if (ack.getLastMessageId().equals(messageId)) {
1:2030097:                         // Don't remove the nodes until we are committed - immediateAck option
1:2030097:                         if (!context.isInTransaction()) {
1:eece576:                             getSubscriptionStatistics().getDequeues().increment();
1:9a8f6e4:                             ((Destination)node.getRegionDestination()).getDestinationStatistics().getInflight().decrement();
1:2030097:                             dispatched.remove(node);
1:4605503:                             getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1:41a1007:                             contractPrefetchExtension(1);
1:2030097:                         } else {
1:2030097:                             registerRemoveSync(context, node);
1:41a1007:                             expandPrefetchExtension(1);
1:2030097:                         }
1:2030097:                         acknowledge(context, ack, node);
1:9a8f6e4:                         destination = (Destination) node.getRegionDestination();
1:ab3b155:                         callDispatchMatched = true;
1:3a5b48a:                         break;
1:30f531d:                     }
1:c256dcf:                 }
1:41a1007:             } else if (ack.isDeliveredAck()) {
1:230a86c:                 // Message was delivered but not acknowledged: update pre-fetch
1:230a86c:                 // counters.
1:230a86c:                 int index = 0;
1:a9ba595:                 for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext(); index++) {
1:c256dcf:                     final MessageReference node = iter.next();
1:9a8f6e4:                     Destination nodeDest = (Destination) node.getRegionDestination();
1:230a86c:                     if (ack.getLastMessageId().equals(node.getMessageId())) {
1:41a1007:                         expandPrefetchExtension(ack.getMessageCount());
1:9a8f6e4:                         destination = nodeDest;
1:230a86c:                         callDispatchMatched = true;
1:3a5b48a:                         break;
1:6a73c40:                     }
1:7a59d28:                 }
1:230a86c:                 if (!callDispatchMatched) {
1:2db7df7:                     throw new JMSException(
1:2db7df7:                             "Could not correlate acknowledgment with dispatched message: "
1:0bfb28a:                                     + ack);
1:a9ba595:                 }
1:f10aab6:             } else if (ack.isExpiredAck()) {
1:f10aab6:                 // Message was expired
1:f10aab6:                 int index = 0;
1:f10aab6:                 boolean inAckRange = false;
1:f10aab6:                 for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext(); index++) {
1:f10aab6:                     final MessageReference node = iter.next();
1:f10aab6:                     Destination nodeDest = (Destination) node.getRegionDestination();
1:f10aab6:                     MessageId messageId = node.getMessageId();
1:cd5ea6c:                     if (ack.getFirstMessageId() == null || ack.getFirstMessageId().equals(messageId)) {
1:f10aab6:                         inAckRange = true;
1:f10aab6:                     }
1:f10aab6:                     if (inAckRange) {
1:cd5ea6c:                         Destination regionDestination = nodeDest;
1:6cc2c11:                         if (broker.isExpired(node)) {
1:6cc2c11:                             regionDestination.messageExpired(context, this, node);
1:6cc2c11:                         }
1:cd5ea6c:                         iter.remove();
1:cd5ea6c:                         nodeDest.getDestinationStatistics().getInflight().decrement();
1:2d9959a: 
1:f10aab6:                         if (ack.getLastMessageId().equals(messageId)) {
1:41a1007:                             contractPrefetchExtension(1);
1:f10aab6:                             destination = (Destination) node.getRegionDestination();
1:f10aab6:                             callDispatchMatched = true;
1:f10aab6:                             break;
1:f10aab6:                         }
1:f10aab6:                     }
1:f10aab6:                 }
1:f10aab6:                 if (!callDispatchMatched) {
1:f10aab6:                     throw new JMSException(
1:f10aab6:                             "Could not correlate expiration acknowledgment with dispatched message: "
1:f10aab6:                                     + ack);
1:f10aab6:                 }
1:2db7df7:             } else if (ack.isRedeliveredAck()) {
1:2db7df7:                 // Message was re-delivered but it was not yet considered to be
1:0bfb28a:                 // a DLQ message.
1:230a86c:                 boolean inAckRange = false;
1:2db7df7:                 for (final MessageReference node : dispatched) {
3:d29ca2a:                     MessageId messageId = node.getMessageId();
1:f10aab6:                     if (ack.getFirstMessageId() == null
1:f10aab6:                             || ack.getFirstMessageId().equals(messageId)) {
1:c256dcf:                         inAckRange = true;
1:f10aab6:                     }
1:c256dcf:                     if (inAckRange) {
1:c256dcf:                         if (ack.getLastMessageId().equals(messageId)) {
1:9a8f6e4:                             destination = (Destination) node.getRegionDestination();
1:c256dcf:                             callDispatchMatched = true;
1:f10aab6:                             break;
1:f10aab6:                         }
1:f10aab6:                     }
1:f10aab6:                 }
1:c256dcf:                 if (!callDispatchMatched) {
1:2db7df7:                     throw new JMSException(
1:2db7df7:                             "Could not correlate acknowledgment with dispatched message: "
1:30f531d:                                     + ack);
1:c256dcf:                 }
1:230a86c:             } else if (ack.isPoisonAck()) {
1:61ab31e:                 // TODO: what if the message is already in a DLQ???
1:2db7df7:                 // Handle the poison ACK case: we need to send the message to a
1:2db7df7:                 // DLQ
1:ecf89a6:                 if (ack.isInTransaction()) {
1:2db7df7:                     throw new JMSException("Poison ack cannot be transacted: "
1:9ce91fa:                             + ack);
1:c256dcf:                 }
2:230a86c:                 int index = 0;
1:230a86c:                 boolean inAckRange = false;
1:2db7df7:                 List<MessageReference> removeList = new ArrayList<MessageReference>();
1:2db7df7:                 for (final MessageReference node : dispatched) {
1:230a86c:                     MessageId messageId = node.getMessageId();
1:2db7df7:                     if (ack.getFirstMessageId() == null
1:2db7df7:                             || ack.getFirstMessageId().equals(messageId)) {
1:230a86c:                         inAckRange = true;
1:c256dcf:                     }
1:230a86c:                     if (inAckRange) {
1:708be6d:                         sendToDLQ(context, node, ack.getPoisonCause());
1:9a8f6e4:                         Destination nodeDest = (Destination) node.getRegionDestination();
1:9a8f6e4:                         nodeDest.getDestinationStatistics()
1:eece576:                         .getInflight().decrement();
1:d453b8d:                         removeList.add(node);
1:eece576:                         getSubscriptionStatistics().getDequeues().increment();
3:d29ca2a:                         index++;
1:230a86c:                         acknowledge(context, ack, node);
1:8de3bd2:                         if (ack.getLastMessageId().equals(messageId)) {
1:41a1007:                             contractPrefetchExtension(1);
1:9a8f6e4:                             destination = nodeDest;
1:230a86c:                             callDispatchMatched = true;
1:3a5b48a:                             break;
1:c256dcf:                         }
1:ecf89a6:                     }
1:62f798a:                 }
1:2db7df7:                 for (final MessageReference node : removeList) {
1:7a59d28:                     dispatched.remove(node);
1:4605503:                     getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1:62f798a:                 }
1:230a86c:                 if (!callDispatchMatched) {
1:2db7df7:                     throw new JMSException(
1:2db7df7:                             "Could not correlate acknowledgment with dispatched message: "
4:2db7df7:                                     + ack);
1:62f798a:                 }
1:a19bfd4:             }
1:a19bfd4:         }
1:e45bb06:         if (callDispatchMatched && destination != null) {
1:e45bb06:             destination.wakeup();
1:3c39db8:             dispatchPending();
1:cd5ea6c: 
1:4742c7d:             if (pending.isEmpty()) {
1:ffee8b4:                 wakeupDestinationsForDispatch();
1:4742c7d:             }
1:9cf216c:         } else {
1:e1bbde7:             LOG.debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): {}", ack);
1:4742c7d:         }
1:a19bfd4:     }
1:9cf216c: 
1:2030097:     private void registerRemoveSync(ConnectionContext context, final MessageReference node) {
1:2030097:         // setup a Synchronization to remove nodes from the
1:2030097:         // dispatched list.
1:2030097:         context.getTransaction().addSynchronization(
1:2030097:                 new Synchronization() {
1:2030097: 
1:2030097:                     @Override
1:2030097:                     public void afterCommit()
1:2030097:                             throws Exception {
1:9a8f6e4:                         Destination nodeDest = (Destination) node.getRegionDestination();
1:41a1007:                         synchronized (dispatchLock) {
1:eece576:                             getSubscriptionStatistics().getDequeues().increment();
1:ea70e82:                             if (dispatched.remove(node)) {
1:ea70e82:                                 // if consumer is removed, dispatched will be empty and inflight will
1:ea70e82:                                 // already have been adjusted
1:ea70e82:                                 getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1:ea70e82:                                 nodeDest.getDestinationStatistics().getInflight().decrement();
1:ea70e82:                             }
1:2030097:                         }
1:41a1007:                         contractPrefetchExtension(1);
1:9a8f6e4:                         nodeDest.wakeup();
1:bbdedea:                         dispatchPending();
1:2030097:                     }
1:2030097: 
1:2030097:                     @Override
1:2030097:                     public void afterRollback() throws Exception {
1:41a1007:                         contractPrefetchExtension(1);
1:2030097:                     }
1:2030097:                 });
1:2030097:     }
1:2030097: 
1:18d616c:     /**
1:9ce91fa:      * Checks an ack versus the contents of the dispatched list.
1:6b4d077:      *  called with dispatchLock held
1:9ce91fa:      * @param ack
1:9ce91fa:      * @throws JMSException if it does not match
1:9ce91fa:      */
1:fdee6e8:     protected void assertAckMatchesDispatched(MessageAck ack) throws JMSException {
1:9ce91fa:         MessageId firstAckedMsg = ack.getFirstMessageId();
1:fdee6e8:         MessageId lastAckedMsg = ack.getLastMessageId();
1:fdee6e8:         int checkCount = 0;
1:fdee6e8:         boolean checkFoundStart = false;
1:fdee6e8:         boolean checkFoundEnd = false;
1:fdee6e8:         for (MessageReference node : dispatched) {
1:3a5b48a: 
1:fdee6e8:             if (firstAckedMsg == null) {
1:fdee6e8:                 checkFoundStart = true;
1:fdee6e8:             } else if (!checkFoundStart && firstAckedMsg.equals(node.getMessageId())) {
1:fdee6e8:                 checkFoundStart = true;
1:2030097:             }
1:3a5b48a: 
1:fdee6e8:             if (checkFoundStart) {
1:fdee6e8:                 checkCount++;
1:2030097:             }
1:3a5b48a: 
1:fdee6e8:             if (lastAckedMsg != null && lastAckedMsg.equals(node.getMessageId())) {
1:fdee6e8:                 checkFoundEnd = true;
1:fdee6e8:                 break;
1:80f7e38:             }
1:fdee6e8:         }
1:fdee6e8:         if (!checkFoundStart && firstAckedMsg != null)
1:0bc545b:             throw new JMSException("Unmatched acknowledge: " + ack
1:fdee6e8:                     + "; Could not find Message-ID " + firstAckedMsg
1:fdee6e8:                     + " in dispatched-list (start of ack)");
1:fdee6e8:         if (!checkFoundEnd && lastAckedMsg != null)
1:0bc545b:             throw new JMSException("Unmatched acknowledge: " + ack
1:fdee6e8:                     + "; Could not find Message-ID " + lastAckedMsg
1:fdee6e8:                     + " in dispatched-list (end of ack)");
1:0bfb28a:         if (ack.getMessageCount() != checkCount && !ack.isInTransaction()) {
1:0bc545b:             throw new JMSException("Unmatched acknowledge: " + ack
1:fdee6e8:                     + "; Expected message count (" + ack.getMessageCount()
1:fdee6e8:                     + ") differs from count in dispatched-list (" + checkCount
1:fdee6e8:                     + ")");
1:fdee6e8:         }
1:fdee6e8:     }
1:3a5b48a: 
1:9ce91fa:     /**
1:708be6d:      *
1:18d616c:      * @param context
1:18d616c:      * @param node
1:708be6d:      * @param poisonCause
1:18d616c:      * @throws IOException
1:18d616c:      * @throws Exception
1:18d616c:      */
1:708be6d:     protected void sendToDLQ(final ConnectionContext context, final MessageReference node, Throwable poisonCause) throws IOException, Exception {
1:708be6d:         broker.getRoot().sendToDeadLetterQueue(context, node, this, poisonCause);
1:fdee6e8:     }
1:30f531d: 
1:ae61847:     @Override
1:d4382e4:     public int getInFlightSize() {
1:d4382e4:         return dispatched.size();
1:fdee6e8:     }
1:3a5b48a: 
1:6eaea6f:     /**
1:807e18f:      * Used to determine if the broker can dispatch to the consumer.
1:3a5b48a:      *
1:5e05df1:      * @return true if the subscription is full
1:807e18f:      */
1:ae61847:     @Override
1:d4382e4:     public boolean isFull() {
1:2d9959a:         return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();
1:d453b8d:     }
1:30f531d: 
1:6eaea6f:     /**
1:6eaea6f:      * @return true when 60% or more room is left for dispatching messages
1:6eaea6f:      */
1:ae61847:     @Override
1:2db7df7:     public boolean isLowWaterMark() {
1:3a5b48a:         return (dispatched.size() - prefetchExtension.get()) <= (info.getPrefetchSize() * .4);
1:d453b8d:     }
1:d453b8d: 
1:6eaea6f:     /**
1:6eaea6f:      * @return true when 10% or less room is left for dispatching messages
1:158dbc6:      */
1:ae61847:     @Override
1:2db7df7:     public boolean isHighWaterMark() {
1:3a5b48a:         return (dispatched.size() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9);
1:230a86c:     }
1:2a328ed: 
1:ae61847:     @Override
1:2db7df7:     public int countBeforeFull() {
1:2d9959a:         return getPrefetchSize() == 0 ? prefetchExtension.get() : info.getPrefetchSize() + prefetchExtension.get() - dispatched.size();
1:da5139c:     }
1:2a328ed: 
1:ae61847:     @Override
1:2db7df7:     public int getPendingQueueSize() {
1:d65ba80:         return pending.size();
1:a19bfd4:     }
1:2a328ed: 
1:ae61847:     @Override
1:734fb7d:     public long getPendingMessageSize() {
1:734fb7d:         synchronized (pendingLock) {
1:734fb7d:             return pending.messageSize();
1:734fb7d:         }
1:734fb7d:     }
1:734fb7d: 
1:734fb7d:     @Override
1:2db7df7:     public int getDispatchedQueueSize() {
1:a3e3821:         return dispatched.size();
1:a19bfd4:     }
1:c9c1107: 
1:ae61847:     @Override
1:2db7df7:     public long getDequeueCounter() {
1:eece576:         return getSubscriptionStatistics().getDequeues().getCount();
1:a19bfd4:     }
1:c9c1107: 
1:ae61847:     @Override
1:2db7df7:     public long getDispatchedCounter() {
1:eece576:         return getSubscriptionStatistics().getDispatched().getCount();
1:a19bfd4:     }
1:74a7a8b: 
1:ae61847:     @Override
1:0f502fa:     public long getEnqueueCounter() {
1:eece576:         return getSubscriptionStatistics().getEnqueues().getCount();
1:a19bfd4:     }
1:74a7a8b: 
1:ae5bd2e:     @Override
1:230a86c:     public boolean isRecoveryRequired() {
1:4eef609:         return pending.isRecoveryRequired();
1:a19bfd4:     }
1:230a86c: 
1:2db7df7:     public PendingMessageCursor getPending() {
1:0c0be94:         return this.pending;
1:a19bfd4:     }
1:230a86c: 
1:2db7df7:     public void setPending(PendingMessageCursor pending) {
1:230a86c:         this.pending = pending;
1:9dd11cb:         if (this.pending!=null) {
1:9dd11cb:             this.pending.setSystemUsage(usageManager);
1:785454a:             this.pending.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
1:807e18f:         }
1:807e18f:     }
1:7695676: 
1:3a5b48a:     @Override
1:969e758:     public void add(ConnectionContext context, Destination destination) throws Exception {
1:d4382e4:         synchronized(pendingLock) {
1:230a86c:             super.add(context, destination);
1:230a86c:             pending.add(context, destination);
1:d65ba80:         }
1:18d616c:     }
1:a58d36b: 
1:1a5ad28:     @Override
1:ae7de6c:     public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
1:3039b67:         return remove(context, destination, dispatched);
1:3039b67:     }
1:3039b67: 
1:3039b67:     public List<MessageReference> remove(ConnectionContext context, Destination destination, List<MessageReference> dispatched) throws Exception {
1:4e23adf:         LinkedList<MessageReference> redispatch = new LinkedList<MessageReference>();
3:2db7df7:         synchronized(pendingLock) {
1:230a86c:             super.remove(context, destination);
1:7a59d28:             // Here is a potential problem concerning Inflight stat:
1:7a59d28:             // Messages not already committed or rolled back may not be removed from dispatched list at the moment
1:7a59d28:             // Except if each commit or rollback callback action comes before remove of subscriber.
1:4e23adf:             redispatch.addAll(pending.remove(context, destination));
1:7a59d28: 
1:3039b67:             if (dispatched == null) {
1:4e23adf:                 return redispatch;
1:3039b67:             }
1:3039b67: 
1:3039b67:             // Synchronized to DispatchLock if necessary
1:3039b67:             if (dispatched == this.dispatched) {
1:2030097:                 synchronized(dispatchLock) {
1:4e23adf:                     addReferencesAndUpdateRedispatch(redispatch, destination, dispatched);
1:ae7de6c:                 }
1:2030097:             } else {
1:4e23adf:                 addReferencesAndUpdateRedispatch(redispatch, destination, dispatched);
1:18d616c:             }
1:07d4e8c:         }
1:4e23adf: 
1:4e23adf:         return redispatch;
1:07d4e8c:     }
1:a58d36b: 
1:4e23adf:     private void addReferencesAndUpdateRedispatch(LinkedList<MessageReference> redispatch, Destination destination, List<MessageReference> dispatched) {
1:3039b67:         ArrayList<MessageReference> references = new ArrayList<MessageReference>();
1:3039b67:         for (MessageReference r : dispatched) {
1:3039b67:             if (r.getRegionDestination() == destination) {
1:3039b67:                 references.add(r);
1:4605503:                 getSubscriptionStatistics().getInflightMessageSize().addSize(-r.getSize());
1:3039b67:             }
1:3039b67:         }
1:4e23adf:         redispatch.addAll(0, references);
1:3039b67:         destination.getDestinationStatistics().getInflight().subtract(references.size());
1:3039b67:         dispatched.removeAll(references);
1:3039b67:     }
1:3039b67: 
1:6c85967:     // made public so it can be used in MQTTProtocolConverter
1:6c85967:     public void dispatchPending() throws IOException {
1:a28a091:         List<Destination> slowConsumerTargets = null;
1:a28a091: 
1:eece576:         synchronized(pendingLock) {
1:230a86c:             try {
1:30f531d:                 int numberToDispatch = countBeforeFull();
1:30f531d:                 if (numberToDispatch > 0) {
1:1b6d397:                     setSlowConsumer(false);
1:6519c3e:                     setPendingBatchSize(pending, numberToDispatch);
1:30f531d:                     int count = 0;
1:30f531d:                     pending.reset();
1:511b9b6:                     while (count < numberToDispatch && !isFull() && pending.hasNext()) {
1:30f531d:                         MessageReference node = pending.next();
1:30f531d:                         if (node == null) {
1:3a5b48a:                             break;
1:3a5b48a:                         }
1:3a5b48a: 
1:0bfb28a:                         // Synchronize between dispatched list and remove of message from pending list
1:30f531d:                         // related to remove subscription action
1:2030097:                         synchronized(dispatchLock) {
1:30f531d:                             pending.remove();
1:c38a61d:                             if (!isDropped(node) && canDispatch(node)) {
1:30f531d: 
1:30f531d:                                 // Message may have been sitting in the pending
1:30f531d:                                 // list a while waiting for the consumer to ak the message.
1:c38a61d:                                 if (node != QueueMessageReference.NULL_MESSAGE && node.isExpired()) {
1:30f531d:                                     //increment number to dispatch
1:30f531d:                                     numberToDispatch++;
1:f10aab6:                                     if (broker.isExpired(node)) {
1:30f531d:                                         ((Destination)node.getRegionDestination()).messageExpired(context, this, node);
1:ca242f4:                                     }
1:c38a61d: 
1:174dcbf:                                     if (!isBrowser()) {
1:e3df09b:                                         node.decrementReferenceCount();
1:174dcbf:                                         continue;
1:174dcbf:                                     }
1:3a5b48a:                                 }
1:30f531d:                                 dispatch(node);
1:30f531d:                                 count++;
1:3a5b48a:                             }
1:30f531d:                         }
1:1ad0117:                         // decrement after dispatch has taken ownership to avoid usage jitter
1:1ad0117:                         node.decrementReferenceCount();
1:30f531d:                     }
1:1b6d397:                 } else if (!isSlowConsumer()) {
1:1b6d397:                     setSlowConsumer(true);
1:a28a091:                     slowConsumerTargets = destinations;
1:30f531d:                 }
1:30f531d:             } finally {
1:30f531d:                 pending.release();
1:30f531d:             }
1:3fe7760:         }
1:a28a091: 
1:a28a091:         if (slowConsumerTargets != null) {
1:a28a091:             for (Destination dest : slowConsumerTargets) {
1:a28a091:                 dest.slowConsumer(context, this);
1:a28a091:             }
1:a28a091:         }
1:ae7de6c:     }
1:da5139c: 
1:6519c3e:     protected void setPendingBatchSize(PendingMessageCursor pending, int numberToDispatch) {
1:6519c3e:         pending.setMaxBatchSize(numberToDispatch);
1:6519c3e:     }
1:6519c3e: 
1:6b4d077:     // called with dispatchLock held
1:2db7df7:     protected boolean dispatch(final MessageReference node) throws IOException {
1:230a86c:         final Message message = node.getMessage();
1:230a86c:         if (message == null) {
1:18d616c:             return false;
1:3fe7760:         }
1:132f662: 
1:132f662:         okForAckAsDispatchDone.countDown();
1:132f662: 
1:30f531d:         MessageDispatch md = createMessageDispatch(node, message);
1:30f531d:         if (node != QueueMessageReference.NULL_MESSAGE) {
1:eece576:             getSubscriptionStatistics().getDispatched().increment();
1:30f531d:             dispatched.add(node);
1:4605503:             getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
1:2d9959a:         }
1:2d9959a:         if (getPrefetchSize() == 0) {
1:2d9959a:             while (true) {
1:2d9959a:                 int currentExtension = prefetchExtension.get();
1:2d9959a:                 int newExtension = Math.max(0, currentExtension - 1);
1:2d9959a:                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:2d9959a:                     break;
1:2d9959a:                 }
1:2d9959a:             }
1:2d9959a:         }
1:30f531d:         if (info.isDispatchAsync()) {
1:ae61847:             md.setTransmitCallback(new TransmitCallback() {
1:2d9959a: 
1:2d9959a:                 @Override
1:ae61847:                 public void onSuccess() {
1:ae61847:                     // Since the message gets queued up in async dispatch, we don't want to
1:ae61847:                     // decrease the reference count until it gets put on the wire.
1:30f531d:                     onDispatch(node, message);
1:2d9959a:                 }
1:f10aab6: 
1:ae61847:                 @Override
1:ae61847:                 public void onFailure() {
1:ae61847:                     Destination nodeDest = (Destination) node.getRegionDestination();
1:ae61847:                     if (nodeDest != null) {
1:ae61847:                         if (node != QueueMessageReference.NULL_MESSAGE) {
1:ae61847:                             nodeDest.getDestinationStatistics().getDispatched().increment();
1:ae61847:                             nodeDest.getDestinationStatistics().getInflight().increment();
1:eece576:                             LOG.trace("{} failed to dispatch: {} - {}, dispatched: {}, inflight: {}", new Object[]{ info.getConsumerId(), message.getMessageId(), message.getDestination(), getSubscriptionStatistics().getDispatched().getCount(), dispatched.size() });
1:f10aab6:                         }
1:7a59d28:                     }
1:52e1a05:                     if (node instanceof QueueMessageReference) {
1:52e1a05:                         ((QueueMessageReference) node).unlock();
1:52e1a05:                     }
1:ae61847:                 }
1:30f531d:             });
1:30f531d:             context.getConnection().dispatchAsync(md);
1:7a59d28:         } else {
1:30f531d:             context.getConnection().dispatchSync(md);
1:30f531d:             onDispatch(node, message);
1:ae61847:         }
1:30f531d:         return true;
1:ae61847:     }
1:7a59d28: 
1:230a86c:     protected void onDispatch(final MessageReference node, final Message message) {
1:9a8f6e4:         Destination nodeDest = (Destination) node.getRegionDestination();
1:9a8f6e4:         if (nodeDest != null) {
2:230a86c:             if (node != QueueMessageReference.NULL_MESSAGE) {
1:9a8f6e4:                 nodeDest.getDestinationStatistics().getDispatched().increment();
1:9a8f6e4:                 nodeDest.getDestinationStatistics().getInflight().increment();
1:eece576:                 LOG.trace("{} dispatched: {} - {}, dispatched: {}, inflight: {}", new Object[]{ info.getConsumerId(), message.getMessageId(), message.getDestination(), getSubscriptionStatistics().getDispatched().getCount(), dispatched.size() });
1:ae61847:             }
1:3a5b48a:         }
1:3a5b48a: 
2:230a86c:         if (info.isDispatchAsync()) {
1:230a86c:             try {
1:f81d0d5:                 dispatchPending();
1:7a59d28:             } catch (IOException e) {
1:230a86c:                 context.getConnection().serviceExceptionAsync(e);
1:3a5b48a:             }
1:3a5b48a:         }
1:3a5b48a:     }
1:3a5b48a: 
1:d29ca2a:     /**
1:6eaea6f:      * inform the MessageConsumer on the client to change it's prefetch
1:3a5b48a:      *
1:6eaea6f:      * @param newPrefetch
1:d29ca2a:      */
1:ae61847:     @Override
1:230a86c:     public void updateConsumerPrefetch(int newPrefetch) {
1:230a86c:         if (context != null && context.getConnection() != null && context.getConnection().isManageable()) {
1:230a86c:             ConsumerControl cc = new ConsumerControl();
1:6eaea6f:             cc.setConsumerId(info.getConsumerId());
1:6eaea6f:             cc.setPrefetch(newPrefetch);
1:6eaea6f:             context.getConnection().dispatchAsync(cc);
1:3a5b48a:         }
1:3a5b48a:     }
1:30f531d: 
1:6eaea6f:     /**
1:d29ca2a:      * @param node
1:8b04e15:      * @param message
1:b6ba20b:      * @return MessageDispatch
1:6eaea6f:      */
1:230a86c:     protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {
1:3a5b48a:         MessageDispatch md = new MessageDispatch();
1:3a5b48a:         md.setConsumerId(info.getConsumerId());
1:3a5b48a: 
1:230a86c:         if (node == QueueMessageReference.NULL_MESSAGE) {
1:a19bfd4:             md.setMessage(null);
1:158dbc6:             md.setDestination(null);
1:3039b67:         } else {
1:9a8f6e4:             Destination regionDestination = (Destination) node.getRegionDestination();
1:9a8f6e4:             md.setDestination(regionDestination.getActiveMQDestination());
1:a19bfd4:             md.setMessage(message);
1:a19bfd4:             md.setRedeliveryCounter(node.getRedeliveryCounter());
1:3a5b48a:         }
1:3a5b48a: 
1:3a5b48a:         return md;
1:3a5b48a:     }
1:3fe7760: 
1:d29ca2a:     /**
1:d29ca2a:      * Use when a matched message is about to be dispatched to the client.
1:3a5b48a:      *
1:d29ca2a:      * @param node
1:230a86c:      * @return false if the message should not be dispatched to the client
1:230a86c:      *         (another sub may have already dispatched it for example).
1:158dbc6:      * @throws IOException
1:d29ca2a:      */
1:fc00993:     protected abstract boolean canDispatch(MessageReference node) throws IOException;
1:3a5b48a: 
1:149428b:     protected abstract boolean isDropped(MessageReference node);
1:53c4e12: 
1:d29ca2a:     /**
1:d29ca2a:      * Used during acknowledgment to remove the message.
1:3a5b48a:      *
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:2a153b0:     protected abstract void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException;
1:3a5b48a: 
1:cafe4cb: 
1:9dd11cb:     public int getMaxProducersToAudit() {
1:9dd11cb:         return maxProducersToAudit;
1:3a5b48a:     }
1:cafe4cb: 
1:9dd11cb:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:9dd11cb:         this.maxProducersToAudit = maxProducersToAudit;
1:37ede54:         if (this.pending != null) {
1:37ede54:             this.pending.setMaxProducersToAudit(maxProducersToAudit);
1:37ede54:         }
1:3a5b48a:     }
1:a19bfd4: 
1:9dd11cb:     public int getMaxAuditDepth() {
1:9dd11cb:         return maxAuditDepth;
1:30f531d:     }
2:a19bfd4: 
1:9dd11cb:     public void setMaxAuditDepth(int maxAuditDepth) {
1:9dd11cb:         this.maxAuditDepth = maxAuditDepth;
1:37ede54:         if (this.pending != null) {
1:37ede54:             this.pending.setMaxAuditDepth(maxAuditDepth);
1:6a73c40:         }
1:6a73c40:     }
1:6a73c40: 
1:1a5ad28:     @Override
1:ae5bd2e:     public void setPrefetchSize(int prefetchSize) {
1:ae5bd2e:         this.info.setPrefetchSize(prefetchSize);
1:ae5bd2e:         try {
1:ae5bd2e:             this.dispatchPending();
1:ae5bd2e:         } catch (Exception e) {
1:ae5bd2e:             LOG.trace("Caught exception during dispatch after prefetch change.", e);
1:37ede54:         }
1:ae5bd2e:     }
1:ae5bd2e: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1:                             if (dispatched.remove(node)) {
1:                                 // if consumer is removed, dispatched will be empty and inflight will
1:                                 // already have been adjusted
1:                                 getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
1:                                 nodeDest.getDestinationStatistics().getInflight().decrement();
1:                             }
commit:41a1007
/////////////////////////////////////////////////////////////////////////
1:                             contractPrefetchExtension(1);
/////////////////////////////////////////////////////////////////////////
1:                             contractPrefetchExtension(1);
1:                             expandPrefetchExtension(1);
1:             } else if (ack.isDeliveredAck()) {
/////////////////////////////////////////////////////////////////////////
1:                         expandPrefetchExtension(ack.getMessageCount());
/////////////////////////////////////////////////////////////////////////
1:                             contractPrefetchExtension(1);
/////////////////////////////////////////////////////////////////////////
1:                             contractPrefetchExtension(1);
/////////////////////////////////////////////////////////////////////////
1:                         synchronized (dispatchLock) {
1:                         contractPrefetchExtension(1);
1:                         contractPrefetchExtension(1);
commit:511b9b6
/////////////////////////////////////////////////////////////////////////
1:                     while (count < numberToDispatch && !isFull() && pending.hasNext()) {
commit:ffee8b4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 wakeupDestinationsForDispatch();
/////////////////////////////////////////////////////////////////////////
commit:6cc2c11
/////////////////////////////////////////////////////////////////////////
1:                         if (broker.isExpired(node)) {
1:                             regionDestination.messageExpired(context, this, node);
1:                         }
commit:e3df09b
/////////////////////////////////////////////////////////////////////////
1:                                         node.decrementReferenceCount();
commit:1ad0117
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         // decrement after dispatch has taken ownership to avoid usage jitter
1:                         node.decrementReferenceCount();
commit:c85fa67
/////////////////////////////////////////////////////////////////////////
commit:2d9959a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         if (usePrefetchExtension && getPrefetchSize() != 0 && ack.isInTransaction()) {
0:                             // allow transaction batch to exceed prefetch
1:                             while (true) {
1:                                 int currentExtension = prefetchExtension.get();
0:                                 int newExtension = Math.max(currentExtension, currentExtension + 1);
1:                                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                                     break;
1:                                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:                         if (usePrefetchExtension && getPrefetchSize() != 0) {
0:                             // allow  batch to exceed prefetch
/////////////////////////////////////////////////////////////////////////
0:                     public void beforeEnd() {
0:                         if (usePrefetchExtension && getPrefetchSize() != 0) {
0:                             while (true) {
0:                                 int currentExtension = prefetchExtension.get();
1:                                 int newExtension = Math.max(0, currentExtension - 1);
0:                                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                                     break;
1:                                 }
1:                             }
1:                         }
1:                     }
1: 
1:                     @Override
/////////////////////////////////////////////////////////////////////////
1:         return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
1:         return getPrefetchSize() == 0 ? prefetchExtension.get() : info.getPrefetchSize() + prefetchExtension.get() - dispatched.size();
/////////////////////////////////////////////////////////////////////////
1:         }
1:         if (getPrefetchSize() == 0) {
commit:52e1a05
/////////////////////////////////////////////////////////////////////////
1:                     if (node instanceof QueueMessageReference) {
1:                         ((QueueMessageReference) node).unlock();
1:                     }
commit:b136df1
/////////////////////////////////////////////////////////////////////////
0:             }else if (ack.isDeliveredAck() || ack.isExpiredAck()) {
author:Vasco Veloso
-------------------------------------------------------------------------------
commit:687badb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         if (isUsePrefetchExtension() && getPrefetchSize() != 0 && ack.isInTransaction()) {
/////////////////////////////////////////////////////////////////////////
0:                         if (isUsePrefetchExtension() && getPrefetchSize() != 0) {
/////////////////////////////////////////////////////////////////////////
0:                             if (isUsePrefetchExtension() && getPrefetchSize() != 0) {
/////////////////////////////////////////////////////////////////////////
0:                         if (isUsePrefetchExtension() && getPrefetchSize() != 0) {
/////////////////////////////////////////////////////////////////////////
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:cd5ea6c
/////////////////////////////////////////////////////////////////////////
1:                     if (ack.getFirstMessageId() == null || ack.getFirstMessageId().equals(messageId)) {
1:                         Destination regionDestination = nodeDest;
0:                         regionDestination.messageExpired(context, this, node);
1:                         iter.remove();
1:                         nodeDest.getDestinationStatistics().getInflight().decrement();
1: 
commit:4e23adf
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1:         LinkedList<MessageReference> redispatch = new LinkedList<MessageReference>();
1:             redispatch.addAll(pending.remove(context, destination));
1:                 return redispatch;
1:                     addReferencesAndUpdateRedispatch(redispatch, destination, dispatched);
1:                 addReferencesAndUpdateRedispatch(redispatch, destination, dispatched);
1: 
1:         return redispatch;
1:     private void addReferencesAndUpdateRedispatch(LinkedList<MessageReference> redispatch, Destination destination, List<MessageReference> dispatched) {
/////////////////////////////////////////////////////////////////////////
1:         redispatch.addAll(0, references);
commit:a28a091
/////////////////////////////////////////////////////////////////////////
1:         List<Destination> slowConsumerTargets = null;
1: 
/////////////////////////////////////////////////////////////////////////
1:                     slowConsumerTargets = destinations;
1: 
1:         if (slowConsumerTargets != null) {
1:             for (Destination dest : slowConsumerTargets) {
1:                 dest.slowConsumer(context, this);
1:             }
1:         }
commit:5e05df1
/////////////////////////////////////////////////////////////////////////
1:      * @return true if the subscription is full
commit:c38a61d
/////////////////////////////////////////////////////////////////////////
1:                             if (!isDropped(node) && canDispatch(node)) {
1:                                 if (node != QueueMessageReference.NULL_MESSAGE && node.isExpired()) {
1: 
commit:05ff52d
/////////////////////////////////////////////////////////////////////////
1:     public Response pullMessage(ConnectionContext context, final MessagePull pull) throws Exception {
1:             prefetchExtension.set(pull.getQuantity());
/////////////////////////////////////////////////////////////////////////
0:                 if (dispatchCounterBeforePull == dispatchCounter || pull.isAlwaysSignalDone()) {
1:                         // Null message indicates the pull is done or did not have pending.
1:                         prefetchExtension.set(1);
/////////////////////////////////////////////////////////////////////////
1:                                 pullTimeout(dispatchCounterBeforePull, pull.isAlwaysSignalDone());
/////////////////////////////////////////////////////////////////////////
1:     final void pullTimeout(long dispatchCounterBeforePull, boolean alwaysSignalDone) {
0:             if (dispatchCounterBeforePull == dispatchCounter || alwaysSignalDone) {
1:                     prefetchExtension.set(1);
1:                 } finally {
1:                     prefetchExtension.set(0);
/////////////////////////////////////////////////////////////////////////
1:             if (!destinations.contains(node.getRegionDestination()) && node != QueueMessageReference.NULL_MESSAGE) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. Ignored ack: {}", ack);
1:         LOG.trace("ack: {}", ack);
1: 
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Could not correlate acknowledgment with dispatched message: {}", ack);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): {}", ack);
/////////////////////////////////////////////////////////////////////////
0:                             LOG.trace("{} failed to dispatch: {} - {}, dispatched: {}, inflight: {}", new Object[]{ info.getConsumerId(), message.getMessageId(), message.getDestination(), dispatchCounter, dispatched.size() });
/////////////////////////////////////////////////////////////////////////
0:                 LOG.trace("{} dispatched: {} - {}, dispatched: {}, inflight: {}", new Object[]{ info.getConsumerId(), message.getMessageId(), message.getDestination(), dispatchCounter, dispatched.size() });
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:734fb7d
/////////////////////////////////////////////////////////////////////////
1:     public long getPendingMessageSize() {
1:         synchronized (pendingLock) {
1:             return pending.messageSize();
1:         }
1:     }
1: 
1:     @Override
commit:f10aab6
/////////////////////////////////////////////////////////////////////////
0:             }else if (ack.isDeliveredAck()) {
/////////////////////////////////////////////////////////////////////////
1:             } else if (ack.isExpiredAck()) {
1:                 // Message was expired
1:                 int index = 0;
1:                 boolean inAckRange = false;
1:                 for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext(); index++) {
1:                     final MessageReference node = iter.next();
1:                     Destination nodeDest = (Destination) node.getRegionDestination();
1:                     MessageId messageId = node.getMessageId();
1:                     if (ack.getFirstMessageId() == null
1:                             || ack.getFirstMessageId().equals(messageId)) {
1:                         inAckRange = true;
1:                     }
1:                     if (inAckRange) {
0:                         if (node.isExpired()) {
1:                             if (broker.isExpired(node)) {
0:                                 Destination regionDestination = nodeDest;
0:                                 regionDestination.messageExpired(context, this, node);
1:                             }
0:                             iter.remove();
0:                             nodeDest.getDestinationStatistics().getInflight().decrement();
1:                         }
1:                         if (ack.getLastMessageId().equals(messageId)) {
0:                             if (usePrefetchExtension && getPrefetchSize() != 0) {
0:                                 // allow  batch to exceed prefetch
0:                                 while (true) {
0:                                     int currentExtension = prefetchExtension.get();
0:                                     int newExtension = Math.max(currentExtension, index + 1);
0:                                     if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                                         break;
1:                                     }
1:                                 }
1:                             }
1: 
1:                             destination = (Destination) node.getRegionDestination();
1:                             callDispatchMatched = true;
1:                             break;
1:                         }
1:                     }
1:                 }
1:                 if (!callDispatchMatched) {
1:                     throw new JMSException(
1:                             "Could not correlate expiration acknowledgment with dispatched message: "
1:                                     + ack);
1:                 }
commit:4605503
/////////////////////////////////////////////////////////////////////////
1:                             getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
/////////////////////////////////////////////////////////////////////////
1:                     getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
/////////////////////////////////////////////////////////////////////////
1:                             getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
/////////////////////////////////////////////////////////////////////////
1:                     getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
/////////////////////////////////////////////////////////////////////////
0:                             getSubscriptionStatistics().getInflightMessageSize().addSize(-node.getSize());
/////////////////////////////////////////////////////////////////////////
1:                 getSubscriptionStatistics().getInflightMessageSize().addSize(-r.getSize());
/////////////////////////////////////////////////////////////////////////
1:             getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());
commit:eece576
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             final long dispatchCounterBeforePull = getSubscriptionStatistics().getDispatched().getCount();
/////////////////////////////////////////////////////////////////////////
1:                 if (dispatchCounterBeforePull == getSubscriptionStatistics().getDispatched().getCount() || pull.isAlwaysSignalDone()) {
/////////////////////////////////////////////////////////////////////////
1:             if (dispatchCounterBeforePull == getSubscriptionStatistics().getDispatched().getCount() || alwaysSignalDone) {
/////////////////////////////////////////////////////////////////////////
1:                 getSubscriptionStatistics().getEnqueues().increment();
/////////////////////////////////////////////////////////////////////////
1:                             getSubscriptionStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:                             getSubscriptionStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:                         .getInflight().decrement();
1:                         getSubscriptionStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:                             getSubscriptionStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
1:         return getSubscriptionStatistics().getDequeues().getCount();
1:         return getSubscriptionStatistics().getDispatched().getCount();
1:         return getSubscriptionStatistics().getEnqueues().getCount();
/////////////////////////////////////////////////////////////////////////
1:         synchronized(pendingLock) {
/////////////////////////////////////////////////////////////////////////
1:             getSubscriptionStatistics().getDispatched().increment();
/////////////////////////////////////////////////////////////////////////
1:                             LOG.trace("{} failed to dispatch: {} - {}, dispatched: {}, inflight: {}", new Object[]{ info.getConsumerId(), message.getMessageId(), message.getDestination(), getSubscriptionStatistics().getDispatched().getCount(), dispatched.size() });
/////////////////////////////////////////////////////////////////////////
1:                 LOG.trace("{} dispatched: {} - {}, dispatched: {}, inflight: {}", new Object[]{ info.getConsumerId(), message.getMessageId(), message.getDestination(), getSubscriptionStatistics().getDispatched().getCount(), dispatched.size() });
author:Christopher L. Shannon
-------------------------------------------------------------------------------
commit:174dcbf
/////////////////////////////////////////////////////////////////////////
0:                                     //AMQ-5340
1:                                     if (!isBrowser()) {
1:                                         continue;
1:                                     }
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:6c85967
/////////////////////////////////////////////////////////////////////////
1:     // made public so it can be used in MQTTProtocolConverter
1:     public void dispatchPending() throws IOException {
author:Gary Tully
-------------------------------------------------------------------------------
commit:708be6d
/////////////////////////////////////////////////////////////////////////
1:                         sendToDLQ(context, node, ack.getPoisonCause());
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param poisonCause
1:     protected void sendToDLQ(final ConnectionContext context, final MessageReference node, Throwable poisonCause) throws IOException, Exception {
1:         broker.getRoot().sendToDeadLetterQueue(context, node, this, poisonCause);
commit:4742c7d
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (pending.isEmpty()) {
1:                 for (Destination dest : destinations) {
0:                     dest.wakeup();
1:                 }
1:             }
commit:fc4f01c
/////////////////////////////////////////////////////////////////////////
0:                         iter.remove();
commit:6b4d077
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final List<MessageReference> dispatched = new ArrayList<MessageReference>();
/////////////////////////////////////////////////////////////////////////
1:     protected final Object dispatchLock = new Object();
/////////////////////////////////////////////////////////////////////////
1:      *  called with dispatchLock held
/////////////////////////////////////////////////////////////////////////
1:     // called with dispatchLock held
commit:2030097
/////////////////////////////////////////////////////////////////////////
1:                             registerRemoveSync(context, node);
/////////////////////////////////////////////////////////////////////////
1:                         // Don't remove the nodes until we are committed - immediateAck option
1:                         if (!context.isInTransaction()) {
0:                             dequeueCounter++;
0:                             node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
1:                             dispatched.remove(node);
1:                         } else {
1:                             registerRemoveSync(context, node);
1:                         }
1:                         acknowledge(context, ack, node);
0:                         destination = node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:     private void registerRemoveSync(ConnectionContext context, final MessageReference node) {
1:         // setup a Synchronization to remove nodes from the
1:         // dispatched list.
1:         context.getTransaction().addSynchronization(
1:                 new Synchronization() {
1: 
1:                     @Override
1:                     public void afterCommit()
1:                             throws Exception {
1:                         synchronized(dispatchLock) {
0:                             dequeueCounter++;
1:                             dispatched.remove(node);
0:                             node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
1:                         }
1:                     }
1: 
1:                     @Override
1:                     public void afterRollback() throws Exception {
1:                         synchronized(dispatchLock) {
0:                             if (isSlave()) {
0:                                 node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
1:                             } else {
0:                                 // poisionAck will decrement - otherwise still inflight on client
1:                             }
1:                         }
1:                     }
1:                 });
1:     }
1: 
commit:e10f75c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.command.ActiveMQMessage;
/////////////////////////////////////////////////////////////////////////
0:                         if (ack.getPoisonCause() != null) {
0:                             node.getMessage().setProperty(ActiveMQMessage.DLQ_DELIVERY_FAILURE_CAUSE_PROPERTY,
0:                                     ack.getPoisonCause().toString());
1:                         }
commit:27c1719
/////////////////////////////////////////////////////////////////////////
0:         broker.getRoot().sendToDeadLetterQueue(context, node, this);
commit:cb96783
/////////////////////////////////////////////////////////////////////////
1:     protected final Object pendingLock = new Object();
commit:6519c3e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         setPendingBatchSize(pending, numberToDispatch);
/////////////////////////////////////////////////////////////////////////
1:     protected void setPendingBatchSize(PendingMessageCursor pending, int numberToDispatch) {
1:         pending.setMaxBatchSize(numberToDispatch);
1:     }
1: 
commit:b182556
/////////////////////////////////////////////////////////////////////////
0:                     LOG.warn("Could not correlate acknowledgment with dispatched message: "
commit:969e758
/////////////////////////////////////////////////////////////////////////
1:     public void add(ConnectionContext context, Destination destination) throws Exception {
commit:383d12e
/////////////////////////////////////////////////////////////////////////
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         setSlowConsumer(false);
/////////////////////////////////////////////////////////////////////////
1:                     } else if (!isSlowConsumer()) {
1:                         setSlowConsumer(true);
0:                         for (Destination dest :destinations) {
0:                             dest.slowConsumer(context, this);
commit:6a73c40
/////////////////////////////////////////////////////////////////////////
0:     protected boolean usePrefetchExtension = true;
/////////////////////////////////////////////////////////////////////////
0:                             } else if (usePrefetchExtension && context.isInTransaction()) {
/////////////////////////////////////////////////////////////////////////
0:                         if (usePrefetchExtension) {
0:                             prefetchExtension = Math.max(prefetchExtension, index + 1);
1:                         }
/////////////////////////////////////////////////////////////////////////
1:     
0:     public boolean isUsePrefetchExtension() {
0:         return usePrefetchExtension;
1:     }
1: 
0:     public void setUsePrefetchExtension(boolean usePrefetchExtension) {
0:         this.usePrefetchExtension = usePrefetchExtension;
1:     }
commit:05f82a9
/////////////////////////////////////////////////////////////////////////
0:                         dequeueCounter++;
commit:5619cd0
/////////////////////////////////////////////////////////////////////////
1:                     node.decrementReferenceCount();
/////////////////////////////////////////////////////////////////////////
0:                                 node.decrementReferenceCount();
commit:8de3bd2
/////////////////////////////////////////////////////////////////////////
1:                         if (ack.getLastMessageId().equals(messageId)) {                  
0:                             // contract prefetch if dispatch required a pull
1:                             if (getPrefetchSize() == 0) {
0:                                 prefetchExtension = Math.max(0, prefetchExtension - index);
0:                             } else if (context.isInTransaction()) {
0:                                 // extend prefetch window only if not a pulling consumer
0:                                 prefetchExtension = Math.max(prefetchExtension, index);
commit:80f7e38
/////////////////////////////////////////////////////////////////////////
0:             LOG.trace("ack:" + ack);
/////////////////////////////////////////////////////////////////////////
0:                                                 if (isSlave()) {
0:                                                     node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
1:                                                 } else {
0:                                                     // poisionAck will decrement - otherwise still inflight on client
1:                                                 }
/////////////////////////////////////////////////////////////////////////
0:                                 .getInflight().decrement();
commit:9cf216c
/////////////////////////////////////////////////////////////////////////
1:                             
/////////////////////////////////////////////////////////////////////////
1:                             } else {
0:                                 // contract prefetch if dispatch required a pull
0:                                 if (getPrefetchSize() == 0) {
0:                                     prefetchExtension = Math.max(0, prefetchExtension - index);
1:                                 }
commit:62eb5cf
/////////////////////////////////////////////////////////////////////////
0:             LOG.info("ack:" + ack);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0bc545b
/////////////////////////////////////////////////////////////////////////
1:             throw new JMSException("Unmatched acknowledge: " + ack
1:             throw new JMSException("Unmatched acknowledge: " + ack
1:             throw new JMSException("Unmatched acknowledge: " + ack
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace(info.getConsumerId() + " dispatched: " + message.getMessageId() 
0:                             + ", dispatched: " + dispatchCounter + ", inflight: " + dispatched.size());
commit:ca242f4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     if (node.isExpired()) {
0:                         if (broker.isExpired(node)) {
0:                         node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                         if (broker.isExpired(node)) {
0:                                             node.getRegionDestination().messageExpired(context, this, node);
1:                                         }
commit:7a59d28
/////////////////////////////////////////////////////////////////////////
0:                     if (hasNotAlreadyExpired(node)) {
0:                         if (node.isExpired()) {
0:                             node.getRegionDestination().messageExpired(context, this, node);
1:                             dispatched.remove(node);
0:                             node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
1:                         }
1:                     } else {
0:                         // already expired
0:                         node.getRegionDestination().getDestinationStatistics().getInflight().decrement();    
/////////////////////////////////////////////////////////////////////////
0:     private boolean hasNotAlreadyExpired(MessageReference node) {
0:         boolean hasNotExpired = true;
1:         try {
0:             hasNotExpired = node.getMessage().getProperty(RegionBroker.ORIGINAL_EXPIRATION) == null;
1:         } catch (IOException e) {
0:             LOG.warn("failed to determine value message property " + RegionBroker.ORIGINAL_EXPIRATION + " for " + node, e);
1:         }
0:         return hasNotExpired;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             // Here is a potential problem concerning Inflight stat:
1:             // Messages not already committed or rolled back may not be removed from dispatched list at the moment
1:             // Except if each commit or rollback callback action comes before remove of subscriber.
0:             rc.addAll(pending.remove(context, destination));
1: 
/////////////////////////////////////////////////////////////////////////
0:                 destination.getDestinationStatistics().getDispatched().subtract(dispatched.size());
0:                 destination.getDestinationStatistics().getInflight().subtract(dispatched.size());
0:                 dispatched.clear();
1:             }            
/////////////////////////////////////////////////////////////////////////
0:                 node.getRegionDestination().getDestinationStatistics().getInflight().increment();   
0:                 if (LOG.isTraceEnabled()) {
0:                     LOG.trace(info.getDestination().getPhysicalName() + " dispatched: " + message.getMessageId() 
0:                             + ", dispatched: " + node.getRegionDestination().getDestinationStatistics().getDispatched().getCount()
0:                             + ", inflight: " + node.getRegionDestination().getDestinationStatistics().getInflight().getCount());
1:                 }
1:         
commit:4e0609f
/////////////////////////////////////////////////////////////////////////
1:             if (!okForAckAsDispatchDone.await(0l, TimeUnit.MILLISECONDS)) {
1:                 // suppress unexpected ack exception in this expected case
0:                 LOG.warn("Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. Ignored ack: " + ack);
1:                 return;
commit:e45bb06
/////////////////////////////////////////////////////////////////////////
1:         if (callDispatchMatched && destination != null) {    
1:             destination.wakeup();
/////////////////////////////////////////////////////////////////////////
0:                 node.getRegionDestination().getDestinationStatistics().getInflight().increment();       
commit:132f662
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
0:     private CountDownLatch okForAckAsDispatchDone = new CountDownLatch(1);
1:     
/////////////////////////////////////////////////////////////////////////
1:         
0:         if (!isSlave()) {
0:             while(!okForAckAsDispatchDone.await(100, TimeUnit.MILLISECONDS)) {
0:                 LOG.warn("Ack before disaptch, waiting for recovery dispatch: " + ack);
1:             }
1:         }
0:         if (LOG.isTraceEnabled()) {
0:             LOG.trace("ack:" + ack);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                     LOG.error("Could not correlate acknowledgment with dispatched message: "
/////////////////////////////////////////////////////////////////////////
1:         
1:         okForAckAsDispatchDone.countDown();
1:         
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isTraceEnabled()) {
0:             LOG.trace(info.getDestination().getPhysicalName() + " dispatched: " + message.getMessageId());
1:         }
commit:c7b48c4
/////////////////////////////////////////////////////////////////////////
1:                         + mdn.getMessageId() + ") was not in the pending list for "
1:                         + mdn.getConsumerId() + " on " + mdn.getDestination().getPhysicalName());
commit:564a9c2
/////////////////////////////////////////////////////////////////////////
commit:3804d66
/////////////////////////////////////////////////////////////////////////
commit:2b2b35e
/////////////////////////////////////////////////////////////////////////
0:     protected static final Scheduler scheduler = Scheduler.getInstance();
1:     
/////////////////////////////////////////////////////////////////////////
1: 	                    scheduler.executeAfterDelay(new Runnable() {
commit:6d1f57b
/////////////////////////////////////////////////////////////////////////
1:                         // Don't remove the nodes until we are committed.  
/////////////////////////////////////////////////////////////////////////
commit:0bfb28a
/////////////////////////////////////////////////////////////////////////
1:                             removeList.add(node);
/////////////////////////////////////////////////////////////////////////
0:                                                 dispatched.remove(node);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 // a DLQ message.
0:                 // the ack.
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): "
1:                         + ack);
/////////////////////////////////////////////////////////////////////////
1:         if (ack.getMessageCount() != checkCount && !ack.isInTransaction()) {
/////////////////////////////////////////////////////////////////////////
1:                             // Synchronize between dispatched list and remove of message from pending list
commit:fdee6e8
/////////////////////////////////////////////////////////////////////////
1: 	protected void assertAckMatchesDispatched(MessageAck ack) throws JMSException {
1:         MessageId lastAckedMsg = ack.getLastMessageId();
1:         int checkCount = 0;
1:         boolean checkFoundStart = false;
1:         boolean checkFoundEnd = false;
1:         for (MessageReference node : dispatched) {
1:             if (firstAckedMsg == null) {
1:                 checkFoundStart = true;
1:             } else if (!checkFoundStart && firstAckedMsg.equals(node.getMessageId())) {
1:                 checkFoundStart = true;
1:             }
1:             if (checkFoundStart) {
1:                 checkCount++;
1:             }
1:             if (lastAckedMsg != null && lastAckedMsg.equals(node.getMessageId())) {
1:                 checkFoundEnd = true;
1:                 break;
1:             }
1:         }
1:         if (!checkFoundStart && firstAckedMsg != null)
0:             throw new JMSException("Unmatched acknowledege: " + ack
1:                     + "; Could not find Message-ID " + firstAckedMsg
1:                     + " in dispatched-list (start of ack)");
1:         if (!checkFoundEnd && lastAckedMsg != null)
0:             throw new JMSException("Unmatched acknowledege: " + ack
1:                     + "; Could not find Message-ID " + lastAckedMsg
1:                     + " in dispatched-list (end of ack)");
0:         if (ack.getMessageCount() != checkCount && ack.isStandardAck()) {
0:             throw new JMSException("Unmatched acknowledege: " + ack
1:                     + "; Expected message count (" + ack.getMessageCount()
1:                     + ") differs from count in dispatched-list (" + checkCount
1:                     + ")");
1:         }
1:     }
commit:543bc84
/////////////////////////////////////////////////////////////////////////
0: 			throw new JMSException("Unmatched acknowledege: Could not find Message-ID "+lastAckedMsg+" in dispatched-list (end of ack)");
commit:ae1bb66
/////////////////////////////////////////////////////////////////////////
1:                             onDispatch(node, node.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                         + mdn.getMessageId() + ") was not in the pending list for " + mdn.getDestination().getPhysicalName());
/////////////////////////////////////////////////////////////////////////
0:                             node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
commit:4713040
/////////////////////////////////////////////////////////////////////////
0:         return dispatched.size() - prefetchExtension >= info.getPrefetchSize();
commit:b006b25
/////////////////////////////////////////////////////////////////////////
0:         return dispatched.size() - prefetchExtension >= info.getPrefetchSize();
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:37ede54
/////////////////////////////////////////////////////////////////////////
1:         if (this.pending != null) {
1:             this.pending.setMaxProducersToAudit(maxProducersToAudit);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (this.pending != null) {
1:             this.pending.setMaxAuditDepth(maxAuditDepth);
1:         }
commit:3039b67
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         return remove(context, destination, dispatched);
1:     }
1: 
1:     public List<MessageReference> remove(ConnectionContext context, Destination destination, List<MessageReference> dispatched) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             if (dispatched == null) {
0:                 return rc;
1:             }
1: 
1:             // Synchronized to DispatchLock if necessary
1:             if (dispatched == this.dispatched) {
1:                 synchronized(dispatchLock) {
0:                     updateDestinationStats(rc, destination, dispatched);
1:             } else {
0:                 updateDestinationStats(rc, destination, dispatched);
0:     private void updateDestinationStats(List<MessageReference> rc, Destination destination, List<MessageReference> dispatched) {
1:         ArrayList<MessageReference> references = new ArrayList<MessageReference>();
1:         for (MessageReference r : dispatched) {
1:             if (r.getRegionDestination() == destination) {
1:                 references.add(r);
1:             }
1:         }
0:         rc.addAll(references);
0:         destination.getDestinationStatistics().getDispatched().subtract(references.size());
1:         destination.getDestinationStatistics().getInflight().subtract(references.size());
1:         dispatched.removeAll(references);
1:     }
1: 
commit:ae61847
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransmitCallback;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:                             Destination regionDestination = nodeDest;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:     @Override
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:                     while (pending.hasNext() && !isFull() && count < numberToDispatch) {
/////////////////////////////////////////////////////////////////////////
1:             md.setTransmitCallback(new TransmitCallback() {
1:                 @Override
1:                 public void onSuccess() {
1:                     // Since the message gets queued up in async dispatch, we don't want to
1:                     // decrease the reference count until it gets put on the wire.
1: 
1:                 @Override
1:                 public void onFailure() {
1:                     Destination nodeDest = (Destination) node.getRegionDestination();
1:                     if (nodeDest != null) {
1:                         if (node != QueueMessageReference.NULL_MESSAGE) {
1:                             nodeDest.getDestinationStatistics().getDispatched().increment();
1:                             nodeDest.getDestinationStatistics().getInflight().increment();
0:                             if (LOG.isTraceEnabled()) {
0:                                 LOG.trace(info.getConsumerId() + " failed to dispatch: " + message.getMessageId() + " - "
0:                                         + message.getDestination()  + ", dispatched: " + dispatchCounter + ", inflight: " + dispatched.size());
1:                             }
1:                         }
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:6ce59ed
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Don't increment for the pullTimeout control message.
1:             if (!node.equals(QueueMessageReference.NULL_MESSAGE)) {
0:                 enqueueCounter++;
1:             }
commit:3c39db8
/////////////////////////////////////////////////////////////////////////
0:                         node.getRegionDestination().wakeup();
1:                         dispatchPending();
commit:ae5bd2e
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public void setPrefetchSize(int prefetchSize) {
1:         this.info.setPrefetchSize(prefetchSize);
1:         try {
1:             this.dispatchPending();
1:         } catch (Exception e) {
1:             LOG.trace("Caught exception during dispatch after prefetch change.", e);
1:         }
1:     }
commit:3a5b48a
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected final AtomicInteger prefetchExtension = new AtomicInteger();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         // The slave should not deliver pull messages.
1:         // TODO: when the slave becomes a master, He should send a NULL message to all the
1:         // consumers to 'wake them up' in case they were waiting for a message.
1: 
0:             prefetchExtension.incrementAndGet();
0:             final long dispatchCounterBeforePull = dispatchCounter;
1: 
1:             // Have the destination push us some messages.
0:             for (Destination dest : destinations) {
1:                 dest.iterate();
1:             }
1:             dispatchPending();
1: 
1:                 // If there was nothing dispatched.. we may need to setup a timeout.
0:                 if (dispatchCounterBeforePull == dispatchCounter) {
1:                     // immediate timeout used by receiveNoWait()
1:                     if (pull.getTimeout() == -1) {
0:                         // Send a NULL message.
1:                         add(QueueMessageReference.NULL_MESSAGE);
1:                         dispatchPending();
1:                     }
1:                     if (pull.getTimeout() > 0) {
0:                         scheduler.executeAfterDelay(new Runnable() {
1:                             @Override
1:                             public void run() {
0:                                 pullTimeout(dispatchCounterBeforePull);
1:                             }
1:                         }, pull.getTimeout());
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         synchronized (pendingLock) {
0:             if (dispatchCounterBeforePull == dispatchCounter) {
/////////////////////////////////////////////////////////////////////////
1:             // The destination may have just been removed...
1:             pending.addMessageLast(node);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 // First check if the ack matches the dispatched. When using failover this might
1:                 // not be the case. We don't ever want to ack the wrong messages.
1:                 assertAckMatchesDispatched(ack);
1: 
/////////////////////////////////////////////////////////////////////////
0:                         // Don't remove the nodes until we are committed.
/////////////////////////////////////////////////////////////////////////
1:                         if (ack.getLastMessageId().equals(messageId)) {
0:                                 // Protect extension update against parallel updates.
0:                                 while (true) {
0:                                     int currentExtension = prefetchExtension.get();
0:                                     int newExtension = Math.max(0, currentExtension - index);
0:                                     if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                                         break;
1:                                     }
1:                                 }
0:                                 while (true) {
0:                                     int currentExtension = prefetchExtension.get();
0:                                     int newExtension = Math.max(currentExtension, index);
0:                                     if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                                         break;
1:                                     }
1:                                 }
/////////////////////////////////////////////////////////////////////////
1: 
0:                         // Protect extension update against parallel updates.
0:                         while (true) {
0:                             int currentExtension = prefetchExtension.get();
0:                             int newExtension = Math.max(0, currentExtension - 1);
0:                             if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                                 break;
1:                             }
1:                         }
/////////////////////////////////////////////////////////////////////////
0:                             while (true) {
0:                                 int currentExtension = prefetchExtension.get();
0:                                 int newExtension = Math.max(currentExtension, index + 1);
0:                                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
1:                                     break;
1:                                 }
1:                             }
/////////////////////////////////////////////////////////////////////////
0:                             while (true) {
0:                                 int currentExtension = prefetchExtension.get();
0:                                 int newExtension = Math.max(0, currentExtension - (index + 1));
0:                                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
0:                                     break;
1:                                 }
1:                             }
/////////////////////////////////////////////////////////////////////////
0:         if (callDispatchMatched && destination != null) {
/////////////////////////////////////////////////////////////////////////
1:      *
0:     protected void assertAckMatchesDispatched(MessageAck ack) throws JMSException {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:      *
0:         return dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();
1:         return (dispatched.size() - prefetchExtension.get()) <= (info.getPrefetchSize() * .4);
1:         return (dispatched.size() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9);
0:         return info.getPrefetchSize() + prefetchExtension.get() - dispatched.size();
/////////////////////////////////////////////////////////////////////////
0:                 for (MessageReference r : dispatched) {
0:                     if( r.getRegionDestination() == destination) {
1:                     }
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:                 while (true) {
0:                     int currentExtension = prefetchExtension.get();
0:                     int newExtension = Math.max(0, currentExtension - 1);
0:                     if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
0:                         break;
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 node.getRegionDestination().getDestinationStatistics().getInflight().increment();
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:         MessageDispatch md = new MessageDispatch();
1:         md.setConsumerId(info.getConsumerId());
1: 
1: 
1:         return md;
1:      *
1: 
1:      *
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected int getPrefetchExtension() {
0:         return this.prefetchExtension.get();
1:     }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:30f531d
/////////////////////////////////////////////////////////////////////////
0:         if (getPrefetchSize() == 0) {
/////////////////////////////////////////////////////////////////////////
0:         if (!okForAckAsDispatchDone.await(0l, TimeUnit.MILLISECONDS)) {
0:             // suppress unexpected ack exception in this expected case
0:             LOG.warn("Ignoring ack received before dispatch; result of failover with an outstanding ack. Acked messages will be replayed if present on this broker. Ignored ack: " + ack);
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
0:             LOG.debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): "
1:                     + ack);
/////////////////////////////////////////////////////////////////////////
0:                             // poisionAck will decrement - otherwise still inflight on client
/////////////////////////////////////////////////////////////////////////
1:        synchronized(pendingLock) {
1:             try {
1:                 int numberToDispatch = countBeforeFull();
1:                 if (numberToDispatch > 0) {
0:                     setSlowConsumer(false);
0:                     setPendingBatchSize(pending, numberToDispatch);
1:                     int count = 0;
1:                     pending.reset();
0:                     while (pending.hasNext() && !isFull()
0:                             && count < numberToDispatch) {
1:                         MessageReference node = pending.next();
1:                         if (node == null) {
0:                             break;
1: 
0:                         // Synchronize between dispatched list and remove of message from pending list
1:                         // related to remove subscription action
1:                         synchronized(dispatchLock) {
1:                             pending.remove();
0:                             node.decrementReferenceCount();
0:                             if( !isDropped(node) && canDispatch(node)) {
1: 
1:                                 // Message may have been sitting in the pending
1:                                 // list a while waiting for the consumer to ak the message.
0:                                 if (node!=QueueMessageReference.NULL_MESSAGE && node.isExpired()) {
1:                                     //increment number to dispatch
1:                                     numberToDispatch++;
0:                                     if (broker.isExpired(node)) {
1:                                         ((Destination)node.getRegionDestination()).messageExpired(context, this, node);
1:                                     }
0:                                     continue;
1:                                 }
1:                                 dispatch(node);
1:                                 count++;
1:                             }
0:                 } else if (!isSlowConsumer()) {
0:                     setSlowConsumer(true);
0:                     for (Destination dest :destinations) {
0:                         dest.slowConsumer(context, this);
1:                     }
1:             } finally {
1:                 pending.release();
/////////////////////////////////////////////////////////////////////////
1:         MessageDispatch md = createMessageDispatch(node, message);
0:         // NULL messages don't count... they don't get Acked.
1:         if (node != QueueMessageReference.NULL_MESSAGE) {
0:             dispatchCounter++;
1:             dispatched.add(node);
0:         } else {
0:             while (true) {
0:                 int currentExtension = prefetchExtension.get();
0:                 int newExtension = Math.max(0, currentExtension - 1);
0:                 if (prefetchExtension.compareAndSet(currentExtension, newExtension)) {
0:                     break;
1:         if (info.isDispatchAsync()) {
0:             md.setTransmitCallback(new Runnable() {
1: 
0:                 public void run() {
0:                     // Since the message gets queued up in async dispatch,
0:                     // we don't want to
0:                     // decrease the reference count until it gets put on the
0:                     // wire.
1:                     onDispatch(node, message);
1:                 }
1:             });
1:             context.getConnection().dispatchAsync(md);
0:         } else {
1:             context.getConnection().dispatchSync(md);
1:             onDispatch(node, message);
1:         }
1:         return true;
commit:58aca86
commit:9a8f6e4
/////////////////////////////////////////////////////////////////////////
1:                             ((Destination)node.getRegionDestination()).getDestinationStatistics().getInflight().decrement();
/////////////////////////////////////////////////////////////////////////
1:                             destination = (Destination) node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:                             ((Destination)node.getRegionDestination()).getDestinationStatistics().getInflight().decrement();
/////////////////////////////////////////////////////////////////////////
1:                         destination = (Destination) node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:                     Destination nodeDest = (Destination) node.getRegionDestination();
0:                             Destination regionDestination = (Destination) nodeDest;
0:                             regionDestination.messageExpired(context, this, node);
0:                         nodeDest.getDestinationStatistics().getInflight().decrement();
/////////////////////////////////////////////////////////////////////////
1:                         destination = nodeDest;
/////////////////////////////////////////////////////////////////////////
1:                             destination = (Destination) node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
1:                         Destination nodeDest = (Destination) node.getRegionDestination();
1:                         nodeDest.getDestinationStatistics()
/////////////////////////////////////////////////////////////////////////
1:                             destination = nodeDest;
/////////////////////////////////////////////////////////////////////////
1:                         Destination nodeDest = (Destination) node.getRegionDestination();
0:                             nodeDest.getDestinationStatistics().getInflight().decrement();
1:                         nodeDest.wakeup();
/////////////////////////////////////////////////////////////////////////
0:                                 ((Destination)node.getRegionDestination()).getDestinationStatistics().getInflight().decrement();
/////////////////////////////////////////////////////////////////////////
0:                                             ((Destination)node.getRegionDestination()).messageExpired(context, this, node);
/////////////////////////////////////////////////////////////////////////
1:         Destination nodeDest = (Destination) node.getRegionDestination();
1:         if (nodeDest != null) {
1:                 nodeDest.getDestinationStatistics().getDispatched().increment();
1:                 nodeDest.getDestinationStatistics().getInflight().increment();
/////////////////////////////////////////////////////////////////////////
1:             Destination regionDestination = (Destination) node.getRegionDestination();
1:             md.setDestination(regionDestination.getActiveMQDestination());
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:3fe7760
/////////////////////////////////////////////////////////////////////////
1:                         // Synchronize between dispatched list and removal of messages from pending list
1:                         // related to remove subscription action
1:                             pending.remove();
1:                             createMessageDispatch(node, node.getMessage());
/////////////////////////////////////////////////////////////////////////
0:             // Synchronized to DispatchLock
0:             synchronized(dispatchLock) {
0: 	            for (MessageReference r : dispatched) {
0: 	                if( r.getRegionDestination() == destination) {
0: 	                	rc.add((QueueMessageReference)r);
1: 	                }
1: 	            }
0:             // TODO Dispatched messages should be decremented from Inflight stat 
0:             // Here is a potential problem concerning Inflight stat:
0:             // Messages not already committed or rolled back may not be removed from dispatched list at the moment
0:             // Except if each commit or rollback callback action comes before remove of subscriber.
/////////////////////////////////////////////////////////////////////////
0:                             // Synchronize between dispatched list and remove of messageg from pending list
0:                             // related to remove subscription action
0:                             synchronized(dispatchLock) {
0:                                 pending.remove();
0:                                 if( !isDropped(node) && canDispatch(node)) {
0:                                     // Message may have been sitting in the pending
0:                                     // list a while waiting for the consumer to ak the message.
0:                                     if (node!=QueueMessageReference.NULL_MESSAGE && node.isExpired()) {
0:                                         //increment number to dispatch
0:                                         numberToDispatch++;
0:                                         node.getRegionDestination().messageExpired(context, this, node);
0:                                         continue;
1:                                     }
0:                                     dispatch(node);
0:                                     count++;
/////////////////////////////////////////////////////////////////////////
1:         }
0:         // No reentrant lock - Patch needed to IndirectMessageReference on method lock
0:         if (!isSlave()) {
1: 
commit:efdf8ce
/////////////////////////////////////////////////////////////////////////
0:                                                 node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                                                 node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
/////////////////////////////////////////////////////////////////////////
0:                                             	// ActiveMQ workaround for AMQ-1730 - Please Ignore next line
0:                                                 node.incrementRedeliveryCounter();
0:                                                 node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
commit:d453b8d
/////////////////////////////////////////////////////////////////////////
1:                         removeList.add(node);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                         public void afterRollback() throws Exception {
0:                                         	// Need to put it back in the front.
0:                                             synchronized(dispatchLock) {
0:                                         	    dispatched.add(0, node);
1:                                             }
/////////////////////////////////////////////////////////////////////////
1: 			
0: 			if( firstAckedMsg == null ) {
0: 				checkFoundStart=true;
0: 			} else if (!checkFoundStart && firstAckedMsg.equals(node.getMessageId())) {
0: 			if (checkFoundStart) {
1: 			}
commit:349466b
/////////////////////////////////////////////////////////////////////////
0:             if( !destinations.contains(node.getRegionDestination()) && node!=QueueMessageReference.NULL_MESSAGE) {
commit:ff46232
/////////////////////////////////////////////////////////////////////////
0:             // The destination may have just been removed...  
0:             if( !destinations.contains(node.getRegionDestination()) ) {
1:                 // perhaps we should inform the caller that we are no longer valid to dispatch to?
1:                 return;
1:             }
commit:2a328ed
/////////////////////////////////////////////////////////////////////////
0:     public Response pullMessage(ConnectionContext context, MessagePull pull) throws Exception {
0:             final long dispatchCounterBeforePull;
1:         	synchronized(this) {
0:         		prefetchExtension++;
0:         		dispatchCounterBeforePull = dispatchCounter;
1:         	}
1:             
0:         	// Have the destination push us some messages.
0:         	for (Destination dest : destinations) {
0: 				dest.iterate();
1: 			}
1:         	dispatchPending();
1:             
1:             synchronized(this) {
0: 	            // If there was nothing dispatched.. we may need to setup a timeout.
0: 	            if (dispatchCounterBeforePull == dispatchCounter) {
0: 	                // imediate timeout used by receiveNoWait()
0: 	                if (pull.getTimeout() == -1) {
0: 	                    // Send a NULL message.
1: 	                    add(QueueMessageReference.NULL_MESSAGE);
1: 	                    dispatchPending();
1: 	                }
0: 	                if (pull.getTimeout() > 0) {
0: 	                    Scheduler.executeAfterDelay(new Runnable() {
1: 	
0: 	                        public void run() {
0: 	                            pullTimeout(dispatchCounterBeforePull);
1: 	                        }
0: 	                    }, pull.getTimeout());
1: 	                }
1: 	            }
commit:a9ba595
/////////////////////////////////////////////////////////////////////////
1:                 for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext(); index++) {
0:                     if( node.isExpired() ) {
0:                         broker.messageExpired(getContext(), node);
0:                         node.getRegionDestination().messageExpired(context, this, node);
0:                         node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                         node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
0:                         dispatched.remove(node);
1:                     }
0:                         prefetchExtension = Math.max(prefetchExtension, index + 1);
/////////////////////////////////////////////////////////////////////////
0:                                 if (node!=QueueMessageReference.NULL_MESSAGE && node.isExpired()) {
0:                                     node.getRegionDestination().messageExpired(context, this, node);
commit:ae7de6c
/////////////////////////////////////////////////////////////////////////
1:     public List<MessageReference> remove(ConnectionContext context, Destination destination) throws Exception {
0:         List<MessageReference> rc = new ArrayList<MessageReference>();
0:             for (MessageReference r : dispatched) {
0:                 if( r.getRegionDestination() == destination ) {
0:                     rc.add((QueueMessageReference)r);
1:                 }
1:             }
0:             rc.addAll(pending.remove(context, destination));
0:         return rc;
commit:c9c1107
/////////////////////////////////////////////////////////////////////////
1:                             
0:                             pending.remove();
0:                             if( !isDropped(node) && canDispatch(node)) {
1: 
commit:c256dcf
/////////////////////////////////////////////////////////////////////////
0:         } else if (ack.isRedeliveredAck() ) {
0:             // Message was re-delivered but it was not yet considered to be a DLQ message.
0:             // Acknowledge all dispatched messages up till the message id of the
0:             // acknowledgment.
1:             boolean inAckRange = false;
0:             for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext();) {
1:                 final MessageReference node = iter.next();
1:                 MessageId messageId = node.getMessageId();
0:                 if (ack.getFirstMessageId() == null || ack.getFirstMessageId().equals(messageId)) {
1:                     inAckRange = true;
1:                 }
1:                 if (inAckRange) {
0:                     node.incrementRedeliveryCounter();
1:                     if (ack.getLastMessageId().equals(messageId)) {
1:                         callDispatchMatched = true;
0:                         break;
1:                     }
1:                 }
1:             }
1:             if (!callDispatchMatched) {
0:                 throw new JMSException("Could not correlate acknowledgment with dispatched message: " + ack);
1:             }
commit:53c4e12
/////////////////////////////////////////////////////////////////////////
1:                 
commit:ecf89a6
/////////////////////////////////////////////////////////////////////////
0:     protected final LinkedList<MessageReference> dispatched = new LinkedList<MessageReference>();
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext();) {
0:                 final MessageReference node = iter.next();
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext(); index++) {
0:                 final MessageReference node = iter.next();
/////////////////////////////////////////////////////////////////////////
1:             if (ack.isInTransaction()) {
1:             }
0:             for (Iterator<MessageReference> iter = dispatched.iterator(); iter.hasNext();) {
0:                 final MessageReference node = iter.next();
/////////////////////////////////////////////////////////////////////////
0:                         if (node == null) {
1:                         }
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
/////////////////////////////////////////////////////////////////////////
1: public abstract class PrefetchSubscription extends AbstractSubscription {
0:     private static final Log LOG = LogFactory.getLog(PrefetchSubscription.class);
0:     protected final LinkedList dispatched = new LinkedList();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized long getDequeueCounter() {
0:     public synchronized long getDispatchedCounter() {
0:     public synchronized long getEnqueueCounter() {
/////////////////////////////////////////////////////////////////////////
1:     protected abstract boolean canDispatch(MessageReference node) throws IOException;
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
commit:230a86c
/////////////////////////////////////////////////////////////////////////
0: abstract public class PrefetchSubscription extends AbstractSubscription {
0:     static private final Log LOG = LogFactory.getLog(PrefetchSubscription.class);
0:     final protected LinkedList dispatched = new LinkedList();
0:     protected int prefetchExtension;
0:     public PrefetchSubscription(Broker broker, ConnectionContext context, ConsumerInfo info, PendingMessageCursor cursor) throws InvalidSelectorException {
0:         super(broker, context, info);
1:         pending = cursor;
0:     public PrefetchSubscription(Broker broker, ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         this(broker, context, info, new VMPendingMessageCursor());
0:     public synchronized Response pullMessage(ConnectionContext context, MessagePull pull) throws Exception {
0:         // The slave should not deliver pull messages. TODO: when the slave
0:         // becomes a master,
0:         // He should send a NULL message to all the consumers to 'wake them up'
0:         // in case
0:         if (getPrefetchSize() == 0 && !isSlave()) {
0:             final long dispatchCounterBeforePull = dispatchCounter;
0:             if (dispatchCounterBeforePull == dispatchCounter) {
0:                 if (pull.getTimeout() == -1) {
0:                 if (pull.getTimeout() > 0) {
0:                     Scheduler.executeAfterDelay(new Runnable() {
0:                         public void run() {
0:                     }, pull.getTimeout());
/////////////////////////////////////////////////////////////////////////
1:      * Occurs when a pull times out. If nothing has been dispatched since the
1:      * timeout was setup, then send the NULL message.
0:     final synchronized void pullTimeout(long dispatchCounterBeforePull) {
0:         if (dispatchCounterBeforePull == dispatchCounter) {
1:             try {
1:             } catch (Exception e) {
0:     public synchronized void add(MessageReference node) throws Exception {
0:         boolean pendingEmpty = false;
0:         pendingEmpty = pending.isEmpty();
1: 
0:         if (!isFull() && pendingEmpty && !isSlave()) {
0:         } else {
0:             synchronized (pending) {
0:                 if (pending.isEmpty() && LOG.isDebugEnabled()) {
0:                     LOG.debug("Prefetch limit.");
0:     public synchronized void processMessageDispatchNotification(MessageDispatchNotification mdn) throws Exception {
1:         try {
1:             while (pending.hasNext()) {
1:                 MessageReference node = pending.next();
1:                 if (node.getMessageId().equals(mdn.getMessageId())) {
0:                     createMessageDispatch(node, node.getMessage());
1:         } finally {
0:         throw new JMSException("Slave broker out of sync with master: Dispatched message (" + mdn.getMessageId() + ") was not in the pending list");
0:     public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {
1:         boolean callDispatchMatched = false;
1:         if (ack.isStandardAck()) {
0:             // Acknowledge all dispatched messages up till the message id of the
0:             // acknowledgment.
1:             int index = 0;
1:             boolean inAckRange = false;
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:                 final MessageReference node = (MessageReference)iter.next();
1:                 MessageId messageId = node.getMessageId();
0:                 if (ack.getFirstMessageId() == null || ack.getFirstMessageId().equals(messageId)) {
1:                     inAckRange = true;
1:                 if (inAckRange) {
1:                     if (!context.isInTransaction()) {
0:                     } else {
0:                         // setup a Synchronization to remove nodes from the
0:                         // dispatched list.
0:                         context.getTransaction().addSynchronization(new Synchronization() {
0:                             public void afterCommit() throws Exception {
0:                                 synchronized (PrefetchSubscription.this) {
/////////////////////////////////////////////////////////////////////////
0:                             public void afterRollback() throws Exception {
1:                     acknowledge(context, ack, node);
1:                     if (ack.getLastMessageId().equals(messageId)) {
0:                         if (context.isInTransaction()) {
0:                             // extend prefetch window only if not a pulling
0:                             // consumer
0:                             if (getPrefetchSize() != 0) {
0:                                 prefetchExtension = Math.max(prefetchExtension, index + 1);
0:                         } else {
0:                             prefetchExtension = Math.max(0, prefetchExtension - (index + 1));
1:                         callDispatchMatched = true;
1:             // this only happens after a reconnect - get an ack which is not
1:             // valid
1:             if (!callDispatchMatched) {
0:                 if (LOG.isDebugEnabled()) {
0:                     LOG.debug("Could not correlate acknowledgment with dispatched message: " + ack);
0:         } else if (ack.isDeliveredAck()) {
1:             // Message was delivered but not acknowledged: update pre-fetch
1:             // counters.
0:             // Acknowledge all dispatched messages up till the message id of the
0:             // acknowledgment.
1:             int index = 0;
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext(); index++) {
0:                 final MessageReference node = (MessageReference)iter.next();
1:                 if (ack.getLastMessageId().equals(node.getMessageId())) {
0:                     prefetchExtension = Math.max(prefetchExtension, index + 1);
1:                     callDispatchMatched = true;
1:             if (!callDispatchMatched) {
0:                 throw new JMSException("Could not correlate acknowledgment with dispatched message: " + ack);
1:         } else if (ack.isPoisonAck()) {
0:             if (ack.isInTransaction())
0:                 throw new JMSException("Poison ack cannot be transacted: " + ack);
0:             // Acknowledge all dispatched messages up till the message id of the
0:             // acknowledgment.
1:             int index = 0;
1:             boolean inAckRange = false;
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:                 final MessageReference node = (MessageReference)iter.next();
1:                 MessageId messageId = node.getMessageId();
0:                 if (ack.getFirstMessageId() == null || ack.getFirstMessageId().equals(messageId)) {
1:                     inAckRange = true;
1:                 if (inAckRange) {
0:                     sendToDLQ(context, node);
1:                     acknowledge(context, ack, node);
1:                     if (ack.getLastMessageId().equals(messageId)) {
0:                         prefetchExtension = Math.max(0, prefetchExtension - (index + 1));
1:                         callDispatchMatched = true;
1:             if (!callDispatchMatched) {
0:                 throw new JMSException("Could not correlate acknowledgment with dispatched message: " + ack);
0:         if (callDispatchMatched) {
0:         } else {
0:             if (isSlave()) {
0:                 throw new JMSException("Slave broker out of sync with master: Acknowledgment (" + ack + ") was not in the dispatch list: " + dispatched);
0:             } else {
0:                 LOG.debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): " + ack);
/////////////////////////////////////////////////////////////////////////
0:     protected void sendToDLQ(final ConnectionContext context, final MessageReference node) throws IOException, Exception {
0:         broker.sendToDeadLetterQueue(context, node);
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized boolean isFull() {
0:         return isSlave() || dispatched.size() - prefetchExtension >= info.getPrefetchSize();
0:     public synchronized boolean isLowWaterMark() {
0:         return (dispatched.size() - prefetchExtension) <= (info.getPrefetchSize() * .4);
0:     public synchronized boolean isHighWaterMark() {
0:         return (dispatched.size() - prefetchExtension) >= (info.getPrefetchSize() * .9);
0:     public synchronized int countBeforeFull() {
0:         return info.getPrefetchSize() + prefetchExtension - dispatched.size();
0:     public synchronized int getPendingQueueSize() {
0:     public synchronized int getDispatchedQueueSize() {
0:     synchronized public long getDequeueCounter() {
0:     synchronized public long getDispatchedCounter() {
0:     synchronized public long getEnqueueCounter() {
1:     public boolean isRecoveryRequired() {
1: 
0:     public synchronized PendingMessageCursor getPending() {
0:     public synchronized void setPending(PendingMessageCursor pending) {
1:         this.pending = pending;
0:     public void optimizePrefetch() {
0:          * &&context.getConnection().isManageable()){
0:          * if(info.getCurrentPrefetchSize()!=info.getPrefetchSize() &&
0:          * isLowWaterMark()){
0:          * info.setCurrentPrefetchSize(info.getPrefetchSize());
0:          * if(info.getCurrentPrefetchSize()==info.getPrefetchSize() &&
0:          * isHighWaterMark()){ // want to purge any outstanding acks held by the
0:          * consumer info.setCurrentPrefetchSize(1); updateConsumerPrefetch(1); } }
0:     public synchronized void add(ConnectionContext context, Destination destination) throws Exception {
1:         super.add(context, destination);
1:         pending.add(context, destination);
0:     public synchronized void remove(ConnectionContext context, Destination destination) throws Exception {
1:         super.remove(context, destination);
0:         pending.remove(context, destination);
0:     protected synchronized void dispatchMatched() throws IOException {
0:         if (!isSlave()) {
1:             try {
0:                 int numberToDispatch = countBeforeFull();
0:                 if (numberToDispatch > 0) {
0:                     int count = 0;
0:                     while (pending.hasNext() && !isFull() && count < numberToDispatch) {
0:                         MessageReference node = pending.next();
0:                         if (node == null)
0:                         if (canDispatch(node)) {
0:                             // Message may have been sitting in the pending list
0:                             // a while
0:                             if (node != QueueMessageReference.NULL_MESSAGE && broker.isExpired(node)) {
0:                                 broker.messageExpired(getContext(), node);
/////////////////////////////////////////////////////////////////////////
0:             } finally {
0:     protected synchronized boolean dispatch(final MessageReference node) throws IOException {
1:         final Message message = node.getMessage();
1:         if (message == null) {
0:         if (canDispatch(node) && !isSlave()) {
0:             MessageDispatch md = createMessageDispatch(node, message);
1:             if (node != QueueMessageReference.NULL_MESSAGE) {
0:             } else {
0:                 prefetchExtension = Math.max(0, prefetchExtension - 1);
1:             if (info.isDispatchAsync()) {
0:                 md.setTransmitCallback(new Runnable() {
0:                     public void run() {
0:                         // Since the message gets queued up in async dispatch,
0:                         // we don't want to
0:                         // decrease the reference count until it gets put on the
0:                         // wire.
0:                         onDispatch(node, message);
0:             } else {
0:                 onDispatch(node, message);
0:             // System.err.println(broker.getBrokerName() + " " + this + " (" +
0:             // enqueueCounter + ", " + dispatchCounter +") " + node);
0:         } else {
1:     protected void onDispatch(final MessageReference node, final Message message) {
0:         if (node.getRegionDestination() != null) {
1:             if (node != QueueMessageReference.NULL_MESSAGE) {
1:         if (info.isDispatchAsync()) {
0:             try {
0:                 dispatchMatched();
0:             } catch (IOException e) {
1:                 context.getConnection().serviceExceptionAsync(e);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public void updateConsumerPrefetch(int newPrefetch) {
1:         if (context != null && context.getConnection() != null && context.getConnection().isManageable()) {
1:             ConsumerControl cc = new ConsumerControl();
/////////////////////////////////////////////////////////////////////////
1:     protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {
1:         if (node == QueueMessageReference.NULL_MESSAGE) {
0:             MessageDispatch md = new MessageDispatch();
0:         } else {
0:             MessageDispatch md = new MessageDispatch();
/////////////////////////////////////////////////////////////////////////
1:      * @return false if the message should not be dispatched to the client
1:      *         (another sub may have already dispatched it for example).
/////////////////////////////////////////////////////////////////////////
0:     protected void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException {
commit:2728ccb
/////////////////////////////////////////////////////////////////////////
0:                 onDispatch(node,message);                
/////////////////////////////////////////////////////////////////////////
1:         }
0:         if( info.isDispatchAsync() ) {
0: 	        try{
0: 	            dispatchMatched();
0: 	        }catch(IOException e){
0: 	            context.getConnection().serviceExceptionAsync(e);
1: 	        }
commit:f7db42a
/////////////////////////////////////////////////////////////////////////
0:                 md.setTransmitCallback(new Runnable(){
commit:7695676
/////////////////////////////////////////////////////////////////////////
0:                                 if ( node == null )
0:                                 	break;
1:                                 
commit:a58d36b
/////////////////////////////////////////////////////////////////////////
1:                         
0:                         // Message may have been sitting in the pending list a while
0:                         // waiting for the consumer to ak the message.
0:                 		if( node.isExpired() ) {
0:                 			continue; // just drop it.
1:                 		}
1: 
commit:da5139c
/////////////////////////////////////////////////////////////////////////
1: 
0:                             public void afterRollback() throws Exception {
0:                             	super.afterRollback();
1:                             }
commit:cafe4cb
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         	log.debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): "+ack);
/////////////////////////////////////////////////////////////////////////
0:                 context.getConnection().serviceExceptionAsync(e);
commit:62f798a
/////////////////////////////////////////////////////////////////////////
0:                         if(context.isInTransaction()) {
0:                             // extend prefetch window only if not a pulling consumer
0:                             if (getPrefetchSize() != 0) {
0:                                 prefetchExtension=Math.max(prefetchExtension,index+1);
1:                             }
1:                         }
0:                         else {
1:                         }
commit:a19bfd4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.Scheduler;
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:     synchronized public Response pullMessage(ConnectionContext context, MessagePull pull) throws Exception {
0:     	// The slave should not deliver pull messages.  TODO: when the slave becomes a master,
0:     	// He should send a NULL message to all the consumers to 'wake them up' in case 
0:     	// they were waiting for a message.
0:         if (getPrefetchSize() == 0 && !isSlaveBroker()) {
0:             final long dispatchCounterBeforePull = dispatchCounter;
0:         	dispatchMatched();
1:         	
0:         	// If there was nothing dispatched.. we may need to setup a timeout.
0:         	if( dispatchCounterBeforePull == dispatchCounter ) {
0:         		// imediate timeout used by receiveNoWait()
0:         		if( pull.getTimeout() == -1 ) {
0:         			// Send a NULL message.
0: 	            	add(QueueMessageReference.NULL_MESSAGE);
0: 	            	dispatchMatched();
1:         		}
0:         		if( pull.getTimeout() > 0 ) {
0: 	            	Scheduler.executeAfterDelay(new Runnable(){
0: 							public void run() {
0: 								pullTimeout(dispatchCounterBeforePull);
1: 							}
0: 						}, pull.getTimeout());
1:         		}
1:         	}
1:     /**
0:      * Occurs when a pull times out.  If nothing has been dispatched
0:      * since the timeout was setup, then send the NULL message.
1:      */
0:     synchronized private void pullTimeout(long dispatchCounterBeforePull) {    	
0:     	if( dispatchCounterBeforePull == dispatchCounter ) {
0:         	try {
0: 				add(QueueMessageReference.NULL_MESSAGE);
0: 				dispatchMatched();
1: 			} catch (Exception e) {
1: 				context.getConnection().serviceException(e);
1: 			}
1:     	}
1: 	}
1:         
/////////////////////////////////////////////////////////////////////////
0:         	
0: 
0:             // NULL messages don't count... they don't get Acked.
0:             if( node != QueueMessageReference.NULL_MESSAGE ) {
0:         		dispatchCounter++;
0:         		dispatched.addLast(node);            
0:             } else {
0:             	prefetchExtension=Math.max(0,prefetchExtension-1);
1:             }
0:             
/////////////////////////////////////////////////////////////////////////
0:         	if( node != QueueMessageReference.NULL_MESSAGE ) {
0: 	            node.getRegionDestination().getDestinationStatistics().onMessageDequeue(message);
0: 	            context.getConnection().getStatistics().onMessageDequeue(message);
1:         	}
/////////////////////////////////////////////////////////////////////////
0:         if( node == QueueMessageReference.NULL_MESSAGE ) {
0:             MessageDispatch md = new MessageDispatch();
1:             md.setMessage(null);
0:             md.setConsumerId( info.getConsumerId() );
0:             md.setDestination( null );
0:             return md;
0:         } else {
0:             MessageDispatch md=new MessageDispatch();
0:             md.setConsumerId(info.getConsumerId());
0:             md.setDestination(node.getRegionDestination().getActiveMQDestination());
1:             md.setMessage(message);
1:             md.setRedeliveryCounter(node.getRedeliveryCounter());
0:             return md;
1:         }
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
0:  *
0:  * Licensed to the Apache Software Foundation (ASF) under one or more
0:  * contributor license agreements.  See the NOTICE file distributed with
0:  * this work for additional information regarding copyright ownership.
0:  * The ASF licenses this file to You under the Apache License, Version 2.0
0:  * (the "License"); you may not use this file except in compliance with
0:  * the License.  You may obtain a copy of the License at
0:  *
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
commit:c6e0984
/////////////////////////////////////////////////////////////////////////
0:     	/*
/////////////////////////////////////////////////////////////////////////
1:         */
commit:807e18f
/////////////////////////////////////////////////////////////////////////
0:         if(!isFull()){
0:                 if( pending.isEmpty() ) {
0:                     log.debug("Prefetch limit.");
1:                 }
0:     synchronized public void processMessageDispatchNotification(MessageDispatchNotification mdn) throws Exception {
0:                     createMessageDispatch(node,node.getMessage());
0:                     dispatched.addLast(node);
0:                     return;
0:             throw new JMSException("Slave broker out of sync with master: Dispatched message ("+mdn.getMessageId()+") was not in the pending list: "+pending);
/////////////////////////////////////////////////////////////////////////
0:         
0:         if( isSlaveBroker() ) {
0:         	throw new JMSException("Slave broker out of sync with master: Acknowledgment ("+ack+") was not in the dispatch list: "+dispatched);
0:         } else {
0:         	throw new JMSException("Invalid acknowledgment: "+ack);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Used to determine if the broker can dispatch to the consumer.
0:      * @return
1:      */
0:         return isSlaveBroker() || dispatched.size()-prefetchExtension>=info.getPrefetchSize();
commit:d65ba80
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         dispatchMatched();
/////////////////////////////////////////////////////////////////////////
0:                     dispatchMatched();
/////////////////////////////////////////////////////////////////////////
0:                         dispatchMatched();
/////////////////////////////////////////////////////////////////////////
0:     public int getPendingQueueSize(){
0:     	synchronized(pending) {
1:     		return pending.size();
1:     	}
/////////////////////////////////////////////////////////////////////////
0:             try{
0:                 dispatchMatched();
0:             }catch(IOException e){
0:                 context.getConnection().serviceException(e);
commit:c46562b
/////////////////////////////////////////////////////////////////////////
commit:18d616c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     sendToDLQ(context, node);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @param context
1:      * @param node
1:      * @throws IOException
1:      * @throws Exception
1:      */
0:     protected void sendToDLQ(final ConnectionContext context, final MessageReference node) throws IOException, Exception {
0:         // Send the message to the DLQ
0:         Message message=node.getMessage();
0:         if(message!=null){
0:             // The original destination and transaction id do not get filled when the message is first
0:             // sent,
0:             // it is only populated if the message is routed to another destination like the DLQ
0:             DeadLetterStrategy deadLetterStrategy=node.getRegionDestination().getDeadLetterStrategy();
0:             ActiveMQDestination deadLetterDestination=deadLetterStrategy.getDeadLetterQueueFor(message.getDestination());
0:             BrokerSupport.resend(context, message, deadLetterDestination);
0: 
1:         }
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     protected boolean dispatch(final MessageReference node) throws IOException{
1:             return false;
/////////////////////////////////////////////////////////////////////////
0:             return true;
0:         } else {
0:             return false;
0:     synchronized protected void onDispatch(final MessageReference node,final Message message){
commit:12cea50
/////////////////////////////////////////////////////////////////////////
commit:4757b27
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if( pending.isEmpty() )
0:                     log.info("Prefetch limit.");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: System.out.println("in range: "+messageId);
/////////////////////////////////////////////////////////////////////////
0:         return dispatched.size()-prefetchExtension>=info.getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5ff3487
/////////////////////////////////////////////////////////////////////////
0:     final protected LinkedList pending=new LinkedList();
0:     protected int prefetchExtension=0;
0:     long dequeueCounter;
/////////////////////////////////////////////////////////////////////////
0:             synchronized(pending){
0:                 pending.addLast(node);
0:         synchronized(pending){
0:             for(Iterator i=pending.iterator();i.hasNext();){
/////////////////////////////////////////////////////////////////////////
0:                     	dequeueCounter++;
0:                                 	dequeueCounter++;
0:                                     prefetchExtension--;
/////////////////////////////////////////////////////////////////////////
0:                             prefetchExtension=Math.max(prefetchExtension,index+1);
0:                             prefetchExtension=Math.max(0,prefetchExtension-(index+1));
/////////////////////////////////////////////////////////////////////////
0:                     prefetchExtension=Math.max(prefetchExtension,index+1);
/////////////////////////////////////////////////////////////////////////
0:                     dequeueCounter++;
0:                         prefetchExtension=Math.max(0,prefetchExtension-(index+1));
/////////////////////////////////////////////////////////////////////////
0:         return dispatched.size()-prefetchExtension>=info.getPrefetchSize()||preLoadSize>preLoadLimit;
0:         return pending.size();
/////////////////////////////////////////////////////////////////////////
0:         return dequeueCounter;
/////////////////////////////////////////////////////////////////////////
0:                 for(Iterator iter=pending.iterator();iter.hasNext()&&!isFull();){
commit:07d4e8c
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.util.Iterator;
0: import java.util.LinkedList;
0: 
0: import javax.jms.InvalidSelectorException;
1: import javax.jms.JMSException;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     long aknowledgedCounter;
/////////////////////////////////////////////////////////////////////////
0:                     	aknowledgedCounter++;
0:                                 	aknowledgedCounter++;
/////////////////////////////////////////////////////////////////////////
0:                     aknowledgedCounter++;
/////////////////////////////////////////////////////////////////////////
0:     synchronized public int getPendingQueueSize(){
0:         return matched.size();
0:     synchronized public int getDispatchedQueueSize(){
0:     synchronized public long getDequeueCounter(){
0:         return aknowledgedCounter;
0:     
0:     synchronized public long getDispatchedCounter() {
0:         return dispatchCounter;
1:     }
0:     
0:     synchronized public long getEnqueueCounter() {
0:         return enqueueCounter;
1:     }
0: 
/////////////////////////////////////////////////////////////////////////
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void add(MessageReference node) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception{
/////////////////////////////////////////////////////////////////////////
0:                             public void afterCommit() throws Exception{
commit:ed5d43b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.BrokerSupport;
/////////////////////////////////////////////////////////////////////////
0:                             ActiveMQDestination deadLetterDestination=deadLetterStrategy.getDeadLetterQueueFor(message.getDestination());
0:                             BrokerSupport.resend(context, message, deadLetterDestination);
0: 
commit:acce91b
/////////////////////////////////////////////////////////////////////////
0:                                     dispatched.remove(node);
0:                                     delivered--;
commit:0f502fa
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:     
0:     long enqueueCounter;
0:     long dispatchCounter;
0:     
0:         enqueueCounter++;
/////////////////////////////////////////////////////////////////////////
0:             dispatchCounter++;
0:             dispatched.addLast(node);            
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     public long getDispatchCounter() {
0:         return dispatchCounter;
0:     }
0: 
1:     public long getEnqueueCounter() {
0:         return enqueueCounter;
0:     }
commit:013f372
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
/////////////////////////////////////////////////////////////////////////
0:     static private final Log log = LogFactory.getLog(PrefetchSubscription.class);
commit:61ab31e
/////////////////////////////////////////////////////////////////////////
1:             // TODO: what if the message is already in a DLQ???
0:             
/////////////////////////////////////////////////////////////////////////
0:                             // The original destination and transaction id do not get filled when the message is first sent,
0:                             // it is only populated if the message is routed to another destination like the DLQ
0:                             
0:                             DeadLetterStrategy deadLetterStrategy = node.getRegionDestination().getDeadLetterStrategy();
0:                             ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(message.getDestination());
0:                             message.setDestination(deadLetterDestination);
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.region;
0: 
0: import java.io.IOException;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: 
0: import javax.jms.InvalidSelectorException;
0: import javax.jms.JMSException;
0: 
1: import org.apache.activemq.broker.ConnectionContext;
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQQueue;
1: import org.apache.activemq.command.ConsumerInfo;
1: import org.apache.activemq.command.Message;
1: import org.apache.activemq.command.MessageAck;
1: import org.apache.activemq.command.MessageDispatch;
1: import org.apache.activemq.command.MessageId;
1: import org.apache.activemq.transaction.Synchronization;
0: 
1: /**
1:  * A subscription that honors the pre-fetch option of the ConsumerInfo.
0:  * 
0:  * @version $Revision: 1.15 $
1:  */
0: abstract public class PrefetchSubscription extends AbstractSubscription {
0:     
0:     final protected LinkedList matched = new LinkedList();
0:     final protected LinkedList dispatched = new LinkedList();
0:     
0:     final protected ActiveMQDestination dlqDestination = new ActiveMQQueue("ActiveMQ.DLQ");
0:     protected int delivered=0;
0:     
0:     int preLoadLimit=1024*100;
0:     int preLoadSize=0;
0:     boolean dispatching=false;
0:     
0:     public PrefetchSubscription(ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         super(context, info);
0:     }
0: 
0:     synchronized public void add(MessageReference node) throws Throwable {
0:         if( !isFull() ) {
0:             dispatch(node);
0:         } else {
0:             matched.addLast(node);
0:         }
0:     }
0:     
0:     synchronized public void acknowledge(final ConnectionContext context, final MessageAck ack) throws Throwable {
0:         
1:         // Handle the standard acknowledgment case.
0:         boolean wasFull = isFull();
0:         if( ack.isStandardAck() ) {
0:                         
0:             // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:             int index=0;
0:             boolean inAckRange=false;
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:                 final MessageReference node = (MessageReference)iter.next();
1:                 MessageId messageId = node.getMessageId();
0:                 
0:                 if( ack.getFirstMessageId()==null || ack.getFirstMessageId().equals(messageId)) {
0:                     inAckRange = true;
0:                 }
0:                 
0:                 if( inAckRange ) {
0:                 
0:                     // Don't remove the nodes until we are committed.
0:                     if ( !context.isInTransaction() ) {
0:                         iter.remove();
0:                     } else {
0:                         // setup a Synchronization to remove nodes from the dispatched list.
0:                         context.getTransaction().addSynchronization(new Synchronization(){
0:                             public void afterCommit() throws Throwable {
0:                                 synchronized(PrefetchSubscription.this) {
0:                                     
0:                                     // Now that we are committed, we can remove the nodes.
0:                                     boolean inAckRange=false;
0:                                     int index=0;
0:                                     for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:                                         final MessageReference node = (MessageReference)iter.next();
1:                                         MessageId messageId = node.getMessageId();
0:                                         if( ack.getFirstMessageId()==null || ack.getFirstMessageId().equals(messageId)) {
0:                                             inAckRange = true;
0:                                         }
0:                                         if( inAckRange ) {
1:                                             index++;
0:                                             iter.remove();
0:                                             if( ack.getLastMessageId().equals(messageId)) {
0:                                                 delivered = Math.max(0, delivered - (index+1));
0:                                                 return;
0:                                             }
0:                                         }
0:                                     }
0:                                     
0:                                 }
0:                             }
0:                         });                        
0:                     }
0:                     
1:                     index++;
0:                     acknowledge(context, ack, node);
0:                     if( ack.getLastMessageId().equals(messageId)) {                        
0:                         if ( context.isInTransaction() )
0:                             delivered = Math.max(delivered,index+1);
0:                         else 
0:                             delivered = Math.max(0, delivered - (index+1));
0:                         
0:                         if( wasFull && !isFull() ) {                            
0:                             dispatchMatched();
0:                         }
0:                         return;
0:                     } else {
0: //                        System.out.println("no match: "+ack.getLastMessageId()+","+messageId);
0:                     }
0:                 }
0:                 
0:             }
0:             log.info("Could not correlate acknowledgment with dispatched message: "+ack);
0:             
0:         } else if( ack.isDeliveredAck() ) {
0:             
0:             // Message was delivered but not acknowledged: update pre-fetch counters.
0:             // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:             int index=0;
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext();index++) {
0:                 final MessageReference node = (MessageReference)iter.next();
0:                 if( ack.getLastMessageId().equals(node.getMessageId()) ) {
0:                     delivered = Math.max(delivered,index+1);
0:                     if( wasFull && !isFull() ) {
0:                         dispatchMatched();
0:                     }
0:                     return;
0:                 }
0:             }
0:             throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
0:             
0:         } else if( ack.isPoisonAck() ) {
0:             
0:             // Handle the poison ACK case: we need to send the message to a DLQ  
0:             if( ack.isInTransaction() )
0:                 throw new JMSException("Poison ack cannot be transacted: "+ack);
0:             
0:             // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:             int index=0;
0:             boolean inAckRange=false;
0:             for (Iterator iter = dispatched.iterator(); iter.hasNext();) {
0:                 final MessageReference node = (MessageReference)iter.next();
1:                 MessageId messageId = node.getMessageId();
0:                 
0:                 if( ack.getFirstMessageId()==null || ack.getFirstMessageId().equals(messageId)) {
0:                     inAckRange = true;
0:                 }
0:                 
0:                 if( inAckRange ) {
0:                 
0:                     // Send the message to the DLQ
0:                     node.incrementReferenceCount();
0:                     try {
0:                         Message message = node.getMessage();
0:                         if( message !=null ) {
0:                             
0:                             if( message.getOriginalDestination()!=null )
0:                                 message.setOriginalDestination(message.getDestination());
0:                             message.setDestination(dlqDestination);
0:                             
0:                             if( message.getOriginalTransactionId()!=null )
0:                                 message.setOriginalTransactionId(message.getTransactionId());
0:                             message.setTransactionId(null);
0:                             message.evictMarshlledForm();
0: 
0:                             boolean originalFlowControl = context.isProducerFlowControl();
0:                             try {
0:                                 context.setProducerFlowControl(false);
0:                                 context.getBroker().send(context, message);
0:                             } finally {
0:                                 context.setProducerFlowControl(originalFlowControl);
0:                             }
0: 
0:                         }                        
0:                     } finally {
0:                         node.decrementReferenceCount();
0:                     }
0:                     
0:                     iter.remove();
1:                     index++;
0:                     acknowledge(context, ack, node);
0:                     if( ack.getLastMessageId().equals(messageId)) {
0:                         
0:                         delivered = Math.max(0, delivered - (index+1));
0:                         
0:                         if( wasFull && !isFull() ) {                            
0:                             dispatchMatched();
0:                         }
0:                         return;
0:                     }
0:                 }
0:             }
0:             throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
0:         }
0: 
0:         throw new JMSException("Invalid acknowledgment: "+ack);
0:     }
0:     
0:     protected boolean isFull() {
0:         return dispatched.size()-delivered >= info.getPrefetchSize() || preLoadSize > preLoadLimit;
0:     }
0:     
0:     protected void dispatchMatched() throws IOException {
0:         if(!dispatching) {
0:             dispatching = true;
0:             try {
0:                 for (Iterator iter = matched.iterator(); iter.hasNext() && !isFull();) {
0:                     MessageReference node = (MessageReference) iter.next();
0:                     iter.remove();
0:                     dispatch(node);
0:                 }
0:             } finally {
0:                 dispatching=false;
0:             }
0:         }
0:     }
0: 
0:     private void dispatch(final MessageReference node) throws IOException {
0:         node.incrementReferenceCount();
0:         
0:         final Message message = node.getMessage();
0:         if( message == null ) {
0:             return;
0:         }       
0:         
0:         // Make sure we can dispatch a message.
0:         if( canDispatch(node) ) {
0: 
0:             MessageDispatch md = createMessageDispatch(node, message);
0:             dispatched.addLast(node);
0:             
0:             incrementPreloadSize(node.getMessage().getSize()); 
0:             
0:             if( info.isDispatchAsync() ) {
0:                 md.setConsumer(new Runnable(){
0:                     public void run() {
0:                         // Since the message gets queued up in async dispatch, we don't want to 
0:                         // decrease the reference count until it gets put on the wire.
0:                         onDispatch(node, message);
0:                     }
0:                 });
0:                 context.getConnection().dispatchAsync(md);
0:             } else {
0:                 context.getConnection().dispatchSync(md);
0:                 onDispatch(node, message);
0:             }
0:             // The onDispatch() does the node.decrementReferenceCount();
0:         } else {
0:             // We were not allowed to dispatch that message (an other consumer grabbed it before we did)
0:             node.decrementReferenceCount();
0:         }
0:         
0:     }
0: 
0:     synchronized private void onDispatch(final MessageReference node, final Message message) {
0:         
0:         boolean wasFull = isFull();
0:         decrementPreloadSize(message.getSize());        
0:         node.decrementReferenceCount();
0:         
0:         if( node.getRegionDestination() !=null ) {
0:             node.getRegionDestination().getDestinationStatistics().onMessageDequeue(message);
0:             context.getConnection().getStatistics().onMessageDequeue(message);
0:             
0:             if( wasFull && !isFull() ) {                            
0:                 try {
0:                     dispatchMatched();
0:                 } catch (IOException e) {
0:                     context.getConnection().serviceException(e);
0:                 }
0:             }
0:         }
0:         
0:     }
0:     
0:     private int incrementPreloadSize(int size) {
0:         preLoadSize += size;
0:         return preLoadSize;
0:     }
0:     
0:     private int decrementPreloadSize(int size) {
0:         preLoadSize -= size;
0:         return preLoadSize;
0:     }
0:     
0: 
1:     /**
1:      * @param node
0:      * @param message TODO
0:      * @return
1:      */
0:     protected MessageDispatch createMessageDispatch(MessageReference node, Message message) {
0:         MessageDispatch md = new MessageDispatch();
0:         md.setConsumerId( info.getConsumerId() );
0:         md.setDestination( node.getRegionDestination().getActiveMQDestination() );
0:         md.setMessage(message);
0:         md.setRedeliveryCounter( node.getRedeliveryCounter() );
0:         return md;
0:     }
0:     
1:     /**
1:      * Use when a matched message is about to be dispatched to the client.
0:      * 
1:      * @param node
0:      * @return false if the message should not be dispatched to the client (another sub may have already dispatched it for example).
1:      */
0:     abstract protected boolean canDispatch(MessageReference node);
0:     
1:     /**
1:      * Used during acknowledgment to remove the message.
1:      * @throws IOException 
1:      */
0:     protected void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException {        
0:     }
0: 
0: 
0: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:915333e
/////////////////////////////////////////////////////////////////////////
1:     public PrefetchSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, PendingMessageCursor cursor) throws JMSException {
0:         try {
1:             pending.start();
0:         } catch (Exception e) {
1:             throw new JMSException(e.getMessage());
0:         }
1:     public PrefetchSubscription(Broker broker,SystemUsage usageManager, ConnectionContext context, ConsumerInfo info) throws JMSException {
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(PrefetchSubscription.class);
commit:5773796
/////////////////////////////////////////////////////////////////////////
0:                     LOG.trace(info.getConsumerId() + " dispatched: " + message.getMessageId() + " - "
0:                             + message.getDestination()  + ", dispatched: " + dispatchCounter + ", inflight: " + dispatched.size());
commit:3a2d939
/////////////////////////////////////////////////////////////////////////
0:                 ArrayList<MessageReference> references = new ArrayList<MessageReference>();
0:                         references.add(r);
0:                 rc.addAll(references);
0:                 destination.getDestinationStatistics().getDispatched().subtract(references.size());
0:                 destination.getDestinationStatistics().getInflight().subtract(references.size());
0:                 dispatched.removeAll(references);
commit:b0f24f3
/////////////////////////////////////////////////////////////////////////
commit:d89abe0
/////////////////////////////////////////////////////////////////////////
1:     	synchronized (pendingLock) {
0:     		if (dispatchCounterBeforePull == dispatchCounter) {
commit:bbdedea
/////////////////////////////////////////////////////////////////////////
0: 	                // immediate timeout used by receiveNoWait()
/////////////////////////////////////////////////////////////////////////
0:     final void pullTimeout(long dispatchCounterBeforePull) {
0:             synchronized (pendingLock) {
0:                 try {
0:                     add(QueueMessageReference.NULL_MESSAGE);
1:                     dispatchPending();
0:                 } catch (Exception e) {
0:                     context.getConnection().serviceException(e);
0:                 }
commit:d8bdf5b
/////////////////////////////////////////////////////////////////////////
0:                                             prefetchExtension, index );
0:                                         prefetchExtension - index);
author:Robert Davies
-------------------------------------------------------------------------------
commit:00879cf
/////////////////////////////////////////////////////////////////////////
1:         this(broker,usageManager,context, info, new VMPendingMessageCursor(false));
commit:69e3b6c
/////////////////////////////////////////////////////////////////////////
0:         broker.getRoot().sendToDeadLetterQueue(context, node);
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected final Scheduler scheduler;
/////////////////////////////////////////////////////////////////////////
1:     private final CountDownLatch okForAckAsDispatchDone = new CountDownLatch(1);
1:         this.scheduler = broker.getScheduler();
/////////////////////////////////////////////////////////////////////////
1:                                         @Override
/////////////////////////////////////////////////////////////////////////
1:                                         @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:    @Override
0: public void add(ConnectionContext context, Destination destination) throws Exception {
0:     @Override
/////////////////////////////////////////////////////////////////////////
0: 	                	rc.add(r);
commit:785454a
/////////////////////////////////////////////////////////////////////////
1:             this.pending.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());
commit:9ce91fa
/////////////////////////////////////////////////////////////////////////
0:             	// First check if the ack matches the dispatched. When using failover this might
0:             	// not be the case. We don't ever want to ack the wrong messages.
0:             	assertAckMatchesDispatched(ack);
0:             	
1:                 // the acknowledgment.
/////////////////////////////////////////////////////////////////////////
0:                         LOG.error("Could not correlate acknowledgment with dispatched message: "
1:                                   + ack);
/////////////////////////////////////////////////////////////////////////
1:      * Checks an ack versus the contents of the dispatched list.
0:      * 
1:      * @param ack
0:      * @param firstAckedMsg
0:      * @param lastAckedMsg
1:      * @throws JMSException if it does not match
1:      */
0: 	protected void assertAckMatchesDispatched(MessageAck ack)
0: 			throws JMSException {
1:         MessageId firstAckedMsg = ack.getFirstMessageId();
0: 		MessageId lastAckedMsg = ack.getLastMessageId();
0: 
0: 		int checkCount = 0;
0: 		boolean checkFoundStart = false;
0: 		boolean checkFoundEnd = false;
0: 		for (MessageReference node : dispatched) {
0: 			if (!checkFoundStart && firstAckedMsg != null && firstAckedMsg.equals(node.getMessageId())) {
0: 				checkFoundStart = true;
0: 			}
0: 
0: 			if (checkFoundStart || firstAckedMsg == null)
0: 				checkCount++;
0: 
0: 			if (lastAckedMsg != null && lastAckedMsg.equals(node.getMessageId())) {
0: 				checkFoundEnd = true;
0: 				break;
0: 			}
0: 		}
0: 		if (!checkFoundStart && firstAckedMsg != null)
0: 			throw new JMSException("Unmatched acknowledege: Could not find Message-ID "+firstAckedMsg+" in dispatched-list (start of ack)");
0: 		if (!checkFoundEnd && lastAckedMsg != null)
0: 			throw new JMSException("Unmatched acknowledege: Could not find Message-ID "+firstAckedMsg+" in dispatched-list (end of ack)");
0: 		if (ack.getMessageCount() != checkCount) {
0: 			throw new JMSException("Unmatched acknowledege: Expected message count ("+ack.getMessageCount()+
0: 					") differs from count in dispatched-list ("+checkCount+")");
0: 		}
0: 	}
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:         return isSlave() || dispatched.size() - prefetchExtension >= info.getPrefetchSize();
commit:ba740dc
/////////////////////////////////////////////////////////////////////////
0:                             if (!this.getConsumerInfo().isBrowser()) {
commit:c6c4e5e
/////////////////////////////////////////////////////////////////////////
0:                             if (this.getConsumerInfo().isBrowser()) {
0:                                 node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                             }
commit:ec3d9ad
/////////////////////////////////////////////////////////////////////////
0: 
0:                                                 node
0:                                                         .getRegionDestination()
0:                                                         .getDestinationStatistics()
0:                                                         .getInflight()
0:                                                         .decrement();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:                         node.getRegionDestination().getDestinationStatistics()
0:                                 .getInflight().increment();
0: 
commit:e2cafda
/////////////////////////////////////////////////////////////////////////
0: //            if (destination.isLazyDispatch()) {
0: //            }
commit:3f4d4a5
/////////////////////////////////////////////////////////////////////////
0:                             if (!isSlave()) {
0:                                 node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
0:                             }
commit:0d85869
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:cdc2fd3
/////////////////////////////////////////////////////////////////////////
0:     private boolean slowConsumer;
/////////////////////////////////////////////////////////////////////////
0:                         slowConsumer=false;
/////////////////////////////////////////////////////////////////////////
0:                     }else {
0:                         if (!slowConsumer) {
0:                             slowConsumer=true;
0:                             ConnectionContext c = new ConnectionContext();
0:                             c.setBroker(context.getBroker());
0:                             for (Destination dest :destinations) {
0:                                 dest.slowConsumer(c,this);
0:                             }
0:                             
0:                         }
commit:ab3b155
/////////////////////////////////////////////////////////////////////////
1:             } else if (ack.isIndividualAck()) {
1:                 // Message was delivered and acknowledge - but only delete the
1:                 // individual message
1:                 for (final MessageReference node : dispatched) {
0:                     MessageId messageId = node.getMessageId();
0:                     if (ack.getLastMessageId().equals(messageId)) {
0:                         // this should never be within a transaction
0:                         node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                         node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
0:                         destination = node.getRegionDestination();
0:                         acknowledge(context, ack, node);
0:                         dispatched.remove(node);
0:                         prefetchExtension = Math.max(0, prefetchExtension - 1);
1:                         callDispatchMatched = true;
0:                         break;
0:                     }
0:                 }
0:             }else if (ack.isDeliveredAck()) {
commit:16f2d75
/////////////////////////////////////////////////////////////////////////
0:     public PrefetchSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, PendingMessageCursor cursor) throws InvalidSelectorException {
1:         super(broker,context, info);
0:     public PrefetchSubscription(Broker broker,SystemUsage usageManager, ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         this(broker,usageManager,context, info, new VMPendingMessageCursor());
/////////////////////////////////////////////////////////////////////////
1:     public final void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception {
1:         Destination destination = null;
/////////////////////////////////////////////////////////////////////////
0:                             destination = node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
0:                         destination = node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
0:                             destination = node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
0:                             destination = node.getRegionDestination();
/////////////////////////////////////////////////////////////////////////
0:         if (callDispatchMatched && destination != null) {
commit:dc4f299
/////////////////////////////////////////////////////////////////////////
commit:044c07d
/////////////////////////////////////////////////////////////////////////
0:     public PrefetchSubscription(Broker broker,Destination destination, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, PendingMessageCursor cursor) throws InvalidSelectorException {
0:         super(broker,destination, context, info);
0:     public PrefetchSubscription(Broker broker,Destination destination, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         this(broker,destination,usageManager,context, info, new VMPendingMessageCursor());
/////////////////////////////////////////////////////////////////////////
0:             if (destination.isLazyDispatch()) {
0:                 destination.wakeup();
0:             }
commit:2a153b0
/////////////////////////////////////////////////////////////////////////
0:                             node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                             node.getRegionDestination().getDestinationStatistics().getInflight().decrement();
/////////////////////////////////////////////////////////////////////////
0:                 node.getRegionDestination().getDestinationStatistics().getInflight().increment();
/////////////////////////////////////////////////////////////////////////
1:     protected abstract void acknowledge(ConnectionContext context, final MessageAck ack, final MessageReference node) throws IOException;
commit:d4382e4
/////////////////////////////////////////////////////////////////////////
0:     
1:     public int getInFlightSize() {
1:         return dispatched.size();
0:     }
0:     
1:     public boolean isFull() {
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0:     public List<MessageReference> getInFlightMessages(){
0:         List<MessageReference> result = new ArrayList<MessageReference>();
1:         synchronized(pendingLock) {
0:             result.addAll(dispatched);
0:             result.addAll(pending.pageInList(1000));
0:         }
0:         return result;
0:     }
commit:149428b
/////////////////////////////////////////////////////////////////////////
0:                             if(isDropped(node)) {
0:                                 pending.remove();
0:                             }
0:                             else if (canDispatch(node)) {
/////////////////////////////////////////////////////////////////////////
0:     
1:     protected abstract boolean isDropped(MessageReference node);
commit:f81d0d5
/////////////////////////////////////////////////////////////////////////
0:             pending.addMessageLast(node);    
1:         dispatchPending();
commit:071b4b1
/////////////////////////////////////////////////////////////////////////
0:     protected ActiveMQMessageAudit audit = new ActiveMQMessageAudit();
/////////////////////////////////////////////////////////////////////////
0:         synchronized (pendingLock) {
0:             enqueueCounter++;
0:             pending.addMessageLast(node);
0:             dispatchPending();
0:         }
0:        
0:     }
/////////////////////////////////////////////////////////////////////////
0:    public void add(ConnectionContext context, Destination destination) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:                                 // list a while waiting for the consumer to ak the message.
0:                                         && node.isExpired()) {
0:                                     //increment number to dispatch
0:                                     numberToDispatch++;
/////////////////////////////////////////////////////////////////////////
0:             
/////////////////////////////////////////////////////////////////////////
0:     
commit:b8674d4
/////////////////////////////////////////////////////////////////////////
0:     protected boolean optimizedDispatch=false;
commit:55810b3
/////////////////////////////////////////////////////////////////////////
0: 		boolean pendingEmpty = false;
0: 		boolean dispatchPending = false;
0: 		synchronized (pendingLock) {
0: 			pendingEmpty = pending.isEmpty();
0: 			enqueueCounter++;
0: 			if (optimizedDispatch && !isFull() && pendingEmpty && !isSlave()) {
0: 				pending.dispatched(node);
0: 				dispatch(node);
0: 			} else {
0: 				optimizePrefetch();
0: 				synchronized (pendingLock) {
0: 					if (pending.isEmpty() && LOG.isDebugEnabled()) {
0: 						LOG.debug("Prefetch limit.");
0: 					}
0: 					pending.addMessageLast(node);
0: 					dispatchPending = true;
0: 				}
0: 			}
0: 		}
0: 		if (dispatchPending) {
0: 			dispatchPending();
0: 		}
0: 	}
/////////////////////////////////////////////////////////////////////////
0:         }         
/////////////////////////////////////////////////////////////////////////
commit:2db7df7
/////////////////////////////////////////////////////////////////////////
0:     private final Object pendingLock = new Object();
0:     private final Object dispatchLock = new Object();
/////////////////////////////////////////////////////////////////////////
0:             dispatchPending();
0:                     dispatchPending();
/////////////////////////////////////////////////////////////////////////
0:                 dispatchPending();
1:     public void add(MessageReference node) throws Exception {
1:         synchronized(pendingLock) {
0:             pendingEmpty = pending.isEmpty();
0:         }
1:             synchronized(pendingLock) {
0:                
0:             dispatchPending();
1:     public void processMessageDispatchNotification(MessageDispatchNotification mdn) throws Exception {
1:         synchronized(pendingLock) {
0:             try {
1:                 pending.reset();
0:                 while (pending.hasNext()) {
0:                     MessageReference node = pending.next();
0:                     if (node.getMessageId().equals(mdn.getMessageId())) {
0:                         pending.remove();
0:                         createMessageDispatch(node, node.getMessage());
0:                         synchronized(dispatchLock) {
1:                             dispatched.add(node);
0:                         }
0:                         return;
0:                     }
0:             } finally {
1:                 pending.release();
1:         throw new JMSException(
1:                 "Slave broker out of sync with master: Dispatched message ("
0:                         + mdn.getMessageId() + ") was not in the pending list");
0:     public  void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception {
0:         synchronized(dispatchLock) {
0:             if (ack.isStandardAck()) {
1:                 // Acknowledge all dispatched messages up till the message id of
0:                 // the
0:                 // acknowledgment.
0:                 int index = 0;
0:                 boolean inAckRange = false;
1:                 List<MessageReference> removeList = new ArrayList<MessageReference>();
1:                 for (final MessageReference node : dispatched) {
0:                     MessageId messageId = node.getMessageId();
1:                     if (ack.getFirstMessageId() == null
1:                             || ack.getFirstMessageId().equals(messageId)) {
0:                         inAckRange = true;
0:                     }
0:                     if (inAckRange) {
0:                         // Don't remove the nodes until we are committed.
0:                         if (!context.isInTransaction()) {
0:                             dequeueCounter++;
0:                             node.getRegionDestination()
0:                                     .getDestinationStatistics().getDequeues()
0:                                     .increment();
0:                             removeList.add(node);
0:                         } else {
0:                             // setup a Synchronization to remove nodes from the
0:                             // dispatched list.
0:                             context.getTransaction().addSynchronization(
0:                                     new Synchronization() {
0: 
0:                                         public void afterCommit()
0:                                                 throws Exception {
0:                                             synchronized(dispatchLock) {
0:                                             
0:                                                 dequeueCounter++;
0:                                                 dispatched.remove(node);
0:                                                 node
0:                                                         .getRegionDestination()
0:                                                         .getDestinationStatistics()
0:                                                         .getDequeues()
0:                                                         .increment();
0:                                                 prefetchExtension--;
0:                                             }
0:                                         }
0: 
0:                                         public void afterRollback()
0:                                                 throws Exception {
0:                                             super.afterRollback();
0:                                         }
0:                                     });
0:                         }
0:                         index++;
0:                         acknowledge(context, ack, node);
0:                         if (ack.getLastMessageId().equals(messageId)) {
0:                             if (context.isInTransaction()) {
0:                                 // extend prefetch window only if not a pulling
0:                                 // consumer
0:                                 if (getPrefetchSize() != 0) {
0:                                     prefetchExtension = Math.max(
0:                                             prefetchExtension, index + 1);
0:                                 }
0:                             } else {
0:                                 prefetchExtension = Math.max(0,
0:                                         prefetchExtension - (index + 1));
0:                             }
0:                             callDispatchMatched = true;
0:                             break;
0:                         }
0:                     }
1:                 for (final MessageReference node : removeList) {
0:                     dispatched.remove(node);
0:                 }
0:                 // this only happens after a reconnect - get an ack which is not
0:                 // valid
0:                 if (!callDispatchMatched) {
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG
0:                                 .debug("Could not correlate acknowledgment with dispatched message: "
1:                                         + ack);
0:                     }
0:                 }
0:             } else if (ack.isDeliveredAck()) {
0:                 // Message was delivered but not acknowledged: update pre-fetch
0:                 // counters.
1:                 // Acknowledge all dispatched messages up till the message id of
0:                 // the
0:                 // acknowledgment.
0:                 int index = 0;
0:                 for (Iterator<MessageReference> iter = dispatched.iterator(); iter
0:                         .hasNext(); index++) {
0:                     final MessageReference node = iter.next();
0:                     if (ack.getLastMessageId().equals(node.getMessageId())) {
0:                         prefetchExtension = Math.max(prefetchExtension,
0:                                 index + 1);
0:                         callDispatchMatched = true;
0:                         break;
0:                     }
0:                 }
0:                 if (!callDispatchMatched) {
1:                     throw new JMSException(
1:                             "Could not correlate acknowledgment with dispatched message: "
1:                                     + ack);
0:                 }
1:             } else if (ack.isRedeliveredAck()) {
1:                 // Message was re-delivered but it was not yet considered to be
0:                 // a
0:                 // DLQ message.
1:                 // Acknowledge all dispatched messages up till the message id of
0:                 // the
0:                 // acknowledgment.
0:                 boolean inAckRange = false;
1:                 for (final MessageReference node : dispatched) {
0:                     MessageId messageId = node.getMessageId();
1:                     if (ack.getFirstMessageId() == null
1:                             || ack.getFirstMessageId().equals(messageId)) {
0:                         inAckRange = true;
0:                     }
0:                     if (inAckRange) {
0:                         node.incrementRedeliveryCounter();
0:                         if (ack.getLastMessageId().equals(messageId)) {
0:                             callDispatchMatched = true;
0:                             break;
0:                         }
0:                     }
0:                 }
0:                 if (!callDispatchMatched) {
1:                     throw new JMSException(
1:                             "Could not correlate acknowledgment with dispatched message: "
1:                                     + ack);
0:                 }
0:             } else if (ack.isPoisonAck()) {
0:                 // TODO: what if the message is already in a DLQ???
1:                 // Handle the poison ACK case: we need to send the message to a
1:                 // DLQ
0:                 if (ack.isInTransaction()) {
1:                     throw new JMSException("Poison ack cannot be transacted: "
1:                             + ack);
0:                 }
1:                 // Acknowledge all dispatched messages up till the message id of
0:                 // the
0:                 // acknowledgment.
0:                 int index = 0;
0:                 boolean inAckRange = false;
1:                 List<MessageReference> removeList = new ArrayList<MessageReference>();
1:                 for (final MessageReference node : dispatched) {
0:                     MessageId messageId = node.getMessageId();
1:                     if (ack.getFirstMessageId() == null
1:                             || ack.getFirstMessageId().equals(messageId)) {
0:                         inAckRange = true;
0:                     }
0:                     if (inAckRange) {
0:                         sendToDLQ(context, node);
0:                         dequeueCounter++;
0:                         index++;
0:                         acknowledge(context, ack, node);
0:                         if (ack.getLastMessageId().equals(messageId)) {
0:                             callDispatchMatched = true;
0:                             break;
1:                 for (final MessageReference node : removeList) {
0:                     dispatched.remove(node);
0:                 }
0:                 if (!callDispatchMatched) {
1:                     throw new JMSException(
1:                             "Could not correlate acknowledgment with dispatched message: "
0:             dispatchPending();
/////////////////////////////////////////////////////////////////////////
0:     protected boolean isFull() {
1:     public boolean isLowWaterMark() {
1:     public boolean isHighWaterMark() {
1:     public int countBeforeFull() {
1:     public int getPendingQueueSize() {
1:     public int getDispatchedQueueSize() {
1:     public long getDequeueCounter() {
1:     public long getDispatchedCounter() {
0:     public long getEnqueueCounter() {
/////////////////////////////////////////////////////////////////////////
1:     public PendingMessageCursor getPending() {
1:     public void setPending(PendingMessageCursor pending) {
/////////////////////////////////////////////////////////////////////////
0:     public void add(ConnectionContext context, Destination destination) throws Exception {
0:         synchronized(pendingLock) {
0:             super.add(context, destination);
0:             pending.add(context, destination);
0:         }
0:     public void remove(ConnectionContext context, Destination destination) throws Exception {
0:         synchronized(pendingLock) {
0:             super.remove(context, destination);
0:             pending.remove(context, destination);
0:         }
0:     protected void dispatchPending() throws IOException {
0:            synchronized(pendingLock) {
0:                 try {
0:                     int numberToDispatch = countBeforeFull();
0:                     if (numberToDispatch > 0) {
0:                         pending.setMaxBatchSize(numberToDispatch);
0:                         int count = 0;
0:                         pending.reset();
0:                         while (pending.hasNext() && !isFull()
0:                                 && count < numberToDispatch) {
0:                             MessageReference node = pending.next();
0:                             if (node == null) {
0:                                 break;
0:                             if (canDispatch(node)) {
0:                                 pending.remove();
0:                                 // Message may have been sitting in the pending
0:                                 // list
0:                                 // a while
0:                                 // waiting for the consumer to ak the message.
0:                                 if (node != QueueMessageReference.NULL_MESSAGE
0:                                         && broker.isExpired(node)) {
0:                                     broker.messageExpired(getContext(), node);
0:                                     dequeueCounter++;
0:                                     continue;
0:                                 }
0:                                 dispatch(node);
0:                                 count++;
0:                             }
0:                 } finally {
0:                     pending.release();
1:     protected boolean dispatch(final MessageReference node) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:                    synchronized(pendingLock) {
0:                         pending.dispatched(message);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                 dispatchPending();
commit:f472000
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
0: import java.util.concurrent.CopyOnWriteArrayList;
/////////////////////////////////////////////////////////////////////////
0:     protected final List<MessageReference> dispatched = new CopyOnWriteArrayList<MessageReference>();
0:     protected boolean optimizedDispatch=true;
/////////////////////////////////////////////////////////////////////////
0:                     dispatched.add(node);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void acknowledge(final ConnectionContext context,
0:             final MessageAck ack) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:             List<MessageReference> removeList = new ArrayList<MessageReference>();
0:             for (final MessageReference node : dispatched) {
0:                 if (ack.getFirstMessageId() == null
0:                         || ack.getFirstMessageId().equals(messageId)) {
0:                         node.getRegionDestination().getDestinationStatistics()
0:                                 .getDequeues().increment();
0:                         removeList.add(node);
0:                         context.getTransaction().addSynchronization(
0:                                 new Synchronization() {
0:                                     public void afterCommit() throws Exception {
0:                                         synchronized (PrefetchSubscription.this) {
0:                                             dequeueCounter++;
0:                                             dispatched.remove(node);
0:                                             node.getRegionDestination()
0:                                                     .getDestinationStatistics()
0:                                                     .getDequeues().increment();
0:                                             prefetchExtension--;
0:                                         }
0:                                     }
0:                                     public void afterRollback()
0:                                             throws Exception {
0:                                         super.afterRollback();
0:                                     }
0:                                 });
/////////////////////////////////////////////////////////////////////////
0:                                 prefetchExtension = Math.max(prefetchExtension,
0:                                         index + 1);
0:                             prefetchExtension = Math.max(0, prefetchExtension
0:                                     - (index + 1));
0:             for (final MessageReference node : removeList) {
0:                 dispatched.remove(node);
0:             }
0:                     LOG
0:                             .debug("Could not correlate acknowledgment with dispatched message: "
0:                                     + ack);
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<MessageReference> iter = dispatched.iterator(); iter
0:                     .hasNext(); index++) {
/////////////////////////////////////////////////////////////////////////
0:                 throw new JMSException(
0:                         "Could not correlate acknowledgment with dispatched message: "
0:                                 + ack);
0:         } else if (ack.isRedeliveredAck()) {
0:             // Message was re-delivered but it was not yet considered to be a
0:             // DLQ message.
0:             for (final MessageReference node : dispatched) {
0:                 if (ack.getFirstMessageId() == null
0:                         || ack.getFirstMessageId().equals(messageId)) {
/////////////////////////////////////////////////////////////////////////
0:                 throw new JMSException(
0:                         "Could not correlate acknowledgment with dispatched message: "
0:                                 + ack);
0:                 throw new JMSException("Poison ack cannot be transacted: "
0:                         + ack);
0:             List<MessageReference> removeList = new ArrayList<MessageReference>();
0:             for (final MessageReference node : dispatched) {
0:                 if (ack.getFirstMessageId() == null
0:                         || ack.getFirstMessageId().equals(messageId)) {
0:                     node.getRegionDestination().getDestinationStatistics()
0:                             .getDequeues().increment();
0:                     removeList.add(node);
0:                         prefetchExtension = Math.max(0, prefetchExtension
0:                                 - (index + 1));
0:             for (final MessageReference node : removeList) {
0:                 dispatched.remove(node);
0:             }
0:                 throw new JMSException(
0:                         "Could not correlate acknowledgment with dispatched message: "
0:                                 + ack);
0:                 throw new JMSException(
0:                         "Slave broker out of sync with master: Acknowledgment ("
0:                                 + ack + ") was not in the dispatch list: "
0:                                 + dispatched);
0:                 LOG
0:                         .debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): "
0:                                 + ack);
/////////////////////////////////////////////////////////////////////////
0:                 dispatched.add(node);
commit:9dd11cb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQMessageAudit;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.usage.SystemUsage;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean optimizedDispatch=false;
1:     private int maxProducersToAudit=32;
1:     private int maxAuditDepth=2048;
1:     protected final SystemUsage usageManager;
0:     protected ActiveMQMessageAudit audit = new ActiveMQMessageAudit();
0:     public PrefetchSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info, PendingMessageCursor cursor) throws InvalidSelectorException {
1:         this.usageManager=usageManager;
0:     public PrefetchSubscription(Broker broker, SystemUsage usageManager, ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         this(broker,usageManager,context, info, new VMPendingMessageCursor());
/////////////////////////////////////////////////////////////////////////
0:         if (optimizedDispatch && !isFull() && pendingEmpty && !isSlave()) {
/////////////////////////////////////////////////////////////////////////
0:                 dispatchMatched();
/////////////////////////////////////////////////////////////////////////
1:         if (this.pending!=null) {
1:             this.pending.setSystemUsage(usageManager);
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 if(pending != null) {
0:                     pending.dispatched(message);
0:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public boolean isOptimizedDispatch() {
0:         return optimizedDispatch;
0:     }
0: 
0:     public void setOptimizedDispatch(boolean optimizedDispatch) {
0:         this.optimizedDispatch = optimizedDispatch;
0:     }
0: 
1:     public int getMaxProducersToAudit() {
1:         return maxProducersToAudit;
0:     }
0: 
1:     public void setMaxProducersToAudit(int maxProducersToAudit) {
1:         this.maxProducersToAudit = maxProducersToAudit;
0:     }
0: 
1:     public int getMaxAuditDepth() {
1:         return maxAuditDepth;
0:     }
0: 
1:     public void setMaxAuditDepth(int maxAuditDepth) {
1:         this.maxAuditDepth = maxAuditDepth;
0:     }
0: 
commit:a401575
/////////////////////////////////////////////////////////////////////////
0:                             if(node!=QueueMessageReference.NULL_MESSAGE&&broker.isExpired(node)){
commit:a414c20
/////////////////////////////////////////////////////////////////////////
0:         broker.sendToDeadLetterQueue(context,node);
/////////////////////////////////////////////////////////////////////////
0:                                 broker.messageExpired(getContext(),node);
0:                                 dequeueCounter++;
0:                                 continue;
commit:83a6eff
/////////////////////////////////////////////////////////////////////////
0:         if(getPrefetchSize()==0&&!isSlave()){
/////////////////////////////////////////////////////////////////////////
0:         if(!isFull()&&pendingEmpty&&!isSlave()){
/////////////////////////////////////////////////////////////////////////
0:             if(isSlave()){
/////////////////////////////////////////////////////////////////////////
0:         return isSlave()||dispatched.size()-prefetchExtension>=info.getPrefetchSize();
/////////////////////////////////////////////////////////////////////////
0:         if(!isSlave()){
/////////////////////////////////////////////////////////////////////////
0:         if(canDispatch(node)&&!isSlave()){
commit:25a252f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0:                 if (log.isDebugEnabled()) {
0:                     log.debug("Could not correlate acknowledgment with dispatched message: "+ack);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:         if(!broker.isSlaveBroker()){
0:                 int numberToDispatch=countBeforeFull();
0:                 if(numberToDispatch>0){
0:                     pending.setMaxBatchSize(numberToDispatch);
0:                     int count=0;
0:                     pending.reset();
0:                     while(pending.hasNext()&&!isFull()&&count<numberToDispatch){
0:                         MessageReference node=pending.next();
0:                         if(node==null)
0:                             break;
0:                         if(canDispatch(node)){
0:                             pending.remove();
0:                             // Message may have been sitting in the pending list a while
0:                             // waiting for the consumer to ak the message.
0:                             if(node!=QueueMessageReference.NULL_MESSAGE&&node.isExpired()){
0:                                 continue; // just drop it.
0:                             dispatch(node);
0:                             count++;
0:                 pending.release();
commit:a3e3821
/////////////////////////////////////////////////////////////////////////
0:     final synchronized void pullTimeout(long dispatchCounterBeforePull){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized boolean isLowWaterMark(){
0:     public synchronized boolean isHighWaterMark(){
/////////////////////////////////////////////////////////////////////////
0:     public synchronized int getPendingQueueSize(){
0:         return pending.size();
0:     public synchronized int getDispatchedQueueSize(){
1:         return dispatched.size();
/////////////////////////////////////////////////////////////////////////
0:     public synchronized PendingMessageCursor getPending(){
0:     public synchronized void setPending(PendingMessageCursor pending){
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized boolean dispatch(final MessageReference node) throws IOException{
commit:a5f74d6
/////////////////////////////////////////////////////////////////////////
commit:ee4bb53
/////////////////////////////////////////////////////////////////////////
0:                         pending.setMaxBatchSize(numberToDispatch);
commit:0c0be94
/////////////////////////////////////////////////////////////////////////
1:     protected PendingMessageCursor pending;
/////////////////////////////////////////////////////////////////////////
0:     
0:    
0:     public PendingMessageCursor getPending(){
1:         return this.pending;
0:     }
0: 
0:     public void setPending(PendingMessageCursor pending){
0:         this.pending=pending;
0:     }
0:     
0:    
/////////////////////////////////////////////////////////////////////////
0: 
0:     
0:     
commit:30716b1
/////////////////////////////////////////////////////////////////////////
0:     private synchronized void pullTimeout(long dispatchCounterBeforePull){
/////////////////////////////////////////////////////////////////////////
0:     protected synchronized void dispatchMatched() throws IOException{
commit:158dbc6
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
0:  * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
0:  * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
0:  * License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     private AtomicBoolean dispatching=new AtomicBoolean();
0: 
0:     public PrefetchSubscription(Broker broker,ConnectionContext context,ConsumerInfo info,PendingMessageCursor cursor)
0:             throws InvalidSelectorException{
0:         pending=cursor;
0:     public PrefetchSubscription(Broker broker,ConnectionContext context,ConsumerInfo info)
0:             throws InvalidSelectorException{
0:         this(broker,context,info,new VMPendingMessageCursor());
0:     }
0: 
0:     public synchronized Response pullMessage(ConnectionContext context,MessagePull pull) throws Exception{
0:         // The slave should not deliver pull messages. TODO: when the slave becomes a master,
0:         // He should send a NULL message to all the consumers to 'wake them up' in case
0:         // they were waiting for a message.
0:         if(getPrefetchSize()==0&&!isSlaveBroker()){
0:             final long dispatchCounterBeforePull=dispatchCounter;
0:             // If there was nothing dispatched.. we may need to setup a timeout.
0:             if(dispatchCounterBeforePull==dispatchCounter){
0:                 // imediate timeout used by receiveNoWait()
0:                 if(pull.getTimeout()==-1){
0:                     // Send a NULL message.
0:                     add(QueueMessageReference.NULL_MESSAGE);
0:                     dispatchMatched();
0:                 }
0:                 if(pull.getTimeout()>0){
0:                     Scheduler.executeAfterDelay(new Runnable(){
0: 
0:                         public void run(){
0:                             pullTimeout(dispatchCounterBeforePull);
0:                         }
0:                     },pull.getTimeout());
0:                 }
0:             }
0: 
0:      * Occurs when a pull times out. If nothing has been dispatched since the timeout was setup, then send the NULL
0:      * message.
0:     private void pullTimeout(long dispatchCounterBeforePull){
0:         if(dispatchCounterBeforePull==dispatchCounter){
0:             try{
0:                 add(QueueMessageReference.NULL_MESSAGE);
0:                 dispatchMatched();
0:             }catch(Exception e){
0:                 context.getConnection().serviceException(e);
0:             }
0:     }
0: 
0:     public synchronized void add(MessageReference node) throws Exception{
0:         boolean pendingEmpty=false;
0:         pendingEmpty=pending.isEmpty();
0:         enqueueCounter++;
0:        
/////////////////////////////////////////////////////////////////////////
0:                 }
0:     public synchronized void processMessageDispatchNotification(MessageDispatchNotification mdn) throws Exception{
0:         try{
0:             pending.reset();
0:             while(pending.hasNext()){
0:                 MessageReference node=pending.next();
0:                 if(node.getMessageId().equals(mdn.getMessageId())){
0:                     pending.remove();
0:                     createMessageDispatch(node,node.getMessage());
0:                     dispatched.addLast(node);
0:                     return;
0:         }finally{
0:             pending.release();
0:         throw new JMSException("Slave broker out of sync with master: Dispatched message ("+mdn.getMessageId()
0:                 +") was not in the pending list");
0:     public synchronized void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception{
0:         if(ack.isStandardAck()){
0:             // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:             int index=0;
0:             boolean inAckRange=false;
0:             for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                 final MessageReference node=(MessageReference)iter.next();
0:                 MessageId messageId=node.getMessageId();
0:                 if(ack.getFirstMessageId()==null||ack.getFirstMessageId().equals(messageId)){
0:                     inAckRange=true;
0:                 }
0:                 if(inAckRange){
0:                     // Don't remove the nodes until we are committed.
0:                     if(!context.isInTransaction()){
0:                         dequeueCounter++;
0:                         node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                         iter.remove();
0:                     }else{
0:                         // setup a Synchronization to remove nodes from the dispatched list.
0:                         context.getTransaction().addSynchronization(new Synchronization(){
0:                             public void afterCommit() throws Exception{
0:                                 synchronized(PrefetchSubscription.this){
0:                                     dequeueCounter++;
0:                                     dispatched.remove(node);
0:                                     node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                                     prefetchExtension--;
0: 
0:                             public void afterRollback() throws Exception{
0:                                 super.afterRollback();
0:                             }
0:                         });
0:                     index++;
0:                     acknowledge(context,ack,node);
0:                     if(ack.getLastMessageId().equals(messageId)){
0:                         if(context.isInTransaction()){
0:                             // extend prefetch window only if not a pulling consumer
0:                             if(getPrefetchSize()!=0){
0:                                 prefetchExtension=Math.max(prefetchExtension,index+1);
0:                             }
0:                         }else{
0:                             prefetchExtension=Math.max(0,prefetchExtension-(index+1));
0:                         }
0:             }
0:             // this only happens after a reconnect - get an ack which is not valid
0:             if(!callDispatchMatched){
0:                 log.info("Could not correlate acknowledgment with dispatched message: "+ack);
0:             }
0:         }else if(ack.isDeliveredAck()){
0:             // Message was delivered but not acknowledged: update pre-fetch counters.
0:             // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:             int index=0;
0:             for(Iterator iter=dispatched.iterator();iter.hasNext();index++){
0:                 final MessageReference node=(MessageReference)iter.next();
0:                 if(ack.getLastMessageId().equals(node.getMessageId())){
0:                     prefetchExtension=Math.max(prefetchExtension,index+1);
0:                     callDispatchMatched=true;
0:                     break;
0:             }
0:             if(!callDispatchMatched){
0:                 throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
0:             }
0:         }else if(ack.isPoisonAck()){
0:             // TODO: what if the message is already in a DLQ???
0:             // Handle the poison ACK case: we need to send the message to a DLQ
0:             if(ack.isInTransaction())
0:                 throw new JMSException("Poison ack cannot be transacted: "+ack);
0:             // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:             int index=0;
0:             boolean inAckRange=false;
0:             for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                 final MessageReference node=(MessageReference)iter.next();
0:                 MessageId messageId=node.getMessageId();
0:                 if(ack.getFirstMessageId()==null||ack.getFirstMessageId().equals(messageId)){
0:                     inAckRange=true;
0:                 }
0:                 if(inAckRange){
0:                     sendToDLQ(context,node);
0:                     node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                     iter.remove();
0:                     dequeueCounter++;
0:                     index++;
0:                     acknowledge(context,ack,node);
0:                     if(ack.getLastMessageId().equals(messageId)){
0:                         prefetchExtension=Math.max(0,prefetchExtension-(index+1));
0:                         callDispatchMatched=true;
0:                         break;
0:             }
0:             if(!callDispatchMatched){
0:                 throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
/////////////////////////////////////////////////////////////////////////
0:     protected void sendToDLQ(final ConnectionContext context,final MessageReference node) throws IOException,Exception{
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQDestination deadLetterDestination=deadLetterStrategy
0:                     .getDeadLetterQueueFor(message.getDestination());
0:             BrokerSupport.resend(context,message,deadLetterDestination);
0:      * 
0:     protected synchronized boolean isFull(){
0:         return isSlaveBroker()||dispatched.size()-prefetchExtension>=info.getPrefetchSize();
0: 
0:         return (dispatched.size()-prefetchExtension)<=(info.getPrefetchSize()*.4);
0: 
0:         return (dispatched.size()-prefetchExtension)>=(info.getPrefetchSize()*.9);
0: 
0:     public synchronized int countBeforeFull(){
0:         return info.getPrefetchSize()+prefetchExtension-dispatched.size();
0: 
0:         synchronized(pending){
0:             return pending.size();
0:         }
0: 
0: 
0: 
0:     synchronized public long getDispatchedCounter(){
0: 
0:     synchronized public long getEnqueueCounter(){
0: 
0: 
0:      * 
0:         /*
0:          * if(info!=null&&info.isOptimizedAcknowledge()&&context!=null&&context.getConnection()!=null
0:          * &&context.getConnection().isManageable()){ if(info.getCurrentPrefetchSize()!=info.getPrefetchSize() &&
0:          * isLowWaterMark()){ info.setCurrentPrefetchSize(info.getPrefetchSize());
0:          * updateConsumerPrefetch(info.getPrefetchSize()); }else
0:          * if(info.getCurrentPrefetchSize()==info.getPrefetchSize() && isHighWaterMark()){ // want to purge any
0:          * outstanding acks held by the consumer info.setCurrentPrefetchSize(1); updateConsumerPrefetch(1); } }
1:          */
0: 
0:     public synchronized void add(ConnectionContext context,Destination destination) throws Exception{
0:         pending.add(context,destination);
0:     public synchronized void remove(ConnectionContext context,Destination destination) throws Exception{
0:         pending.remove(context,destination);
0:         if(!broker.isSlaveBroker()&&dispatching.compareAndSet(false,true)){
0:                 try{
0:                     int numberToDispatch=countBeforeFull();
0:                     if(numberToDispatch>0){
0:                         int count=0;
0:                         pending.reset();
0:                         while(pending.hasNext()&&!isFull()&&count<numberToDispatch){
0:                             MessageReference node=pending.next();
0:                             if(node==null)
0:                                 break;
0:                             if(canDispatch(node)){
0:                                 pending.remove();
0:                                 // Message may have been sitting in the pending list a while
0:                                 // waiting for the consumer to ak the message.
0:                                 if(node!=QueueMessageReference.NULL_MESSAGE&&node.isExpired()){
0:                                     continue; // just drop it.
0:                                 dispatch(node);
0:                                 count++;
0:                 }finally{
0:                     pending.release();
/////////////////////////////////////////////////////////////////////////
0:         // Make sure we can dispatch a message.
0:         if(canDispatch(node)&&!isSlaveBroker()){
0:             MessageDispatch md=createMessageDispatch(node,message);
0:             // NULL messages don't count... they don't get Acked.
0:             if(node!=QueueMessageReference.NULL_MESSAGE){
0:                 dispatchCounter++;
0:                 dispatched.addLast(node);
0:                 prefetchExtension=Math.max(0,prefetchExtension-1);
0:             if(info.isDispatchAsync()){
0:                 md.setConsumer(new Runnable(){
0: 
0:                     public void run(){
0:                         // Since the message gets queued up in async dispatch, we don't want to
0:                         // decrease the reference count until it gets put on the wire.
0:                         onDispatch(node,message);
0:                     }
0:                 });
0:                 context.getConnection().dispatchAsync(md);
0:             }else{
0:                 context.getConnection().dispatchSync(md);
0:                 onDispatch(node,message);
0:             }
0:             //System.err.println(broker.getBrokerName() + " " + this + " (" + enqueueCounter + ", " + dispatchCounter +") " + node);
0:             return true;
0:         }else{
0:             QueueMessageReference n=(QueueMessageReference)node;
0:             return false;
0:             if(node!=QueueMessageReference.NULL_MESSAGE){
0:                 node.getRegionDestination().getDestinationStatistics().getDispatched().increment();
0:                 context.getConnection().getStatistics().onMessageDequeue(message);
0:             }
/////////////////////////////////////////////////////////////////////////
0: 
0:      * 
0:         if(context!=null&&context.getConnection()!=null&&context.getConnection().isManageable()){
0:             ConsumerControl cc=new ConsumerControl();
/////////////////////////////////////////////////////////////////////////
0:         if(node==QueueMessageReference.NULL_MESSAGE){
0:             MessageDispatch md=new MessageDispatch();
0:             md.setConsumerId(info.getConsumerId());
1:             md.setDestination(null);
0:         }else{
0:             md.setDestination(node.getRegionDestination().getActiveMQDestination());
0:             md.setMessage(message);
0:             md.setRedeliveryCounter(node.getRedeliveryCounter());
0:             return md;
0:         }
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException
/////////////////////////////////////////////////////////////////////////
0:             throws IOException{
0:     }
commit:6ddeac7
/////////////////////////////////////////////////////////////////////////
0:         
0:         if(!isFull()&&pendingEmpty&&!broker.isSlaveBroker()){
0:                 }       
/////////////////////////////////////////////////////////////////////////
0:                         
/////////////////////////////////////////////////////////////////////////
0:                     +") was not in the pending list");
/////////////////////////////////////////////////////////////////////////
0:         if(!broker.isSlaveBroker() && dispatching.compareAndSet(false,true)){
commit:d2e6062
/////////////////////////////////////////////////////////////////////////
0:     public int countBeforeFull() {
0:         return info.getPrefetchSize() + prefetchExtension - dispatched.size();
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:                         int numberToDispatch=countBeforeFull();
0:                         if(numberToDispatch>0){
0:                             int count=0;
0:                             pending.reset();
0:                             while(pending.hasNext()&&!isFull()&&count<numberToDispatch){
0:                                 MessageReference node=pending.next();
0:                                
0:                                 if(canDispatch(node)){
0:                                     pending.remove();
0:                                     // Message may have been sitting in the pending list a while
0:                                     // waiting for the consumer to ak the message.
0:                                     if(node!=QueueMessageReference.NULL_MESSAGE&&node.isExpired()){
0:                                         continue; // just drop it.
0:                                     }
0:                                     if(toDispatch==null){
0:                                         toDispatch=new ArrayList();
0:                                     }
0:                                     toDispatch.add(node);
0:                                     count++;
0:                                 }
0:                     synchronized(dispatched){
0:                         for(int i=0;i<toDispatch.size();i++){
0:                             MessageReference node=(MessageReference)toDispatch.get(i);
0:                             dispatch(node);
0:                         }
/////////////////////////////////////////////////////////////////////////
0:                 QueueMessageReference n = (QueueMessageReference) node;
commit:c651ace
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean dispatching = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
0:         if(dispatching.compareAndSet(false,true)){
0:                 List toDispatch=null;
0:                 synchronized(pending){
0:                     try{
0:                         pending.reset();
0:                         while(pending.hasNext()&&!isFull()){
0:                             MessageReference node=pending.next();
0:                             pending.remove();
0:                             // Message may have been sitting in the pending list a while
0:                             // waiting for the consumer to ak the message.
0:                             if(node!=QueueMessageReference.NULL_MESSAGE&&node.isExpired()){
0:                                 continue; // just drop it.
0:                             }
0:                             if(toDispatch==null){
0:                                 toDispatch=new ArrayList();
0:                             }
0:                             toDispatch.add(node);
0:                         }
0:                     }finally{
0:                         pending.release();
0:                 }
0:                 if(toDispatch!=null){
0:                     for(int i=0;i<toDispatch.size();i++){
0:                         MessageReference node=(MessageReference)toDispatch.get(i);
0:                         dispatch(node);
0:                 dispatching.set(false);
commit:d8674a0
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:         
0:     protected long enqueueCounter;
0:     protected long dispatchCounter;
0:     protected long dequeueCounter;
/////////////////////////////////////////////////////////////////////////
0:         boolean pendingEmpty=false;
/////////////////////////////////////////////////////////////////////////
0:                 if(pending.isEmpty()&&log.isDebugEnabled()){
0:             //we might be able to dispatch messages (i.e. not full() anymore)
0:             dispatchMatched();
0:     
/////////////////////////////////////////////////////////////////////////
0:         boolean callDispatchMatched=false;
/////////////////////////////////////////////////////////////////////////
0:                             callDispatchMatched=true;
0:                             break;
0:                 // this only happens after a reconnect - get an ack which is not valid
0:                 if(!callDispatchMatched){
0:                     log.info("Could not correlate acknowledgment with dispatched message: "+ack);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                         callDispatchMatched=true;
0:                         break;
0:                 if(!callDispatchMatched){
0:                     throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                             callDispatchMatched=true;
0:                             break;
0:                 if(!callDispatchMatched){
0:                     throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
0:                 }
0:         }
0:         if(callDispatchMatched){
0:             dispatchMatched();
0:         }else{
/////////////////////////////////////////////////////////////////////////
0:     public void add(ConnectionContext context,Destination destination) throws Exception{
0:         synchronized(pending){
0:             pending.add(context,destination);
0:         }
0:     public void remove(ConnectionContext context,Destination destination) throws Exception{
0:         synchronized(pending){
0:             pending.remove(context,destination);
0:         }
0:         List toDispatch=null;
0:             try{
0:                 pending.reset();
0:                 while(pending.hasNext()&&!isFull()){
0:                     MessageReference node=pending.next();
0:                     pending.remove();
0:                     // Message may have been sitting in the pending list a while
0:                     // waiting for the consumer to ak the message.
0:                     if(node!=QueueMessageReference.NULL_MESSAGE&&node.isExpired()){
0:                         continue; // just drop it.
0:                     if(toDispatch==null){
0:                         toDispatch=new ArrayList();
0:                     }
0:                     toDispatch.add(node);
0:             }finally{
0:                 pending.release();
0:             }
0:         }
0:         if(toDispatch!=null){
0:             for(int i=0;i<toDispatch.size();i++){
0:                 MessageReference node=(MessageReference)toDispatch.get(i);
0:                 dispatch(node);
commit:a110604
/////////////////////////////////////////////////////////////////////////
0:                 		if( node != QueueMessageReference.NULL_MESSAGE && node.isExpired() ) {
commit:ec63977
/////////////////////////////////////////////////////////////////////////
0:         try {
/////////////////////////////////////////////////////////////////////////
0:         }catch(Throwable e) {
0:             e.printStackTrace();
0:             
0:         }
0:     public void processMessageDispatchNotification(MessageDispatchNotification mdn) throws Exception{
0:             try{
0:                 pending.reset();
0:                 while(pending.hasNext()){
0:                     MessageReference node=pending.next();
0:                     if(node.getMessageId().equals(mdn.getMessageId())){
0:                         pending.remove();
0:                         createMessageDispatch(node,node.getMessage());
0:                         dispatched.addLast(node);
0:                         return;
0:                     }
0:             }finally{
0:                 pending.release();
0:             throw new JMSException("Slave broker out of sync with master: Dispatched message ("+mdn.getMessageId()
0:                     +") was not in the pending list: "+pending);
/////////////////////////////////////////////////////////////////////////
0:                     pending.release();
commit:6895d00
/////////////////////////////////////////////////////////////////////////
0:     public Response pullMessage(ConnectionContext context, MessagePull pull) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     private void pullTimeout(long dispatchCounterBeforePull) {    	
/////////////////////////////////////////////////////////////////////////
0:     public void add(MessageReference node) throws Exception{
0:         boolean pendingEmpty = false;
0:         synchronized(pending){
0:             pendingEmpty=pending.isEmpty();
0:             enqueueCounter++;
0:         }
0:         if(!isFull()&&pendingEmpty){
0:                 if(log.isDebugEnabled() && pending.isEmpty()){
/////////////////////////////////////////////////////////////////////////
0:     public void processMessageDispatchNotification(MessageDispatchNotification mdn) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public void acknowledge(final ConnectionContext context,final MessageAck ack) throws Exception{
0:         synchronized(dispatched){
0:             if(ack.isStandardAck()){
0:                 // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:                 int index=0;
0:                 boolean inAckRange=false;
0:                 for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                     final MessageReference node=(MessageReference)iter.next();
0:                     MessageId messageId=node.getMessageId();
0:                     if(ack.getFirstMessageId()==null||ack.getFirstMessageId().equals(messageId)){
0:                         inAckRange=true;
0:                     }
0:                     if(inAckRange){
0:                         // Don't remove the nodes until we are committed.
0:                         if(!context.isInTransaction()){
0:                             dequeueCounter++;
0:                             node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                             iter.remove();
0:                         }else{
0:                             // setup a Synchronization to remove nodes from the dispatched list.
0:                             context.getTransaction().addSynchronization(new Synchronization(){
0:                                 public void afterCommit() throws Exception{
0:                                     synchronized(PrefetchSubscription.this){
0:                                         dequeueCounter++;
0:                                         dispatched.remove(node);
0:                                         node.getRegionDestination().getDestinationStatistics().getDequeues()
0:                                                 .increment();
0:                                         prefetchExtension--;
0:                                     }
0:                                 }
0: 
0:                                 public void afterRollback() throws Exception{
0:                                     super.afterRollback();
0:                                 }
0:                             });
0:                         index++;
0:                         acknowledge(context,ack,node);
0:                         if(ack.getLastMessageId().equals(messageId)){
0:                             if(context.isInTransaction()){
0:                                 // extend prefetch window only if not a pulling consumer
0:                                 if(getPrefetchSize()!=0){
0:                                     prefetchExtension=Math.max(prefetchExtension,index+1);
0:                                 }
0:                             }else{
0:                                 prefetchExtension=Math.max(0,prefetchExtension-(index+1));
0:                             }
0:                             dispatchMatched();
0:                             return;
0:                         }
0:                     }
0:                 }
0:                 //this only happens after a reconnect - get an ack which is not valid
0:                 log.info("Could not correlate acknowledgment with dispatched message: "+ack);
0:             }else if(ack.isDeliveredAck()){
0:                 // Message was delivered but not acknowledged: update pre-fetch counters.
0:                 // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:                 int index=0;
0:                 for(Iterator iter=dispatched.iterator();iter.hasNext();index++){
0:                     final MessageReference node=(MessageReference)iter.next();
0:                     if(ack.getLastMessageId().equals(node.getMessageId())){
0:                         prefetchExtension=Math.max(prefetchExtension,index+1);
0:                         dispatchMatched();
0:                         return;
0:                     }
0:                 }
0:                 throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
0:             }else if(ack.isPoisonAck()){
0:                 // TODO: what if the message is already in a DLQ???
0:                 // Handle the poison ACK case: we need to send the message to a DLQ
0:                 if(ack.isInTransaction())
0:                     throw new JMSException("Poison ack cannot be transacted: "+ack);
0:                 // Acknowledge all dispatched messages up till the message id of the acknowledgment.
0:                 int index=0;
0:                 boolean inAckRange=false;
0:                 for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                     final MessageReference node=(MessageReference)iter.next();
0:                     MessageId messageId=node.getMessageId();
0:                     if(ack.getFirstMessageId()==null||ack.getFirstMessageId().equals(messageId)){
0:                         inAckRange=true;
0:                     }
0:                     if(inAckRange){
0:                         sendToDLQ(context,node);
0:                         node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
0:                         iter.remove();
0:                         dequeueCounter++;
0:                         index++;
0:                         acknowledge(context,ack,node);
0:                         if(ack.getLastMessageId().equals(messageId)){
0:                             dispatchMatched();
0:                             return;
0:                 
0:                 throw new JMSException("Could not correlate acknowledgment with dispatched message: "+ack);
0:             if(isSlaveBroker()){
0:                 throw new JMSException("Slave broker out of sync with master: Acknowledgment ("+ack
0:                         +") was not in the dispatch list: "+dispatched);
0:             }else{
0:                 log.debug("Acknowledgment out of sync (Normally occurs when failover connection reconnects): "+ack);
/////////////////////////////////////////////////////////////////////////
0:     public int getDispatchedQueueSize(){
0:         synchronized(dispatched){
0:             return dispatched.size();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         synchronized(pending){
0:             if(!dispatching){
0:                 dispatching=true;
0:                 try{
0:                     pending.reset();
0:                     while(pending.hasNext()&&!isFull()){
0:                         MessageReference node=pending.next();
0:                         pending.remove();
0:                         dispatch(node);
0:                     }
0:                 }finally{
0:                     dispatching=false;
/////////////////////////////////////////////////////////////////////////
0:         synchronized(dispatched){
0:             // Make sure we can dispatch a message.
0:             if(canDispatch(node)&&!isSlaveBroker()){
0:                 MessageDispatch md=createMessageDispatch(node,message);
0:                 // NULL messages don't count... they don't get Acked.
0:                 if(node!=QueueMessageReference.NULL_MESSAGE){
0:                     dispatchCounter++;
0:                     dispatched.addLast(node);
0:                 }else{
0:                     prefetchExtension=Math.max(0,prefetchExtension-1);
0:                 }
0:                 if(info.isDispatchAsync()){
0:                     md.setConsumer(new Runnable(){
0: 
0:                         public void run(){
0:                             // Since the message gets queued up in async dispatch, we don't want to
0:                             // decrease the reference count until it gets put on the wire.
0:                             onDispatch(node,message);
0:                         }
0:                     });
0:                     context.getConnection().dispatchAsync(md);
0:                 }else{
0:                     context.getConnection().dispatchSync(md);
0:                     onDispatch(node,message);
0:                 }
0:                 return true;
0:                 return false;
0:     protected void onDispatch(final MessageReference node,final Message message){
commit:3a9299b
/////////////////////////////////////////////////////////////////////////
0:       
0:         if(!isFull() && pending.isEmpty() ){
/////////////////////////////////////////////////////////////////////////
commit:b6ba20b
/////////////////////////////////////////////////////////////////////////
0:         //if(!isFull()){
0:         if(!isFull() && pending.isEmpty() && canDispatch(node)){
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @return MessageDispatch
commit:4eef609
/////////////////////////////////////////////////////////////////////////
0:                             prefetchExtension=Math.max(prefetchExtension,index+1);
/////////////////////////////////////////////////////////////////////////
0:     public boolean isRecoveryRequired(){
1:         return pending.isRecoveryRequired();
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     public void add(ConnectionContext context, Destination destination) throws Exception {
0:         super.add(context,destination);
0:         pending.add(context,destination);
0:     }
0: 
0:     public void remove(ConnectionContext context, Destination destination) throws Exception {
0:         super.remove(context,destination);
0:         pending.remove(context,destination);
0:        
0:     }
commit:7d1e6bc
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.region.cursors.FilePendingMessageCursor;
1: import org.apache.activemq.broker.region.cursors.PendingMessageCursor;
1: import org.apache.activemq.broker.region.cursors.VMPendingMessageCursor;
/////////////////////////////////////////////////////////////////////////
0:     final protected PendingMessageCursor pending;
/////////////////////////////////////////////////////////////////////////
0:     
0:     public PrefetchSubscription(Broker broker,ConnectionContext context,ConsumerInfo info, PendingMessageCursor cursor)
0:                     throws  InvalidSelectorException{
0:         pending = cursor;
0:     }
0:     
0:     public PrefetchSubscription(Broker broker,ConnectionContext context,ConsumerInfo info)
0:     throws  InvalidSelectorException{
0:        this(broker,context,info,new VMPendingMessageCursor()); 
/////////////////////////////////////////////////////////////////////////
0:             dispatchMatched();
0:             
/////////////////////////////////////////////////////////////////////////
0:         }
/////////////////////////////////////////////////////////////////////////
0:                 pending.addMessageLast(node);
0:             pending.reset();
0:             while(pending.hasNext()){
0:                 MessageReference node=pending.next();
0:                     pending.remove();
/////////////////////////////////////////////////////////////////////////
0:                 pending.reset();
0:                 while(pending.hasNext()&&!isFull()){
0:                     MessageReference node=pending.next();
0:                     pending.remove();
/////////////////////////////////////////////////////////////////////////
0:             dispatchCounter++;
0:             dispatched.addLast(node);            
/////////////////////////////////////////////////////////////////////////
0:             node.getRegionDestination().getDestinationStatistics().onMessageDequeue(message);
0:             context.getConnection().getStatistics().onMessageDequeue(message);
/////////////////////////////////////////////////////////////////////////
0:         MessageDispatch md=new MessageDispatch();
0:         md.setConsumerId(info.getConsumerId());
0:         md.setDestination(node.getRegionDestination().getActiveMQDestination());
0:         md.setMessage(message);
0:         md.setRedeliveryCounter(node.getRedeliveryCounter());
0:         return md;
0:     }
commit:6eaea6f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.ConsumerControl;
/////////////////////////////////////////////////////////////////////////
0:             optimizePrefetch();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @return true when 60% or more room is left for dispatching messages
1:      */
0:     public boolean isLowWaterMark(){
0:         return (dispatched.size()-prefetchExtension) <= (info.getPrefetchSize() *.4);
0:     }
0:     
1:     /**
1:      * @return true when 10% or less room is left for dispatching messages
1:      */
0:     public boolean isHighWaterMark(){
0:         return (dispatched.size()-prefetchExtension) >= (info.getPrefetchSize() *.9);
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
0:      * optimize message consumer prefetch if the consumer supports it
0:      *
0:      */
0:     public void optimizePrefetch(){
0:         if(info!=null&&info.isOptimizedAcknowledge()&&context!=null&&context.getConnection()!=null
0:                         &&context.getConnection().isManageable()){
0:             if(info.getCurrentPrefetchSize()!=info.getPrefetchSize() && isLowWaterMark()){
0:                 info.setCurrentPrefetchSize(info.getPrefetchSize());
0:                 updateConsumerPrefetch(info.getPrefetchSize());
0:             }else if(info.getCurrentPrefetchSize()==info.getPrefetchSize() && isHighWaterMark()){
0:                 // want to purge any outstanding acks held by the consumer
0:                 info.setCurrentPrefetchSize(1);
0:                 updateConsumerPrefetch(1);
0:             }
0:         }
0:     }
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * inform the MessageConsumer on the client to change it's prefetch
1:      * @param newPrefetch
0:      */
0:     public void updateConsumerPrefetch(int newPrefetch){
0:         if (context != null && context.getConnection() != null && context.getConnection().isManageable()){
0:             ConsumerControl cc = new ConsumerControl();
1:             cc.setConsumerId(info.getConsumerId());
1:             cc.setPrefetch(newPrefetch);
1:             context.getConnection().dispatchAsync(cc);
0:         }
0:     }
commit:39ad4a8
/////////////////////////////////////////////////////////////////////////
0:                     if (log.isDebugEnabled()){
0:                         log.debug("Prefetch limit.");
0:                     }
commit:3601e81
/////////////////////////////////////////////////////////////////////////
0:     
0:     public int pending(){
0:         return matched.size() - dispatched.size();
0:     }
0:     
0:     public int dispatched(){
0:         return dispatched.size();
0:     }
0:     
0:     public int delivered(){
0:         return delivered;
0:     }
commit:8b04e15
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
0:  * the License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
0: abstract public class PrefetchSubscription extends AbstractSubscription{
0:     static private final Log log=LogFactory.getLog(PrefetchSubscription.class);
0:     final protected LinkedList matched=new LinkedList();
0:     final protected LinkedList dispatched=new LinkedList();
0: 
0:     public PrefetchSubscription(Broker broker,ConnectionContext context,ConsumerInfo info)
0:                     throws InvalidSelectorException{
0:         super(broker,context,info);
0:     synchronized public void add(MessageReference node) throws Throwable{
0:         if(!isFull()&&!isSlaveBroker()){
0:         }else{
0: 
0:     public void processMessageDispatchNotification(MessageDispatchNotification mdn){
0:             for(Iterator i=matched.iterator();i.hasNext();){
0:                 MessageReference node=(MessageReference) i.next();
0:                 if(node.getMessageId().equals(mdn.getMessageId())){
0:                     try{
0:                         MessageDispatch md=createMessageDispatch(node,node.getMessage());
0:                         dispatched.addLast(node);
0:                         incrementPreloadSize(node.getSize());
0:                         node.decrementReferenceCount();
0:                         log.error("Problem processing MessageDispatchNotification: "+mdn,e);
0: 
0:     synchronized public void acknowledge(final ConnectionContext context,final MessageAck ack) throws Throwable{
0:         boolean wasFull=isFull();
0:         if(ack.isStandardAck()){
0:             for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                 final MessageReference node=(MessageReference) iter.next();
0:                 MessageId messageId=node.getMessageId();
0:                 if(ack.getFirstMessageId()==null||ack.getFirstMessageId().equals(messageId)){
0:                     inAckRange=true;
0:                 if(inAckRange){
0:                     if(!context.isInTransaction()){
0:                     }else{
0:                             public void afterCommit() throws Throwable{
0:                                 synchronized(PrefetchSubscription.this){
0:                                     for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                                         final MessageReference node=(MessageReference) iter.next();
0:                                         MessageId messageId=node.getMessageId();
0:                                         if(ack.getFirstMessageId()==null||ack.getFirstMessageId().equals(messageId)){
0:                                             inAckRange=true;
0:                                         if(inAckRange){
0:                                             if(ack.getLastMessageId().equals(messageId)){
0:                                                 delivered=Math.max(0,delivered-(index+1));
0:                         });
0:                     acknowledge(context,ack,node);
0:                     if(ack.getLastMessageId().equals(messageId)){
0:                         if(context.isInTransaction())
0:                             delivered=Math.max(delivered,index+1);
0:                         else
0:                             delivered=Math.max(0,delivered-(index+1));
0:                         if(wasFull&&!isFull()){
0:                     }else{
0:                         // System.out.println("no match: "+ack.getLastMessageId()+","+messageId);
0:         }else if(ack.isDeliveredAck()){
0:             for(Iterator iter=dispatched.iterator();iter.hasNext();index++){
0:                 final MessageReference node=(MessageReference) iter.next();
0:                 if(ack.getLastMessageId().equals(node.getMessageId())){
0:                     delivered=Math.max(delivered,index+1);
0:                     if(wasFull&&!isFull()){
0:         }else if(ack.isPoisonAck()){
0:             // Handle the poison ACK case: we need to send the message to a DLQ
0:             if(ack.isInTransaction())
0:             for(Iterator iter=dispatched.iterator();iter.hasNext();){
0:                 final MessageReference node=(MessageReference) iter.next();
0:                 MessageId messageId=node.getMessageId();
0:                 if(ack.getFirstMessageId()==null||ack.getFirstMessageId().equals(messageId)){
0:                     inAckRange=true;
0:                 if(inAckRange){
0:                     try{
0:                         Message message=node.getMessage();
0:                         if(message!=null){
0:                             // The original destination and transaction id do not get filled when the message is first
0:                             // sent,
0:                             if(message.getOriginalDestination()!=null)
0:                             if(message.getOriginalTransactionId()!=null)
0:                             DeadLetterStrategy deadLetterStrategy=node.getRegionDestination().getDeadLetterStrategy();
0:                             ActiveMQDestination deadLetterDestination=deadLetterStrategy.getDeadLetterQueueFor(message
0:                                             .getDestination());
0:                             boolean originalFlowControl=context.isProducerFlowControl();
0:                             try{
0:                                 context.getBroker().send(context,message);
0:                             }finally{
0:                         }
0:                     }finally{
0:                     acknowledge(context,ack,node);
0:                     if(ack.getLastMessageId().equals(messageId)){
0:                         delivered=Math.max(0,delivered-(index+1));
0:                         if(wasFull&&!isFull()){
/////////////////////////////////////////////////////////////////////////
0: 
0:     protected boolean isFull(){
0:         return dispatched.size()-delivered>=info.getPrefetchSize()||preLoadSize>preLoadLimit;
0: 
0:     protected void dispatchMatched() throws IOException{
0:         if(!dispatching){
0:             dispatching=true;
0:             try{
0:                 for(Iterator iter=matched.iterator();iter.hasNext()&&!isFull();){
0:                     MessageReference node=(MessageReference) iter.next();
0:             }finally{
0:     private void dispatch(final MessageReference node) throws IOException{
0:         final Message message=node.getMessage();
0:         if(message==null){
0:         }
0:         if(canDispatch(node)&&!isSlaveBroker()){
0:             MessageDispatch md=createMessageDispatch(node,message);
0:             incrementPreloadSize(node.getMessage().getSize());
0:             if(info.isDispatchAsync()){
0:                     public void run(){
0:                         // Since the message gets queued up in async dispatch, we don't want to
0:                         onDispatch(node,message);
0:             }else{
0:                 onDispatch(node,message);
0:         }else{
0:     synchronized private void onDispatch(final MessageReference node,final Message message){
0:         boolean wasFull=isFull();
0:         decrementPreloadSize(message.getSize());
0:         if(node.getRegionDestination()!=null){
0:             if(wasFull&&!isFull()){
0:                 try{
0:                 }catch(IOException e){
0: 
0:     private int incrementPreloadSize(int size){
0:         preLoadSize+=size;
0: 
0:     private int decrementPreloadSize(int size){
0:         preLoadSize-=size;
1:      * @param message
0:      *            TODO
0:     protected MessageDispatch createMessageDispatch(MessageReference node,Message message){
0:         MessageDispatch md=new MessageDispatch();
0:         md.setConsumerId(info.getConsumerId());
0:         md.setDestination(node.getRegionDestination().getActiveMQDestination());
0:         md.setRedeliveryCounter(node.getRedeliveryCounter());
0: 
0:      * @return false if the message should not be dispatched to the client (another sub may have already dispatched it
0:      *         for example).
0: 
0:      * 
0:      * @throws IOException
0:     protected void acknowledge(ConnectionContext context,final MessageAck ack,final MessageReference node)
0:                     throws IOException{}
commit:4098942
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessageDispatchNotification;
/////////////////////////////////////////////////////////////////////////
0:     public PrefetchSubscription(Broker broker,ConnectionContext context, ConsumerInfo info) throws InvalidSelectorException {
0:         super(broker,context, info);
0:         if( !isFull()  && !isSlaveBroker()) {
0:             synchronized(matched){
0:                 matched.addLast(node);
0:             }
0:         }
0:         
0:     }
0:     
0:     public void processMessageDispatchNotification(MessageDispatchNotification  mdn){
0:         synchronized(matched){
0:             for (Iterator i = matched.iterator(); i.hasNext();){
0:                 MessageReference node = (MessageReference)i.next();
0:                 if (node.getMessageId().equals(mdn.getMessageId())){
0:                     i.remove();
0:                     try {
0:                     MessageDispatch md = createMessageDispatch(node, node.getMessage());
0:                     dispatched.addLast(node);
0:                     
0:                     incrementPreloadSize(node.getMessage().getSize()); 
0:                     node.decrementReferenceCount();
0:                     }catch(Exception e){
0:                         log.error("Problem processing MessageDispatchNotification: " + mdn,e);
0:                     }
0:                     break;
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
0:     
0:     
/////////////////////////////////////////////////////////////////////////
0:         if( canDispatch(node) && !isSlaveBroker()) {
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:015cd8a
/////////////////////////////////////////////////////////////////////////
commit:36de58b
/////////////////////////////////////////////////////////////////////////
0:                     	node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
0:                                     node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
0:                     node.getRegionDestination().getDestinationStatistics().getDequeues().increment();
/////////////////////////////////////////////////////////////////////////
0:             node.getRegionDestination().getDestinationStatistics().getDispatched().increment();
author:James Strachan
-------------------------------------------------------------------------------
commit:9d671b7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.MessagePull;
1: import org.apache.activemq.command.Response;
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
1:      * Allows a message to be pulled on demand by a client
0:      */
0:     public Response pullMessage(ConnectionContext context, MessagePull pull) throws Exception {
0:         if (getPrefetchSize() == 0) {
0:             prefetchExtension++;
0:             dispatchMatched();
0:             
0:             // TODO it might be nice one day to actually return the message itself
0:         }
1:         return null;
0:     }
0:     
commit:a640ff5
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException 
0:     abstract protected boolean canDispatch(MessageReference node) throws IOException;
commit:de7f650
/////////////////////////////////////////////////////////////////////////
0:                             // TODO is this meant to be == null?
0:                             if( message.getOriginalDestination()!=null )
0:                             if (originalDestination == null) {
0:                                 originalDestination = message.getDestination();
0:                             }
commit:10c6b29
/////////////////////////////////////////////////////////////////////////
0:                             // TODO is this meant to be == null - it was != ?
0:                             if( message.getOriginalDestination()==null )
0:                             ActiveMQDestination deadLetterDestination = deadLetterStrategy.getDeadLetterQueueFor(originalDestination);
0:                             message.setDestination(deadLetterDestination);
commit:88203ae
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.DeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.InvalidSelectorException;
0: import javax.jms.JMSException;
0: 
0: import java.io.IOException;
0: import java.util.Iterator;
0: import java.util.LinkedList;
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             // TODO is this meant to be == null?
0:                             
0:                             ActiveMQDestination originalDestination = message.getOriginalDestination();
0:                             DeadLetterStrategy deadLetterStrategy = node.getRegionDestination().getDeadLetterStrategy();
0:                             message.setDestination(deadLetterStrategy.getDeadLetterQueueFor(originalDestination));
============================================================================