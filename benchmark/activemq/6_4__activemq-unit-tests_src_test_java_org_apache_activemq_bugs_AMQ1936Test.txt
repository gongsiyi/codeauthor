1:2b28443: /**
1:2b28443:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:2b28443:  * contributor license agreements.  See the NOTICE file distributed with
1:2b28443:  * this work for additional information regarding copyright ownership.
1:2b28443:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:2b28443:  * (the "License"); you may not use this file except in compliance with
1:2b28443:  * the License.  You may obtain a copy of the License at
1:2b28443:  *
1:2b28443:  *      http://www.apache.org/licenses/LICENSE-2.0
1:2b28443:  *
1:2b28443:  * Unless required by applicable law or agreed to in writing, software
1:2b28443:  * distributed under the License is distributed on an "AS IS" BASIS,
1:2b28443:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2b28443:  * See the License for the specific language governing permissions and
1:2b28443:  * limitations under the License.
1:2b28443:  */
1:2b28443: package org.apache.activemq.bugs;
1:fd6be7f: 
1:2b28443: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:2b28443: import java.util.concurrent.CountDownLatch;
1:2b28443: import java.util.concurrent.LinkedBlockingQueue;
1:2b28443: import java.util.concurrent.ThreadPoolExecutor;
1:2b28443: import java.util.concurrent.TimeUnit;
1:2b28443: import java.util.concurrent.atomic.AtomicBoolean;
1:2b28443: import java.util.concurrent.atomic.AtomicInteger;
1:5219fa1: 
1:2b28443: import javax.jms.DeliveryMode;
1:2b28443: import javax.jms.JMSException;
1:2b28443: import javax.jms.Message;
1:2b28443: import javax.jms.Queue;
1:2b28443: import javax.jms.QueueConnection;
1:2b28443: import javax.jms.QueueConnectionFactory;
1:2b28443: import javax.jms.QueueReceiver;
1:2b28443: import javax.jms.QueueSender;
1:2b28443: import javax.jms.QueueSession;
1:2b28443: import javax.jms.TextMessage;
1:2b28443: import javax.naming.NamingException;
1:5219fa1: 
1:2b28443: import junit.framework.TestCase;
1:5219fa1: 
1:5219fa1: import org.apache.activemq.ActiveMQConnectionFactory;
1:5219fa1: import org.apache.activemq.AutoFailTestSupport;
1:5219fa1: import org.apache.activemq.broker.BrokerService;
1:5219fa1: import org.apache.activemq.util.Wait;
1:5219fa1: import org.apache.log4j.Logger;
1:5219fa1: 
1:2b28443: /**
1:2b28443:  * A AMQ1936Test
1:2b28443:  *
1:2b28443:  */
1:5219fa1: public class AMQ1936Test extends TestCase {
1:5219fa1:     private final static Logger logger = Logger.getLogger(AMQ1936Test.class);
1:5219fa1:     private final static String TEST_QUEUE_NAME = "dynamicQueues/duplicate.message.test.queue";
1:5219fa1:     // //--
1:2b28443:     //
1:5219fa1:     private final static long TEST_MESSAGE_COUNT = 6000; // The number of test messages to use
1:2b28443:     //
1:5219fa1:     // //--
1:5219fa1:     private final static int CONSUMER_COUNT = 2; // The number of message receiver instances
1:5219fa1:     private final static boolean TRANSACTED_RECEIVE = true; // Flag used by receiver which indicates messages should be
1:5219fa1:                                                             // processed within a JMS transaction
1:fd6be7f: 
1:5219fa1:     private final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(CONSUMER_COUNT, CONSUMER_COUNT, Long.MAX_VALUE, TimeUnit.SECONDS,
1:5219fa1:         new LinkedBlockingQueue<Runnable>());
1:5219fa1:     private final ThreadedMessageReceiver[] receivers = new ThreadedMessageReceiver[CONSUMER_COUNT];
1:5219fa1:     private BrokerService broker = null;
1:2b28443:     static QueueConnectionFactory connectionFactory = null;
1:fd6be7f: 
1:2b28443:     @Override
1:2b28443:     protected void setUp() throws Exception {
1:2b28443:         super.setUp();
1:fd6be7f: 
1:2b28443:         broker = new BrokerService();
1:5219fa1:         broker.getSystemUsage().getMemoryUsage().setLimit(5 * 1024 * 1024);
1:2b28443:         broker.setBrokerName("test");
1:2b28443:         broker.setDeleteAllMessagesOnStartup(true);
1:2b28443:         broker.start();
1:5219fa1:         connectionFactory = new ActiveMQConnectionFactory("vm://test");
1:5219fa1:         ;
1:2b28443:     }
1:fd6be7f: 
1:2b28443:     @Override
1:2b28443:     protected void tearDown() throws Exception {
1:2b28443:         super.tearDown();
1:fd6be7f: 
1:5219fa1:         if (threadPool != null) {
1:2b28443:             // signal receivers to stop
1:5219fa1:             for (ThreadedMessageReceiver receiver : receivers) {
1:5219fa1:                 receiver.setShouldStop(true);
1:2b28443:             }
1:fd6be7f: 
1:2b28443:             logger.info("Waiting for receivers to shutdown..");
1:5219fa1:             if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {
1:2b28443:                 logger.warn("Not all receivers completed shutdown.");
1:2b28443:             } else {
1:2b28443:                 logger.info("All receivers shutdown successfully..");
1:2b28443:             }
1:2b28443:         }
1:fd6be7f: 
1:2b28443:         logger.debug("Stoping the broker.");
1:fd6be7f: 
1:5219fa1:         if (broker != null) {
1:2b28443:             broker.stop();
1:2b28443:         }
1:2b28443:     }
1:fd6be7f: 
1:5219fa1:     private void sendTextMessage(String queueName, int i) throws JMSException, NamingException {
1:5219fa1:         QueueConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://test");
1:5219fa1:         QueueConnection queueConnection = null;
1:5219fa1:         QueueSession session = null;
1:5219fa1:         QueueSender sender = null;
1:5219fa1:         Queue queue = null;
1:5219fa1:         TextMessage message = null;
1:fd6be7f: 
1:2b28443:         try {
1:fd6be7f: 
1:2b28443:             // Create the queue connection
1:2b28443:             queueConnection = connectionFactory.createQueueConnection();
1:fd6be7f: 
1:5219fa1:             session = queueConnection.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);
1:2b28443:             queue = session.createQueue(TEST_QUEUE_NAME);
1:5219fa1:             sender = session.createSender(queue);
1:5219fa1:             sender.setDeliveryMode(DeliveryMode.PERSISTENT);
1:fd6be7f: 
1:5219fa1:             message = session.createTextMessage(String.valueOf(i));
1:fd6be7f: 
1:2b28443:             // send the message
1:5219fa1:             sender.send(message);
1:fd6be7f: 
1:5219fa1:             if (session.getTransacted()) {
1:2b28443:                 session.commit();
1:2b28443:             }
1:5219fa1:             if (i % 1000 == 0) {
1:5219fa1:                 logger.info("Message successfully sent to : " + queue.getQueueName() + " messageid: " + message.getJMSMessageID() + " content:"
1:5219fa1:                     + message.getText());
1:c204304:             }
1:2b28443:         } finally {
1:5219fa1:             if (sender != null) {
1:2b28443:                 sender.close();
1:2b28443:             }
1:5219fa1:             if (session != null) {
1:2b28443:                 session.close();
1:2b28443:             }
1:5219fa1:             if (queueConnection != null) {
1:2b28443:                 queueConnection.close();
1:2b28443:             }
1:2b28443:         }
1:2b28443:     }
1:fd6be7f: 
1:5219fa1:     public void testForDuplicateMessages() throws Exception {
1:9ef4259:         final ConcurrentMap<String, String> messages = new ConcurrentHashMap<String, String>();
1:5219fa1:         final Object lock = new Object();
1:5219fa1:         final CountDownLatch duplicateSignal = new CountDownLatch(1);
1:5219fa1:         final AtomicInteger messageCount = new AtomicInteger(0);
1:fd6be7f: 
1:2b28443:         // add 1/2 the number of our total messages
1:5219fa1:         for (int i = 0; i < TEST_MESSAGE_COUNT / 2; i++) {
1:5219fa1:             if (duplicateSignal.getCount() == 0) {
1:5219fa1:                 fail("Duplicate message id detected");
1:2b28443:             }
1:5219fa1:             sendTextMessage(TEST_QUEUE_NAME, i);
1:2b28443:         }
1:fd6be7f: 
1:5219fa1:         // create a number of consumers to read of the messages and start them with a handler which simply stores the
1:5219fa1:         // message ids
1:2b28443:         // in a Map and checks for a duplicate
1:5219fa1:         for (int i = 0; i < CONSUMER_COUNT; i++) {
1:5219fa1:             receivers[i] = new ThreadedMessageReceiver(TEST_QUEUE_NAME, new IMessageHandler() {
1:fd6be7f: 
1:5219fa1:                 @Override
1:5219fa1:                 public void onMessage(Message message) throws Exception {
1:5219fa1:                     synchronized (lock) {
1:c204304:                         int current = messageCount.incrementAndGet();
1:c204304:                         if (current % 1000 == 0) {
1:5219fa1:                             logger.info("Received message:" + message.getJMSMessageID() + " with content: " + ((TextMessage) message).getText());
1:2b28443:                         }
1:5219fa1:                         if (messages.containsKey(message.getJMSMessageID())) {
1:5219fa1:                             duplicateSignal.countDown();
1:5219fa1:                             logger.fatal("duplicate message id detected:" + message.getJMSMessageID());
1:5219fa1:                             fail("Duplicate message id detected:" + message.getJMSMessageID());
1:2b28443:                         } else {
1:5219fa1:                             messages.put(message.getJMSMessageID(), message.getJMSMessageID());
1:2b28443:                         }
1:2b28443:                     }
1:c204304:                 }
1:2b28443:             });
1:5219fa1:             threadPool.submit(receivers[i]);
1:2b28443:         }
1:fd6be7f: 
1:2b28443:         // starting adding the remaining messages
1:5219fa1:         for (int i = 0; i < TEST_MESSAGE_COUNT / 2; i++) {
1:5219fa1:             if (duplicateSignal.getCount() == 0) {
1:5219fa1:                 fail("Duplicate message id detected");
1:2b28443:             }
1:5219fa1:             sendTextMessage(TEST_QUEUE_NAME, i);
1:2b28443:         }
1:fd6be7f: 
1:c204304:         logger.info("sent all " + TEST_MESSAGE_COUNT + " messages");
1:fd6be7f: 
1:2b28443:         // allow some time for messages to be delivered to receivers.
1:c204304:         boolean ok = Wait.waitFor(new Wait.Condition() {
1:5219fa1:             @Override
1:a27709b:             public boolean isSatisified() throws Exception {
1:a27709b:                 return TEST_MESSAGE_COUNT == messages.size();
1:2b28443:             }
1:fd6be7f:         }, TimeUnit.MINUTES.toMillis(7));
1:c204304:         if (!ok) {
1:2b0a194:             AutoFailTestSupport.dumpAllThreads("--STUCK?--");
1:2b28443:         }
1:5219fa1:         assertEquals("Number of messages received does not match the number sent", TEST_MESSAGE_COUNT, messages.size());
1:5219fa1:         assertEquals(TEST_MESSAGE_COUNT, messageCount.get());
4:c204304:     }
1:fd6be7f: 
1:2b28443:     private final static class ThreadedMessageReceiver implements Runnable {
1:fd6be7f: 
1:5219fa1:         private IMessageHandler handler = null;
1:5219fa1:         private final AtomicBoolean shouldStop = new AtomicBoolean(false);
1:fd6be7f: 
1:5219fa1:         public ThreadedMessageReceiver(String queueName, IMessageHandler handler) {
1:5219fa1:             this.handler = handler;
1:2b28443:         }
1:fd6be7f: 
1:5219fa1:         @Override
1:5219fa1:         public void run() {
1:fd6be7f: 
1:5219fa1:             QueueConnection queueConnection = null;
1:5219fa1:             QueueSession session = null;
1:5219fa1:             QueueReceiver receiver = null;
1:5219fa1:             Queue queue = null;
1:5219fa1:             Message message = null;
1:2b28443:             try {
1:2b28443:                 try {
1:fd6be7f: 
1:5219fa1:                     queueConnection = connectionFactory.createQueueConnection();
1:2b28443:                     // create a transacted session
1:5219fa1:                     session = queueConnection.createQueueSession(TRANSACTED_RECEIVE, QueueSession.AUTO_ACKNOWLEDGE);
1:2b28443:                     queue = session.createQueue(TEST_QUEUE_NAME);
1:5219fa1:                     receiver = session.createReceiver(queue);
1:fd6be7f: 
1:2b28443:                     // start the connection
1:5219fa1:                     queueConnection.start();
1:fd6be7f: 
1:5219fa1:                     logger.info("Receiver " + Thread.currentThread().getName() + " connected.");
1:fd6be7f: 
1:2b28443:                     // start receive loop
1:5219fa1:                     while (!(shouldStop.get() || Thread.currentThread().isInterrupted())) {
1:2b28443:                         try {
1:5219fa1:                             message = receiver.receive(200);
1:5219fa1:                         } catch (Exception e) {
1:2b28443:                             //
1:2b28443:                             // ignore interrupted exceptions
1:2b28443:                             //
1:5219fa1:                             if (e instanceof InterruptedException || e.getCause() instanceof InterruptedException) {
1:2b28443:                                 /* ignore */
1:2b28443:                             } else {
1:2b28443:                                 throw e;
1:2b28443:                             }
1:2b28443:                         }
1:fd6be7f: 
1:5219fa1:                         if (message != null && this.handler != null) {
1:2b28443:                             this.handler.onMessage(message);
1:2b28443:                         }
1:fd6be7f: 
1:2b28443:                         // commit session on successful handling of message
1:5219fa1:                         if (session.getTransacted()) {
1:2b28443:                             session.commit();
1:2b28443:                         }
1:2b28443:                     }
1:fd6be7f: 
1:5219fa1:                     logger.info("Receiver " + Thread.currentThread().getName() + " shutting down.");
1:fd6be7f: 
1:2b28443:                 } finally {
1:5219fa1:                     if (receiver != null) {
1:2b28443:                         try {
1:2b28443:                             receiver.close();
1:5219fa1:                         } catch (JMSException e) {
1:fd6be7f:                             logger.warn(e);
1:2b28443:                         }
1:2b28443:                     }
1:5219fa1:                     if (session != null) {
1:2b28443:                         try {
1:2b28443:                             session.close();
1:5219fa1:                         } catch (JMSException e) {
1:fd6be7f:                             logger.warn(e);
1:2b28443:                         }
1:2b28443:                     }
1:5219fa1:                     if (queueConnection != null) {
1:2b28443:                         queueConnection.close();
1:2b28443:                     }
1:2b28443:                 }
1:5219fa1:             } catch (JMSException e) {
1:2b28443:                 logger.error(e);
1:2b28443:                 e.printStackTrace();
1:2b28443:             } catch (NamingException e) {
1:2b28443:                 logger.error(e);
1:2b28443:             } catch (Exception e) {
1:2b28443:                 logger.error(e);
1:2b28443:                 e.printStackTrace();
1:2b28443:             }
1:2b28443:         }
1:fd6be7f: 
1:2b28443:         public void setShouldStop(Boolean shouldStop) {
1:2b28443:             this.shouldStop.set(shouldStop);
1:2b28443:         }
1:2b28443:     }
48:2b28443: 
1:2b28443:     public interface IMessageHandler {
1:5219fa1:         void onMessage(Message message) throws Exception;
1:2b28443:     }
1:2b28443: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:         final ConcurrentMap<String, String> messages = new ConcurrentHashMap<String, String>();
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:5219fa1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: import org.apache.activemq.ActiveMQConnectionFactory;
1: import org.apache.activemq.AutoFailTestSupport;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.util.Wait;
1: import org.apache.log4j.Logger;
1: 
1: public class AMQ1936Test extends TestCase {
1:     private final static Logger logger = Logger.getLogger(AMQ1936Test.class);
1:     private final static String TEST_QUEUE_NAME = "dynamicQueues/duplicate.message.test.queue";
1:     // //--
1:     private final static long TEST_MESSAGE_COUNT = 6000; // The number of test messages to use
1:     // //--
1:     private final static int CONSUMER_COUNT = 2; // The number of message receiver instances
1:     private final static boolean TRANSACTED_RECEIVE = true; // Flag used by receiver which indicates messages should be
1:                                                             // processed within a JMS transaction
1:     private final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(CONSUMER_COUNT, CONSUMER_COUNT, Long.MAX_VALUE, TimeUnit.SECONDS,
1:         new LinkedBlockingQueue<Runnable>());
1:     private final ThreadedMessageReceiver[] receivers = new ThreadedMessageReceiver[CONSUMER_COUNT];
1:     private BrokerService broker = null;
1:         broker.getSystemUsage().getMemoryUsage().setLimit(5 * 1024 * 1024);
1:         connectionFactory = new ActiveMQConnectionFactory("vm://test");
1:         ;
1:         if (threadPool != null) {
1:             for (ThreadedMessageReceiver receiver : receivers) {
1:                 receiver.setShouldStop(true);
1:             if (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) {
/////////////////////////////////////////////////////////////////////////
1:         if (broker != null) {
1:     private void sendTextMessage(String queueName, int i) throws JMSException, NamingException {
1:         QueueConnectionFactory connectionFactory = new ActiveMQConnectionFactory("vm://test");
1:         QueueConnection queueConnection = null;
1:         QueueSession session = null;
1:         QueueSender sender = null;
1:         Queue queue = null;
1:         TextMessage message = null;
1:             session = queueConnection.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);
1:             sender = session.createSender(queue);
1:             sender.setDeliveryMode(DeliveryMode.PERSISTENT);
1:             message = session.createTextMessage(String.valueOf(i));
1:             sender.send(message);
1:             if (session.getTransacted()) {
1:             if (i % 1000 == 0) {
1:                 logger.info("Message successfully sent to : " + queue.getQueueName() + " messageid: " + message.getJMSMessageID() + " content:"
1:                     + message.getText());
1:             if (sender != null) {
1:             if (session != null) {
1:             if (queueConnection != null) {
1:     public void testForDuplicateMessages() throws Exception {
0:         final ConcurrentHashMap<String, String> messages = new ConcurrentHashMap<String, String>();
1:         final Object lock = new Object();
1:         final CountDownLatch duplicateSignal = new CountDownLatch(1);
1:         final AtomicInteger messageCount = new AtomicInteger(0);
1:         for (int i = 0; i < TEST_MESSAGE_COUNT / 2; i++) {
1:             if (duplicateSignal.getCount() == 0) {
1:                 fail("Duplicate message id detected");
1:             sendTextMessage(TEST_QUEUE_NAME, i);
1:         // create a number of consumers to read of the messages and start them with a handler which simply stores the
1:         // message ids
1:         for (int i = 0; i < CONSUMER_COUNT; i++) {
1:             receivers[i] = new ThreadedMessageReceiver(TEST_QUEUE_NAME, new IMessageHandler() {
1:                 @Override
1:                 public void onMessage(Message message) throws Exception {
1:                     synchronized (lock) {
1:                             logger.info("Received message:" + message.getJMSMessageID() + " with content: " + ((TextMessage) message).getText());
1:                         if (messages.containsKey(message.getJMSMessageID())) {
1:                             duplicateSignal.countDown();
1:                             logger.fatal("duplicate message id detected:" + message.getJMSMessageID());
1:                             fail("Duplicate message id detected:" + message.getJMSMessageID());
1:                             messages.put(message.getJMSMessageID(), message.getJMSMessageID());
1:             threadPool.submit(receivers[i]);
1:         for (int i = 0; i < TEST_MESSAGE_COUNT / 2; i++) {
1:             if (duplicateSignal.getCount() == 0) {
1:                 fail("Duplicate message id detected");
1:             sendTextMessage(TEST_QUEUE_NAME, i);
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("Number of messages received does not match the number sent", TEST_MESSAGE_COUNT, messages.size());
1:         assertEquals(TEST_MESSAGE_COUNT, messageCount.get());
1:         private IMessageHandler handler = null;
1:         private final AtomicBoolean shouldStop = new AtomicBoolean(false);
1:         public ThreadedMessageReceiver(String queueName, IMessageHandler handler) {
1:             this.handler = handler;
1:         @Override
1:         public void run() {
1:             QueueConnection queueConnection = null;
1:             QueueSession session = null;
1:             QueueReceiver receiver = null;
1:             Queue queue = null;
1:             Message message = null;
1:                     queueConnection = connectionFactory.createQueueConnection();
1:                     session = queueConnection.createQueueSession(TRANSACTED_RECEIVE, QueueSession.AUTO_ACKNOWLEDGE);
1:                     receiver = session.createReceiver(queue);
1:                     queueConnection.start();
1:                     logger.info("Receiver " + Thread.currentThread().getName() + " connected.");
1:                     while (!(shouldStop.get() || Thread.currentThread().isInterrupted())) {
1:                             message = receiver.receive(200);
1:                         } catch (Exception e) {
1:                             if (e instanceof InterruptedException || e.getCause() instanceof InterruptedException) {
1:                         if (message != null && this.handler != null) {
1:                         if (session.getTransacted()) {
1:                     logger.info("Receiver " + Thread.currentThread().getName() + " shutting down.");
1:                     if (receiver != null) {
1:                         } catch (JMSException e) {
1:                     if (session != null) {
1:                         } catch (JMSException e) {
1:                     if (queueConnection != null) {
1:             } catch (JMSException e) {
/////////////////////////////////////////////////////////////////////////
1:         void onMessage(Message message) throws Exception;
commit:ef24cc9
commit:fd6be7f
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         }, TimeUnit.MINUTES.toMillis(7));
1: 
1: 
1: 
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1: 
0:                         } catch (JMSException e)  {
1:                             logger.warn(e);
0:                         } catch (JMSException e)  {
1:                             logger.warn(e);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:bfbe90b
/////////////////////////////////////////////////////////////////////////
author:Robert Davies
-------------------------------------------------------------------------------
commit:b403707
/////////////////////////////////////////////////////////////////////////
0:     private final static long TEST_MESSAGE_COUNT    = 6000;    // The number of test messages to use
commit:2b28443
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.bugs;
1: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.log4j.Logger;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import javax.jms.DeliveryMode;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.Queue;
1: import javax.jms.QueueConnection;
1: import javax.jms.QueueConnectionFactory;
1: import javax.jms.QueueReceiver;
1: import javax.jms.QueueSender;
1: import javax.jms.QueueSession;
1: import javax.jms.TextMessage;
1: import javax.naming.NamingException;
1: import junit.framework.TestCase;
1: /**
1:  * A AMQ1936Test
1:  *
1:  */
0: public class AMQ1936Test extends TestCase{
0:     private final static Logger logger = Logger.getLogger( AMQ1936Test.class );
0:     private final static String TEST_QUEUE_NAME     = "dynamicQueues/duplicate.message.test.queue";
0:     ////--
1:     //
0:     private final static long TEST_MESSAGE_COUNT    = 60000;    // The number of test messages to use
1:     //
0:     ////--
0:     private final static int CONSUMER_COUNT         = 2;        // The number of message receiver instances
0:     private final static boolean TRANSACTED_RECEIVE = true; // Flag used by receiver which indicates messages should be processed within a JMS transaction
1: 
0:     private ThreadPoolExecutor threadPool           = new ThreadPoolExecutor( CONSUMER_COUNT,CONSUMER_COUNT, Long.MAX_VALUE,TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>() );
0:     private ThreadedMessageReceiver[] receivers     = new ThreadedMessageReceiver[ CONSUMER_COUNT ];
0:     private BrokerService broker                    = null;
1:     static QueueConnectionFactory connectionFactory = null;
1:    
1:    
1: 
1:     @Override
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         
1:         broker = new BrokerService();
0:         broker.getSystemUsage().getMemoryUsage().setLimit(5*1024*1024);
1:         broker.setBrokerName("test");
1:         broker.setDeleteAllMessagesOnStartup(true);
1:         broker.start();
0:         connectionFactory        = new ActiveMQConnectionFactory("vm://test");;
1:     }
1: 
1:     @Override
1:     protected void tearDown() throws Exception {
1:         super.tearDown();
1:         
0:         if( threadPool!=null ) {
1:             // signal receivers to stop
0:             for( ThreadedMessageReceiver receiver: receivers) {
0:                 receiver.setShouldStop( true );
1:             }
1:             
1:             logger.info("Waiting for receivers to shutdown..");
0:             if( ! threadPool.awaitTermination( 10, TimeUnit.SECONDS ) ) {
1:                 logger.warn("Not all receivers completed shutdown.");
1:             } else {
1:                 logger.info("All receivers shutdown successfully..");
1:             }
1:         }
1:         
1:         logger.debug("Stoping the broker.");
1:         
0:         if( broker!=null ) {
1:             broker.stop();
1:         }
1:     }
1:     
0:     private void sendTextMessage( String queueName, String msg ) throws JMSException, NamingException {
0:         QueueConnectionFactory connectionFactory        = new ActiveMQConnectionFactory("vm://test");
0:         QueueConnection queueConnection                 = null;
0:         QueueSession session                            = null;
0:         QueueSender sender                              = null;
0:         Queue queue                                     = null;
0:         TextMessage message                                 = null;
1:         
1:         try {
1:             
1:             // Create the queue connection
1:             queueConnection = connectionFactory.createQueueConnection();
1:     
0:             session = queueConnection.createQueueSession( false, QueueSession.AUTO_ACKNOWLEDGE );
1:             queue = session.createQueue(TEST_QUEUE_NAME);
0:             sender = session.createSender( queue );
0:             sender.setDeliveryMode( DeliveryMode.PERSISTENT );
1: 
0:             message = session.createTextMessage( msg );
1:             
1:             // send the message
0:             sender.send( message );
1:     
0:             if( session.getTransacted()) {
1:                 session.commit();
1:             }
1: 
0:             logger.info( "Message successfully sent to : " + queue.getQueueName( ) + " messageid: " + message.getJMSMessageID( )
0:                         + " content:" + message.getText());
1:         } finally {
0:             if( sender!=null ) {
1:                 sender.close();
1:             }
0:             if( session!=null ) {
1:                 session.close();
1:             }
0:             if( queueConnection!=null ) {
1:                 queueConnection.close();
1:             }
1:         }
1:     }
1:      
1:     
0:     public void testForDuplicateMessages( ) throws Exception {
0:         final ConcurrentHashMap<String,String> messages = new ConcurrentHashMap<String, String>( );
0:         final Object lock                               = new Object( );
0:         final CountDownLatch duplicateSignal            = new CountDownLatch( 1 );
0:         final AtomicInteger messageCount                = new AtomicInteger( 0 );
1:         
1:         // add 1/2 the number of our total messages
0:         for( int i = 0; i < TEST_MESSAGE_COUNT/2; i++ ) {
0:             if( duplicateSignal.getCount()==0 ) {
0:                 fail( "Duplicate message id detected" );
1:             }
0:             sendTextMessage( TEST_QUEUE_NAME, String.valueOf(i) );
1:         }
1:         
0:         // create a number of consumers to read of the messages and start them with a handler which simply stores the message ids
1:         // in a Map and checks for a duplicate
0:         for( int i = 0; i < CONSUMER_COUNT; i++ ) {
0:             receivers[i] = new ThreadedMessageReceiver(TEST_QUEUE_NAME, new IMessageHandler( ) {
1:             
0:                 public void onMessage( Message message ) throws Exception {
0:                     synchronized( lock ) {
0:                         logger.info( "Received message:" + message.getJMSMessageID() +  " with content: " + ((TextMessage)message).getText() );
1: 
0:                         messageCount.incrementAndGet();
1:                         
0:                         if(  messages.containsKey( message.getJMSMessageID()) ) {
0:                             duplicateSignal.countDown( );
0:                             logger.fatal( "duplicate message id detected:" + message.getJMSMessageID() );
0:                             fail( "Duplicate message id detected:" + message.getJMSMessageID() );
1:                         } else {
0:                             messages.put( message.getJMSMessageID(), message.getJMSMessageID() );
1:                         }
1:                     }
1:                 }
1:             });
0:             threadPool.submit( receivers[i]);
1:         }
1:         
1:         // starting adding the remaining messages
0:         for(int i = 0; i < TEST_MESSAGE_COUNT/2; i++ ) {
0:             if( duplicateSignal.getCount()==0) {
0:                 fail( "Duplicate message id detected" );
1:             }
0:             sendTextMessage( TEST_QUEUE_NAME, String.valueOf( i ) );
1:         }
1: 
1:         // allow some time for messages to be delivered to receivers.
0:         Thread.sleep( 5000 );
1:         
0:         assertEquals( "Number of messages received does not match the number sent", TEST_MESSAGE_COUNT, messages.size( ) );
0:         assertEquals( TEST_MESSAGE_COUNT,  messageCount.get() );
1:     }
1:     
1:     private final static class ThreadedMessageReceiver implements Runnable {
1:        
0:         private String queueName            = null;
0:         private IMessageHandler handler     = null;
0:         private AtomicBoolean shouldStop    = new AtomicBoolean( false );
1:         
0:         public ThreadedMessageReceiver(String queueName, IMessageHandler handler ) {
1:          
0:             this.queueName      = queueName;
0:             this.handler        = handler;
1:         }
1: 
0:         public void run( ) {
1:            
0:             QueueConnection queueConnection                 = null;
0:             QueueSession session                            = null;
0:             QueueReceiver receiver                          = null;
0:             Queue queue                                     = null;
0:             Message message                                 = null;
1:             try {
1:                 try {
1:                  
0:                     queueConnection = connectionFactory.createQueueConnection( );
1:                     // create a transacted session
0:                     session = queueConnection.createQueueSession( TRANSACTED_RECEIVE, QueueSession.AUTO_ACKNOWLEDGE );
1:                     queue = session.createQueue(TEST_QUEUE_NAME);
0:                     receiver = session.createReceiver( queue );
1: 
1:                     // start the connection
0:                     queueConnection.start( );
1:                     
0:                     logger.info( "Receiver " + Thread.currentThread().getName() + " connected." );
1:                     
1:                     // start receive loop
0:                     while( ! ( shouldStop.get() || Thread.currentThread().isInterrupted()) ) {
1:                         try {
0:                             message = receiver.receive( 200 );
0:                         } catch( Exception e) {
1:                             //
1:                             // ignore interrupted exceptions
1:                             //
0:                             if( e instanceof InterruptedException || e.getCause() instanceof InterruptedException ) {
1:                                 /* ignore */
1:                             } else {
1:                                 throw e;
1:                             }
1:                         }
1:                         
0:                         if( message!=null && this.handler!=null ) {
1:                             this.handler.onMessage(message);
1:                         }
1:                         
1:                         // commit session on successful handling of message
0:                         if( session.getTransacted()) {
1:                             session.commit();
1:                         }
1:                     }
1:                     
0:                     logger.info( "Receiver " + Thread.currentThread().getName() + " shutting down." );
1:                     
1:                 } finally {
0:                     if( receiver!=null ) {
1:                         try {
1:                             receiver.close();
0:                         } catch (JMSException e)  { 
0:                             logger.warn(e); 
1:                         }
1:                     }
0:                     if( session!=null ) {
1:                         try {
1:                             session.close();
0:                         } catch (JMSException e)  { 
0:                             logger.warn(e); 
1:                         }
1:                     }
0:                     if( queueConnection!=null ) {
1:                         queueConnection.close();
1:                     }
1:                 }
0:             } catch ( JMSException e ) {
1:                 logger.error(e);
1:                 e.printStackTrace();
1:             } catch (NamingException e) {
1:                 logger.error(e);
1:             } catch (Exception e) {
1:                 logger.error(e);
1:                 e.printStackTrace();
1:             }
1:         }
1: 
0:         public Boolean getShouldStop() {
0:             return shouldStop.get();
1:         }
1: 
1:         public void setShouldStop(Boolean shouldStop) {
1:             this.shouldStop.set(shouldStop);
1:         }
1:     }
1:     
1:     public interface IMessageHandler {
0:         void onMessage( Message message ) throws Exception;
1:     }
1:     
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:2b0a194
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.AutoFailTestSupport;
/////////////////////////////////////////////////////////////////////////
1:             AutoFailTestSupport.dumpAllThreads("--STUCK?--");
0:     
commit:c204304
/////////////////////////////////////////////////////////////////////////
0: 
0: import java.util.Map;
0: import java.util.Map.Entry;
/////////////////////////////////////////////////////////////////////////
0:     private void sendTextMessage( String queueName, int i ) throws JMSException, NamingException {
/////////////////////////////////////////////////////////////////////////
0:             message = session.createTextMessage( String.valueOf(i) );
/////////////////////////////////////////////////////////////////////////
0:             if (i%1000 == 0) {
0:                 logger.info( "Message successfully sent to : " + queue.getQueueName( ) + " messageid: " + message.getJMSMessageID( )
1:             }
/////////////////////////////////////////////////////////////////////////
0:             sendTextMessage( TEST_QUEUE_NAME, i );
/////////////////////////////////////////////////////////////////////////
1:                         int current = messageCount.incrementAndGet();
1:                         if (current % 1000 == 0) {
0:                             logger.info( "Received message:" + message.getJMSMessageID() +  " with content: " + ((TextMessage)message).getText() );
1:                         }
/////////////////////////////////////////////////////////////////////////
0:             sendTextMessage( TEST_QUEUE_NAME, i );
0:         
1:         logger.info("sent all " + TEST_MESSAGE_COUNT + " messages");
0:         
1:         boolean ok = Wait.waitFor(new Wait.Condition() {
0:         }, 20*60*1000);
1:         if (!ok) {
0:             dumpAllThreads("--STUCK?--");
1:         }
0:     
0:     private void dumpAllThreads(String prefix) {
0:         Map<Thread, StackTraceElement[]> stacks = Thread.getAllStackTraces();
0:         for (Entry<Thread, StackTraceElement[]> stackEntry : stacks.entrySet()) {
0:             System.err.println(prefix + stackEntry.getKey());
0:             for(StackTraceElement element : stackEntry.getValue()) {
0:                 System.err.println("     " + element);
1:             }
1:         }
0:         
1:     }
commit:a27709b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
0:         Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return TEST_MESSAGE_COUNT == messages.size();
0:             }
0:         });
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:813d590
/////////////////////////////////////////////////////////////////////////
0:         }, 1*60*1000);
============================================================================