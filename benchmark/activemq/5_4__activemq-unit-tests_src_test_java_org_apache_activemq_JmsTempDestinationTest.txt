1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
1:f812e34:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:f812e34:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq;
1:f812e34: 
1:ba9037c: import java.io.IOException;
1:14b8957: import java.net.URISyntaxException;
1:74a7a8b: import java.util.ArrayList;
1:14b8957: import java.util.Collections;
1:14b8957: import java.util.Iterator;
1:14b8957: import java.util.List;
1:ba9037c: import java.util.concurrent.CountDownLatch;
1:ba9037c: import java.util.concurrent.TimeUnit;
1:ba9037c: import java.util.concurrent.atomic.AtomicBoolean;
20:d29ca2a: 
1:05a8cba: import javax.jms.BytesMessage;
1:05a8cba: import javax.jms.Connection;
1:05a8cba: import javax.jms.DeliveryMode;
1:05a8cba: import javax.jms.InvalidDestinationException;
1:05a8cba: import javax.jms.JMSException;
1:05a8cba: import javax.jms.Message;
1:05a8cba: import javax.jms.MessageConsumer;
1:05a8cba: import javax.jms.MessageProducer;
1:05a8cba: import javax.jms.Queue;
1:05a8cba: import javax.jms.Session;
1:05a8cba: import javax.jms.TemporaryQueue;
1:05a8cba: import javax.jms.TextMessage;
1:74a7a8b: 
1:74a7a8b: import junit.framework.TestCase;
1:c7d559f: 
1:ba9037c: import org.apache.activemq.transport.TransportListener;
1:ba9037c: import org.apache.activemq.transport.vm.VMTransport;
1:215dd18: import org.apache.activemq.util.Wait;
1:ba9037c: import org.slf4j.Logger;
1:ba9037c: import org.slf4j.LoggerFactory;
1:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  * @version
1:d29ca2a:  */
1:d29ca2a: public class JmsTempDestinationTest extends TestCase {
1:d29ca2a: 
1:ba9037c:     private static final Logger LOG = LoggerFactory.getLogger(JmsTempDestinationTest.class);
1:d29ca2a:     private Connection connection;
1:d29ca2a:     private ActiveMQConnectionFactory factory;
1:14b8957:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
1:d29ca2a: 
1:c7d559f:     @Override
1:d29ca2a:     protected void setUp() throws Exception {
1:d29ca2a:         factory = new ActiveMQConnectionFactory("vm://localhost?broker.persistent=false");
1:b5df4ba:         factory.setAlwaysSyncSend(true);
1:d29ca2a:         connection = factory.createConnection();
1:14b8957:         connections.add(connection);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @see junit.framework.TestCase#tearDown()
1:d29ca2a:      */
1:c7d559f:     @Override
1:d29ca2a:     protected void tearDown() throws Exception {
1:c7d559f:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:c7d559f:             Connection conn = iter.next();
1:14b8957:             try {
1:14b8957:                 conn.close();
1:14b8957:             } catch (Throwable e) {
1:14b8957:             }
1:14b8957:             iter.remove();
1:86cbdfd:         }
1:d29ca2a:     }
1:b5df4ba: 
1:d29ca2a:     /**
1:d29ca2a:      * Make sure Temp destination can only be consumed by local connection
1:c7d559f:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testTempDestOnlyConsumedByLocalConn() throws JMSException {
2:d29ca2a:         connection.start();
1:14b8957: 
1:d29ca2a:         Session tempSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
3:d29ca2a:         TemporaryQueue queue = tempSession.createTemporaryQueue();
1:d29ca2a:         MessageProducer producer = tempSession.createProducer(queue);
1:d29ca2a:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:d29ca2a:         TextMessage message = tempSession.createTextMessage("First");
1:d29ca2a:         producer.send(message);
1:d29ca2a: 
1:f812e34:         // temp destination should not be consume when using another connection
1:d29ca2a:         Connection otherConnection = factory.createConnection();
1:14b8957:         connections.add(otherConnection);
1:d29ca2a:         Session otherSession = otherConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         TemporaryQueue otherQueue = otherSession.createTemporaryQueue();
1:d29ca2a:         MessageConsumer consumer = otherSession.createConsumer(otherQueue);
1:d29ca2a:         Message msg = consumer.receive(3000);
1:d29ca2a:         assertNull(msg);
1:d29ca2a: 
1:f812e34:         // should throw InvalidDestinationException when consuming a temp
1:f812e34:         // destination from another connection
1:f812e34:         try {
1:f812e34:             consumer = otherSession.createConsumer(queue);
1:f812e34:             fail("Send should fail since temp destination should be used from another connection");
1:f812e34:         } catch (InvalidDestinationException e) {
1:f812e34:             assertTrue("failed to throw an exception", true);
1:d29ca2a:         }
1:d29ca2a: 
1:f812e34:         // should be able to consume temp destination from the same connection
1:d29ca2a:         consumer = tempSession.createConsumer(queue);
1:d29ca2a:         msg = consumer.receive(3000);
1:d29ca2a:         assertNotNull(msg);
1:d29ca2a: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Make sure that a temp queue does not drop message if there is an active
1:d29ca2a:      * consumers.
1:c7d559f:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testTempQueueHoldsMessagesWithConsumers() throws JMSException {
2:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         Queue queue = session.createTemporaryQueue();
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(queue);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:d29ca2a:         MessageProducer producer = session.createProducer(queue);
1:d29ca2a:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:d29ca2a:         TextMessage message = session.createTextMessage("Hello");
1:d29ca2a:         producer.send(message);
1:d29ca2a: 
1:d29ca2a:         Message message2 = consumer.receive(1000);
1:d29ca2a:         assertNotNull(message2);
1:d29ca2a:         assertTrue("Expected message to be a TextMessage", message2 instanceof TextMessage);
1:f812e34:         assertTrue("Expected message to be a '" + message.getText() + "'", ((TextMessage)message2).getText().equals(message.getText()));
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Make sure that a temp queue does not drop message if there are no active
1:d29ca2a:      * consumers.
1:c7d559f:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testTempQueueHoldsMessagesWithoutConsumers() throws JMSException {
1:d29ca2a: 
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         Queue queue = session.createTemporaryQueue();
1:d29ca2a:         MessageProducer producer = session.createProducer(queue);
1:d29ca2a:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:d29ca2a:         TextMessage message = session.createTextMessage("Hello");
1:d29ca2a:         producer.send(message);
1:d29ca2a: 
1:d29ca2a:         connection.start();
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(queue);
1:d29ca2a:         Message message2 = consumer.receive(3000);
1:d29ca2a:         assertNotNull(message2);
1:d29ca2a:         assertTrue("Expected message to be a TextMessage", message2 instanceof TextMessage);
1:f812e34:         assertTrue("Expected message to be a '" + message.getText() + "'", ((TextMessage)message2).getText().equals(message.getText()));
1:f812e34: 
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Test temp queue works under load
1:c7d559f:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testTmpQueueWorksUnderLoad() throws JMSException {
1:d29ca2a:         int count = 500;
1:d29ca2a:         int dataSize = 1024;
1:f812e34: 
1:c7d559f:         ArrayList<BytesMessage> list = new ArrayList<BytesMessage>(count);
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         Queue queue = session.createTemporaryQueue();
1:d29ca2a:         MessageProducer producer = session.createProducer(queue);
1:d29ca2a:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:f812e34: 
1:d29ca2a:         byte[] data = new byte[dataSize];
1:f812e34:         for (int i = 0; i < count; i++) {
1:d29ca2a:             BytesMessage message = session.createBytesMessage();
1:d29ca2a:             message.writeBytes(data);
1:14b8957:             message.setIntProperty("c", i);
1:d29ca2a:             producer.send(message);
1:d29ca2a:             list.add(message);
1:d29ca2a:         }
1:f812e34: 
1:d29ca2a:         connection.start();
1:d29ca2a:         MessageConsumer consumer = session.createConsumer(queue);
1:f812e34:         for (int i = 0; i < count; i++) {
1:d29ca2a:             Message message2 = consumer.receive(2000);
1:d29ca2a:             assertTrue(message2 != null);
1:14b8957:             assertEquals(i, message2.getIntProperty("c"));
1:d29ca2a:             assertTrue(message2.equals(list.get(i)));
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:f812e34:      * Make sure you cannot publish to a temp destination that does not exist
1:f812e34:      * anymore.
1:c7d559f:      *
1:d29ca2a:      * @throws JMSException
1:f812e34:      * @throws InterruptedException
1:c7d559f:      * @throws URISyntaxException
1:d29ca2a:      */
1:591c1a5:     public void testPublishFailsForClosedConnection() throws Exception {
1:c7d559f: 
1:d29ca2a:         Connection tempConnection = factory.createConnection();
1:14b8957:         connections.add(tempConnection);
1:f812e34:         Session tempSession = tempConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:591c1a5:         final TemporaryQueue queue = tempSession.createTemporaryQueue();
1:14b8957: 
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:f812e34:         connection.start();
1:f812e34: 
1:591c1a5:         final ActiveMQConnection activeMQConnection = (ActiveMQConnection) connection;
1:591c1a5:         assertTrue("creation advisory received in time with async dispatch", Wait.waitFor(new Wait.Condition() {
1:591c1a5:             @Override
1:591c1a5:             public boolean isSatisified() throws Exception {
1:591c1a5:                 return activeMQConnection.activeTempDestinations.containsKey(queue);
1:d29ca2a:             }
1:591c1a5:         }));
1:f812e34: 
1:f812e34:         // This message delivery should work since the temp connection is still
1:f812e34:         // open.
1:d29ca2a:         MessageProducer producer = session.createProducer(queue);
1:d29ca2a:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:d29ca2a:         TextMessage message = session.createTextMessage("First");
1:d29ca2a:         producer.send(message);
1:f812e34: 
1:f812e34:         // Closing the connection should destroy the temp queue that was
1:f812e34:         // created.
1:d29ca2a:         tempConnection.close();
1:bcacddf:         Thread.sleep(5000); // Wait a little bit to let the delete take effect.
1:f812e34: 
1:f812e34:         // This message delivery NOT should work since the temp connection is
1:f812e34:         // now closed.
1:d29ca2a:         try {
1:d29ca2a:             message = session.createTextMessage("Hello");
1:d29ca2a:             producer.send(message);
1:d29ca2a:             fail("Send should fail since temp destination should not exist anymore.");
1:f812e34:         } catch (JMSException e) {
1:d29ca2a:         }
1:d29ca2a:     }
1:f812e34: 
1:d29ca2a:     /**
1:f812e34:      * Make sure you cannot publish to a temp destination that does not exist
1:f812e34:      * anymore.
1:c7d559f:      *
1:d29ca2a:      * @throws JMSException
1:f812e34:      * @throws InterruptedException
1:d29ca2a:      */
1:215dd18:     public void testPublishFailsForDestroyedTempDestination() throws Exception {
1:f812e34: 
1:d29ca2a:         Connection tempConnection = factory.createConnection();
1:14b8957:         connections.add(tempConnection);
1:f812e34:         Session tempSession = tempConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:215dd18:         final TemporaryQueue queue = tempSession.createTemporaryQueue();
1:f812e34: 
1:f812e34:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:f812e34:         connection.start();
1:f812e34: 
1:215dd18:         final ActiveMQConnection activeMQConnection = (ActiveMQConnection) connection;
1:215dd18:         assertTrue("creation advisory received in time with async dispatch", Wait.waitFor(new Wait.Condition() {
1:215dd18:             @Override
1:215dd18:             public boolean isSatisified() throws Exception {
1:215dd18:                 return activeMQConnection.activeTempDestinations.containsKey(queue);
1:591c1a5:             }
1:215dd18:         }));
1:d29ca2a: 
1:f812e34:         // This message delivery should work since the temp connection is still
1:f812e34:         // open.
1:d29ca2a:         MessageProducer producer = session.createProducer(queue);
1:d29ca2a:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:d29ca2a:         TextMessage message = session.createTextMessage("First");
1:d29ca2a:         producer.send(message);
1:d29ca2a: 
1:d29ca2a:         // deleting the Queue will cause sends to fail
1:d29ca2a:         queue.delete();
1:bcacddf:         Thread.sleep(5000); // Wait a little bit to let the delete take effect.
1:f812e34: 
1:f812e34:         // This message delivery NOT should work since the temp connection is
1:f812e34:         // now closed.
1:d29ca2a:         try {
1:d29ca2a:             message = session.createTextMessage("Hello");
1:d29ca2a:             producer.send(message);
1:d29ca2a:             fail("Send should fail since temp destination should not exist anymore.");
1:f812e34:         } catch (JMSException e) {
1:f812e34:             assertTrue("failed to throw an exception", true);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Test you can't delete a Destination with Active Subscribers
1:c7d559f:      *
1:d29ca2a:      * @throws JMSException
1:d29ca2a:      */
1:d29ca2a:     public void testDeleteDestinationWithSubscribersFails() throws JMSException {
1:d29ca2a:         Connection connection = factory.createConnection();
1:14b8957:         connections.add(connection);
1:f812e34:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a:         TemporaryQueue queue = session.createTemporaryQueue();
1:f812e34: 
1:f812e34:         connection.start();
1:f812e34: 
1:d29ca2a:         session.createConsumer(queue);
1:f812e34: 
1:f812e34:         // This message delivery should NOT work since the temp connection is
1:f812e34:         // now closed.
1:d29ca2a:         try {
1:d29ca2a:             queue.delete();
1:d29ca2a:             fail("Should fail as Subscribers are active");
1:f812e34:         } catch (JMSException e) {
2:f812e34:             assertTrue("failed to throw an exception", true);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:ba9037c:     public void testSlowConsumerDoesNotBlockFastTempUsers() throws Exception {
1:ba9037c:         ActiveMQConnectionFactory advisoryConnFactory = new ActiveMQConnectionFactory("vm://localhost?asyncQueueDepth=20");
1:ba9037c:         Connection connection = advisoryConnFactory.createConnection();
1:ba9037c:         connections.add(connection);
1:d29ca2a:         connection.start();
1:d29ca2a: 
1:ba9037c:         final CountDownLatch done = new CountDownLatch(1);
1:ba9037c:         final AtomicBoolean ok = new AtomicBoolean(true);
1:ba9037c:         final AtomicBoolean first = new AtomicBoolean(true);
1:ba9037c:         VMTransport t = ((ActiveMQConnection)connection).getTransport().narrow(VMTransport.class);
1:ba9037c:         t.setTransportListener(new TransportListener() {
1:ba9037c:             @Override
1:ba9037c:             public void onCommand(Object command) {
1:ba9037c:                 // block first dispatch for a while so broker backs up, but other connection should be able to proceed
1:ba9037c:                 if (first.compareAndSet(true, false)) {
1:ba9037c:                     try {
1:ba9037c:                         ok.set(done.await(35, TimeUnit.SECONDS));
1:ba9037c:                         LOG.info("Done waiting: " + ok.get());
1:ba9037c:                     } catch (InterruptedException e) {
1:ba9037c:                         e.printStackTrace();
1:d29ca2a:                     }
1:215dd18:                 }
2:ba9037c:             }
1:d29ca2a: 
1:ba9037c:             @Override
1:ba9037c:             public void onException(IOException error) {
1:ba9037c:             }
1:d29ca2a: 
1:ba9037c:             @Override
1:ba9037c:             public void transportInterupted() {
1:ba9037c:             }
1:d29ca2a: 
1:ba9037c:             @Override
1:ba9037c:             public void transportResumed() {
1:ba9037c:             }
1:ba9037c:         });
1:d29ca2a: 
1:ba9037c:         connection = factory.createConnection();
1:ba9037c:         connections.add(connection);
1:ba9037c:         ((ActiveMQConnection)connection).setWatchTopicAdvisories(false);
1:d29ca2a:         connection.start();
1:d29ca2a:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:d29ca2a: 
1:ba9037c:         for (int i=0; i<2500; i++) {
1:ba9037c:             TemporaryQueue queue = session.createTemporaryQueue();
1:ba9037c:             MessageConsumer consumer = session.createConsumer(queue);
1:ba9037c:             consumer.close();
1:ba9037c:             queue.delete();
1:ba9037c:         }
1:ba9037c:         LOG.info("Done with work: " + ok.get());
1:ba9037c:         done.countDown();
1:ba9037c:         assertTrue("ok", ok.get());
1:ba9037c:     }
1:ba9037c: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:c7d559f
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         for (Iterator<Connection> iter = connections.iterator(); iter.hasNext();) {
1:             Connection conn = iter.next();
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
1:         ArrayList<BytesMessage> list = new ArrayList<BytesMessage>(count);
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws URISyntaxException
1: 
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
commit:ef24cc9
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:bfbe90b
/////////////////////////////////////////////////////////////////////////
commit:bcacddf
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(5000); // Wait a little bit to let the delete take effect.
/////////////////////////////////////////////////////////////////////////
1:         Thread.sleep(5000); // Wait a little bit to let the delete take effect.
commit:b5df4ba
/////////////////////////////////////////////////////////////////////////
1:         factory.setAlwaysSyncSend(true);
/////////////////////////////////////////////////////////////////////////
1: 
commit:14b8957
/////////////////////////////////////////////////////////////////////////
0: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.util.Collections;
0: import java.util.Date;
1: import java.util.Iterator;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     protected List<Connection> connections = Collections.synchronizedList(new ArrayList<Connection>());
1:         connections.add(connection);
0:         for (Iterator iter = connections.iterator(); iter.hasNext();) {
0:             Connection conn = (Connection)iter.next();
1:             try {
1:                 conn.close();
1:             } catch (Throwable e) {
1:             }
1:             iter.remove();
1:     
/////////////////////////////////////////////////////////////////////////
1:         connections.add(otherConnection);
/////////////////////////////////////////////////////////////////////////
1:             message.setIntProperty("c", i);
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(i, message2.getIntProperty("c"));
/////////////////////////////////////////////////////////////////////////
0:      * @throws URISyntaxException 
0:     public void testPublishFailsForClosedConnection() throws JMSException, InterruptedException, URISyntaxException {
1:         
1:         connections.add(tempConnection);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         connections.add(tempConnection);
/////////////////////////////////////////////////////////////////////////
1:         connections.add(connection);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: 
1: import junit.framework.TestCase;
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1:      * 
/////////////////////////////////////////////////////////////////////////
1:         // temp destination should not be consume when using another connection
/////////////////////////////////////////////////////////////////////////
1:         // should throw InvalidDestinationException when consuming a temp
1:         // destination from another connection
1:         try {
1:             consumer = otherSession.createConsumer(queue);
1:             fail("Send should fail since temp destination should be used from another connection");
1:         } catch (InvalidDestinationException e) {
1:             assertTrue("failed to throw an exception", true);
1:         // should be able to consume temp destination from the same connection
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("Expected message to be a '" + message.getText() + "'", ((TextMessage)message2).getText().equals(message.getText()));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("Expected message to be a '" + message.getText() + "'", ((TextMessage)message2).getText().equals(message.getText()));
1: 
1:      * 
1: 
1: 
1:         for (int i = 0; i < count; i++) {
1:         for (int i = 0; i < count; i++) {
1: 
1: 
1:      * Make sure you cannot publish to a temp destination that does not exist
1:      * anymore.
1:      * @throws InterruptedException
1: 
1:         Session tempSession = tempConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         connection.start();
1: 
1:         // This message delivery should work since the temp connection is still
1:         // open.
1:         // Closing the connection should destroy the temp queue that was
1:         // created.
1: 
1:         // This message delivery NOT should work since the temp connection is
1:         // now closed.
1:         } catch (JMSException e) {
1:             assertTrue("failed to throw an exception", true);
1: 
1:      * Make sure you cannot publish to a temp destination that does not exist
1:      * anymore.
1:      * @throws InterruptedException
1: 
1:         Session tempSession = tempConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.start();
1: 
1:         // This message delivery should work since the temp connection is still
1:         // open.
/////////////////////////////////////////////////////////////////////////
1: 
1:         // This message delivery NOT should work since the temp connection is
1:         // now closed.
1:         } catch (JMSException e) {
1:             assertTrue("failed to throw an exception", true);
1: 
0:      * 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1: 
1:         connection.start();
1: 
1: 
1:         // This message delivery should NOT work since the temp connection is
1:         // now closed.
1:         } catch (JMSException e) {
1:             assertTrue("failed to throw an exception", true);
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:ea74731
/////////////////////////////////////////////////////////////////////////
0:      * @throws InterruptedException 
0:     public void testPublishFailsForClosedConnection() throws JMSException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(1000); // Wait a little bit to let the delete take effect.
commit:421b911
/////////////////////////////////////////////////////////////////////////
0:      * @throws InterruptedException 
0:     public void testPublishFailsForDestoryedTempDestination() throws JMSException, InterruptedException {
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(1000); // Wait a little bit to let the delete take effect.
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
1: }
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq;
1: 
0: import java.util.ArrayList;
0: import javax.jms.*;
1: 
0: import org.apache.activemq.ActiveMQConnectionFactory;
1: 
0: import junit.framework.TestCase;
1: 
1: /**
1:  * @version
1:  */
1: public class JmsTempDestinationTest extends TestCase {
1: 
1:     private Connection connection;
1:     private ActiveMQConnectionFactory factory;
1: 
1:     protected void setUp() throws Exception {
1:         factory = new ActiveMQConnectionFactory("vm://localhost?broker.persistent=false");
0:         factory.setUseAsyncSend(false);
1:         connection = factory.createConnection();
1:     }
1: 
1:     /**
1:      * @see junit.framework.TestCase#tearDown()
1:      */
1:     protected void tearDown() throws Exception {
0:         if (connection != null) {
0:             connection.close();
0:             connection = null;
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Make sure Temp destination can only be consumed by local connection
0:      *
1:      * @throws JMSException
1:      */
1:     public void testTempDestOnlyConsumedByLocalConn() throws JMSException {
1:         connection.start();
1: 
1:         Session tempSession = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         TemporaryQueue queue = tempSession.createTemporaryQueue();
1:         MessageProducer producer = tempSession.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         TextMessage message = tempSession.createTextMessage("First");
1:         producer.send(message);
1: 
0:         //temp destination should not be consume  when using another connection
1:         Connection otherConnection = factory.createConnection();
1:         Session otherSession = otherConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         TemporaryQueue otherQueue = otherSession.createTemporaryQueue();
1:         MessageConsumer consumer = otherSession.createConsumer(otherQueue);
1:         Message msg = consumer.receive(3000);
1:         assertNull(msg);
1: 
0:         //should throw InvalidDestinationException when consuming a temp destination from another connection
0:         try{
0:              consumer = otherSession.createConsumer(queue);
0:              fail("Send should fail since temp destination should be used from another connection");
0:         }catch(InvalidDestinationException e){
0:               assertTrue("failed to throw an exception",true);
1:         }
1: 
1: 
0:         //should be able to consume temp destination from the same connection
1:         consumer = tempSession.createConsumer(queue);
1:         msg = consumer.receive(3000);
1:         assertNotNull(msg);
1: 
1: 
1:     }
1: 
1:     /**
1:      * Make sure that a temp queue does not drop message if there is an active
1:      * consumers.
0:      * 
1:      * @throws JMSException
1:      */
1:     public void testTempQueueHoldsMessagesWithConsumers() throws JMSException {
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createTemporaryQueue();
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         connection.start();
1: 
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         TextMessage message = session.createTextMessage("Hello");
1:         producer.send(message);
1: 
1:         Message message2 = consumer.receive(1000);
1:         assertNotNull(message2);
1:         assertTrue("Expected message to be a TextMessage", message2 instanceof TextMessage);
0:         assertTrue("Expected message to be a '" + message.getText() + "'", 
0:                 ((TextMessage) message2).getText().equals(message.getText()));
1:     }
1: 
1:     /**
1:      * Make sure that a temp queue does not drop message if there are no active
1:      * consumers.
0:      * 
1:      * @throws JMSException
1:      */
1:     public void testTempQueueHoldsMessagesWithoutConsumers() throws JMSException {
1: 
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createTemporaryQueue();
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         TextMessage message = session.createTextMessage("Hello");
1:         producer.send(message);
1: 
1:         connection.start();
1:         MessageConsumer consumer = session.createConsumer(queue);
1:         Message message2 = consumer.receive(3000);
1:         assertNotNull(message2);
1:         assertTrue("Expected message to be a TextMessage", message2 instanceof TextMessage);
0:         assertTrue("Expected message to be a '" + message.getText() + "'", 
0:                 ((TextMessage) message2).getText().equals(message.getText()));
1: 
1:     }
1:     
1:     /**
1:      * Test temp queue works under load
1:      * @throws JMSException
1:      */
1:     public void testTmpQueueWorksUnderLoad() throws JMSException {
1:         int count = 500;
1:         int dataSize = 1024;
1:         
0:         ArrayList list = new ArrayList(count);
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue queue = session.createTemporaryQueue();
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:       
1:         byte[] data = new byte[dataSize];
0:         for (int i =0; i < count; i++){
1:             BytesMessage message = session.createBytesMessage();
1:             message.writeBytes(data);
1:             producer.send(message);
1:             list.add(message);
1:         }
1:         
1: 
1:         connection.start();
1:         MessageConsumer consumer = session.createConsumer(queue);
0:         for (int i =0; i < count; i++){
1:             Message message2 = consumer.receive(2000);
1:             
1:             assertTrue(message2 != null);
1:             assertTrue(message2.equals(list.get(i)));
1:         }
1:     }
1:     
1:     /**
0:      * Make sure you cannot publish to a temp destination that does not exist anymore.
0:      * 
1:      * @throws JMSException
1:      */
0:     public void testPublishFailsForClosedConnection() throws JMSException {
1:         
1:         Connection tempConnection = factory.createConnection();
0:         Session tempSession = tempConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);        
1:         TemporaryQueue queue = tempSession.createTemporaryQueue();
1:         
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         connection.start();        
1:         
0:         // This message delivery should work since the temp connection is still open.
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         TextMessage message = session.createTextMessage("First");
1:         producer.send(message);
1: 
0:         // Closing the connection should destroy the temp queue that was created.
1:         tempConnection.close();
1:         
0:         // This message delivery NOT should work since the temp connection is now closed.
1:         try {
1:             message = session.createTextMessage("Hello");
1:             producer.send(message);
1:             fail("Send should fail since temp destination should not exist anymore.");
0:         } catch ( JMSException e ) {      
0:             assertTrue("failed to throw an exception",true);
1:         }
1:     }
1:     
1:     /**
0:      * Make sure you cannot publish to a temp destination that does not exist anymore.
0:      * 
1:      * @throws JMSException
1:      */
0:     public void testPublishFailsForDestoryedTempDestination() throws JMSException {
1:         
1:         Connection tempConnection = factory.createConnection();
0:         Session tempSession = tempConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);        
1:         TemporaryQueue queue = tempSession.createTemporaryQueue();
1:         
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);        
1:         connection.start();        
1:         
0:         // This message delivery should work since the temp connection is still open.
1:         MessageProducer producer = session.createProducer(queue);
1:         producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
1:         TextMessage message = session.createTextMessage("First");
1:         producer.send(message);
1: 
1:         // deleting the Queue will cause sends to fail
1:         queue.delete();
1:         
0:         // This message delivery NOT should work since the temp connection is now closed.
1:         try {
1:             message = session.createTextMessage("Hello");
1:             producer.send(message);
1:             fail("Send should fail since temp destination should not exist anymore.");
0:         } catch ( JMSException e ) {      
0:             assertTrue("failed to throw an exception",true);
1:         }
1:     }
1:     
1:     /**
1:      * Test you can't delete a Destination with Active Subscribers
1:      * @throws JMSException
1:      */
1:     public void testDeleteDestinationWithSubscribersFails() throws JMSException {
1:         Connection connection = factory.createConnection();
1:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);        
1:         TemporaryQueue queue = session.createTemporaryQueue();
1:           
1:         connection.start();        
1:         
1:         session.createConsumer(queue);
1:         
0:         // This message delivery should NOT work since the temp connection is now closed.
1:         try {
1:             queue.delete();
1:             fail("Should fail as Subscribers are active");
0:         } catch ( JMSException e ) {      
0:             assertTrue("failed to throw an exception",true);
1:         }
1:     }
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:591c1a5
/////////////////////////////////////////////////////////////////////////
1:     public void testPublishFailsForClosedConnection() throws Exception {
1:         final TemporaryQueue queue = tempSession.createTemporaryQueue();
1:         final ActiveMQConnection activeMQConnection = (ActiveMQConnection) connection;
1:         assertTrue("creation advisory received in time with async dispatch", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return activeMQConnection.activeTempDestinations.containsKey(queue);
1:             }
1:         }));
0: 
commit:215dd18
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
1:     public void testPublishFailsForDestroyedTempDestination() throws Exception {
1:         final TemporaryQueue queue = tempSession.createTemporaryQueue();
1:         final ActiveMQConnection activeMQConnection = (ActiveMQConnection) connection;
1:         assertTrue("creation advisory received in time with async dispatch", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return activeMQConnection.activeTempDestinations.containsKey(queue);
1:             }
1:         }));
0: 
commit:ba9037c
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.transport.TransportListener;
1: import org.apache.activemq.transport.vm.VMTransport;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(JmsTempDestinationTest.class);
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void testSlowConsumerDoesNotBlockFastTempUsers() throws Exception {
1:         ActiveMQConnectionFactory advisoryConnFactory = new ActiveMQConnectionFactory("vm://localhost?asyncQueueDepth=20");
1:         Connection connection = advisoryConnFactory.createConnection();
1:         connections.add(connection);
0:         connection.start();
0: 
1:         final CountDownLatch done = new CountDownLatch(1);
1:         final AtomicBoolean ok = new AtomicBoolean(true);
1:         final AtomicBoolean first = new AtomicBoolean(true);
1:         VMTransport t = ((ActiveMQConnection)connection).getTransport().narrow(VMTransport.class);
1:         t.setTransportListener(new TransportListener() {
1:             @Override
1:             public void onCommand(Object command) {
1:                 // block first dispatch for a while so broker backs up, but other connection should be able to proceed
1:                 if (first.compareAndSet(true, false)) {
1:                     try {
1:                         ok.set(done.await(35, TimeUnit.SECONDS));
1:                         LOG.info("Done waiting: " + ok.get());
1:                     } catch (InterruptedException e) {
1:                         e.printStackTrace();
1:                     }
1:                 }
1:             }
0: 
1:             @Override
1:             public void onException(IOException error) {
1:             }
0: 
1:             @Override
1:             public void transportInterupted() {
1:             }
0: 
1:             @Override
1:             public void transportResumed() {
1:             }
1:         });
0: 
1:         connection = factory.createConnection();
1:         connections.add(connection);
1:         ((ActiveMQConnection)connection).setWatchTopicAdvisories(false);
0:         connection.start();
0:         Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0: 
1:         for (int i=0; i<2500; i++) {
1:             TemporaryQueue queue = session.createTemporaryQueue();
1:             MessageConsumer consumer = session.createConsumer(queue);
1:             consumer.close();
1:             queue.delete();
1:         }
1:         LOG.info("Done with work: " + ok.get());
1:         done.countDown();
1:         assertTrue("ok", ok.get());
1:     }
author:James Strachan
-------------------------------------------------------------------------------
commit:cdfb3c0
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(2000); // Wait a little bit to let the delete take effect.
commit:05a8cba
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.BytesMessage;
1: import javax.jms.Connection;
1: import javax.jms.DeliveryMode;
1: import javax.jms.InvalidDestinationException;
1: import javax.jms.JMSException;
1: import javax.jms.Message;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Queue;
1: import javax.jms.Session;
1: import javax.jms.TemporaryQueue;
1: import javax.jms.TextMessage;
0: import java.util.ArrayList;
0: 
============================================================================