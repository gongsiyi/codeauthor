1:383d12e: /**
1:383d12e:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:383d12e:  * contributor license agreements.  See the NOTICE file distributed with
1:383d12e:  * this work for additional information regarding copyright ownership.
1:383d12e:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:383d12e:  * (the "License"); you may not use this file except in compliance with
1:383d12e:  * the License.  You may obtain a copy of the License at
1:383d12e:  *
1:383d12e:  *      http://www.apache.org/licenses/LICENSE-2.0
1:383d12e:  *
1:383d12e:  * Unless required by applicable law or agreed to in writing, software
1:383d12e:  * distributed under the License is distributed on an "AS IS" BASIS,
1:383d12e:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:383d12e:  * See the License for the specific language governing permissions and
1:383d12e:  * limitations under the License.
1:383d12e:  */
1:1b6d397: package org.apache.activemq.broker.region.policy;
14:1b6d397: 
1:cdb7bb1: import java.util.ArrayList;
1:1b6d397: import java.util.HashMap;
1:cdb7bb1: import java.util.List;
1:1b6d397: import java.util.Map;
1:1b6d397: import java.util.Map.Entry;
1:1b6d397: import java.util.concurrent.ConcurrentHashMap;
1:1b6d397: import java.util.concurrent.atomic.AtomicBoolean;
1:383d12e: 
1:383d12e: import org.apache.activemq.broker.Broker;
1:1b6d397: import org.apache.activemq.broker.Connection;
1:1b6d397: import org.apache.activemq.broker.ConnectionContext;
1:2b99f39: import org.apache.activemq.broker.region.Destination;
1:1b6d397: import org.apache.activemq.broker.region.Subscription;
1:1b6d397: import org.apache.activemq.command.ConsumerControl;
1:9bf9e1c: import org.apache.activemq.command.RemoveInfo;
1:9bf9e1c: import org.apache.activemq.state.CommandVisitor;
1:1b6d397: import org.apache.activemq.thread.Scheduler;
1:1b6d397: import org.apache.activemq.transport.InactivityIOException;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:1b6d397: 
1:1b6d397: /**
1:1b6d397:  * Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds
1:2b99f39:  *
1:1b6d397:  * @org.apache.xbean.XBean
1:1b6d397:  */
1:1b6d397: public class AbortSlowConsumerStrategy implements SlowConsumerStrategy, Runnable {
1:2b99f39: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(AbortSlowConsumerStrategy.class);
1:1b6d397: 
1:2b99f39:     protected String name = "AbortSlowConsumerStrategy@" + hashCode();
1:2b99f39:     protected Scheduler scheduler;
1:2b99f39:     protected Broker broker;
1:2b99f39:     protected final AtomicBoolean taskStarted = new AtomicBoolean(false);
1:2b99f39:     protected final Map<Subscription, SlowConsumerEntry> slowConsumers =
1:2b99f39:         new ConcurrentHashMap<Subscription, SlowConsumerEntry>();
1:1b6d397: 
1:1b6d397:     private long maxSlowCount = -1;
1:1b6d397:     private long maxSlowDuration = 30*1000;
1:1b6d397:     private long checkPeriod = 30*1000;
1:1b6d397:     private boolean abortConnection = false;
1:a0835c2:     private boolean ignoreNetworkConsumers = true;
1:1b6d397: 
1:2b99f39:     @Override
1:383d12e:     public void setBrokerService(Broker broker) {
1:383d12e:        this.scheduler = broker.getScheduler();
1:383d12e:        this.broker = broker;
1:383d12e:     }
1:383d12e: 
1:2b99f39:     @Override
1:1b6d397:     public void slowConsumer(ConnectionContext context, Subscription subs) {
1:1b6d397:         if (maxSlowCount < 0 && maxSlowDuration < 0) {
1:1b6d397:             // nothing to do
1:1b6d397:             LOG.info("no limits set, slowConsumer strategy has nothing to do");
1:1b6d397:             return;
5:1b6d397:         }
1:2b99f39: 
1:1b6d397:         if (taskStarted.compareAndSet(false, true)) {
1:1b6d397:             scheduler.executePeriodically(this, checkPeriod);
1:1b6d397:         }
1:2b99f39: 
1:1b6d397:         if (!slowConsumers.containsKey(subs)) {
1:1b6d397:             slowConsumers.put(subs, new SlowConsumerEntry(context));
1:1b6d397:         } else if (maxSlowCount > 0) {
1:1b6d397:             slowConsumers.get(subs).slow();
1:1b6d397:         }
1:1b6d397:     }
1:1b6d397: 
1:2b99f39:     @Override
2:1b6d397:     public void run() {
1:1b6d397:         if (maxSlowDuration > 0) {
1:1b6d397:             // mark
1:1b6d397:             for (SlowConsumerEntry entry : slowConsumers.values()) {
1:1b6d397:                 entry.mark();
1:1b6d397:             }
1:1b6d397:         }
1:2b99f39: 
1:1b6d397:         HashMap<Subscription, SlowConsumerEntry> toAbort = new HashMap<Subscription, SlowConsumerEntry>();
1:1b6d397:         for (Entry<Subscription, SlowConsumerEntry> entry : slowConsumers.entrySet()) {
1:a0835c2:             Subscription subscription = entry.getKey();
1:a0835c2:             if (isIgnoreNetworkSubscriptions() && subscription.getConsumerInfo().isNetworkSubscription()) {
1:a0835c2:                 if (slowConsumers.remove(subscription) != null) {
1:a0835c2:                     LOG.info("network sub: {} is no longer slow", subscription.getConsumerInfo().getConsumerId());
1:a0835c2:                 }
1:a0835c2:                 continue;
1:a0835c2:             }
1:a0835c2: 
1:1b6d397:             if (entry.getKey().isSlowConsumer()) {
1:a69379d:                 if (maxSlowDuration > 0 && (entry.getValue().markCount * checkPeriod >= maxSlowDuration)
1:a69379d:                         || maxSlowCount > 0 && entry.getValue().slowCount >= maxSlowCount) {
1:1b6d397:                     toAbort.put(entry.getKey(), entry.getValue());
1:1b6d397:                     slowConsumers.remove(entry.getKey());
1:1b6d397:                 }
3:1b6d397:             } else {
1:1b6d397:                 LOG.info("sub: " + entry.getKey().getConsumerInfo().getConsumerId() + " is no longer slow");
1:1b6d397:                 slowConsumers.remove(entry.getKey());
1:1b6d397:             }
1:1b6d397:         }
1:383d12e: 
1:383d12e:         abortSubscription(toAbort, abortConnection);
1:383d12e:     }
1:383d12e: 
1:2b99f39:     protected void abortSubscription(Map<Subscription, SlowConsumerEntry> toAbort, boolean abortSubscriberConnection) {
1:cdb7bb1: 
1:cdb7bb1:         Map<Connection, List<Subscription>> abortMap = new HashMap<Connection, List<Subscription>>();
1:cdb7bb1: 
1:1b6d397:         for (final Entry<Subscription, SlowConsumerEntry> entry : toAbort.entrySet()) {
1:1b6d397:             ConnectionContext connectionContext = entry.getValue().context;
1:cdb7bb1:             if (connectionContext == null) {
1:cdb7bb1:                 continue;
1:cdb7bb1:             }
1:383d12e: 
1:cdb7bb1:             Connection connection = connectionContext.getConnection();
1:cdb7bb1:             if (connection == null) {
1:cdb7bb1:                 LOG.debug("slowConsumer abort ignored, no connection in context:"  + connectionContext);
1:cdb7bb1:             }
1:cdb7bb1: 
1:cdb7bb1:             if (!abortMap.containsKey(connection)) {
1:cdb7bb1:                 abortMap.put(connection, new ArrayList<Subscription>());
1:cdb7bb1:             }
1:cdb7bb1: 
1:cdb7bb1:             abortMap.get(connection).add(entry.getKey());
1:cdb7bb1:         }
1:cdb7bb1: 
1:cdb7bb1:         for (Entry<Connection, List<Subscription>> entry : abortMap.entrySet()) {
1:cdb7bb1:             final Connection connection = entry.getKey();
1:cdb7bb1:             final List<Subscription> subscriptions = entry.getValue();
1:cdb7bb1: 
1:cdb7bb1:             if (abortSubscriberConnection) {
1:cdb7bb1: 
1:cdb7bb1:                 LOG.info("aborting connection:{} with {} slow consumers",
1:cdb7bb1:                          connection.getConnectionId(), subscriptions.size());
1:cdb7bb1: 
1:cdb7bb1:                 if (LOG.isTraceEnabled()) {
1:cdb7bb1:                     for (Subscription subscription : subscriptions) {
1:cdb7bb1:                         LOG.trace("Connection {} being aborted because of slow consumer: {} on destination: {}",
1:cdb7bb1:                                   new Object[] { connection.getConnectionId(),
1:cdb7bb1:                                                  subscription.getConsumerInfo().getConsumerId(),
1:cdb7bb1:                                                  subscription.getActiveMQDestination() });
1:cdb7bb1:                     }
1:1b6d397:                 }
1:cdb7bb1: 
1:cdb7bb1:                 try {
1:cdb7bb1:                     scheduler.executeAfterDelay(new Runnable() {
1:cdb7bb1:                         @Override
1:cdb7bb1:                         public void run() {
1:cdb7bb1:                             connection.serviceException(new InactivityIOException(
1:cdb7bb1:                                     subscriptions.size() + " Consumers was slow too often (>"
1:cdb7bb1:                                     + maxSlowCount +  ") or too long (>"
1:cdb7bb1:                                     + maxSlowDuration + "): "));
1:cdb7bb1:                         }}, 0l);
1:1b6d397:                 } catch (Exception e) {
1:cdb7bb1:                     LOG.info("exception on aborting connection {} with {} slow consumers",
1:cdb7bb1:                              connection.getConnectionId(), subscriptions.size());
1:cdb7bb1:                 }
1:cdb7bb1:             } else {
1:9bf9e1c:                 // just abort each consumer
1:cdb7bb1:                 for (Subscription subscription : subscriptions) {
1:9bf9e1c:                     final Subscription subToClose = subscription;
1:cdb7bb1:                     LOG.info("aborting slow consumer: {} for destination:{}",
1:cdb7bb1:                              subscription.getConsumerInfo().getConsumerId(),
1:cdb7bb1:                              subscription.getActiveMQDestination());
1:cdb7bb1: 
1:9bf9e1c:                     // tell the remote consumer to close
1:cdb7bb1:                     try {
1:cdb7bb1:                         ConsumerControl stopConsumer = new ConsumerControl();
1:cdb7bb1:                         stopConsumer.setConsumerId(subscription.getConsumerInfo().getConsumerId());
1:cdb7bb1:                         stopConsumer.setClose(true);
1:cdb7bb1:                         connection.dispatchAsync(stopConsumer);
1:cdb7bb1:                     } catch (Exception e) {
1:9bf9e1c:                         LOG.info("exception on aborting slow consumer: {}", subscription.getConsumerInfo().getConsumerId(), e);
1:cdb7bb1:                     }
1:9bf9e1c: 
1:9bf9e1c:                     // force a local remove in case remote is unresponsive
1:9bf9e1c:                     try {
1:9bf9e1c:                         scheduler.executeAfterDelay(new Runnable() {
1:9bf9e1c:                             @Override
1:9bf9e1c:                             public void run() {
1:9bf9e1c:                                 try {
1:9bf9e1c:                                     RemoveInfo removeCommand = subToClose.getConsumerInfo().createRemoveCommand();
1:9bf9e1c:                                     if (connection instanceof CommandVisitor) {
1:9bf9e1c:                                         // avoid service exception handling and logging
1:9bf9e1c:                                         removeCommand.visit((CommandVisitor) connection);
1:9bf9e1c:                                     } else {
1:9bf9e1c:                                         connection.service(removeCommand);
1:9bf9e1c:                                     }
1:9bf9e1c:                                 } catch (IllegalStateException ignoredAsRemoteHasDoneTheJob) {
1:9bf9e1c:                                 } catch (Exception e) {
1:9bf9e1c:                                     LOG.info("exception on local remove of slow consumer: {}", subToClose.getConsumerInfo().getConsumerId(), e);
1:9bf9e1c:                                 }
1:9bf9e1c:                             }}, 1000l);
1:9bf9e1c: 
1:9bf9e1c:                     } catch (Exception e) {
1:9bf9e1c:                         LOG.info("exception on local remove of slow consumer: {}", subscription.getConsumerInfo().getConsumerId(), e);
1:9bf9e1c:                     }
1:1b6d397:                 }
1:1b6d397:             }
1:1b6d397:         }
1:1b6d397:     }
1:383d12e: 
1:383d12e:     public void abortConsumer(Subscription sub, boolean abortSubscriberConnection) {
1:383d12e:         if (sub != null) {
1:383d12e:             SlowConsumerEntry entry = slowConsumers.remove(sub);
1:383d12e:             if (entry != null) {
1:2b99f39:                 Map<Subscription, SlowConsumerEntry> toAbort = new HashMap<Subscription, SlowConsumerEntry>();
1:383d12e:                 toAbort.put(sub, entry);
1:383d12e:                 abortSubscription(toAbort, abortSubscriberConnection);
1:383d12e:             } else {
1:383d12e:                 LOG.warn("cannot abort subscription as it no longer exists in the map of slow consumers: " + sub);
1:383d12e:             }
1:383d12e:         }
1:383d12e:     }
1:383d12e: 
1:1b6d397:     public long getMaxSlowCount() {
1:1b6d397:         return maxSlowCount;
1:1b6d397:     }
1:383d12e: 
1:1b6d397:     /**
1:1b6d397:      * number of times a subscription can be deemed slow before triggering abort
1:1b6d397:      * effect depends on dispatch rate as slow determination is done on dispatch
1:1b6d397:      */
1:383d12e:     public void setMaxSlowCount(long maxSlowCount) {
1:1b6d397:         this.maxSlowCount = maxSlowCount;
1:1b6d397:     }
1:1b6d397: 
1:1b6d397:     public long getMaxSlowDuration() {
1:1b6d397:         return maxSlowDuration;
1:1b6d397:     }
1:1b6d397: 
1:1b6d397:     /**
1:1b6d397:      * time in milliseconds that a sub can remain slow before triggering
1:1b6d397:      * an abort.
1:1b6d397:      * @param maxSlowDuration
1:1b6d397:      */
1:1b6d397:     public void setMaxSlowDuration(long maxSlowDuration) {
1:1b6d397:         this.maxSlowDuration = maxSlowDuration;
1:1b6d397:     }
1:1b6d397: 
1:1b6d397:     public long getCheckPeriod() {
1:1b6d397:         return checkPeriod;
1:1b6d397:     }
1:1b6d397: 
1:1b6d397:     /**
1:1b6d397:      * time in milliseconds between checks for slow subscriptions
1:1b6d397:      * @param checkPeriod
1:1b6d397:      */
1:1b6d397:     public void setCheckPeriod(long checkPeriod) {
1:1b6d397:         this.checkPeriod = checkPeriod;
1:1b6d397:     }
1:1b6d397: 
1:1b6d397:     public boolean isAbortConnection() {
1:1b6d397:         return abortConnection;
1:1b6d397:     }
1:1b6d397: 
1:1b6d397:     /**
1:1b6d397:      * abort the consumers connection rather than sending a stop command to the remote consumer
1:1b6d397:      * @param abortConnection
1:1b6d397:      */
1:1b6d397:     public void setAbortConnection(boolean abortConnection) {
1:1b6d397:         this.abortConnection = abortConnection;
1:1b6d397:     }
1:383d12e: 
1:a0835c2:     /**
1:a0835c2:      * Returns whether the strategy is configured to ignore subscriptions that are from a network
1:a0835c2:      * connection.
1:a0835c2:      *
1:a0835c2:      * @return true if the strategy will ignore network connection subscriptions when looking
1:a0835c2:      *         for slow consumers.
1:a0835c2:      */
1:a0835c2:     public boolean isIgnoreNetworkSubscriptions() {
1:a0835c2:         return ignoreNetworkConsumers;
1:a0835c2:     }
1:a0835c2: 
1:a0835c2:     /**
1:a0835c2:      * Sets whether the strategy is configured to ignore consumers that are part of a network
1:a0835c2:      * connection to another broker.
1:a0835c2:      *
1:a0835c2:      * When configured to not ignore idle consumers this strategy acts not only on consumers
1:a0835c2:      * that are actually slow but also on any consumer that has not received any messages for
1:a0835c2:      * the maxTimeSinceLastAck.  This allows for a way to evict idle consumers while also
1:a0835c2:      * aborting slow consumers however for a network subscription this can create a lot of
1:a0835c2:      * unnecessary churn and if the abort connection option is also enabled this can result
1:a0835c2:      * in the entire network connection being torn down and rebuilt for no reason.
1:a0835c2:      *
1:a0835c2:      * @param ignoreNetworkConsumers
1:a0835c2:      *      Should this strategy ignore subscriptions made by a network connector.
1:a0835c2:      */
1:a0835c2:     public void setIgnoreNetworkConsumers(boolean ignoreNetworkConsumers) {
1:a0835c2:         this.ignoreNetworkConsumers = ignoreNetworkConsumers;
1:a0835c2:     }
1:a0835c2: 
1:383d12e:     public void setName(String name) {
1:383d12e:         this.name = name;
1:383d12e:     }
1:2b99f39: 
1:383d12e:     public String getName() {
1:383d12e:         return name;
1:383d12e:     }
1:1b6d397: 
1:383d12e:     public Map<Subscription, SlowConsumerEntry> getSlowConsumers() {
1:383d12e:         return slowConsumers;
1:1b6d397:     }
1:2b99f39: 
1:2b99f39:     @Override
1:2b99f39:     public void addDestination(Destination destination) {
1:2b99f39:         // Not needed for this strategy.
1:2b99f39:     }
1:1b6d397: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:a0835c2
/////////////////////////////////////////////////////////////////////////
1:     private boolean ignoreNetworkConsumers = true;
/////////////////////////////////////////////////////////////////////////
1:             Subscription subscription = entry.getKey();
1:             if (isIgnoreNetworkSubscriptions() && subscription.getConsumerInfo().isNetworkSubscription()) {
1:                 if (slowConsumers.remove(subscription) != null) {
1:                     LOG.info("network sub: {} is no longer slow", subscription.getConsumerInfo().getConsumerId());
1:                 }
1:                 continue;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns whether the strategy is configured to ignore subscriptions that are from a network
1:      * connection.
1:      *
1:      * @return true if the strategy will ignore network connection subscriptions when looking
1:      *         for slow consumers.
1:      */
1:     public boolean isIgnoreNetworkSubscriptions() {
1:         return ignoreNetworkConsumers;
1:     }
1: 
1:     /**
1:      * Sets whether the strategy is configured to ignore consumers that are part of a network
1:      * connection to another broker.
1:      *
1:      * When configured to not ignore idle consumers this strategy acts not only on consumers
1:      * that are actually slow but also on any consumer that has not received any messages for
1:      * the maxTimeSinceLastAck.  This allows for a way to evict idle consumers while also
1:      * aborting slow consumers however for a network subscription this can create a lot of
1:      * unnecessary churn and if the abort connection option is also enabled this can result
1:      * in the entire network connection being torn down and rebuilt for no reason.
1:      *
1:      * @param ignoreNetworkConsumers
1:      *      Should this strategy ignore subscriptions made by a network connector.
1:      */
1:     public void setIgnoreNetworkConsumers(boolean ignoreNetworkConsumers) {
1:         this.ignoreNetworkConsumers = ignoreNetworkConsumers;
1:     }
1: 
commit:cdb7bb1
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: 
1:         Map<Connection, List<Subscription>> abortMap = new HashMap<Connection, List<Subscription>>();
1: 
1:             if (connectionContext == null) {
1:                 continue;
1:             }
1:             Connection connection = connectionContext.getConnection();
1:             if (connection == null) {
1:                 LOG.debug("slowConsumer abort ignored, no connection in context:"  + connectionContext);
1:             }
1: 
1:             if (!abortMap.containsKey(connection)) {
1:                 abortMap.put(connection, new ArrayList<Subscription>());
1:             }
1: 
1:             abortMap.get(connection).add(entry.getKey());
1:         }
1: 
1:         for (Entry<Connection, List<Subscription>> entry : abortMap.entrySet()) {
1:             final Connection connection = entry.getKey();
1:             final List<Subscription> subscriptions = entry.getValue();
1: 
1:             if (abortSubscriberConnection) {
1: 
1:                 LOG.info("aborting connection:{} with {} slow consumers",
1:                          connection.getConnectionId(), subscriptions.size());
1: 
1:                 if (LOG.isTraceEnabled()) {
1:                     for (Subscription subscription : subscriptions) {
1:                         LOG.trace("Connection {} being aborted because of slow consumer: {} on destination: {}",
1:                                   new Object[] { connection.getConnectionId(),
1:                                                  subscription.getConsumerInfo().getConsumerId(),
1:                                                  subscription.getActiveMQDestination() });
1:                 }
1: 
1:                 try {
1:                     scheduler.executeAfterDelay(new Runnable() {
1:                         @Override
1:                         public void run() {
1:                             connection.serviceException(new InactivityIOException(
1:                                     subscriptions.size() + " Consumers was slow too often (>"
1:                                     + maxSlowCount +  ") or too long (>"
1:                                     + maxSlowDuration + "): "));
1:                         }}, 0l);
1:                     LOG.info("exception on aborting connection {} with {} slow consumers",
1:                              connection.getConnectionId(), subscriptions.size());
1:                 }
1:             } else {
0:                 // just abort each consumer by telling it to stop
1:                 for (Subscription subscription : subscriptions) {
1:                     LOG.info("aborting slow consumer: {} for destination:{}",
1:                              subscription.getConsumerInfo().getConsumerId(),
1:                              subscription.getActiveMQDestination());
1: 
1:                     try {
1:                         ConsumerControl stopConsumer = new ConsumerControl();
1:                         stopConsumer.setConsumerId(subscription.getConsumerInfo().getConsumerId());
1:                         stopConsumer.setClose(true);
1:                         connection.dispatchAsync(stopConsumer);
1:                     } catch (Exception e) {
0:                         LOG.info("exception on aborting slow consumer: {}", subscription.getConsumerInfo().getConsumerId());
1:                     }
author:gtully
-------------------------------------------------------------------------------
commit:9bf9e1c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.RemoveInfo;
1: import org.apache.activemq.state.CommandVisitor;
/////////////////////////////////////////////////////////////////////////
1:                 // just abort each consumer
1:                     final Subscription subToClose = subscription;
1:                     // tell the remote consumer to close
1:                         LOG.info("exception on aborting slow consumer: {}", subscription.getConsumerInfo().getConsumerId(), e);
1:                     }
1: 
1:                     // force a local remove in case remote is unresponsive
1:                     try {
1:                         scheduler.executeAfterDelay(new Runnable() {
1:                             @Override
1:                             public void run() {
1:                                 try {
1:                                     RemoveInfo removeCommand = subToClose.getConsumerInfo().createRemoveCommand();
1:                                     if (connection instanceof CommandVisitor) {
1:                                         // avoid service exception handling and logging
1:                                         removeCommand.visit((CommandVisitor) connection);
1:                                     } else {
1:                                         connection.service(removeCommand);
1:                                     }
1:                                 } catch (IllegalStateException ignoredAsRemoteHasDoneTheJob) {
1:                                 } catch (Exception e) {
1:                                     LOG.info("exception on local remove of slow consumer: {}", subToClose.getConsumerInfo().getConsumerId(), e);
1:                                 }
1:                             }}, 1000l);
1: 
1:                     } catch (Exception e) {
1:                         LOG.info("exception on local remove of slow consumer: {}", subscription.getConsumerInfo().getConsumerId(), e);
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:a69379d
/////////////////////////////////////////////////////////////////////////
1:                 if (maxSlowDuration > 0 && (entry.getValue().markCount * checkPeriod >= maxSlowDuration)
1:                         || maxSlowCount > 0 && entry.getValue().slowCount >= maxSlowCount) {
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2b99f39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.Destination;
/////////////////////////////////////////////////////////////////////////
1:  *
1: 
1:     protected String name = "AbortSlowConsumerStrategy@" + hashCode();
1:     protected Scheduler scheduler;
1:     protected Broker broker;
1:     protected final AtomicBoolean taskStarted = new AtomicBoolean(false);
1:     protected final Map<Subscription, SlowConsumerEntry> slowConsumers =
1:         new ConcurrentHashMap<Subscription, SlowConsumerEntry>();
1:     @Override
1:     @Override
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
0:                         || maxSlowCount > 0 && entry.getValue().slowCount > maxSlowCount) {
/////////////////////////////////////////////////////////////////////////
1:     protected void abortSubscription(Map<Subscription, SlowConsumerEntry> toAbort, boolean abortSubscriberConnection) {
0:                             + (abortSubscriberConnection ? "connection" : "consumer")
1:                                 @Override
/////////////////////////////////////////////////////////////////////////
1:                 Map<Subscription, SlowConsumerEntry> toAbort = new HashMap<Subscription, SlowConsumerEntry>();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Override
1:     public void addDestination(Destination destination) {
1:         // Not needed for this strategy.
1:     }
author:Gary Tully
-------------------------------------------------------------------------------
commit:a95c6db
/////////////////////////////////////////////////////////////////////////
0:                             + ", slow consumer: " + entry.getKey());
commit:383d12e
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.activemq.broker.Broker;
/////////////////////////////////////////////////////////////////////////
0:     private String name = "AbortSlowConsumerStrategy@" + hashCode();
0:     private Broker broker;
/////////////////////////////////////////////////////////////////////////
1:     public void setBrokerService(Broker broker) {
1:        this.scheduler = broker.getScheduler();
1:        this.broker = broker;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         abortSubscription(toAbort, abortConnection);
1:     }
1: 
0:     private void abortSubscription(Map<Subscription, SlowConsumerEntry> toAbort, boolean abortSubscriberConnection) {
0:                     LOG.info("aborting "
0:                             + (abortSubscriberConnection ? "connection" : "consumer") 
0:                             + ", slow consumer: " + entry.getKey().getConsumerInfo().getConsumerId());
0:                     if (connection != null) {
0:                         if (abortSubscriberConnection) {
0:                                     connection.serviceException(new InactivityIOException("Consumer was slow too often (>"
/////////////////////////////////////////////////////////////////////////
0:                             stopConsumer.setClose(true);
0:                     LOG.info("exception on stopping "
0:                             + (abortSubscriberConnection ? "connection" : "consumer")
0:                             + " to abort slow consumer: " + entry.getKey(), e);
1: 
1: 
1:     public void abortConsumer(Subscription sub, boolean abortSubscriberConnection) {
1:         if (sub != null) {
1:             SlowConsumerEntry entry = slowConsumers.remove(sub);
1:             if (entry != null) {
0:                 Map toAbort = new HashMap<Subscription, SlowConsumerEntry>();
1:                 toAbort.put(sub, entry);
1:                 abortSubscription(toAbort, abortSubscriberConnection);
1:             } else {
1:                 LOG.warn("cannot abort subscription as it no longer exists in the map of slow consumers: " + sub);
1:             }
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setMaxSlowCount(long maxSlowCount) {
/////////////////////////////////////////////////////////////////////////
1:     public void setName(String name) {
1:         this.name = name;
1:     }
1:     
1:     public String getName() {
1:         return name;
1:     }
1:     public Map<Subscription, SlowConsumerEntry> getSlowConsumers() {
1:         return slowConsumers;
commit:1b6d397
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.broker.region.policy;
1: 
1: import java.util.HashMap;
1: import java.util.Map;
1: import java.util.Map.Entry;
1: import java.util.concurrent.ConcurrentHashMap;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import org.apache.activemq.broker.Connection;
1: import org.apache.activemq.broker.ConnectionContext;
1: import org.apache.activemq.broker.region.Subscription;
1: import org.apache.activemq.command.ConsumerControl;
1: import org.apache.activemq.thread.Scheduler;
1: import org.apache.activemq.transport.InactivityIOException;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
1:  * Abort slow consumers when they reach the configured threshold of slowness, default is slow for 30 seconds
0:  * 
1:  * @org.apache.xbean.XBean
1:  */
1: public class AbortSlowConsumerStrategy implements SlowConsumerStrategy, Runnable {
1:     
0:     private static final Log LOG = LogFactory.getLog(AbortSlowConsumerStrategy.class);
1: 
0:     private static final Scheduler scheduler = Scheduler.getInstance();
0:     private AtomicBoolean taskStarted = new AtomicBoolean(false);
0:     private Map<Subscription, SlowConsumerEntry> slowConsumers = new ConcurrentHashMap<Subscription, SlowConsumerEntry>();
1: 
1:     private long maxSlowCount = -1;
1:     private long maxSlowDuration = 30*1000;
1:     private long checkPeriod = 30*1000;
1:     private boolean abortConnection = false;
1: 
1:     public void slowConsumer(ConnectionContext context, Subscription subs) {
1:         if (maxSlowCount < 0 && maxSlowDuration < 0) {
1:             // nothing to do
1:             LOG.info("no limits set, slowConsumer strategy has nothing to do");
1:             return;
1:         }
1:         
1:         if (taskStarted.compareAndSet(false, true)) {
1:             scheduler.executePeriodically(this, checkPeriod);
1:         }
1:             
1:         if (!slowConsumers.containsKey(subs)) {
1:             slowConsumers.put(subs, new SlowConsumerEntry(context));
1:         } else if (maxSlowCount > 0) {
1:             slowConsumers.get(subs).slow();
1:         }
1:     }
1: 
1:     public void run() {
1:         if (maxSlowDuration > 0) {
1:             // mark
1:             for (SlowConsumerEntry entry : slowConsumers.values()) {
1:                 entry.mark();
1:             }
1:         }
1:         
1:         HashMap<Subscription, SlowConsumerEntry> toAbort = new HashMap<Subscription, SlowConsumerEntry>();
1:         for (Entry<Subscription, SlowConsumerEntry> entry : slowConsumers.entrySet()) {
1:             if (entry.getKey().isSlowConsumer()) {
0:                 if (maxSlowDuration > 0 && (entry.getValue().markCount * checkPeriod > maxSlowDuration)
0:                         || maxSlowCount > 0 && entry.getValue().slowCount > maxSlowCount) { 
1:                     toAbort.put(entry.getKey(), entry.getValue());
1:                     slowConsumers.remove(entry.getKey());
1:                 }
1:             } else {
1:                 LOG.info("sub: " + entry.getKey().getConsumerInfo().getConsumerId() + " is no longer slow");
1:                 slowConsumers.remove(entry.getKey());
1:             }
1:         }
1:         
1:         for (final Entry<Subscription, SlowConsumerEntry> entry : toAbort.entrySet()) {
1:             ConnectionContext connectionContext = entry.getValue().context;
0:             if (connectionContext!= null) {
0:                 try {
0:                     LOG.info("aborting " 
0:                             + (abortConnection ? "connection" : "consumer") 
0:                             + ", slow consumer: " + entry.getKey().getConsumerInfo().getConsumerId()); 
1: 
0:                     final Connection connection = connectionContext.getConnection();
0:                     if (connection != null) {    
0:                         if (abortConnection) {
0:                             scheduler.executeAfterDelay(new Runnable() {
1:                                 public void run() {
0:                                     connection.serviceException(new InactivityIOException("Consumer was slow too often (>" 
0:                                             + maxSlowCount +  ") or too long (>"
0:                                             + maxSlowDuration + "): " + entry.getKey().getConsumerInfo().getConsumerId()));
0:                                 }}, 0l);
1:                         } else {
0:                             // just abort the consumer by telling it to stop
0:                             ConsumerControl stopConsumer = new ConsumerControl();
0:                             stopConsumer.setConsumerId(entry.getKey().getConsumerInfo().getConsumerId());
0:                             stopConsumer.setClose(true);    
0:                             connection.dispatchAsync(stopConsumer);
1:                         }
1:                     } else {
0:                         LOG.debug("slowConsumer abort ignored, no connection in context:"  + connectionContext);
1:                     }
1:                 } catch (Exception e) {
0:                     LOG.info("exception on stopping " 
0:                             + (abortConnection ? "connection" : "consumer") 
0:                             + " to abort slow consumer: " + entry.getKey(), e);   
1:                 }
1:             }
1:         }
1:     }
1:     
1:     public long getMaxSlowCount() {
1:         return maxSlowCount;
1:     }
1: 
1:     /**
1:      * number of times a subscription can be deemed slow before triggering abort
1:      * effect depends on dispatch rate as slow determination is done on dispatch
1:      */
0:     public void setMaxSlowCount(int maxSlowCount) {
1:         this.maxSlowCount = maxSlowCount;
1:     }
1: 
1:     public long getMaxSlowDuration() {
1:         return maxSlowDuration;
1:     }
1: 
1:     /**
1:      * time in milliseconds that a sub can remain slow before triggering
1:      * an abort.
1:      * @param maxSlowDuration
1:      */
1:     public void setMaxSlowDuration(long maxSlowDuration) {
1:         this.maxSlowDuration = maxSlowDuration;
1:     }
1: 
1:     public long getCheckPeriod() {
1:         return checkPeriod;
1:     }
1: 
1:     /**
1:      * time in milliseconds between checks for slow subscriptions
1:      * @param checkPeriod
1:      */
1:     public void setCheckPeriod(long checkPeriod) {
1:         this.checkPeriod = checkPeriod;
1:     }
1: 
1:     public boolean isAbortConnection() {
1:         return abortConnection;
1:     }
1: 
1:     /**
1:      * abort the consumers connection rather than sending a stop command to the remote consumer
1:      * @param abortConnection
1:      */
1:     public void setAbortConnection(boolean abortConnection) {
1:         this.abortConnection = abortConnection;
1:     }
1: 
0:     static class SlowConsumerEntry {
1:         
0:         final ConnectionContext context;
0:         int slowCount = 1;
0:         int markCount = 0;
1:         
0:         SlowConsumerEntry(ConnectionContext context) {
0:             this.context = context;
1:         }
1: 
0:         public void slow() {
0:             slowCount++;
1:         }
1:         
0:         public void mark() {
0:             markCount++;
1:         }
1:     }
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(AbortSlowConsumerStrategy.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:1a5ad28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private Scheduler scheduler;
0:     private final AtomicBoolean taskStarted = new AtomicBoolean(false);
0:     private final Map<Subscription, SlowConsumerEntry> slowConsumers = new ConcurrentHashMap<Subscription, SlowConsumerEntry>();
0:    public void setScheduler(Scheduler s) {
0:        this.scheduler=s;
0:    }
0:    
============================================================================