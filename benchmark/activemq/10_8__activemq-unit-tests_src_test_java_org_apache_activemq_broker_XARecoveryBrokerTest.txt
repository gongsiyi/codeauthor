1:d29ca2a: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:d29ca2a:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:d29ca2a:  *
1:d29ca2a:  * Unless required by applicable law or agreed to in writing, software
1:d29ca2a:  * distributed under the License is distributed on an "AS IS" BASIS,
1:d29ca2a:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d29ca2a:  * See the License for the specific language governing permissions and
1:d29ca2a:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker;
1:230a86c: 
1:16bc0f0: import java.util.Arrays;
1:e900fb4: import java.util.HashSet;
1:16bc0f0: import java.util.LinkedList;
1:e900fb4: import java.util.Set;
1:ab9bce6: import java.util.concurrent.TimeUnit;
1:cb7b657: 
1:1d242a2: import javax.jms.JMSException;
1:1d242a2: import javax.management.InstanceNotFoundException;
1:1d242a2: import javax.management.MalformedObjectNameException;
1:1d242a2: import javax.management.ObjectName;
1:16bc0f0: import javax.transaction.xa.XAResource;
1:16bc0f0: import javax.transaction.xa.Xid;
1:d29ca2a: import junit.framework.Test;
1:16bc0f0: import org.apache.activemq.ActiveMQConnection;
1:16bc0f0: import org.apache.activemq.TransactionContext;
1:69c0d39: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1:64f3492: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1:69c0d39: import org.apache.activemq.broker.jmx.PersistenceAdapterViewMBean;
1:1d242a2: import org.apache.activemq.broker.jmx.RecoveredXATransactionViewMBean;
1:64f3492: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:cfe099d: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
1:cb7b657: import org.apache.activemq.command.*;
1:69c0d39: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
1:1d242a2: import org.apache.activemq.util.JMXSupport;
1:1595378: import org.slf4j.Logger;
1:1595378: import org.slf4j.LoggerFactory;
31:d29ca2a: 
1:d29ca2a: /**
1:d29ca2a:  * Used to simulate the recovery that occurs when a broker shuts down.
1:b0c2a40:  * 
1:d29ca2a:  * 
1:d29ca2a:  */
1:d29ca2a: public class XARecoveryBrokerTest extends BrokerRestartTestSupport {
1:1595378:     protected static final Logger LOG = LoggerFactory.getLogger(XARecoveryBrokerTest.class);
1:bd45d93:     public boolean prioritySupport = true;
1:64f3492: 
1:1d242a2:     public void testPreparedJmxView() throws Exception {
1:1d242a2: 
1:1d242a2:         ActiveMQDestination destination = createDestination();
1:1d242a2: 
1:1d242a2:         // Setup the producer and send the message.
1:1d242a2:         StubConnection connection = createConnection();
1:1d242a2:         ConnectionInfo connectionInfo = createConnectionInfo();
1:1d242a2:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:1d242a2:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:1d242a2:         connection.send(connectionInfo);
1:1d242a2:         connection.send(sessionInfo);
1:1d242a2:         connection.send(producerInfo);
1:1d242a2:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:1d242a2:         connection.send(consumerInfo);
1:1d242a2: 
1:1d242a2:         // Prepare 4 message sends.
1:1d242a2:         for (int i = 0; i < 4; i++) {
1:1d242a2:             // Begin the transaction.
1:1d242a2:             XATransactionId txid = createXATransaction(sessionInfo);
1:1d242a2:             connection.send(createBeginTransaction(connectionInfo, txid));
1:1d242a2: 
1:1d242a2:             Message message = createMessage(producerInfo, destination);
1:1d242a2:             message.setPersistent(true);
1:1d242a2:             message.setTransactionId(txid);
1:1d242a2:             connection.send(message);
1:1d242a2: 
1:1d242a2:             // Prepare
1:1d242a2:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:1d242a2:         }
1:64f3492: 
1:1d242a2:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:1d242a2:         assertNotNull(response);
1:1d242a2:         DataArrayResponse dar = (DataArrayResponse)response;
1:1d242a2:         assertEquals(4, dar.getData().length);
1:98b7dcd: 
1:69c0d39:         // view prepared in kahadb view
1:69c0d39:         if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:69c0d39:             PersistenceAdapterViewMBean kahadbView = getProxyToPersistenceAdapter(broker.getPersistenceAdapter().toString());
1:69c0d39:             String txFromView = kahadbView.getTransactions();
1:69c0d39:             LOG.info("Tx view fromm PA:" + txFromView);
1:69c0d39:             assertTrue("xid with our dud format in transaction string " + txFromView, txFromView.contains("XID:[55,"));
1:69c0d39:         }
1:69c0d39: 
1:1d242a2:         // restart the broker.
1:1d242a2:         restartBroker();
1:1d242a2: 
1:1d242a2:         connection = createConnection();
1:1d242a2:         connectionInfo = createConnectionInfo();
1:1d242a2:         connection.send(connectionInfo);
1:1d242a2: 
1:1d242a2: 
1:1d242a2:         response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:1d242a2:         assertNotNull(response);
1:1d242a2:         dar = (DataArrayResponse)response;
1:1d242a2:         assertEquals(4, dar.getData().length);
1:1d242a2: 
1:16bc0f0:         // verify XAResource scan loop
1:16bc0f0:         XAResource transactionContextXAResource = new TransactionContext(ActiveMQConnection.makeConnection(broker.getVmConnectorURI().toString()));
1:16bc0f0:         LinkedList<Xid> tracked = new LinkedList<Xid>();
1:16bc0f0:         Xid[] recoveryXids = transactionContextXAResource.recover(XAResource.TMSTARTRSCAN);
1:16bc0f0:         while (recoveryXids.length > 0) {
1:16bc0f0:             tracked.addAll(Arrays.asList(recoveryXids));
1:16bc0f0:             recoveryXids = transactionContextXAResource.recover(XAResource.TMNOFLAGS);
1:16bc0f0:         }
1:16bc0f0:         assertEquals("got 4 via scan loop", 4, tracked.size());
1:16bc0f0: 
1:64f3492:         // validate destination depth via jmx
1:64f3492:         DestinationViewMBean destinationView = getProxyToDestination(destinationList(destination)[0]);
1:64f3492:         assertEquals("enqueue count does not see prepared", 0, destinationView.getQueueSize());
1:64f3492: 
1:1d242a2:         TransactionId first = (TransactionId)dar.getData()[0];
1:60624c4:         int commitCount = 0;
1:1d242a2:         // via jmx, force outcome
1:1d242a2:         for (int i = 0; i < 4; i++) {
1:1d242a2:             RecoveredXATransactionViewMBean mbean =  getProxyToPreparedTransactionViewMBean((TransactionId)dar.getData()[i]);
1:1d242a2:             if (i%2==0) {
1:1d242a2:                 mbean.heuristicCommit();
1:60624c4:                 commitCount++;
1:1d242a2:             } else {
1:1d242a2:                 mbean.heuristicRollback();
1:1d242a2:             }
1:1d242a2:         }
1:1d242a2: 
1:1d242a2:         // verify all completed
1:1d242a2:         response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:1d242a2:         assertNotNull(response);
1:1d242a2:         dar = (DataArrayResponse)response;
1:1d242a2:         assertEquals(0, dar.getData().length);
1:1d242a2: 
1:60624c4:         // verify messages available
1:60624c4:         assertEquals("enqueue count reflects outcome", commitCount, destinationView.getQueueSize());
1:60624c4: 
1:1d242a2:         // verify mbeans gone
1:1d242a2:         try {
1:1d242a2:             RecoveredXATransactionViewMBean gone = getProxyToPreparedTransactionViewMBean(first);
1:1d242a2:             gone.heuristicRollback();
1:1d242a2:             fail("Excepted not found");
1:1d242a2:         } catch (InstanceNotFoundException expectedNotfound) {
1:1d242a2:         }
1:1d242a2:     }
1:1d242a2: 
1:69c0d39:     private PersistenceAdapterViewMBean getProxyToPersistenceAdapter(String name) throws MalformedObjectNameException, JMSException {
1:69c0d39:        return (PersistenceAdapterViewMBean)broker.getManagementContext().newProxyInstance(
1:69c0d39:                BrokerMBeanSupport.createPersistenceAdapterName(broker.getBrokerObjectName().toString(), name),
1:69c0d39:                PersistenceAdapterViewMBean.class, true);
1:69c0d39:     }
1:69c0d39: 
1:1d242a2:     private RecoveredXATransactionViewMBean getProxyToPreparedTransactionViewMBean(TransactionId xid) throws MalformedObjectNameException, JMSException {
1:1d242a2: 
1:0709c2c:         ObjectName objectName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,transactionType=RecoveredXaTransaction,xid=" +
1:cb7b657:                 JMXSupport.encodeObjectNamePart(xid.toString()));
1:1d242a2:         RecoveredXATransactionViewMBean proxy = (RecoveredXATransactionViewMBean) broker.getManagementContext().newProxyInstance(objectName,
1:1d242a2:                 RecoveredXATransactionViewMBean.class, true);
1:1d242a2:         return proxy;
1:1d242a2:     }
1:1d242a2: 
1:64f3492:     private DestinationViewMBean getProxyToDestination(ActiveMQDestination destination) throws MalformedObjectNameException, JMSException {
1:64f3492: 
1:cb7b657:         final ObjectName objectName = new ObjectName("org.apache.activemq:type=Broker,brokerName="+broker.getBrokerName()+",destinationType="
1:cb7b657:                 + JMXSupport.encodeObjectNamePart(destination.getDestinationTypeAsString())
1:cb7b657:                 + ",destinationName=" + JMXSupport.encodeObjectNamePart(destination.getPhysicalName()));
1:cb7b657: 
1:64f3492:         DestinationViewMBean proxy = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(objectName,
1:64f3492:                 DestinationViewMBean.class, true);
1:64f3492:         return proxy;
1:64f3492: 
1:64f3492:     }
1:64f3492: 
1:7f5213b:     public void testPreparedTransactionRecoveredOnRestart() throws Exception {
1:1d242a2: 
1:e39a679:         ActiveMQDestination destination = createDestination();
1:1d242a2: 
1:230a86c:         // Setup the producer and send the message.
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:230a86c:         connection.send(producerInfo);
4:d29ca2a:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
4:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:d29ca2a:         // Prepare 4 message sends.
1:101e711:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             // Begin the transaction.
1:d29ca2a:             XATransactionId txid = createXATransaction(sessionInfo);
1:d29ca2a:             connection.send(createBeginTransaction(connectionInfo, txid));
1:230a86c: 
1:d29ca2a:             Message message = createMessage(producerInfo, destination);
1:d29ca2a:             message.setPersistent(true);
1:d29ca2a:             message.setTransactionId(txid);
1:d29ca2a:             connection.send(message);
1:230a86c: 
1:d29ca2a:             // Prepare
1:d29ca2a:             connection.send(createPrepareTransaction(connectionInfo, txid));
4:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Since prepared but not committed.. they should not get delivered.
1:101e711:         assertNull(receiveMessage(connection));
1:d29ca2a:         assertNoMessagesLeft(connection);
1:c97b97e:         connection.request(closeConnectionInfo(connectionInfo));
1:64f3492: 
1:d29ca2a:         // restart the broker.
1:d29ca2a:         restartBroker();
1:64f3492: 
1:101e711:         // Setup the consumer and try receive the message.
1:d29ca2a:         connection = createConnection();
1:d29ca2a:         connectionInfo = createConnectionInfo();
1:d29ca2a:         sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:d29ca2a:         // Since prepared but not committed.. they should not get delivered.
1:101e711:         assertNull(receiveMessage(connection));
1:d29ca2a:         assertNoMessagesLeft(connection);
1:230a86c: 
1:230a86c:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:d29ca2a:         assertNotNull(response);
1:230a86c:         DataArrayResponse dar = (DataArrayResponse)response;
1:d29ca2a:         assertEquals(4, dar.getData().length);
1:230a86c: 
1:2b10259:         // ensure we can close a connection with prepared transactions
1:2b10259:         connection.request(closeConnectionInfo(connectionInfo));
1:2b10259: 
1:2b10259:         // open again  to deliver outcome
1:2b10259:         connection = createConnection();
1:2b10259:         connectionInfo = createConnectionInfo();
1:2b10259:         sessionInfo = createSessionInfo(connectionInfo);
1:2b10259:         connection.send(connectionInfo);
1:2b10259:         connection.send(sessionInfo);
1:2b10259:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:2b10259:         connection.send(consumerInfo);
1:2b10259: 
1:d29ca2a:         // Commit the prepared transactions.
1:230a86c:         for (int i = 0; i < dar.getData().length; i++) {
1:cfe099d:             TransactionId transactionId = (TransactionId) dar.getData()[i];
1:cfe099d:             LOG.info("commit: " + transactionId);
1:cfe099d:             connection.request(createCommitTransaction2Phase(connectionInfo, transactionId));
1:d29ca2a:         }
1:230a86c: 
1:101e711:         // We should get the committed transactions.
1:d41f40a:         final int countToReceive = expectedMessageCount(4, destination);
1:d41f40a:         for (int i = 0; i < countToReceive ; i++) {
1:ab9bce6:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:cfe099d:             LOG.info("received: " + m);
1:d41f40a:             assertNotNull("Got non null message: " + i, m);
1:d29ca2a:         }
1:230a86c: 
1:e39a679:         assertNoMessagesLeft(connection);
1:cfe099d:         assertEmptyDLQ();
1:24b9ae2:     }
1:24b9ae2: 
1:28819ae:     public void testPreparedTransactionRecoveredPurgeRollbackOnRestart() throws Exception {
1:24b9ae2: 
1:24b9ae2:         ActiveMQDestination destination = createDestination();
1:24b9ae2: 
1:24b9ae2:         // Setup the producer and send the message.
1:24b9ae2:         StubConnection connection = createConnection();
1:24b9ae2:         ConnectionInfo connectionInfo = createConnectionInfo();
1:24b9ae2:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:24b9ae2:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:24b9ae2:         connection.send(connectionInfo);
1:24b9ae2:         connection.send(sessionInfo);
1:24b9ae2:         connection.send(producerInfo);
1:24b9ae2:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:24b9ae2:         connection.send(consumerInfo);
1:24b9ae2: 
1:24b9ae2:         // Prepare 4 message sends.
1:24b9ae2:         for (int i = 0; i < 4; i++) {
1:24b9ae2:             // Begin the transaction.
1:24b9ae2:             XATransactionId txid = createXATransaction(sessionInfo);
1:24b9ae2:             connection.send(createBeginTransaction(connectionInfo, txid));
1:24b9ae2: 
1:24b9ae2:             Message message = createMessage(producerInfo, destination);
1:24b9ae2:             message.setPersistent(true);
1:24b9ae2:             message.setTransactionId(txid);
1:24b9ae2:             connection.send(message);
1:24b9ae2: 
1:24b9ae2:             // Prepare
1:24b9ae2:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:cfe099d:         }
1:24b9ae2: 
1:24b9ae2:         // Since prepared but not committed.. they should not get delivered.
1:24b9ae2:         assertNull(receiveMessage(connection));
1:24b9ae2:         assertNoMessagesLeft(connection);
1:24b9ae2:         connection.request(closeConnectionInfo(connectionInfo));
1:cfe099d: 
1:24b9ae2:         // restart the broker.
1:24b9ae2:         stopBroker();
1:24b9ae2:         if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:24b9ae2:             KahaDBPersistenceAdapter adapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
1:28819ae:             adapter.setPurgeRecoveredXATransactionStrategy("ROLLBACK");
1:24b9ae2:             LOG.info("Setting purgeRecoveredXATransactions to true on the KahaDBPersistenceAdapter");
1:24b9ae2:         }
1:24b9ae2:         broker.start();
1:24b9ae2: 
1:24b9ae2:         // Setup the consumer and try receive the message.
1:24b9ae2:         connection = createConnection();
1:24b9ae2:         connectionInfo = createConnectionInfo();
1:24b9ae2:         sessionInfo = createSessionInfo(connectionInfo);
1:24b9ae2:         connection.send(connectionInfo);
1:24b9ae2:         connection.send(sessionInfo);
1:24b9ae2:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:24b9ae2:         connection.send(consumerInfo);
1:24b9ae2: 
1:28819ae:         // Since rolledback but not committed.. they should not get delivered.
1:28819ae:         assertNull(receiveMessage(connection));
1:28819ae:         assertNoMessagesLeft(connection);
1:28819ae: 
1:28819ae:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:28819ae:         assertNotNull(response);
1:28819ae:         DataArrayResponse dar = (DataArrayResponse)response;
1:28819ae: 
1:28819ae:         //These should be purged so expect 0
1:28819ae:         assertEquals(0, dar.getData().length);
1:28819ae: 
1:28819ae:     }
1:28819ae: 
1:28819ae:     public void testPreparedTransactionRecoveredPurgeCommitOnRestart() throws Exception {
1:28819ae: 
1:28819ae:         ActiveMQDestination destination = createDestination();
1:28819ae: 
1:28819ae:         // Setup the producer and send the message.
1:28819ae:         StubConnection connection = createConnection();
1:28819ae:         ConnectionInfo connectionInfo = createConnectionInfo();
1:28819ae:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:28819ae:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:28819ae:         connection.send(connectionInfo);
1:28819ae:         connection.send(sessionInfo);
1:28819ae:         connection.send(producerInfo);
1:28819ae:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:28819ae:         connection.send(consumerInfo);
1:28819ae: 
1:28819ae:         // Prepare 4 message sends.
1:28819ae:         for (int i = 0; i < 4; i++) {
1:28819ae:             // Begin the transaction.
1:28819ae:             XATransactionId txid = createXATransaction(sessionInfo);
1:28819ae:             connection.send(createBeginTransaction(connectionInfo, txid));
1:28819ae: 
1:28819ae:             Message message = createMessage(producerInfo, destination);
1:28819ae:             message.setPersistent(true);
1:28819ae:             message.setTransactionId(txid);
1:28819ae:             connection.send(message);
1:28819ae: 
1:28819ae:             // Prepare
1:28819ae:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:28819ae:         }
1:28819ae: 
1:24b9ae2:         // Since prepared but not committed.. they should not get delivered.
1:24b9ae2:         assertNull(receiveMessage(connection));
1:24b9ae2:         assertNoMessagesLeft(connection);
1:28819ae:         connection.request(closeConnectionInfo(connectionInfo));
1:28819ae: 
1:28819ae:         // restart the broker.
1:28819ae:         stopBroker();
1:28819ae:         if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:28819ae:             KahaDBPersistenceAdapter adapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
1:28819ae:             adapter.setPurgeRecoveredXATransactionStrategy("COMMIT");
1:28819ae:             LOG.info("Setting purgeRecoveredXATransactions to true on the KahaDBPersistenceAdapter");
1:28819ae:         }
1:28819ae:         broker.start();
1:28819ae: 
1:28819ae:         // Setup the consumer and try receive the message.
1:28819ae:         connection = createConnection();
1:28819ae:         connectionInfo = createConnectionInfo();
1:28819ae:         sessionInfo = createSessionInfo(connectionInfo);
1:28819ae:         connection.send(connectionInfo);
1:28819ae:         connection.send(sessionInfo);
1:28819ae:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:28819ae:         connection.send(consumerInfo);
1:28819ae: 
1:28819ae:         // Since committed ... they should get delivered.
1:28819ae:         for (int i = 0; i < 4; i++) {
1:28819ae:             assertNotNull(receiveMessage(connection));
1:28819ae:         }
1:28819ae:         assertNoMessagesLeft(connection);
1:24b9ae2: 
1:24b9ae2:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:24b9ae2:         assertNotNull(response);
1:24b9ae2:         DataArrayResponse dar = (DataArrayResponse)response;
1:24b9ae2: 
1:24b9ae2:         //These should be purged so expect 0
1:24b9ae2:         assertEquals(0, dar.getData().length);
1:24b9ae2: 
1:24b9ae2:     }
1:24b9ae2: 
1:cfe099d:     private void assertEmptyDLQ() throws Exception {
1:cfe099d:         try {
1:cfe099d:             DestinationViewMBean destinationView = getProxyToDestination(new ActiveMQQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME));
1:cfe099d:             assertEquals("nothing on dlq", 0, destinationView.getQueueSize());
1:cfe099d:             assertEquals("nothing added to dlq", 0, destinationView.getEnqueueCount());
1:cfe099d:         } catch (java.lang.reflect.UndeclaredThrowableException maybeOk) {
1:cfe099d:             if (maybeOk.getUndeclaredThrowable() instanceof javax.management.InstanceNotFoundException) {
1:cfe099d:                 // perfect no dlq
1:cfe099d:             } else {
1:cfe099d:                 throw maybeOk;
1:cfe099d:             }
1:cfe099d:         }
1:cfe099d:     }
1:cfe099d: 
1:cfe099d:     public void testPreparedInterleavedTransactionRecoveredOnRestart() throws Exception {
1:cfe099d: 
1:cfe099d:         ActiveMQDestination destination = createDestination();
1:cfe099d: 
1:cfe099d:         // Setup the producer and send the message.
1:cfe099d:         StubConnection connection = createConnection();
1:cfe099d:         ConnectionInfo connectionInfo = createConnectionInfo();
1:cfe099d:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:cfe099d:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:cfe099d:         connection.send(connectionInfo);
1:cfe099d:         connection.send(sessionInfo);
1:cfe099d:         connection.send(producerInfo);
1:cfe099d:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:cfe099d:         connection.send(consumerInfo);
1:cfe099d: 
1:cfe099d:         // Prepare 4 message sends.
1:cfe099d:         for (int i = 0; i < 4; i++) {
1:cfe099d:             // Begin the transaction.
1:cfe099d:             XATransactionId txid = createXATransaction(sessionInfo);
1:cfe099d:             connection.send(createBeginTransaction(connectionInfo, txid));
1:cfe099d: 
1:cfe099d:             Message message = createMessage(producerInfo, destination);
1:cfe099d:             message.setPersistent(true);
1:cfe099d:             message.setTransactionId(txid);
1:cfe099d:             connection.send(message);
1:cfe099d: 
1:cfe099d:             // Prepare
1:cfe099d:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:cfe099d:         }
1:cfe099d: 
1:cfe099d:         // Since prepared but not committed.. they should not get delivered.
1:cfe099d:         assertNull(receiveMessage(connection));
1:cfe099d:         assertNoMessagesLeft(connection);
1:cfe099d: 
1:cfe099d:         // send non tx message
1:cfe099d:         Message message = createMessage(producerInfo, destination);
1:cfe099d:         message.setPersistent(true);
1:cfe099d:         connection.request(message);
1:cfe099d: 
1:cfe099d:         connection.request(closeConnectionInfo(connectionInfo));
1:cfe099d: 
1:cfe099d:         // restart the broker.
1:cfe099d:         restartBroker();
1:cfe099d: 
1:cfe099d:         // Setup the consumer and try receive the message.
1:cfe099d:         connection = createConnection();
1:cfe099d:         connectionInfo = createConnectionInfo();
1:cfe099d:         sessionInfo = createSessionInfo(connectionInfo);
1:cfe099d:         connection.send(connectionInfo);
1:cfe099d:         connection.send(sessionInfo);
1:cfe099d:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:cfe099d:         connection.send(consumerInfo);
1:cfe099d: 
1:cfe099d:         // consume non transacted message, but don't ack
1:cfe099d:         int countToReceive = expectedMessageCount(1, destination);
1:cfe099d:         for (int i=0; i< countToReceive; i++) {
1:cfe099d:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:cfe099d:             LOG.info("received: " + m);
1:cfe099d:             assertNotNull("got non tx message after prepared", m);
1:cfe099d:         }
1:cfe099d: 
1:cfe099d:         // Since prepared but not committed.. they should not get delivered.
1:cfe099d:         assertNull(receiveMessage(connection));
1:cfe099d:         assertNoMessagesLeft(connection);
1:cfe099d: 
1:cfe099d:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:cfe099d:         assertNotNull(response);
1:cfe099d:         DataArrayResponse dar = (DataArrayResponse)response;
1:cfe099d:         assertEquals(4, dar.getData().length);
1:cfe099d: 
1:cfe099d:         // ensure we can close a connection with prepared transactions
1:cfe099d:         connection.request(closeConnectionInfo(connectionInfo));
1:cfe099d: 
1:cfe099d:         // open again  to deliver outcome
1:cfe099d:         connection = createConnection();
1:cfe099d:         connectionInfo = createConnectionInfo();
1:cfe099d:         sessionInfo = createSessionInfo(connectionInfo);
1:cfe099d:         connection.send(connectionInfo);
1:cfe099d:         connection.send(sessionInfo);
1:cfe099d: 
1:cfe099d:         // Commit the prepared transactions.
1:cfe099d:         for (int i = 0; i < dar.getData().length; i++) {
1:cfe099d:             TransactionId transactionId = (TransactionId) dar.getData()[i];
1:cfe099d:             LOG.info("commit: " + transactionId);
1:cfe099d:             connection.request(createCommitTransaction2Phase(connectionInfo, transactionId));
1:cfe099d:         }
1:cfe099d: 
1:cfe099d:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:cfe099d:         connection.send(consumerInfo);
1:cfe099d: 
1:cfe099d:         // We should get the committed transactions and the non tx message
1:cfe099d:         countToReceive = expectedMessageCount(5, destination);
1:cfe099d:         for (int i = 0; i < countToReceive ; i++) {
1:cfe099d:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:cfe099d:             LOG.info("received: " + m);
1:cfe099d:             assertNotNull("Got non null message: " + i, m);
1:cfe099d:         }
1:cfe099d: 
1:cfe099d:         assertNoMessagesLeft(connection);
1:cfe099d:         assertEmptyDLQ();
1:d29ca2a:     }
1:230a86c: 
1:64f3492:     public void testTopicPreparedTransactionRecoveredOnRestart() throws Exception {
1:64f3492:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1:64f3492: 
1:64f3492:         StubConnection connection = createConnection();
1:64f3492:         ConnectionInfo connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:64f3492:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         connection.send(producerInfo);
1:64f3492:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:64f3492:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         // Prepare 4 message sends.
1:64f3492:         for (int i = 0; i < 4; i++) {
1:64f3492:             // Begin the transaction.
1:64f3492:             XATransactionId txid = createXATransaction(sessionInfo);
1:64f3492:             connection.send(createBeginTransaction(connectionInfo, txid));
1:64f3492: 
1:64f3492:             Message message = createMessage(producerInfo, destination);
1:64f3492:             message.setPersistent(true);
1:64f3492:             message.setTransactionId(txid);
1:64f3492:             connection.send(message);
1:64f3492: 
1:64f3492:             // Prepare
1:64f3492:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:64f3492:         }
1:64f3492: 
1:64f3492:         // Since prepared but not committed.. they should not get delivered.
1:64f3492:         assertNull(receiveMessage(connection));
1:64f3492:         assertNoMessagesLeft(connection);
1:64f3492:         connection.request(closeConnectionInfo(connectionInfo));
1:64f3492: 
1:64f3492:         // restart the broker.
1:64f3492:         restartBroker();
1:64f3492: 
1:64f3492:         // Setup the consumer and try receive the message.
1:64f3492:         connection = createConnection();
1:64f3492:         connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:64f3492: 
1:64f3492:         sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:64f3492:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         // Since prepared but not committed.. they should not get delivered.
1:64f3492:         assertNull(receiveMessage(connection));
1:64f3492:         assertNoMessagesLeft(connection);
1:64f3492: 
1:64f3492:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:64f3492:         assertNotNull(response);
1:64f3492:         DataArrayResponse dar = (DataArrayResponse) response;
1:64f3492:         assertEquals(4, dar.getData().length);
1:64f3492: 
1:64f3492:         // ensure we can close a connection with prepared transactions
1:64f3492:         connection.request(closeConnectionInfo(connectionInfo));
1:64f3492: 
1:64f3492:         // open again  to deliver outcome
1:64f3492:         connection = createConnection();
1:64f3492:         connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:64f3492:         sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:64f3492:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         // Commit the prepared transactions.
1:64f3492:         for (int i = 0; i < dar.getData().length; i++) {
1:69c0d39:             connection.request(createCommitTransaction2Phase(connectionInfo, (TransactionId) dar.getData()[i]));
1:64f3492:         }
1:64f3492: 
1:64f3492:         // We should get the committed transactions.
1:64f3492:         for (int i = 0; i < expectedMessageCount(4, destination); i++) {
1:64f3492:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:64f3492:             assertNotNull(m);
1:64f3492:         }
1:64f3492: 
1:64f3492:         assertNoMessagesLeft(connection);
1:64f3492: 
1:64f3492:     }
1:64f3492: 
1:7f5213b:     public void testQueuePersistentCommitedMessagesNotLostOnRestart() throws Exception {
1:64f3492: 
1:e39a679:         ActiveMQDestination destination = createDestination();
1:230a86c: 
1:64f3492:         // Setup the producer and send the message.
1:64f3492:         StubConnection connection = createConnection();
1:64f3492:         ConnectionInfo connectionInfo = createConnectionInfo();
1:64f3492:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         connection.send(producerInfo);
1:230a86c: 
1:d29ca2a:         // Begin the transaction.
1:d29ca2a:         XATransactionId txid = createXATransaction(sessionInfo);
1:d29ca2a:         connection.send(createBeginTransaction(connectionInfo, txid));
1:230a86c: 
1:64f3492:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message message = createMessage(producerInfo, destination);
1:d29ca2a:             message.setPersistent(true);
1:d29ca2a:             message.setTransactionId(txid);
1:d29ca2a:             connection.send(message);
1:d29ca2a:         }
1:230a86c: 
1:d29ca2a:         // Commit
2:d29ca2a:         connection.send(createCommitTransaction1Phase(connectionInfo, txid));
1:c97b97e:         connection.request(closeConnectionInfo(connectionInfo));
1:d29ca2a:         // restart the broker.
1:d29ca2a:         restartBroker();
1:230a86c: 
1:1595378:         // Setup the consumer and receive the message.
1:d29ca2a:         connection = createConnection();
1:d29ca2a:         connectionInfo = createConnectionInfo();
1:d29ca2a:         sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:101e711:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:d29ca2a:         connection.send(consumerInfo);
1:230a86c: 
1:1595378:         for (int i = 0; i < expectedMessageCount(4, destination); i++) {
6:d29ca2a:             Message m = receiveMessage(connection);
5:d29ca2a:             assertNotNull(m);
1:230a86c:         }
1:230a86c: 
1:d29ca2a:         assertNoMessagesLeft(connection);
1:d29ca2a:     }
1:230a86c: 
1:64f3492:     public void testQueuePersistentCommited2PhaseMessagesNotLostOnRestart() throws Exception {
1:64f3492: 
1:64f3492:         ActiveMQDestination destination = createDestination();
1:64f3492: 
1:64f3492:         // Setup the producer and send the message.
1:64f3492:         StubConnection connection = createConnection();
1:64f3492:         ConnectionInfo connectionInfo = createConnectionInfo();
1:64f3492:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         connection.send(producerInfo);
1:64f3492: 
1:64f3492:         // Begin the transaction.
1:64f3492:         XATransactionId txid = createXATransaction(sessionInfo);
1:64f3492:         connection.send(createBeginTransaction(connectionInfo, txid));
1:64f3492: 
1:64f3492:         for (int i = 0; i < 4; i++) {
1:64f3492:             Message message = createMessage(producerInfo, destination);
1:64f3492:             message.setPersistent(true);
1:64f3492:             message.setTransactionId(txid);
1:64f3492:             connection.send(message);
1:64f3492:         }
1:230a86c: 
1:64f3492:         // Commit 2 phase
1:64f3492:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:64f3492:         connection.send(createCommitTransaction2Phase(connectionInfo, txid));
1:64f3492: 
1:64f3492:         connection.request(closeConnectionInfo(connectionInfo));
1:64f3492:         // restart the broker.
1:64f3492:         restartBroker();
1:64f3492: 
1:64f3492:         // Setup the consumer and receive the message.
1:64f3492:         connection = createConnection();
1:64f3492:         connectionInfo = createConnectionInfo();
1:64f3492:         sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         for (int i = 0; i < expectedMessageCount(4, destination); i++) {
1:64f3492:             Message m = receiveMessage(connection);
1:64f3492:             assertNotNull(m);
1:64f3492:         }
1:64f3492: 
1:64f3492:         assertNoMessagesLeft(connection);
1:64f3492:     }
1:64f3492: 
1:7f5213b:     public void testQueuePersistentCommitedAcksNotLostOnRestart() throws Exception {
1:230a86c: 
1:e39a679:         ActiveMQDestination destination = createDestination();
1:230a86c: 
1:230a86c:         // Setup the producer and send the message.
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:230a86c:         connection.send(producerInfo);
1:230a86c: 
1:1595378:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message message = createMessage(producerInfo, destination);
1:d29ca2a:             message.setPersistent(true);
1:d29ca2a:             connection.send(message);
1:101e711:         }
1:230a86c: 
1:d29ca2a:         // Begin the transaction.
1:d29ca2a:         XATransactionId txid = createXATransaction(sessionInfo);
1:d29ca2a:         connection.send(createBeginTransaction(connectionInfo, txid));
1:230a86c: 
1:1595378:         ConsumerInfo consumerInfo;
1:1595378:         Message m = null;
1:98b7dcd:         for (ActiveMQDestination dest : destinationList(destination)) {
1:98b7dcd:             // Setup the consumer and receive the message.
1:1595378:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:1595378:             connection.send(consumerInfo);
1:1595378: 
1:1595378:             for (int i = 0; i < 4; i++) {
1:1595378:                 m = receiveMessage(connection);
1:1595378:                 assertNotNull(m);
1:1595378:             }
1:1595378: 
1:1595378:             MessageAck ack = createAck(consumerInfo, m, 4, MessageAck.STANDARD_ACK_TYPE);
1:1595378:             ack.setTransactionId(txid);
1:1595378:             connection.send(ack);
1:1595378:         }
1:1595378: 
1:d29ca2a:         // Commit
1:2a6a441:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1:1595378: 
1:d29ca2a:         // restart the broker.
1:d29ca2a:         restartBroker();
1:101e711: 
1:1595378:         // Setup the consumer and receive the message.
1:d29ca2a:         connection = createConnection();
1:d29ca2a:         connectionInfo = createConnectionInfo();
1:d29ca2a:         sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:1595378:         connection.send(consumerInfo);
1:101e711: 
1:d29ca2a:         // No messages should be delivered.
1:d29ca2a:         assertNoMessagesLeft(connection);
1:101e711: 
1:1595378:         m = receiveMessage(connection);
1:d29ca2a:         assertNull(m);
1:1595378:     }
1:60624c4:     
1:5f6f23e:     public void testQueuePersistentPreparedAcksNotLostOnRestart() throws Exception {
1:230a86c: 
1:5f6f23e:         ActiveMQDestination destination = createDestination();
1:230a86c: 
1:230a86c:         // Setup the producer and send the message.
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:230a86c:         connection.send(producerInfo);
1:230a86c: 
1:1595378:         for (int i = 0; i < 4; i++) {
1:d29ca2a:             Message message = createMessage(producerInfo, destination);
1:d29ca2a:             message.setPersistent(true);
1:d29ca2a:             connection.send(message);
1:1595378:         }
1:d29ca2a: 
1:d29ca2a:         // Begin the transaction.
1:d29ca2a:         XATransactionId txid = createXATransaction(sessionInfo);
1:d29ca2a:         connection.send(createBeginTransaction(connectionInfo, txid));
1:d29ca2a: 
1:1595378:         ConsumerInfo consumerInfo;
1:1595378:         Message m = null;
1:1595378:         for (ActiveMQDestination dest : destinationList(destination)) {
1:1595378:             // Setup the consumer and receive the message.
1:1595378:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:d29ca2a:             connection.send(consumerInfo);
1:d29ca2a: 
1:1595378:             for (int i = 0; i < 4; i++) {
1:101e711:                 m = receiveMessage(connection);
1:1595378:                 assertNotNull(m);
1:101e711:             }
1:d29ca2a: 
1:1595378:             // one ack with last received, mimic a beforeEnd synchronization
1:1595378:             MessageAck ack = createAck(consumerInfo, m, 4, MessageAck.STANDARD_ACK_TYPE);
1:1595378:             ack.setTransactionId(txid);
1:1595378:             connection.send(ack);
1:1595378:         }
1:101e711: 
1:5f6f23e:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:101e711: 
1:d29ca2a:         // restart the broker.
1:d29ca2a:         restartBroker();
1:d29ca2a: 
1:d29ca2a:         connection = createConnection();
1:d29ca2a:         connectionInfo = createConnectionInfo();
1:d29ca2a:         connection.send(connectionInfo);
1:d29ca2a: 
1:101e711:         // validate recovery
1:101e711:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:101e711:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:101e711: 
1:101e711:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:101e711:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1:101e711: 
1:101e711:         sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         connection.send(sessionInfo);
1:d29ca2a:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:101e711:         connection.send(consumerInfo);
1:101e711:         
1:101e711:         // no redelivery, exactly once semantics unless there is rollback
1:101e711:         m = receiveMessage(connection);
1:101e711:         assertNull(m);
1:101e711:         assertNoMessagesLeft(connection);
1:101e711: 
1:60624c4:         // validate destination depth via jmx
1:60624c4:         DestinationViewMBean destinationView = getProxyToDestination(destinationList(destination)[0]);
1:ea70e82:         assertEquals("enqueue count does not see prepared acks", 0, destinationView.getQueueSize());
1:ea70e82:         assertEquals("dequeue count does not see prepared acks", 0, destinationView.getDequeueCount());
1:101e711: 
1:101e711:         connection.request(createCommitTransaction2Phase(connectionInfo, txid));
1:101e711: 
1:101e711:         // validate recovery complete
1:101e711:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:101e711:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:efaf9cd: 
1:60624c4:         assertEquals("enqueue count does not see commited acks", 0, destinationView.getQueueSize());
1:ea70e82:         assertEquals("dequeue count does not see commited acks", 4, destinationView.getDequeueCount());
1:efaf9cd: 
1:64f3492:     }
1:e900fb4: 
1:bd45d93:     public void x_initCombosForTestTopicPersistentPreparedAcksNotLostOnRestart() {
1:64f3492:         addCombinationValues("prioritySupport", new Boolean[]{Boolean.FALSE, Boolean.TRUE});
1:64f3492:     }
1:e900fb4: 
1:64f3492:     public void testTopicPersistentPreparedAcksNotLostOnRestart() throws Exception {
1:64f3492:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1:e900fb4: 
1:e900fb4:         // Setup the producer and send the message.
1:e900fb4:         StubConnection connection = createConnection();
1:e900fb4:         ConnectionInfo connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:e900fb4:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:e900fb4:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:efaf9cd:         connection.send(connectionInfo);
1:efaf9cd:         connection.send(sessionInfo);
1:e900fb4:         connection.send(producerInfo);
1:60624c4: 
1:64f3492:         // setup durable subs
1:64f3492:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:64f3492:         connection.send(consumerInfo);
1:60624c4: 
1:b07f31e:         final int numMessages = 4;
1:b07f31e:         for (int i = 0; i < numMessages; i++) {
1:64f3492:             Message message = createMessage(producerInfo, destination);
1:64f3492:             message.setPersistent(true);
1:64f3492:             connection.send(message);
1:64f3492:         }
1:64f3492: 
1:64f3492:         // Begin the transaction.
1:64f3492:         XATransactionId txid = createXATransaction(sessionInfo);
1:64f3492:         connection.send(createBeginTransaction(connectionInfo, txid));
1:64f3492: 
1:e900fb4:         final int messageCount = expectedMessageCount(numMessages, destination);
1:64f3492:         Message m = null;
1:64f3492:         for (int i = 0; i < messageCount; i++) {
1:64f3492:             m = receiveMessage(connection);
1:64f3492:             assertNotNull("unexpected null on: " + i, m);
1:64f3492:         }
1:64f3492: 
1:64f3492:         // one ack with last received, mimic a beforeEnd synchronization
1:64f3492:         MessageAck ack = createAck(consumerInfo, m, messageCount, MessageAck.STANDARD_ACK_TYPE);
1:64f3492:         ack.setTransactionId(txid);
1:64f3492:         connection.send(ack);
1:64f3492: 
1:64f3492:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:64f3492: 
1:64f3492:         // restart the broker.
1:64f3492:         restartBroker();
1:64f3492: 
1:64f3492:         connection = createConnection();
1:64f3492:         connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:64f3492:         connection.send(connectionInfo);
1:64f3492: 
1:64f3492:         // validate recovery
1:64f3492:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:64f3492:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:64f3492: 
1:64f3492:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:64f3492:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1:64f3492: 
1:64f3492:         sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:64f3492:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         // no redelivery, exactly once semantics unless there is rollback
1:64f3492:         m = receiveMessage(connection);
1:64f3492:         assertNull(m);
1:64f3492:         assertNoMessagesLeft(connection);
1:64f3492: 
1:64f3492:         connection.request(createCommitTransaction2Phase(connectionInfo, txid));
1:64f3492: 
1:64f3492:         // validate recovery complete
1:64f3492:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:64f3492:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:64f3492:     }
1:64f3492: 
1:101e711:     public void testQueuePersistentPreparedAcksAvailableAfterRestartAndRollback() throws Exception {
1:64f3492: 
1:101e711:         ActiveMQDestination destination = createDestination();
1:64f3492: 
1:101e711:         // Setup the producer and send the message.
1:101e711:         StubConnection connection = createConnection();
1:101e711:         ConnectionInfo connectionInfo = createConnectionInfo();
1:101e711:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:101e711:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:101e711:         connection.send(connectionInfo);
1:101e711:         connection.send(sessionInfo);
1:101e711:         connection.send(producerInfo);
1:64f3492: 
1:64f3492:         int numMessages = 4;
1:64f3492:         for (int i = 0; i < numMessages; i++) {
1:101e711:             Message message = createMessage(producerInfo, destination);
1:101e711:             message.setPersistent(true);
1:101e711:             connection.send(message);
1:efaf9cd:         }
1:efaf9cd: 
1:101e711:         // Begin the transaction.
1:101e711:         XATransactionId txid = createXATransaction(sessionInfo);
1:101e711:         connection.send(createBeginTransaction(connectionInfo, txid));
1:64f3492: 
1:1595378:         ConsumerInfo consumerInfo;
1:98b7dcd:         Message message = null;
1:98b7dcd:         for (ActiveMQDestination dest : destinationList(destination)) {
1:98b7dcd:             // Setup the consumer and receive the message.
1:1595378:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:64f3492:             connection.send(consumerInfo);
1:64f3492: 
1:64f3492:             for (int i = 0; i < numMessages; i++) {
1:64f3492:                 message = receiveMessage(connection);
1:98b7dcd:                 assertNotNull(message);
1:64f3492:             }
1:1595378: 
1:1595378:             // one ack with last received, mimic a beforeEnd synchronization
1:64f3492:             MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:64f3492:             ack.setTransactionId(txid);
1:64f3492:             connection.send(ack);
1:64f3492:         }
1:64f3492: 
1:101e711:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:64f3492: 
1:101e711:         // restart the broker.
1:101e711:         restartBroker();
1:64f3492: 
1:101e711:         connection = createConnection();
1:101e711:         connectionInfo = createConnectionInfo();
1:101e711:         connection.send(connectionInfo);
1:1595378: 
1:101e711:         // validate recovery
1:101e711:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:101e711:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:101e711: 
1:101e711:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:101e711:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1:101e711: 
1:101e711:         sessionInfo = createSessionInfo(connectionInfo);
1:101e711:         connection.send(sessionInfo);
1:101e711:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:1595378:         connection.send(consumerInfo);
1:101e711: 
1:101e711:         // no redelivery, exactly once semantics while prepared
1:1595378:         message = receiveMessage(connection);
1:101e711:         assertNull(message);
1:5f6f23e:         assertNoMessagesLeft(connection);
1:efaf9cd:         connection.request(consumerInfo.createRemoveCommand());
1:efaf9cd: 
1:efaf9cd:         LOG.info("Send some more before the rollback");
1:efaf9cd:         // send some more messages
1:efaf9cd:         producerInfo = createProducerInfo(sessionInfo);
1:efaf9cd:         connection.send(producerInfo);
1:efaf9cd: 
1:efaf9cd:         for (int i = 0; i < numMessages*2; i++) {
1:efaf9cd:             message = createMessage(producerInfo, destination);
1:efaf9cd:             message.setPersistent(true);
1:efaf9cd:             connection.send(message);
1:efaf9cd:         }
1:efaf9cd: 
1:efaf9cd:         LOG.info("Send some more before the rollback");
1:101e711: 
1:101e711:         // rollback so we get redelivery
1:101e711:         connection.request(createRollbackTransaction(connectionInfo, txid));
1:b07f31e: 
1:64f3492:         LOG.info("new tx for redelivery");
1:101e711:         txid = createXATransaction(sessionInfo);
1:101e711:         connection.send(createBeginTransaction(connectionInfo, txid));
1:1595378: 
1:efaf9cd:         Set<ConsumerInfo> consumerInfoSet = new HashSet<ConsumerInfo>();
1:1595378:         for (ActiveMQDestination dest : destinationList(destination)) {
1:1595378:             // Setup the consumer and receive the message.
1:1595378:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:1595378:             connection.send(consumerInfo);
1:efaf9cd:             consumerInfoSet.add(consumerInfo);
1:efaf9cd:             LOG.info("consume messages for: " + dest.getPhysicalName() + " " + consumerInfo.getConsumerId());
1:1595378: 
1:64f3492:             for (int i = 0; i < numMessages; i++) {
1:1595378:                 message = receiveMessage(connection);
1:64f3492:                 assertNotNull("unexpected null on:" + i, message);
1:efaf9cd:                 LOG.info(dest.getPhysicalName()  + " ID: " + message.getMessageId());
1:64f3492:             }
1:64f3492:             MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:1595378:             ack.setTransactionId(txid);
1:efaf9cd:             connection.request(ack);
1:efaf9cd: 
1:efaf9cd:             // clear any pending messages on the stub connection via prefetch
1:efaf9cd:             while ((message = receiveMessage(connection)) != null) {
1:efaf9cd:                 LOG.info("Pre fetched and unwanted: " + message.getMessageId() + " on " + message.getDestination().getPhysicalName());
1:efaf9cd:             }
1:1595378:         }
1:101e711: 
1:efaf9cd:         LOG.info("commit..");
1:101e711:         // Commit
1:101e711:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1:101e711: 
1:efaf9cd:         // remove consumers 'after' commit b/c of inflight tally issue
1:efaf9cd:         for (ConsumerInfo info : consumerInfoSet) {
1:efaf9cd:             connection.request(info.createRemoveCommand());
1:efaf9cd:         }
1:efaf9cd:         consumerInfoSet.clear();
1:efaf9cd: 
1:101e711:         // validate recovery complete
1:101e711:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:101e711:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:efaf9cd: 
1:efaf9cd:         LOG.info("consume additional messages");
1:efaf9cd: 
1:efaf9cd:         // clear any pending messages on the stub connection via prefetch
1:efaf9cd:         while ((message = receiveMessage(connection)) != null) {
1:efaf9cd:             LOG.info("Pre fetched and unwanted: " + message.getMessageId() + " on " + message.getDestination().getPhysicalName());
1:efaf9cd:         }
1:efaf9cd:         // consume the additional messages
1:efaf9cd:         for (ActiveMQDestination dest : destinationList(destination)) {
1:efaf9cd: 
1:efaf9cd:             // Setup the consumer and receive the message.
1:efaf9cd:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:efaf9cd:             connection.request(consumerInfo);
1:efaf9cd: 
1:efaf9cd:             LOG.info("consume additional messages for: " + dest.getPhysicalName() + " " + consumerInfo.getConsumerId());
1:efaf9cd: 
1:efaf9cd:             for (int i = 0; i < numMessages*2; i++) {
1:efaf9cd:                 message = receiveMessage(connection);
1:efaf9cd:                 assertNotNull("unexpected null on:" + i, message);
1:efaf9cd:                 LOG.info(dest.getPhysicalName()  + " ID: " + message.getMessageId());
1:efaf9cd:                 MessageAck ack = createAck(consumerInfo, message, 1, MessageAck.STANDARD_ACK_TYPE);
1:efaf9cd:                 connection.request(ack);
1:efaf9cd:             }
1:efaf9cd:             connection.request(consumerInfo.createRemoveCommand());
1:efaf9cd:         }
1:efaf9cd: 
1:efaf9cd:         assertNoMessagesLeft(connection);
1:1595378:     }
1:101e711: 
1:e900fb4:     public void testQueuePersistentPreparedAcksAvailableAfterRollbackPrefetchOne() throws Exception {
1:e900fb4: 
1:e900fb4:         ActiveMQDestination destination = createDestination();
1:101e711: 
1:230a86c:         // Setup the producer and send the message.
1:d29ca2a:         StubConnection connection = createConnection();
1:d29ca2a:         ConnectionInfo connectionInfo = createConnectionInfo();
1:d29ca2a:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:d29ca2a:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:e900fb4:         connection.send(connectionInfo);
1:e900fb4:         connection.send(sessionInfo);
1:230a86c:         connection.send(producerInfo);
1:101e711: 
1:e900fb4:         int numMessages = 1;
1:e900fb4:         for (int i = 0; i < numMessages; i++) {
1:e900fb4:             Message message = createMessage(producerInfo, destination);
1:e900fb4:             message.setPersistent(true);
1:e900fb4:             connection.send(message);
1:e900fb4:         }
1:e900fb4: 
1:e900fb4:         // Begin the transaction.
1:e900fb4:         XATransactionId txid = createXATransaction(sessionInfo);
1:e900fb4:         connection.send(createBeginTransaction(connectionInfo, txid));
1:e900fb4: 
1:e900fb4:         // use consumer per destination for the composite dest case
1:e900fb4:         // bc the same composite dest is used for sending so there
1:e900fb4:         // will be duplicate message ids in the mix which a single
1:e900fb4:         // consumer (PrefetchSubscription) cannot handle in a tx
1:e900fb4:         // atm. The matching is based on messageId rather than messageId
1:e900fb4:         // and destination
1:e900fb4:         Set<ConsumerInfo> consumerInfos = new HashSet<ConsumerInfo>();
1:e900fb4:         for (ActiveMQDestination dest : destinationList(destination)) {
1:e900fb4:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:e900fb4:             consumerInfo.setPrefetchSize(numMessages);
1:e900fb4:             consumerInfos.add(consumerInfo);
1:efaf9cd:         }
1:e900fb4: 
1:e900fb4:         for (ConsumerInfo info : consumerInfos) {
1:e900fb4:             connection.send(info);
1:e900fb4:         }
1:e900fb4: 
1:e900fb4:         Message message = null;
1:efaf9cd:         for (ConsumerInfo info : consumerInfos) {
1:e900fb4:             for (int i = 0; i < numMessages; i++) {
1:efaf9cd:                message = receiveMessage(connection);
1:e900fb4:                assertNotNull(message);
1:e900fb4:                connection.send(createAck(info, message, 1, MessageAck.DELIVERED_ACK_TYPE));
1:e900fb4:             }
1:e900fb4:             MessageAck ack = createAck(info, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:e900fb4:             ack.setTransactionId(txid);
1:e900fb4:             connection.send(ack);
1:e900fb4:         }
1:e900fb4:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:efaf9cd: 
1:e900fb4:         // reconnect
1:e900fb4:         connection.send(connectionInfo.createRemoveCommand());
1:e900fb4:         connection = createConnection();
1:e900fb4:         connection.send(connectionInfo);
1:e900fb4: 
1:e900fb4:         // validate recovery
1:e900fb4:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:e900fb4:         DataArrayResponse dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1:e900fb4: 
1:e900fb4:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:e900fb4:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1:e900fb4: 
1:e900fb4:         connection.send(sessionInfo);
1:e900fb4: 
1:e900fb4:         for (ConsumerInfo info : consumerInfos) {
1:e900fb4:             connection.send(info);
1:e900fb4:         }
1:e900fb4: 
1:e900fb4:         // no redelivery, exactly once semantics while prepared
1:e900fb4:         message = receiveMessage(connection);
1:e900fb4:         assertNull(message);
1:e900fb4:         assertNoMessagesLeft(connection);
1:e900fb4: 
1:e900fb4:         // rollback so we get redelivery
1:e900fb4:         connection.request(createRollbackTransaction(connectionInfo, txid));
1:e900fb4: 
1:e900fb4:         LOG.info("new tx for redelivery");
1:e900fb4:         txid = createXATransaction(sessionInfo);
1:e900fb4:         connection.send(createBeginTransaction(connectionInfo, txid));
1:e900fb4: 
1:e900fb4:         for (ConsumerInfo info : consumerInfos) {
1:e900fb4:             for (int i = 0; i < numMessages; i++) {
1:e900fb4:                 message = receiveMessage(connection);
1:e900fb4:                 assertNotNull("unexpected null on:" + i, message);
1:e900fb4:                 MessageAck ack = createAck(info, message, 1, MessageAck.STANDARD_ACK_TYPE);
1:e900fb4:                 ack.setTransactionId(txid);
1:e900fb4:                 connection.send(ack);
1:e900fb4:             }
1:e900fb4:         }
1:e900fb4: 
1:e900fb4:         // Commit
1:e900fb4:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1:e900fb4: 
1:e900fb4:         // validate recovery complete
1:e900fb4:         dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1:e900fb4:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:e900fb4:     }
1:e900fb4: 
1:e900fb4: 
1:efaf9cd:     public void testQueuePersistentPreparedAcksAvailableAfterRollback() throws Exception {
1:efaf9cd: 
1:efaf9cd:         ActiveMQDestination destination = createDestination();
1:efaf9cd: 
1:efaf9cd:         // Setup the producer and send the message.
1:efaf9cd:         StubConnection connection = createConnection();
1:efaf9cd:         ConnectionInfo connectionInfo = createConnectionInfo();
1:efaf9cd:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:efaf9cd:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:efaf9cd:         connection.send(connectionInfo);
1:efaf9cd:         connection.send(sessionInfo);
1:efaf9cd:         connection.send(producerInfo);
1:efaf9cd: 
1:efaf9cd:         int numMessages = 4;
1:efaf9cd:         for (int i = 0; i < numMessages; i++) {
1:efaf9cd:             Message message = createMessage(producerInfo, destination);
1:efaf9cd:             connection.send(message);
1:efaf9cd:         }
1:efaf9cd: 
1:efaf9cd:         // Begin the transaction.
1:efaf9cd:         XATransactionId txid = createXATransaction(sessionInfo);
1:efaf9cd:         connection.send(createBeginTransaction(connectionInfo, txid));
1:efaf9cd: 
1:efaf9cd:         // use consumer per destination for the composite dest case
1:efaf9cd:         // bc the same composite dest is used for sending so there
1:efaf9cd:         // will be duplicate message ids in the mix which a single
1:efaf9cd:         // consumer (PrefetchSubscription) cannot handle in a tx
1:efaf9cd:         // atm. The matching is based on messageId rather than messageId
1:efaf9cd:         // and destination
1:efaf9cd:         Set<ConsumerInfo> consumerInfos = new HashSet<ConsumerInfo>();
1:efaf9cd:         for (ActiveMQDestination dest : destinationList(destination)) {
1:efaf9cd:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:efaf9cd:             consumerInfos.add(consumerInfo);
1:efaf9cd:         }
1:efaf9cd: 
1:efaf9cd:         for (ConsumerInfo info : consumerInfos) {
1:efaf9cd:             connection.send(info);
1:efaf9cd:         }
1:efaf9cd: 
1:efaf9cd:         Message message = null;
1:efaf9cd:         for (ConsumerInfo info : consumerInfos) {
1:efaf9cd:             for (int i = 0; i < numMessages; i++) {
1:efaf9cd:                 message = receiveMessage(connection);
1:efaf9cd:                 assertNotNull(message);
1:efaf9cd:                 connection.send(createAck(info, message, 1, MessageAck.DELIVERED_ACK_TYPE));
1:e900fb4:             }
1:efaf9cd:             MessageAck ack = createAck(info, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:efaf9cd:             ack.setTransactionId(txid);
1:efaf9cd:             connection.send(ack);
1:98b7dcd:         }
1:efaf9cd:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:efaf9cd: 
1:efaf9cd:         // reconnect
1:efaf9cd:         connection.send(connectionInfo.createRemoveCommand());
1:efaf9cd:         connection = createConnection();
1:d29ca2a:         connection.send(connectionInfo);
1:efaf9cd: 
1:efaf9cd:         // validate recovery
1:efaf9cd:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:efaf9cd:         DataArrayResponse dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1:efaf9cd: 
1:efaf9cd:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:efaf9cd:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1:98b7dcd: 
1:d29ca2a:         connection.send(sessionInfo);
1:98b7dcd: 
1:efaf9cd:         LOG.info("add consumers..");
1:efaf9cd:         for (ConsumerInfo info : consumerInfos) {
1:efaf9cd:             connection.send(info);
1:efaf9cd:         }
1:efaf9cd: 
1:efaf9cd:         // no redelivery, exactly once semantics while prepared
1:efaf9cd:         message = receiveMessage(connection);
1:efaf9cd:         assertNull(message);
1:efaf9cd:         assertNoMessagesLeft(connection);
1:efaf9cd: 
1:efaf9cd:         // rollback so we get redelivery
1:efaf9cd:         connection.request(createRollbackTransaction(connectionInfo, txid));
1:efaf9cd: 
1:efaf9cd:         LOG.info("new tx for redelivery");
1:efaf9cd:         txid = createXATransaction(sessionInfo);
1:efaf9cd:         connection.send(createBeginTransaction(connectionInfo, txid));
1:efaf9cd: 
1:e900fb4:         for (ConsumerInfo info : consumerInfos) {
1:efaf9cd:             for (int i = 0; i < numMessages; i++) {
1:e900fb4:                 message = receiveMessage(connection);
1:efaf9cd:                 assertNotNull("unexpected null on:" + i, message);
1:efaf9cd:                 LOG.info("REC " + message.getMessageId());
1:efaf9cd:                 MessageAck ack = createAck(info, message, 1, MessageAck.STANDARD_ACK_TYPE);
1:efaf9cd:                 ack.setTransactionId(txid);
1:efaf9cd:                 connection.send(ack);
1:efaf9cd:             }
1:efaf9cd:         }
1:efaf9cd: 
1:efaf9cd:         // Commit
1:efaf9cd:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1:efaf9cd: 
1:efaf9cd:         // validate recovery complete
1:efaf9cd:         dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1:efaf9cd:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:efaf9cd:     }
1:101e711: 
1:64f3492:     public void initCombosForTestTopicPersistentPreparedAcksAvailableAfterRestartAndRollback() {
1:64f3492:         addCombinationValues("prioritySupport", new Boolean[]{Boolean.FALSE, Boolean.TRUE});
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void testTopicPersistentPreparedAcksAvailableAfterRestartAndRollback() throws Exception {
1:64f3492: 
1:64f3492:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1:64f3492: 
1:64f3492:         // Setup the producer and send the message.
1:64f3492:         StubConnection connection = createConnection();
1:64f3492:         ConnectionInfo connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:64f3492:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         connection.send(producerInfo);
1:64f3492: 
1:64f3492:         // setup durable subs
1:64f3492:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:64f3492:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         int numMessages = 4;
1:64f3492:         for (int i = 0; i < numMessages; i++) {
1:64f3492:             Message message = createMessage(producerInfo, destination);
1:64f3492:             message.setPersistent(true);
1:64f3492:             connection.send(message);
1:64f3492:         }
1:64f3492: 
1:64f3492:         // Begin the transaction.
1:64f3492:         XATransactionId txid = createXATransaction(sessionInfo);
1:64f3492:         connection.send(createBeginTransaction(connectionInfo, txid));
1:64f3492: 
1:64f3492:         Message message = null;
1:64f3492:         for (int i = 0; i < numMessages; i++) {
1:64f3492:             message = receiveMessage(connection);
1:64f3492:             assertNotNull(message);
1:64f3492:         }
1:64f3492: 
1:64f3492:         // one ack with last received, mimic a beforeEnd synchronization
1:64f3492:         MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:64f3492:         ack.setTransactionId(txid);
1:64f3492:         connection.send(ack);
1:64f3492: 
1:64f3492:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:64f3492: 
1:64f3492:         // restart the broker.
1:64f3492:         restartBroker();
1:64f3492: 
1:64f3492:         connection = createConnection();
1:64f3492:         connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:64f3492:         connection.send(connectionInfo);
1:64f3492: 
1:64f3492:         // validate recovery
1:64f3492:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:64f3492:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:64f3492: 
1:64f3492:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:64f3492:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1:64f3492: 
1:64f3492:         sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:98b7dcd:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         // no redelivery, exactly once semantics while prepared
1:64f3492:         message = receiveMessage(connection);
1:64f3492:         assertNull(message);
1:64f3492:         assertNoMessagesLeft(connection);
1:64f3492: 
1:64f3492:         // rollback so we get redelivery
1:64f3492:         connection.request(createRollbackTransaction(connectionInfo, txid));
1:64f3492: 
2:64f3492:         LOG.info("new tx for redelivery");
1:64f3492:         txid = createXATransaction(sessionInfo);
1:64f3492:         connection.send(createBeginTransaction(connectionInfo, txid));
1:101e711: 
1:64f3492:         for (int i = 0; i < numMessages; i++) {
1:98b7dcd:             message = receiveMessage(connection);
1:64f3492:             assertNotNull("unexpected null on:" + i, message);
1:64f3492:         }
1:64f3492:         ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:98b7dcd:         ack.setTransactionId(txid);
1:98b7dcd:         connection.send(ack);
1:64f3492: 
1:64f3492:         // Commit
1:64f3492:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1:64f3492: 
1:64f3492:         // validate recovery complete
1:64f3492:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:64f3492:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:64f3492:     }
1:101e711: 
1:64f3492:     public void initCombosForTestTopicPersistentPreparedAcksAvailableAfterRollback() {
1:64f3492:         addCombinationValues("prioritySupport", new Boolean[]{Boolean.FALSE, Boolean.TRUE});
1:64f3492:     }
1:64f3492: 
1:64f3492:     public void testTopicPersistentPreparedAcksAvailableAfterRollback() throws Exception {
1:64f3492: 
1:64f3492:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1:64f3492: 
1:64f3492:         // Setup the producer and send the message.
1:64f3492:         StubConnection connection = createConnection();
1:64f3492:         ConnectionInfo connectionInfo = createConnectionInfo();
1:64f3492:         connectionInfo.setClientId("durable");
1:64f3492:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:64f3492:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:64f3492:         connection.send(connectionInfo);
1:64f3492:         connection.send(sessionInfo);
1:64f3492:         connection.send(producerInfo);
1:64f3492: 
1:64f3492:         // setup durable subs
1:64f3492:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:64f3492:         consumerInfo.setSubscriptionName("durable");
1:64f3492:         connection.send(consumerInfo);
1:64f3492: 
1:64f3492:         int numMessages = 4;
1:64f3492:         for (int i = 0; i < numMessages; i++) {
1:64f3492:             Message message = createMessage(producerInfo, destination);
1:64f3492:             message.setPersistent(true);
1:64f3492:             connection.send(message);
1:64f3492:         }
1:64f3492: 
1:64f3492:         // Begin the transaction.
1:64f3492:         XATransactionId txid = createXATransaction(sessionInfo);
1:64f3492:         connection.send(createBeginTransaction(connectionInfo, txid));
1:64f3492: 
1:64f3492:         Message message = null;
1:64f3492:         for (int i = 0; i < numMessages; i++) {
1:64f3492:             message = receiveMessage(connection);
1:64f3492:             assertNotNull(message);
1:64f3492:         }
1:64f3492: 
1:64f3492:         // one ack with last received, mimic a beforeEnd synchronization
1:64f3492:         MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:64f3492:         ack.setTransactionId(txid);
1:64f3492:         connection.send(ack);
1:64f3492: 
1:64f3492:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:64f3492: 
1:64f3492:         // rollback so we get redelivery
1:64f3492:         connection.request(createRollbackTransaction(connectionInfo, txid));
1:64f3492: 
1:b07f31e:         LOG.info("new consumer/tx for redelivery");
1:b07f31e:         connection.request(closeConnectionInfo(connectionInfo));
1:b07f31e: 
1:b07f31e:         connectionInfo = createConnectionInfo();
1:b07f31e:         connectionInfo.setClientId("durable");
1:b07f31e:         sessionInfo = createSessionInfo(connectionInfo);
1:b07f31e:         connection.send(connectionInfo);
1:b07f31e:         connection.send(sessionInfo);
1:b07f31e: 
1:b07f31e:         // setup durable subs
1:b07f31e:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:b07f31e:         consumerInfo.setSubscriptionName("durable");
1:b07f31e:         connection.send(consumerInfo);
1:101e711: 
1:64f3492:         txid = createXATransaction(sessionInfo);
1:64f3492:         connection.send(createBeginTransaction(connectionInfo, txid));
1:101e711: 
1:64f3492:         for (int i = 0; i < numMessages; i++) {
1:64f3492:             message = receiveMessage(connection);
1:64f3492:             assertNotNull("unexpected null on:" + i, message);
1:64f3492:         }
1:64f3492:         ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:64f3492:         ack.setTransactionId(txid);
1:64f3492:         connection.send(ack);
1:101e711: 
1:64f3492:         // Commit
1:64f3492:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1:98b7dcd:     }
1:d29ca2a: 
1:1595378:     private ActiveMQDestination[] destinationList(ActiveMQDestination dest) {
1:1595378:         return dest.isComposite() ? dest.getCompositeDestinations() : new ActiveMQDestination[]{dest};
1:1595378:     }
1:1595378: 
1:1595378:     private int expectedMessageCount(int i, ActiveMQDestination destination) {
1:1595378:         return i * (destination.isComposite() ? destination.getCompositeDestinations().length : 1);
1:1595378:     }
1:1595378: 
1:7f5213b:     public void testQueuePersistentUncommittedAcksLostOnRestart() throws Exception {
1:d29ca2a: 
1:e39a679:         ActiveMQDestination destination = createDestination();
1:d29ca2a: 
4:d29ca2a:         // Setup the producer and send the message.
1:5f6f23e:         StubConnection connection = createConnection();
1:5f6f23e:         ConnectionInfo connectionInfo = createConnectionInfo();
1:5f6f23e:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:5f6f23e:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:5f6f23e:         connection.send(connectionInfo);
1:5f6f23e:         connection.send(sessionInfo);
4:d29ca2a:         connection.send(producerInfo);
1:d29ca2a: 
1:98b7dcd:         for (int i = 0; i < 4; i++) {
1:5f6f23e:             Message message = createMessage(producerInfo, destination);
1:5f6f23e:             message.setPersistent(true);
1:5f6f23e:             connection.send(message);
1:101e711:         }
1:d29ca2a: 
1:5f6f23e:         // Begin the transaction.
1:5f6f23e:         XATransactionId txid = createXATransaction(sessionInfo);
1:5f6f23e:         connection.send(createBeginTransaction(connectionInfo, txid));
1:d29ca2a: 
1:1595378:         Message message = null;
1:1595378:         for (ActiveMQDestination dest : destinationList(destination)) {
1:101e711:             // Setup the consumer and receive the message.
1:98b7dcd:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:98b7dcd:             connection.send(consumerInfo);
1:d29ca2a: 
1:98b7dcd:             for (int i = 0; i < 4; i++) {
1:98b7dcd:                 message = receiveMessage(connection);
1:98b7dcd:                 assertNotNull(message);
1:230a86c:             }
1:98b7dcd:             MessageAck ack = createAck(consumerInfo, message, 4, MessageAck.STANDARD_ACK_TYPE);
1:1595378:             ack.setTransactionId(txid);
1:69c0d39:             connection.request(ack);
1:d29ca2a:         }
1:98b7dcd: 
1:d29ca2a:         // Don't commit
1:230a86c: 
1:5f6f23e:         // restart the broker.
1:5f6f23e:         restartBroker();
1:d29ca2a: 
5:d29ca2a:         // Setup the consumer and receive the message.
1:5f6f23e:         connection = createConnection();
1:5f6f23e:         connectionInfo = createConnectionInfo();
1:d29ca2a:         sessionInfo = createSessionInfo(connectionInfo);
1:5f6f23e:         connection.send(connectionInfo);
1:5f6f23e:         connection.send(sessionInfo);
1:d29ca2a: 
1:1595378:         for (ActiveMQDestination dest : destinationList(destination)) {
1:d29ca2a:             // Setup the consumer and receive the message.
1:98b7dcd:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:101e711:             connection.send(consumerInfo);
1:d29ca2a: 
1:101e711:             for (int i = 0; i < 4; i++) {
3:101e711:                 message = receiveMessage(connection);
1:1595378:                 assertNotNull(message);
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a: 
1:d29ca2a:         assertNoMessagesLeft(connection);
1:d29ca2a:     }
1:d29ca2a: 
1:64f3492:     @Override
1:64f3492:     protected PolicyEntry getDefaultPolicy() {
1:64f3492:         PolicyEntry policyEntry = super.getDefaultPolicy();
1:64f3492:         policyEntry.setPrioritizedMessages(prioritySupport);
1:64f3492:         return policyEntry;
1:64f3492:     }
1:64f3492: 
1:d29ca2a:     public static Test suite() {
1:d29ca2a:         return suite(XARecoveryBrokerTest.class);
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a:     public static void main(String[] args) {
1:d29ca2a:         junit.textui.TestRunner.run(suite());
1:d29ca2a:     }
1:d29ca2a: 
1:e39a679:     protected ActiveMQDestination createDestination() {
1:e39a679:         return new ActiveMQQueue(getClass().getName() + "." + getName());
1:d29ca2a:     }
1:230a86c: 
1:d29ca2a: }
============================================================================
author:Jeff Genender
-------------------------------------------------------------------------------
commit:28819ae
/////////////////////////////////////////////////////////////////////////
1:     public void testPreparedTransactionRecoveredPurgeRollbackOnRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:             adapter.setPurgeRecoveredXATransactionStrategy("ROLLBACK");
/////////////////////////////////////////////////////////////////////////
1:         // Since rolledback but not committed.. they should not get delivered.
1:         assertNull(receiveMessage(connection));
1:         assertNoMessagesLeft(connection);
1: 
1:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         assertNotNull(response);
1:         DataArrayResponse dar = (DataArrayResponse)response;
1: 
1:         //These should be purged so expect 0
1:         assertEquals(0, dar.getData().length);
1: 
1:     }
1: 
1:     public void testPreparedTransactionRecoveredPurgeCommitOnRestart() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Prepare 4 message sends.
1:         for (int i = 0; i < 4; i++) {
1:             // Begin the transaction.
1:             XATransactionId txid = createXATransaction(sessionInfo);
1:             connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1: 
1:             // Prepare
1:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:         }
1: 
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         // restart the broker.
1:         stopBroker();
1:         if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:             KahaDBPersistenceAdapter adapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
1:             adapter.setPurgeRecoveredXATransactionStrategy("COMMIT");
1:             LOG.info("Setting purgeRecoveredXATransactions to true on the KahaDBPersistenceAdapter");
1:         }
1:         broker.start();
1: 
1:         // Setup the consumer and try receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Since committed ... they should get delivered.
1:         for (int i = 0; i < 4; i++) {
1:             assertNotNull(receiveMessage(connection));
1:         }
1:         assertNoMessagesLeft(connection);
author:hkesler
-------------------------------------------------------------------------------
commit:24b9ae2
/////////////////////////////////////////////////////////////////////////
0:     public void testPreparedTransactionRecoveredPurgeOnRestart() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Prepare 4 message sends.
1:         for (int i = 0; i < 4; i++) {
1:             // Begin the transaction.
1:             XATransactionId txid = createXATransaction(sessionInfo);
1:             connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1: 
1:             // Prepare
1:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:         }
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNull(receiveMessage(connection));
1:         assertNoMessagesLeft(connection);
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         // restart the broker.
1:         stopBroker();
1:         if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:             KahaDBPersistenceAdapter adapter = (KahaDBPersistenceAdapter)broker.getPersistenceAdapter();
0:             adapter.setPurgeRecoveredXATransactions(true);
1:             LOG.info("Setting purgeRecoveredXATransactions to true on the KahaDBPersistenceAdapter");
1:         }
1:         broker.start();
1: 
1:         // Setup the consumer and try receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNull(receiveMessage(connection));
1:         assertNoMessagesLeft(connection);
1: 
1:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         assertNotNull(response);
1:         DataArrayResponse dar = (DataArrayResponse)response;
1: 
1:         //These should be purged so expect 0
1:         assertEquals(0, dar.getData().length);
1: 
1:     }
1: 
author:gtully
-------------------------------------------------------------------------------
commit:bd45d93
/////////////////////////////////////////////////////////////////////////
1:     public boolean prioritySupport = true;
/////////////////////////////////////////////////////////////////////////
1:     public void x_initCombosForTestTopicPersistentPreparedAcksNotLostOnRestart() {
commit:ea70e82
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("enqueue count does not see prepared acks", 0, destinationView.getQueueSize());
1:         assertEquals("dequeue count does not see prepared acks", 0, destinationView.getDequeueCount());
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("dequeue count does not see commited acks", 4, destinationView.getDequeueCount());
commit:efaf9cd
/////////////////////////////////////////////////////////////////////////
1:         connection.request(consumerInfo.createRemoveCommand());
1: 
1:         LOG.info("Send some more before the rollback");
1:         // send some more messages
1:         producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         for (int i = 0; i < numMessages*2; i++) {
1:             message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         }
1: 
1:         LOG.info("Send some more before the rollback");
/////////////////////////////////////////////////////////////////////////
1:         Set<ConsumerInfo> consumerInfoSet = new HashSet<ConsumerInfo>();
1:             consumerInfoSet.add(consumerInfo);
1:             LOG.info("consume messages for: " + dest.getPhysicalName() + " " + consumerInfo.getConsumerId());
1:                 LOG.info(dest.getPhysicalName()  + " ID: " + message.getMessageId());
1:             connection.request(ack);
1: 
1:             // clear any pending messages on the stub connection via prefetch
1:             while ((message = receiveMessage(connection)) != null) {
1:                 LOG.info("Pre fetched and unwanted: " + message.getMessageId() + " on " + message.getDestination().getPhysicalName());
1:             }
1:         LOG.info("commit..");
1:         // remove consumers 'after' commit b/c of inflight tally issue
1:         for (ConsumerInfo info : consumerInfoSet) {
1:             connection.request(info.createRemoveCommand());
1:         }
1:         consumerInfoSet.clear();
1: 
1: 
1:         LOG.info("consume additional messages");
1: 
1:         // clear any pending messages on the stub connection via prefetch
1:         while ((message = receiveMessage(connection)) != null) {
1:             LOG.info("Pre fetched and unwanted: " + message.getMessageId() + " on " + message.getDestination().getPhysicalName());
1:         }
1:         // consume the additional messages
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1: 
1:             // Setup the consumer and receive the message.
1:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             connection.request(consumerInfo);
1: 
1:             LOG.info("consume additional messages for: " + dest.getPhysicalName() + " " + consumerInfo.getConsumerId());
1: 
1:             for (int i = 0; i < numMessages*2; i++) {
1:                 message = receiveMessage(connection);
1:                 assertNotNull("unexpected null on:" + i, message);
1:                 LOG.info(dest.getPhysicalName()  + " ID: " + message.getMessageId());
1:                 MessageAck ack = createAck(consumerInfo, message, 1, MessageAck.STANDARD_ACK_TYPE);
1:                 connection.request(ack);
1:             }
1:             connection.request(consumerInfo.createRemoveCommand());
1:         }
1: 
1:         assertNoMessagesLeft(connection);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testQueuePersistentPreparedAcksAvailableAfterRollback() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         int numMessages = 4;
1:         for (int i = 0; i < numMessages; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             connection.send(message);
1:         }
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         // use consumer per destination for the composite dest case
1:         // bc the same composite dest is used for sending so there
1:         // will be duplicate message ids in the mix which a single
1:         // consumer (PrefetchSubscription) cannot handle in a tx
1:         // atm. The matching is based on messageId rather than messageId
1:         // and destination
1:         Set<ConsumerInfo> consumerInfos = new HashSet<ConsumerInfo>();
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             consumerInfos.add(consumerInfo);
1:         }
1: 
1:         for (ConsumerInfo info : consumerInfos) {
1:             connection.send(info);
1:         }
1: 
1:         Message message = null;
1:         for (ConsumerInfo info : consumerInfos) {
1:             for (int i = 0; i < numMessages; i++) {
1:                 message = receiveMessage(connection);
1:                 assertNotNull(message);
1:                 connection.send(createAck(info, message, 1, MessageAck.DELIVERED_ACK_TYPE));
1:             }
1:             MessageAck ack = createAck(info, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
1:             connection.send(ack);
1:         }
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
1: 
1:         // reconnect
1:         connection.send(connectionInfo.createRemoveCommand());
1:         connection = createConnection();
1:         connection.send(connectionInfo);
1: 
1:         // validate recovery
1:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:         DataArrayResponse dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1: 
1:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1: 
1:         connection.send(sessionInfo);
1: 
1:         LOG.info("add consumers..");
1:         for (ConsumerInfo info : consumerInfos) {
1:             connection.send(info);
1:         }
1: 
1:         // no redelivery, exactly once semantics while prepared
1:         message = receiveMessage(connection);
1:         assertNull(message);
1:         assertNoMessagesLeft(connection);
1: 
1:         // rollback so we get redelivery
1:         connection.request(createRollbackTransaction(connectionInfo, txid));
1: 
1:         LOG.info("new tx for redelivery");
1:         txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         for (ConsumerInfo info : consumerInfos) {
1:             for (int i = 0; i < numMessages; i++) {
1:                 message = receiveMessage(connection);
1:                 assertNotNull("unexpected null on:" + i, message);
1:                 LOG.info("REC " + message.getMessageId());
1:                 MessageAck ack = createAck(info, message, 1, MessageAck.STANDARD_ACK_TYPE);
1:                 ack.setTransactionId(txid);
1:                 connection.send(ack);
1:             }
1:         }
1: 
1:         // Commit
1:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1: 
1:         // validate recovery complete
1:         dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:     }
1: 
commit:16bc0f0
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: import org.apache.activemq.ActiveMQConnection;
1: import org.apache.activemq.TransactionContext;
/////////////////////////////////////////////////////////////////////////
1:         // verify XAResource scan loop
1:         XAResource transactionContextXAResource = new TransactionContext(ActiveMQConnection.makeConnection(broker.getVmConnectorURI().toString()));
1:         LinkedList<Xid> tracked = new LinkedList<Xid>();
1:         Xid[] recoveryXids = transactionContextXAResource.recover(XAResource.TMSTARTRSCAN);
1:         while (recoveryXids.length > 0) {
1:             tracked.addAll(Arrays.asList(recoveryXids));
1:             recoveryXids = transactionContextXAResource.recover(XAResource.TMNOFLAGS);
1:         }
1:         assertEquals("got 4 via scan loop", 4, tracked.size());
1: 
commit:0709c2c
/////////////////////////////////////////////////////////////////////////
1:         ObjectName objectName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,transactionType=RecoveredXaTransaction,xid=" +
commit:cfe099d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy;
/////////////////////////////////////////////////////////////////////////
1:             TransactionId transactionId = (TransactionId) dar.getData()[i];
1:             LOG.info("commit: " + transactionId);
1:             connection.request(createCommitTransaction2Phase(connectionInfo, transactionId));
1:             LOG.info("received: " + m);
1:         assertEmptyDLQ();
1:     }
1: 
1:     private void assertEmptyDLQ() throws Exception {
1:         try {
1:             DestinationViewMBean destinationView = getProxyToDestination(new ActiveMQQueue(SharedDeadLetterStrategy.DEFAULT_DEAD_LETTER_QUEUE_NAME));
1:             assertEquals("nothing on dlq", 0, destinationView.getQueueSize());
1:             assertEquals("nothing added to dlq", 0, destinationView.getEnqueueCount());
1:         } catch (java.lang.reflect.UndeclaredThrowableException maybeOk) {
1:             if (maybeOk.getUndeclaredThrowable() instanceof javax.management.InstanceNotFoundException) {
1:                 // perfect no dlq
1:             } else {
1:                 throw maybeOk;
1:             }
1:         }
1:     }
1: 
1:     public void testPreparedInterleavedTransactionRecoveredOnRestart() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Prepare 4 message sends.
1:         for (int i = 0; i < 4; i++) {
1:             // Begin the transaction.
1:             XATransactionId txid = createXATransaction(sessionInfo);
1:             connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1: 
1:             // Prepare
1:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:         }
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNull(receiveMessage(connection));
1:         assertNoMessagesLeft(connection);
1: 
1:         // send non tx message
1:         Message message = createMessage(producerInfo, destination);
1:         message.setPersistent(true);
1:         connection.request(message);
1: 
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         // restart the broker.
1:         restartBroker();
1: 
1:         // Setup the consumer and try receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // consume non transacted message, but don't ack
1:         int countToReceive = expectedMessageCount(1, destination);
1:         for (int i=0; i< countToReceive; i++) {
1:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:             LOG.info("received: " + m);
1:             assertNotNull("got non tx message after prepared", m);
1:         }
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNull(receiveMessage(connection));
1:         assertNoMessagesLeft(connection);
1: 
1:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         assertNotNull(response);
1:         DataArrayResponse dar = (DataArrayResponse)response;
1:         assertEquals(4, dar.getData().length);
1: 
1:         // ensure we can close a connection with prepared transactions
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         // open again  to deliver outcome
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1: 
1:         // Commit the prepared transactions.
1:         for (int i = 0; i < dar.getData().length; i++) {
1:             TransactionId transactionId = (TransactionId) dar.getData()[i];
1:             LOG.info("commit: " + transactionId);
1:             connection.request(createCommitTransaction2Phase(connectionInfo, transactionId));
1:         }
1: 
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // We should get the committed transactions and the non tx message
1:         countToReceive = expectedMessageCount(5, destination);
1:         for (int i = 0; i < countToReceive ; i++) {
1:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:             LOG.info("received: " + m);
1:             assertNotNull("Got non null message: " + i, m);
1:         }
1: 
1:         assertNoMessagesLeft(connection);
1:         assertEmptyDLQ();
commit:69c0d39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.jmx.BrokerMBeanSupport;
1: import org.apache.activemq.broker.jmx.PersistenceAdapterViewMBean;
1: import org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
1:         // view prepared in kahadb view
1:         if (broker.getPersistenceAdapter() instanceof KahaDBPersistenceAdapter) {
1:             PersistenceAdapterViewMBean kahadbView = getProxyToPersistenceAdapter(broker.getPersistenceAdapter().toString());
1:             String txFromView = kahadbView.getTransactions();
1:             LOG.info("Tx view fromm PA:" + txFromView);
1:             assertTrue("xid with our dud format in transaction string " + txFromView, txFromView.contains("XID:[55,"));
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private PersistenceAdapterViewMBean getProxyToPersistenceAdapter(String name) throws MalformedObjectNameException, JMSException {
1:        return (PersistenceAdapterViewMBean)broker.getManagementContext().newProxyInstance(
1:                BrokerMBeanSupport.createPersistenceAdapterName(broker.getBrokerObjectName().toString(), name),
1:                PersistenceAdapterViewMBean.class, true);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             connection.request(createCommitTransaction2Phase(connectionInfo, (TransactionId) dar.getData()[i]));
/////////////////////////////////////////////////////////////////////////
0:             connection.request(createCommitTransaction2Phase(connectionInfo, (TransactionId) dar.getData()[i]));
/////////////////////////////////////////////////////////////////////////
1:             connection.request(ack);
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:f9bec8f
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:ef24cc9
author:Robert Davies
-------------------------------------------------------------------------------
commit:cb7b657
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.command.*;
/////////////////////////////////////////////////////////////////////////
0:         ObjectName objectName = new ObjectName("org.apache.activemq:type=Broker,brokerName=localhost,transactionType=RecoveredXaTransaction,Xid=" +
1:                 JMXSupport.encodeObjectNamePart(xid.toString()));
/////////////////////////////////////////////////////////////////////////
1:         final ObjectName objectName = new ObjectName("org.apache.activemq:type=Broker,brokerName="+broker.getBrokerName()+",destinationType="
1:                 + JMXSupport.encodeObjectNamePart(destination.getDestinationTypeAsString())
1:                 + ",destinationName=" + JMXSupport.encodeObjectNamePart(destination.getPhysicalName()));
1: 
commit:2a6a441
/////////////////////////////////////////////////////////////////////////
1:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
commit:c97b97e
/////////////////////////////////////////////////////////////////////////
1:         connection.request(closeConnectionInfo(connectionInfo));
/////////////////////////////////////////////////////////////////////////
1:         connection.request(closeConnectionInfo(connectionInfo));
author:Gary Tully
-------------------------------------------------------------------------------
commit:d41f40a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final int countToReceive = expectedMessageCount(4, destination);
1:         for (int i = 0; i < countToReceive ; i++) {
1:             assertNotNull("Got non null message: " + i, m);
commit:e900fb4
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:     public void testQueuePersistentPreparedAcksAvailableAfterRollbackPrefetchOne() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         int numMessages = 1;
1:         for (int i = 0; i < numMessages; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         }
1: 
1:         final int messageCount = expectedMessageCount(numMessages, destination);
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         // use consumer per destination for the composite dest case
1:         // bc the same composite dest is used for sending so there
1:         // will be duplicate message ids in the mix which a single
1:         // consumer (PrefetchSubscription) cannot handle in a tx
1:         // atm. The matching is based on messageId rather than messageId
1:         // and destination
1:         Set<ConsumerInfo> consumerInfos = new HashSet<ConsumerInfo>();
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             consumerInfo.setPrefetchSize(numMessages);
1:             consumerInfos.add(consumerInfo);
1:         }
1: 
1:         for (ConsumerInfo info : consumerInfos) {
1:             connection.send(info);
1:         }
1: 
1:         Message message = null;
1:         for (ConsumerInfo info : consumerInfos) {
1:             for (int i = 0; i < numMessages; i++) {
1:                message = receiveMessage(connection);
1:                assertNotNull(message);
1:                connection.send(createAck(info, message, 1, MessageAck.DELIVERED_ACK_TYPE));
1:             }
1:             MessageAck ack = createAck(info, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
1:             connection.send(ack);
1:         }
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
1: 
1:         // reconnect
1:         connection.send(connectionInfo.createRemoveCommand());
1:         connection = createConnection();
1:         connection.send(connectionInfo);
1: 
1:         // validate recovery
1:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:         DataArrayResponse dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1: 
1:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1: 
1:         connection.send(sessionInfo);
1: 
1:         for (ConsumerInfo info : consumerInfos) {
1:             connection.send(info);
1:         }
1: 
1:         // no redelivery, exactly once semantics while prepared
1:         message = receiveMessage(connection);
1:         assertNull(message);
1:         assertNoMessagesLeft(connection);
1: 
1:         // rollback so we get redelivery
1:         connection.request(createRollbackTransaction(connectionInfo, txid));
1: 
1:         LOG.info("new tx for redelivery");
1:         txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         for (ConsumerInfo info : consumerInfos) {
1:             for (int i = 0; i < numMessages; i++) {
1:                 message = receiveMessage(connection);
1:                 assertNotNull("unexpected null on:" + i, message);
1:                 MessageAck ack = createAck(info, message, 1, MessageAck.STANDARD_ACK_TYPE);
1:                 ack.setTransactionId(txid);
1:                 connection.send(ack);
1:             }
1:         }
1: 
1:         // Commit
1:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1: 
1:         // validate recovery complete
1:         dataArrayResponse = (DataArrayResponse) connection.request(recoverInfo);
1:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:     }
1: 
commit:60624c4
/////////////////////////////////////////////////////////////////////////
1:         int commitCount = 0;
1:                 commitCount++;
/////////////////////////////////////////////////////////////////////////
1:         // verify messages available
1:         assertEquals("enqueue count reflects outcome", commitCount, destinationView.getQueueSize());
1: 
/////////////////////////////////////////////////////////////////////////
1:         // validate destination depth via jmx
1:         DestinationViewMBean destinationView = getProxyToDestination(destinationList(destination)[0]);
0:         assertEquals("enqueue count does not see prepared acks", 4, destinationView.getQueueSize());
0:         assertEquals("enqueue count does not see prepared acks", 0, destinationView.getDequeueCount());
1: 
1: 
1:         assertEquals("enqueue count does not see commited acks", 0, destinationView.getQueueSize());
0:         assertEquals("enqueue count does not see commited acks", 4, destinationView.getDequeueCount());
1: 
commit:b07f31e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final int numMessages = 4;
1:         for (int i = 0; i < numMessages; i++) {
/////////////////////////////////////////////////////////////////////////
0:         final int messageCount = expectedMessageCount(numMessages, destination);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("new consumer/tx for redelivery");
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1: 
1:         // setup durable subs
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
commit:64f3492
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.jmx.DestinationView;
1: import org.apache.activemq.broker.jmx.DestinationViewMBean;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.command.ActiveMQTopic;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.jdbc.JDBCPersistenceAdapter;
/////////////////////////////////////////////////////////////////////////
0:     public boolean prioritySupport = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // validate destination depth via jmx
1:         DestinationViewMBean destinationView = getProxyToDestination(destinationList(destination)[0]);
1:         assertEquals("enqueue count does not see prepared", 0, destinationView.getQueueSize());
1: 
/////////////////////////////////////////////////////////////////////////
1:     private DestinationViewMBean getProxyToDestination(ActiveMQDestination destination) throws MalformedObjectNameException, JMSException {
1: 
0:         ObjectName objectName = new ObjectName("org.apache.activemq:Type=" + (destination.isQueue() ? "Queue" : "Topic") + ",Destination=" +
0:                 JMXSupport.encodeObjectNamePart(destination.getPhysicalName()) + ",BrokerName=localhost");
1:         DestinationViewMBean proxy = (DestinationViewMBean) broker.getManagementContext().newProxyInstance(objectName,
1:                 DestinationViewMBean.class, true);
1:         return proxy;
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testTopicPreparedTransactionRecoveredOnRestart() throws Exception {
1:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1: 
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         // Prepare 4 message sends.
1:         for (int i = 0; i < 4; i++) {
1:             // Begin the transaction.
1:             XATransactionId txid = createXATransaction(sessionInfo);
1:             connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1: 
1:             // Prepare
1:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:         }
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNull(receiveMessage(connection));
1:         assertNoMessagesLeft(connection);
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         // restart the broker.
1:         restartBroker();
1: 
1:         // Setup the consumer and try receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1: 
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNull(receiveMessage(connection));
1:         assertNoMessagesLeft(connection);
1: 
1:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         assertNotNull(response);
1:         DataArrayResponse dar = (DataArrayResponse) response;
1:         assertEquals(4, dar.getData().length);
1: 
1:         // ensure we can close a connection with prepared transactions
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         // open again  to deliver outcome
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         // Commit the prepared transactions.
1:         for (int i = 0; i < dar.getData().length; i++) {
0:             connection.send(createCommitTransaction2Phase(connectionInfo, (TransactionId) dar.getData()[i]));
1:         }
1: 
1:         // We should get the committed transactions.
1:         for (int i = 0; i < expectedMessageCount(4, destination); i++) {
1:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
1:             assertNotNull(m);
1:         }
1: 
1:         assertNoMessagesLeft(connection);
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testQueuePersistentCommited2PhaseMessagesNotLostOnRestart() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         for (int i = 0; i < 4; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1:         }
1: 
1:         // Commit 2 phase
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
1:         connection.send(createCommitTransaction2Phase(connectionInfo, txid));
1: 
1:         connection.request(closeConnectionInfo(connectionInfo));
1:         // restart the broker.
1:         restartBroker();
1: 
1:         // Setup the consumer and receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         for (int i = 0; i < expectedMessageCount(4, destination); i++) {
1:             Message m = receiveMessage(connection);
1:             assertNotNull(m);
1:         }
1: 
1:         assertNoMessagesLeft(connection);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     public void initCombosForTestTopicPersistentPreparedAcksNotLostOnRestart() {
1:         addCombinationValues("prioritySupport", new Boolean[]{Boolean.FALSE, Boolean.TRUE});
1:     }
1: 
1:     public void testTopicPersistentPreparedAcksNotLostOnRestart() throws Exception {
0:         // REVISIT for kahadb
0:         if (! (broker.getPersistenceAdapter() instanceof JDBCPersistenceAdapter)) {
0:             LOG.warn("only works on jdbc");
0:             return;
1:         }
1:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         // setup durable subs
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         for (int i = 0; i < 4; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         }
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
0:         final int messageCount = expectedMessageCount(4, destination);
1:         Message m = null;
1:         for (int i = 0; i < messageCount; i++) {
1:             m = receiveMessage(connection);
1:             assertNotNull("unexpected null on: " + i, m);
1:         }
1: 
1:         // one ack with last received, mimic a beforeEnd synchronization
1:         MessageAck ack = createAck(consumerInfo, m, messageCount, MessageAck.STANDARD_ACK_TYPE);
1:         ack.setTransactionId(txid);
1:         connection.send(ack);
1: 
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
1: 
1:         // restart the broker.
1:         restartBroker();
1: 
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         connection.send(connectionInfo);
1: 
1:         // validate recovery
1:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1: 
1:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1: 
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         // no redelivery, exactly once semantics unless there is rollback
1:         m = receiveMessage(connection);
1:         assertNull(m);
1:         assertNoMessagesLeft(connection);
1: 
1:         connection.request(createCommitTransaction2Phase(connectionInfo, txid));
1: 
1:         // validate recovery complete
1:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         int numMessages = 4;
1:         for (int i = 0; i < numMessages; i++) {
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < numMessages; i++) {
1:             MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("new tx for redelivery");
/////////////////////////////////////////////////////////////////////////
1:             for (int i = 0; i < numMessages; i++) {
1:                 assertNotNull("unexpected null on:" + i, message);
1:             MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
/////////////////////////////////////////////////////////////////////////
1:     public void initCombosForTestTopicPersistentPreparedAcksAvailableAfterRestartAndRollback() {
1:         addCombinationValues("prioritySupport", new Boolean[]{Boolean.FALSE, Boolean.TRUE});
1:     }
1: 
1:     public void testTopicPersistentPreparedAcksAvailableAfterRestartAndRollback() throws Exception {
1: 
0:         // REVISIT for kahadb
0:         if (! (broker.getPersistenceAdapter() instanceof JDBCPersistenceAdapter)) {
0:             LOG.warn("only works on jdbc");
0:             return;
1:         }
1: 
1:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         // setup durable subs
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         int numMessages = 4;
1:         for (int i = 0; i < numMessages; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         }
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         Message message = null;
1:         for (int i = 0; i < numMessages; i++) {
1:             message = receiveMessage(connection);
1:             assertNotNull(message);
1:         }
1: 
1:         // one ack with last received, mimic a beforeEnd synchronization
1:         MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:         ack.setTransactionId(txid);
1:         connection.send(ack);
1: 
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
1: 
1:         // restart the broker.
1:         restartBroker();
1: 
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         connection.send(connectionInfo);
1: 
1:         // validate recovery
1:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1: 
1:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1: 
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         // no redelivery, exactly once semantics while prepared
1:         message = receiveMessage(connection);
1:         assertNull(message);
1:         assertNoMessagesLeft(connection);
1: 
1:         // rollback so we get redelivery
1:         connection.request(createRollbackTransaction(connectionInfo, txid));
1: 
1:         LOG.info("new tx for redelivery");
1:         txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         for (int i = 0; i < numMessages; i++) {
1:             message = receiveMessage(connection);
1:             assertNotNull("unexpected null on:" + i, message);
1:         }
1:         ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:         ack.setTransactionId(txid);
1:         connection.send(ack);
1: 
1:         // Commit
1:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1: 
1:         // validate recovery complete
1:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:     }
1: 
1:     public void initCombosForTestTopicPersistentPreparedAcksAvailableAfterRollback() {
1:         addCombinationValues("prioritySupport", new Boolean[]{Boolean.FALSE, Boolean.TRUE});
1:     }
1: 
1:     public void testTopicPersistentPreparedAcksAvailableAfterRollback() throws Exception {
1: 
0:         // REVISIT for kahadb
0:         if (! (broker.getPersistenceAdapter() instanceof JDBCPersistenceAdapter)) {
0:             LOG.warn("only works on jdbc");
0:             return;
1:         }
1: 
1:         ActiveMQDestination destination = new ActiveMQTopic("TryTopic");
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         connectionInfo.setClientId("durable");
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:         // setup durable subs
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         consumerInfo.setSubscriptionName("durable");
1:         connection.send(consumerInfo);
1: 
1:         int numMessages = 4;
1:         for (int i = 0; i < numMessages; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         }
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         Message message = null;
1:         for (int i = 0; i < numMessages; i++) {
1:             message = receiveMessage(connection);
1:             assertNotNull(message);
1:         }
1: 
1:         // one ack with last received, mimic a beforeEnd synchronization
1:         MessageAck ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:         ack.setTransactionId(txid);
1:         connection.send(ack);
1: 
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
1: 
1:         // rollback so we get redelivery
1:         connection.request(createRollbackTransaction(connectionInfo, txid));
1: 
1:         LOG.info("new tx for redelivery");
1:         txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:         for (int i = 0; i < numMessages; i++) {
1:             message = receiveMessage(connection);
1:             assertNotNull("unexpected null on:" + i, message);
1:         }
1:         ack = createAck(consumerInfo, message, numMessages, MessageAck.STANDARD_ACK_TYPE);
1:         ack.setTransactionId(txid);
1:         connection.send(ack);
1: 
1:         // Commit
1:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     protected PolicyEntry getDefaultPolicy() {
1:         PolicyEntry policyEntry = super.getDefaultPolicy();
1:         policyEntry.setPrioritizedMessages(prioritySupport);
1:         return policyEntry;
1:     }
1: 
commit:98b7dcd
/////////////////////////////////////////////////////////////////////////
1: 
1:         Message message = null;
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             // Setup the consumer and receive the message.
1:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             connection.send(consumerInfo);
1: 
1:             for (int i = 0; i < 4; i++) {
1:                 message = receiveMessage(connection);
1:                 assertNotNull(message);
1:             }
1:             MessageAck ack = createAck(consumerInfo, message, 4, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
1:             connection.send(ack);
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             // Setup the consumer and receive the message.
1:             ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             connection.send(consumerInfo);
1: 
1:             for (int i = 0; i < 4; i++) {
1:                 message = receiveMessage(connection);
1:                 assertNotNull(message);
1:             }
commit:ab9bce6
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:             Message m = receiveMessage(connection, TimeUnit.SECONDS.toMillis(10));
commit:1595378
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     protected static final Logger LOG = LoggerFactory.getLogger(XARecoveryBrokerTest.class);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < expectedMessageCount(4, destination); i++) {
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < expectedMessageCount(4, destination); i++) {
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo consumerInfo;
1:         Message m = null;
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             // Setup the consumer and receive the message.
1:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             connection.send(consumerInfo);
1: 
1:             for (int i = 0; i < 4; i++) {
1:                 m = receiveMessage(connection);
1:                 assertNotNull(m);
1:             }
1: 
1:             MessageAck ack = createAck(consumerInfo, m, 4, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
1:             connection.send(ack);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo consumerInfo;
1:         Message m = null;
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             // Setup the consumer and receive the message.
1:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             connection.send(consumerInfo);
1: 
1:             for (int i = 0; i < 4; i++) {
1:                 m = receiveMessage(connection);
1:                 assertNotNull(m);
1:             }
1: 
1:             // one ack with last received, mimic a beforeEnd synchronization
1:             MessageAck ack = createAck(consumerInfo, m, 4, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
1:             connection.send(ack);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         ConsumerInfo consumerInfo;
1:         Message message = null;
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             // Setup the consumer and receive the message.
1:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             connection.send(consumerInfo);
1: 
1:             for (int i = 0; i < 4; i++) {
1:                 message = receiveMessage(connection);
1:                 assertNotNull(message);
1:             }
1: 
1:             // one ack with last received, mimic a beforeEnd synchronization
0:             MessageAck ack = createAck(consumerInfo, message, 4, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
0:             connection.send(ack);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (ActiveMQDestination dest : destinationList(destination)) {
1:             // Setup the consumer and receive the message.
1:             consumerInfo = createConsumerInfo(sessionInfo, dest);
1:             connection.send(consumerInfo);
1: 
1:             for (int i = 0; i < 4; i++) {
1:                 message = receiveMessage(connection);
0:                 assertNotNull(message);
1:             }
0:             MessageAck ack = createAck(consumerInfo, message, 4, MessageAck.STANDARD_ACK_TYPE);
1:             ack.setTransactionId(txid);
0:             connection.send(ack);
/////////////////////////////////////////////////////////////////////////
1:     private ActiveMQDestination[] destinationList(ActiveMQDestination dest) {
1:         return dest.isComposite() ? dest.getCompositeDestinations() : new ActiveMQDestination[]{dest};
1:     }
1: 
1:     private int expectedMessageCount(int i, ActiveMQDestination destination) {
1:         return i * (destination.isComposite() ? destination.getCompositeDestinations().length : 1);
1:     }
1: 
commit:2b10259
/////////////////////////////////////////////////////////////////////////
1:         // ensure we can close a connection with prepared transactions
1:         connection.request(closeConnectionInfo(connectionInfo));
1: 
1:         // open again  to deliver outcome
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
commit:1d242a2
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.JMSException;
1: import javax.management.InstanceNotFoundException;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
1: import org.apache.activemq.broker.jmx.RecoveredXATransactionViewMBean;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.JMXSupport;
/////////////////////////////////////////////////////////////////////////
1:     public void testPreparedJmxView() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Prepare 4 message sends.
1:         for (int i = 0; i < 4; i++) {
1:             // Begin the transaction.
1:             XATransactionId txid = createXATransaction(sessionInfo);
1:             connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1: 
1:             // Prepare
1:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:         }
1: 
1:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         assertNotNull(response);
1:         DataArrayResponse dar = (DataArrayResponse)response;
1:         assertEquals(4, dar.getData().length);
1: 
1:         // restart the broker.
1:         restartBroker();
1: 
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         connection.send(connectionInfo);
1: 
1: 
1:         response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         assertNotNull(response);
1:         dar = (DataArrayResponse)response;
1:         assertEquals(4, dar.getData().length);
1: 
1:         TransactionId first = (TransactionId)dar.getData()[0];
1:         // via jmx, force outcome
1:         for (int i = 0; i < 4; i++) {
1:             RecoveredXATransactionViewMBean mbean =  getProxyToPreparedTransactionViewMBean((TransactionId)dar.getData()[i]);
1:             if (i%2==0) {
1:                 mbean.heuristicCommit();
1:             } else {
1:                 mbean.heuristicRollback();
1:             }
1:         }
1: 
1:         // verify all completed
1:         response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         assertNotNull(response);
1:         dar = (DataArrayResponse)response;
1:         assertEquals(0, dar.getData().length);
1: 
1:         // verify mbeans gone
1:         try {
1:             RecoveredXATransactionViewMBean gone = getProxyToPreparedTransactionViewMBean(first);
1:             gone.heuristicRollback();
1:             fail("Excepted not found");
1:         } catch (InstanceNotFoundException expectedNotfound) {
1:         }
1:     }
1: 
1:     private RecoveredXATransactionViewMBean getProxyToPreparedTransactionViewMBean(TransactionId xid) throws MalformedObjectNameException, JMSException {
1: 
0:         ObjectName objectName = new ObjectName("org.apache.activemq:Type=RecoveredXaTransaction,Xid=" +
0:                 JMXSupport.encodeObjectNamePart(xid.toString()) + ",BrokerName=localhost");
1:         RecoveredXATransactionViewMBean proxy = (RecoveredXATransactionViewMBean) broker.getManagementContext().newProxyInstance(objectName,
1:                 RecoveredXATransactionViewMBean.class, true);
1:         return proxy;
1:     }
1: 
commit:101e711
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.region.policy.PolicyEntry;
0: import org.apache.activemq.broker.region.policy.PolicyMap;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.openwire.v5.MessageMarshaller;
/////////////////////////////////////////////////////////////////////////
1:         assertNull(receiveMessage(connection));
1:         // Setup the consumer and try receive the message.
/////////////////////////////////////////////////////////////////////////
1:         assertNull(receiveMessage(connection));
/////////////////////////////////////////////////////////////////////////
1:         // We should get the committed transactions.
/////////////////////////////////////////////////////////////////////////
0:         Message m = null;
1:             m = receiveMessage(connection);
1: 
0:         MessageAck ack = createAck(consumerInfo, m, 4, MessageAck.STANDARD_ACK_TYPE);
0:         ack.setTransactionId(txid);
0:         connection.send(ack);
1: 
/////////////////////////////////////////////////////////////////////////
1:         m = receiveMessage(connection);
/////////////////////////////////////////////////////////////////////////
0:         Message m = null;
0:             m = receiveMessage(connection);
1: 
0:         // one ack with last received, mimic a beforeEnd synchronization
0:         MessageAck ack = createAck(consumerInfo, m, 4, MessageAck.STANDARD_ACK_TYPE);
0:         ack.setTransactionId(txid);
0:         connection.send(ack);
1: 
1: 
1:         // validate recovery
1:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1: 
1:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1: 
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         // no redelivery, exactly once semantics unless there is rollback
0:         m = receiveMessage(connection);
1:         assertNull(m);
1:         assertNoMessagesLeft(connection);
1: 
1:         connection.request(createCommitTransaction2Phase(connectionInfo, txid));
1: 
1:         // validate recovery complete
1:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
1:     }
1: 
1:     public void testQueuePersistentPreparedAcksAvailableAfterRestartAndRollback() throws Exception {
1: 
1:         ActiveMQDestination destination = createDestination();
1: 
1:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);
1: 
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         // Setup the consumer and receive the message.
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
0:         Message message = null;
1:         for (int i = 0; i < 4; i++) {
1:             message = receiveMessage(connection);
0:             assertNotNull(message);
1:         }
1: 
0:         // one ack with last received, mimic a beforeEnd synchronization
0:         MessageAck ack = createAck(consumerInfo, message, 4, MessageAck.STANDARD_ACK_TYPE);
0:         ack.setTransactionId(txid);
0:         connection.send(ack);
1: 
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
1: 
1:         // restart the broker.
1:         restartBroker();
1: 
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         connection.send(connectionInfo);
1: 
1:         // validate recovery
1:         TransactionInfo recoverInfo = new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER);
1:         DataArrayResponse dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1: 
1:         assertEquals("there is a prepared tx", 1, dataArrayResponse.getData().length);
1:         assertEquals("it matches", txid, dataArrayResponse.getData()[0]);
1: 
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // no redelivery, exactly once semantics while prepared
1:         message = receiveMessage(connection);
1:         assertNull(message);
1: 
1:         // rollback so we get redelivery
1:         connection.request(createRollbackTransaction(connectionInfo, txid));
1: 
0:         // Begin new transaction for redelivery
1:         txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1:         for (int i = 0; i < 4; i++) {
1:             message = receiveMessage(connection);
0:             assertNotNull(message);
1:         }
0:         ack = createAck(consumerInfo, message, 4, MessageAck.STANDARD_ACK_TYPE);
0:         ack.setTransactionId(txid);
0:         connection.send(ack);
1: 
1:         // Commit
1:         connection.request(createCommitTransaction1Phase(connectionInfo, txid));
1: 
1:         // validate recovery complete
1:         dataArrayResponse = (DataArrayResponse)connection.request(recoverInfo);
1:         assertEquals("there are no prepared tx", 0, dataArrayResponse.getData().length);
/////////////////////////////////////////////////////////////////////////
0:         Message m = null;
0:             m = receiveMessage(connection);
0:         MessageAck ack = createAck(consumerInfo, m, 4, MessageAck.STANDARD_ACK_TYPE);
0:         ack.setTransactionId(txid);
0:         connection.send(ack);
/////////////////////////////////////////////////////////////////////////
0:             m = receiveMessage(connection);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
1:         // Setup the producer and send the message.
1:         connection.send(producerInfo);
1: 
0:         for (int i = 0; i < 4; i++) {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         Response response = connection.request(new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER));
1:         DataArrayResponse dar = (DataArrayResponse)response;
1: 
1:         for (int i = 0; i < dar.getData().length; i++) {
0:             connection.send(createCommitTransaction2Phase(connectionInfo, (TransactionId)dar.getData()[i]));
0:         for (int i = 0; i < 4; i++) {
1: 
1: 
1: 
1:         // Setup the producer and send the message.
1:         connection.send(producerInfo);
1: 
0:         for (int i = 0; i < 4; i++) {
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < 4; i++) {
1: 
1: 
1: 
1: 
1:         // Setup the producer and send the message.
1:         connection.send(producerInfo);
1: 
0:         for (int i = 0; i < 4; i++) {
1: 
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < 4; i++) {
1:         }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:         // Setup the producer and send the message.
1:         connection.send(producerInfo);
1: 
0:         for (int i = 0; i < 4; i++) {
1: 
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < 4; i++) {
1:         }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < 4; i++) {
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:7f5213b
/////////////////////////////////////////////////////////////////////////
1:     public void testPreparedTransactionRecoveredOnRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueuePersistentCommitedMessagesNotLostOnRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueuePersistentCommitedAcksNotLostOnRestart() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void testQueuePersistentUncommittedAcksLostOnRestart() throws Exception {
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2004 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker;
1: 
1: import junit.framework.Test;
1: 
0: import org.apache.activemq.command.ActiveMQDestination;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ConnectionInfo;
0: import org.apache.activemq.command.ConsumerInfo;
0: import org.apache.activemq.command.DataArrayResponse;
0: import org.apache.activemq.command.Message;
0: import org.apache.activemq.command.MessageAck;
0: import org.apache.activemq.command.ProducerInfo;
0: import org.apache.activemq.command.Response;
0: import org.apache.activemq.command.SessionInfo;
0: import org.apache.activemq.command.TransactionId;
0: import org.apache.activemq.command.TransactionInfo;
0: import org.apache.activemq.command.XATransactionId;
1: 
1: /**
1:  * Used to simulate the recovery that occurs when a broker shuts down.
1:  * 
0:  * @version $Revision$
1:  */
1: public class XARecoveryBrokerTest extends BrokerRestartTestSupport {
1:         
1:     
0:     public void testPreparedTransactionRecoveredOnRestart() throws Throwable {
1:         
0:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup the producer and send the message.  
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);        
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1:         
1:         // Prepare 4 message sends.
0:         for( int i=0; i < 4; i++) {
1:             // Begin the transaction.
1:             XATransactionId txid = createXATransaction(sessionInfo);
1:             connection.send(createBeginTransaction(connectionInfo, txid));
1: 
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1:             
1:             // Prepare
1:             connection.send(createPrepareTransaction(connectionInfo, txid));
1:         }
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNoMessagesLeft(connection);
1: 
1:         // restart the broker.
1:         restartBroker();
1:         
1:         // Setup the consumer and receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Since prepared but not committed.. they should not get delivered.
1:         assertNoMessagesLeft(connection);
1:         
0:         Response response = connection.request( new TransactionInfo(connectionInfo.getConnectionId(), null, TransactionInfo.RECOVER) );
1:         assertNotNull(response);
0:         DataArrayResponse dar = (DataArrayResponse) response;
1:         assertEquals(4, dar.getData().length);
1:         
1:         // Commit the prepared transactions.
0:         for( int i=0; i < dar.getData().length ;i ++ ) {
0:             connection.send( createCommitTransaction2Phase(connectionInfo, (TransactionId)dar.getData()[i]) );
1:         }
1: 
0:         // We should not get the committed transactions.
0:         for( int i=0; i < 4 ;i ++ ) {
1:             Message m = receiveMessage(connection);
1:             assertNotNull(m);
1:         }
1:         
1:         assertNoMessagesLeft(connection);
1:     }
1: 
0:     public void testQueuePersistentCommitedMessagesNotLostOnRestart() throws Throwable {
1:         
0:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup the producer and send the message.  
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);        
1:         
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
1: 
0:         for( int i=0; i < 4; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             message.setTransactionId(txid);
1:             connection.send(message);
1:         }
1:         
1:         // Commit
1:         connection.send(createCommitTransaction1Phase(connectionInfo, txid));
1: 
1:         // restart the broker.
1:         restartBroker();
1:         
1:         // Setup the consumer and receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
0:         for( int i=0; i < 4 ;i ++ ) {
1:             Message m = receiveMessage(connection);
1:             assertNotNull(m);
1:         }
1:         
1:         assertNoMessagesLeft(connection);
1:     }
1:     
0:     public void testQueuePersistentCommitedAcksNotLostOnRestart() throws Throwable {
1:         
0:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup the producer and send the message.  
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);        
1:         
0:         for( int i=0; i < 4; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         }
1:         
1:         // Setup the consumer and receive the message.
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
0:         for( int i=0; i < 4 ;i ++ ) {
1:             Message m = receiveMessage(connection);
1:             assertNotNull(m);
0:             MessageAck ack = createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE);
0:             ack.setTransactionId(txid);
0:             connection.send(ack);
1:         }        
1:         // Commit
1:         connection.send(createCommitTransaction1Phase(connectionInfo, txid));
1:         
1:         // restart the broker.
1:         restartBroker();
1:         
1:         // Setup the consumer and receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // No messages should be delivered.
1:         Message m = receiveMessage(connection);
1:         assertNull(m);        
1:     }
1:     
0:     public void testQueuePersistentUncommittedAcksLostOnRestart() throws Throwable {
1:         
0:         ActiveMQDestination destination = new ActiveMQQueue("TEST");
1:         
1:         // Setup the producer and send the message.  
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         connection.send(producerInfo);        
1:         
0:         for( int i=0; i < 4; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
1:         }
1:         
1:         // Setup the consumer and receive the message.
1:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
0:         for( int i=0; i < 4 ;i ++ ) {
1:             Message m = receiveMessage(connection);
1:             assertNotNull(m);
0:             MessageAck ack = createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE);
0:             ack.setTransactionId(txid);
0:             connection.send(ack);
1:         }        
1:         // Don't commit
1:         
1:         // restart the broker.
1:         restartBroker();
1:         
1:         // Setup the consumer and receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
1:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
1:         consumerInfo = createConsumerInfo(sessionInfo, destination);
1:         connection.send(consumerInfo);
1: 
0:         // All messages should be re-delivered.
0:         for( int i=0; i < 4 ;i ++ ) {
1:             Message m = receiveMessage(connection);
1:             assertNotNull(m);
1:         }
1:         
1:         assertNoMessagesLeft(connection);
1:     }
1: 
1:     public static Test suite() {
1:         return suite(XARecoveryBrokerTest.class);
1:     }
1:     
1:     public static void main(String[] args) {
1:         junit.textui.TestRunner.run(suite());
1:     }
1: 
1: }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:5f6f23e
/////////////////////////////////////////////////////////////////////////
0:     
1:     public void testQueuePersistentPreparedAcksNotLostOnRestart() throws Exception {
0: 
1:         ActiveMQDestination destination = createDestination();
0: 
0:         // Setup the producer and send the message.
1:         StubConnection connection = createConnection();
1:         ConnectionInfo connectionInfo = createConnectionInfo();
1:         SessionInfo sessionInfo = createSessionInfo(connectionInfo);
1:         ProducerInfo producerInfo = createProducerInfo(sessionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
0:         connection.send(producerInfo);
0: 
0:         for (int i = 0; i < 4; i++) {
1:             Message message = createMessage(producerInfo, destination);
1:             message.setPersistent(true);
1:             connection.send(message);
0:         }
0: 
0:         // Setup the consumer and receive the message.
0:         ConsumerInfo consumerInfo = createConsumerInfo(sessionInfo, destination);
0:         connection.send(consumerInfo);
0: 
1:         // Begin the transaction.
1:         XATransactionId txid = createXATransaction(sessionInfo);
1:         connection.send(createBeginTransaction(connectionInfo, txid));
0:         for (int i = 0; i < 4; i++) {
0:             Message m = receiveMessage(connection);
0:             assertNotNull(m);
0:             MessageAck ack = createAck(consumerInfo, m, 1, MessageAck.STANDARD_ACK_TYPE);
0:             ack.setTransactionId(txid);
0:             connection.send(ack);
0:         }
0:         
1:         connection.request(createPrepareTransaction(connectionInfo, txid));
0: 
1:         // restart the broker.
1:         restartBroker();
0: 
0:         // Setup the consumer and receive the message.
1:         connection = createConnection();
1:         connectionInfo = createConnectionInfo();
0:         sessionInfo = createSessionInfo(connectionInfo);
1:         connection.send(connectionInfo);
1:         connection.send(sessionInfo);
0:         consumerInfo = createConsumerInfo(sessionInfo, destination);
0:         connection.send(consumerInfo);
0:         
0:         // All messages should be re-delivered.
0:         for (int i = 0; i < 4; i++) {
0:             Message m = receiveMessage(connection);
0:             assertNotNull(m);
0:         }
0: 
1:         assertNoMessagesLeft(connection);
0:     }
author:James Strachan
-------------------------------------------------------------------------------
commit:e39a679
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination destination = createDestination();
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination destination = createDestination();
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQDestination destination = createDestination();
/////////////////////////////////////////////////////////////////////////
1:         assertNoMessagesLeft(connection);
0: 
0:         assertNull(m);
0: 
1:         ActiveMQDestination destination = createDestination();
/////////////////////////////////////////////////////////////////////////
1:     protected ActiveMQDestination createDestination() {
1:         return new ActiveMQQueue(getClass().getName() + "." + getName());
0:     }
0:     
============================================================================