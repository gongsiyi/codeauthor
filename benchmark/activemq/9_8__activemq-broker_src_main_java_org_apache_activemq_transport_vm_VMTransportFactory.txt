1:d29ca2a: /**
1:7f883f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7f883f6:  * contributor license agreements.  See the NOTICE file distributed with
1:7f883f6:  * this work for additional information regarding copyright ownership.
1:7f883f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7f883f6:  * (the "License"); you may not use this file except in compliance with
1:7f883f6:  * the License.  You may obtain a copy of the License at
2:7f883f6:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:7f883f6:  *
1:7f883f6:  * Unless required by applicable law or agreed to in writing, software
1:7f883f6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7f883f6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7f883f6:  * See the License for the specific language governing permissions and
1:7f883f6:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.transport.vm;
1:74a7a8b: 
1:d29ca2a: import java.io.IOException;
1:d29ca2a: import java.net.URI;
1:d29ca2a: import java.net.URISyntaxException;
1:d29ca2a: import java.util.HashMap;
1:d29ca2a: import java.util.Map;
1:74a7a8b: import java.util.concurrent.ConcurrentHashMap;
1:9ef4259: import java.util.concurrent.ConcurrentMap;
1:fc00993: 
1:d29ca2a: import org.apache.activemq.broker.BrokerFactory;
1:74a7a8b: import org.apache.activemq.broker.BrokerFactoryHandler;
1:d29ca2a: import org.apache.activemq.broker.BrokerRegistry;
1:d29ca2a: import org.apache.activemq.broker.BrokerService;
1:d29ca2a: import org.apache.activemq.broker.TransportConnector;
1:d29ca2a: import org.apache.activemq.transport.MarshallingTransportFilter;
1:d29ca2a: import org.apache.activemq.transport.Transport;
1:d29ca2a: import org.apache.activemq.transport.TransportFactory;
1:d29ca2a: import org.apache.activemq.transport.TransportServer;
1:d29ca2a: import org.apache.activemq.util.IOExceptionSupport;
1:d29ca2a: import org.apache.activemq.util.IntrospectionSupport;
1:d29ca2a: import org.apache.activemq.util.ServiceSupport;
1:d29ca2a: import org.apache.activemq.util.URISupport;
1:d29ca2a: import org.apache.activemq.util.URISupport.CompositeData;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:2b456dd: import org.slf4j.MDC;
1:fc00993: 
1:f812e34: public class VMTransportFactory extends TransportFactory {
1:5016c4d: 
1:9ef4259:     public static final ConcurrentMap<String, BrokerService> BROKERS = new ConcurrentHashMap<String, BrokerService>();
1:9ef4259:     public static final ConcurrentMap<String, TransportConnector> CONNECTORS = new ConcurrentHashMap<String, TransportConnector>();
1:9ef4259:     public static final ConcurrentMap<String, VMTransportServer> SERVERS = new ConcurrentHashMap<String, VMTransportServer>();
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(VMTransportFactory.class);
1:5016c4d: 
1:d29ca2a:     BrokerFactoryHandler brokerFactoryHandler;
16:d29ca2a: 
1:5016c4d:     @Override
1:f812e34:     public Transport doConnect(URI location) throws Exception {
1:d29ca2a:         return VMTransportServer.configure(doCompositeConnect(location));
1:bcca668:     }
1:d29ca2a: 
1:5016c4d:     @Override
1:f812e34:     public Transport doCompositeConnect(URI location) throws Exception {
1:d29ca2a:         URI brokerURI;
1:d29ca2a:         String host;
1:933eb2f:         Map<String, String> options;
1:f812e34:         boolean create = true;
1:43880af:         int waitForStart = -1;
1:f812e34:         CompositeData data = URISupport.parseComposite(location);
1:f812e34:         if (data.getComponents().length == 1 && "broker".equals(data.getComponents()[0].getScheme())) {
1:f812e34:             brokerURI = data.getComponents()[0];
1:f812e34:             CompositeData brokerData = URISupport.parseComposite(brokerURI);
1:5016c4d:             host = brokerData.getParameters().get("brokerName");
1:fc00993:             if (host == null) {
1:f812e34:                 host = "localhost";
1:fc00993:             }
1:fc00993:             if (brokerData.getPath() != null) {
1:5bf2329:                 host = brokerData.getPath();
1:fc00993:             }
1:f812e34:             options = data.getParameters();
1:f812e34:             location = new URI("vm://" + host);
1:f812e34:         } else {
1:f812e34:             // If using the less complex vm://localhost?broker.persistent=true
1:f812e34:             // form
1:f812e34:             try {
1:c4d8bc4:                 host = extractHost(location);
1:784b93d:                 options = URISupport.parseParameters(location);
1:5016c4d:                 String config = options.remove("brokerConfig");
1:f812e34:                 if (config != null) {
1:f812e34:                     brokerURI = new URI(config);
1:f812e34:                 } else {
1:cfce361:                     Map<String, Object> brokerOptions = IntrospectionSupport.extractProperties(options, "broker.");
1:f812e34:                     brokerURI = new URI("broker://()/" + host + "?"
1:f812e34:                                         + URISupport.createQueryString(brokerOptions));
1:bcca668:                 }
1:f812e34:                 if ("false".equals(options.remove("create"))) {
1:f812e34:                     create = false;
1:d29ca2a:                 }
1:43880af:                 String waitForStartString = options.remove("waitForStart");
1:43880af:                 if (waitForStartString != null) {
1:43880af:                     waitForStart = Integer.parseInt(waitForStartString);
1:d29ca2a:                 }
1:f812e34:             } catch (URISyntaxException e1) {
1:d29ca2a:                 throw IOExceptionSupport.create(e1);
1:d29ca2a:             }
1:f812e34:             location = new URI("vm://" + host);
1:d29ca2a:         }
1:277f3b3:         if (host == null) {
1:d29ca2a:             host = "localhost";
1:d29ca2a:         }
1:933eb2f:         VMTransportServer server = SERVERS.get(host);
1:5a429d9:         // validate the broker is still active
1:f812e34:         if (!validateBroker(host) || server == null) {
1:f812e34:             BrokerService broker = null;
1:f812e34:             // Synchronize on the registry so that multiple concurrent threads
1:f812e34:             // doing this do not think that the broker has not been created and
1:43880af:             // cause multiple brokers to be started.
1:f812e34:             synchronized (BrokerRegistry.getInstance().getRegistryMutext()) {
1:43880af:                 broker = lookupBroker(BrokerRegistry.getInstance(), host, waitForStart);
1:f812e34:                 if (broker == null) {
1:f812e34:                     if (!create) {
1:f812e34:                         throw new IOException("Broker named '" + host + "' does not exist.");
1:f812e34:                     }
1:f812e34:                     try {
1:f812e34:                         if (brokerFactoryHandler != null) {
1:f812e34:                             broker = brokerFactoryHandler.createBroker(brokerURI);
1:f812e34:                         } else {
1:f812e34:                             broker = BrokerFactory.createBroker(brokerURI);
1:61fef74:                         }
1:61fef74:                         broker.start();
1:3da9f1c:                         MDC.put("activemq.broker", broker.getBrokerName());
1:f812e34:                     } catch (URISyntaxException e) {
1:61fef74:                         throw IOExceptionSupport.create(e);
1:d29ca2a:                     }
1:fc00993:                     BROKERS.put(host, broker);
1:43880af:                     BrokerRegistry.getInstance().getRegistryMutext().notifyAll();
1:d29ca2a:                 }
1:f812e34: 
1:933eb2f:                 server = SERVERS.get(host);
1:f812e34:                 if (server == null) {
1:f812e34:                     server = (VMTransportServer)bind(location, true);
1:5d99c99:                     TransportConnector connector = new TransportConnector(server);
1:5d99c99:                     connector.setBrokerService(broker);
1:84fd773:                     connector.setUri(location);
1:f812e34:                     connector.setTaskRunnerFactory(broker.getTaskRunnerFactory());
1:61fef74:                     connector.start();
1:fc00993:                     CONNECTORS.put(host, connector);
1:61fef74:                 }
1:f812e34: 
1:61fef74:             }
1:d29ca2a:         }
1:f812e34: 
1:f812e34:         VMTransport vmtransport = server.connect();
1:18aa159:         IntrospectionSupport.setProperties(vmtransport.peer, new HashMap<String,String>(options));
1:f812e34:         IntrospectionSupport.setProperties(vmtransport, options);
1:f812e34:         Transport transport = vmtransport;
1:f812e34:         if (vmtransport.isMarshal()) {
1:933eb2f:             Map<String, String> optionsCopy = new HashMap<String, String>(options);
1:f812e34:             transport = new MarshallingTransportFilter(transport, createWireFormat(options),
1:f812e34:                                                        createWireFormat(optionsCopy));
1:d29ca2a:         }
1:f812e34:         if (!options.isEmpty()) {
1:f812e34:             throw new IllegalArgumentException("Invalid connect parameters: " + options);
1:d29ca2a:         }
1:d29ca2a:         return transport;
1:d29ca2a:     }
1:61fef74: 
1:c4d8bc4:    private static String extractHost(URI location) {
1:f812e34:        String host = location.getHost();
1:c4d8bc4:        if (host == null || host.length() == 0) {
1:c4d8bc4:            host = location.getAuthority();
1:c4d8bc4:            if (host == null || host.length() == 0) {
1:c4d8bc4:                host = "localhost";
1:d29ca2a:            }
1:d29ca2a:        }
1:c4d8bc4:        return host;
1:c4d8bc4:     }
1:61fef74: 
1:5016c4d:    /**
1:5016c4d:     * Attempt to find a Broker instance.
1:5016c4d:     *
1:43880af:     * @param registry
1:5016c4d:     *        the registry in which to search for the BrokerService instance.
1:43880af:     * @param brokerName
1:5016c4d:     *        the name of the Broker that should be located.
1:5016c4d:     * @param waitForStart
1:5016c4d:     *        time in milliseconds to wait for a broker to appear and be started.
1:5016c4d:     *
1:5016c4d:     * @return a BrokerService instance if one is found, or null.
1:43880af:     */
1:43880af:     private BrokerService lookupBroker(final BrokerRegistry registry, final String brokerName, int waitForStart) {
1:43880af:         BrokerService broker = null;
1:43880af:         synchronized(registry.getRegistryMutext()) {
2:43880af:             broker = registry.lookup(brokerName);
1:5016c4d:             if (broker == null || waitForStart > 0) {
1:43880af:                 final long expiry = System.currentTimeMillis() + waitForStart;
1:5b1412d:                 while ((broker == null || !broker.isStarted()) && System.currentTimeMillis() - expiry < 0) {
1:43880af:                     long timeout = Math.max(0, expiry - System.currentTimeMillis());
1:cfce361:                     if (broker == null) {
1:cfce361:                         try {
1:cfce361:                             LOG.debug("waiting for broker named: " + brokerName + " to enter registry");
1:cfce361:                             registry.getRegistryMutext().wait(timeout);
1:a9b8d98:                             broker = registry.lookup(brokerName);
1:cfce361:                         } catch (InterruptedException ignored) {
1:cfce361:                         }
1:c4d8bc4:                     }
1:5016c4d:                     if (broker != null && !broker.isStarted()) {
1:5016c4d:                         LOG.debug("waiting for broker named: " + brokerName + " to start");
1:5016c4d:                         timeout = Math.max(0, expiry - System.currentTimeMillis());
1:5016c4d:                         // Wait for however long we have left for broker to be started, if
1:5016c4d:                         // it doesn't get started we need to clear broker so it doesn't get
1:5016c4d:                         // returned.  A null return should throw an exception.
1:5016c4d:                         if (!broker.waitUntilStarted(timeout)) {
1:5016c4d:                             broker = null;
1:5016c4d:                             break;
1:5016c4d:                         }
1:5016c4d:                     }
1:c4d8bc4:                 }
1:43880af:             }
1:43880af:         }
1:43880af:         return broker;
1:43880af:     }
1:61fef74: 
1:5016c4d:     @Override
1:5d99c99:     public TransportServer doBind(URI location) throws IOException {
1:f812e34:         return bind(location, false);
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param location
1:5a429d9:      * @return the TransportServer
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:f812e34:     private TransportServer bind(URI location, boolean dispose) throws IOException {
1:c4d8bc4:         String host = extractHost(location);
1:fc00993:         LOG.debug("binding to broker: " + host);
1:f812e34:         VMTransportServer server = new VMTransportServer(location, dispose);
1:fc00993:         Object currentBoundValue = SERVERS.get(host);
1:f812e34:         if (currentBoundValue != null) {
1:f812e34:             throw new IOException("VMTransportServer already bound at: " + location);
1:d29ca2a:         }
1:fc00993:         SERVERS.put(host, server);
1:d29ca2a:         return server;
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     public static void stopped(VMTransportServer server) {
1:c4d8bc4:         String host = extractHost(server.getBindURI());
1:80a7ec5:         stopped(host);
1:43880af:     }
1:d29ca2a: 
1:f812e34:     public static void stopped(String host) {
1:fc00993:         SERVERS.remove(host);
1:933eb2f:         TransportConnector connector = CONNECTORS.remove(host);
2:f812e34:         if (connector != null) {
1:fc00993:             LOG.debug("Shutting down VM connectors for broker: " + host);
1:d29ca2a:             ServiceSupport.dispose(connector);
1:933eb2f:             BrokerService broker = BROKERS.remove(host);
2:f812e34:             if (broker != null) {
1:d29ca2a:                 ServiceSupport.dispose(broker);
1:d29ca2a:             }
1:3da9f1c:             MDC.remove("activemq.broker");
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     public BrokerFactoryHandler getBrokerFactoryHandler() {
1:d29ca2a:         return brokerFactoryHandler;
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     public void setBrokerFactoryHandler(BrokerFactoryHandler brokerFactoryHandler) {
1:f812e34:         this.brokerFactoryHandler = brokerFactoryHandler;
1:d29ca2a:     }
1:d29ca2a: 
1:f812e34:     private boolean validateBroker(String host) {
1:f812e34:         boolean result = true;
1:fc00993:         if (BROKERS.containsKey(host) || SERVERS.containsKey(host) || CONNECTORS.containsKey(host)) {
1:5a429d9:             // check the broker is still in the BrokerRegistry
1:933eb2f:             TransportConnector connector = CONNECTORS.get(host);
1:f812e34:             if (BrokerRegistry.getInstance().lookup(host) == null
1:f812e34:                 || (connector != null && connector.getBroker().isStopped())) {
1:f812e34:                 result = false;
1:5a429d9:                 // clean-up
1:fc00993:                 BROKERS.remove(host);
1:fc00993:                 SERVERS.remove(host);
1:f812e34:                 if (connector != null) {
1:fc00993:                     CONNECTORS.remove(host);
1:f812e34:                     if (connector != null) {
1:5a429d9:                         ServiceSupport.dispose(connector);
1:d29ca2a:                     }
1:43880af:                 }
1:43880af:             }
1:5a429d9:         }
1:233b604:         return result;
1:5a429d9:     }
1:5a429d9: }
============================================================================
author:giliva
-------------------------------------------------------------------------------
commit:5b1412d
/////////////////////////////////////////////////////////////////////////
1:                 while ((broker == null || !broker.isStarted()) && System.currentTimeMillis() - expiry < 0) {
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:d54d046
author:Timothy Bish
-------------------------------------------------------------------------------
commit:9ef4259
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentMap;
/////////////////////////////////////////////////////////////////////////
1:     public static final ConcurrentMap<String, BrokerService> BROKERS = new ConcurrentHashMap<String, BrokerService>();
1:     public static final ConcurrentMap<String, TransportConnector> CONNECTORS = new ConcurrentHashMap<String, TransportConnector>();
1:     public static final ConcurrentMap<String, VMTransportServer> SERVERS = new ConcurrentHashMap<String, VMTransportServer>();
commit:cfce361
/////////////////////////////////////////////////////////////////////////
1:                     Map<String, Object> brokerOptions = IntrospectionSupport.extractProperties(options, "broker.");
/////////////////////////////////////////////////////////////////////////
1:                     if (broker == null) {
1:                         try {
1:                             LOG.debug("waiting for broker named: " + brokerName + " to enter registry");
1:                             registry.getRegistryMutext().wait(timeout);
1:                         } catch (InterruptedException ignored) {
1:                         }
commit:5016c4d
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             host = brokerData.getParameters().get("brokerName");
/////////////////////////////////////////////////////////////////////////
1:                 String config = options.remove("brokerConfig");
/////////////////////////////////////////////////////////////////////////
1:    /**
1:     * Attempt to find a Broker instance.
1:     *
1:     *        the registry in which to search for the BrokerService instance.
1:     *        the name of the Broker that should be located.
1:     * @param waitForStart
1:     *        time in milliseconds to wait for a broker to appear and be started.
1:     *
1:     * @return a BrokerService instance if one is found, or null.
1:             if (broker == null || waitForStart > 0) {
0:                         LOG.debug("waiting for broker named: " + brokerName + " to enter registry");
1:                     if (broker != null && !broker.isStarted()) {
1:                         LOG.debug("waiting for broker named: " + brokerName + " to start");
1:                         timeout = Math.max(0, expiry - System.currentTimeMillis());
1:                         // Wait for however long we have left for broker to be started, if
1:                         // it doesn't get started we need to clear broker so it doesn't get
1:                         // returned.  A null return should throw an exception.
1:                         if (!broker.waitUntilStarted(timeout)) {
1:                             broker = null;
1:                             break;
1:                         }
1:                     }
1:     @Override
author:gtully
-------------------------------------------------------------------------------
commit:a9b8d98
/////////////////////////////////////////////////////////////////////////
1:                             broker = registry.lookup(brokerName);
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:428a063
/////////////////////////////////////////////////////////////////////////
0:                 while ((broker == null || !broker.isStarted()) && expiry > System.currentTimeMillis()) {
commit:3da9f1c
/////////////////////////////////////////////////////////////////////////
1:                         MDC.put("activemq.broker", broker.getBrokerName());
/////////////////////////////////////////////////////////////////////////
1:             MDC.remove("activemq.broker");
commit:2b456dd
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.MDC;
/////////////////////////////////////////////////////////////////////////
0:                         MDC.put("broker", broker.getBrokerName());
/////////////////////////////////////////////////////////////////////////
0:             MDC.remove("broker");
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1:     private static final Logger LOG = LoggerFactory.getLogger(VMTransportFactory.class);
commit:784b93d
/////////////////////////////////////////////////////////////////////////
1:                 options = URISupport.parseParameters(location);
commit:80a7ec5
/////////////////////////////////////////////////////////////////////////
1:         stopped(host);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:5d99c99
/////////////////////////////////////////////////////////////////////////
1:                     TransportConnector connector = new TransportConnector(server);
1:                     connector.setBrokerService(broker);
/////////////////////////////////////////////////////////////////////////
1:     public TransportServer doBind(URI location) throws IOException {
commit:933eb2f
/////////////////////////////////////////////////////////////////////////
0:     public static final ConcurrentHashMap<String, BrokerService> BROKERS = new ConcurrentHashMap<String, BrokerService>();
0:     public static final ConcurrentHashMap<String, TransportConnector> CONNECTORS = new ConcurrentHashMap<String, TransportConnector>();
0:     public static final ConcurrentHashMap<String, VMTransportServer> SERVERS = new ConcurrentHashMap<String, VMTransportServer>();
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> options;
/////////////////////////////////////////////////////////////////////////
1:         VMTransportServer server = SERVERS.get(host);
/////////////////////////////////////////////////////////////////////////
1:                 server = SERVERS.get(host);
/////////////////////////////////////////////////////////////////////////
1:             Map<String, String> optionsCopy = new HashMap<String, String>(options);
/////////////////////////////////////////////////////////////////////////
1:         TransportConnector connector = CONNECTORS.remove(host);
1:             BrokerService broker = BROKERS.remove(host);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnector connector = CONNECTORS.remove(host);
0:             BrokerService broker = BROKERS.remove(host);
/////////////////////////////////////////////////////////////////////////
1:             TransportConnector connector = CONNECTORS.get(host);
commit:fc00993
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static final ConcurrentHashMap BROKERS = new ConcurrentHashMap();
0:     public static final ConcurrentHashMap CONNECTORS = new ConcurrentHashMap();
0:     public static final ConcurrentHashMap SERVERS = new ConcurrentHashMap();
0:     private static final Log LOG = LogFactory.getLog(VMTransportFactory.class);
1:     
/////////////////////////////////////////////////////////////////////////
1:             if (host == null) {
1:             }
1:             if (brokerData.getPath() != null) {
1:             }
/////////////////////////////////////////////////////////////////////////
0:         VMTransportServer server = (VMTransportServer)SERVERS.get(host);
/////////////////////////////////////////////////////////////////////////
1:                     BROKERS.put(host, broker);
0:                 server = (VMTransportServer)SERVERS.get(host);
1:                     CONNECTORS.put(host, connector);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("binding to broker: " + host);
1:         Object currentBoundValue = SERVERS.get(host);
1:         SERVERS.put(host, server);
1:         SERVERS.remove(host);
0:         TransportConnector connector = (TransportConnector)CONNECTORS.remove(host);
1:             LOG.debug("Shutting down VM connectors for broker: " + host);
0:             BrokerService broker = (BrokerService)BROKERS.remove(host);
/////////////////////////////////////////////////////////////////////////
1:         SERVERS.remove(host);
0:         TransportConnector connector = (TransportConnector)CONNECTORS.remove(host);
0:             LOG.debug("Shutting down VM connectors for broker: " + host);
0:             BrokerService broker = (BrokerService)BROKERS.remove(host);
/////////////////////////////////////////////////////////////////////////
1:         if (BROKERS.containsKey(host) || SERVERS.containsKey(host) || CONNECTORS.containsKey(host)) {
0:             TransportConnector connector = (TransportConnector)CONNECTORS.get(host);
1:                 BROKERS.remove(host);
0:                 SERVERS.remove(host);
1:                     CONNECTORS.remove(host);
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.ConcurrentHashMap;
1: 
1: import org.apache.activemq.broker.BrokerFactoryHandler;
/////////////////////////////////////////////////////////////////////////
commit:f812e34
/////////////////////////////////////////////////////////////////////////
1: public class VMTransportFactory extends TransportFactory {
0:     final public static ConcurrentHashMap brokers = new ConcurrentHashMap();
0:     final public static ConcurrentHashMap connectors = new ConcurrentHashMap();
0:     final public static ConcurrentHashMap servers = new ConcurrentHashMap();
1:     public Transport doConnect(URI location) throws Exception {
1:     public Transport doCompositeConnect(URI location) throws Exception {
1:         boolean create = true;
1:         CompositeData data = URISupport.parseComposite(location);
1:         if (data.getComponents().length == 1 && "broker".equals(data.getComponents()[0].getScheme())) {
1:             brokerURI = data.getComponents()[0];
1:             CompositeData brokerData = URISupport.parseComposite(brokerURI);
0:             host = (String)brokerData.getParameters().get("brokerName");
0:             if (host == null)
1:                 host = "localhost";
0:             if (brokerData.getPath() != null)
0:                 host = data.getPath();
1:             options = data.getParameters();
1:             location = new URI("vm://" + host);
1:         } else {
1:             // If using the less complex vm://localhost?broker.persistent=true
1:             // form
1:             try {
0:                 host = location.getHost();
0:                 options = URISupport.parseParamters(location);
0:                 String config = (String)options.remove("brokerConfig");
1:                 if (config != null) {
1:                     brokerURI = new URI(config);
1:                 } else {
0:                     Map brokerOptions = IntrospectionSupport.extractProperties(options, "broker.");
1:                     brokerURI = new URI("broker://()/" + host + "?"
1:                                         + URISupport.createQueryString(brokerOptions));
1:                 if ("false".equals(options.remove("create"))) {
1:                     create = false;
1:             } catch (URISyntaxException e1) {
1:             location = new URI("vm://" + host);
0:         VMTransportServer server = (VMTransportServer)servers.get(host);
1:         if (!validateBroker(host) || server == null) {
1:             BrokerService broker = null;
1:             // Synchronize on the registry so that multiple concurrent threads
1:             // doing this do not think that the broker has not been created and
0:             // cause multiple
1:             synchronized (BrokerRegistry.getInstance().getRegistryMutext()) {
0:                 broker = BrokerRegistry.getInstance().lookup(host);
1:                 if (broker == null) {
1:                     if (!create) {
1:                         throw new IOException("Broker named '" + host + "' does not exist.");
1:                     }
1:                     try {
1:                         if (brokerFactoryHandler != null) {
1:                             broker = brokerFactoryHandler.createBroker(brokerURI);
1:                         } else {
1:                             broker = BrokerFactory.createBroker(brokerURI);
1:                     } catch (URISyntaxException e) {
0:                     brokers.put(host, broker);
1: 
0:                 server = (VMTransportServer)servers.get(host);
1:                 if (server == null) {
1:                     server = (VMTransportServer)bind(location, true);
0:                     TransportConnector connector = new TransportConnector(broker.getBroker(), server);
1:                     connector.setTaskRunnerFactory(broker.getTaskRunnerFactory());
0:                     connectors.put(host, connector);
1: 
1: 
1:         VMTransport vmtransport = server.connect();
1:         IntrospectionSupport.setProperties(vmtransport, options);
1:         Transport transport = vmtransport;
1:         if (vmtransport.isMarshal()) {
0:             HashMap optionsCopy = new HashMap(options);
1:             transport = new MarshallingTransportFilter(transport, createWireFormat(options),
1:                                                        createWireFormat(optionsCopy));
1:         if (!options.isEmpty()) {
1:             throw new IllegalArgumentException("Invalid connect parameters: " + options);
0:     public TransportServer doBind(String brokerId, URI location) throws IOException {
1:         return bind(location, false);
/////////////////////////////////////////////////////////////////////////
1:     private TransportServer bind(URI location, boolean dispose) throws IOException {
1:         String host = location.getHost();
1:         VMTransportServer server = new VMTransportServer(location, dispose);
0:         Object currentBoundValue = servers.get(host);
1:         if (currentBoundValue != null) {
1:             throw new IOException("VMTransportServer already bound at: " + location);
0:         servers.put(host, server);
1:     public static void stopped(VMTransportServer server) {
0:         String host = server.getBindURI().getHost();
0:         TransportConnector connector = (TransportConnector)connectors.remove(host);
1:         if (connector != null) {
0:             log.debug("Shutting down VM connectors for broker: " + host);
0:             BrokerService broker = (BrokerService)brokers.remove(host);
1:             if (broker != null) {
1:     public static void stopped(String host) {
0:         TransportConnector connector = (TransportConnector)connectors.remove(host);
1:         if (connector != null) {
0:             log.debug("Shutting down VM connectors for broker: " + host);
0:             BrokerService broker = (BrokerService)brokers.remove(host);
1:             if (broker != null) {
1:     public BrokerFactoryHandler getBrokerFactoryHandler() {
1:     public void setBrokerFactoryHandler(BrokerFactoryHandler brokerFactoryHandler) {
1:         this.brokerFactoryHandler = brokerFactoryHandler;
1:     private boolean validateBroker(String host) {
1:         boolean result = true;
0:         if (brokers.containsKey(host) || servers.containsKey(host) || connectors.containsKey(host)) {
0:             TransportConnector connector = (TransportConnector)connectors.get(host);
1:             if (BrokerRegistry.getInstance().lookup(host) == null
1:                 || (connector != null && connector.getBroker().isStopped())) {
1:                 result = false;
1:                 if (connector != null) {
1:                     if (connector != null) {
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
commit:bcca668
/////////////////////////////////////////////////////////////////////////
0:         boolean create=true;
/////////////////////////////////////////////////////////////////////////
0:                 if( "false".equals(options.get("create")) ) {
0:                 	create=false;
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 	if( !create ) {
0:                 		throw new IOException("Broker named '"+host+"' does not exist.");
1:                 	}
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:40958b6
/////////////////////////////////////////////////////////////////////////
0:         log.debug("binding to broker: " + host);
/////////////////////////////////////////////////////////////////////////
0:             log.debug("Shutting down VM connectors for broker: "  +host);
/////////////////////////////////////////////////////////////////////////
0:             log.debug("Shutting down VM connectors for broker: "  +host);
commit:84fd773
/////////////////////////////////////////////////////////////////////////
1:                     connector.setUri(location);
commit:61fef74
/////////////////////////////////////////////////////////////////////////
0:             BrokerService broker=null;
0:             // Synchronize on the registry so that multiple concurrent threads 
0:             // doing this do not think that the broker has not been created and cause multiple
0:             // brokers to be started.
0:             synchronized( BrokerRegistry.getInstance().getRegistryMutext() ) {
0:                 broker=BrokerRegistry.getInstance().lookup(host);
0:                 if(broker==null){
0:                     try{
0:                         if(brokerFactoryHandler!=null){
0:                             broker=brokerFactoryHandler.createBroker(brokerURI);
0:                         }else{
0:                             broker=BrokerFactory.createBroker(brokerURI);
1:                         }
1:                         broker.start();
0:                     }catch(URISyntaxException e){
1:                         throw IOExceptionSupport.create(e);
0:                     brokers.put(host,broker);
1:                 
0:                 server=(VMTransportServer) servers.get(host);
0:                 if(server==null){
0:                     server=(VMTransportServer) bind(location,true);
0:                     TransportConnector connector=new TransportConnector(broker.getBroker(),server);
0:                     connector.setTaskRunnerFactory( broker.getTaskRunnerFactory() );
1:                     connector.start();
0:                     connectors.put(host,connector);
1:                 }
1:                 
1:         }
1:         
commit:1b60ebb
/////////////////////////////////////////////////////////////////////////
0:                 connector.setTaskRunnerFactory( broker.getTaskRunnerFactory() );
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.vm;
1: 
1: import java.io.IOException;
1: import java.net.URI;
1: import java.net.URISyntaxException;
1: import java.util.HashMap;
1: import java.util.Map;
1: 
1: import org.apache.activemq.broker.BrokerFactory;
1: import org.apache.activemq.broker.BrokerRegistry;
1: import org.apache.activemq.broker.BrokerService;
1: import org.apache.activemq.broker.TransportConnector;
0: import org.apache.activemq.broker.BrokerFactory.BrokerFactoryHandler;
1: import org.apache.activemq.transport.MarshallingTransportFilter;
1: import org.apache.activemq.transport.Transport;
1: import org.apache.activemq.transport.TransportFactory;
1: import org.apache.activemq.transport.TransportServer;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.IntrospectionSupport;
1: import org.apache.activemq.util.ServiceSupport;
1: import org.apache.activemq.util.URISupport;
1: import org.apache.activemq.util.URISupport.CompositeData;
1: 
0: import edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap;
1: 
0: public class VMTransportFactory extends TransportFactory {
1: 
0:     final public static ConcurrentHashMap brokers = new ConcurrentHashMap();
0:     final public static ConcurrentHashMap connectors = new ConcurrentHashMap();
0:     final public static ConcurrentHashMap servers = new ConcurrentHashMap();
1: 
1:     BrokerFactoryHandler brokerFactoryHandler;
1:     
0:     public Transport doConnect(URI location) throws Exception {
1:         return VMTransportServer.configure(doCompositeConnect(location));
1:     }
1: 
0:     public Transport doCompositeConnect(URI location) throws Exception {
1:         URI brokerURI;
1:         String host;
0:         Map options;
1: 
0:         CompositeData data = URISupport.parseComposite(location);
0:         if( data.getComponents().length==1 && "broker".equals(data.getComponents()[0].getScheme()) ) {
0:             brokerURI = data.getComponents()[0];
1:             
0:             CompositeData brokerData = URISupport.parseComposite(brokerURI);
0:             host = (String)brokerData.getParameters().get("brokerName");
0:             if( host == null )
1:                 host = "localhost";
0:             if( brokerData.getPath()!=null )
0:                 host = data.getPath();
1:             
0:             options = data.getParameters();
0:             location = new URI("vm://"+host);
0:         } else {
0:             // If using the less complex vm://localhost?broker.persistent=true form
0:             try {
0:                 host =  location.getHost();
0:                 options = URISupport.parseParamters(location);
0:                 String config = (String) options.remove("brokerConfig");
0:                 if( config != null ) {
0:                     brokerURI = new URI(config);
0:                 } else {
0:                     Map brokerOptions = IntrospectionSupport.extractProperties(options, "broker.");
0:                     brokerURI = new URI("broker://()/"+host+"?"+URISupport.createQueryString(brokerOptions));
1:                 }
0:             } catch (URISyntaxException e1) {
1:                 throw IOExceptionSupport.create(e1);
1:             }
1:             
0:             location = new URI("vm://"+host);
1:         }
1:         
0:         VMTransportServer server = (VMTransportServer) servers.get(host);        
0:         if( server == null ) {
0:             BrokerService broker = BrokerRegistry.getInstance().lookup(host);
0:             if (broker == null) {
0:                 try {
0:                     if( brokerFactoryHandler !=null ) {
0:                         broker = brokerFactoryHandler.createBroker(brokerURI);
0:                     } else {
0:                         broker = BrokerFactory.createBroker(brokerURI);
1:                     }
0:                     broker.start();
1:                 }
0:                 catch (URISyntaxException e) {
0:                     throw IOExceptionSupport.create(e);
1:                 }
0:                 brokers.put(host, broker);
1:             }
0:             server = (VMTransportServer) servers.get(host);
0:             if (server == null) {
0:                 server = (VMTransportServer) bind(location, true);
0:                 TransportConnector connector = new TransportConnector(broker.getBroker(), server);
0:                 connector.start();
0:                 connectors.put(host, connector);
1:             }
1:         }
1: 
0:         VMTransport vmtransport = server.connect();
0:         IntrospectionSupport.setProperties(vmtransport, options);
1: 
0:         Transport transport = vmtransport;
0:         if (vmtransport.isMarshal()) {
0:             HashMap optionsCopy = new HashMap(options);
0:             transport = new MarshallingTransportFilter(transport, createWireFormat(options), createWireFormat(optionsCopy));
1:         }
1: 
0:         if( !options.isEmpty() ) {
0:             throw new IllegalArgumentException("Invalid connect parameters: "+options);
1:         }
1:         
1:         return transport;
1:     }
1: 
0:     public TransportServer doBind(String brokerId,URI location) throws IOException {
0:         return bind(location, false);
1:     }
1: 
1:     /**
1:      * @param location
0:      * @return
1:      * @throws IOException
1:      */
0:     private TransportServer bind(URI location, boolean dispose) throws IOException {
0:         String host = location.getHost();
0:         VMTransportServer server = new VMTransportServer(location, dispose);
0:         Object currentBoundValue = servers.get(host);
0:         if (currentBoundValue != null) {
0:             throw new IOException("VMTransportServer already bound at: " + location);
1:         }
0:         servers.put(host, server);
1:         return server;
1:     }
1: 
0:     public static void stopped(VMTransportServer server) {
0:         String host = server.getBindURI().getHost();
0:         servers.remove(host);
0:         TransportConnector connector = (TransportConnector) connectors.remove(host);
0:         if (connector != null) {
1:             ServiceSupport.dispose(connector);
0:             BrokerService broker = (BrokerService) brokers.remove(host);
0:             if (broker != null) {
1:                 ServiceSupport.dispose(broker);
1:             }
1:         }
1:     }
1: 
0:     public BrokerFactoryHandler getBrokerFactoryHandler() {
1:         return brokerFactoryHandler;
1:     }
1: 
0:     public void setBrokerFactoryHandler(BrokerFactoryHandler brokerFactoryHandler) {
0:         this.brokerFactoryHandler = brokerFactoryHandler;
1:     }
1: 
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:c4d8bc4
/////////////////////////////////////////////////////////////////////////
1:                 host = extractHost(location);
/////////////////////////////////////////////////////////////////////////
1:    private static String extractHost(URI location) {
0:        String host = location.getHost();
1:        if (host == null || host.length() == 0) {
1:            host = location.getAuthority();
1:            if (host == null || host.length() == 0) {
1:                host = "localhost";
1:            }
1:        }
1:        return host;
1:     }
0: 
0: /**
/////////////////////////////////////////////////////////////////////////
1:         String host = extractHost(location);
/////////////////////////////////////////////////////////////////////////
1:         String host = extractHost(server.getBindURI());
commit:5bf2329
/////////////////////////////////////////////////////////////////////////
1:                 host = brokerData.getPath();
commit:43880af
/////////////////////////////////////////////////////////////////////////
1:         int waitForStart = -1;
/////////////////////////////////////////////////////////////////////////
1:                 String waitForStartString = options.remove("waitForStart");
1:                 if (waitForStartString != null) {
1:                     waitForStart = Integer.parseInt(waitForStartString);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             // cause multiple brokers to be started.
1:                 broker = lookupBroker(BrokerRegistry.getInstance(), host, waitForStart);
/////////////////////////////////////////////////////////////////////////
1:                     BrokerRegistry.getInstance().getRegistryMutext().notifyAll();
/////////////////////////////////////////////////////////////////////////
0:    /**
1:     * @param registry
1:     * @param brokerName
0:     * @param waitForStart - time in milliseconds to wait for a broker to appear
0:     * @return
1:     */
1:     private BrokerService lookupBroker(final BrokerRegistry registry, final String brokerName, int waitForStart) {
1:         BrokerService broker = null;
1:         synchronized(registry.getRegistryMutext()) {
1:             broker = registry.lookup(brokerName);
0:             if (broker == null && waitForStart > 0) {
1:                 final long expiry = System.currentTimeMillis() + waitForStart;
0:                 while (broker == null  && expiry > System.currentTimeMillis()) {
1:                     long timeout = Math.max(0, expiry - System.currentTimeMillis());
0:                     try {
0:                         LOG.debug("waiting for broker named: " + brokerName + " to start");
0:                         registry.getRegistryMutext().wait(timeout);
0:                     } catch (InterruptedException ignored) {
1:                     }
1:                     broker = registry.lookup(brokerName);
1:                 }
1:             }
1:         }
1:         return broker;
1:     }
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:18aa159
/////////////////////////////////////////////////////////////////////////
1:         IntrospectionSupport.setProperties(vmtransport.peer, new HashMap<String,String>(options));
commit:5a429d9
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
0:  * the License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: public class VMTransportFactory extends TransportFactory{
0:     private static final Log log = LogFactory.getLog(VMTransportFactory.class);
0:     final public static ConcurrentHashMap brokers=new ConcurrentHashMap();
0:     final public static ConcurrentHashMap connectors=new ConcurrentHashMap();
0:     final public static ConcurrentHashMap servers=new ConcurrentHashMap();
0: 
0:     public Transport doConnect(URI location) throws Exception{
0:     public Transport doCompositeConnect(URI location) throws Exception{
0:         CompositeData data=URISupport.parseComposite(location);
0:         if(data.getComponents().length==1&&"broker".equals(data.getComponents()[0].getScheme())){
0:             brokerURI=data.getComponents()[0];
0:             CompositeData brokerData=URISupport.parseComposite(brokerURI);
0:             host=(String) brokerData.getParameters().get("brokerName");
0:             if(host==null)
0:                 host="localhost";
0:             if(brokerData.getPath()!=null)
0:                 host=data.getPath();
0:             options=data.getParameters();
0:             location=new URI("vm://"+host);
0:         }else{
0:             try{
0:                 host=location.getHost();
0:                 options=URISupport.parseParamters(location);
0:                 String config=(String) options.remove("brokerConfig");
0:                 if(config!=null){
0:                     brokerURI=new URI(config);
0:                 }else{
0:                     Map brokerOptions=IntrospectionSupport.extractProperties(options,"broker.");
0:                     brokerURI=new URI("broker://()/"+host+"?"+URISupport.createQueryString(brokerOptions));
0:             }catch(URISyntaxException e1){
0:             location=new URI("vm://"+host);
0:         VMTransportServer server=(VMTransportServer) servers.get(host);
1:         // validate the broker is still active
0:         if(!validateBroker(host)||server==null){
0:             BrokerService broker=BrokerRegistry.getInstance().lookup(host);
0:             if(broker==null){
0:                 try{
0:                     if(brokerFactoryHandler!=null){
0:                         broker=brokerFactoryHandler.createBroker(brokerURI);
0:                     }else{
0:                         broker=BrokerFactory.createBroker(brokerURI);
0:                 }catch(URISyntaxException e){
0:                 brokers.put(host,broker);
0:             server=(VMTransportServer) servers.get(host);
0:             if(server==null){
0:                 server=(VMTransportServer) bind(location,true);
0:                 TransportConnector connector=new TransportConnector(broker.getBroker(),server);
0:                 connectors.put(host,connector);
0:         }else{}
0:         VMTransport vmtransport=server.connect();
0:         IntrospectionSupport.setProperties(vmtransport,options);
0:         Transport transport=vmtransport;
0:         if(vmtransport.isMarshal()){
0:             HashMap optionsCopy=new HashMap(options);
0:             transport=new MarshallingTransportFilter(transport,createWireFormat(options),createWireFormat(optionsCopy));
0:         if(!options.isEmpty()){
0:     public TransportServer doBind(String brokerId,URI location) throws IOException{
0:         return bind(location,false);
1:      * @return the TransportServer
0:     private TransportServer bind(URI location,boolean dispose) throws IOException{
0:         String host=location.getHost();
0:         log.info("binding to broker: " + host);
0:         VMTransportServer server=new VMTransportServer(location,dispose);
0:         Object currentBoundValue=servers.get(host);
0:         if(currentBoundValue!=null){
0:             throw new IOException("VMTransportServer already bound at: "+location);
0:         servers.put(host,server);
0:     public static void stopped(VMTransportServer server){
0:         String host=server.getBindURI().getHost();
0:         log.info("Shutting down VM connectors for broker: "  +host);
0:         TransportConnector connector=(TransportConnector) connectors.remove(host);
0:         if(connector!=null){
0:             BrokerService broker=(BrokerService) brokers.remove(host);
0:             if(broker!=null){
0:     public static void stopped(String host){
0:         log.info("Shutting down VM connectors for broker: "  +host);
0:         servers.remove(host);
0:         TransportConnector connector=(TransportConnector) connectors.remove(host);
0:         if(connector!=null){
1:             ServiceSupport.dispose(connector);
0:             BrokerService broker=(BrokerService) brokers.remove(host);
0:             if(broker!=null){
0:                 ServiceSupport.dispose(broker);
1:             }
1:         }
1:     }
0: 
0:     public BrokerFactoryHandler getBrokerFactoryHandler(){
0:     public void setBrokerFactoryHandler(BrokerFactoryHandler brokerFactoryHandler){
0:         this.brokerFactoryHandler=brokerFactoryHandler;
1:             // check the broker is still in the BrokerRegistry
1:                 // clean-up
commit:233b604
/////////////////////////////////////////////////////////////////////////
0:         VMTransportServer server = (VMTransportServer) servers.get(host);   
0:         //validate the broker is still active
0:         if( !validateBroker(host) || server == null ) {
/////////////////////////////////////////////////////////////////////////
0:         }else {
0:             
/////////////////////////////////////////////////////////////////////////
0:     
0:     private boolean validateBroker(String host){
0:         boolean result=true;
0:         if(brokers.containsKey(host)||servers.containsKey(host)||connectors.containsKey(host)){
0:             //check the broker is still in the BrokerRegistry
0:             TransportConnector connector=(TransportConnector) connectors.get(host);
0:             if(BrokerRegistry.getInstance().lookup(host)==null||(connector!=null&&connector.getBroker().isStopped())){
0:                 result=false;
0:                 //clean-up
0:                 brokers.remove(host);
0:                 servers.remove(host);
0:                 if(connector!=null){
0:                     connectors.remove(host);
0:                     if(connector!=null){
0:                         ServiceSupport.dispose(connector);
0:                     }
0:                 }
0:             }
0:         }
1:         return result;
0:     }
author:James Strachan
-------------------------------------------------------------------------------
commit:a640190
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerFactoryHandler;
commit:c3fd0a6
/////////////////////////////////////////////////////////////////////////
0:                 if( "false".equals(options.remove("create")) ) {
commit:277f3b3
/////////////////////////////////////////////////////////////////////////
1:         if (host == null) {
0:             host = "localhost";
0:         }
============================================================================