1:3f32507: /*
1:3f32507:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:3f32507:  *  contributor license agreements.  See the NOTICE file distributed with
1:3f32507:  *  this work for additional information regarding copyright ownership.
1:3f32507:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:3f32507:  *  (the "License"); you may not use this file except in compliance with
1:3f32507:  *  the License.  You may obtain a copy of the License at
1:3f32507:  *
1:3f32507:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3f32507:  *
1:3f32507:  *  Unless required by applicable law or agreed to in writing, software
1:3f32507:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:3f32507:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3f32507:  *  See the License for the specific language governing permissions and
1:3f32507:  *  limitations under the License.
1:3f32507:  *
1:3f32507:  */
1:3f32507: 
1:3f32507: /*
1:3f32507:  * This package is based on the work done by Timothy Gerard Endres
1:3f32507:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
1:3f32507:  */
1:3f32507: 
1:3f32507: package org.apache.activemq.console.command.store.tar;
1:3f32507: 
1:3f32507: import java.io.FilterInputStream;
1:3f32507: import java.io.IOException;
1:3f32507: import java.io.InputStream;
1:3f32507: import java.io.OutputStream;
1:3f32507: 
1:3f32507: /**
1:3f32507:  * The TarInputStream reads a UNIX tar archive as an InputStream.
1:3f32507:  * methods are provided to position at each successive entry in
1:3f32507:  * the archive, and the read each entry as a normal input stream
1:3f32507:  * using read().
1:3f32507:  *
1:3f32507:  */
1:3f32507: public class TarInputStream extends FilterInputStream {
1:3f32507:     private static final int SMALL_BUFFER_SIZE = 256;
1:3f32507:     private static final int BUFFER_SIZE = 8 * 1024;
1:3f32507:     private static final int LARGE_BUFFER_SIZE = 32 * 1024;
1:3f32507:     private static final int BYTE_MASK = 0xFF;
1:3f32507: 
1:3f32507:     // CheckStyle:VisibilityModifier OFF - bc
1:3f32507:     protected boolean debug;
1:3f32507:     protected boolean hasHitEOF;
1:3f32507:     protected long entrySize;
1:3f32507:     protected long entryOffset;
1:3f32507:     protected byte[] readBuf;
1:3f32507:     protected TarBuffer buffer;
1:3f32507:     protected TarEntry currEntry;
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * This contents of this array is not used at all in this class,
1:3f32507:      * it is only here to avoid repreated object creation during calls
1:3f32507:      * to the no-arg read method.
1:3f32507:      */
1:3f32507:     protected byte[] oneBuf;
1:3f32507: 
1:3f32507:     // CheckStyle:VisibilityModifier ON
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Constructor for TarInputStream.
1:3f32507:      * @param is the input stream to use
1:3f32507:      */
1:3f32507:     public TarInputStream(InputStream is) {
1:3f32507:         this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Constructor for TarInputStream.
1:3f32507:      * @param is the input stream to use
1:3f32507:      * @param blockSize the block size to use
1:3f32507:      */
1:3f32507:     public TarInputStream(InputStream is, int blockSize) {
1:3f32507:         this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Constructor for TarInputStream.
1:3f32507:      * @param is the input stream to use
1:3f32507:      * @param blockSize the block size to use
1:3f32507:      * @param recordSize the record size to use
1:3f32507:      */
1:3f32507:     public TarInputStream(InputStream is, int blockSize, int recordSize) {
1:3f32507:         super(is);
1:3f32507: 
1:3f32507:         this.buffer = new TarBuffer(is, blockSize, recordSize);
1:3f32507:         this.readBuf = null;
1:3f32507:         this.oneBuf = new byte[1];
1:3f32507:         this.debug = false;
1:3f32507:         this.hasHitEOF = false;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Sets the debugging flag.
1:3f32507:      *
1:3f32507:      * @param debug True to turn on debugging.
1:3f32507:      */
1:3f32507:     public void setDebug(boolean debug) {
1:3f32507:         this.debug = debug;
1:3f32507:         buffer.setDebug(debug);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Closes this stream. Calls the TarBuffer's close() method.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void close() throws IOException {
1:3f32507:         buffer.close();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get the record size being used by this stream's TarBuffer.
1:3f32507:      *
1:3f32507:      * @return The TarBuffer record size.
1:3f32507:      */
1:3f32507:     public int getRecordSize() {
1:3f32507:         return buffer.getRecordSize();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get the available data that can be read from the current
1:3f32507:      * entry in the archive. This does not indicate how much data
1:3f32507:      * is left in the entire archive, only in the current entry.
1:3f32507:      * This value is determined from the entry's size header field
1:3f32507:      * and the amount of data already read from the current entry.
1:3f32507:      * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
1:3f32507:      * bytes are left in the current entry in the archive.
1:3f32507:      *
1:3f32507:      * @return The number of available bytes for the current entry.
1:3f32507:      * @throws IOException for signature
1:3f32507:      */
1:3f32507:     public int available() throws IOException {
1:3f32507:         if (entrySize - entryOffset > Integer.MAX_VALUE) {
1:3f32507:             return Integer.MAX_VALUE;
1:3f32507:         }
1:3f32507:         return (int) (entrySize - entryOffset);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Skip bytes in the input buffer. This skips bytes in the
1:3f32507:      * current entry's data, not the entire archive, and will
1:3f32507:      * stop at the end of the current entry's data if the number
1:3f32507:      * to skip extends beyond that point.
1:3f32507:      *
1:3f32507:      * @param numToSkip The number of bytes to skip.
1:3f32507:      * @return the number actually skipped
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public long skip(long numToSkip) throws IOException {
1:3f32507:         // REVIEW
1:3f32507:         // This is horribly inefficient, but it ensures that we
1:3f32507:         // properly skip over bytes via the TarBuffer...
1:3f32507:         //
1:3f32507:         byte[] skipBuf = new byte[BUFFER_SIZE];
1:3f32507:         long skip = numToSkip;
1:3f32507:         while (skip > 0) {
1:3f32507:             int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
1:3f32507:             int numRead = read(skipBuf, 0, realSkip);
1:3f32507:             if (numRead == -1) {
1:3f32507:                 break;
1:3f32507:             }
1:3f32507:             skip -= numRead;
1:3f32507:         }
1:3f32507:         return (numToSkip - skip);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Since we do not support marking just yet, we return false.
1:3f32507:      *
1:3f32507:      * @return False.
1:3f32507:      */
1:3f32507:     public boolean markSupported() {
1:3f32507:         return false;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Since we do not support marking just yet, we do nothing.
1:3f32507:      *
1:3f32507:      * @param markLimit The limit to mark.
1:3f32507:      */
1:3f32507:     public void mark(int markLimit) {
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Since we do not support marking just yet, we do nothing.
1:3f32507:      */
1:3f32507:     public void reset() {
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get the next entry in this tar archive. This will skip
1:3f32507:      * over any remaining data in the current entry, if there
1:3f32507:      * is one, and place the input stream at the header of the
1:3f32507:      * next entry, and read the header and instantiate a new
1:3f32507:      * TarEntry from the header bytes and return that entry.
1:3f32507:      * If there are no more entries in the archive, null will
1:3f32507:      * be returned to indicate that the end of the archive has
1:3f32507:      * been reached.
1:3f32507:      *
1:3f32507:      * @return The next TarEntry in the archive, or null.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public TarEntry getNextEntry() throws IOException {
1:3f32507:         if (hasHitEOF) {
1:3f32507:             return null;
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (currEntry != null) {
1:3f32507:             long numToSkip = entrySize - entryOffset;
1:3f32507: 
1:3f32507:             if (debug) {
1:3f32507:                 System.err.println("TarInputStream: SKIP currENTRY '"
1:3f32507:                         + currEntry.getName() + "' SZ "
1:3f32507:                         + entrySize + " OFF "
1:3f32507:                         + entryOffset + "  skipping "
1:3f32507:                         + numToSkip + " bytes");
1:3f32507:             }
1:3f32507: 
1:3f32507:             while (numToSkip > 0) {
1:3f32507:                 long skipped = skip(numToSkip);
1:3f32507:                 if (skipped <= 0) {
1:3f32507:                     throw new RuntimeException("failed to skip current tar"
1:3f32507:                                                + " entry");
1:3f32507:                 }
1:3f32507:                 numToSkip -= skipped;
1:3f32507:             }
1:3f32507: 
1:3f32507:             readBuf = null;
1:3f32507:         }
1:3f32507: 
1:3f32507:         byte[] headerBuf = buffer.readRecord();
1:3f32507: 
1:3f32507:         if (headerBuf == null) {
1:3f32507:             if (debug) {
1:3f32507:                 System.err.println("READ NULL RECORD");
1:3f32507:             }
1:3f32507:             hasHitEOF = true;
1:3f32507:         } else if (buffer.isEOFRecord(headerBuf)) {
1:3f32507:             if (debug) {
1:3f32507:                 System.err.println("READ EOF RECORD");
1:3f32507:             }
1:3f32507:             hasHitEOF = true;
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (hasHitEOF) {
1:3f32507:             currEntry = null;
1:3f32507:         } else {
1:3f32507:             currEntry = new TarEntry(headerBuf);
1:3f32507: 
1:3f32507:             if (debug) {
1:3f32507:                 System.err.println("TarInputStream: SET CURRENTRY '"
1:3f32507:                         + currEntry.getName()
1:3f32507:                         + "' size = "
1:3f32507:                         + currEntry.getSize());
1:3f32507:             }
1:3f32507: 
1:3f32507:             entryOffset = 0;
1:3f32507: 
1:3f32507:             entrySize = currEntry.getSize();
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (currEntry != null && currEntry.isGNULongNameEntry()) {
1:3f32507:             // read in the name
1:3f32507:             StringBuffer longName = new StringBuffer();
1:3f32507:             byte[] buf = new byte[SMALL_BUFFER_SIZE];
1:3f32507:             int length = 0;
1:3f32507:             while ((length = read(buf)) >= 0) {
1:3f32507:                 longName.append(new String(buf, 0, length));
1:3f32507:             }
1:3f32507:             getNextEntry();
1:3f32507:             if (currEntry == null) {
1:3f32507:                 // Bugzilla: 40334
1:3f32507:                 // Malformed tar file - long entry name not followed by entry
1:3f32507:                 return null;
1:3f32507:             }
1:3f32507:             // remove trailing null terminator
1:3f32507:             if (longName.length() > 0
1:3f32507:                 && longName.charAt(longName.length() - 1) == 0) {
1:3f32507:                 longName.deleteCharAt(longName.length() - 1);
1:3f32507:             }
1:3f32507:             currEntry.setName(longName.toString());
1:3f32507:         }
1:3f32507: 
1:3f32507:         return currEntry;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Reads a byte from the current tar archive entry.
1:3f32507:      *
1:3f32507:      * This method simply calls read( byte[], int, int ).
1:3f32507:      *
1:3f32507:      * @return The byte read, or -1 at EOF.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public int read() throws IOException {
1:3f32507:         int num = read(oneBuf, 0, 1);
1:3f32507:         return num == -1 ? -1 : ((int) oneBuf[0]) & BYTE_MASK;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Reads bytes from the current tar archive entry.
1:3f32507:      *
1:3f32507:      * This method is aware of the boundaries of the current
1:3f32507:      * entry in the archive and will deal with them as if they
1:3f32507:      * were this stream's start and EOF.
1:3f32507:      *
1:3f32507:      * @param buf The buffer into which to place bytes read.
1:3f32507:      * @param offset The offset at which to place bytes read.
1:3f32507:      * @param numToRead The number of bytes to read.
1:3f32507:      * @return The number of bytes read, or -1 at EOF.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public int read(byte[] buf, int offset, int numToRead) throws IOException {
1:3f32507:         int totalRead = 0;
1:3f32507: 
1:3f32507:         if (entryOffset >= entrySize) {
1:3f32507:             return -1;
1:3f32507:         }
1:3f32507: 
1:3f32507:         if ((numToRead + entryOffset) > entrySize) {
1:3f32507:             numToRead = (int) (entrySize - entryOffset);
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (readBuf != null) {
1:3f32507:             int sz = (numToRead > readBuf.length) ? readBuf.length
1:3f32507:                     : numToRead;
1:3f32507: 
1:3f32507:             System.arraycopy(readBuf, 0, buf, offset, sz);
1:3f32507: 
1:3f32507:             if (sz >= readBuf.length) {
1:3f32507:                 readBuf = null;
1:3f32507:             } else {
1:3f32507:                 int newLen = readBuf.length - sz;
1:3f32507:                 byte[] newBuf = new byte[newLen];
1:3f32507: 
1:3f32507:                 System.arraycopy(readBuf, sz, newBuf, 0, newLen);
1:3f32507: 
1:3f32507:                 readBuf = newBuf;
1:3f32507:             }
1:3f32507: 
1:3f32507:             totalRead += sz;
1:3f32507:             numToRead -= sz;
1:3f32507:             offset += sz;
1:3f32507:         }
1:3f32507: 
1:3f32507:         while (numToRead > 0) {
1:3f32507:             byte[] rec = buffer.readRecord();
1:3f32507: 
1:3f32507:             if (rec == null) {
1:3f32507:                 // Unexpected EOF!
1:3f32507:                 throw new IOException("unexpected EOF with " + numToRead
1:3f32507:                         + " bytes unread");
1:3f32507:             }
1:3f32507: 
1:3f32507:             int sz = numToRead;
1:3f32507:             int recLen = rec.length;
1:3f32507: 
1:3f32507:             if (recLen > sz) {
1:3f32507:                 System.arraycopy(rec, 0, buf, offset, sz);
1:3f32507: 
1:3f32507:                 readBuf = new byte[recLen - sz];
1:3f32507: 
1:3f32507:                 System.arraycopy(rec, sz, readBuf, 0, recLen - sz);
1:3f32507:             } else {
1:3f32507:                 sz = recLen;
1:3f32507: 
1:3f32507:                 System.arraycopy(rec, 0, buf, offset, recLen);
1:3f32507:             }
1:3f32507: 
1:3f32507:             totalRead += sz;
1:3f32507:             numToRead -= sz;
1:3f32507:             offset += sz;
1:3f32507:         }
1:3f32507: 
1:3f32507:         entryOffset += totalRead;
1:3f32507: 
1:3f32507:         return totalRead;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Copies the contents of the current tar archive entry directly into
1:3f32507:      * an output stream.
1:3f32507:      *
1:3f32507:      * @param out The OutputStream into which to write the entry's data.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void copyEntryContents(OutputStream out) throws IOException {
1:3f32507:         byte[] buf = new byte[LARGE_BUFFER_SIZE];
1:3f32507: 
1:3f32507:         while (true) {
1:3f32507:             int numRead = read(buf, 0, buf.length);
1:3f32507: 
1:3f32507:             if (numRead == -1) {
1:3f32507:                 break;
1:3f32507:             }
1:3f32507: 
1:3f32507:             out.write(buf, 0, numRead);
1:3f32507:         }
1:3f32507:     }
1:3f32507: }
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:3f32507
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  *
1:  */
1: 
1: /*
1:  * This package is based on the work done by Timothy Gerard Endres
1:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
1:  */
1: 
1: package org.apache.activemq.console.command.store.tar;
1: 
1: import java.io.FilterInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: 
1: /**
1:  * The TarInputStream reads a UNIX tar archive as an InputStream.
1:  * methods are provided to position at each successive entry in
1:  * the archive, and the read each entry as a normal input stream
1:  * using read().
1:  *
1:  */
1: public class TarInputStream extends FilterInputStream {
1:     private static final int SMALL_BUFFER_SIZE = 256;
1:     private static final int BUFFER_SIZE = 8 * 1024;
1:     private static final int LARGE_BUFFER_SIZE = 32 * 1024;
1:     private static final int BYTE_MASK = 0xFF;
1: 
1:     // CheckStyle:VisibilityModifier OFF - bc
1:     protected boolean debug;
1:     protected boolean hasHitEOF;
1:     protected long entrySize;
1:     protected long entryOffset;
1:     protected byte[] readBuf;
1:     protected TarBuffer buffer;
1:     protected TarEntry currEntry;
1: 
1:     /**
1:      * This contents of this array is not used at all in this class,
1:      * it is only here to avoid repreated object creation during calls
1:      * to the no-arg read method.
1:      */
1:     protected byte[] oneBuf;
1: 
1:     // CheckStyle:VisibilityModifier ON
1: 
1:     /**
1:      * Constructor for TarInputStream.
1:      * @param is the input stream to use
1:      */
1:     public TarInputStream(InputStream is) {
1:         this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
1:     }
1: 
1:     /**
1:      * Constructor for TarInputStream.
1:      * @param is the input stream to use
1:      * @param blockSize the block size to use
1:      */
1:     public TarInputStream(InputStream is, int blockSize) {
1:         this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
1:     }
1: 
1:     /**
1:      * Constructor for TarInputStream.
1:      * @param is the input stream to use
1:      * @param blockSize the block size to use
1:      * @param recordSize the record size to use
1:      */
1:     public TarInputStream(InputStream is, int blockSize, int recordSize) {
1:         super(is);
1: 
1:         this.buffer = new TarBuffer(is, blockSize, recordSize);
1:         this.readBuf = null;
1:         this.oneBuf = new byte[1];
1:         this.debug = false;
1:         this.hasHitEOF = false;
1:     }
1: 
1:     /**
1:      * Sets the debugging flag.
1:      *
1:      * @param debug True to turn on debugging.
1:      */
1:     public void setDebug(boolean debug) {
1:         this.debug = debug;
1:         buffer.setDebug(debug);
1:     }
1: 
1:     /**
1:      * Closes this stream. Calls the TarBuffer's close() method.
1:      * @throws IOException on error
1:      */
1:     public void close() throws IOException {
1:         buffer.close();
1:     }
1: 
1:     /**
1:      * Get the record size being used by this stream's TarBuffer.
1:      *
1:      * @return The TarBuffer record size.
1:      */
1:     public int getRecordSize() {
1:         return buffer.getRecordSize();
1:     }
1: 
1:     /**
1:      * Get the available data that can be read from the current
1:      * entry in the archive. This does not indicate how much data
1:      * is left in the entire archive, only in the current entry.
1:      * This value is determined from the entry's size header field
1:      * and the amount of data already read from the current entry.
1:      * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
1:      * bytes are left in the current entry in the archive.
1:      *
1:      * @return The number of available bytes for the current entry.
1:      * @throws IOException for signature
1:      */
1:     public int available() throws IOException {
1:         if (entrySize - entryOffset > Integer.MAX_VALUE) {
1:             return Integer.MAX_VALUE;
1:         }
1:         return (int) (entrySize - entryOffset);
1:     }
1: 
1:     /**
1:      * Skip bytes in the input buffer. This skips bytes in the
1:      * current entry's data, not the entire archive, and will
1:      * stop at the end of the current entry's data if the number
1:      * to skip extends beyond that point.
1:      *
1:      * @param numToSkip The number of bytes to skip.
1:      * @return the number actually skipped
1:      * @throws IOException on error
1:      */
1:     public long skip(long numToSkip) throws IOException {
1:         // REVIEW
1:         // This is horribly inefficient, but it ensures that we
1:         // properly skip over bytes via the TarBuffer...
1:         //
1:         byte[] skipBuf = new byte[BUFFER_SIZE];
1:         long skip = numToSkip;
1:         while (skip > 0) {
1:             int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
1:             int numRead = read(skipBuf, 0, realSkip);
1:             if (numRead == -1) {
1:                 break;
1:             }
1:             skip -= numRead;
1:         }
1:         return (numToSkip - skip);
1:     }
1: 
1:     /**
1:      * Since we do not support marking just yet, we return false.
1:      *
1:      * @return False.
1:      */
1:     public boolean markSupported() {
1:         return false;
1:     }
1: 
1:     /**
1:      * Since we do not support marking just yet, we do nothing.
1:      *
1:      * @param markLimit The limit to mark.
1:      */
1:     public void mark(int markLimit) {
1:     }
1: 
1:     /**
1:      * Since we do not support marking just yet, we do nothing.
1:      */
1:     public void reset() {
1:     }
1: 
1:     /**
1:      * Get the next entry in this tar archive. This will skip
1:      * over any remaining data in the current entry, if there
1:      * is one, and place the input stream at the header of the
1:      * next entry, and read the header and instantiate a new
1:      * TarEntry from the header bytes and return that entry.
1:      * If there are no more entries in the archive, null will
1:      * be returned to indicate that the end of the archive has
1:      * been reached.
1:      *
1:      * @return The next TarEntry in the archive, or null.
1:      * @throws IOException on error
1:      */
1:     public TarEntry getNextEntry() throws IOException {
1:         if (hasHitEOF) {
1:             return null;
1:         }
1: 
1:         if (currEntry != null) {
1:             long numToSkip = entrySize - entryOffset;
1: 
1:             if (debug) {
1:                 System.err.println("TarInputStream: SKIP currENTRY '"
1:                         + currEntry.getName() + "' SZ "
1:                         + entrySize + " OFF "
1:                         + entryOffset + "  skipping "
1:                         + numToSkip + " bytes");
1:             }
1: 
1:             while (numToSkip > 0) {
1:                 long skipped = skip(numToSkip);
1:                 if (skipped <= 0) {
1:                     throw new RuntimeException("failed to skip current tar"
1:                                                + " entry");
1:                 }
1:                 numToSkip -= skipped;
1:             }
1: 
1:             readBuf = null;
1:         }
1: 
1:         byte[] headerBuf = buffer.readRecord();
1: 
1:         if (headerBuf == null) {
1:             if (debug) {
1:                 System.err.println("READ NULL RECORD");
1:             }
1:             hasHitEOF = true;
1:         } else if (buffer.isEOFRecord(headerBuf)) {
1:             if (debug) {
1:                 System.err.println("READ EOF RECORD");
1:             }
1:             hasHitEOF = true;
1:         }
1: 
1:         if (hasHitEOF) {
1:             currEntry = null;
1:         } else {
1:             currEntry = new TarEntry(headerBuf);
1: 
1:             if (debug) {
1:                 System.err.println("TarInputStream: SET CURRENTRY '"
1:                         + currEntry.getName()
1:                         + "' size = "
1:                         + currEntry.getSize());
1:             }
1: 
1:             entryOffset = 0;
1: 
1:             entrySize = currEntry.getSize();
1:         }
1: 
1:         if (currEntry != null && currEntry.isGNULongNameEntry()) {
1:             // read in the name
1:             StringBuffer longName = new StringBuffer();
1:             byte[] buf = new byte[SMALL_BUFFER_SIZE];
1:             int length = 0;
1:             while ((length = read(buf)) >= 0) {
1:                 longName.append(new String(buf, 0, length));
1:             }
1:             getNextEntry();
1:             if (currEntry == null) {
1:                 // Bugzilla: 40334
1:                 // Malformed tar file - long entry name not followed by entry
1:                 return null;
1:             }
1:             // remove trailing null terminator
1:             if (longName.length() > 0
1:                 && longName.charAt(longName.length() - 1) == 0) {
1:                 longName.deleteCharAt(longName.length() - 1);
1:             }
1:             currEntry.setName(longName.toString());
1:         }
1: 
1:         return currEntry;
1:     }
1: 
1:     /**
1:      * Reads a byte from the current tar archive entry.
1:      *
1:      * This method simply calls read( byte[], int, int ).
1:      *
1:      * @return The byte read, or -1 at EOF.
1:      * @throws IOException on error
1:      */
1:     public int read() throws IOException {
1:         int num = read(oneBuf, 0, 1);
1:         return num == -1 ? -1 : ((int) oneBuf[0]) & BYTE_MASK;
1:     }
1: 
1:     /**
1:      * Reads bytes from the current tar archive entry.
1:      *
1:      * This method is aware of the boundaries of the current
1:      * entry in the archive and will deal with them as if they
1:      * were this stream's start and EOF.
1:      *
1:      * @param buf The buffer into which to place bytes read.
1:      * @param offset The offset at which to place bytes read.
1:      * @param numToRead The number of bytes to read.
1:      * @return The number of bytes read, or -1 at EOF.
1:      * @throws IOException on error
1:      */
1:     public int read(byte[] buf, int offset, int numToRead) throws IOException {
1:         int totalRead = 0;
1: 
1:         if (entryOffset >= entrySize) {
1:             return -1;
1:         }
1: 
1:         if ((numToRead + entryOffset) > entrySize) {
1:             numToRead = (int) (entrySize - entryOffset);
1:         }
1: 
1:         if (readBuf != null) {
1:             int sz = (numToRead > readBuf.length) ? readBuf.length
1:                     : numToRead;
1: 
1:             System.arraycopy(readBuf, 0, buf, offset, sz);
1: 
1:             if (sz >= readBuf.length) {
1:                 readBuf = null;
1:             } else {
1:                 int newLen = readBuf.length - sz;
1:                 byte[] newBuf = new byte[newLen];
1: 
1:                 System.arraycopy(readBuf, sz, newBuf, 0, newLen);
1: 
1:                 readBuf = newBuf;
1:             }
1: 
1:             totalRead += sz;
1:             numToRead -= sz;
1:             offset += sz;
1:         }
1: 
1:         while (numToRead > 0) {
1:             byte[] rec = buffer.readRecord();
1: 
1:             if (rec == null) {
1:                 // Unexpected EOF!
1:                 throw new IOException("unexpected EOF with " + numToRead
1:                         + " bytes unread");
1:             }
1: 
1:             int sz = numToRead;
1:             int recLen = rec.length;
1: 
1:             if (recLen > sz) {
1:                 System.arraycopy(rec, 0, buf, offset, sz);
1: 
1:                 readBuf = new byte[recLen - sz];
1: 
1:                 System.arraycopy(rec, sz, readBuf, 0, recLen - sz);
1:             } else {
1:                 sz = recLen;
1: 
1:                 System.arraycopy(rec, 0, buf, offset, recLen);
1:             }
1: 
1:             totalRead += sz;
1:             numToRead -= sz;
1:             offset += sz;
1:         }
1: 
1:         entryOffset += totalRead;
1: 
1:         return totalRead;
1:     }
1: 
1:     /**
1:      * Copies the contents of the current tar archive entry directly into
1:      * an output stream.
1:      *
1:      * @param out The OutputStream into which to write the entry's data.
1:      * @throws IOException on error
1:      */
1:     public void copyEntryContents(OutputStream out) throws IOException {
1:         byte[] buf = new byte[LARGE_BUFFER_SIZE];
1: 
1:         while (true) {
1:             int numRead = read(buf, 0, buf.length);
1: 
1:             if (numRead == -1) {
1:                 break;
1:             }
1: 
1:             out.write(buf, 0, numRead);
1:         }
1:     }
1: }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:cfe5e98
/////////////////////////////////////////////////////////////////////////
0: /*
0:  *  Licensed to the Apache Software Foundation (ASF) under one or more
0:  *  contributor license agreements.  See the NOTICE file distributed with
0:  *  this work for additional information regarding copyright ownership.
0:  *  The ASF licenses this file to You under the Apache License, Version 2.0
0:  *  (the "License"); you may not use this file except in compliance with
0:  *  the License.  You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  *  Unless required by applicable law or agreed to in writing, software
0:  *  distributed under the License is distributed on an "AS IS" BASIS,
0:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  *  See the License for the specific language governing permissions and
0:  *  limitations under the License.
0:  *
0:  */
0: 
0: /*
0:  * This package is based on the work done by Timothy Gerard Endres
0:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
0:  */
0: 
0: package org.apache.activemq.console.command.store.tar;
0: 
0: import java.io.FilterInputStream;
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: 
0: /**
0:  * The TarInputStream reads a UNIX tar archive as an InputStream.
0:  * methods are provided to position at each successive entry in
0:  * the archive, and the read each entry as a normal input stream
0:  * using read().
0:  *
0:  */
0: public class TarInputStream extends FilterInputStream {
0:     private static final int SMALL_BUFFER_SIZE = 256;
0:     private static final int BUFFER_SIZE = 8 * 1024;
0:     private static final int LARGE_BUFFER_SIZE = 32 * 1024;
0:     private static final int BYTE_MASK = 0xFF;
0: 
0:     // CheckStyle:VisibilityModifier OFF - bc
0:     protected boolean debug;
0:     protected boolean hasHitEOF;
0:     protected long entrySize;
0:     protected long entryOffset;
0:     protected byte[] readBuf;
0:     protected TarBuffer buffer;
0:     protected TarEntry currEntry;
0: 
0:     /**
0:      * This contents of this array is not used at all in this class,
0:      * it is only here to avoid repreated object creation during calls
0:      * to the no-arg read method.
0:      */
0:     protected byte[] oneBuf;
0: 
0:     // CheckStyle:VisibilityModifier ON
0: 
0:     /**
0:      * Constructor for TarInputStream.
0:      * @param is the input stream to use
0:      */
0:     public TarInputStream(InputStream is) {
0:         this(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
0:     }
0: 
0:     /**
0:      * Constructor for TarInputStream.
0:      * @param is the input stream to use
0:      * @param blockSize the block size to use
0:      */
0:     public TarInputStream(InputStream is, int blockSize) {
0:         this(is, blockSize, TarBuffer.DEFAULT_RCDSIZE);
0:     }
0: 
0:     /**
0:      * Constructor for TarInputStream.
0:      * @param is the input stream to use
0:      * @param blockSize the block size to use
0:      * @param recordSize the record size to use
0:      */
0:     public TarInputStream(InputStream is, int blockSize, int recordSize) {
0:         super(is);
0: 
0:         this.buffer = new TarBuffer(is, blockSize, recordSize);
0:         this.readBuf = null;
0:         this.oneBuf = new byte[1];
0:         this.debug = false;
0:         this.hasHitEOF = false;
0:     }
0: 
0:     /**
0:      * Sets the debugging flag.
0:      *
0:      * @param debug True to turn on debugging.
0:      */
0:     public void setDebug(boolean debug) {
0:         this.debug = debug;
0:         buffer.setDebug(debug);
0:     }
0: 
0:     /**
0:      * Closes this stream. Calls the TarBuffer's close() method.
0:      * @throws IOException on error
0:      */
0:     public void close() throws IOException {
0:         buffer.close();
0:     }
0: 
0:     /**
0:      * Get the record size being used by this stream's TarBuffer.
0:      *
0:      * @return The TarBuffer record size.
0:      */
0:     public int getRecordSize() {
0:         return buffer.getRecordSize();
0:     }
0: 
0:     /**
0:      * Get the available data that can be read from the current
0:      * entry in the archive. This does not indicate how much data
0:      * is left in the entire archive, only in the current entry.
0:      * This value is determined from the entry's size header field
0:      * and the amount of data already read from the current entry.
0:      * Integer.MAX_VALUE is returen in case more than Integer.MAX_VALUE
0:      * bytes are left in the current entry in the archive.
0:      *
0:      * @return The number of available bytes for the current entry.
0:      * @throws IOException for signature
0:      */
0:     public int available() throws IOException {
0:         if (entrySize - entryOffset > Integer.MAX_VALUE) {
0:             return Integer.MAX_VALUE;
0:         }
0:         return (int) (entrySize - entryOffset);
0:     }
0: 
0:     /**
0:      * Skip bytes in the input buffer. This skips bytes in the
0:      * current entry's data, not the entire archive, and will
0:      * stop at the end of the current entry's data if the number
0:      * to skip extends beyond that point.
0:      *
0:      * @param numToSkip The number of bytes to skip.
0:      * @return the number actually skipped
0:      * @throws IOException on error
0:      */
0:     public long skip(long numToSkip) throws IOException {
0:         // REVIEW
0:         // This is horribly inefficient, but it ensures that we
0:         // properly skip over bytes via the TarBuffer...
0:         //
0:         byte[] skipBuf = new byte[BUFFER_SIZE];
0:         long skip = numToSkip;
0:         while (skip > 0) {
0:             int realSkip = (int) (skip > skipBuf.length ? skipBuf.length : skip);
0:             int numRead = read(skipBuf, 0, realSkip);
0:             if (numRead == -1) {
0:                 break;
0:             }
0:             skip -= numRead;
0:         }
0:         return (numToSkip - skip);
0:     }
0: 
0:     /**
0:      * Since we do not support marking just yet, we return false.
0:      *
0:      * @return False.
0:      */
0:     public boolean markSupported() {
0:         return false;
0:     }
0: 
0:     /**
0:      * Since we do not support marking just yet, we do nothing.
0:      *
0:      * @param markLimit The limit to mark.
0:      */
0:     public void mark(int markLimit) {
0:     }
0: 
0:     /**
0:      * Since we do not support marking just yet, we do nothing.
0:      */
0:     public void reset() {
0:     }
0: 
0:     /**
0:      * Get the next entry in this tar archive. This will skip
0:      * over any remaining data in the current entry, if there
0:      * is one, and place the input stream at the header of the
0:      * next entry, and read the header and instantiate a new
0:      * TarEntry from the header bytes and return that entry.
0:      * If there are no more entries in the archive, null will
0:      * be returned to indicate that the end of the archive has
0:      * been reached.
0:      *
0:      * @return The next TarEntry in the archive, or null.
0:      * @throws IOException on error
0:      */
0:     public TarEntry getNextEntry() throws IOException {
0:         if (hasHitEOF) {
0:             return null;
0:         }
0: 
0:         if (currEntry != null) {
0:             long numToSkip = entrySize - entryOffset;
0: 
0:             if (debug) {
0:                 System.err.println("TarInputStream: SKIP currENTRY '"
0:                         + currEntry.getName() + "' SZ "
0:                         + entrySize + " OFF "
0:                         + entryOffset + "  skipping "
0:                         + numToSkip + " bytes");
0:             }
0: 
0:             while (numToSkip > 0) {
0:                 long skipped = skip(numToSkip);
0:                 if (skipped <= 0) {
0:                     throw new RuntimeException("failed to skip current tar"
0:                                                + " entry");
0:                 }
0:                 numToSkip -= skipped;
0:             }
0: 
0:             readBuf = null;
0:         }
0: 
0:         byte[] headerBuf = buffer.readRecord();
0: 
0:         if (headerBuf == null) {
0:             if (debug) {
0:                 System.err.println("READ NULL RECORD");
0:             }
0:             hasHitEOF = true;
0:         } else if (buffer.isEOFRecord(headerBuf)) {
0:             if (debug) {
0:                 System.err.println("READ EOF RECORD");
0:             }
0:             hasHitEOF = true;
0:         }
0: 
0:         if (hasHitEOF) {
0:             currEntry = null;
0:         } else {
0:             currEntry = new TarEntry(headerBuf);
0: 
0:             if (debug) {
0:                 System.err.println("TarInputStream: SET CURRENTRY '"
0:                         + currEntry.getName()
0:                         + "' size = "
0:                         + currEntry.getSize());
0:             }
0: 
0:             entryOffset = 0;
0: 
0:             entrySize = currEntry.getSize();
0:         }
0: 
0:         if (currEntry != null && currEntry.isGNULongNameEntry()) {
0:             // read in the name
0:             StringBuffer longName = new StringBuffer();
0:             byte[] buf = new byte[SMALL_BUFFER_SIZE];
0:             int length = 0;
0:             while ((length = read(buf)) >= 0) {
0:                 longName.append(new String(buf, 0, length));
0:             }
0:             getNextEntry();
0:             if (currEntry == null) {
0:                 // Bugzilla: 40334
0:                 // Malformed tar file - long entry name not followed by entry
0:                 return null;
0:             }
0:             // remove trailing null terminator
0:             if (longName.length() > 0
0:                 && longName.charAt(longName.length() - 1) == 0) {
0:                 longName.deleteCharAt(longName.length() - 1);
0:             }
0:             currEntry.setName(longName.toString());
0:         }
0: 
0:         return currEntry;
0:     }
0: 
0:     /**
0:      * Reads a byte from the current tar archive entry.
0:      *
0:      * This method simply calls read( byte[], int, int ).
0:      *
0:      * @return The byte read, or -1 at EOF.
0:      * @throws IOException on error
0:      */
0:     public int read() throws IOException {
0:         int num = read(oneBuf, 0, 1);
0:         return num == -1 ? -1 : ((int) oneBuf[0]) & BYTE_MASK;
0:     }
0: 
0:     /**
0:      * Reads bytes from the current tar archive entry.
0:      *
0:      * This method is aware of the boundaries of the current
0:      * entry in the archive and will deal with them as if they
0:      * were this stream's start and EOF.
0:      *
0:      * @param buf The buffer into which to place bytes read.
0:      * @param offset The offset at which to place bytes read.
0:      * @param numToRead The number of bytes to read.
0:      * @return The number of bytes read, or -1 at EOF.
0:      * @throws IOException on error
0:      */
0:     public int read(byte[] buf, int offset, int numToRead) throws IOException {
0:         int totalRead = 0;
0: 
0:         if (entryOffset >= entrySize) {
0:             return -1;
0:         }
0: 
0:         if ((numToRead + entryOffset) > entrySize) {
0:             numToRead = (int) (entrySize - entryOffset);
0:         }
0: 
0:         if (readBuf != null) {
0:             int sz = (numToRead > readBuf.length) ? readBuf.length
0:                     : numToRead;
0: 
0:             System.arraycopy(readBuf, 0, buf, offset, sz);
0: 
0:             if (sz >= readBuf.length) {
0:                 readBuf = null;
0:             } else {
0:                 int newLen = readBuf.length - sz;
0:                 byte[] newBuf = new byte[newLen];
0: 
0:                 System.arraycopy(readBuf, sz, newBuf, 0, newLen);
0: 
0:                 readBuf = newBuf;
0:             }
0: 
0:             totalRead += sz;
0:             numToRead -= sz;
0:             offset += sz;
0:         }
0: 
0:         while (numToRead > 0) {
0:             byte[] rec = buffer.readRecord();
0: 
0:             if (rec == null) {
0:                 // Unexpected EOF!
0:                 throw new IOException("unexpected EOF with " + numToRead
0:                         + " bytes unread");
0:             }
0: 
0:             int sz = numToRead;
0:             int recLen = rec.length;
0: 
0:             if (recLen > sz) {
0:                 System.arraycopy(rec, 0, buf, offset, sz);
0: 
0:                 readBuf = new byte[recLen - sz];
0: 
0:                 System.arraycopy(rec, sz, readBuf, 0, recLen - sz);
0:             } else {
0:                 sz = recLen;
0: 
0:                 System.arraycopy(rec, 0, buf, offset, recLen);
0:             }
0: 
0:             totalRead += sz;
0:             numToRead -= sz;
0:             offset += sz;
0:         }
0: 
0:         entryOffset += totalRead;
0: 
0:         return totalRead;
0:     }
0: 
0:     /**
0:      * Copies the contents of the current tar archive entry directly into
0:      * an output stream.
0:      *
0:      * @param out The OutputStream into which to write the entry's data.
0:      * @throws IOException on error
0:      */
0:     public void copyEntryContents(OutputStream out) throws IOException {
0:         byte[] buf = new byte[LARGE_BUFFER_SIZE];
0: 
0:         while (true) {
0:             int numRead = read(buf, 0, buf.length);
0: 
0:             if (numRead == -1) {
0:                 break;
0:             }
0: 
0:             out.write(buf, 0, numRead);
0:         }
0:     }
0: }
============================================================================