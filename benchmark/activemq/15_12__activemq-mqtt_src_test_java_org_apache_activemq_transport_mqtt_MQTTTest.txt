1:cfc6917: /**
1:cfc6917:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:cfc6917:  * contributor license agreements.  See the NOTICE file distributed with
1:cfc6917:  * this work for additional information regarding copyright ownership.
1:cfc6917:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:cfc6917:  * (the "License"); you may not use this file except in compliance with
1:cfc6917:  * the License.  You may obtain a copy of the License at
1:cfc6917:  *
1:cfc6917:  *      http://www.apache.org/licenses/LICENSE-2.0
1:cfc6917:  *
1:cfc6917:  * Unless required by applicable law or agreed to in writing, software
1:cfc6917:  * distributed under the License is distributed on an "AS IS" BASIS,
1:cfc6917:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cfc6917:  * See the License for the specific language governing permissions and
1:cfc6917:  * limitations under the License.
1:cfc6917:  */
1:cfc6917: package org.apache.activemq.transport.mqtt;
1:8d04e2b: 
1:fc3d90e: import static org.fusesource.hawtbuf.UTF8Buffer.utf8;
1:b11fc8f: import static org.junit.Assert.assertArrayEquals;
1:b11fc8f: import static org.junit.Assert.assertEquals;
1:67f151f: import static org.junit.Assert.assertNotEquals;
1:b11fc8f: import static org.junit.Assert.assertNotNull;
1:b11fc8f: import static org.junit.Assert.assertNull;
1:b11fc8f: import static org.junit.Assert.assertTrue;
1:b11fc8f: import static org.junit.Assert.fail;
1:b11fc8f: 
1:67f151f: import java.net.ProtocolException;
1:bcb60a4: import java.util.ArrayList;
1:bf8eb0e: import java.util.Arrays;
1:bcb60a4: import java.util.List;
1:afddc1a: import java.util.Map;
1:afddc1a: import java.util.Random;
1:afddc1a: import java.util.concurrent.ConcurrentHashMap;
1:bc9751a: import java.util.concurrent.CountDownLatch;
1:1e3ea5c: import java.util.concurrent.TimeUnit;
1:62c20eb: import java.util.concurrent.atomic.AtomicReference;
1:e7e317d: import java.util.regex.Pattern;
1:b11fc8f: 
1:6683eb6: import javax.jms.BytesMessage;
1:6683eb6: import javax.jms.Connection;
1:6683eb6: import javax.jms.Destination;
1:6683eb6: import javax.jms.MessageConsumer;
1:6683eb6: import javax.jms.MessageProducer;
1:f55edcf: import javax.jms.Queue;
1:6683eb6: import javax.jms.Session;
1:6683eb6: import javax.jms.TextMessage;
1:8d04e2b: 
1:bc9751a: import org.apache.activemq.ActiveMQConnection;
1:f55edcf: import org.apache.activemq.ActiveMQConnectionFactory;
1:bcb60a4: import org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy;
1:bcb60a4: import org.apache.activemq.broker.region.policy.PolicyEntry;
1:bcb60a4: import org.apache.activemq.broker.region.policy.PolicyMap;
1:a581d01: import org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy;
1:bc9751a: import org.apache.activemq.command.ActiveMQMessage;
1:ac23b01: import org.apache.activemq.command.ActiveMQTopic;
1:bc9751a: import org.apache.activemq.util.ByteSequence;
1:cfc6917: import org.apache.activemq.util.Wait;
1:0f5b406: import org.fusesource.mqtt.client.BlockingConnection;
1:0f5b406: import org.fusesource.mqtt.client.MQTT;
1:0f5b406: import org.fusesource.mqtt.client.Message;
1:0f5b406: import org.fusesource.mqtt.client.QoS;
1:0f5b406: import org.fusesource.mqtt.client.Topic;
1:e0ae445: import org.fusesource.mqtt.client.Tracer;
1:e0ae445: import org.fusesource.mqtt.codec.MQTTFrame;
1:0db7e69: import org.fusesource.mqtt.codec.PUBLISH;
1:0f5b406: import org.junit.Test;
1:cfc6917: import org.slf4j.Logger;
1:cfc6917: import org.slf4j.LoggerFactory;
1:fb569e3: 
1:fb569e3: public class MQTTTest extends MQTTTestSupport {
1:fb569e3: 
1:cfc6917:     private static final Logger LOG = LoggerFactory.getLogger(MQTTTest.class);
1:fb569e3: 
1:101b712:     private static final int NUM_MESSAGES = 200;
1:fb569e3: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bc9751a:     public void testSendAndReceiveMQTT() throws Exception {
1:bc9751a:         final MQTTClientProvider subscriptionProvider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(subscriptionProvider);
1:f4a8b11: 
1:f4a8b11:         subscriptionProvider.subscribe("foo/bah", AT_MOST_ONCE);
1:f4a8b11: 
1:fb569e3:         final CountDownLatch latch = new CountDownLatch(NUM_MESSAGES);
1:0db7e69: 
1:bc9751a:         Thread thread = new Thread(new Runnable() {
1:7e56f34:             @Override
1:bc9751a:             public void run() {
1:fb569e3:                 for (int i = 0; i < NUM_MESSAGES; i++) {
1:0db7e69:                     try {
1:bc9751a:                         byte[] payload = subscriptionProvider.receive(10000);
1:bc9751a:                         assertNotNull("Should get a message", payload);
1:6dacef1:                         latch.countDown();
1:bc9751a:                     } catch (Exception e) {
1:bc9751a:                         e.printStackTrace();
1:bf8eb0e:                         break;
1:bc9751a:                     }
1:67f151f: 
1:6dacef1:                 }
1:7948d69:             }
1:fb569e3:         });
1:bc9751a:         thread.start();
1:6dacef1: 
1:bc9751a:         final MQTTClientProvider publishProvider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(publishProvider);
1:6dacef1: 
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Message " + i;
1:f4a8b11:             publishProvider.publish("foo/bah", payload.getBytes(), AT_LEAST_ONCE);
1:fb569e3:         }
1:f4a8b11: 
2:bc9751a:         latch.await(10, TimeUnit.SECONDS);
1:bc9751a:         assertEquals(0, latch.getCount());
1:bc9751a:         subscriptionProvider.disconnect();
1:bc9751a:         publishProvider.disconnect();
1:bc9751a:     }
1:7e56f34: 
1:67f151f:     @Test(timeout = 60 * 1000)
1:bc9751a:     public void testUnsubscribeMQTT() throws Exception {
1:bc9751a:         final MQTTClientProvider subscriptionProvider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(subscriptionProvider);
1:6d20cba: 
1:bc9751a:         String topic = "foo/bah";
1:6d20cba: 
1:bf8eb0e:         subscriptionProvider.subscribe(topic, AT_MOST_ONCE);
1:6d20cba: 
1:fb569e3:         final CountDownLatch latch = new CountDownLatch(NUM_MESSAGES / 2);
1:fc3d90e: 
1:bc9751a:         Thread thread = new Thread(new Runnable() {
1:45c0dfb:             @Override
1:bc9751a:             public void run() {
1:fb569e3:                 for (int i = 0; i < NUM_MESSAGES; i++) {
1:7e56f34:                     try {
1:bc9751a:                         byte[] payload = subscriptionProvider.receive(10000);
1:bc9751a:                         assertNotNull("Should get a message", payload);
1:6dacef1:                         latch.countDown();
1:bc9751a:                     } catch (Exception e) {
1:bc9751a:                         e.printStackTrace();
2:bc9751a:                         break;
1:bc9751a:                     }
1:fc3d90e: 
1:bc9751a:                 }
1:bc9751a:             }
1:9c67f0d:         });
1:bc9751a:         thread.start();
1:ac23b01: 
1:bc9751a:         final MQTTClientProvider publishProvider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(publishProvider);
1:ac23b01: 
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Message " + i;
1:fb569e3:             if (i == NUM_MESSAGES / 2) {
1:d547025:                 latch.await(20, TimeUnit.SECONDS);
1:bc9751a:                 subscriptionProvider.unsubscribe(topic);
1:bc9751a:             }
1:f4a8b11:             publishProvider.publish(topic, payload.getBytes(), AT_LEAST_ONCE);
1:bc9751a:         }
1:ac23b01: 
1:413e484:         latch.await(20, TimeUnit.SECONDS);
1:bc9751a:         assertEquals(0, latch.getCount());
1:bc9751a:         subscriptionProvider.disconnect();
1:bc9751a:         publishProvider.disconnect();
1:bc9751a:     }
1:ac23b01: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bc9751a:     public void testSendAtMostOnceReceiveExactlyOnce() throws Exception {
1:bc9751a:         /**
1:bc9751a:          * Although subscribing with EXACTLY ONCE, the message gets published
1:f4a8b11:          * with AT_MOST_ONCE - in MQTT the QoS is always determined by the
1:f4a8b11:          * message as published - not the wish of the subscriber
1:bc9751a:          */
1:bc9751a:         final MQTTClientProvider provider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(provider);
1:f4a8b11:         provider.subscribe("foo", EXACTLY_ONCE);
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Test Message: " + i;
1:bc9751a:             provider.publish("foo", payload.getBytes(), AT_MOST_ONCE);
3:bc9751a:             byte[] message = provider.receive(5000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:bc9751a:             assertEquals(payload, new String(message));
1:bc9751a:         }
1:bc9751a:         provider.disconnect();
1:bc9751a:     }
1:ac23b01: 
1:d4a376d:     @Test(timeout = 2 * 60 * 1000)
1:bc9751a:     public void testSendAtLeastOnceReceiveExactlyOnce() throws Exception {
1:bc9751a:         final MQTTClientProvider provider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(provider);
1:f4a8b11:         provider.subscribe("foo", EXACTLY_ONCE);
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Test Message: " + i;
1:bc9751a:             provider.publish("foo", payload.getBytes(), AT_LEAST_ONCE);
1:101b712:             byte[] message = provider.receive(2000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:bc9751a:             assertEquals(payload, new String(message));
1:bc9751a:         }
1:bc9751a:         provider.disconnect();
1:bc9751a:     }
1:ac23b01: 
1:d4a376d:     @Test(timeout = 2 * 60 * 1000)
1:bc9751a:     public void testSendAtLeastOnceReceiveAtMostOnce() throws Exception {
1:bc9751a:         final MQTTClientProvider provider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(provider);
1:f4a8b11:         provider.subscribe("foo", AT_MOST_ONCE);
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Test Message: " + i;
1:bc9751a:             provider.publish("foo", payload.getBytes(), AT_LEAST_ONCE);
1:bc9751a:             byte[] message = provider.receive(5000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:bc9751a:             assertEquals(payload, new String(message));
1:bc9751a:         }
1:bc9751a:         provider.disconnect();
1:bc9751a:     }
1:ac23b01: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bc9751a:     public void testSendAndReceiveAtMostOnce() throws Exception {
1:bc9751a:         final MQTTClientProvider provider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(provider);
1:f4a8b11:         provider.subscribe("foo", AT_MOST_ONCE);
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Test Message: " + i;
1:bc9751a:             provider.publish("foo", payload.getBytes(), AT_MOST_ONCE);
1:bc9751a:             byte[] message = provider.receive(5000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:bc9751a:             assertEquals(payload, new String(message));
1:bc9751a:         }
1:bc9751a:         provider.disconnect();
1:bc9751a:     }
1:6c85967: 
1:d4a376d:     @Test(timeout = 2 * 60 * 1000)
1:bc9751a:     public void testSendAndReceiveAtLeastOnce() throws Exception {
1:bc9751a:         final MQTTClientProvider provider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(provider);
1:f4a8b11:         provider.subscribe("foo", AT_LEAST_ONCE);
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Test Message: " + i;
1:bc9751a:             provider.publish("foo", payload.getBytes(), AT_LEAST_ONCE);
1:bc9751a:             byte[] message = provider.receive(5000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:bc9751a:             assertEquals(payload, new String(message));
1:bc9751a:         }
1:bc9751a:         provider.disconnect();
1:bc9751a:     }
1:a581d01: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bc9751a:     public void testSendAndReceiveExactlyOnce() throws Exception {
1:bc9751a:         final MQTTClientProvider publisher = getMQTTClientProvider();
1:bc9751a:         initializeConnection(publisher);
1:a581d01: 
1:bc9751a:         final MQTTClientProvider subscriber = getMQTTClientProvider();
1:bc9751a:         initializeConnection(subscriber);
1:a581d01: 
1:f4a8b11:         subscriber.subscribe("foo", EXACTLY_ONCE);
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Test Message: " + i;
1:bc9751a:             publisher.publish("foo", payload.getBytes(), EXACTLY_ONCE);
1:bc9751a:             byte[] message = subscriber.receive(5000);
1:f4a8b11:             assertNotNull("Should get a message + [" + i + "]", message);
1:bc9751a:             assertEquals(payload, new String(message));
1:bc9751a:         }
1:bc9751a:         subscriber.disconnect();
1:bc9751a:         publisher.disconnect();
1:e7e317d:     }
1:0db7e69: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bc9751a:     public void testSendAndReceiveLargeMessages() throws Exception {
1:bc9751a:         byte[] payload = new byte[1024 * 32];
1:f4a8b11:         for (int i = 0; i < payload.length; i++) {
1:bc9751a:             payload[i] = '2';
1:bc9751a:         }
1:bc9751a:         final MQTTClientProvider publisher = getMQTTClientProvider();
1:bc9751a:         initializeConnection(publisher);
1:a581d01: 
1:bc9751a:         final MQTTClientProvider subscriber = getMQTTClientProvider();
1:bc9751a:         initializeConnection(subscriber);
1:a581d01: 
1:f4a8b11:         subscriber.subscribe("foo", AT_LEAST_ONCE);
1:f4a8b11:         for (int i = 0; i < 10; i++) {
1:bc9751a:             publisher.publish("foo", payload, AT_LEAST_ONCE);
1:bc9751a:             byte[] message = subscriber.receive(5000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:bcb60a4: 
1:bc9751a:             assertArrayEquals(payload, message);
1:bc9751a:         }
1:bc9751a:         subscriber.disconnect();
1:bc9751a:         publisher.disconnect();
1:bc9751a:     }
1:bcb60a4: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:6683eb6:     public void testSendAndReceiveRetainedMessages() throws Exception {
1:6683eb6:         final MQTTClientProvider publisher = getMQTTClientProvider();
1:6683eb6:         initializeConnection(publisher);
1:bcb60a4: 
1:6683eb6:         final MQTTClientProvider subscriber = getMQTTClientProvider();
1:6683eb6:         initializeConnection(subscriber);
1:e7e317d: 
1:6683eb6:         String RETAINED = "retained";
1:7e56f34:         publisher.publish("foo", RETAINED.getBytes(), AT_LEAST_ONCE, true);
1:e7e317d: 
1:6683eb6:         List<String> messages = new ArrayList<String>();
1:f4a8b11:         for (int i = 0; i < 10; i++) {
1:6683eb6:             messages.add("TEST MESSAGE:" + i);
1:bc9751a:         }
1:e7e317d: 
1:f4a8b11:         subscriber.subscribe("foo", AT_LEAST_ONCE);
1:e7e317d: 
1:bc9751a:         for (int i = 0; i < 10; i++) {
1:6683eb6:             publisher.publish("foo", messages.get(i).getBytes(), AT_LEAST_ONCE);
1:bc9751a:         }
1:6683eb6:         byte[] msg = subscriber.receive(5000);
1:7e56f34:         assertNotNull(msg);
1:f4a8b11:         assertEquals(RETAINED, new String(msg));
1:e7e317d: 
1:f4a8b11:         for (int i = 0; i < 10; i++) {
1:6683eb6:             msg = subscriber.receive(5000);
1:0db7e69:             assertNotNull(msg);
1:7e56f34:             assertEquals(messages.get(i), new String(msg));
1:bc9751a:         }
1:6683eb6:         subscriber.disconnect();
1:6683eb6:         publisher.disconnect();
1:bc9751a:     }
1:e7e317d: 
1:f4a8b11:     @Test(timeout = 30 * 1000)
1:e7e317d:     public void testValidZeroLengthClientId() throws Exception {
1:67f151f:         MQTT mqtt = createMQTTConnection();
1:e7e317d:         mqtt.setClientId("");
1:67f151f:         mqtt.setCleanSession(true);
1:c530b69: 
1:45c0dfb:         BlockingConnection connection = mqtt.blockingConnection();
1:7948d69:         connection.connect();
2:e7e317d:         connection.disconnect();
1:6dacef1:     }
1:808a4c5: 
1:c530b69:     @Test(timeout = 30 * 1000)
1:c530b69:     public void testConnectWithUserButNoPassword() throws Exception {
1:6dacef1:         MQTT mqtt = createMQTTConnection();
1:c530b69:         mqtt.setClientId("test");
1:c530b69:         mqtt.setUserName("foo");
1:6dacef1: 
1:c530b69:         BlockingConnection connection = mqtt.blockingConnection();
1:c530b69:         connection.connect();
1:c530b69:         connection.disconnect();
1:6dacef1:     }
1:6dacef1: 
1:c530b69:     @Test(timeout = 30 * 1000)
1:c530b69:     public void testConnectWithPasswordButNoUsername() throws Exception {
1:6dacef1:         MQTT mqtt = createMQTTConnection();
1:c530b69:         mqtt.setVersion("3.1.1"); // The V3.1 spec doesn't make the same assertion
1:c530b69:         mqtt.setClientId("test");
1:c530b69:         mqtt.setPassword("bar");
1:6dacef1: 
1:c530b69:         BlockingConnection connection = mqtt.blockingConnection();
1:6dacef1: 
1:67f151f:         try {
1:c530b69:             connection.connect();
1:c530b69:             fail("Should not be able to connect in this case.");
1:c530b69:         } catch (Exception ex) {
1:c530b69:             LOG.info("Exception expected on connect with password but no username");
1:6dacef1:         }
1:6dacef1:     }
1:6dacef1: 
1:d4a376d:     @Test(timeout = 2 *  60 * 1000)
1:fc3d90e:     public void testMQTTWildcard() throws Exception {
1:6dacef1:         MQTT mqtt = createMQTTConnection();
1:fc3d90e:         mqtt.setClientId("");
1:fc3d90e:         mqtt.setCleanSession(true);
1:6dacef1: 
1:fc3d90e:         BlockingConnection connection = mqtt.blockingConnection();
1:fc3d90e:         connection.connect();
1:6dacef1: 
1:fc3d90e:         Topic[] topics = {new Topic(utf8("a/#"), QoS.values()[AT_MOST_ONCE])};
1:fc3d90e:         connection.subscribe(topics);
1:fc3d90e:         String payload = "Test Message";
1:fc3d90e:         String publishedTopic = "a/b/1.2.3*4>";
1:fc3d90e:         connection.publish(publishedTopic, payload.getBytes(), QoS.values()[AT_MOST_ONCE], false);
1:6dacef1: 
1:fc3d90e:         Message msg = connection.receive(1, TimeUnit.SECONDS);
1:fc3d90e:         assertEquals("Topic changed", publishedTopic, msg.getTopic());
1:6dacef1:     }
1:6dacef1: 
1:fc3d90e:     @Test(timeout = 2 *  60 * 1000)
1:6d20cba:     public void testMQTTCompositeDestinations() throws Exception {
1:6dacef1:         MQTT mqtt = createMQTTConnection();
1:6d20cba:         mqtt.setClientId("");
1:6d20cba:         mqtt.setCleanSession(true);
1:6dacef1: 
1:6d20cba:         BlockingConnection connection = mqtt.blockingConnection();
1:6d20cba:         connection.connect();
1:c530b69: 
1:6d20cba:         Topic[] topics = {new Topic(utf8("a/1"), QoS.values()[AT_MOST_ONCE]), new Topic(utf8("a/2"), QoS.values()[AT_MOST_ONCE])};
1:6d20cba:         connection.subscribe(topics);
1:c530b69: 
1:6d20cba:         String payload = "Test Message";
1:6d20cba:         String publishedTopic = "a/1,a/2";
1:6d20cba:         connection.publish(publishedTopic, payload.getBytes(), QoS.values()[AT_MOST_ONCE], false);
1:c530b69: 
1:6d20cba:         Message msg = connection.receive(1, TimeUnit.SECONDS);
1:45c0dfb:         assertNotNull(msg);
1:6d20cba:         assertEquals("a/2", msg.getTopic());
1:c530b69: 
1:6d20cba:         msg = connection.receive(1, TimeUnit.SECONDS);
1:45c0dfb:         assertNotNull(msg);
1:6d20cba:         assertEquals("a/1", msg.getTopic());
1:6d20cba: 
1:6d20cba:         msg = connection.receive(1, TimeUnit.SECONDS);
1:6d20cba:         assertNull(msg);
1:6d20cba: 
1:6dacef1:     }
1:6d20cba: 
1:6d20cba:     @Test(timeout = 2 *  60 * 1000)
1:e7e317d:     public void testMQTTPathPatterns() throws Exception {
1:c530b69:         MQTT mqtt = createMQTTConnection();
1:e7e317d:         mqtt.setClientId("");
1:a581d01:         mqtt.setCleanSession(true);
1:6d20cba: 
1:73908d6:         BlockingConnection connection = mqtt.blockingConnection();
1:ac23b01:         connection.connect();
1:6d20cba: 
1:e7e317d:         final String RETAINED = "RETAINED";
1:f4a8b11:         String[] topics = { "TopicA", "/TopicA", "/", "TopicA/", "//" };
1:e7e317d:         for (String topic : topics) {
1:e7e317d:             // test retained message
1:e7e317d:             connection.publish(topic, (RETAINED + topic).getBytes(), QoS.AT_LEAST_ONCE, true);
1:fc3d90e: 
1:f4a8b11:             connection.subscribe(new Topic[] { new Topic(topic, QoS.AT_LEAST_ONCE) });
1:0a39782:             Message msg = connection.receive(5, TimeUnit.SECONDS);
1:bcb60a4:             assertNotNull("No message for " + topic, msg);
1:e7e317d:             assertEquals(RETAINED + topic, new String(msg.getPayload()));
1:ac23b01:             msg.ack();
1:fc3d90e: 
1:e7e317d:             // test non-retained message
1:e7e317d:             connection.publish(topic, topic.getBytes(), QoS.AT_LEAST_ONCE, false);
1:4ba4aa2:             msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:67f151f:             assertNotNull(msg);
1:e7e317d:             assertEquals(topic, new String(msg.getPayload()));
1:ac23b01:             msg.ack();
1:64baf09: 
1:f4a8b11:             connection.unsubscribe(new String[] { topic });
1:c530b69:         }
1:e7e317d:         connection.disconnect();
1:64baf09: 
1:e7e317d:         // test wildcard patterns with above topics
1:f4a8b11:         String[] wildcards = { "#", "+", "+/#", "/+", "+/", "+/+", "+/+/", "+/+/+" };
1:e7e317d:         for (String wildcard : wildcards) {
1:e7e317d:             final Pattern pattern = Pattern.compile(wildcard.replaceAll("/?#", "(/?.*)*").replaceAll("\\+", "[^/]*"));
1:64baf09: 
1:45c0dfb:             connection = mqtt.blockingConnection();
1:a581d01:             connection.connect();
1:bcb60a4:             final byte[] qos = connection.subscribe(new Topic[]{new Topic(wildcard, QoS.AT_LEAST_ONCE)});
1:bcb60a4:             assertNotEquals("Subscribe failed " + wildcard, (byte)0x80, qos[0]);
1:45c0dfb: 
1:e7e317d:             // test retained messages
1:101b712:             Message msg = connection.receive(2, TimeUnit.SECONDS);
1:e7e317d:             do {
1:e7e317d:                 assertNotNull("RETAINED null " + wildcard, msg);
1:e7e317d:                 assertTrue("RETAINED prefix " + wildcard, new String(msg.getPayload()).startsWith(RETAINED));
1:f4a8b11:                 assertTrue("RETAINED matching " + wildcard + " " + msg.getTopic(), pattern.matcher(msg.getTopic()).matches());
3:a581d01:                 msg.ack();
2:67f151f:                 msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:e7e317d:             } while (msg != null);
1:45c0dfb: 
1:e7e317d:             // test non-retained message
1:e7e317d:             for (String topic : topics) {
1:e7e317d:                 connection.publish(topic, topic.getBytes(), QoS.AT_LEAST_ONCE, false);
1:c530b69:             }
1:ac23b01:             msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:e7e317d:             do {
1:e7e317d:                 assertNotNull("Non-retained Null " + wildcard, msg);
1:f4a8b11:                 assertTrue("Non-retained matching " + wildcard + " " + msg.getTopic(), pattern.matcher(msg.getTopic()).matches());
1:6c85967:                 msg.ack();
4:e7e317d:                 msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:e7e317d:             } while (msg != null);
1:45c0dfb: 
1:e7e317d:             connection.unsubscribe(new String[] { wildcard });
1:e7e317d:             connection.disconnect();
1:c530b69:         }
1:45c0dfb:     }
1:64baf09: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:0db7e69:     public void testMQTTRetainQoS() throws Exception {
1:0db7e69:         String[] topics = { "AT_MOST_ONCE", "AT_LEAST_ONCE", "EXACTLY_ONCE" };
1:0db7e69:         for (int i = 0; i < topics.length; i++) {
1:0db7e69:             final String topic = topics[i];
1:0db7e69: 
1:c530b69:             MQTT mqtt = createMQTTConnection();
1:67f151f:             mqtt.setClientId("foo");
1:bf8eb0e:             mqtt.setKeepAlive((short) 2);
1:67f151f: 
1:f4a8b11:             final int[] actualQoS = { -1 };
1:67f151f:             mqtt.setTracer(new Tracer() {
1:67f151f:                 @Override
1:67f151f:                 public void onReceive(MQTTFrame frame) {
1:0db7e69:                     // validate the QoS
1:67f151f:                     if (frame.messageType() == PUBLISH.TYPE) {
1:e7e317d:                         actualQoS[0] = frame.qos().ordinal();
1:67f151f:                     }
1:67f151f:                 }
1:0db7e69:             });
1:67f151f: 
1:0db7e69:             final BlockingConnection connection = mqtt.blockingConnection();
1:0db7e69:             connection.connect();
1:0db7e69:             connection.publish(topic, topic.getBytes(), QoS.EXACTLY_ONCE, true);
1:0a39782:             connection.subscribe(new Topic[]{new Topic(topic, QoS.valueOf(topic))});
1:7e56f34: 
1:0db7e69:             final Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:67f151f:             assertNotNull(msg);
1:0db7e69:             assertEquals(topic, new String(msg.getPayload()));
1:0db7e69:             int waitCount = 0;
1:0db7e69:             while (actualQoS[0] == -1 && waitCount < 10) {
1:67f151f:                 Thread.sleep(1000);
1:0db7e69:                 waitCount++;
1:67f151f:             }
1:0db7e69:             assertEquals(i, actualQoS[0]);
1:45c0dfb:             msg.ack();
1:0db7e69: 
1:0db7e69:             connection.unsubscribe(new String[]{topic});
1:ac23b01:             connection.disconnect();
1:67f151f:         }
1:0db7e69: 
1:45c0dfb:     }
1:0db7e69: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:7e56f34:     public void testDuplicateSubscriptions() throws Exception {
1:7e56f34:         MQTT mqtt = createMQTTConnection();
1:7e56f34:         mqtt.setClientId("foo");
1:f4a8b11:         mqtt.setKeepAlive((short) 2);
1:7e56f34: 
1:f4a8b11:         final int[] actualQoS = { -1 };
1:7e56f34:         mqtt.setTracer(new Tracer() {
1:67f151f:             @Override
1:7e56f34:             public void onReceive(MQTTFrame frame) {
1:7e56f34:                 // validate the QoS
1:7e56f34:                 if (frame.messageType() == PUBLISH.TYPE) {
1:e7e317d:                     actualQoS[0] = frame.qos().ordinal();
1:7e56f34:                 }
1:7e56f34:             }
1:7e56f34:         });
1:7e56f34: 
1:7e56f34:         final BlockingConnection connection = mqtt.blockingConnection();
1:7e56f34:         connection.connect();
1:7948d69: 
1:7e56f34:         final String RETAIN = "RETAIN";
1:7e56f34:         connection.publish("TopicA", RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
1:7e56f34: 
1:7e56f34:         QoS[] qoss = { QoS.AT_MOST_ONCE, QoS.AT_MOST_ONCE, QoS.AT_LEAST_ONCE, QoS.EXACTLY_ONCE };
1:7e56f34:         for (QoS qos : qoss) {
1:bcb60a4:             connection.subscribe(new Topic[]{new Topic("TopicA", qos)});
1:7e56f34: 
1:7e56f34:             final Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:bcb60a4:             assertNotNull("No message for " + qos, msg);
1:7e56f34:             assertEquals(RETAIN, new String(msg.getPayload()));
1:45c0dfb:             msg.ack();
1:7e56f34:             int waitCount = 0;
1:7e56f34:             while (actualQoS[0] == -1 && waitCount < 10) {
1:7e56f34:                 Thread.sleep(1000);
1:7e56f34:                 waitCount++;
1:7e56f34:             }
1:7e56f34:             assertEquals(qos.ordinal(), actualQoS[0]);
1:a581d01:             actualQoS[0] = -1;
1:0db7e69:         }
1:64baf09: 
1:f4a8b11:         connection.unsubscribe(new String[] { "TopicA" });
1:a581d01:         connection.disconnect();
1:64baf09: 
1:0db7e69:     }
1:64baf09: 
1:413e484:     @Test(timeout = 120 * 1000)
1:a581d01:     public void testRetainedMessage() throws Exception {
1:47e954d:         doTestRetainedMessages("TopicA");
1:0db7e69:     }
1:64baf09: 
1:6c85967:     @Test(timeout = 120 * 1000)
1:413e484:     public void testRetainedMessageOnVirtualTopics() throws Exception {
1:47e954d:         doTestRetainedMessages("VirtualTopic/TopicA");
1:47e954d:     }
1:47e954d: 
1:47e954d:     public void doTestRetainedMessages(String topicName) throws Exception {
1:413e484:         MQTT mqtt = createMQTTConnection();
1:413e484:         mqtt.setKeepAlive((short) 60);
1:413e484: 
1:413e484:         final String RETAIN = "RETAIN";
1:47e954d:         final String TOPICA = topicName;
1:413e484: 
1:413e484:         final String[] clientIds = { null, "foo", "durable" };
1:413e484:         for (String clientId : clientIds) {
1:47e954d:             boolean cleanSession = !"durable".equals(clientId);
1:47e954d:             LOG.info("Testing now with Client ID: {} clean: {}", clientId, cleanSession);
1:413e484: 
1:413e484:             mqtt.setClientId(clientId);
1:47e954d:             mqtt.setCleanSession(cleanSession);
1:413e484: 
1:413e484:             BlockingConnection connection = mqtt.blockingConnection();
1:413e484:             connection.connect();
1:413e484: 
1:413e484:             // set retained message and check
1:413e484:             connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
1:413e484:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
2:67f151f:             Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:413e484:             assertNotNull("No retained message for " + clientId, msg);
1:413e484:             assertEquals(RETAIN, new String(msg.getPayload()));
1:413e484:             msg.ack();
1:413e484:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1:413e484: 
1:413e484:             // test duplicate subscription
1:413e484:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
1:413e484:             msg = connection.receive(15000, TimeUnit.MILLISECONDS);
1:413e484:             assertNotNull("No retained message on duplicate subscription for " + clientId, msg);
1:413e484:             assertEquals(RETAIN, new String(msg.getPayload()));
1:413e484:             msg.ack();
1:413e484:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1:413e484:             connection.unsubscribe(new String[]{TOPICA});
1:413e484: 
1:413e484:             // clear retained message and check that we don't receive it
1:413e484:             connection.publish(TOPICA, "".getBytes(), QoS.AT_MOST_ONCE, true);
1:413e484:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
1:413e484:             msg = connection.receive(500, TimeUnit.MILLISECONDS);
1:413e484:             assertNull("Retained message not cleared for " + clientId, msg);
1:413e484:             connection.unsubscribe(new String[]{TOPICA});
1:413e484: 
1:413e484:             // set retained message again and check
1:413e484:             connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
1:47e954d:             LOG.info("Performing first subscription");
1:413e484:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
1:67f151f:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:413e484:             assertNotNull("No reset retained message for " + clientId, msg);
1:413e484:             assertEquals(RETAIN, new String(msg.getPayload()));
1:413e484:             msg.ack();
1:413e484:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1:413e484: 
1:413e484:             // re-connect and check
1:413e484:             connection.disconnect();
1:413e484:             connection = mqtt.blockingConnection();
1:413e484:             connection.connect();
1:47e954d:             LOG.info("Performing second subscription");
1:413e484:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
1:67f151f:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:413e484:             assertNotNull("No reset retained message for " + clientId, msg);
1:413e484:             assertEquals(RETAIN, new String(msg.getPayload()));
1:413e484:             msg.ack();
1:413e484:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1:413e484: 
1:413e484:             LOG.info("Test now unsubscribing from: {} for the last time", TOPICA);
1:413e484:             connection.unsubscribe(new String[]{TOPICA});
1:413e484:             connection.disconnect();
1:413e484:         }
1:413e484:     }
1:413e484: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:67f151f:     public void testUniqueMessageIds() throws Exception {
1:0db7e69:         MQTT mqtt = createMQTTConnection();
1:0db7e69:         mqtt.setClientId("foo");
1:f4a8b11:         mqtt.setKeepAlive((short) 2);
1:67f151f:         mqtt.setCleanSession(true);
1:64baf09: 
1:67f151f:         final List<PUBLISH> publishList = new ArrayList<PUBLISH>();
1:0db7e69:         mqtt.setTracer(new Tracer() {
1:6dacef1:             @Override
1:0db7e69:             public void onReceive(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client received:\n" + frame);
1:0db7e69:                 if (frame.messageType() == PUBLISH.TYPE) {
1:67f151f:                     PUBLISH publish = new PUBLISH();
1:c530b69:                     try {
1:67f151f:                         publish.decode(frame);
1:67f151f:                     } catch (ProtocolException e) {
1:67f151f:                         fail("Error decoding publish " + e.getMessage());
1:45c0dfb:                     }
1:67f151f:                     publishList.add(publish);
1:45c0dfb:                 }
1:7e56f34:             }
1:45c0dfb: 
1:6dacef1:             @Override
1:67f151f:             public void onSend(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client sent:\n" + frame);
1:67f151f:             }
1:67f151f:         });
1:67f151f: 
1:67f151f:         final BlockingConnection connection = mqtt.blockingConnection();
1:67f151f:         connection.connect();
1:67f151f: 
2:67f151f:         // create overlapping subscriptions with different QoSs
1:67f151f:         QoS[] qoss = { QoS.AT_MOST_ONCE, QoS.AT_LEAST_ONCE, QoS.EXACTLY_ONCE };
1:67f151f:         final String TOPIC = "TopicA/";
1:67f151f: 
1:67f151f:         // publish retained message
1:67f151f:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, true);
1:67f151f: 
1:f4a8b11:         String[] subs = { TOPIC, "TopicA/#", "TopicA/+" };
1:67f151f:         for (int i = 0; i < qoss.length; i++) {
1:f4a8b11:             connection.subscribe(new Topic[] { new Topic(subs[i], qoss[i]) });
1:67f151f:         }
1:67f151f: 
1:67f151f:         // publish non-retained message
1:67f151f:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:67f151f:         int received = 0;
1:67f151f: 
1:101b712:         Message msg = connection.receive(2000, TimeUnit.MILLISECONDS);
1:67f151f:         do {
1:67f151f:             assertNotNull(msg);
2:67f151f:             assertEquals(TOPIC, new String(msg.getPayload()));
1:67f151f:             msg.ack();
1:67f151f:             int waitCount = 0;
1:67f151f:             while (publishList.size() <= received && waitCount < 10) {
1:67f151f:                 Thread.sleep(1000);
1:67f151f:                 waitCount++;
1:67f151f:             }
1:101b712:             msg = connection.receive(2000, TimeUnit.MILLISECONDS);
1:67f151f:         } while (msg != null && received++ < subs.length * 2);
1:67f151f:         assertEquals("Unexpected number of messages", subs.length * 2, received + 1);
1:67f151f: 
1:f4a8b11:         // make sure we received distinct ids for QoS != AT_MOST_ONCE, and 0 for
1:f4a8b11:         // AT_MOST_ONCE
2:67f151f:         for (int i = 0; i < publishList.size(); i++) {
1:bf8eb0e:             for (int j = i + 1; j < publishList.size(); j++) {
1:67f151f:                 final PUBLISH publish1 = publishList.get(i);
1:67f151f:                 final PUBLISH publish2 = publishList.get(j);
1:67f151f:                 boolean qos0 = false;
1:67f151f:                 if (publish1.qos() == QoS.AT_MOST_ONCE) {
1:67f151f:                     qos0 = true;
1:67f151f:                     assertEquals(0, publish1.messageId());
1:67f151f:                 }
1:67f151f:                 if (publish2.qos() == QoS.AT_MOST_ONCE) {
1:67f151f:                     qos0 = true;
1:67f151f:                     assertEquals(0, publish2.messageId());
1:67f151f:                 }
1:67f151f:                 if (!qos0) {
1:67f151f:                     assertNotEquals(publish1.messageId(), publish2.messageId());
1:67f151f:                 }
1:67f151f:             }
1:67f151f:         }
1:67f151f: 
3:67f151f:         connection.unsubscribe(subs);
1:67f151f:         connection.disconnect();
1:67f151f:     }
1:67f151f: 
1:bf8eb0e:     @Test(timeout = 60 * 1000)
1:67f151f:     public void testResendMessageId() throws Exception {
1:bf8eb0e:         final MQTT mqtt = createMQTTConnection("resend", false);
1:afddc1a:         mqtt.setKeepAlive((short) 5);
1:67f151f: 
1:67f151f:         final List<PUBLISH> publishList = new ArrayList<PUBLISH>();
1:67f151f:         mqtt.setTracer(new Tracer() {
1:67f151f:             @Override
1:67f151f:             public void onReceive(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client received:\n" + frame);
1:67f151f:                 if (frame.messageType() == PUBLISH.TYPE) {
1:67f151f:                     PUBLISH publish = new PUBLISH();
1:67f151f:                     try {
1:67f151f:                         publish.decode(frame);
1:67f151f:                     } catch (ProtocolException e) {
1:67f151f:                         fail("Error decoding publish " + e.getMessage());
1:67f151f:                     }
1:67f151f:                     publishList.add(publish);
1:67f151f:                 }
1:67f151f:             }
1:67f151f: 
1:67f151f:             @Override
1:67f151f:             public void onSend(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client sent:\n" + frame);
1:67f151f:             }
1:67f151f:         });
1:67f151f: 
1:45c0dfb:         BlockingConnection connection = mqtt.blockingConnection();
1:67f151f:         connection.connect();
1:67f151f:         final String TOPIC = "TopicA/";
1:f4a8b11:         final String[] topics = new String[] { TOPIC, "TopicA/+" };
1:f4a8b11:         connection.subscribe(new Topic[] { new Topic(topics[0], QoS.AT_LEAST_ONCE), new Topic(topics[1], QoS.EXACTLY_ONCE) });
1:67f151f: 
1:67f151f:         // publish non-retained message
1:67f151f:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:67f151f: 
1:45c0dfb:         Wait.waitFor(new Wait.Condition() {
1:45c0dfb:             @Override
1:6dacef1:             public boolean isSatisified() throws Exception {
1:45c0dfb:                 return publishList.size() == 2;
1:67f151f:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(100));
1:45c0dfb:         assertEquals(2, publishList.size());
1:67f151f: 
1:45c0dfb:         connection.disconnect();
1:67f151f: 
1:45c0dfb:         connection = mqtt.blockingConnection();
1:45c0dfb:         connection.connect();
1:67f151f: 
1:45c0dfb:         Wait.waitFor(new Wait.Condition() {
1:6dacef1:             @Override
1:45c0dfb:             public boolean isSatisified() throws Exception {
1:45c0dfb:                 return publishList.size() == 4;
1:6dacef1:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(100));
1:45c0dfb:         assertEquals(4, publishList.size());
1:67f151f: 
1:67f151f:         // make sure we received duplicate message ids
1:f4a8b11:         assertTrue(publishList.get(0).messageId() == publishList.get(2).messageId() || publishList.get(0).messageId() == publishList.get(3).messageId());
1:f4a8b11:         assertTrue(publishList.get(1).messageId() == publishList.get(3).messageId() || publishList.get(1).messageId() == publishList.get(2).messageId());
1:45c0dfb:         assertTrue(publishList.get(2).dup() && publishList.get(3).dup());
1:bf8eb0e: 
1:45c0dfb:         connection.unsubscribe(topics);
1:45c0dfb:         connection.disconnect();
1:67f151f:     }
1:67f151f: 
1:45c0dfb:     @Test(timeout = 90 * 1000)
1:45c0dfb:     public void testPacketIdGeneratorNonCleanSession() throws Exception {
1:45c0dfb:         final MQTT mqtt = createMQTTConnection("nonclean-packetid", false);
1:45c0dfb:         mqtt.setKeepAlive((short) 15);
1:6dacef1: 
1:45c0dfb:         final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<Short, PUBLISH>();
1:45c0dfb:         mqtt.setTracer(new Tracer() {
1:45c0dfb:             @Override
1:45c0dfb:             public void onReceive(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client received:\n" + frame);
1:45c0dfb:                 if (frame.messageType() == PUBLISH.TYPE) {
1:45c0dfb:                     PUBLISH publish = new PUBLISH();
1:45c0dfb:                     try {
1:45c0dfb:                         publish.decode(frame);
1:101b712:                         LOG.debug("PUBLISH " + publish);
1:45c0dfb:                     } catch (ProtocolException e) {
1:45c0dfb:                         fail("Error decoding publish " + e.getMessage());
1:67f151f:                     }
1:45c0dfb:                     if (publishMap.get(publish.messageId()) != null) {
1:45c0dfb:                         assertTrue(publish.dup());
1:67f151f:                     }
1:45c0dfb:                     publishMap.put(publish.messageId(), publish);
1:67f151f:                 }
1:45c0dfb:             }
1:6dacef1: 
1:45c0dfb:             @Override
1:45c0dfb:             public void onSend(MQTTFrame frame) {
1:101b712:                 LOG.debug("Client sent:\n" + frame);
1:45c0dfb:             }
1:45c0dfb:         });
1:45c0dfb: 
1:bf8eb0e:         BlockingConnection connection = mqtt.blockingConnection();
1:45c0dfb:         connection.connect();
1:45c0dfb:         final String TOPIC = "TopicA/";
1:f4a8b11:         connection.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
1:45c0dfb: 
1:45c0dfb:         // publish non-retained messages
1:45c0dfb:         final int TOTAL_MESSAGES = 10;
1:45c0dfb:         for (int i = 0; i < TOTAL_MESSAGES; i++) {
1:45c0dfb:             connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:45c0dfb:         }
1:45c0dfb: 
1:45c0dfb:         // receive half the messages in this session
1:45c0dfb:         for (int i = 0; i < TOTAL_MESSAGES / 2; i++) {
1:45c0dfb:             final Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:67f151f:             assertNotNull(msg);
1:67f151f:             assertEquals(TOPIC, new String(msg.getPayload()));
1:67f151f:             msg.ack();
1:45c0dfb:         }
1:45c0dfb: 
1:45c0dfb:         connection.disconnect();
1:45c0dfb:         // resume session
1:bf8eb0e:         connection = mqtt.blockingConnection();
1:45c0dfb:         connection.connect();
1:45c0dfb:         // receive rest of the messages
1:45c0dfb:         Message msg = null;
1:45c0dfb:         do {
1:45c0dfb:             msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:45c0dfb:             if (msg != null) {
1:67f151f:                 assertEquals(TOPIC, new String(msg.getPayload()));
1:67f151f:                 msg.ack();
1:45c0dfb:             }
1:45c0dfb:         } while (msg != null);
1:45c0dfb: 
1:45c0dfb:         // make sure we received all message ids
1:45c0dfb:         for (short id = 1; id <= TOTAL_MESSAGES; id++) {
1:45c0dfb:             assertNotNull("No message for id " + id, publishMap.get(id));
1:45c0dfb:         }
1:45c0dfb: 
1:9c67f0d:         connection.unsubscribe(new String[] { TOPIC });
1:7e56f34:         connection.disconnect();
1:45c0dfb:     }
1:45c0dfb: 
1:45c0dfb:     @Test(timeout = 90 * 1000)
1:45c0dfb:     public void testPacketIdGeneratorCleanSession() throws Exception {
1:f4a8b11:         final String[] cleanClientIds = new String[] { "", "clean-packetid", null };
1:45c0dfb:         final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<Short, PUBLISH>();
1:45c0dfb:         MQTT[] mqtts = new MQTT[cleanClientIds.length];
1:45c0dfb:         for (int i = 0; i < cleanClientIds.length; i++) {
1:45c0dfb:             mqtts[i] = createMQTTConnection("", true);
1:45c0dfb:             mqtts[i].setKeepAlive((short) 15);
1:45c0dfb: 
1:45c0dfb:             mqtts[i].setTracer(new Tracer() {
1:45c0dfb:                 @Override
1:45c0dfb:                 public void onReceive(MQTTFrame frame) {
1:101b712:                     LOG.debug("Client received:\n" + frame);
1:45c0dfb:                     if (frame.messageType() == PUBLISH.TYPE) {
1:45c0dfb:                         PUBLISH publish = new PUBLISH();
1:45c0dfb:                         try {
1:45c0dfb:                             publish.decode(frame);
2:45c0dfb:                             LOG.info("PUBLISH " + publish);
1:45c0dfb:                         } catch (ProtocolException e) {
1:45c0dfb:                             fail("Error decoding publish " + e.getMessage());
1:45c0dfb:                         }
1:45c0dfb:                         if (publishMap.get(publish.messageId()) != null) {
1:45c0dfb:                             assertTrue(publish.dup());
1:45c0dfb:                         }
1:45c0dfb:                         publishMap.put(publish.messageId(), publish);
1:45c0dfb:                     }
1:45c0dfb:                 }
1:45c0dfb: 
1:45c0dfb:                 @Override
1:45c0dfb:                 public void onSend(MQTTFrame frame) {
1:101b712:                     LOG.debug("Client sent:\n" + frame);
1:45c0dfb:                 }
1:45c0dfb:             });
1:45c0dfb:         }
1:45c0dfb: 
1:45c0dfb:         final Random random = new Random();
1:45c0dfb:         for (short i = 0; i < 10; i++) {
1:45c0dfb:             BlockingConnection connection = mqtts[random.nextInt(cleanClientIds.length)].blockingConnection();
1:45c0dfb:             connection.connect();
1:45c0dfb:             final String TOPIC = "TopicA/";
1:f4a8b11:             connection.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
1:45c0dfb: 
1:45c0dfb:             // publish non-retained message
1:45c0dfb:             connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:bf8eb0e:             Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:67f151f:             assertNotNull(msg);
1:67f151f:             assertEquals(TOPIC, new String(msg.getPayload()));
1:45c0dfb:             msg.ack();
1:45c0dfb: 
1:45c0dfb:             assertEquals(1, publishMap.size());
1:45c0dfb:             final short id = (short) (i + 1);
1:45c0dfb:             assertNotNull("No message for id " + id, publishMap.get(id));
1:45c0dfb:             publishMap.clear();
1:45c0dfb: 
1:bf8eb0e:             connection.disconnect();
1:45c0dfb:         }
1:45c0dfb:     }
1:45c0dfb: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bf8eb0e:     public void testClientConnectionFailure() throws Exception {
1:bf8eb0e:         MQTT mqtt = createMQTTConnection("reconnect", false);
1:67f151f:         final BlockingConnection connection = mqtt.blockingConnection();
1:bf8eb0e:         connection.connect();
1:7948d69:         Wait.waitFor(new Wait.Condition() {
1:0db7e69:             @Override
1:45c0dfb:             public boolean isSatisified() throws Exception {
1:9c67f0d:                 return connection.isConnected();
1:45c0dfb:             }
1:7948d69:         });
1:bf8eb0e: 
1:bf8eb0e:         final String TOPIC = "TopicA";
1:f4a8b11:         final byte[] qos = connection.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
1:bf8eb0e:         assertEquals(QoS.EXACTLY_ONCE.ordinal(), qos[0]);
1:bf8eb0e:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:bf8eb0e:         // kill transport
1:bf8eb0e:         connection.kill();
1:bf8eb0e: 
1:9c67f0d:         final BlockingConnection newConnection = mqtt.blockingConnection();
1:9c67f0d:         newConnection.connect();
1:101b712:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:9c67f0d:             @Override
1:9c67f0d:             public boolean isSatisified() throws Exception {
1:9c67f0d:                 return newConnection.isConnected();
1:bf8eb0e:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
1:bf8eb0e: 
1:bf8eb0e:         assertEquals(QoS.EXACTLY_ONCE.ordinal(), qos[0]);
1:9c67f0d:         Message msg = newConnection.receive(1000, TimeUnit.MILLISECONDS);
1:bf8eb0e:         assertNotNull(msg);
1:bf8eb0e:         assertEquals(TOPIC, new String(msg.getPayload()));
1:bf8eb0e:         msg.ack();
1:9c67f0d:         newConnection.disconnect();
1:7e56f34:     }
1:bf8eb0e: 
1:bf8eb0e:     @Test(timeout = 60 * 1000)
1:7948d69:     public void testNoClientId() throws Exception {
1:7948d69:         final MQTT mqtt = createMQTTConnection("", true);
1:7948d69:         final BlockingConnection connection = mqtt.blockingConnection();
1:bf8eb0e:         connection.connect();
1:101b712:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:7948d69:             @Override
1:7948d69:             public boolean isSatisified() throws Exception {
1:7948d69:                 return connection.isConnected();
1:7e56f34:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
1:bf8eb0e: 
2:7948d69:         connection.subscribe(new Topic[]{new Topic("TopicA", QoS.AT_LEAST_ONCE)});
1:7948d69:         connection.publish("TopicA", "test".getBytes(), QoS.AT_LEAST_ONCE, true);
1:7948d69:         Message message = connection.receive(3, TimeUnit.SECONDS);
1:7948d69:         assertNotNull(message);
1:7948d69:         //TODO fix audit problem for retained messages
1:101b712:         //Thread.sleep(2000);
1:101b712:         //connection.subscribe(new Topic[]{new Topic("TopicA", QoS.AT_LEAST_ONCE)});
1:7948d69:         //message = connection.receive(3, TimeUnit.SECONDS);
1:7948d69:         //assertNotNull(message);
1:0db7e69:     }
1:45c0dfb: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bf8eb0e:     public void testCleanSession() throws Exception {
1:bf8eb0e:         final String CLIENTID = "cleansession";
1:bf8eb0e:         final MQTT mqttNotClean = createMQTTConnection(CLIENTID, false);
1:bf8eb0e:         BlockingConnection notClean = mqttNotClean.blockingConnection();
1:bf8eb0e:         final String TOPIC = "TopicA";
1:bf8eb0e:         notClean.connect();
1:f4a8b11:         notClean.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
1:bf8eb0e:         notClean.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:bf8eb0e:         notClean.disconnect();
1:bf8eb0e: 
1:bf8eb0e:         // MUST receive message from previous not clean session
1:bf8eb0e:         notClean = mqttNotClean.blockingConnection();
1:bf8eb0e:         notClean.connect();
1:bf8eb0e:         Message msg = notClean.receive(10000, TimeUnit.MILLISECONDS);
1:bf8eb0e:         assertNotNull(msg);
1:bf8eb0e:         assertEquals(TOPIC, new String(msg.getPayload()));
1:bf8eb0e:         msg.ack();
1:bf8eb0e:         notClean.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:bf8eb0e:         notClean.disconnect();
1:bf8eb0e: 
1:bf8eb0e:         // MUST NOT receive message from previous not clean session
1:bf8eb0e:         final MQTT mqttClean = createMQTTConnection(CLIENTID, true);
1:bf8eb0e:         final BlockingConnection clean = mqttClean.blockingConnection();
1:bf8eb0e:         clean.connect();
1:101b712:         msg = clean.receive(2000, TimeUnit.MILLISECONDS);
1:bf8eb0e:         assertNull(msg);
1:f4a8b11:         clean.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
1:bf8eb0e:         clean.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:bf8eb0e:         clean.disconnect();
1:bf8eb0e: 
1:bf8eb0e:         // MUST NOT receive message from previous clean session
1:bf8eb0e:         notClean = mqttNotClean.blockingConnection();
1:bf8eb0e:         notClean.connect();
1:bf8eb0e:         msg = notClean.receive(1000, TimeUnit.MILLISECONDS);
1:bf8eb0e:         assertNull(msg);
1:bf8eb0e:         notClean.disconnect();
1:bf8eb0e:     }
1:bf8eb0e: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:bc9751a:     public void testSendMQTTReceiveJMS() throws Exception {
1:413e484:         doTestSendMQTTReceiveJMS("foo.*");
1:413e484:     }
1:413e484: 
1:413e484:     public void doTestSendMQTTReceiveJMS(String destinationName) throws Exception {
1:bc9751a:         final MQTTClientProvider provider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(provider);
1:45c0dfb: 
1:a581d01:         // send retained message
1:a581d01:         final String RETAINED = "RETAINED";
1:a581d01:         provider.publish("foo/bah", RETAINED.getBytes(), AT_LEAST_ONCE, true);
1:7e56f34: 
1:fb569e3:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
1:a581d01:         // MUST set to true to receive retained messages
1:a581d01:         activeMQConnection.setUseRetroactiveConsumer(true);
1:bc9751a:         activeMQConnection.start();
1:bc9751a:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:413e484:         javax.jms.Topic jmsTopic = s.createTopic(destinationName);
1:bc9751a:         MessageConsumer consumer = s.createConsumer(jmsTopic);
1:7e56f34: 
1:a581d01:         // check whether we received retained message on JMS subscribe
1:a581d01:         ActiveMQMessage message = (ActiveMQMessage) consumer.receive(5000);
1:a581d01:         assertNotNull("Should get retained message", message);
1:a581d01:         ByteSequence bs = message.getContent();
1:a581d01:         assertEquals(RETAINED, new String(bs.data, bs.offset, bs.length));
1:a581d01:         assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));
1:0db7e69: 
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "Test Message: " + i;
1:bc9751a:             provider.publish("foo/bah", payload.getBytes(), AT_LEAST_ONCE);
1:a581d01:             message = (ActiveMQMessage) consumer.receive(5000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:a581d01:             bs = message.getContent();
1:bc9751a:             assertEquals(payload, new String(bs.data, bs.offset, bs.length));
1:0db7e69:         }
1:0db7e69: 
1:bc9751a:         activeMQConnection.close();
1:bc9751a:         provider.disconnect();
1:6d20cba:     }
1:7948d69: 
1:d4a376d:     @Test(timeout = 2 * 60 * 1000)
1:bc9751a:     public void testSendJMSReceiveMQTT() throws Exception {
1:413e484:         doTestSendJMSReceiveMQTT("foo.far");
1:413e484:     }
1:413e484: 
1:413e484:     public void doTestSendJMSReceiveMQTT(String destinationName) throws Exception {
1:bc9751a:         final MQTTClientProvider provider = getMQTTClientProvider();
1:bc9751a:         initializeConnection(provider);
1:64baf09: 
1:fb569e3:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
1:a581d01:         activeMQConnection.setUseRetroactiveConsumer(true);
1:bc9751a:         activeMQConnection.start();
1:bc9751a:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:413e484:         javax.jms.Topic jmsTopic = s.createTopic(destinationName);
1:bc9751a:         MessageProducer producer = s.createProducer(jmsTopic);
1:ac23b01: 
1:a581d01:         // send retained message from JMS
1:a581d01:         final String RETAINED = "RETAINED";
1:a581d01:         TextMessage sendMessage = s.createTextMessage(RETAINED);
1:a581d01:         // mark the message to be retained
1:a581d01:         sendMessage.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);
1:a581d01:         // MQTT QoS can be set using MQTTProtocolConverter.QOS_PROPERTY_NAME property
1:a581d01:         sendMessage.setIntProperty(MQTTProtocolConverter.QOS_PROPERTY_NAME, 0);
1:a581d01:         producer.send(sendMessage);
1:ac23b01: 
1:f4a8b11:         provider.subscribe("foo/+", AT_MOST_ONCE);
1:a581d01:         byte[] message = provider.receive(10000);
1:a581d01:         assertNotNull("Should get retained message", message);
1:a581d01:         assertEquals(RETAINED, new String(message));
1:ac23b01: 
1:fb569e3:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:bc9751a:             String payload = "This is Test Message: " + i;
1:a581d01:             sendMessage = s.createTextMessage(payload);
1:bc9751a:             producer.send(sendMessage);
1:a581d01:             message = provider.receive(5000);
1:bc9751a:             assertNotNull("Should get a message", message);
1:ac23b01: 
1:bc9751a:             assertEquals(payload, new String(message));
1:7948d69:         }
1:bc9751a:         provider.disconnect();
1:bc9751a:         activeMQConnection.close();
1:fc3d90e:     }
1:a581d01: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:8a5f160:     public void testPingKeepsInactivityMonitorAlive() throws Exception {
1:67f151f:         MQTT mqtt = createMQTTConnection();
1:67f151f:         mqtt.setClientId("foo");
1:f4a8b11:         mqtt.setKeepAlive((short) 2);
1:9c67f0d:         final BlockingConnection connection = mqtt.blockingConnection();
1:bcb60a4:         connection.connect();
1:a581d01: 
1:d3571a6:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
1:a581d01: 
1:9c67f0d:             @Override
1:9c67f0d:             public boolean isSatisified() throws Exception {
1:d3571a6:                 return connection.isConnected();
1:9c67f0d:             }
1:b11fc8f:         }));
1:a581d01: 
1:45c0dfb:         connection.disconnect();
1:9c67f0d:     }
1:bcb60a4: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:f4a8b11:     public void testTurnOffInactivityMonitor() throws Exception {
1:fb569e3:         stopBroker();
1:fb569e3:         protocolConfig = "transport.useInactivityMonitor=false";
1:fb569e3:         startBroker();
1:fb569e3: 
1:6d20cba:         MQTT mqtt = createMQTTConnection();
1:72e484c:         mqtt.setClientId("foo3");
1:f4a8b11:         mqtt.setKeepAlive((short) 2);
1:ac23b01:         final BlockingConnection connection = mqtt.blockingConnection();
1:e7e317d:         connection.connect();
1:e8c5a9f: 
1:d3571a6:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
1:73908d6: 
1:bcb60a4:             @Override
2:cfc6917:             public boolean isSatisified() throws Exception {
1:d3571a6:                 return connection.isConnected();
1:4ba4aa2:             }
1:b11fc8f:         }));
1:73908d6: 
1:fb569e3:         connection.disconnect();
1:ac23b01:     }
1:bcb60a4: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:73908d6:     public void testPublishDollarTopics() throws Exception {
1:fc3d90e:         MQTT mqtt = createMQTTConnection();
1:73908d6:         final String clientId = "publishDollar";
1:73908d6:         mqtt.setClientId(clientId);
1:ac23b01:         mqtt.setKeepAlive((short) 2);
1:e8c5a9f:         BlockingConnection connection = mqtt.blockingConnection();
1:73908d6:         connection.connect();
1:73908d6: 
1:73908d6:         final String DOLLAR_TOPIC = "$TopicA";
1:73908d6:         connection.subscribe(new Topic[] { new Topic(DOLLAR_TOPIC, QoS.EXACTLY_ONCE)});
1:73908d6:         connection.publish(DOLLAR_TOPIC, DOLLAR_TOPIC.getBytes(), QoS.EXACTLY_ONCE, true);
1:73908d6: 
1:101b712:         Message message = connection.receive(3, TimeUnit.SECONDS);
1:73908d6:         assertNull("Publish enabled for $ Topics by default", message);
1:101b712: 
1:0db7e69:         connection.disconnect();
1:73908d6: 
1:fb569e3:         stopBroker();
1:73908d6:         protocolConfig = "transport.publishDollarTopics=true";
1:fb569e3:         startBroker();
1:73908d6: 
1:73908d6:         mqtt = createMQTTConnection();
1:73908d6:         mqtt.setClientId(clientId);
2:73908d6:         mqtt.setKeepAlive((short) 2);
1:e8c5a9f:         connection = mqtt.blockingConnection();
1:73908d6:         connection.connect();
1:73908d6: 
1:73908d6:         connection.subscribe(new Topic[] { new Topic(DOLLAR_TOPIC, QoS.EXACTLY_ONCE)});
1:73908d6:         connection.publish(DOLLAR_TOPIC, DOLLAR_TOPIC.getBytes(), QoS.EXACTLY_ONCE, true);
1:e7e317d: 
1:73908d6:         message = connection.receive(10, TimeUnit.SECONDS);
1:73908d6:         assertNotNull(message);
1:73908d6:         message.ack();
1:73908d6:         assertEquals("Message body", DOLLAR_TOPIC, new String(message.getPayload()));
1:73908d6: 
1:73908d6:         connection.disconnect();
1:73908d6:     }
1:73908d6: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:1b38b27:     public void testPublishWildcard31() throws Exception {
1:1b38b27:         testPublishWildcard("3.1");
1:1b38b27:     }
1:1b38b27: 
1:1b38b27:     @Test(timeout = 60 * 1000)
1:1b38b27:     public void testPublishWildcard311() throws Exception {
1:1b38b27:         testPublishWildcard("3.1.1");
1:1b38b27:     }
1:1b38b27: 
1:1b38b27:     private void testPublishWildcard(String version) throws Exception {
1:1b38b27:         MQTT mqttPub = createMQTTConnection("MQTTPub-Client", true);
1:1b38b27:         mqttPub.setVersion(version);
1:1b38b27:         BlockingConnection blockingConnection = mqttPub.blockingConnection();
1:1b38b27:         blockingConnection.connect();
1:1b38b27:         String payload = "Test Message";
1:1b38b27:         try {
1:1b38b27:             blockingConnection.publish("foo/#", payload.getBytes(), QoS.AT_LEAST_ONCE, false);
1:1b38b27:             fail("Should not be able to publish with wildcard in topic.");
1:1b38b27:         } catch (Exception ex) {
1:1b38b27:             LOG.info("Exception expected on publish with wildcard in topic name");
1:1b38b27:         }
1:1b38b27:         try {
1:1b38b27:             blockingConnection.publish("foo/+", payload.getBytes(), QoS.AT_LEAST_ONCE, false);
1:1b38b27:             fail("Should not be able to publish with wildcard in topic.");
1:1b38b27:         } catch (Exception ex) {
1:1b38b27:             LOG.info("Exception expected on publish with wildcard in topic name");
1:1b38b27:         }
1:1b38b27:         blockingConnection.disconnect();
1:1b38b27:     }
1:1b38b27: 
1:1b38b27:     @Test(timeout = 60 * 1000)
1:e8c5a9f:     public void testDuplicateClientId() throws Exception {
1:e8c5a9f:         // test link stealing enabled by default
1:e8c5a9f:         final String clientId = "duplicateClient";
1:e8c5a9f:         MQTT mqtt = createMQTTConnection(clientId, false);
1:e8c5a9f:         mqtt.setKeepAlive((short) 2);
1:b11fc8f:         final BlockingConnection connection = mqtt.blockingConnection();
1:e8c5a9f:         connection.connect();
1:e8c5a9f:         final String TOPICA = "TopicA";
3:e8c5a9f:         connection.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:e8c5a9f: 
1:e8c5a9f:         MQTT mqtt1 = createMQTTConnection(clientId, false);
1:e8c5a9f:         mqtt1.setKeepAlive((short) 2);
1:b11fc8f:         final BlockingConnection connection1 = mqtt1.blockingConnection();
2:e8c5a9f:         connection1.connect();
1:e8c5a9f: 
1:b11fc8f:         assertTrue("Duplicate client disconnected", Wait.waitFor(new Wait.Condition() {
1:b11fc8f:             @Override
1:b11fc8f:             public boolean isSatisified() throws Exception {
1:b11fc8f:                 return connection1.isConnected();
1:b11fc8f:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
1:b11fc8f: 
1:b11fc8f:         assertTrue("Old client still connected", Wait.waitFor(new Wait.Condition() {
1:b11fc8f:             @Override
1:b11fc8f:             public boolean isSatisified() throws Exception {
1:b11fc8f:                 return !connection.isConnected();
1:b11fc8f:             }
1:101b712:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
1:b11fc8f: 
1:e8c5a9f:         connection1.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:e8c5a9f:         connection1.disconnect();
1:e8c5a9f: 
1:e8c5a9f:         // disable link stealing
2:e8c5a9f:         stopBroker();
1:e8c5a9f:         protocolConfig = "allowLinkStealing=false";
2:e8c5a9f:         startBroker();
1:e8c5a9f: 
1:e8c5a9f:         mqtt = createMQTTConnection(clientId, false);
1:e8c5a9f:         mqtt.setKeepAlive((short) 2);
1:b11fc8f:         final BlockingConnection connection2 = mqtt.blockingConnection();
1:b11fc8f:         connection2.connect();
1:b11fc8f:         connection2.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:e8c5a9f: 
1:e8c5a9f:         mqtt1 = createMQTTConnection(clientId, false);
1:e8c5a9f:         mqtt1.setKeepAlive((short) 2);
1:b11fc8f:         final BlockingConnection connection3 = mqtt1.blockingConnection();
1:e8c5a9f:         try {
1:b11fc8f:             connection3.connect();
1:e8c5a9f:             fail("Duplicate client connected");
1:e8c5a9f:         } catch (Exception e) {
1:e8c5a9f:             // ignore
1:e8c5a9f:         }
1:e8c5a9f: 
1:b11fc8f:         assertTrue("Old client disconnected", connection2.isConnected());
1:b11fc8f:         connection2.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:b11fc8f:         connection2.disconnect();
1:e8c5a9f:     }
1:62c20eb: 
1:62c20eb:     @Test(timeout = 60 * 1000)
1:62c20eb:     public void testRepeatedLinkStealing() throws Exception {
1:62c20eb:         final String clientId = "duplicateClient";
1:62c20eb:         final AtomicReference<BlockingConnection> oldConnection = new AtomicReference<BlockingConnection>();
1:62c20eb:         final String TOPICA = "TopicA";
1:62c20eb: 
1:62c20eb:         for (int i = 1; i <= 10; ++i) {
1:62c20eb: 
1:62c20eb:             LOG.info("Creating MQTT Connection {}", i);
1:62c20eb: 
1:62c20eb:             MQTT mqtt = createMQTTConnection(clientId, false);
1:62c20eb:             mqtt.setKeepAlive((short) 2);
1:62c20eb:             final BlockingConnection connection = mqtt.blockingConnection();
1:62c20eb:             connection.connect();
1:62c20eb:             connection.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:62c20eb: 
1:62c20eb:             assertTrue("Client connect failed for attempt: " + i, Wait.waitFor(new Wait.Condition() {
1:62c20eb:                 @Override
1:62c20eb:                 public boolean isSatisified() throws Exception {
1:62c20eb:                     return connection.isConnected();
1:62c20eb:                 }
1:101b712:             }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(200)));
1:62c20eb: 
1:62c20eb:             if (oldConnection.get() != null) {
1:62c20eb:                 assertTrue("Old client still connected", Wait.waitFor(new Wait.Condition() {
1:62c20eb:                     @Override
1:62c20eb:                     public boolean isSatisified() throws Exception {
1:62c20eb:                         return !oldConnection.get().isConnected();
1:62c20eb:                     }
1:101b712:                 }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(200)));
1:62c20eb:             }
1:62c20eb: 
1:62c20eb:             oldConnection.set(connection);
1:62c20eb:         }
1:62c20eb: 
1:62c20eb:         oldConnection.get().publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:62c20eb:         oldConnection.get().disconnect();
1:62c20eb:     }
1:62c20eb: 
1:f4a8b11:     @Test(timeout = 30 * 10000)
1:e59ea6d:     public void testJmsMapping() throws Exception {
1:413e484:         doTestJmsMapping("test.foo");
1:413e484:     }
1:413e484: 
1:413e484:     public void doTestJmsMapping(String destinationName) throws Exception {
1:e59ea6d:         // start up jms consumer
1:fb569e3:         Connection jmsConn = cf.createConnection();
1:e59ea6d:         Session session = jmsConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:413e484:         Destination dest = session.createTopic(destinationName);
1:e59ea6d:         MessageConsumer consumer = session.createConsumer(dest);
1:e59ea6d:         jmsConn.start();
1:e8c5a9f: 
1:e59ea6d:         // set up mqtt producer
1:ac23b01:         MQTT mqtt = createMQTTConnection();
1:e59ea6d:         mqtt.setClientId("foo3");
1:f4a8b11:         mqtt.setKeepAlive((short) 2);
1:a581d01:         final BlockingConnection connection = mqtt.blockingConnection();
1:e8c5a9f:         connection.connect();
1:6c85967: 
1:e59ea6d:         int messagesToSend = 5;
1:6c85967: 
1:e59ea6d:         // publish
1:e59ea6d:         for (int i = 0; i < messagesToSend; ++i) {
1:e59ea6d:             connection.publish("test/foo", "hello world".getBytes(), QoS.AT_LEAST_ONCE, false);
1:a581d01:         }
1:a581d01: 
1:e8c5a9f:         connection.disconnect();
1:a581d01: 
1:e59ea6d:         for (int i = 0; i < messagesToSend; i++) {
1:a581d01: 
1:e59ea6d:             javax.jms.Message message = consumer.receive(2 * 1000);
1:e59ea6d:             assertNotNull(message);
1:e59ea6d:             assertTrue(message instanceof BytesMessage);
1:e59ea6d:             BytesMessage bytesMessage = (BytesMessage) message;
1:a581d01: 
1:e59ea6d:             int length = (int) bytesMessage.getBodyLength();
1:e59ea6d:             byte[] buffer = new byte[length];
1:e59ea6d:             bytesMessage.readBytes(buffer);
1:e59ea6d:             assertEquals("hello world", new String(buffer));
1:a581d01:         }
1:a581d01: 
1:e59ea6d:         jmsConn.close();
1:bcb60a4:     }
1:bcb60a4: 
1:8ef4445:     @Test(timeout = 30 * 10000)
1:8ef4445:     public void testSubscribeWithLargeTopicFilter() throws Exception {
1:8ef4445: 
1:8ef4445:         byte[] payload = new byte[1024 * 32];
1:8ef4445:         for (int i = 0; i < payload.length; i++) {
1:8ef4445:             payload[i] = '2';
1:8ef4445:         }
1:8ef4445: 
1:8ef4445:         StringBuilder topicBuilder = new StringBuilder("/topic/");
1:8ef4445: 
1:8ef4445:         for (int i = 0; i < 32800; ++i) {
1:8ef4445:             topicBuilder.append("a");
1:8ef4445:         }
1:8ef4445: 
1:8ef4445:         MQTT mqtt = createMQTTConnection();
1:8ef4445:         mqtt.setClientId("MQTT-Client");
1:8ef4445:         mqtt.setCleanSession(false);
1:5d6d42c: 
1:8ef4445:         final BlockingConnection connection = mqtt.blockingConnection();
1:8ef4445:         connection.connect();
1:8ef4445: 
1:8ef4445:         Topic[] topic = { new Topic(topicBuilder.toString(), QoS.EXACTLY_ONCE) };
1:8ef4445:         connection.subscribe(topic);
1:8ef4445:         connection.publish(topic[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1:8ef4445: 
1:8ef4445:         Message message = connection.receive();
1:8ef4445:         assertNotNull(message);
1:8ef4445:         message.ack();
1:8ef4445:     }
1:8ef4445: 
1:f4a8b11:     @Test(timeout = 30 * 10000)
1:5d6d42c:     public void testSubscribeWithZeroLengthTopic() throws Exception {
1:5d6d42c: 
1:5d6d42c:         MQTT mqtt = createMQTTConnection();
1:5d6d42c:         mqtt.setClientId("MQTT-Client");
1:5d6d42c:         mqtt.setCleanSession(false);
1:5d6d42c: 
1:5d6d42c:         Topic topic = new Topic("", QoS.EXACTLY_ONCE);
1:5d6d42c: 
1:5d6d42c:         final BlockingConnection connection = mqtt.blockingConnection();
1:5d6d42c:         connection.connect();
1:5d6d42c: 
1:5d6d42c:         LOG.info("Trying to subscrobe to topic: {}", topic.name());
1:5d6d42c: 
1:5d6d42c:         try {
1:5d6d42c:             connection.subscribe(new Topic[] { topic });
1:5d6d42c:             fail("Should not be able to subscribe with invalid Topic");
1:5d6d42c:         } catch (Exception ex) {
1:5d6d42c:             LOG.info("Caught expected error on subscribe");
1:5d6d42c:         }
1:5d6d42c: 
1:5d6d42c:         assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1:5d6d42c: 
1:5d6d42c:             @Override
1:5d6d42c:             public boolean isSatisified() throws Exception {
1:5d6d42c:                 return !connection.isConnected();
1:5d6d42c:             }
1:5d6d42c:         }));
1:5d6d42c:     }
1:5d6d42c: 
1:5d6d42c:     @Test(timeout = 30 * 10000)
1:5d6d42c:     public void testUnsubscribeWithZeroLengthTopic() throws Exception {
1:5d6d42c: 
1:5d6d42c:         MQTT mqtt = createMQTTConnection();
1:5d6d42c:         mqtt.setClientId("MQTT-Client");
1:5d6d42c:         mqtt.setCleanSession(false);
1:5d6d42c: 
1:5d6d42c:         Topic topic = new Topic("", QoS.EXACTLY_ONCE);
1:5d6d42c: 
1:5d6d42c:         final BlockingConnection connection = mqtt.blockingConnection();
1:5d6d42c:         connection.connect();
1:5d6d42c: 
1:5d6d42c:         LOG.info("Trying to subscrobe to topic: {}", topic.name());
1:5d6d42c: 
1:5d6d42c:         try {
1:5d6d42c:             connection.unsubscribe(new String[] { topic.name().toString() });
1:5d6d42c:             fail("Should not be able to subscribe with invalid Topic");
1:5d6d42c:         } catch (Exception ex) {
1:5d6d42c:             LOG.info("Caught expected error on subscribe");
1:5d6d42c:         }
1:5d6d42c: 
1:5d6d42c:         assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1:5d6d42c: 
1:5d6d42c:             @Override
1:5d6d42c:             public boolean isSatisified() throws Exception {
1:5d6d42c:                 return !connection.isConnected();
1:5d6d42c:             }
1:5d6d42c:         }));
1:5d6d42c:     }
1:5d6d42c: 
1:5d6d42c:     @Test(timeout = 30 * 10000)
1:5d6d42c:     public void testSubscribeWithInvalidMultiLevelWildcards() throws Exception {
1:5d6d42c: 
1:5d6d42c:         MQTT mqtt = createMQTTConnection();
1:5d6d42c:         mqtt.setClientId("MQTT-Client");
1:5d6d42c:         mqtt.setCleanSession(false);
1:5d6d42c: 
1:5d6d42c:         Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("#/Foo/#", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/#/Level", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/X#", QoS.EXACTLY_ONCE) };
1:5d6d42c: 
1:5d6d42c:         for (int i = 0; i < topics.length; ++i) {
1:5d6d42c:             final BlockingConnection connection = mqtt.blockingConnection();
1:5d6d42c:             connection.connect();
1:5d6d42c: 
1:5d6d42c:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1:5d6d42c: 
1:5d6d42c:             try {
1:5d6d42c:                 connection.subscribe(new Topic[] { topics[i] });
1:5d6d42c:                 fail("Should not be able to subscribe with invalid Topic");
1:5d6d42c:             } catch (Exception ex) {
1:5d6d42c:                 LOG.info("Caught expected error on subscribe");
1:5d6d42c:             }
1:5d6d42c: 
1:5d6d42c:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1:5d6d42c: 
1:5d6d42c:                 @Override
1:5d6d42c:                 public boolean isSatisified() throws Exception {
1:5d6d42c:                     return !connection.isConnected();
1:5d6d42c:                 }
1:5d6d42c:             }));
1:5d6d42c:         }
1:5d6d42c:     }
1:5d6d42c: 
1:5d6d42c:     @Test(timeout = 30 * 10000)
1:5d6d42c:     public void testSubscribeWithInvalidSingleLevelWildcards() throws Exception {
1:5d6d42c: 
1:5d6d42c:         MQTT mqtt = createMQTTConnection();
1:5d6d42c:         mqtt.setClientId("MQTT-Client");
1:5d6d42c:         mqtt.setCleanSession(false);
1:5d6d42c: 
1:5d6d42c:         Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("+Foo/#", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("+#", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/+F", QoS.EXACTLY_ONCE) };
1:5d6d42c: 
1:5d6d42c:         for (int i = 0; i < topics.length; ++i) {
1:5d6d42c:             final BlockingConnection connection = mqtt.blockingConnection();
1:5d6d42c:             connection.connect();
1:5d6d42c: 
1:5d6d42c:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1:5d6d42c: 
1:5d6d42c:             try {
1:5d6d42c:                 connection.subscribe(new Topic[] { topics[i] });
1:5d6d42c:                 fail("Should not be able to subscribe with invalid Topic");
1:5d6d42c:             } catch (Exception ex) {
1:5d6d42c:                 LOG.info("Caught expected error on subscribe");
1:5d6d42c:             }
1:5d6d42c: 
1:5d6d42c:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1:5d6d42c: 
1:5d6d42c:                 @Override
1:5d6d42c:                 public boolean isSatisified() throws Exception {
1:5d6d42c:                     return !connection.isConnected();
1:5d6d42c:                 }
1:5d6d42c:             }));
1:5d6d42c:         }
1:5d6d42c:     }
1:5d6d42c: 
1:5d6d42c:     @Test(timeout = 30 * 10000)
1:5d6d42c:     public void testUnsubscribeWithInvalidMultiLevelWildcards() throws Exception {
1:5d6d42c: 
1:5d6d42c:         MQTT mqtt = createMQTTConnection();
1:5d6d42c:         mqtt.setClientId("MQTT-Client");
1:5d6d42c:         mqtt.setCleanSession(false);
1:5d6d42c: 
1:5d6d42c:         Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("#/Foo/#", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/#/Level", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/X#", QoS.EXACTLY_ONCE) };
1:5d6d42c: 
1:5d6d42c:         for (int i = 0; i < topics.length; ++i) {
1:5d6d42c:             final BlockingConnection connection = mqtt.blockingConnection();
1:5d6d42c:             connection.connect();
1:5d6d42c: 
1:5d6d42c:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1:5d6d42c: 
1:5d6d42c:             try {
1:5d6d42c:                 connection.unsubscribe(new String[] { topics[i].name().toString() });
1:5d6d42c:                 fail("Should not be able to unsubscribe with invalid Topic");
1:5d6d42c:             } catch (Exception ex) {
1:5d6d42c:                 LOG.info("Caught expected error on subscribe");
1:5d6d42c:             }
1:5d6d42c: 
1:5d6d42c:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1:5d6d42c: 
1:5d6d42c:                 @Override
1:5d6d42c:                 public boolean isSatisified() throws Exception {
1:5d6d42c:                     return !connection.isConnected();
1:5d6d42c:                 }
1:5d6d42c:             }));
1:5d6d42c:         }
1:5d6d42c:     }
1:5d6d42c: 
1:5d6d42c:     @Test(timeout = 30 * 10000)
1:5d6d42c:     public void testUnsubscribeWithInvalidSingleLevelWildcards() throws Exception {
1:5d6d42c: 
1:5d6d42c:         MQTT mqtt = createMQTTConnection();
1:5d6d42c:         mqtt.setClientId("MQTT-Client");
1:5d6d42c:         mqtt.setCleanSession(false);
1:5d6d42c: 
1:5d6d42c:         Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("+Foo/#", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("+#", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE),
1:5d6d42c:                            new Topic("Foo/+F", QoS.EXACTLY_ONCE) };
1:5d6d42c: 
1:5d6d42c:         for (int i = 0; i < topics.length; ++i) {
1:5d6d42c:             final BlockingConnection connection = mqtt.blockingConnection();
1:5d6d42c:             connection.connect();
1:5d6d42c: 
1:5d6d42c:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1:5d6d42c: 
1:5d6d42c:             try {
1:5d6d42c:                 connection.unsubscribe(new String[] { topics[i].name().toString() });
1:5d6d42c:                 fail("Should not be able to unsubscribe with invalid Topic");
1:5d6d42c:             } catch (Exception ex) {
1:5d6d42c:                 LOG.info("Caught expected error on subscribe");
1:5d6d42c:             }
1:5d6d42c: 
1:5d6d42c:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1:5d6d42c: 
1:5d6d42c:                 @Override
1:5d6d42c:                 public boolean isSatisified() throws Exception {
1:5d6d42c:                     return !connection.isConnected();
1:5d6d42c:                 }
1:5d6d42c:             }));
1:5d6d42c:         }
1:5d6d42c:     }
1:8ef4445: 
1:5d6d42c:     @Test(timeout = 30 * 10000)
1:3845c7c:     public void testSubscribeMultipleTopics() throws Exception {
1:e7e317d: 
1:4c38438:         byte[] payload = new byte[1024 * 32];
1:e59ea6d:         for (int i = 0; i < payload.length; i++) {
1:4c38438:             payload[i] = '2';
1:bcb60a4:         }
1:e7e317d: 
1:73908d6:         MQTT mqtt = createMQTTConnection();
1:2484c67:         mqtt.setClientId("MQTT-Client");
1:2484c67:         mqtt.setCleanSession(false);
1:e7e317d: 
1:ad30410:         final BlockingConnection connection = mqtt.blockingConnection();
1:6c85967:         connection.connect();
1:e7e317d: 
1:f4a8b11:         Topic[] topics = { new Topic("Topic/A", QoS.EXACTLY_ONCE), new Topic("Topic/B", QoS.EXACTLY_ONCE) };
1:f4a8b11:         Topic[] wildcardTopic = { new Topic("Topic/#", QoS.AT_LEAST_ONCE) };
1:4dc1ddc:         connection.subscribe(wildcardTopic);
1:e7e317d: 
1:3845c7c:         for (Topic topic : topics) {
1:3845c7c:             connection.publish(topic.name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1:bcb60a4:         }
1:e7e317d: 
1:3845c7c:         int received = 0;
1:3845c7c:         for (int i = 0; i < topics.length; ++i) {
1:1e3ea5c:             Message message = connection.receive();
16:cfc6917:             assertNotNull(message);
1:e2b932e:             received++;
2:e2b932e:             payload = message.getPayload();
1:e2b932e:             String messageContent = new String(payload);
1:f4a8b11:             LOG.info("Received message from topic: " + message.getTopic() + " Message content: " + messageContent);
1:1e3ea5c:             message.ack();
1:bcb60a4:         }
1:e7e317d: 
1:3845c7c:         assertEquals("Should have received " + topics.length + " messages", topics.length, received);
1:e7e317d:     }
1:e7e317d: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:2484c67:     public void testReceiveMessageSentWhileOffline() throws Exception {
1:bf8eb0e:         final byte[] payload = new byte[1024 * 32];
1:f4a8b11:         for (int i = 0; i < payload.length; i++) {
1:e2b932e:             payload[i] = '2';
1:e7e317d:         }
1:e7e317d: 
1:e2b932e:         int numberOfRuns = 100;
1:e2b932e:         int messagesPerRun = 2;
1:ad30410: 
1:bf8eb0e:         final MQTT mqttPub = createMQTTConnection("MQTT-Pub-Client", true);
1:bf8eb0e:         final MQTT mqttSub = createMQTTConnection("MQTT-Sub-Client", false);
35:bc9751a: 
1:e2b932e:         final BlockingConnection connectionPub = mqttPub.blockingConnection();
1:64baf09:         connectionPub.connect();
1:64baf09: 
1:64baf09:         BlockingConnection connectionSub = mqttSub.blockingConnection();
1:64baf09:         connectionSub.connect();
1:bc9751a: 
1:f4a8b11:         Topic[] topics = { new Topic("TopicA", QoS.EXACTLY_ONCE) };
2:e2b932e:         connectionSub.subscribe(topics);
1:f4a8b11: 
3:e2b932e:         for (int i = 0; i < messagesPerRun; ++i) {
2:e2b932e:             connectionPub.publish(topics[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1:e7e317d:         }
1:bc9751a: 
1:e2b932e:         int received = 0;
1:e2b932e:         for (int i = 0; i < messagesPerRun; ++i) {
2:e2b932e:             Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:f4a8b11:             assertNotNull(message);
1:e2b932e:             received++;
1:bf8eb0e:             assertTrue(Arrays.equals(payload, message.getPayload()));
1:1e3ea5c:             message.ack();
1:e7e317d:         }
2:e2b932e:         connectionSub.disconnect();
1:0a39782: 
1:2b3f0e5:         try {
1:2b3f0e5:             for (int j = 0; j < numberOfRuns; j++) {
1:2b3f0e5: 
1:2b3f0e5:                 for (int i = 0; i < messagesPerRun; ++i) {
1:2b3f0e5:                     connectionPub.publish(topics[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1:2b3f0e5:                 }
1:0a39782: 
1:2b3f0e5:                 connectionSub = mqttSub.blockingConnection();
1:2b3f0e5:                 connectionSub.connect();
1:2b3f0e5:                 connectionSub.subscribe(topics);
1:2b3f0e5: 
1:2b3f0e5:                 for (int i = 0; i < messagesPerRun; ++i) {
1:2b3f0e5:                     Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:2b3f0e5:                     assertNotNull(message);
1:2b3f0e5:                     received++;
1:2b3f0e5:                     assertTrue(Arrays.equals(payload, message.getPayload()));
1:2b3f0e5:                     message.ack();
1:2b3f0e5:                 }
1:2b3f0e5:                 connectionSub.disconnect();
1:ad30410:             }
1:2b3f0e5:         } catch (Exception exception) {
1:2b3f0e5:             LOG.error("unexpected exception", exception);
1:2b3f0e5:             exception.printStackTrace();
1:bc9751a:         }
1:e2b932e:         assertEquals("Should have received " + (messagesPerRun * (numberOfRuns + 1)) + " messages", (messagesPerRun * (numberOfRuns + 1)), received);
1:bc9751a:     }
1:74d2c24: 
1:74d2c24:     @Test(timeout = 60 * 1000)
1:74d2c24:     public void testReceiveMessageSentWhileOfflineAndBrokerRestart() throws Exception {
1:74d2c24:         stopBroker();
1:74d2c24:         this.persistent = true;
1:74d2c24:         startBroker();
1:74d2c24: 
1:74d2c24:         final byte[] payload = new byte[1024 * 32];
1:74d2c24:         for (int i = 0; i < payload.length; i++) {
1:74d2c24:             payload[i] = '2';
1:74d2c24:         }
1:bc9751a: 
1:74d2c24:         int messagesPerRun = 10;
1:74d2c24: 
1:74d2c24:         Topic[] topics = { new Topic("TopicA", QoS.EXACTLY_ONCE) };
1:74d2c24: 
1:74d2c24:         {
1:74d2c24:             // Establish a durable subscription.
1:74d2c24:             MQTT mqttSub = createMQTTConnection("MQTT-Sub-Client", false);
1:74d2c24:             BlockingConnection connectionSub = mqttSub.blockingConnection();
1:74d2c24:             connectionSub.connect();
1:74d2c24:             connectionSub.subscribe(topics);
1:74d2c24:             connectionSub.disconnect();
1:74d2c24:         }
1:74d2c24: 
1:74d2c24:         MQTT mqttPubLoop = createMQTTConnection("MQTT-Pub-Client", true);
1:74d2c24:         BlockingConnection connectionPub = mqttPubLoop.blockingConnection();
1:74d2c24:         connectionPub.connect();
1:74d2c24: 
1:74d2c24:         for (int i = 0; i < messagesPerRun; ++i) {
1:74d2c24:             connectionPub.publish(topics[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1:74d2c24:         }
1:74d2c24: 
1:74d2c24:         connectionPub.disconnect();
1:74d2c24: 
1:fd2805f:         restartBroker();
1:74d2c24: 
1:74d2c24:         MQTT mqttSub = createMQTTConnection("MQTT-Sub-Client", false);
1:74d2c24:         BlockingConnection connectionSub = mqttSub.blockingConnection();
1:74d2c24:         connectionSub.connect();
1:74d2c24:         connectionSub.subscribe(topics);
1:74d2c24: 
1:74d2c24:         for (int i = 0; i < messagesPerRun; ++i) {
1:74d2c24:             Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:74d2c24:             assertNotNull(message);
1:bf8eb0e:             assertTrue(Arrays.equals(payload, message.getPayload()));
1:74d2c24:             message.ack();
1:74d2c24:         }
1:74d2c24:         connectionSub.disconnect();
1:74d2c24:     }
1:74d2c24: 
1:f4a8b11:     @Test(timeout = 30 * 1000)
1:d212d3c:     public void testDefaultKeepAliveWhenClientSpecifiesZero() throws Exception {
1:74d2c24:         stopBroker();
1:fb569e3:         protocolConfig = "transport.defaultKeepAlive=2000";
1:74d2c24:         startBroker();
1:fb569e3: 
1:a581d01:         MQTT mqtt = createMQTTConnection();
1:ac23b01:         mqtt.setClientId("foo");
1:f4a8b11:         mqtt.setKeepAlive((short) 0);
1:e59ea6d:         final BlockingConnection connection = mqtt.blockingConnection();
1:e7e317d:         connection.connect();
1:bc9751a: 
1:d3571a6:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
1:bc9751a: 
1:bc9751a:             @Override
1:cfc6917:             public boolean isSatisified() throws Exception {
1:d3571a6:                 return connection.isConnected();
1:bc9751a:             }
1:62c20eb:         }));
1:bc9751a:     }
1:bc9751a: 
1:7e56f34:     @Test(timeout = 60 * 1000)
1:7b5f956:     public void testReuseConnection() throws Exception {
2:e7e317d:         MQTT mqtt = createMQTTConnection();
1:7b5f956:         mqtt.setClientId("Test-Client");
1:bc9751a: 
1:cfc6917:         {
1:6c85967:             BlockingConnection connection = mqtt.blockingConnection();
1:e7e317d:             connection.connect();
1:73908d6:             connection.disconnect();
1:101b712:             Thread.sleep(500);
2:6683eb6:         }
1:2484c67:         {
2:e7e317d:             BlockingConnection connection = mqtt.blockingConnection();
1:e7e317d:             connection.connect();
1:6c85967:             connection.disconnect();
1:101b712:             Thread.sleep(500);
1:6683eb6:         }
1:6683eb6:     }
1:bc9751a: 
1:0db7e69:     @Test(timeout = 60 * 1000)
1:f4a8b11:     public void testNoMessageReceivedAfterUnsubscribeMQTT() throws Exception {
1:f4a8b11:         Topic[] topics = { new Topic("TopicA", QoS.EXACTLY_ONCE) };
1:bc9751a: 
1:f4a8b11:         MQTT mqttPub = createMQTTConnection("MQTTPub-Client", true);
1:f4a8b11:         // mqttPub.setVersion("3.1.1");
1:f4a8b11: 
1:f4a8b11:         MQTT mqttSub = createMQTTConnection("MQTTSub-Client", false);
1:f4a8b11:         // mqttSub.setVersion("3.1.1");
1:f4a8b11: 
1:f4a8b11:         BlockingConnection connectionPub = mqttPub.blockingConnection();
1:f4a8b11:         connectionPub.connect();
1:f4a8b11: 
1:f4a8b11:         BlockingConnection connectionSub = mqttSub.blockingConnection();
1:f4a8b11:         connectionSub.connect();
1:f4a8b11:         connectionSub.subscribe(topics);
1:f4a8b11:         connectionSub.disconnect();
1:f4a8b11: 
1:0a39782:         for (int i = 0; i < 5; i++) {
1:f4a8b11:             String payload = "Message " + i;
1:f4a8b11:             connectionPub.publish(topics[0].name().toString(), payload.getBytes(), QoS.EXACTLY_ONCE, false);
1:f4a8b11:         }
1:f4a8b11: 
1:f4a8b11:         connectionSub = mqttSub.blockingConnection();
1:f4a8b11:         connectionSub.connect();
1:64baf09: 
1:f4a8b11:         int received = 0;
1:0a39782:         for (int i = 0; i < 5; ++i) {
1:f4a8b11:             Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:0a39782:             assertNotNull("Missing message " + i, message);
1:f4a8b11:             LOG.info("Message is " + new String(message.getPayload()));
1:f4a8b11:             received++;
1:f4a8b11:             message.ack();
1:f4a8b11:         }
1:0a39782:         assertEquals(5, received);
1:f4a8b11: 
1:0a39782:         // unsubscribe from topic
1:0a39782:         connectionSub.unsubscribe(new String[]{"TopicA"});
1:f4a8b11: 
1:0a39782:         // send more messages
1:0a39782:         for (int i = 0; i < 5; i++) {
1:0a39782:             String payload = "Message " + i;
1:0a39782:             connectionPub.publish(topics[0].name().toString(), payload.getBytes(), QoS.EXACTLY_ONCE, false);
1:f4a8b11:         }
1:0a39782: 
1:0a39782:         // these should not be received
1:101b712:         assertNull(connectionSub.receive(2, TimeUnit.SECONDS));
1:bc9751a: 
1:f4a8b11:         connectionSub.disconnect();
1:f4a8b11:         connectionPub.disconnect();
1:64baf09:     }
1:bc9751a: 
1:f4a8b11:     @Test(timeout = 60 * 1000)
1:f4a8b11:     public void testMQTT311Connection() throws Exception {
1:f4a8b11:         MQTT mqtt = createMQTTConnection();
1:f4a8b11:         mqtt.setClientId("foo");
2:6dacef1:         mqtt.setVersion("3.1.1");
1:f4a8b11:         final BlockingConnection connection = mqtt.blockingConnection();
1:6dacef1:         connection.connect();
1:f4a8b11:         connection.disconnect();
1:6dacef1:     }
1:6dacef1: 
1:7948d69:     @Test(timeout = 60 * 1000)
1:bcb60a4:     public void testActiveMQRecoveryPolicy() throws Exception {
1:bcb60a4:         // test with ActiveMQ LastImageSubscriptionRecoveryPolicy
1:bcb60a4:         final PolicyMap policyMap = new PolicyMap();
1:bcb60a4:         final PolicyEntry policyEntry = new PolicyEntry();
1:bcb60a4:         policyEntry.setSubscriptionRecoveryPolicy(new LastImageSubscriptionRecoveryPolicy());
1:bcb60a4:         policyMap.put(new ActiveMQTopic(">"), policyEntry);
1:bcb60a4:         brokerService.setDestinationPolicy(policyMap);
1:6dacef1: 
1:bcb60a4:         MQTT mqtt = createMQTTConnection("pub-sub", true);
1:bcb60a4:         final int[] retain = new int[1];
1:bcb60a4:         final int[] nonretain  = new int[1];
1:6dacef1:         mqtt.setTracer(new Tracer() {
1:6dacef1:             @Override
1:6dacef1:             public void onReceive(MQTTFrame frame) {
1:bcb60a4:                 if (frame.messageType() == PUBLISH.TYPE) {
1:bcb60a4:                     LOG.info("Received message with retain=" + frame.retain());
1:bcb60a4:                     if (frame.retain()) {
1:bcb60a4:                         retain[0]++;
1:bcb60a4:                     } else {
1:bcb60a4:                         nonretain[0]++;
1:6dacef1:                     }
1:6dacef1:                 }
1:6dacef1:             }
1:6dacef1:         });
1:6dacef1: 
1:bcb60a4:         BlockingConnection connection = mqtt.blockingConnection();
1:f4a8b11:         connection.connect();
1:bcb60a4:         final String RETAINED = "RETAINED";
1:bcb60a4:         connection.publish("one", RETAINED.getBytes(), QoS.AT_LEAST_ONCE, true);
1:bcb60a4:         connection.publish("two", RETAINED.getBytes(), QoS.AT_LEAST_ONCE, true);
1:6dacef1: 
1:bcb60a4:         final String NONRETAINED = "NONRETAINED";
1:bcb60a4:         connection.publish("one", NONRETAINED.getBytes(), QoS.AT_LEAST_ONCE, false);
1:bcb60a4:         connection.publish("two", NONRETAINED.getBytes(), QoS.AT_LEAST_ONCE, false);
1:6dacef1: 
1:bcb60a4:         connection.subscribe(new Topic[]{new Topic("#", QoS.AT_LEAST_ONCE)});
1:bcb60a4:         for (int i = 0; i < 4; i++) {
1:bcb60a4:             final Message message = connection.receive(30, TimeUnit.SECONDS);
1:bcb60a4:             assertNotNull("Should receive 4 messages", message);
1:bcb60a4:             message.ack();
1:f4a8b11:         }
1:bcb60a4:         assertEquals("Should receive 2 retained messages", 2, retain[0]);
1:bcb60a4:         assertEquals("Should receive 2 non-retained messages", 2, nonretain[0]);
1:0a39782:     }
1:f4a8b11: 
1:fb569e3:     @Test(timeout = 60 * 1000)
1:f55edcf:     public void testSendMQTTReceiveJMSVirtualTopic() throws Exception {
1:f55edcf: 
1:f55edcf:         final MQTTClientProvider provider = getMQTTClientProvider();
1:f55edcf:         initializeConnection(provider);
1:f55edcf:         final String DESTINATION_NAME = "Consumer.jms.VirtualTopic.TopicA";
1:f55edcf: 
1:f55edcf:         // send retained message
1:f55edcf:         final String RETAINED = "RETAINED";
1:f55edcf:         final String MQTT_DESTINATION_NAME = "VirtualTopic/TopicA";
1:f55edcf:         provider.publish(MQTT_DESTINATION_NAME, RETAINED.getBytes(), AT_LEAST_ONCE, true);
1:f55edcf: 
1:f55edcf:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory(jmsUri).createConnection();
1:f55edcf:         // MUST set to true to receive retained messages
1:f55edcf:         activeMQConnection.setUseRetroactiveConsumer(true);
1:f55edcf:         activeMQConnection.start();
1:f55edcf:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:f55edcf:         Queue jmsQueue = s.createQueue(DESTINATION_NAME);
1:f55edcf:         MessageConsumer consumer = s.createConsumer(jmsQueue);
1:f55edcf: 
1:f55edcf:         // check whether we received retained message on JMS subscribe
1:f55edcf:         ActiveMQMessage message = (ActiveMQMessage) consumer.receive(5000);
1:f55edcf:         assertNotNull("Should get retained message", message);
1:f55edcf:         ByteSequence bs = message.getContent();
1:f55edcf:         assertEquals(RETAINED, new String(bs.data, bs.offset, bs.length));
1:f55edcf:         assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));
1:f55edcf: 
1:f55edcf:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:f55edcf:             String payload = "Test Message: " + i;
1:f55edcf:             provider.publish(MQTT_DESTINATION_NAME, payload.getBytes(), AT_LEAST_ONCE);
1:f55edcf:             message = (ActiveMQMessage) consumer.receive(5000);
1:f55edcf:             assertNotNull("Should get a message", message);
1:f55edcf:             bs = message.getContent();
1:f55edcf:             assertEquals(payload, new String(bs.data, bs.offset, bs.length));
1:f55edcf:         }
1:f55edcf: 
1:f55edcf:         // re-create consumer and check we received retained message again
1:f55edcf:         consumer.close();
1:f55edcf:         consumer = s.createConsumer(jmsQueue);
1:f55edcf:         message = (ActiveMQMessage) consumer.receive(5000);
1:f55edcf:         assertNotNull("Should get retained message", message);
1:f55edcf:         bs = message.getContent();
1:f55edcf:         assertEquals(RETAINED, new String(bs.data, bs.offset, bs.length));
1:f55edcf:         assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));
1:f55edcf: 
1:f55edcf:         activeMQConnection.close();
1:f55edcf:         provider.disconnect();
1:f55edcf:     }
1:f55edcf: 
1:f55edcf:     @Test(timeout = 60 * 1000)
1:fb569e3:     public void testPingOnMQTT() throws Exception {
1:fb569e3:         stopBroker();
1:fb569e3:         protocolConfig = "maxInactivityDuration=-1";
1:fb569e3:         startBroker();
1:bcb60a4: 
1:fb569e3:         MQTT mqtt = createMQTTConnection();
1:fb569e3:         mqtt.setClientId("test-mqtt");
2:67f151f:         mqtt.setKeepAlive((short)2);
1:fb569e3:         final BlockingConnection connection = mqtt.blockingConnection();
1:fb569e3:         connection.connect();
1:fb569e3:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
1:67f151f: 
1:bc9751a:             @Override
1:fb569e3:             public boolean isSatisified() throws Exception {
1:fb569e3:                 return connection.isConnected();
1:67f151f:             }
1:62c20eb:         }));
1:67f151f: 
1:67f151f:         connection.disconnect();
1:0db7e69:     }
1:7e56f34: 
1:808a4c5:     @Test
1:808a4c5:     public void testConnectWithLargePassword() throws Exception {
1:808a4c5:        for (String version : Arrays.asList("3.1", "3.1.1")) {
1:808a4c5:           String longString = new String(new char[65535]);
1:808a4c5: 
1:808a4c5:           BlockingConnection connection = null;
1:808a4c5:           try {
1:808a4c5:              MQTT mqtt = createMQTTConnection("test-" + version, true);
1:808a4c5:              mqtt.setUserName(longString);
1:808a4c5:              mqtt.setPassword(longString);
1:808a4c5:              mqtt.setConnectAttemptsMax(1);
1:808a4c5:              mqtt.setVersion(version);
1:808a4c5:              connection = mqtt.blockingConnection();
1:808a4c5:              connection.connect();
1:808a4c5:              final BlockingConnection con = connection;
1:808a4c5:              assertTrue(Wait.waitFor(new Wait.Condition() {
1:808a4c5:                  @Override
1:808a4c5:                  public boolean isSatisified() throws Exception {
1:808a4c5:                      return con.isConnected();
1:808a4c5:                  }
1:808a4c5:              }));
1:808a4c5:           } finally {
1:808a4c5:              if (connection != null && connection.isConnected()) connection.disconnect();
1:808a4c5:           }
1:808a4c5:        }
1:808a4c5:     }
1:bcb60a4: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:2b3f0e5
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             for (int j = 0; j < numberOfRuns; j++) {
1:                 for (int i = 0; i < messagesPerRun; ++i) {
1:                     connectionPub.publish(topics[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1:                 }
1: 
1:                 connectionSub = mqttSub.blockingConnection();
1:                 connectionSub.connect();
1:                 connectionSub.subscribe(topics);
1: 
1:                 for (int i = 0; i < messagesPerRun; ++i) {
1:                     Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:                     assertNotNull(message);
1:                     received++;
1:                     assertTrue(Arrays.equals(payload, message.getPayload()));
1:                     message.ack();
1:                 }
1:                 connectionSub.disconnect();
1:         } catch (Exception exception) {
1:             LOG.error("unexpected exception", exception);
1:             exception.printStackTrace();
commit:bf8eb0e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:         subscriptionProvider.subscribe(topic, AT_MOST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:         mqtt.setKeepAlive((short) 2);
/////////////////////////////////////////////////////////////////////////
1:         final MQTT mqtt = createMQTTConnection("resend", false);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         List<Integer> dups = new ArrayList<Integer>();
0:         for (int i = 0; i < publishList.size() - 1; i++) {
0:             if (!dups.contains(i)) {
0:                 boolean found = false;
1:                 for (int j = i + 1; j < publishList.size(); j++) {
0:                         dups.add(j);
1:                         break;
0:                 assertTrue("Dup Not found " + publishList.get(i), found);
1:     @Test(timeout = 60 * 1000)
1:     public void testClientConnectionFailure() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection("reconnect", false);
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
0:         assertTrue(connection.isConnected());
1: 
1:         final String TOPIC = "TopicA";
0:         final byte[] qos = connection.subscribe(new Topic[]{new Topic(TOPIC, QoS.EXACTLY_ONCE)});
1:         assertEquals(QoS.EXACTLY_ONCE.ordinal(), qos[0]);
1:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:         // kill transport
1:         connection.kill();
1: 
1:         connection = mqtt.blockingConnection();
1:         connection.connect();
0:         assertTrue(connection.isConnected());
1: 
1:         assertEquals(QoS.EXACTLY_ONCE.ordinal(), qos[0]);
1:         Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:         assertNotNull(msg);
1:         assertEquals(TOPIC, new String(msg.getPayload()));
1:         msg.ack();
1:         connection.disconnect();
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
1:     public void testCleanSession() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         final String CLIENTID = "cleansession";
1:         final MQTT mqttNotClean = createMQTTConnection(CLIENTID, false);
1:         BlockingConnection notClean = mqttNotClean.blockingConnection();
1:         final String TOPIC = "TopicA";
1:         notClean.connect();
0:         notClean.subscribe(new Topic[]{new Topic(TOPIC, QoS.EXACTLY_ONCE)});
1:         notClean.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:         notClean.disconnect();
1: 
1:         // MUST receive message from previous not clean session
1:         notClean = mqttNotClean.blockingConnection();
1:         notClean.connect();
1:         Message msg = notClean.receive(10000, TimeUnit.MILLISECONDS);
1:         assertNotNull(msg);
1:         assertEquals(TOPIC, new String(msg.getPayload()));
1:         msg.ack();
1:         notClean.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:         notClean.disconnect();
1: 
1:         // MUST NOT receive message from previous not clean session
1:         final MQTT mqttClean = createMQTTConnection(CLIENTID, true);
1:         final BlockingConnection clean = mqttClean.blockingConnection();
1:         clean.connect();
0:         msg = clean.receive(10000, TimeUnit.MILLISECONDS);
1:         assertNull(msg);
0:         clean.subscribe(new Topic[]{new Topic(TOPIC, QoS.EXACTLY_ONCE)});
1:         clean.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:         clean.disconnect();
1: 
1:         // MUST NOT receive message from previous clean session
1:         notClean = mqttNotClean.blockingConnection();
1:         notClean.connect();
1:         msg = notClean.receive(1000, TimeUnit.MILLISECONDS);
1:         assertNull(msg);
1:         notClean.disconnect();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         final byte[] payload = new byte[1024 * 32];
/////////////////////////////////////////////////////////////////////////
1:         final MQTT mqttPub = createMQTTConnection("MQTT-Pub-Client", true);
1:         final MQTT mqttSub = createMQTTConnection("MQTT-Sub-Client", false);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue(Arrays.equals(payload, message.getPayload()));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 assertTrue(Arrays.equals(payload, message.getPayload()));
commit:67f151f
/////////////////////////////////////////////////////////////////////////
1: import java.net.ProtocolException;
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertNotEquals;
0: import org.fusesource.hawtbuf.Buffer;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testUniqueMessageIds() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("foo");
1:         mqtt.setKeepAlive((short)2);
1:         mqtt.setCleanSession(true);
1: 
1:         final List<PUBLISH> publishList = new ArrayList<PUBLISH>();
1:         mqtt.setTracer(new Tracer() {
1:             @Override
1:             public void onReceive(MQTTFrame frame) {
0:                 LOG.info("Client received:\n" + frame);
1:                 if (frame.messageType() == PUBLISH.TYPE) {
1:                     PUBLISH publish = new PUBLISH();
1:                     try {
0:                         // copy the buffers before we decode
0:                         Buffer[] buffers = frame.buffers();
0:                         Buffer[] copy = new Buffer[buffers.length];
0:                         for (int i = 0; i < buffers.length; i++) {
0:                             copy[i] = buffers[i].deepCopy();
1:                         }
1:                         publish.decode(frame);
0:                         // reset frame buffers to deep copy
0:                         frame.buffers(copy);
1:                     } catch (ProtocolException e) {
1:                         fail("Error decoding publish " + e.getMessage());
1:                     }
1:                     publishList.add(publish);
1:                 }
1:             }
1: 
1:             @Override
1:             public void onSend(MQTTFrame frame) {
0:                 LOG.info("Client sent:\n" + frame);
1:             }
1:         });
1: 
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         // create overlapping subscriptions with different QoSs
1:         QoS[] qoss = { QoS.AT_MOST_ONCE, QoS.AT_LEAST_ONCE, QoS.EXACTLY_ONCE };
1:         final String TOPIC = "TopicA/";
1: 
1:         // publish retained message
1:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, true);
1: 
0:         String[] subs = {TOPIC, "TopicA/#", "TopicA/+"};
1:         for (int i = 0; i < qoss.length; i++) {
0:             connection.subscribe(new Topic[]{ new Topic(subs[i], qoss[i]) });
1:         }
1: 
1:         // publish non-retained message
1:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:         int received = 0;
1: 
1:         Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:         do {
1:             assertNotNull(msg);
1:             assertEquals(TOPIC, new String(msg.getPayload()));
1:             msg.ack();
1:             int waitCount = 0;
1:             while (publishList.size() <= received && waitCount < 10) {
1:                 Thread.sleep(1000);
1:                 waitCount++;
1:             }
1:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:         } while (msg != null && received++ < subs.length * 2);
1:         assertEquals("Unexpected number of messages", subs.length * 2, received + 1);
1: 
0:         // make sure we received distinct ids for QoS != AT_MOST_ONCE, and 0 for AT_MOST_ONCE
1:         for (int i = 0; i < publishList.size(); i++) {
0:             for (int j = i + 1; j < publishList.size(); j++) {
1:                 final PUBLISH publish1 = publishList.get(i);
1:                 final PUBLISH publish2 = publishList.get(j);
1:                 boolean qos0 = false;
1:                 if (publish1.qos() == QoS.AT_MOST_ONCE) {
1:                     qos0 = true;
1:                     assertEquals(0, publish1.messageId());
1:                 }
1:                 if (publish2.qos() == QoS.AT_MOST_ONCE) {
1:                     qos0 = true;
1:                     assertEquals(0, publish2.messageId());
1:                 }
1:                 if (!qos0) {
1:                     assertNotEquals(publish1.messageId(), publish2.messageId());
1:                 }
1:             }
1:         }
1: 
1:         connection.unsubscribe(subs);
1:         connection.disconnect();
1:     }
1: 
0:     @Test(timeout = 600 * 1000)
1:     public void testResendMessageId() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("foo");
1:         mqtt.setKeepAlive((short)2);
1:         mqtt.setCleanSession(true);
1: 
1:         final List<PUBLISH> publishList = new ArrayList<PUBLISH>();
1:         mqtt.setTracer(new Tracer() {
1:             @Override
1:             public void onReceive(MQTTFrame frame) {
0:                 LOG.info("Client received:\n" + frame);
1:                 if (frame.messageType() == PUBLISH.TYPE) {
1:                     PUBLISH publish = new PUBLISH();
1:                     try {
0:                         // copy the buffers before we decode
0:                         Buffer[] buffers = frame.buffers();
0:                         Buffer[] copy = new Buffer[buffers.length];
0:                         for (int i = 0; i < buffers.length; i++) {
0:                             copy[i] = buffers[i].deepCopy();
1:                         }
1:                         publish.decode(frame);
0:                         // reset frame buffers to deep copy
0:                         frame.buffers(copy);
1:                     } catch (ProtocolException e) {
1:                         fail("Error decoding publish " + e.getMessage());
1:                     }
1:                     publishList.add(publish);
1:                 }
1:             }
1: 
1:             @Override
1:             public void onSend(MQTTFrame frame) {
0:                 LOG.info("Client sent:\n" + frame);
1:             }
1:         });
1: 
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         // create overlapping subscriptions with different QoSs
1:         final String TOPIC = "TopicA/";
0:         final String[] subs = { TOPIC, "+/"};
0:         connection.subscribe(new Topic[]{new Topic(subs[0], QoS.AT_LEAST_ONCE), new Topic(subs[1], QoS.EXACTLY_ONCE)});
1: 
1:         // publish non-retained message
1:         connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1: 
1:         Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:         assertNotNull(msg);
1:         assertEquals(TOPIC, new String(msg.getPayload()));
1:         msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:         assertNotNull(msg);
1:         assertEquals(TOPIC, new String(msg.getPayload()));
1: 
0:         // drop subs without acknowledging messages, then subscribe and receive again
1:         connection.unsubscribe(subs);
0:         connection.subscribe(new Topic[]{new Topic(subs[0], QoS.AT_LEAST_ONCE), new Topic(subs[1], QoS.EXACTLY_ONCE)});
0:         // wait for all acks to be processed
1:         Thread.sleep(1000);
1: 
1:         msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:         assertNotNull(msg);
1:         assertEquals(TOPIC, new String(msg.getPayload()));
1:         msg.ack();
1:         msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:         assertNotNull(msg);
1:         assertEquals(TOPIC, new String(msg.getPayload()));
1:         msg.ack();
1: 
1:         // make sure we received duplicate message ids
1:         for (int i = 0; i < publishList.size(); i++) {
0:             boolean found = false;
0:             for (int j = 0; j < publishList.size(); j++) {
0:                 if (i != j) {
0:                     if (publishList.get(i).messageId() == publishList.get(j).messageId()) {
0:                         // one of them is a duplicate
0:                         assertTrue(publishList.get(i).dup() || publishList.get(j).dup());
0:                         found = true;
1:                     }
1:                 }
1:             }
0:             assertTrue("Dup Not found " + publishList.get(i), found);
1:         }
1: 
1:         connection.unsubscribe(subs);
1:         connection.disconnect();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 " Message content: " + messageContent);
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:808a4c5
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Test
1:     public void testConnectWithLargePassword() throws Exception {
1:        for (String version : Arrays.asList("3.1", "3.1.1")) {
1:           String longString = new String(new char[65535]);
1: 
1:           BlockingConnection connection = null;
1:           try {
1:              MQTT mqtt = createMQTTConnection("test-" + version, true);
1:              mqtt.setUserName(longString);
1:              mqtt.setPassword(longString);
1:              mqtt.setConnectAttemptsMax(1);
1:              mqtt.setVersion(version);
1:              connection = mqtt.blockingConnection();
1:              connection.connect();
1:              final BlockingConnection con = connection;
1:              assertTrue(Wait.waitFor(new Wait.Condition() {
1:                  @Override
1:                  public boolean isSatisified() throws Exception {
1:                      return con.isConnected();
1:                  }
1:              }));
1:           } finally {
1:              if (connection != null && connection.isConnected()) connection.disconnect();
1:           }
1:        }
1:     }
commit:b5b087d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6dacef1
/////////////////////////////////////////////////////////////////////////
0: import java.io.EOFException;
0: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.Wait.Condition;
0: import org.fusesource.hawtdispatch.transport.Transport;
0: import org.fusesource.mqtt.client.Callback;
0: import org.fusesource.mqtt.client.CallbackConnection;
0: import org.fusesource.mqtt.client.FutureConnection;
0: import org.fusesource.mqtt.codec.MQTTProtocolCodec;
0: import org.fusesource.mqtt.codec.PINGREQ;
0: import org.fusesource.mqtt.codec.PINGRESP;
/////////////////////////////////////////////////////////////////////////
1: 
0:     @Test(timeout = 15 * 1000, expected=EOFException.class)
0:     public void testPingReqWithoutConnectFail31() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setClientId("clientId");
0:         mqtt.setVersion("3.1");
0:         testPingReqWithoutConnectFail(mqtt);
1:     }
1: 
0:     @Test(timeout = 15 * 1000, expected=EOFException.class)
0:     public void testPingReqWithoutConnectFail311() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setClientId("clientId");
1:         mqtt.setVersion("3.1.1");
0:         testPingReqWithoutConnectFail(mqtt);
1:     }
1: 
0:     @Test(timeout = 15 * 1000)
0:     public void testPingReqConnectSuccess31() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setClientId("clientId");
0:         mqtt.setVersion("3.1");
0:         testPingReqConnectSuccess(mqtt);
1:     }
1: 
0:     @Test(timeout = 15 * 1000)
0:     public void testPingReqConnectSuccess311() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setClientId("clientId");
1:         mqtt.setVersion("3.1.1");
0:         testPingReqConnectSuccess(mqtt);
1:     }
1: 
0:     private void testPingReqWithoutConnectFail(final  MQTT mqtt) throws Exception {
0:         final CountDownLatch latch = new CountDownLatch(1);
0:         final AtomicReference<Transport> transport = new AtomicReference<>();
0:         final AtomicReference<Throwable> error = new AtomicReference<>();
0:         final Callback<Transport> con = new Callback<Transport>() {
1: 
1:             @Override
0:             public void onSuccess(Transport value) {
0:                 transport.set(value);
1:                 latch.countDown();
1:             }
1: 
1:             @Override
0:             public void onFailure(Throwable value) {
0:                 error.set(value);
1:                 latch.countDown();
1:             }
0:         };
1: 
0:         //Connect to the transport by using the createTransport method with a custom callback
0:         //This will ensure that we connect without sending a CONNECT packet for testing
0:         //and that we won't receive automatically
0:         CallbackConnection connection = new CallbackConnection(mqtt);
0:         Method createTransportMethod = connection.getClass().getDeclaredMethod("createTransport", Callback.class);
0:         createTransportMethod.setAccessible(true);
0:         createTransportMethod.invoke(connection, con);
0:         latch.await();
1: 
0:         //Make sure no error on connect
0:         if (error.get() != null) {
0:             LOG.error(error.get().getMessage(), error.get());
0:             fail(error.get().getMessage());
1:         }
1: 
0:         //Send a PINGREQ without a connect packet first
0:         final MQTTProtocolCodec codec = new MQTTProtocolCodec();
0:         codec.setTransport(transport.get());
0:         transport.get().offer(new PINGREQ().encode());
1: 
0:         //Protocol should throw an exception since we never sent a CONNECT
0:         Wait.waitFor(new Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 //Wait for exception to be thrown
0:                 codec.read();
0:                 return false;
1:             }
0:         }, 5000, 100);
1: 
1:     }
1: 
0:     private void testPingReqConnectSuccess(final MQTT mqtt) throws Exception {
0:         final CountDownLatch pingRespReceived = new CountDownLatch(1);
0:         //Tracer to assert we received the response by waiting for it
1:         mqtt.setTracer(new Tracer() {
1: 
1:             @Override
1:             public void onReceive(MQTTFrame frame) {
0:                 if (frame.messageType() == PINGRESP.TYPE) {
0:                     pingRespReceived.countDown();
1:                 }
1:             }
1: 
1:         });
0:         CallbackConnection callbackConnection = new CallbackConnection(mqtt);
0:         BlockingConnection connection = new BlockingConnection(new FutureConnection(callbackConnection));
1:         connection.connect();
0:         Transport transport =  callbackConnection.transport();
1: 
0:         //SEND a PINGREQ and wait for the response
0:         final MQTTProtocolCodec codec = new MQTTProtocolCodec();
0:         codec.setTransport(transport);
0:         transport.offer(new PINGREQ().encode());
1: 
0:         //Wait for the response
0:         assertTrue(pingRespReceived.await(5, TimeUnit.SECONDS));
1:     }
1: 
commit:1b38b27
/////////////////////////////////////////////////////////////////////////
1:     public void testPublishWildcard31() throws Exception {
1:         testPublishWildcard("3.1");
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
1:     public void testPublishWildcard311() throws Exception {
1:         testPublishWildcard("3.1.1");
1:     }
1: 
1:     private void testPublishWildcard(String version) throws Exception {
1:         MQTT mqttPub = createMQTTConnection("MQTTPub-Client", true);
1:         mqttPub.setVersion(version);
1:         BlockingConnection blockingConnection = mqttPub.blockingConnection();
1:         blockingConnection.connect();
1:         String payload = "Test Message";
1:         try {
1:             blockingConnection.publish("foo/#", payload.getBytes(), QoS.AT_LEAST_ONCE, false);
1:             fail("Should not be able to publish with wildcard in topic.");
1:         } catch (Exception ex) {
1:             LOG.info("Exception expected on publish with wildcard in topic name");
1:         }
1:         try {
1:             blockingConnection.publish("foo/+", payload.getBytes(), QoS.AT_LEAST_ONCE, false);
1:             fail("Should not be able to publish with wildcard in topic.");
1:         } catch (Exception ex) {
1:             LOG.info("Exception expected on publish with wildcard in topic name");
1:         }
1:         blockingConnection.disconnect();
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
author:Timothy Bish
-------------------------------------------------------------------------------
commit:27799fe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5d6d42c
/////////////////////////////////////////////////////////////////////////
1:     public void testSubscribeWithZeroLengthTopic() throws Exception {
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
1: 
1:         Topic topic = new Topic("", QoS.EXACTLY_ONCE);
1: 
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         LOG.info("Trying to subscrobe to topic: {}", topic.name());
1: 
1:         try {
1:             connection.subscribe(new Topic[] { topic });
1:             fail("Should not be able to subscribe with invalid Topic");
1:         } catch (Exception ex) {
1:             LOG.info("Caught expected error on subscribe");
1:         }
1: 
1:         assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return !connection.isConnected();
1:             }
1:         }));
1:     }
1: 
1:     @Test(timeout = 30 * 10000)
1:     public void testUnsubscribeWithZeroLengthTopic() throws Exception {
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
1: 
1:         Topic topic = new Topic("", QoS.EXACTLY_ONCE);
1: 
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         LOG.info("Trying to subscrobe to topic: {}", topic.name());
1: 
1:         try {
1:             connection.unsubscribe(new String[] { topic.name().toString() });
1:             fail("Should not be able to subscribe with invalid Topic");
1:         } catch (Exception ex) {
1:             LOG.info("Caught expected error on subscribe");
1:         }
1: 
1:         assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1: 
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return !connection.isConnected();
1:             }
1:         }));
1:     }
1: 
1:     @Test(timeout = 30 * 10000)
1:     public void testSubscribeWithInvalidMultiLevelWildcards() throws Exception {
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
1: 
1:         Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE),
1:                            new Topic("#/Foo/#", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/#/Level", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/X#", QoS.EXACTLY_ONCE) };
1: 
1:         for (int i = 0; i < topics.length; ++i) {
1:             final BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1: 
1:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1: 
1:             try {
1:                 connection.subscribe(new Topic[] { topics[i] });
1:                 fail("Should not be able to subscribe with invalid Topic");
1:             } catch (Exception ex) {
1:                 LOG.info("Caught expected error on subscribe");
1:             }
1: 
1:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return !connection.isConnected();
1:                 }
1:             }));
1:         }
1:     }
1: 
1:     @Test(timeout = 30 * 10000)
1:     public void testSubscribeWithInvalidSingleLevelWildcards() throws Exception {
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
1: 
1:         Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE),
1:                            new Topic("+Foo/#", QoS.EXACTLY_ONCE),
1:                            new Topic("+#", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/+F", QoS.EXACTLY_ONCE) };
1: 
1:         for (int i = 0; i < topics.length; ++i) {
1:             final BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1: 
1:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1: 
1:             try {
1:                 connection.subscribe(new Topic[] { topics[i] });
1:                 fail("Should not be able to subscribe with invalid Topic");
1:             } catch (Exception ex) {
1:                 LOG.info("Caught expected error on subscribe");
1:             }
1: 
1:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return !connection.isConnected();
1:                 }
1:             }));
1:         }
1:     }
1: 
1:     @Test(timeout = 30 * 10000)
1:     public void testUnsubscribeWithInvalidMultiLevelWildcards() throws Exception {
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
1: 
1:         Topic[] topics = { new Topic("#/Foo", QoS.EXACTLY_ONCE),
1:                            new Topic("#/Foo/#", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/#/Level", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/X#", QoS.EXACTLY_ONCE) };
1: 
1:         for (int i = 0; i < topics.length; ++i) {
1:             final BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1: 
1:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1: 
1:             try {
1:                 connection.unsubscribe(new String[] { topics[i].name().toString() });
1:                 fail("Should not be able to unsubscribe with invalid Topic");
1:             } catch (Exception ex) {
1:                 LOG.info("Caught expected error on subscribe");
1:             }
1: 
1:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return !connection.isConnected();
1:                 }
1:             }));
1:         }
1:     }
1: 
1:     @Test(timeout = 30 * 10000)
1:     public void testUnsubscribeWithInvalidSingleLevelWildcards() throws Exception {
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
1: 
1:         Topic[] topics = { new Topic("Foo+", QoS.EXACTLY_ONCE),
1:                            new Topic("+Foo/#", QoS.EXACTLY_ONCE),
1:                            new Topic("+#", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/+X/Level", QoS.EXACTLY_ONCE),
1:                            new Topic("Foo/+F", QoS.EXACTLY_ONCE) };
1: 
1:         for (int i = 0; i < topics.length; ++i) {
1:             final BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1: 
1:             LOG.info("Trying to subscrobe to topic: {}", topics[i].name());
1: 
1:             try {
1:                 connection.unsubscribe(new String[] { topics[i].name().toString() });
1:                 fail("Should not be able to unsubscribe with invalid Topic");
1:             } catch (Exception ex) {
1:                 LOG.info("Caught expected error on subscribe");
1:             }
1: 
1:             assertTrue("Should have lost connection", Wait.waitFor(new Wait.Condition() {
1: 
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return !connection.isConnected();
1:                 }
1:             }));
1:         }
1:     }
1: 
1:     @Test(timeout = 30 * 10000)
commit:8ef4445
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
0:     @Ignore("Needs fix in MQTT client for string length decode.")
1:     @Test(timeout = 30 * 10000)
1:     public void testSubscribeWithLargeTopicFilter() throws Exception {
1: 
1:         byte[] payload = new byte[1024 * 32];
1:         for (int i = 0; i < payload.length; i++) {
1:             payload[i] = '2';
1:         }
1: 
1:         StringBuilder topicBuilder = new StringBuilder("/topic/");
1: 
1:         for (int i = 0; i < 32800; ++i) {
1:             topicBuilder.append("a");
1:         }
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
1: 
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         Topic[] topic = { new Topic(topicBuilder.toString(), QoS.EXACTLY_ONCE) };
1:         connection.subscribe(topic);
1:         connection.publish(topic[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1: 
1:         Message message = connection.receive();
1:         assertNotNull(message);
1:         message.ack();
1:     }
1: 
commit:c530b69
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 30 * 1000)
1:     public void testConnectWithUserButNoPassword() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("test");
1:         mqtt.setUserName("foo");
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         connection.disconnect();
1:     }
1: 
1:     @Test(timeout = 30 * 1000)
1:     public void testConnectWithPasswordButNoUsername() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setVersion("3.1.1"); // The V3.1 spec doesn't make the same assertion
1:         mqtt.setClientId("test");
1:         mqtt.setPassword("bar");
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1: 
1:         try {
1:             connection.connect();
1:             fail("Should not be able to connect in this case.");
1:         } catch (Exception ex) {
1:             LOG.info("Exception expected on connect with password but no username");
1:         }
1:     }
1: 
commit:47e954d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         doTestRetainedMessages("TopicA");
1:         doTestRetainedMessages("VirtualTopic/TopicA");
1:     }
1: 
1:     public void doTestRetainedMessages(String topicName) throws Exception {
1:         final String TOPICA = topicName;
1:             boolean cleanSession = !"durable".equals(clientId);
1:             LOG.info("Testing now with Client ID: {} clean: {}", clientId, cleanSession);
1:             mqtt.setCleanSession(cleanSession);
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Performing first subscription");
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Performing second subscription");
commit:fd2805f
/////////////////////////////////////////////////////////////////////////
1:         restartBroker();
commit:101b712
/////////////////////////////////////////////////////////////////////////
1:     private static final int NUM_MESSAGES = 200;
/////////////////////////////////////////////////////////////////////////
1:             byte[] message = provider.receive(2000);
/////////////////////////////////////////////////////////////////////////
1:             Message msg = connection.receive(2, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Client received:\n" + frame);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Client sent:\n" + frame);
/////////////////////////////////////////////////////////////////////////
1:         Message msg = connection.receive(2000, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:             msg = connection.receive(2000, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Client received:\n" + frame);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Client sent:\n" + frame);
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(100));
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(5), TimeUnit.MILLISECONDS.toMillis(100));
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Client received:\n" + frame);
1:                         LOG.debug("PUBLISH " + publish);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Client sent:\n" + frame);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Client received:\n" + frame);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Client sent:\n" + frame);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(Wait.waitFor(new Wait.Condition() {
1:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
1:         //Thread.sleep(2000);
1:         //connection.subscribe(new Topic[]{new Topic("TopicA", QoS.AT_LEAST_ONCE)});
/////////////////////////////////////////////////////////////////////////
1:         msg = clean.receive(2000, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:         Message message = connection.receive(3, TimeUnit.SECONDS);
1: 
/////////////////////////////////////////////////////////////////////////
1:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
1:         }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(100)));
/////////////////////////////////////////////////////////////////////////
1:             }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(200)));
1:                 }, TimeUnit.SECONDS.toMillis(30), TimeUnit.MILLISECONDS.toMillis(200)));
/////////////////////////////////////////////////////////////////////////
1:             Thread.sleep(500);
1:             Thread.sleep(500);
/////////////////////////////////////////////////////////////////////////
1:         assertNull(connectionSub.receive(2, TimeUnit.SECONDS));
commit:74d2c24
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testReceiveMessageSentWhileOfflineAndBrokerRestart() throws Exception {
1:         stopBroker();
1:         this.persistent = true;
1:         startBroker();
1: 
1:         final byte[] payload = new byte[1024 * 32];
1:         for (int i = 0; i < payload.length; i++) {
1:             payload[i] = '2';
1:         }
1: 
1:         int messagesPerRun = 10;
1: 
1:         Topic[] topics = { new Topic("TopicA", QoS.EXACTLY_ONCE) };
1: 
1:         {
1:             // Establish a durable subscription.
1:             MQTT mqttSub = createMQTTConnection("MQTT-Sub-Client", false);
1:             BlockingConnection connectionSub = mqttSub.blockingConnection();
1:             connectionSub.connect();
1:             connectionSub.subscribe(topics);
1:             connectionSub.disconnect();
1:         }
1: 
1:         MQTT mqttPubLoop = createMQTTConnection("MQTT-Pub-Client", true);
1:         BlockingConnection connectionPub = mqttPubLoop.blockingConnection();
1:         connectionPub.connect();
1: 
1:         for (int i = 0; i < messagesPerRun; ++i) {
1:             connectionPub.publish(topics[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
1:         }
1: 
1:         connectionPub.disconnect();
1: 
1:         stopBroker();
1:         startBroker();
1: 
1:         MQTT mqttSub = createMQTTConnection("MQTT-Sub-Client", false);
1:         BlockingConnection connectionSub = mqttSub.blockingConnection();
1:         connectionSub.connect();
1:         connectionSub.subscribe(topics);
1: 
1:         for (int i = 0; i < messagesPerRun; ++i) {
1:             Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:             assertNotNull(message);
0:             assertTrue(Arrays.equals(payload, message.getPayload()));
1:             message.ack();
1:         }
1:         connectionSub.disconnect();
1:     }
1: 
commit:62c20eb
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicReference;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testRepeatedLinkStealing() throws Exception {
1:         final String clientId = "duplicateClient";
1:         final AtomicReference<BlockingConnection> oldConnection = new AtomicReference<BlockingConnection>();
1:         final String TOPICA = "TopicA";
1: 
1:         for (int i = 1; i <= 10; ++i) {
1: 
1:             LOG.info("Creating MQTT Connection {}", i);
1: 
1:             MQTT mqtt = createMQTTConnection(clientId, false);
1:             mqtt.setKeepAlive((short) 2);
1:             final BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1:             connection.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1: 
1:             assertTrue("Client connect failed for attempt: " + i, Wait.waitFor(new Wait.Condition() {
1:                 @Override
1:                 public boolean isSatisified() throws Exception {
1:                     return connection.isConnected();
1:                 }
1:             }));
1: 
1:             if (oldConnection.get() != null) {
1: 
1:                 assertTrue("Old client still connected", Wait.waitFor(new Wait.Condition() {
1:                     @Override
1:                     public boolean isSatisified() throws Exception {
1:                         return !oldConnection.get().isConnected();
1:                     }
1:                 }));
1:             }
1: 
1:             oldConnection.set(connection);
1:         }
1: 
1:         oldConnection.get().publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:         oldConnection.get().disconnect();
1:     }
1: 
commit:413e484
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
/////////////////////////////////////////////////////////////////////////
1:         latch.await(20, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
1:         mqtt.setKeepAlive((short) 60);
0:             LOG.info("Testing now with Client ID: {}", clientId);
/////////////////////////////////////////////////////////////////////////
0:     @Ignore
1:     @Test(timeout = 120 * 1000)
1:     public void testRetainedMessageOnVirtualTopics() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive((short) 60);
1: 
1:         final String RETAIN = "RETAIN";
0:         final String TOPICA = "VirtualTopic/TopicA";
1: 
1:         final String[] clientIds = { null, "foo", "durable" };
1:         for (String clientId : clientIds) {
0:             LOG.info("Testing now with Client ID: {}", clientId);
1: 
1:             mqtt.setClientId(clientId);
0:             mqtt.setCleanSession(!"durable".equals(clientId));
1: 
1:             BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1: 
1:             // set retained message and check
1:             connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
1:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:             assertNotNull("No retained message for " + clientId, msg);
1:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
1:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1: 
1:             // test duplicate subscription
1:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
1:             msg = connection.receive(15000, TimeUnit.MILLISECONDS);
1:             assertNotNull("No retained message on duplicate subscription for " + clientId, msg);
1:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
1:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1:             connection.unsubscribe(new String[]{TOPICA});
1: 
1:             // clear retained message and check that we don't receive it
1:             connection.publish(TOPICA, "".getBytes(), QoS.AT_MOST_ONCE, true);
1:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
1:             msg = connection.receive(500, TimeUnit.MILLISECONDS);
1:             assertNull("Retained message not cleared for " + clientId, msg);
1:             connection.unsubscribe(new String[]{TOPICA});
1: 
1:             // set retained message again and check
1:             connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
1:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:             assertNotNull("No reset retained message for " + clientId, msg);
1:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
1:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1: 
1:             // re-connect and check
1:             connection.disconnect();
1:             connection = mqtt.blockingConnection();
1:             connection.connect();
1:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:             assertNotNull("No reset retained message for " + clientId, msg);
1:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
1:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
1: 
1:             LOG.info("Test now unsubscribing from: {} for the last time", TOPICA);
1:             connection.unsubscribe(new String[]{TOPICA});
1:             connection.disconnect();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         doTestSendMQTTReceiveJMS("foo.*");
1:     }
1: 
1:     public void doTestSendMQTTReceiveJMS(String destinationName) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         javax.jms.Topic jmsTopic = s.createTopic(destinationName);
/////////////////////////////////////////////////////////////////////////
1:         doTestSendJMSReceiveMQTT("foo.far");
1:     }
1: 
1:     public void doTestSendJMSReceiveMQTT(String destinationName) throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         javax.jms.Topic jmsTopic = s.createTopic(destinationName);
/////////////////////////////////////////////////////////////////////////
1:         doTestJmsMapping("test.foo");
1:     }
1: 
1:     public void doTestJmsMapping(String destinationName) throws Exception {
1:         Destination dest = session.createTopic(destinationName);
commit:5de0c8e
/////////////////////////////////////////////////////////////////////////
0:             connection.unsubscribe(new String[]{TOPICA});
0:             connection.unsubscribe(new String[]{TOPICA});
/////////////////////////////////////////////////////////////////////////
0:             connection.unsubscribe(new String[]{TOPICA});
commit:829a186
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f55edcf
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.Queue;
1: import org.apache.activemq.ActiveMQConnectionFactory;
/////////////////////////////////////////////////////////////////////////
1:     public void testSendMQTTReceiveJMSVirtualTopic() throws Exception {
1: 
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
1:         final String DESTINATION_NAME = "Consumer.jms.VirtualTopic.TopicA";
1: 
1:         // send retained message
1:         final String RETAINED = "RETAINED";
1:         final String MQTT_DESTINATION_NAME = "VirtualTopic/TopicA";
1:         provider.publish(MQTT_DESTINATION_NAME, RETAINED.getBytes(), AT_LEAST_ONCE, true);
1: 
1:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory(jmsUri).createConnection();
1:         // MUST set to true to receive retained messages
1:         activeMQConnection.setUseRetroactiveConsumer(true);
1:         activeMQConnection.start();
1:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
1:         Queue jmsQueue = s.createQueue(DESTINATION_NAME);
1:         MessageConsumer consumer = s.createConsumer(jmsQueue);
1: 
1:         // check whether we received retained message on JMS subscribe
1:         ActiveMQMessage message = (ActiveMQMessage) consumer.receive(5000);
1:         assertNotNull("Should get retained message", message);
1:         ByteSequence bs = message.getContent();
1:         assertEquals(RETAINED, new String(bs.data, bs.offset, bs.length));
1:         assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));
1: 
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:             String payload = "Test Message: " + i;
1:             provider.publish(MQTT_DESTINATION_NAME, payload.getBytes(), AT_LEAST_ONCE);
1:             message = (ActiveMQMessage) consumer.receive(5000);
1:             assertNotNull("Should get a message", message);
1:             bs = message.getContent();
1:             assertEquals(payload, new String(bs.data, bs.offset, bs.length));
1:         }
1: 
1:         // re-create consumer and check we received retained message again
1:         consumer.close();
1:         consumer = s.createConsumer(jmsQueue);
1:         message = (ActiveMQMessage) consumer.receive(5000);
1:         assertNotNull("Should get retained message", message);
1:         bs = message.getContent();
1:         assertEquals(RETAINED, new String(bs.data, bs.offset, bs.length));
1:         assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));
1: 
1:         activeMQConnection.close();
1:         provider.disconnect();
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
commit:b11fc8f
/////////////////////////////////////////////////////////////////////////
1: import static org.junit.Assert.assertArrayEquals;
1: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNotEquals;
1: import static org.junit.Assert.assertNotNull;
1: import static org.junit.Assert.assertNull;
1: import static org.junit.Assert.assertTrue;
1: import static org.junit.Assert.fail;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         final BlockingConnection connection1 = mqtt1.blockingConnection();
1:         assertTrue("Duplicate client disconnected", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return connection1.isConnected();
1:             }
1:         }));
1: 
1:         assertTrue("Old client still connected", Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return !connection.isConnected();
1:             }
1:         }));
1: 
/////////////////////////////////////////////////////////////////////////
1:         final BlockingConnection connection2 = mqtt.blockingConnection();
1:         connection2.connect();
1:         connection2.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:         final BlockingConnection connection3 = mqtt1.blockingConnection();
1:             connection3.connect();
1:         assertTrue("Old client disconnected", connection2.isConnected());
1:         connection2.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:         connection2.disconnect();
commit:8d04e2b
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNotEquals;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:fb569e3
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNotEquals;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
1: 
0: import java.util.Collection;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.junit.runner.RunWith;
0: import org.junit.runners.Parameterized;
0: import org.junit.runners.Parameterized.Parameters;
0: @RunWith(Parameterized.class)
1: public class MQTTTest extends MQTTTestSupport {
0:     private static final int NUM_MESSAGES = 250;
1: 
0:     @Parameters(name= "{index}: scheme({0})")
0:     public static Collection<Object[]> data() {
0:         return Arrays.asList(new Object[][] {
0:                 {"mqtt", false},
0:                 {"mqtt+ssl", true},
0:                 {"mqtt+nio", false}
0:                 // TODO - Fails {"mqtt+nio+ssl", true}
1:             });
1:     }
1: 
1:         final CountDownLatch latch = new CountDownLatch(NUM_MESSAGES);
1:                 for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         final CountDownLatch latch = new CountDownLatch(NUM_MESSAGES / 2);
1:                 for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
1:             if (i == NUM_MESSAGES / 2) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
1:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) cf.createConnection();
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < NUM_MESSAGES; i++) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         stopBroker();
1:         protocolConfig = "transport.useInactivityMonitor=false";
1:         startBroker();
1: 
/////////////////////////////////////////////////////////////////////////
1:         Connection jmsConn = cf.createConnection();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         stopBroker();
1:         protocolConfig = "transport.defaultKeepAlive=2000";
1:         startBroker();
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testPingOnMQTT() throws Exception {
1:         stopBroker();
1:         protocolConfig = "maxInactivityDuration=-1";
1:         startBroker();
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("test-mqtt");
0:         mqtt.setKeepAlive((short)2);
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
1:             public boolean isSatisified() throws Exception {
1:                 return connection.isConnected();
0:         }));
1:         connection.disconnect();
commit:f4a8b11
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertNotEquals;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:         subscriptionProvider.subscribe("foo/bah", AT_MOST_ONCE);
0:                 for (int i = 0; i < numberOfMessages; i++) {
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             publishProvider.publish("foo/bah", payload.getBytes(), AT_LEAST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:         final CountDownLatch latch = new CountDownLatch(numberOfMessages / 2);
0:                 for (int i = 0; i < numberOfMessages; i++) {
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < numberOfMessages; i++) {
0:             if (i == numberOfMessages / 2) {
1:             publishProvider.publish(topic, payload.getBytes(), AT_LEAST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:          * with AT_MOST_ONCE - in MQTT the QoS is always determined by the
1:          * message as published - not the wish of the subscriber
1:         provider.subscribe("foo", EXACTLY_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:         provider.subscribe("foo", EXACTLY_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:         provider.subscribe("foo", AT_MOST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:         provider.subscribe("foo", AT_MOST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:         provider.subscribe("foo", AT_LEAST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         subscriber.subscribe("foo", EXACTLY_ONCE);
1:             assertNotNull("Should get a message + [" + i + "]", message);
1:     @Test(timeout = 60 * 1000)
1:         for (int i = 0; i < payload.length; i++) {
/////////////////////////////////////////////////////////////////////////
1:         subscriber.subscribe("foo", AT_LEAST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 10; i++) {
1:         subscriber.subscribe("foo", AT_LEAST_ONCE);
1:         assertEquals(RETAINED, new String(msg));
1:         for (int i = 0; i < 10; i++) {
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 30 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         String[] topics = { "TopicA", "/TopicA", "/", "TopicA/", "//" };
1:             connection.subscribe(new Topic[] { new Topic(topic, QoS.AT_LEAST_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:             connection.unsubscribe(new String[] { topic });
1:         String[] wildcards = { "#", "+", "+/#", "/+", "+/", "+/+", "+/+/", "+/+/+" };
0:             connection.subscribe(new Topic[] { new Topic(wildcard, QoS.AT_LEAST_ONCE) });
1:                 assertTrue("RETAINED matching " + wildcard + " " + msg.getTopic(), pattern.matcher(msg.getTopic()).matches());
/////////////////////////////////////////////////////////////////////////
0:             connection.subscribe(new Topic[] { new Topic(wildcard, QoS.AT_LEAST_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:                 assertTrue("Non-retained matching " + wildcard + " " + msg.getTopic(), pattern.matcher(msg.getTopic()).matches());
/////////////////////////////////////////////////////////////////////////
1:             mqtt.setKeepAlive((short) 2);
1:             final int[] actualQoS = { -1 };
/////////////////////////////////////////////////////////////////////////
0:             connection.subscribe(new Topic[] { new Topic(topic, QoS.valueOf(topic)) });
/////////////////////////////////////////////////////////////////////////
0:             connection.unsubscribe(new String[] { topic });
/////////////////////////////////////////////////////////////////////////
1:         mqtt.setKeepAlive((short) 2);
1:         final int[] actualQoS = { -1 };
/////////////////////////////////////////////////////////////////////////
0:             connection.subscribe(new Topic[] { new Topic("TopicA", qos) });
/////////////////////////////////////////////////////////////////////////
1:         connection.unsubscribe(new String[] { "TopicA" });
/////////////////////////////////////////////////////////////////////////
0:         brokerService.setPlugins(new BrokerPlugin[] { authorizationPlugin, authenticationPlugin });
/////////////////////////////////////////////////////////////////////////
0:         byte[] qos = connection.subscribe(new Topic[] { new Topic(NAMED, QoS.AT_MOST_ONCE), new Topic(ANONYMOUS, QoS.EXACTLY_ONCE) });
0:         assertEquals((byte) 0x80, qos[0]);
0:         assertEquals((byte) QoS.EXACTLY_ONCE.ordinal(), qos[1]);
/////////////////////////////////////////////////////////////////////////
0:         connection.unsubscribe(new String[] { ANONYMOUS });
0:         qos = connection.subscribe(new Topic[] { new Topic(ANONYMOUS, QoS.AT_LEAST_ONCE) });
0:         assertEquals((byte) QoS.AT_LEAST_ONCE.ordinal(), qos[0]);
/////////////////////////////////////////////////////////////////////////
1:         String[] subs = { TOPIC, "TopicA/#", "TopicA/+" };
1:             connection.subscribe(new Topic[] { new Topic(subs[i], qoss[i]) });
/////////////////////////////////////////////////////////////////////////
1:         // make sure we received distinct ids for QoS != AT_MOST_ONCE, and 0 for
1:         // AT_MOST_ONCE
/////////////////////////////////////////////////////////////////////////
1:         final String[] topics = new String[] { TOPIC, "TopicA/+" };
1:         connection.subscribe(new Topic[] { new Topic(topics[0], QoS.AT_LEAST_ONCE), new Topic(topics[1], QoS.EXACTLY_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(publishList.get(0).messageId() == publishList.get(2).messageId() || publishList.get(0).messageId() == publishList.get(3).messageId());
1:         assertTrue(publishList.get(1).messageId() == publishList.get(3).messageId() || publishList.get(1).messageId() == publishList.get(2).messageId());
/////////////////////////////////////////////////////////////////////////
1:         connection.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:         final String[] cleanClientIds = new String[] { "", "clean-packetid", null };
/////////////////////////////////////////////////////////////////////////
1:             connection.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:         final byte[] qos = connection.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:         notClean.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:         clean.subscribe(new Topic[] { new Topic(TOPIC, QoS.EXACTLY_ONCE) });
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         provider.subscribe("foo/+", AT_MOST_ONCE);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:         mqtt.setKeepAlive((short) 2);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testTurnOffInactivityMonitor() throws Exception {
1:         mqtt.setKeepAlive((short) 2);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 30 * 10000)
/////////////////////////////////////////////////////////////////////////
1:         mqtt.setKeepAlive((short) 2);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 30 * 10000)
/////////////////////////////////////////////////////////////////////////
1:         Topic[] topics = { new Topic("Topic/A", QoS.EXACTLY_ONCE), new Topic("Topic/B", QoS.EXACTLY_ONCE) };
1:         Topic[] wildcardTopic = { new Topic("Topic/#", QoS.AT_LEAST_ONCE) };
/////////////////////////////////////////////////////////////////////////
1:             LOG.info("Received message from topic: " + message.getTopic() + " Message content: " + messageContent);
1:     @Test(timeout = 60 * 1000)
1:         for (int i = 0; i < payload.length; i++) {
/////////////////////////////////////////////////////////////////////////
1:         Topic[] topics = { new Topic("TopicA", QoS.EXACTLY_ONCE) };
/////////////////////////////////////////////////////////////////////////
0:         for (int j = 0; j < numberOfRuns; j++) {
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 30 * 1000)
1:         mqtt.setKeepAlive((short) 0);
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testNoMessageReceivedAfterUnsubscribeMQTT() throws Exception {
0:         addMQTTConnector();
0:         brokerService.setPersistent(true);
0:         brokerService.start();
1:         Topic[] topics = { new Topic("TopicA", QoS.EXACTLY_ONCE) };
1: 
1:         MQTT mqttPub = createMQTTConnection("MQTTPub-Client", true);
1:         // mqttPub.setVersion("3.1.1");
1: 
1:         MQTT mqttSub = createMQTTConnection("MQTTSub-Client", false);
1:         // mqttSub.setVersion("3.1.1");
1: 
1:         BlockingConnection connectionPub = mqttPub.blockingConnection();
1:         connectionPub.connect();
1: 
1:         BlockingConnection connectionSub = mqttSub.blockingConnection();
1:         connectionSub.connect();
1:         connectionSub.subscribe(topics);
0:         connectionSub.unsubscribe(new String[] { "TopicA" });
1:         connectionSub.disconnect();
1: 
1:         for (int i = 0; i < 10; i++) {
1:             String payload = "Message " + i;
1:             connectionPub.publish(topics[0].name().toString(), payload.getBytes(), QoS.EXACTLY_ONCE, false);
1:         }
1: 
1:         connectionSub = mqttSub.blockingConnection();
1:         connectionSub.connect();
1: 
1:         int received = 0;
0:         for (int i = 0; i < 10; ++i) {
1:             Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:             assertNotNull(message);
1:             LOG.info("Message is " + new String(message.getPayload()));
1:             received++;
1:             message.ack();
1:         }
0:         assertEquals(10, received);
1: 
1:         connectionSub.disconnect();
1:         connectionPub.disconnect();
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
1:     public void testMQTT311Connection() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("foo");
0:         mqtt.setVersion("3.1.1");
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         connection.disconnect();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         return new Tracer() {
0:                 LOG.info("Client Received:\n" + frame);
/////////////////////////////////////////////////////////////////////////
commit:45c0dfb
/////////////////////////////////////////////////////////////////////////
1:         BlockingConnection connection = mqtt.blockingConnection();
0:         final String[] topics = new String[] {TOPIC, "TopicA/+"};
0:         connection.subscribe(new Topic[]{new Topic(topics[0], QoS.AT_LEAST_ONCE), new Topic(topics[1], QoS.EXACTLY_ONCE)});
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return publishList.size() == 2;
1:             }
0:         }, 5000);
1:         assertEquals(2, publishList.size());
1:         connection.disconnect();
1:         connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return publishList.size() == 4;
1:             }
0:         }, 5000);
1:         assertEquals(4, publishList.size());
0:         assertTrue(publishList.get(0).messageId() == publishList.get(2).messageId() ||
0:             publishList.get(0).messageId() == publishList.get(3).messageId());
0:         assertTrue(publishList.get(1).messageId() == publishList.get(3).messageId() ||
0:             publishList.get(1).messageId() == publishList.get(2).messageId());
1:         assertTrue(publishList.get(2).dup() && publishList.get(3).dup());
1: 
1:         connection.unsubscribe(topics);
1:         connection.disconnect();
1:     }
1: 
1:     @Test(timeout = 90 * 1000)
1:     public void testPacketIdGeneratorNonCleanSession() throws Exception {
0:         addMQTTConnector("trace=true");
0:         brokerService.start();
1: 
1:         final MQTT mqtt = createMQTTConnection("nonclean-packetid", false);
1:         mqtt.setKeepAlive((short) 15);
1: 
1:         final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<Short, PUBLISH>();
1:         mqtt.setTracer(new Tracer() {
1:             @Override
1:             public void onReceive(MQTTFrame frame) {
0:                 LOG.info("Client received:\n" + frame);
1:                 if (frame.messageType() == PUBLISH.TYPE) {
1:                     PUBLISH publish = new PUBLISH();
1:                     try {
1:                         publish.decode(frame);
1:                         LOG.info("PUBLISH " + publish);
1:                     } catch (ProtocolException e) {
1:                         fail("Error decoding publish " + e.getMessage());
1:                     }
1:                     if (publishMap.get(publish.messageId()) != null) {
1:                         assertTrue(publish.dup());
1:                     }
1:                     publishMap.put(publish.messageId(), publish);
1:                 }
1:             }
1: 
1:             @Override
1:             public void onSend(MQTTFrame frame) {
0:                 LOG.info("Client sent:\n" + frame);
1:             }
1:         });
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         final String TOPIC = "TopicA/";
0:         connection.subscribe(new Topic[]{new Topic(TOPIC, QoS.EXACTLY_ONCE)});
1: 
1:         // publish non-retained messages
1:         final int TOTAL_MESSAGES = 10;
1:         for (int i = 0; i < TOTAL_MESSAGES; i++) {
1:             connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
1:         }
1: 
1:         // receive half the messages in this session
1:         for (int i = 0; i < TOTAL_MESSAGES / 2; i++) {
1:             final Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:             assertNotNull(msg);
0:             assertEquals(TOPIC, new String(msg.getPayload()));
1:             msg.ack();
1:         }
1: 
1:         connection.disconnect();
1:         // resume session
1:         connection = mqtt.blockingConnection();
1:         connection.connect();
1:         // receive rest of the messages
1:         Message msg = null;
1:         do {
1:             msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:             if (msg != null) {
0:                 assertEquals(TOPIC, new String(msg.getPayload()));
1:                 msg.ack();
1:             }
1:         } while (msg != null);
1: 
1:         // make sure we received all message ids
1:         for (short id = 1; id <= TOTAL_MESSAGES; id++) {
1:             assertNotNull("No message for id " + id, publishMap.get(id));
1:         }
1:     @Test(timeout = 90 * 1000)
1:     public void testPacketIdGeneratorCleanSession() throws Exception {
0:         addMQTTConnector("trace=true");
0:         brokerService.start();
1: 
0:         final String[] cleanClientIds = new String[] { "", "clean-packetid", null};
1:         final Map<Short, PUBLISH> publishMap = new ConcurrentHashMap<Short, PUBLISH>();
1:         MQTT[] mqtts = new MQTT[cleanClientIds.length];
1:         for (int i = 0; i < cleanClientIds.length; i++) {
1:             mqtts[i] = createMQTTConnection("", true);
1:             mqtts[i].setKeepAlive((short) 15);
1: 
1:             mqtts[i].setTracer(new Tracer() {
1:                 @Override
1:                 public void onReceive(MQTTFrame frame) {
0:                     LOG.info("Client received:\n" + frame);
1:                     if (frame.messageType() == PUBLISH.TYPE) {
1:                         PUBLISH publish = new PUBLISH();
1:                         try {
1:                             publish.decode(frame);
1:                             LOG.info("PUBLISH " + publish);
1:                         } catch (ProtocolException e) {
1:                             fail("Error decoding publish " + e.getMessage());
1:                         }
1:                         if (publishMap.get(publish.messageId()) != null) {
1:                             assertTrue(publish.dup());
1:                         }
1:                         publishMap.put(publish.messageId(), publish);
1:                     }
1:                 }
1: 
1:                 @Override
1:                 public void onSend(MQTTFrame frame) {
0:                     LOG.info("Client sent:\n" + frame);
1:                 }
1:             });
1:         }
1: 
1:         final Random random = new Random();
1:         for (short i = 0; i < 10; i++) {
1:             BlockingConnection connection = mqtts[random.nextInt(cleanClientIds.length)].blockingConnection();
1:             connection.connect();
1:             final String TOPIC = "TopicA/";
0:             connection.subscribe(new Topic[]{new Topic(TOPIC, QoS.EXACTLY_ONCE)});
1: 
1:             // publish non-retained message
1:             connection.publish(TOPIC, TOPIC.getBytes(), QoS.EXACTLY_ONCE, false);
0:             Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:             assertNotNull(msg);
0:             assertEquals(TOPIC, new String(msg.getPayload()));
1:             msg.ack();
1: 
1:             assertEquals(1, publishMap.size());
1:             final short id = (short) (i + 1);
1:             assertNotNull("No message for id " + id, publishMap.get(id));
1:             publishMap.clear();
1: 
1:             connection.disconnect();
1:         }
1: 
1:     }
1: 
commit:afddc1a
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import java.util.Random;
1: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector("trace=true");
1:         mqtt.setKeepAlive((short) 5);
commit:7e56f34
/////////////////////////////////////////////////////////////////////////
1:         publisher.publish("foo", RETAINED.getBytes(), AT_LEAST_ONCE, true);
/////////////////////////////////////////////////////////////////////////
1:             assertEquals(messages.get(i), new String(msg));
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testDuplicateSubscriptions() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("foo");
0:         mqtt.setKeepAlive((short)2);
1: 
0:         final int[] actualQoS = {-1};
1:         mqtt.setTracer(new Tracer() {
1:             @Override
1:             public void onReceive(MQTTFrame frame) {
1:                 // validate the QoS
1:                 if (frame.messageType() == PUBLISH.TYPE) {
0:                     PUBLISH publish = new PUBLISH();
1:                     try {
0:                         publish.decode(frame);
0:                     } catch (ProtocolException e) {
0:                         fail("Failed decoding " + e.getMessage());
1:                     }
0:                     actualQoS[0] = publish.qos().ordinal();
1:                 }
1:             }
1:         });
1: 
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         final String RETAIN = "RETAIN";
1:         connection.publish("TopicA", RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
1: 
1:         QoS[] qoss = { QoS.AT_MOST_ONCE, QoS.AT_MOST_ONCE, QoS.AT_LEAST_ONCE, QoS.EXACTLY_ONCE };
1:         for (QoS qos : qoss) {
0:             connection.subscribe(new Topic[]{ new Topic("TopicA", qos) });
1: 
1:             final Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:             assertNotNull(msg);
1:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             int waitCount = 0;
1:             while (actualQoS[0] == -1 && waitCount < 10) {
1:                 Thread.sleep(1000);
1:                 waitCount++;
1:             }
1:             assertEquals(qos.ordinal(), actualQoS[0]);
1:         }
1: 
0:         connection.unsubscribe(new String[]{"TopicA"});
1:         connection.disconnect();
1: 
1:     }
1: 
commit:0db7e69
/////////////////////////////////////////////////////////////////////////
0: import java.net.ProtocolException;
/////////////////////////////////////////////////////////////////////////
1: 
0: import static org.junit.Assert.assertArrayEquals;
/////////////////////////////////////////////////////////////////////////
1: import org.fusesource.mqtt.codec.PUBLISH;
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 60 * 1000)
1:     public void testMQTTRetainQoS() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         String[] topics = { "AT_MOST_ONCE", "AT_LEAST_ONCE", "EXACTLY_ONCE" };
1:         for (int i = 0; i < topics.length; i++) {
1:             final String topic = topics[i];
1: 
1:             MQTT mqtt = createMQTTConnection();
1:             mqtt.setClientId("foo");
0:             mqtt.setKeepAlive((short)2);
1: 
0:             final int[] actualQoS = {-1};
1:             mqtt.setTracer(new Tracer() {
1:                 @Override
1:                 public void onReceive(MQTTFrame frame) {
1:                     // validate the QoS
1:                     if (frame.messageType() == PUBLISH.TYPE) {
0:                         PUBLISH publish = new PUBLISH();
1:                         try {
0:                             publish.decode(frame);
0:                         } catch (ProtocolException e) {
0:                             fail ("Failed decoding " + e.getMessage());
1:                         }
0:                         actualQoS[0] = publish.qos().ordinal();
1:                     }
1:                 }
1:             });
1: 
1:             final BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1:             connection.publish(topic, topic.getBytes(), QoS.EXACTLY_ONCE, true);
0:             connection.subscribe(new Topic[]{ new Topic(topic, QoS.valueOf(topic)) });
1: 
1:             final Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
1:             assertNotNull(msg);
1:             assertEquals(topic, new String(msg.getPayload()));
1:             int waitCount = 0;
1:             while (actualQoS[0] == -1 && waitCount < 10) {
0:                 Thread.sleep(1000);
1:                 waitCount++;
1:             }
1:             assertEquals(i, actualQoS[0]);
1: 
1:             connection.unsubscribe(new String[]{topic});
1:             connection.disconnect();
1:         }
1: 
1:     }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:6d20cba
/////////////////////////////////////////////////////////////////////////
1:     public void testMQTTCompositeDestinations() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("");
1:         mqtt.setCleanSession(true);
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         Topic[] topics = {new Topic(utf8("a/1"), QoS.values()[AT_MOST_ONCE]), new Topic(utf8("a/2"), QoS.values()[AT_MOST_ONCE])};
1:         connection.subscribe(topics);
1: 
1:         String payload = "Test Message";
1:         String publishedTopic = "a/1,a/2";
1:         connection.publish(publishedTopic, payload.getBytes(), QoS.values()[AT_MOST_ONCE], false);
1: 
1:         Message msg = connection.receive(1, TimeUnit.SECONDS);
0:         assertNotNull(msg);
1:         assertEquals("a/2", msg.getTopic());
1: 
1:         msg = connection.receive(1, TimeUnit.SECONDS);
0:         assertNotNull(msg);
1:         assertEquals("a/1", msg.getTopic());
1: 
1:         msg = connection.receive(1, TimeUnit.SECONDS);
1:         assertNull(msg);
1: 
1:     }
1: 
1:     @Test(timeout = 2 *  60 * 1000)
commit:d547025
/////////////////////////////////////////////////////////////////////////
1:                 latch.await(20, TimeUnit.SECONDS);
commit:7948d69
/////////////////////////////////////////////////////////////////////////
1:     public void testNoClientId() throws Exception {
1:         final MQTT mqtt = createMQTTConnection("", true);
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return connection.isConnected();
1:             }
1:         });
1: 
1:         connection.subscribe(new Topic[]{new Topic("TopicA", QoS.AT_LEAST_ONCE)});
1:         connection.publish("TopicA", "test".getBytes(), QoS.AT_LEAST_ONCE, true);
1:         Message message = connection.receive(3, TimeUnit.SECONDS);
1:         assertNotNull(message);
0:         Thread.sleep(2000);
1:         connection.subscribe(new Topic[]{new Topic("TopicA", QoS.AT_LEAST_ONCE)});
1:         //TODO fix audit problem for retained messages
1:         //message = connection.receive(3, TimeUnit.SECONDS);
1:         //assertNotNull(message);
1:     }
1: 
1:     @Test(timeout = 60 * 1000)
commit:fc3d90e
/////////////////////////////////////////////////////////////////////////
1: import static org.fusesource.hawtbuf.UTF8Buffer.utf8;
/////////////////////////////////////////////////////////////////////////
1:     public void testMQTTWildcard() throws Exception {
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("");
1:         mqtt.setCleanSession(true);
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         Topic[] topics = {new Topic(utf8("a/#"), QoS.values()[AT_MOST_ONCE])};
1:         connection.subscribe(topics);
1:         String payload = "Test Message";
1:         String publishedTopic = "a/b/1.2.3*4>";
1:         connection.publish(publishedTopic, payload.getBytes(), QoS.values()[AT_MOST_ONCE], false);
1: 
1:         Message msg = connection.receive(1, TimeUnit.SECONDS);
1:         assertEquals("Topic changed", publishedTopic, msg.getTopic());
1:     }
1: 
1:     @Test(timeout = 2 *  60 * 1000)
commit:64baf09
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.filter.DestinationMapEntry;
0: import org.apache.activemq.security.*;
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
0:     public void testWildcardRetainedSubscription() throws Exception {
0:         addMQTTConnector();
1: 
0:         LinkedList<AuthenticationUser> users = new LinkedList<AuthenticationUser>();
0:         users.add(new AuthenticationUser("user", "user", "users"));
0:         users.add(new AuthenticationUser("admin", "admin", "admins"));
0:         final SimpleAuthenticationPlugin authenticationPlugin = new SimpleAuthenticationPlugin(users);
1: 
1: 
0:         DefaultAuthorizationMap map = new DefaultAuthorizationMap();
0:         LinkedList<DestinationMapEntry> authz = new LinkedList<DestinationMapEntry>();
1: 
0:         AuthorizationEntry entryOne = new AuthorizationEntry();
0:         entryOne.setDestination(new ActiveMQTopic("one"));
0:         entryOne.setAdmin("admins");
0:         entryOne.setRead("admins");
0:         entryOne.setWrite("admins");
0:         authz.add(entryOne);
1: 
0:         AuthorizationEntry entryTwo = new AuthorizationEntry();
0:         entryTwo.setDestination(new ActiveMQTopic("two"));
0:         entryTwo.setAdmin("users");
0:         entryTwo.setRead("users");
0:         entryTwo.setWrite("users");
0:         authz.add(entryTwo);
1: 
0:         map.setAuthorizationEntries(authz);
0:         AuthorizationPlugin authorizationPlugin = new AuthorizationPlugin(map);
1: 
0:         brokerService.setPlugins(new BrokerPlugin[] { authorizationPlugin, authenticationPlugin });
1: 
0:         brokerService.start();
1: 
0:         MQTT mqttPub = createMQTTConnection("pub", true);
0:         mqttPub.setUserName("admin");
0:         mqttPub.setPassword("admin");
1: 
0:         BlockingConnection connectionPub = mqttPub.blockingConnection();
1:         connectionPub.connect();
0:         connectionPub.publish("one", "test".getBytes(), QoS.AT_LEAST_ONCE, true);
1: 
0:         MQTT mqttSub = createMQTTConnection("sub", true);
0:         mqttSub.setUserName("user");
0:         mqttSub.setPassword("user");
1:         BlockingConnection connectionSub = mqttSub.blockingConnection();
1:         connectionSub.connect();
0:         connectionSub.subscribe(new Topic[]{new Topic("#", QoS.AT_LEAST_ONCE)});
0:         Message msg = connectionSub.receive(1, TimeUnit.SECONDS);
0:         assertNull("Shouldn't receive the message", msg);
1:     }
1: 
commit:9c67f0d
/////////////////////////////////////////////////////////////////////////
0:         final Topic[] topics = {new Topic(TOPIC, QoS.AT_LEAST_ONCE)};
0:         connection.subscribe(topics);
/////////////////////////////////////////////////////////////////////////
0:         connection.unsubscribe(new String[]{ TOPIC });
0:         connection.subscribe(topics);
0:         msg = connection.receive(30000, TimeUnit.MILLISECONDS);
0:         assertEquals(2, publishList.size());
0:         assertEquals(publishList.get(0).messageId(), publishList.get(1).messageId());
0:         assertTrue(publishList.get(0).dup() || publishList.get(1).dup());
1:         connection.unsubscribe(new String[] { TOPIC });
/////////////////////////////////////////////////////////////////////////
1:         final BlockingConnection connection = mqtt.blockingConnection();
0:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return connection.isConnected();
1:             }
1:         });
/////////////////////////////////////////////////////////////////////////
1:         final BlockingConnection newConnection = mqtt.blockingConnection();
1:         newConnection.connect();
0:         Wait.waitFor(new Wait.Condition() {
1:             @Override
1:             public boolean isSatisified() throws Exception {
1:                 return newConnection.isConnected();
1:             }
0:         });
1:         Message msg = newConnection.receive(1000, TimeUnit.MILLISECONDS);
1:         newConnection.disconnect();
commit:4ba4aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:         msg = connection.receive(1000, TimeUnit.MILLISECONDS);
0:         Thread.sleep(1000);
0:         Thread.sleep(1000);
0:         final Message msg2 = connection.receive(5000, TimeUnit.MILLISECONDS);
0:         assertNotNull(msg2);
0:         assertEquals(TOPIC, new String(msg2.getPayload()));
0:         // ack messages after receiving all of them
0:         msg2.ack();
/////////////////////////////////////////////////////////////////////////
1: }
commit:ac23b01
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.BrokerPlugin;
1: import org.apache.activemq.command.ActiveMQTopic;
0: import org.apache.activemq.jaas.GroupPrincipal;
0: import org.apache.activemq.security.AuthorizationPlugin;
0: import org.apache.activemq.security.DefaultAuthorizationMap;
0: import org.apache.activemq.security.SimpleAuthenticationPlugin;
0: import org.apache.activemq.security.SimpleAuthorizationMap;
/////////////////////////////////////////////////////////////////////////
0:     public void testFailedSubscription() throws Exception {
0:         addMQTTConnector();
1: 
0:         final SimpleAuthenticationPlugin authenticationPlugin = new SimpleAuthenticationPlugin();
0:         authenticationPlugin.setAnonymousAccessAllowed(true);
1: 
0:         final String ANONYMOUS = "anonymous";
0:         authenticationPlugin.setAnonymousGroup(ANONYMOUS);
0:         final DefaultAuthorizationMap map = new DefaultAuthorizationMap();
0:         // only one authorized destination, anonymous for anonymous group!
0:         map.put(new ActiveMQTopic(ANONYMOUS), new GroupPrincipal(ANONYMOUS));
0:         final AuthorizationPlugin authorizationPlugin = new AuthorizationPlugin(new SimpleAuthorizationMap(map, map, map));
1: 
0:         brokerService.setPlugins(new BrokerPlugin[] {authorizationPlugin, authenticationPlugin});
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("foo");
1:         mqtt.setKeepAlive((short) 2);
1: 
1:         final BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
0:         final String NAMED = "named";
0:         byte[] qos = connection.subscribe(new Topic[] {
0:             new Topic(NAMED, QoS.AT_MOST_ONCE), new Topic(ANONYMOUS, QoS.EXACTLY_ONCE)});
0:         assertEquals((byte)0x80, qos[0]);
0:         assertEquals((byte)QoS.EXACTLY_ONCE.ordinal(), qos[1]);
1: 
0:         // validate the subscription by sending a retained message
0:         connection.publish(ANONYMOUS, ANONYMOUS.getBytes(), QoS.AT_MOST_ONCE, true);
0:         Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
0:         assertNotNull(msg);
0:         assertEquals(ANONYMOUS, new String(msg.getPayload()));
1:         msg.ack();
1: 
0:         connection.unsubscribe(new String[]{ANONYMOUS});
0:         qos = connection.subscribe(new Topic[]{new Topic(ANONYMOUS, QoS.AT_LEAST_ONCE)});
0:         assertEquals((byte)QoS.AT_LEAST_ONCE.ordinal(), qos[0]);
1: 
1:         msg = connection.receive(1000, TimeUnit.MILLISECONDS);
0:         assertNotNull(msg);
0:         assertEquals(ANONYMOUS, new String(msg.getPayload()));
1:         msg.ack();
1: 
1:         connection.disconnect();
1:     }
1: 
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
author:Dhiraj Bokde
-------------------------------------------------------------------------------
commit:bba026a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertFalse;
0: import static org.junit.Assert.assertNotEquals;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
/////////////////////////////////////////////////////////////////////////
commit:e8c5a9f
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertFalse;
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
1:     public void testDuplicateClientId() throws Exception {
1:         // test link stealing enabled by default
1:         stopBroker();
1:         startBroker();
1: 
1:         final String clientId = "duplicateClient";
1:         MQTT mqtt = createMQTTConnection(clientId, false);
1:         mqtt.setKeepAlive((short) 2);
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         final String TOPICA = "TopicA";
1:         connection.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1: 
1:         MQTT mqtt1 = createMQTTConnection(clientId, false);
1:         mqtt1.setKeepAlive((short) 2);
0:         BlockingConnection connection1 = mqtt1.blockingConnection();
1:         connection1.connect();
1: 
0:         assertTrue("Duplicate client disconnected", connection1.isConnected());
0:         assertFalse("Old client still connected", connection.isConnected());
1:         connection1.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:         connection1.disconnect();
1: 
1:         // disable link stealing
1:         stopBroker();
1:         protocolConfig = "allowLinkStealing=false";
1:         startBroker();
1: 
1:         mqtt = createMQTTConnection(clientId, false);
1:         mqtt.setKeepAlive((short) 2);
1:         connection = mqtt.blockingConnection();
1:         connection.connect();
1:         connection.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1: 
1:         mqtt1 = createMQTTConnection(clientId, false);
1:         mqtt1.setKeepAlive((short) 2);
0:         connection1 = mqtt1.blockingConnection();
1:         try {
1:             connection1.connect();
1:             fail("Duplicate client connected");
1:         } catch (Exception e) {
1:             // ignore
1:         }
1: 
0:         assertTrue("Old client disconnected", connection.isConnected());
1:         connection.publish(TOPICA, TOPICA.getBytes(), QoS.EXACTLY_ONCE, true);
1:         connection.disconnect();
1:     }
1: 
commit:73908d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNotEquals;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertNull;
0: import static org.junit.Assert.assertTrue;
0: import static org.junit.Assert.fail;
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
1:     public void testPublishDollarTopics() throws Exception {
0:         stopBroker();
0:         startBroker();
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         final String clientId = "publishDollar";
1:         mqtt.setClientId(clientId);
1:         mqtt.setKeepAlive((short) 2);
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         final String DOLLAR_TOPIC = "$TopicA";
1:         connection.subscribe(new Topic[] { new Topic(DOLLAR_TOPIC, QoS.EXACTLY_ONCE)});
1:         connection.publish(DOLLAR_TOPIC, DOLLAR_TOPIC.getBytes(), QoS.EXACTLY_ONCE, true);
1: 
0:         Message message = connection.receive(10, TimeUnit.SECONDS);
1:         assertNull("Publish enabled for $ Topics by default", message);
1:         connection.disconnect();
1: 
0:         stopBroker();
1:         protocolConfig = "transport.publishDollarTopics=true";
0:         startBroker();
1: 
1:         mqtt = createMQTTConnection();
1:         mqtt.setClientId(clientId);
1:         mqtt.setKeepAlive((short) 2);
0:         connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         connection.subscribe(new Topic[] { new Topic(DOLLAR_TOPIC, QoS.EXACTLY_ONCE)});
1:         connection.publish(DOLLAR_TOPIC, DOLLAR_TOPIC.getBytes(), QoS.EXACTLY_ONCE, true);
1: 
1:         message = connection.receive(10, TimeUnit.SECONDS);
1:         assertNotNull(message);
1:         message.ack();
1:         assertEquals("Message body", DOLLAR_TOPIC, new String(message.getPayload()));
1: 
1:         connection.disconnect();
1:     }
1: 
commit:6c85967
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 120 * 1000)
0:         final String[] clientIds = { null, "foo", "durable" };
0:             mqtt.setCleanSession(!"durable".equals(clientId));
1: 
1:             BlockingConnection connection = mqtt.blockingConnection();
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             assertNull(connection.receive(5000, TimeUnit.MILLISECONDS));
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             msg = connection.receive(15000, TimeUnit.MILLISECONDS);
0:             assertNull(connection.receive(5000, TimeUnit.MILLISECONDS));
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             assertNull(connection.receive(5000, TimeUnit.MILLISECONDS));
1: 
0:             // re-connect and check
1:             connection.disconnect();
0:             connection = mqtt.blockingConnection();
1:             connection.connect();
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_LEAST_ONCE)});
0:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
0:             assertNotNull("No reset retained message for " + clientId, msg);
0:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
0:             assertNull(connection.receive(5000, TimeUnit.MILLISECONDS));
1: 
commit:70f7c58
/////////////////////////////////////////////////////////////////////////
commit:0a39782
/////////////////////////////////////////////////////////////////////////
1:             Message msg = connection.receive(5, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
0:             Message msg = connection.receive(5, TimeUnit.SECONDS);
/////////////////////////////////////////////////////////////////////////
1:             connection.subscribe(new Topic[]{new Topic(topic, QoS.valueOf(topic))});
/////////////////////////////////////////////////////////////////////////
0:             connection.unsubscribe(new String[]{topic});
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 5; i++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < 5; ++i) {
1:             assertNotNull("Missing message " + i, message);
1:         assertEquals(5, received);
1: 
1:         // unsubscribe from topic
1:         connectionSub.unsubscribe(new String[]{"TopicA"});
1: 
1:         // send more messages
1:         for (int i = 0; i < 5; i++) {
1:             String payload = "Message " + i;
1:             connectionPub.publish(topics[0].name().toString(), payload.getBytes(), QoS.EXACTLY_ONCE, false);
1:         }
1: 
1:         // these should not be received
0:         connectionSub = mqttSub.blockingConnection();
0:         connectionSub.connect();
0:         assertNull(connectionSub.receive(5, TimeUnit.SECONDS));
commit:a581d01
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             actualQoS[0] = -1;
/////////////////////////////////////////////////////////////////////////
1:     public void testRetainedMessage() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive((short) 2);
1:         mqtt.setCleanSession(true);
1: 
0:         final String RETAIN = "RETAIN";
0:         final String TOPICA = "TopicA";
1: 
0:         final String[] clientIds = { null, "foo" };
0:         for (String clientId : clientIds) {
1: 
0:             mqtt.setClientId(clientId);
1:             final BlockingConnection connection = mqtt.blockingConnection();
1:             connection.connect();
1: 
0:             // set retained message and check
0:             connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_MOST_ONCE)});
0:             Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
0:             assertNotNull("No retained message for " + clientId, msg);
0:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
1: 
0:             // test duplicate subscription
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_MOST_ONCE)});
0:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
0:             assertNotNull("No retained message on duplicate subscription for " + clientId, msg);
0:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
0:             connection.unsubscribe(new String[]{"TopicA"});
1: 
0:             // clear retained message and check that we don't receive it
0:             connection.publish(TOPICA, "".getBytes(), QoS.AT_MOST_ONCE, true);
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_MOST_ONCE)});
0:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
0:             assertNull("Retained message not cleared for " + clientId, msg);
0:             connection.unsubscribe(new String[]{"TopicA"});
1: 
0:             // set retained message again and check
0:             connection.publish(TOPICA, RETAIN.getBytes(), QoS.EXACTLY_ONCE, true);
0:             connection.subscribe(new Topic[]{new Topic(TOPICA, QoS.AT_MOST_ONCE)});
0:             msg = connection.receive(5000, TimeUnit.MILLISECONDS);
0:             assertNotNull("No reset retained message for " + clientId, msg);
0:             assertEquals(RETAIN, new String(msg.getPayload()));
1:             msg.ack();
0:             connection.unsubscribe(new String[]{"TopicA"});
1: 
1:             connection.disconnect();
1:         }
1:     }
1: 
0:     @Test(timeout = 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:         // send retained message
1:         final String RETAINED = "RETAINED";
1:         provider.publish("foo/bah", RETAINED.getBytes(), AT_LEAST_ONCE, true);
1: 
1:         // MUST set to true to receive retained messages
1:         activeMQConnection.setUseRetroactiveConsumer(true);
1:         // check whether we received retained message on JMS subscribe
1:         ActiveMQMessage message = (ActiveMQMessage) consumer.receive(5000);
1:         assertNotNull("Should get retained message", message);
1:         ByteSequence bs = message.getContent();
1:         assertEquals(RETAINED, new String(bs.data, bs.offset, bs.length));
1:         assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));
1: 
1:             message = (ActiveMQMessage) consumer.receive(5000);
1:             bs = message.getContent();
/////////////////////////////////////////////////////////////////////////
1:         activeMQConnection.setUseRetroactiveConsumer(true);
1:         // send retained message from JMS
1:         final String RETAINED = "RETAINED";
1:         TextMessage sendMessage = s.createTextMessage(RETAINED);
1:         // mark the message to be retained
1:         sendMessage.setBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY, true);
1:         // MQTT QoS can be set using MQTTProtocolConverter.QOS_PROPERTY_NAME property
1:         sendMessage.setIntProperty(MQTTProtocolConverter.QOS_PROPERTY_NAME, 0);
1:         producer.send(sendMessage);
1: 
1:         byte[] message = provider.receive(10000);
1:         assertNotNull("Should get retained message", message);
1:         assertEquals(RETAINED, new String(message));
1: 
1:             sendMessage = s.createTextMessage(payload);
1:             message = provider.receive(5000);
commit:bcb60a4
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
0: import java.util.Arrays;
0: import java.util.LinkedList;
1: import java.util.List;
0: import java.util.Map;
0: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertNotEquals;
1: import org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy;
1: import org.apache.activemq.broker.region.policy.PolicyEntry;
1: import org.apache.activemq.broker.region.policy.PolicyMap;
0: import org.apache.activemq.security.AuthenticationUser;
0: import org.apache.activemq.security.AuthorizationEntry;
0: import org.apache.activemq.security.AuthorizationPlugin;
0: import org.apache.activemq.security.DefaultAuthorizationMap;
0: import org.apache.activemq.security.SimpleAuthenticationPlugin;
0: import org.apache.activemq.security.SimpleAuthorizationMap;
/////////////////////////////////////////////////////////////////////////
1:             assertNotNull("No message for " + topic, msg);
/////////////////////////////////////////////////////////////////////////
1:             final byte[] qos = connection.subscribe(new Topic[]{new Topic(wildcard, QoS.AT_LEAST_ONCE)});
1:             assertNotEquals("Subscribe failed " + wildcard, (byte)0x80, qos[0]);
0:             Message msg = connection.receive(5000, TimeUnit.MILLISECONDS);
0:                 msg = connection.receive(5000, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
1:             connection.subscribe(new Topic[]{new Topic("TopicA", qos)});
1:             assertNotNull("No message for " + qos, msg);
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 60 * 1000)
1:     public void testActiveMQRecoveryPolicy() throws Exception {
0:         addMQTTConnector();
1: 
0:         brokerService.start();
1: 
1:         // test with ActiveMQ LastImageSubscriptionRecoveryPolicy
1:         final PolicyMap policyMap = new PolicyMap();
1:         final PolicyEntry policyEntry = new PolicyEntry();
1:         policyEntry.setSubscriptionRecoveryPolicy(new LastImageSubscriptionRecoveryPolicy());
1:         policyMap.put(new ActiveMQTopic(">"), policyEntry);
1:         brokerService.setDestinationPolicy(policyMap);
1: 
1:         MQTT mqtt = createMQTTConnection("pub-sub", true);
1:         final int[] retain = new int[1];
1:         final int[] nonretain  = new int[1];
0:         mqtt.setTracer(new Tracer() {
1:             @Override
0:             public void onReceive(MQTTFrame frame) {
1:                 if (frame.messageType() == PUBLISH.TYPE) {
1:                     LOG.info("Received message with retain=" + frame.retain());
1:                     if (frame.retain()) {
1:                         retain[0]++;
1:                     } else {
1:                         nonretain[0]++;
1:                     }
1:                 }
1:             }
0:         });
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         final String RETAINED = "RETAINED";
1:         connection.publish("one", RETAINED.getBytes(), QoS.AT_LEAST_ONCE, true);
1:         connection.publish("two", RETAINED.getBytes(), QoS.AT_LEAST_ONCE, true);
1: 
1:         final String NONRETAINED = "NONRETAINED";
1:         connection.publish("one", NONRETAINED.getBytes(), QoS.AT_LEAST_ONCE, false);
1:         connection.publish("two", NONRETAINED.getBytes(), QoS.AT_LEAST_ONCE, false);
1: 
1:         connection.subscribe(new Topic[]{new Topic("#", QoS.AT_LEAST_ONCE)});
1:         for (int i = 0; i < 4; i++) {
1:             final Message message = connection.receive(30, TimeUnit.SECONDS);
1:             assertNotNull("Should receive 4 messages", message);
1:             message.ack();
1:         }
1:         assertEquals("Should receive 2 retained messages", 2, retain[0]);
1:         assertEquals("Should receive 2 non-retained messages", 2, nonretain[0]);
1:     }
1: 
author:Daniel Kulp
-------------------------------------------------------------------------------
commit:4de5219
/////////////////////////////////////////////////////////////////////////
0:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
0:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
0:             msg = connection.receive(500, TimeUnit.MILLISECONDS);
/////////////////////////////////////////////////////////////////////////
0:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
/////////////////////////////////////////////////////////////////////////
0:             assertNull(connection.receive(500, TimeUnit.MILLISECONDS));
author:Kevin Earls
-------------------------------------------------------------------------------
commit:d4a376d
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 2 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 2 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 2 * 60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 2 *  60 * 1000)
/////////////////////////////////////////////////////////////////////////
1:     @Test(timeout = 2 * 60 * 1000)
commit:e57aeb3
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=60 * 1000)
author:Hiram Chirino
-------------------------------------------------------------------------------
commit:e7e317d
/////////////////////////////////////////////////////////////////////////
1: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
1:     public void testValidZeroLengthClientId() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("");
0:         mqtt.setCleanSession(true);
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1:         connection.disconnect();
1:     }
1: 
0:     @Test(timeout = 60 * 1000)
1:     public void testMQTTPathPatterns() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("");
0:         mqtt.setCleanSession(true);
1: 
1:         BlockingConnection connection = mqtt.blockingConnection();
1:         connection.connect();
1: 
1:         final String RETAINED = "RETAINED";
0:         String[] topics = {"TopicA", "/TopicA", "/", "TopicA/", "//"};
1:         for (String topic : topics) {
1:             // test retained message
1:             connection.publish(topic, (RETAINED + topic).getBytes(), QoS.AT_LEAST_ONCE, true);
1: 
0:             connection.subscribe(new Topic[]{new Topic(topic, QoS.AT_LEAST_ONCE)});
0:             Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
0:             assertNotNull(msg);
1:             assertEquals(RETAINED + topic, new String(msg.getPayload()));
0:             msg.ack();
1: 
1:             // test non-retained message
1:             connection.publish(topic, topic.getBytes(), QoS.AT_LEAST_ONCE, false);
1:             msg = connection.receive(1000, TimeUnit.MILLISECONDS);
0:             assertNotNull(msg);
1:             assertEquals(topic, new String(msg.getPayload()));
0:             msg.ack();
1: 
0:             connection.unsubscribe(new String[] {topic});
1:         }
1:         connection.disconnect();
1: 
1:         // test wildcard patterns with above topics
0:         String[] wildcards = {"#", "+", "+/#", "/+", "+/", "+/+", "+/+/", "+/+/+"};
1:         for (String wildcard : wildcards) {
1:             final Pattern pattern = Pattern.compile(wildcard.replaceAll("/?#", "(/?.*)*").replaceAll("\\+", "[^/]*"));
1: 
0:             connection = mqtt.blockingConnection();
1:             connection.connect();
0:             connection.subscribe(new Topic[]{new Topic(wildcard, QoS.AT_LEAST_ONCE)});
1: 
1:             // test retained messages
0:             Message msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:             do {
1:                 assertNotNull("RETAINED null " + wildcard, msg);
1:                 assertTrue("RETAINED prefix " + wildcard, new String(msg.getPayload()).startsWith(RETAINED));
0:                 assertTrue("RETAINED matching " + wildcard + " " + msg.getTopic(),
0:                     pattern.matcher(msg.getTopic()).matches());
0:                 msg.ack();
1:                 msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:             } while (msg != null);
1: 
0:             // connection is borked after timeout in connection.receive()
1:             connection.disconnect();
0:             connection = mqtt.blockingConnection();
1:             connection.connect();
0:             connection.subscribe(new Topic[]{new Topic(wildcard, QoS.AT_LEAST_ONCE)});
1: 
1:             // test non-retained message
1:             for (String topic : topics) {
1:                 connection.publish(topic, topic.getBytes(), QoS.AT_LEAST_ONCE, false);
1:             }
1:             msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:             do {
1:                 assertNotNull("Non-retained Null " + wildcard, msg);
0:                 assertTrue("Non-retained matching " + wildcard + " " + msg.getTopic(),
0:                     pattern.matcher(msg.getTopic()).matches());
0:                 msg.ack();
1:                 msg = connection.receive(1000, TimeUnit.MILLISECONDS);
1:             } while (msg != null);
1: 
1:             connection.unsubscribe(new String[] { wildcard });
1:             connection.disconnect();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         actualQoS[0] = frame.qos().ordinal();
/////////////////////////////////////////////////////////////////////////
0:             msg.ack();
/////////////////////////////////////////////////////////////////////////
1:                     actualQoS[0] = frame.qos().ordinal();
/////////////////////////////////////////////////////////////////////////
0:             msg.ack();
commit:ad30410
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info(String.format(message, args));
0:     @Test(timeout=60 * 1000)
0:     public void testMQTT311Connection()throws Exception{
0:         addMQTTConnector();
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setClientId("foo");
0:         mqtt.setVersion("3.1.1");
1:         final BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0:         connection.disconnect();
1:     }
1: 
commit:bc9751a
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.broker.TransportConnector;
1: import org.apache.activemq.command.ActiveMQMessage;
1: import org.apache.activemq.util.ByteSequence;
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
1: 
1:     public void testSendAndReceiveMQTT() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1:         final MQTTClientProvider subscriptionProvider = getMQTTClientProvider();
1:         initializeConnection(subscriptionProvider);
1: 
1: 
0:         subscriptionProvider.subscribe("foo/bah",AT_MOST_ONCE);
1: 
0:         final CountDownLatch latch = new CountDownLatch(numberOfMessages);
1: 
1:         Thread thread = new Thread(new Runnable() {
1:             @Override
1:             public void run() {
0:                 for (int i = 0; i < numberOfMessages; i++){
0:                     try {
1:                         byte[] payload = subscriptionProvider.receive(10000);
1:                         assertNotNull("Should get a message", payload);
0:                         latch.countDown();
1:                     } catch (Exception e) {
1:                         e.printStackTrace();
1:                         break;
1:                     }
1: 
1:                 }
1:             }
0:         });
1:         thread.start();
1: 
1:         final MQTTClientProvider publishProvider = getMQTTClientProvider();
1:         initializeConnection(publishProvider);
1: 
0:         for (int i = 0; i < numberOfMessages; i++){
1:             String payload = "Message " + i;
0:             publishProvider.publish("foo/bah",payload.getBytes(),AT_LEAST_ONCE);
1:         }
1: 
1:         latch.await(10, TimeUnit.SECONDS);
1:         assertEquals(0, latch.getCount());
1:         subscriptionProvider.disconnect();
1:         publishProvider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testUnsubscribeMQTT() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1:         final MQTTClientProvider subscriptionProvider = getMQTTClientProvider();
1:         initializeConnection(subscriptionProvider);
1: 
1:         String topic = "foo/bah";
1: 
0:         subscriptionProvider.subscribe(topic,AT_MOST_ONCE);
1: 
0:         final CountDownLatch latch = new CountDownLatch(numberOfMessages/2);
1: 
1:         Thread thread = new Thread(new Runnable() {
1:             @Override
1:             public void run() {
0:                 for (int i = 0; i < numberOfMessages; i++){
0:                     try {
1:                         byte[] payload = subscriptionProvider.receive(10000);
1:                         assertNotNull("Should get a message", payload);
0:                         latch.countDown();
1:                     } catch (Exception e) {
1:                         e.printStackTrace();
1:                         break;
1:                     }
1: 
1:                 }
1:             }
0:         });
1:         thread.start();
1: 
1:         final MQTTClientProvider publishProvider = getMQTTClientProvider();
1:         initializeConnection(publishProvider);
1: 
0:         for (int i = 0; i < numberOfMessages; i++){
1:             String payload = "Message " + i;
0:             if (i == numberOfMessages/2){
1:                 subscriptionProvider.unsubscribe(topic);
1:             }
0:             publishProvider.publish(topic,payload.getBytes(),AT_LEAST_ONCE);
1:         }
1: 
1:         latch.await(10, TimeUnit.SECONDS);
1:         assertEquals(0, latch.getCount());
1:         subscriptionProvider.disconnect();
1:         publishProvider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendAtMostOnceReceiveExactlyOnce() throws Exception {
1:         /**
1:          * Although subscribing with EXACTLY ONCE, the message gets published
0:          * with AT_MOST_ONCE - in MQTT the QoS is always determined by the message
0:          * as published - not the wish of the subscriber
1:          */
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
0:         provider.subscribe("foo",EXACTLY_ONCE);
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "Test Message: " + i;
1:             provider.publish("foo", payload.getBytes(), AT_MOST_ONCE);
1:             byte[] message = provider.receive(5000);
1:             assertNotNull("Should get a message", message);
1:             assertEquals(payload, new String(message));
1:         }
1:         provider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendAtLeastOnceReceiveExactlyOnce() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
0:         provider.subscribe("foo",EXACTLY_ONCE);
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "Test Message: " + i;
1:             provider.publish("foo", payload.getBytes(), AT_LEAST_ONCE);
1:             byte[] message = provider.receive(5000);
1:             assertNotNull("Should get a message", message);
1:             assertEquals(payload, new String(message));
1:         }
1:         provider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendAtLeastOnceReceiveAtMostOnce() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
0:         provider.subscribe("foo",AT_MOST_ONCE);
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "Test Message: " + i;
1:             provider.publish("foo", payload.getBytes(), AT_LEAST_ONCE);
1:             byte[] message = provider.receive(5000);
1:             assertNotNull("Should get a message", message);
1:             assertEquals(payload, new String(message));
1:         }
1:         provider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendAndReceiveAtMostOnce() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
0:         provider.subscribe("foo",AT_MOST_ONCE);
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "Test Message: " + i;
1:             provider.publish("foo", payload.getBytes(), AT_MOST_ONCE);
1:             byte[] message = provider.receive(5000);
1:             assertNotNull("Should get a message", message);
1:             assertEquals(payload, new String(message));
1:         }
1:         provider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendAndReceiveAtLeastOnce() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
0:         provider.subscribe("foo",AT_LEAST_ONCE);
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "Test Message: " + i;
1:             provider.publish("foo", payload.getBytes(), AT_LEAST_ONCE);
1:             byte[] message = provider.receive(5000);
1:             assertNotNull("Should get a message", message);
1:             assertEquals(payload, new String(message));
1:         }
1:         provider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendAndReceiveExactlyOnce() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
1:         final MQTTClientProvider publisher = getMQTTClientProvider();
1:         initializeConnection(publisher);
1: 
1:         final MQTTClientProvider subscriber = getMQTTClientProvider();
1:         initializeConnection(subscriber);
1: 
0:         subscriber.subscribe("foo",EXACTLY_ONCE);
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "Test Message: " + i;
1:             publisher.publish("foo", payload.getBytes(), EXACTLY_ONCE);
1:             byte[] message = subscriber.receive(5000);
0:             assertNotNull("Should get a message + ["+ i + "]", message);
1:             assertEquals(payload, new String(message));
1:         }
1:         subscriber.disconnect();
1:         publisher.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendAndReceiveLargeMessages() throws Exception {
1:         byte[] payload = new byte[1024 * 32];
0:         for (int i = 0; i < payload.length; i++){
1:             payload[i] = '2';
1:         }
0:         addMQTTConnector();
0:         brokerService.start();
1: 
1:         final MQTTClientProvider publisher = getMQTTClientProvider();
1:         initializeConnection(publisher);
1: 
1:         final MQTTClientProvider subscriber = getMQTTClientProvider();
1:         initializeConnection(subscriber);
1: 
0:         subscriber.subscribe("foo",AT_LEAST_ONCE);
1:         for (int i = 0; i < 10; i++) {
1:             publisher.publish("foo", payload, AT_LEAST_ONCE);
1:             byte[] message = subscriber.receive(5000);
1:             assertNotNull("Should get a message", message);
1: 
1:             assertArrayEquals(payload, message);
1:         }
1:         subscriber.disconnect();
1:         publisher.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendMQTTReceiveJMS() throws Exception {
0:         addMQTTConnector();
0:         TransportConnector openwireTransport = brokerService.addConnector("tcp://localhost:0");
0:         brokerService.start();
1: 
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
0:         final String DESTINATION_NAME = "foo.*";
1: 
0:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory(openwireTransport.getConnectUri()).createConnection();
1:         activeMQConnection.start();
1:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         javax.jms.Topic jmsTopic = s.createTopic(DESTINATION_NAME);
1:         MessageConsumer consumer = s.createConsumer(jmsTopic);
1: 
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "Test Message: " + i;
1:             provider.publish("foo/bah", payload.getBytes(), AT_LEAST_ONCE);
0:             ActiveMQMessage message = (ActiveMQMessage) consumer.receive(5000);
1:             assertNotNull("Should get a message", message);
0:             ByteSequence bs = message.getContent();
1:             assertEquals(payload, new String(bs.data, bs.offset, bs.length));
1:         }
1: 
1:         activeMQConnection.close();
1:         provider.disconnect();
1:     }
1: 
0:     @Test(timeout=300000)
1:     public void testSendJMSReceiveMQTT() throws Exception {
0:         addMQTTConnector();
0:         TransportConnector openwireTransport = brokerService.addConnector("tcp://localhost:0");
0:         brokerService.start();
1:         final MQTTClientProvider provider = getMQTTClientProvider();
1:         initializeConnection(provider);
1: 
0:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory(openwireTransport.getConnectUri()).createConnection();
1:         activeMQConnection.start();
1:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         javax.jms.Topic jmsTopic = s.createTopic("foo.far");
1:         MessageProducer producer = s.createProducer(jmsTopic);
1: 
0:         provider.subscribe("foo/+",AT_MOST_ONCE);
0:         for (int i = 0; i < numberOfMessages; i++) {
1:             String payload = "This is Test Message: " + i;
0:             TextMessage sendMessage = s.createTextMessage(payload);
1:             producer.send(sendMessage);
1:             byte[] message = provider.receive(5000);
1:             assertNotNull("Should get a message", message);
1: 
1:             assertEquals(payload, new String(message));
1:         }
1:         provider.disconnect();
1:         activeMQConnection.close();
1:     }
1: 
0:     @Test(timeout=300000)
/////////////////////////////////////////////////////////////////////////
author:rajdavies
-------------------------------------------------------------------------------
commit:6683eb6
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.List;
1: import javax.jms.BytesMessage;
1: import javax.jms.Connection;
1: import javax.jms.Destination;
1: import javax.jms.MessageConsumer;
1: import javax.jms.MessageProducer;
1: import javax.jms.Session;
1: import javax.jms.TextMessage;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testSendAndReceiveRetainedMessages() throws Exception {
0: 
0:         addMQTTConnector();
0:         brokerService.start();
0: 
1:         final MQTTClientProvider publisher = getMQTTClientProvider();
1:         initializeConnection(publisher);
0: 
1:         final MQTTClientProvider subscriber = getMQTTClientProvider();
1:         initializeConnection(subscriber);
0: 
1:         String RETAINED = "retained";
0:         publisher.publish("foo",RETAINED.getBytes(),AT_LEAST_ONCE,true);
0: 
1:         List<String> messages = new ArrayList<String>();
0:         for (int i = 0; i < 10; i++){
1:             messages.add("TEST MESSAGE:" + i);
1:         }
0: 
0:         subscriber.subscribe("foo",AT_LEAST_ONCE);
0: 
0:         for (int i = 0; i < 10; i++) {
1:             publisher.publish("foo", messages.get(i).getBytes(), AT_LEAST_ONCE);
1:         }
1:         byte[] msg = subscriber.receive(5000);
0:         assertNotNull(msg);
0:         assertEquals(RETAINED,new String(msg));
0: 
0:         for (int i =0; i < 10; i++){
1:             msg = subscriber.receive(5000);
0:             assertNotNull(msg);
0:             assertEquals(messages.get(i),new String(msg));
1:         }
1:         subscriber.disconnect();
1:         publisher.disconnect();
1:     }
0: 
0: 
0:     @Test(timeout=60 * 1000)
author:Christian Posta
-------------------------------------------------------------------------------
commit:e59ea6d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.ActiveMQConnectionFactory;
/////////////////////////////////////////////////////////////////////////
0: import javax.jms.*;
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout = 300000)
1:     public void testJmsMapping() throws Exception {
0:         addMQTTConnector();
0:         addOpenwireConnector();
0:         brokerService.start();
0: 
1:         // start up jms consumer
0:         ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:" + openwireConnector.getConnectUri().getPort());
0:         Connection jmsConn = factory.createConnection();
1:         Session session = jmsConn.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         Destination dest = session.createTopic("test.foo");
1:         MessageConsumer consumer = session.createConsumer(dest);
1:         jmsConn.start();
0: 
1:         // set up mqtt producer
0:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("foo3");
0:         mqtt.setKeepAlive((short)2);
1:         final BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0: 
1:         int messagesToSend = 5;
0: 
1:         // publish
1:         for (int i = 0; i < messagesToSend; ++i) {
1:             connection.publish("test/foo", "hello world".getBytes(), QoS.AT_LEAST_ONCE, false);
0:         }
0: 
0:         connection.disconnect();
0: 
1:         for (int i = 0; i < messagesToSend; i++) {
0: 
1:             javax.jms.Message message = consumer.receive(2 * 1000);
1:             assertNotNull(message);
1:             assertTrue(message instanceof BytesMessage);
1:             BytesMessage bytesMessage = (BytesMessage) message;
0: 
1:             int length = (int) bytesMessage.getBodyLength();
1:             byte[] buffer = new byte[length];
1:             bytesMessage.readBytes(buffer);
1:             assertEquals("hello world", new String(buffer));
0:         }
0: 
1:         jmsConn.close();
0: 
0:     }
0: 
0:     @Test(timeout = 300000)
0: 
1:         for (int i = 0; i < payload.length; i++) {
/////////////////////////////////////////////////////////////////////////
0:                     " Message content: " + messageContent);
commit:4dc1ddc
/////////////////////////////////////////////////////////////////////////
0:         Topic[] topics = {new Topic("Topic/A", QoS.EXACTLY_ONCE), new Topic("Topic/B", QoS.EXACTLY_ONCE)};
0:         Topic[] wildcardTopic = {new Topic("Topic/#", QoS.AT_LEAST_ONCE)};
1:         connection.subscribe(wildcardTopic);
commit:d212d3c
/////////////////////////////////////////////////////////////////////////
0: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.broker.TransportConnector;
/////////////////////////////////////////////////////////////////////////
0:     protected LinkedList<Throwable> exceptions = new LinkedList<Throwable>();
/////////////////////////////////////////////////////////////////////////
0:         subscribeConnection.disconnect();
0:         publisherConnection.disconnect();
/////////////////////////////////////////////////////////////////////////
0:             connection.publish("foo", payload.getBytes(), QoS.AT_MOST_ONCE, false);
/////////////////////////////////////////////////////////////////////////
0:         TransportConnector mqttConnector = brokerService.getTransportConnectorByScheme("mqtt");
0:         Transport clientTransport = createManualMQTTClient();
0:         // wait for broker to register the MQTT connection
0:         TimeUnit.SECONDS.sleep(1);
0:         assertTrue(mqttConnector.getConnections().size() > 0);
0:         // wait for the inactivity monitor to remove the connection due to inactivity
0:         assertTrue(mqttConnector.getConnections().size() == 0);
0:         assertTrue("Should have seen client transport exception", exceptions.size() > 0);
0: 
0:         clientTransport.stop();
0:     private Transport createManualMQTTClient() throws IOException, URISyntaxException {
/////////////////////////////////////////////////////////////////////////
0:                 exceptions.add(error);
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testTurnOffInactivityMonitor()throws Exception{
0:         addMQTTConnector(brokerService, "?transport.useInactivityMonitor=false");
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive((short)2);
0:         final BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0: 
0:         TimeUnit.SECONDS.sleep(10);
0: 
0: 
0:         assertTrue("KeepAlive didn't work properly", connection.isConnected());
0: 
0:         connection.disconnect();
0:     }
0: 
0:     @Test
0:     public void testPingOnMQTTNIO() throws Exception {
0:         brokerService.addConnector("mqtt+nio://localhost:1883");
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive((short)2);
0:         final BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0: 
0:         TimeUnit.SECONDS.sleep(10);
0: 
0:         assertTrue("KeepAlive didn't work properly", connection.isConnected());
0: 
0:         connection.disconnect();
0:     }
0: 
0:     @Test
1:     public void testDefaultKeepAliveWhenClientSpecifiesZero() throws Exception {
0:         // default keep alive in milliseconds
0:         brokerService.addConnector("mqtt://localhost:1883?transport.defaultKeepAlive=2000");
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive((short)0);
0:         final BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0: 
0:         TimeUnit.SECONDS.sleep(10);
0: 
0:         assertFalse("KeepAlive didn't work properly", connection.isConnected());
0: 
0:     }
0: 
0:     protected void addMQTTConnector(BrokerService brokerService, String config) throws Exception {
0:         brokerService.addConnector("mqtt://localhost:1883" + config);
0:     }
0: 
0:         // shut off connect retry
0:         mqtt.setConnectAttemptsMax(0);
0:         mqtt.setReconnectAttemptsMax(0);
commit:8a5f160
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.util.concurrent.atomic.AtomicLong;
0: import javax.net.SocketFactory;
0: 
0: import org.apache.activemq.transport.Transport;
0: import org.apache.activemq.transport.TransportListener;
0: import org.apache.activemq.transport.tcp.TcpTransport;
0: import org.fusesource.hawtbuf.UTF8Buffer;
0: import org.fusesource.mqtt.codec.CONNECT;
0: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testInactivityTimeoutDisconnectsClient() throws Exception{
0: 
0:         addMQTTConnector(brokerService);
0:         brokerService.start();
0: 
0:         // manually need to create the client so we don't send keep alive (PINGREQ) frames to keep the conn
0:         // from timing out
0:         final AtomicLong exceptionCount = new AtomicLong(0);
0:         Transport clientTransport = createManualMQTTClient(exceptionCount);
0:         clientTransport.start();
0:         CONNECT connectFrame = new CONNECT().clientId(new UTF8Buffer("testClient")).keepAlive((short)2);
0:         clientTransport.oneway(connectFrame.encode());
0: 
0: 
0: 
0:         TimeUnit.SECONDS.sleep(10);
0:         System.out.println("Done waiting");
0:         assertEquals("We have elapsed the keep alive, we should have disconnected", 1, exceptionCount.get());
0: 
0:     }
0: 
0: 
0:     private Transport createManualMQTTClient(final AtomicLong exceptionCount) throws IOException, URISyntaxException {
0:         Transport clientTransport = new TcpTransport(new MQTTWireFormat(), SocketFactory.getDefault(),
0:                 new URI("tcp://localhost:1883"), null);
0:         clientTransport.setTransportListener(new TransportListener() {
0:             @Override
0:             public void onCommand(Object command) {
0:             }
0: 
0:             @Override
0:             public void onException(IOException error) {
0:                 System.out.println("Exception!!!" + error.getMessage());
0:                 exceptionCount.incrementAndGet();
0:             }
0: 
0:             @Override
0:             public void transportInterupted() {
0:             }
0: 
0:             @Override
0:             public void transportResumed() {
0:             }
0:         });
0:         return clientTransport;
0:     }
0: 
0:     @Test
1:     public void testPingKeepsInactivityMonitorAlive() throws Exception {
0:         addMQTTConnector(brokerService);
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive((short)2);
0:         final BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0: 
0:         TimeUnit.SECONDS.sleep(10);
0: 
0:         assertTrue("KeepAlive didn't work properly", connection.isConnected());
0: 
0:         connection.disconnect();
0:     }
0: 
author:Robert Davies
-------------------------------------------------------------------------------
commit:72e484c
/////////////////////////////////////////////////////////////////////////
0:         mqtt.setClientId("foo");
/////////////////////////////////////////////////////////////////////////
1:         mqtt.setClientId("foo3");
/////////////////////////////////////////////////////////////////////////
0:         mqtt.setClientId("foo");
/////////////////////////////////////////////////////////////////////////
commit:09c4500
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertTrue;
0: public class MQTTTest extends AbstractMQTTTest {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     protected MQTTClientProvider getMQTTClientProvider() {
0:         return new FuseMQQTTClientProvider();
0:     }
0: 
commit:667237f
/////////////////////////////////////////////////////////////////////////
0:         this.numberOfMessages = 3000;
/////////////////////////////////////////////////////////////////////////
0:             //System.err.println("Sent " + payload + " GOT " + new String(message.getPayload()));
commit:dfaa05d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import static org.fusesource.hawtbuf.UTF8Buffer.utf8;
0: import static org.junit.Assert.*;
/////////////////////////////////////////////////////////////////////////
0:         this.numberOfMessages = 1000;
commit:4d43c74
/////////////////////////////////////////////////////////////////////////
commit:144dda0
/////////////////////////////////////////////////////////////////////////
0:         Topic[] topics = {new Topic(utf8("foo/+"), QoS.AT_MOST_ONCE)};
commit:1e3ea5c
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
0: import javax.jms.MessageProducer;
0: import javax.jms.TextMessage;
/////////////////////////////////////////////////////////////////////////
0:     public void testSendAndReceiveMQTT() throws Exception {
0:         addMQTTConnector(brokerService);
0:         brokerService.start();
0:         MQTT mqtt = new MQTT();
0:         final BlockingConnection subscribeConnection = mqtt.blockingConnection();
0:         subscribeConnection.connect();
0:         Topic topic = new Topic("foo/bah",QoS.AT_MOST_ONCE);
0:         Topic[] topics = {topic};
0:         subscribeConnection.subscribe(topics);
0:         final CountDownLatch latch = new CountDownLatch(numberOfMessages);
0: 
0:         Thread thread = new Thread(new Runnable() {
0:             public void run() {
0:                 for (int i = 0; i < numberOfMessages; i++){
0:                     try {
0:                         Message message = subscribeConnection.receive();
1:                         message.ack();
0:                         latch.countDown();
0:                     } catch (Exception e) {
0:                         e.printStackTrace();
0:                         break;
0:                     }
0: 
0:                 }
0:             }
0:         });
0:         thread.start();
0: 
0:         BlockingConnection publisherConnection = mqtt.blockingConnection();
0:         publisherConnection.connect();
0:         for (int i = 0; i < numberOfMessages; i++){
0:             String payload = "Message " + i;
0:             publisherConnection.publish(topic.name().toString(),payload.getBytes(),QoS.AT_LEAST_ONCE,false);
0:         }
0: 
0:         latch.await(10, TimeUnit.SECONDS);
0:         assertEquals(0, latch.getCount());
0: 
0:     }
0: 
0:     @Test
/////////////////////////////////////////////////////////////////////////
0:         final String DESTINATION_NAME = "foo.*";
/////////////////////////////////////////////////////////////////////////
0:             connection.publish("foo/bah", payload.getBytes(), QoS.AT_LEAST_ONCE, false);
/////////////////////////////////////////////////////////////////////////
0:     @Test
0:     public void testSendJMSReceiveMQTT() throws Exception {
0:         addMQTTConnector(brokerService);
0:         brokerService.addConnector(ActiveMQConnectionFactory.DEFAULT_BROKER_BIND_URL);
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive(Short.MAX_VALUE);
0:         BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0: 
0:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory().createConnection();
0:         activeMQConnection.start();
0:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         javax.jms.Topic jmsTopic = s.createTopic("foo.far");
0:         MessageProducer producer = s.createProducer(jmsTopic);
0: 
0:         Topic[] topics = {new Topic(utf8("foo/far"), QoS.AT_MOST_ONCE)};
0:         connection.subscribe(topics);
0:         for (int i = 0; i < numberOfMessages; i++) {
0:             String payload = "This is Test Message: " + i;
0:             TextMessage sendMessage = s.createTextMessage(payload);
0:             producer.send(sendMessage);
1:             Message message = connection.receive();
1:             message.ack();
0:             assertEquals(payload, new String(message.getPayload()));
0:         }
0:         connection.disconnect();
0:     }
0: 
0: 
commit:4c38438
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertArrayEquals;
0:     protected static final Logger LOG = LoggerFactory.getLogger(MQTTTest.class);
0:     protected BrokerService brokerService;
0:     protected Vector<Throwable> exceptions = new Vector<Throwable>();
0:     protected int numberOfMessages;
/////////////////////////////////////////////////////////////////////////
0:         this.numberOfMessages = 2000;
/////////////////////////////////////////////////////////////////////////
0:     public void testSendAndReceiveAtMostOnce() throws Exception {
0:         addMQTTConnector(brokerService);
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive(Short.MAX_VALUE);
0:         BlockingConnection connection = mqtt.blockingConnection();
0: 
0:         connection.connect();
0: 
0: 
0:         Topic[] topics = {new Topic(utf8("foo"), QoS.AT_MOST_ONCE)};
0:         connection.subscribe(topics);
0:         for (int i = 0; i < numberOfMessages; i++) {
0:             String payload = "Test Message: " + i;
0:             connection.publish("foo", payload.getBytes(), QoS.AT_MOST_ONCE, false);
0:             Message message = connection.receive();
0:             assertEquals(payload, new String(message.getPayload()));
0:         }
0:         connection.disconnect();
0:     }
0: 
0:     @Test
0:     public void testSendAndReceiveAtLeastOnce() throws Exception {
0:         addMQTTConnector(brokerService);
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setKeepAlive(Short.MAX_VALUE);
0:         for (int i = 0; i < numberOfMessages; i++) {
/////////////////////////////////////////////////////////////////////////
0:     public void testSendAndReceiveExactlyOnce() throws Exception {
0:         addMQTTConnector(brokerService);
0:         brokerService.start();
0:         MQTT publisher = createMQTTConnection();
0:         BlockingConnection pubConnection = publisher.blockingConnection();
0:         pubConnection.connect();
0: 
0:         MQTT subscriber = createMQTTConnection();
0:         BlockingConnection subConnection = subscriber.blockingConnection();
0: 
0:         subConnection.connect();
0: 
0:         Topic[] topics = {new Topic(utf8("foo"), QoS.EXACTLY_ONCE)};
0:         subConnection.subscribe(topics);
0:         for (int i = 0; i < numberOfMessages; i++) {
0:             String payload = "Test Message: " + i;
0:             pubConnection.publish("foo", payload.getBytes(), QoS.EXACTLY_ONCE, false);
0:             Message message = subConnection.receive();
0:             message.ack();
0:             assertEquals(payload, new String(message.getPayload()));
0:         }
0:         subConnection.disconnect();
0:         pubConnection.disconnect();
0:     }
0: 
0:     @Test
0:     public void testSendAndReceiveLargeMessages() throws Exception {
1:         byte[] payload = new byte[1024 * 32];
0:         for (int i = 0; i < payload.length; i++){
1:             payload[i] = '2';
0:         }
0:         addMQTTConnector(brokerService);
0:         brokerService.start();
0: 
0:         MQTT publisher = createMQTTConnection();
0:         BlockingConnection pubConnection = publisher.blockingConnection();
0: 
0:         pubConnection.connect();
0: 
0:         MQTT subscriber = createMQTTConnection();
0:         BlockingConnection subConnection = subscriber.blockingConnection();
0: 
0:         subConnection.connect();
0: 
0:         Topic[] topics = {new Topic(utf8("foo"), QoS.AT_LEAST_ONCE)};
0:         subConnection.subscribe(topics);
0:         for (int i = 0; i < 10; i++) {
0:             pubConnection.publish("foo", payload, QoS.AT_LEAST_ONCE, false);
0:             Message message = subConnection.receive();
0:             message.ack();
0:             assertArrayEquals(payload, message.getPayload());
0:         }
0:         subConnection.disconnect();
0:         pubConnection.disconnect();
0:     }
0: 
0: 
0:     @Test
0:     public void testSendMQTTReceiveJMS() throws Exception {
0:         addMQTTConnector(brokerService);
0:         MQTT mqtt = createMQTTConnection();
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < numberOfMessages; i++) {
/////////////////////////////////////////////////////////////////////////
0:     protected void addMQTTConnector(BrokerService brokerService) throws Exception {
0:         brokerService.addConnector("mqtt://localhost:1883");
0:     }
0: 
0:     protected MQTT createMQTTConnection() throws Exception {
0:         MQTT mqtt = new MQTT();
0:         mqtt.setHost("localhost", 1883);
0:         return mqtt;
0:     }
0: 
commit:0f5b406
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
0: import org.apache.activemq.ActiveMQConnection;
0: import org.apache.activemq.command.ActiveMQMessage;
0: import org.apache.activemq.util.ByteSequence;
1: import org.fusesource.mqtt.client.BlockingConnection;
1: import org.fusesource.mqtt.client.MQTT;
1: import org.fusesource.mqtt.client.Message;
1: import org.fusesource.mqtt.client.QoS;
1: import org.fusesource.mqtt.client.Topic;
0: import org.junit.After;
0: import org.junit.Before;
1: import org.junit.Test;
0: import static org.fusesource.hawtbuf.UTF8Buffer.utf8;
0: import static org.junit.Assert.assertEquals;
0: public class MQTTTest {
0:     private static final Logger LOG = LoggerFactory.getLogger(MQTTConnectTest.class);
0:     BrokerService brokerService;
0:     Vector<Throwable> exceptions = new Vector<Throwable>();
0:     @Before
0:     public void startBroker() throws Exception {
0:         exceptions.clear();
0:         brokerService = new BrokerService();
0:         brokerService.setPersistent(false);
0:         brokerService.setAdvisorySupport(false);
0:     @After
0:     public void stopBroker() throws Exception {
0:         if (brokerService != null) {
0:             brokerService.stop();
0:     @Test
0:     public void testSendAndReceiveAtLeastOnce() throws Exception {
0: 
0:         brokerService.addConnector("mqtt://localhost:1883");
0:         brokerService.start();
0:         MQTT mqtt = new MQTT();
0:         mqtt.setHost("localhost", 1883);
0:         BlockingConnection connection = mqtt.blockingConnection();
0: 
0:         connection.connect();
0: 
0:         Topic[] topics = {new Topic(utf8("foo"), QoS.AT_LEAST_ONCE)};
0:         connection.subscribe(topics);
0:         for (int i = 0; i < 10000; i++) {
0:             String payload = "Test Message: " + i;
0:             connection.publish("foo", payload.getBytes(), QoS.AT_LEAST_ONCE, false);
0:             Message message = connection.receive();
0:             message.ack();
0:             assertEquals(payload, new String(message.getPayload()));
0:         connection.disconnect();
0:     @Test
0:     public void testSendMQTTReceiveJMS() throws Exception {
0:         brokerService.addConnector("mqtt://localhost:1883");
0:         brokerService.addConnector(ActiveMQConnectionFactory.DEFAULT_BROKER_BIND_URL);
0:         brokerService.start();
0:         MQTT mqtt = new MQTT();
0:         mqtt.setHost("localhost", 1883);
0:         BlockingConnection connection = mqtt.blockingConnection();
0:         final String DESTINATION_NAME = "foo";
0:         connection.connect();
0:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory().createConnection();
0:         activeMQConnection.start();
0:         Session s = activeMQConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         javax.jms.Topic jmsTopic = s.createTopic(DESTINATION_NAME);
0:         MessageConsumer consumer = s.createConsumer(jmsTopic);
0:         for (int i = 0; i < 10000; i++) {
0:             String payload = "Test Message: " + i;
0:             connection.publish("foo", payload.getBytes(), QoS.AT_LEAST_ONCE, false);
0:             ActiveMQMessage message = (ActiveMQMessage) consumer.receive();
0:             ByteSequence bs = message.getContent();
0:             assertEquals(payload, new String(bs.data, bs.offset, bs.length));
0:         activeMQConnection.close();
0:         connection.disconnect();
0: }
commit:cfc6917
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport.mqtt;
0: 
0: import java.io.IOException;
0: import java.net.Socket;
0: import java.net.SocketTimeoutException;
0: import java.net.URI;
0: import java.net.URISyntaxException;
0: import java.net.UnknownHostException;
0: import java.util.Arrays;
0: import java.util.HashMap;
0: import java.util.Map;
0: import java.util.UUID;
0: import java.util.concurrent.TimeUnit;
0: import java.util.regex.Matcher;
0: import java.util.regex.Pattern;
0: 
0: import javax.jms.BytesMessage;
0: import javax.jms.Connection;
0: import javax.jms.JMSException;
0: import javax.jms.MapMessage;
0: import javax.jms.MessageConsumer;
0: import javax.jms.MessageProducer;
0: import javax.jms.ObjectMessage;
0: import javax.jms.Session;
0: import javax.jms.TextMessage;
0: import javax.management.MalformedObjectNameException;
0: import javax.management.ObjectName;
0: import org.apache.activemq.ActiveMQConnectionFactory;
0: import org.apache.activemq.CombinationTestSupport;
0: import org.apache.activemq.broker.BrokerFactory;
0: import org.apache.activemq.broker.BrokerService;
0: import org.apache.activemq.broker.jmx.BrokerViewMBean;
0: import org.apache.activemq.broker.jmx.QueueViewMBean;
0: import org.apache.activemq.command.ActiveMQQueue;
0: import org.apache.activemq.command.ActiveMQTextMessage;
0: import org.apache.activemq.transport.stomp.SamplePojo;
0: import org.apache.activemq.transport.stomp.Stomp;
0: import org.apache.activemq.transport.stomp.StompConnection;
0: import org.apache.activemq.transport.stomp.StompFrame;
1: import org.apache.activemq.util.Wait;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
0: 
0: public class MQTTTest extends CombinationTestSupport {
1:     private static final Logger LOG = LoggerFactory.getLogger(MQTTTest.class);
0: 
0:     protected String bindAddress = "mqtt://localhost:1883";
0:     protected String confUri = "xbean:org/apache/activemq/transport/stomp/stomp-auth-broker.xml";
0:     protected String jmsUri = "vm://localhost";
0: 
0:     private BrokerService broker;
0:     protected StompConnection stompConnection = new StompConnection();
0:     protected Connection connection;
0:     protected Session session;
0:     protected ActiveMQQueue queue;
0:     private final String xmlObject = "<pojo>\n"
0:             + "  <name>Dejan</name>\n"
0:             + "  <city>Belgrade</city>\n"
0:             + "</pojo>";
0: 
0:     private String xmlMap = "<map>\n"
0:         + "  <entry>\n"
0:         + "    <string>name</string>\n"
0:         + "    <string>Dejan</string>\n"
0:         + "  </entry>\n"
0:         + "  <entry>\n"
0:         + "    <string>city</string>\n"
0:         + "    <string>Belgrade</string>\n"
0:         + "  </entry>\n"
0:         + "</map>\n";
0: 
0:     private final String jsonObject = "{\"pojo\":{"
0:         + "\"name\":\"Dejan\","
0:         + "\"city\":\"Belgrade\""
0:         + "}}";
0: 
0:     private String jsonMap = "{\"map\":{"
0:         + "\"entry\":["
0:         + "{\"string\":[\"name\",\"Dejan\"]},"
0:         + "{\"string\":[\"city\",\"Belgrade\"]}"
0:         + "]"
0:         + "}}";
0: 
0:     @Override
0:     protected void setUp() throws Exception {
0:         // The order of the entries is different when using ibm jdk 5.
0:         if (System.getProperty("java.vendor").equals("IBM Corporation")
0:             && System.getProperty("java.version").startsWith("1.5")) {
0:             xmlMap = "<map>\n"
0:                 + "  <entry>\n"
0:                 + "    <string>city</string>\n"
0:                 + "    <string>Belgrade</string>\n"
0:                 + "  </entry>\n"
0:                 + "  <entry>\n"
0:                 + "    <string>name</string>\n"
0:                 + "    <string>Dejan</string>\n"
0:                 + "  </entry>\n"
0:                 + "</map>\n";
0:             jsonMap = "{\"map\":{"
0:                 + "\"entry\":["
0:                 + "{\"string\":[\"city\",\"Belgrade\"]},"
0:                 + "{\"string\":[\"name\",\"Dejan\"]}"
0:                 + "]"
0:                 + "}}";
0:         }
0:         broker = BrokerFactory.createBroker(new URI(confUri));
0:         broker.setDeleteAllMessagesOnStartup(true);
0:         broker.start();
0:         broker.waitUntilStarted();
0: 
0:         stompConnect();
0: 
0:         ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(jmsUri);
0:         connection = cf.createConnection("system", "manager");
0:         session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
0:         queue = new ActiveMQQueue(getQueueName());
0:         connection.start();
0:     }
0: 
0:     protected void stompConnect() throws IOException, URISyntaxException, UnknownHostException {
0:         URI connectUri = new URI(bindAddress);
0:         stompConnection.open(createSocket(connectUri));
0:     }
0: 
0:     private void stompConnect(StompConnection connection) throws IOException, URISyntaxException, UnknownHostException {
0:         URI connectUri = new URI(bindAddress);
0:         connection.open(createSocket(connectUri));
0:     }
0: 
0:     protected Socket createSocket(URI connectUri) throws IOException {
0:         return new Socket("127.0.0.1", connectUri.getPort());
0:     }
0: 
0:     protected String getQueueName() {
0:         return getClass().getName() + "." + getName();
0:     }
0: 
0:     @Override
0:     protected void tearDown() throws Exception {
0:         try {
0:             connection.close();
0:             stompDisconnect();
0:         } catch(Exception e) {
0:             // Some tests explicitly disconnect from stomp so can ignore
0:         } finally {
0:             broker.stop();
0:             broker.waitUntilStopped();
0:         }
0:     }
0: 
0:     protected void stompDisconnect() throws IOException {
0:         if (stompConnection != null) {
0:             stompConnection.close();
0:             stompConnection = null;
0:         }
0:     }
0: 
0:     public void sendMessage(String msg) throws Exception {
0:         sendMessage(msg, "foo", "xyz");
0:     }
0: 
0:     public void sendMessage(String msg, String propertyName, String propertyValue) throws JMSException {
0:         MessageProducer producer = session.createProducer(queue);
0:         TextMessage message = session.createTextMessage(msg);
0:         message.setStringProperty(propertyName, propertyValue);
0:         producer.send(message);
0:     }
0: 
0:     public void sendBytesMessage(byte[] msg) throws Exception {
0:         MessageProducer producer = session.createProducer(queue);
0:         BytesMessage message = session.createBytesMessage();
0:         message.writeBytes(msg);
0:         producer.send(message);
0:     }
0: 
0:     public void testConnect() throws Exception {
0: 
0:         String connectFrame = "CONNECT\n" + "login: system\n" + "passcode: manager\n" + "request-id: 1\n" + "\n" + Stomp.NULL;
0:         stompConnection.sendFrame(connectFrame);
0: 
0:         String f = stompConnection.receiveFrame();
0:         assertTrue(f.startsWith("CONNECTED"));
0:         assertTrue(f.indexOf("response-id:1") >= 0);
0: 
0:     }
0: 
0:     public void testSendMessage() throws Exception {
0: 
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals("Hello World", message.getText());
0: 
0:         // Make sure that the timestamp is valid - should
0:         // be very close to the current time.
0:         long tnow = System.currentTimeMillis();
0:         long tmsg = message.getJMSTimestamp();
0:         assertTrue(Math.abs(tnow - tmsg) < 1000);
0:     }
0: 
0:     public void testJMSXGroupIdCanBeSet() throws Exception {
0: 
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "JMSXGroupID: TEST\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals("TEST", ((ActiveMQTextMessage)message).getGroupID());
0:     }
0: 
0:     public void testSendMessageWithCustomHeadersAndSelector() throws Exception {
0: 
0:         MessageConsumer consumer = session.createConsumer(queue, "foo = 'abc'");
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "foo:abc\n" + "bar:123\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals("Hello World", message.getText());
0:         assertEquals("foo", "abc", message.getStringProperty("foo"));
0:         assertEquals("bar", "123", message.getStringProperty("bar"));
0:     }
0: 
0:     public void testSendMessageWithDelay() throws Exception {
0: 
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "AMQ_SCHEDULED_DELAY:5000\n"  + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2000);
0:         assertNull(message);
0:         message = (TextMessage)consumer.receive(5000);
1:         assertNotNull(message);
0:     }
0: 
0:     public void testSendMessageWithStandardHeaders() throws Exception {
0: 
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "correlation-id:c123\n" + "priority:3\n" + "type:t345\n" + "JMSXGroupID:abc\n" + "foo:abc\n" + "bar:123\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World"
0:                 + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals("Hello World", message.getText());
0:         assertEquals("JMSCorrelationID", "c123", message.getJMSCorrelationID());
0:         assertEquals("getJMSType", "t345", message.getJMSType());
0:         assertEquals("getJMSPriority", 3, message.getJMSPriority());
0:         assertEquals("foo", "abc", message.getStringProperty("foo"));
0:         assertEquals("bar", "123", message.getStringProperty("bar"));
0: 
0:         assertEquals("JMSXGroupID", "abc", message.getStringProperty("JMSXGroupID"));
0:         ActiveMQTextMessage amqMessage = (ActiveMQTextMessage)message;
0:         assertEquals("GroupID", "abc", amqMessage.getGroupID());
0:     }
0: 
0:     public void testSendMessageWithNoPriorityReceivesDefault() throws Exception {
0: 
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "correlation-id:c123\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World"
0:                 + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals("Hello World", message.getText());
0:         assertEquals("getJMSPriority", 4, message.getJMSPriority());
0:     }
0: 
0:     public void testReceipts() throws Exception {
0: 
0:         StompConnection receiver = new StompConnection();
0:         URI connectUri = new URI(bindAddress);
0:         receiver.open(createSocket(connectUri));
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         receiver.sendFrame(frame);
0: 
0:         frame = receiver.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         receiver.sendFrame(frame);
0: 
0:         frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt: msg-1\n" + "\n\n" + "Hello World" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = receiver.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0:         assertTrue("Stomp Message does not contain receipt request", frame.indexOf(Stomp.Headers.RECEIPT_REQUESTED) == -1);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("RECEIPT"));
0:         assertTrue("Receipt contains correct receipt-id", frame.indexOf(Stomp.Headers.Response.RECEIPT_ID) >= 0);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         receiver.sendFrame(frame);
0: 
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt: msg-1\n" + "\n\n" + "Hello World" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("RECEIPT"));
0:         assertTrue("Receipt contains correct receipt-id", frame.indexOf(Stomp.Headers.Response.RECEIPT_ID) >= 0);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(10000);
1:         assertNotNull(message);
0:         assertNull("JMS Message does not contain receipt request", message.getStringProperty(Stomp.Headers.RECEIPT_REQUESTED));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0: 
0:     public void testSubscriptionReceipts() throws Exception {
0:         final int done = 500;
0:         int count = 0;
0:         int receiptId = 0;
0: 
0:         URI connectUri = new URI(bindAddress);
0: 
0:         do {
0: 
0:             StompConnection sender = new StompConnection();
0:             sender.open(createSocket(connectUri));
0:             String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:             sender.sendFrame(frame);
0: 
0:             frame = sender.receiveFrame();
0:             assertTrue(frame.startsWith("CONNECTED"));
0: 
0:             frame = "SEND\n" + "destination:/queue/" + getQueueName()  + "\n"  + "receipt: " + (receiptId++) + "\n" + "Hello World:" + (count++) + "\n\n" +  Stomp.NULL;
0:             sender.sendFrame(frame);
0:             frame = sender.receiveFrame();
0:             assertTrue("" + frame, frame.startsWith("RECEIPT"));
0: 
0:             sender.disconnect();
0: 
0:             StompConnection receiver = new StompConnection();
0:             receiver.open(createSocket(connectUri));
0: 
0:             frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:             receiver.sendFrame(frame);
0: 
0:             frame = receiver.receiveFrame();
0:             assertTrue(frame.startsWith("CONNECTED"));
0: 
0:             frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n"  + "receipt: " +  (receiptId++)  + "\n\n" + Stomp.NULL;
0:             receiver.sendFrame(frame);
0: 
0:             frame = receiver.receiveFrame();
0:             assertTrue("" + frame, frame.startsWith("RECEIPT"));
0:             assertTrue("Receipt contains receipt-id", frame.indexOf(Stomp.Headers.Response.RECEIPT_ID) >= 0);
0:             frame = receiver.receiveFrame();
0:             assertTrue("" + frame, frame.startsWith("MESSAGE"));
0: 
0:             // remove suscription  so we don't hang about and get next message
0:             frame = "UNSUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n"  + "receipt: " +  (receiptId++)  + "\n\n" + Stomp.NULL;
0:             receiver.sendFrame(frame);
0:             frame = receiver.receiveFrame();
0:             assertTrue("" + frame, frame.startsWith("RECEIPT"));
0: 
0:             receiver.disconnect();
0:         } while (count < done);
0: 
0:     }
0: 
0:     public void testSubscribeWithAutoAck() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         sendMessage(getName());
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSubscribeWithAutoAckAndBytesMessage() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         sendBytesMessage(new byte[] {
0:             1, 2, 3, 4, 5
0:         });
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0: 
0:         Pattern cl = Pattern.compile("Content-length:\\s*(\\d+)", Pattern.CASE_INSENSITIVE);
0:         Matcher clMmatcher = cl.matcher(frame);
0:         assertTrue(clMmatcher.find());
0:         assertEquals("5", clMmatcher.group(1));
0: 
0:         assertFalse(Pattern.compile("type:\\s*null", Pattern.CASE_INSENSITIVE).matcher(frame).find());
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testBytesMessageWithNulls() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n destination:/queue/" + getQueueName() + "\ncontent-length:5" + " \n\n" + "\u0001\u0002\u0000\u0004\u0005" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         StompFrame message = stompConnection.receive();
0:         assertTrue(message.getAction().startsWith("MESSAGE"));
0: 
0:         String length = message.getHeaders().get("content-length");
0:         assertEquals("5", length);
0: 
0:         assertEquals(5, message.getContent().length);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSendMultipleBytesMessages() throws Exception {
0: 
0:         final int MSG_COUNT = 50;
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         for( int ix = 0; ix < MSG_COUNT; ix++) {
0:             frame = "SEND\n destination:/queue/" + getQueueName() + "\ncontent-length:5" + " \n\n" + "\u0001\u0002\u0000\u0004\u0005" + Stomp.NULL;
0:             stompConnection.sendFrame(frame);
0:         }
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         for( int ix = 0; ix < MSG_COUNT; ix++) {
0:             StompFrame message = stompConnection.receive();
0:             assertTrue(message.getAction().startsWith("MESSAGE"));
0: 
0:             String length = message.getHeaders().get("content-length");
0:             assertEquals("5", length);
0: 
0:             assertEquals(5, message.getContent().length);
0:         }
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSubscribeWithMessageSentWithProperties() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         MessageProducer producer = session.createProducer(queue);
0:         TextMessage message = session.createTextMessage("Hello World");
0:         message.setStringProperty("s", "value");
0:         message.setBooleanProperty("n", false);
0:         message.setByteProperty("byte", (byte)9);
0:         message.setDoubleProperty("d", 2.0);
0:         message.setFloatProperty("f", (float)6.0);
0:         message.setIntProperty("i", 10);
0:         message.setLongProperty("l", 121);
0:         message.setShortProperty("s", (short)12);
0:         producer.send(message);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0: 
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testMessagesAreInOrder() throws Exception {
0:         int ctr = 10;
0:         String[] data = new String[ctr];
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         for (int i = 0; i < ctr; ++i) {
0:             data[i] = getName() + i;
0:             sendMessage(data[i]);
0:         }
0: 
0:         for (int i = 0; i < ctr; ++i) {
0:             frame = stompConnection.receiveFrame();
0:             assertTrue("Message not in order", frame.indexOf(data[i]) >= 0);
0:         }
0: 
0:         // sleep a while before publishing another set of messages
0:         TimeUnit.SECONDS.sleep(2);
0: 
0:         for (int i = 0; i < ctr; ++i) {
0:             data[i] = getName() + ":second:" + i;
0:             sendMessage(data[i]);
0:         }
0: 
0:         for (int i = 0; i < ctr; ++i) {
0:             frame = stompConnection.receiveFrame();
0:             assertTrue("Message not in order", frame.indexOf(data[i]) >= 0);
0:         }
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSubscribeWithAutoAckAndSelector() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "selector: foo = 'zzz'\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         sendMessage("Ignored message", "foo", "1234");
0:         sendMessage("Real message", "foo", "zzz");
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0:         assertTrue("Should have received the real message but got: " + frame, frame.indexOf("Real message") > 0);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSubscribeWithAutoAckAndNumericSelector() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "selector: foo = 42\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // Ignored
0:         frame = "SEND\n" + "foo:abc\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Ignored Message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // Matches
0:         frame = "SEND\n" + "foo:42\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Real Message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0:         assertTrue("Should have received the real message but got: " + frame, frame.indexOf("Real Message") > 0);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSubscribeWithAutoAckAndBooleanSelector() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "selector: foo = true\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // Ignored
0:         frame = "SEND\n" + "foo:false\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Ignored Message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // Matches
0:         frame = "SEND\n" + "foo:true\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Real Message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0:         assertTrue("Should have received the real message but got: " + frame, frame.indexOf("Real Message") > 0);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSubscribeWithAutoAckAnFloatSelector() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "selector: foo = 3.14159\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // Ignored
0:         frame = "SEND\n" + "foo:6.578\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Ignored Message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // Matches
0:         frame = "SEND\n" + "foo:3.14159\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Real Message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0:         assertTrue("Should have received the real message but got: " + frame, frame.indexOf("Real Message") > 0);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testSubscribeWithClientAck() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:client\n\n" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0:         sendMessage(getName());
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0: 
0:         stompDisconnect();
0: 
0:         // message should be received since message was not acknowledged
0:         MessageConsumer consumer = session.createConsumer(queue);
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertTrue(message.getJMSRedelivered());
0:     }
0: 
0:     public void testSubscribeWithClientAckedAndContentLength() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:client\n\n" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0:         sendMessage(getName());
0:         StompFrame msg = stompConnection.receive();
0: 
0: 
0:         assertTrue(msg.getAction().equals("MESSAGE"));
0: 
0:         HashMap<String, String> ackHeaders = new HashMap<String, String>();
0:         ackHeaders.put("message-id", msg.getHeaders().get("message-id"));
0:         ackHeaders.put("content-length", "8511");
0: 
0:         StompFrame ack = new StompFrame("ACK", ackHeaders);
0:         stompConnection.sendFrame(ack.format());
0: 
0:         final QueueViewMBean queueView = getProxyToQueue(getQueueName());
0:         assertTrue("dequeue complete", Wait.waitFor(new Wait.Condition(){
0:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 LOG.info("queueView, enqueue:" + queueView.getEnqueueCount() +", dequeue:" + queueView.getDequeueCount() + ", inflight:" + queueView.getInFlightCount());
0:                 return queueView.getDequeueCount() == 1;
0:             }
0:         }));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         stompDisconnect();
0: 
0:         // message should not be received since it was acknowledged
0:         MessageConsumer consumer = session.createConsumer(queue);
0:         TextMessage message = (TextMessage)consumer.receive(500);
0:         assertNull(message);
0:     }
0: 
0:     public void testUnsubscribe() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // send a message to our queue
0:         sendMessage("first message");
0: 
0:         // receive message from socket
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0: 
0:         // remove suscription
0:         frame = "UNSUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "receipt:1" +  "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue("" + frame, frame.startsWith("RECEIPT"));
0: 
0:         // send a message to our queue
0:         sendMessage("second message");
0: 
0:         try {
0:             frame = stompConnection.receiveFrame();
0:             LOG.info("Received frame: " + frame);
0:             fail("No message should have been received since subscription was removed");
0:         } catch (SocketTimeoutException e) {
0:         }
0:     }
0: 
0:     public void testTransactionCommit() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         String f = stompConnection.receiveFrame();
0:         assertTrue(f.startsWith("CONNECTED"));
0: 
0:         frame = "BEGIN\n" + "transaction: tx1\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transaction: tx1\n" + "\n\n" + "Hello World" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "COMMIT\n" + "transaction: tx1\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(10000);
0:         assertNotNull("Should have received a message", message);
0:     }
0: 
0:     public void testTransactionRollback() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         String f = stompConnection.receiveFrame();
0:         assertTrue(f.startsWith("CONNECTED"));
0: 
0:         frame = "BEGIN\n" + "transaction: tx1\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transaction: tx1\n" + "\n" + "first message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // rollback first message
0:         frame = "ABORT\n" + "transaction: tx1\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "BEGIN\n" + "transaction: tx1\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transaction: tx1\n" + "\n" + "second message" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "COMMIT\n" + "transaction: tx1\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         // only second msg should be received since first msg was rolled back
0:         TextMessage message = (TextMessage)consumer.receive(10000);
1:         assertNotNull(message);
0:         assertEquals("second message", message.getText().trim());
0:     }
0: 
0:     public void testDisconnectedClientsAreRemovedFromTheBroker() throws Exception {
0:         assertClients(1);
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         assertClients(2);
0: 
0:         // now lets kill the stomp connection
0:         stompConnection.close();
0: 
0:         assertClients(1);
0:     }
0: 
0:     public void testConnectNotAuthenticatedWrongUser() throws Exception {
0:         String frame = "CONNECT\n" + "login: dejanb\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         String f = stompConnection.receiveFrame();
0: 
0:         assertTrue(f.startsWith("ERROR"));
0:         assertClients(1);
0:     }
0: 
0:     public void testConnectNotAuthenticatedWrongPassword() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: dejanb\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         String f = stompConnection.receiveFrame();
0: 
0:         assertTrue(f.startsWith("ERROR"));
0:         assertClients(1);
0:     }
0: 
0:     public void testSendNotAuthorized() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: guest\n" + "passcode: password\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/USERS." + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0:         String f = stompConnection.receiveFrame();
0:         assertTrue(f.startsWith("ERROR"));
0:     }
0: 
0:     public void testSubscribeNotAuthorized() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: guest\n" + "passcode: password\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0:         String f = stompConnection.receiveFrame();
0:         assertTrue(f.startsWith("ERROR"));
0: 
0:     }
0: 
0:     public void testTransformationUnknownTranslator() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:test" + "\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals("Hello World", message.getText());
0:     }
0: 
0:     public void testTransformationFailed() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_OBJECT_XML + "\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         assertNotNull(message.getStringProperty(Stomp.Headers.TRANSFORMATION_ERROR));
0:         assertEquals("Hello World", message.getText());
0:     }
0: 
0:     public void testTransformationSendXMLObject() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_OBJECT_XML + "\n\n" + xmlObject + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         ObjectMessage message = (ObjectMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         SamplePojo object = (SamplePojo)message.getObject();
0:         assertEquals("Dejan", object.getName());
0:     }
0: 
0:     public void testTransformationSendJSONObject() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_OBJECT_JSON + "\n\n" + jsonObject + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         ObjectMessage message = (ObjectMessage)consumer.receive(2500);
1:         assertNotNull(message);
0:         SamplePojo object = (SamplePojo)message.getObject();
0:         assertEquals("Dejan", object.getName());
0:     }
0: 
0:     public void testTransformationSubscribeXML() throws Exception {
0: 
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage message = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_OBJECT_XML + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(xmlObject));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationReceiveJSONObject() throws Exception {
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage message = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_OBJECT_JSON + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(jsonObject));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationReceiveXMLObject() throws Exception {
0: 
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage message = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_OBJECT_XML + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(xmlObject));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationReceiveObject() throws Exception {
0: 
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage message = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_OBJECT_XML + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(xmlObject));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationReceiveXMLObjectAndMap() throws Exception {
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage objMessage = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         producer.send(objMessage);
0: 
0:         MapMessage mapMessage = session.createMapMessage();
0:         mapMessage.setString("name", "Dejan");
0:         mapMessage.setString("city", "Belgrade");
0:         producer.send(mapMessage);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_XML + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(xmlObject));
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(xmlMap.trim()));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationReceiveJSONObjectAndMap() throws Exception {
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage objMessage = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         producer.send(objMessage);
0: 
0:         MapMessage mapMessage = session.createMapMessage();
0:         mapMessage.setString("name", "Dejan");
0:         mapMessage.setString("city", "Belgrade");
0:         producer.send(mapMessage);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_JSON + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(jsonObject));
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(jsonMap.trim()));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationSendAndReceiveXmlMap() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:" + Stomp.Transformations.JMS_XML + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_MAP_JSON + "\n\n" + jsonMap + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertNotNull(frame);
0:         assertTrue(frame.trim().endsWith(xmlMap.trim()));
0:         assertTrue(frame.contains("jms-map-xml"));
0:     }
0: 
0:     public void testTransformationSendAndReceiveJsonMap() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:" + Stomp.Transformations.JMS_JSON + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_MAP_XML + "\n\n" + xmlMap + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertNotNull(frame);
0:         assertTrue(frame.trim().endsWith(jsonMap.trim()));
0:         assertTrue(frame.contains("jms-map-json"));
0:     }
0: 
0:     public void testTransformationReceiveBytesMessage() throws Exception {
0: 
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         BytesMessage message = session.createBytesMessage();
0:         message.writeBytes(new byte[]{1, 2, 3, 4, 5});
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_XML + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("MESSAGE"));
0: 
0:         Pattern cl = Pattern.compile("Content-length:\\s*(\\d+)", Pattern.CASE_INSENSITIVE);
0:         Matcher clMmatcher = cl.matcher(frame);
0:         assertTrue(clMmatcher.find());
0:         assertEquals("5", clMmatcher.group(1));
0: 
0:         assertFalse(Pattern.compile("type:\\s*null", Pattern.CASE_INSENSITIVE).matcher(frame).find());
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationNotOverrideSubscription() throws Exception {
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage message = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         message.setStringProperty("transformation",	Stomp.Transformations.JMS_OBJECT_XML.toString());
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n" + "transformation:"	+ Stomp.Transformations.JMS_OBJECT_JSON + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(jsonObject));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationIgnoreTransformation() throws Exception {
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         ObjectMessage message = session.createObjectMessage(new SamplePojo("Dejan", "Belgrade"));
0:         message.setStringProperty("transformation", Stomp.Transformations.JMS_OBJECT_XML.toString());
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.endsWith("\n\n"));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationSendXMLMap() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_MAP_XML + "\n\n" + xmlMap + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         MapMessage message = (MapMessage) consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals(message.getString("name"), "Dejan");
0:     }
0: 
0:     public void testTransformationSendJSONMap() throws Exception {
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "transformation:" + Stomp.Transformations.JMS_MAP_JSON + "\n\n" + jsonMap + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         MapMessage message = (MapMessage) consumer.receive(2500);
1:         assertNotNull(message);
0:         assertEquals(message.getString("name"), "Dejan");
0:     }
0: 
0:     public void testTransformationReceiveXMLMap() throws Exception {
0: 
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         MapMessage message = session.createMapMessage();
0:         message.setString("name", "Dejan");
0:         message.setString("city", "Belgrade");
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto\n" + "transformation:" + Stomp.Transformations.JMS_MAP_XML + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(xmlMap.trim()));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransformationReceiveJSONMap() throws Exception {
0: 
0:         MessageProducer producer = session.createProducer(new ActiveMQQueue("USERS." + getQueueName()));
0:         MapMessage message = session.createMapMessage();
0:         message.setString("name", "Dejan");
0:         message.setString("city", "Belgrade");
0:         producer.send(message);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/USERS." + getQueueName() + "\n" + "ack:auto\n" + "transformation:" + Stomp.Transformations.JMS_MAP_JSON + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0: 
0:         assertTrue(frame.trim().endsWith(jsonMap.trim()));
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testDurableUnsub() throws Exception {
0:         // get broker JMX view
0: 
0:         String domain = "org.apache.activemq";
0:         ObjectName brokerName = new ObjectName(domain + ":Type=Broker,BrokerName=localhost");
0: 
0:         BrokerViewMBean view = (BrokerViewMBean)broker.getManagementContext().newProxyInstance(brokerName, BrokerViewMBean.class, true);
0: 
0:         // connect
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\nclient-id:test\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0:         assertEquals(view.getDurableTopicSubscribers().length, 0);
0: 
0:         // subscribe
0:         frame = "SUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "\n" + "ack:auto\nactivemq.subscriptionName:test\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:         // wait a bit for MBean to get refreshed
0:         try {
0:             Thread.sleep(400);
0:         } catch (InterruptedException e){}
0: 
0:         assertEquals(view.getDurableTopicSubscribers().length, 1);
0:         // disconnect
0:         frame = "DISCONNECT\nclient-id:test\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:         try {
0:             Thread.sleep(400);
0:         } catch (InterruptedException e){}
0: 
0:         //reconnect
0:         stompConnect();
0:         // connect
0:         frame = "CONNECT\n" + "login: system\n" + "passcode: manager\nclient-id:test\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         // unsubscribe
0:         frame = "UNSUBSCRIBE\n" + "destination:/topic/" + getQueueName() + "\n" + "ack:auto\nactivemq.subscriptionName:test\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:         try {
0:             Thread.sleep(400);
0:         } catch (InterruptedException e){}
0:         assertEquals(view.getDurableTopicSubscribers().length, 0);
0:     }
0: 
0:     public void testMessageIdHeader() throws Exception {
0:         stompConnection.connect("system", "manager");
0: 
0:         stompConnection.begin("tx1");
0:         stompConnection.send("/queue/" + getQueueName(), "msg", "tx1", null);
0:         stompConnection.commit("tx1");
0: 
0:         stompConnection.subscribe("/queue/" + getQueueName());
0:         StompFrame stompMessage = stompConnection.receive();
0:         assertNull(stompMessage.getHeaders().get("transaction"));
0:     }
0: 
0:     public void testPrefetchSize() throws Exception {
0:         stompConnection.connect("system", "manager");
0: 
0:         HashMap<String, String> headers = new HashMap<String, String>();
0:         headers.put("activemq.prefetchSize", "1");
0:         stompConnection.subscribe("/queue/" + getQueueName(), "client", headers);
0: 
0:         // send messages using JMS
0:         sendMessage("message 1");
0:         sendMessage("message 2");
0:         sendMessage("message 3");
0:         sendMessage("message 4");
0:         sendMessage("message 5");
0: 
0:         StompFrame frame = stompConnection.receive();
0:         assertEquals(frame.getBody(), "message 1");
0: 
0:         stompConnection.begin("tx1");
0:         stompConnection.ack(frame, "tx1");
0: 
0:         StompFrame frame1 = stompConnection.receive();
0:         assertEquals(frame1.getBody(), "message 2");
0: 
0:         try {
0:             StompFrame frame2 = stompConnection.receive(500);
0:             if (frame2 != null) {
0:                 fail("Should not have received the second message");
0:             }
0:         } catch (SocketTimeoutException soe) {}
0: 
0:         stompConnection.ack(frame1, "tx1");
0:         Thread.sleep(1000);
0:         stompConnection.abort("tx1");
0: 
0:         stompConnection.begin("tx2");
0: 
0:         // Previously delivered message need to get re-acked...
0:         stompConnection.ack(frame, "tx2");
0:         stompConnection.ack(frame1, "tx2");
0: 
0:         StompFrame frame3 = stompConnection.receive();
0:         assertEquals(frame3.getBody(), "message 3");
0:         stompConnection.ack(frame3, "tx2");
0: 
0:         StompFrame frame4 = stompConnection.receive();
0:         assertEquals(frame4.getBody(), "message 4");
0:         stompConnection.ack(frame4, "tx2");
0: 
0:         stompConnection.commit("tx2");
0: 
0:         stompConnection.begin("tx3");
0:         StompFrame frame5 = stompConnection.receive();
0:         assertEquals(frame5.getBody(), "message 5");
0:         stompConnection.ack(frame5, "tx3");
0:         stompConnection.commit("tx3");
0: 
0:         stompDisconnect();
0:     }
0: 
0:     public void testTransactionsWithMultipleDestinations() throws Exception {
0: 
0:         stompConnection.connect("system", "manager");
0: 
0:         HashMap<String, String> headers = new HashMap<String, String>();
0:         headers.put("activemq.prefetchSize", "1");
0:         headers.put("activemq.exclusive", "true");
0: 
0:         stompConnection.subscribe("/queue/test1", "client", headers);
0: 
0:         stompConnection.begin("ID:tx1");
0: 
0:         headers.clear();
0:         headers.put("receipt", "ID:msg1");
0:         stompConnection.send("/queue/test2", "test message", "ID:tx1", headers);
0: 
0:         stompConnection.commit("ID:tx1");
0: 
0:         // make sure connection is active after commit
0:         Thread.sleep(1000);
0:         stompConnection.send("/queue/test1", "another message");
0: 
0:         StompFrame frame = stompConnection.receive(500);
0:         assertNotNull(frame);
0: 
0:         stompConnection.disconnect();
0:     }
0: 
0:     public void testTempDestination() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/temp-queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/temp-queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         StompFrame message = stompConnection.receive(1000);
0:         assertEquals("Hello World", message.getBody());
0:     }
0: 
0:     public void testJMSXUserIDIsSetInMessage() throws Exception {
0: 
0:         MessageConsumer consumer = session.createConsumer(queue);
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;
0: 
0:         stompConnection.sendFrame(frame);
0: 
0:         TextMessage message = (TextMessage)consumer.receive(5000);
1:         assertNotNull(message);
0:         assertEquals("system", message.getStringProperty(Stomp.Headers.Message.USERID));
0:     }
0: 
0:     public void testJMSXUserIDIsSetInStompMessage() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n\n" + "Hello World" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         StompFrame message = stompConnection.receive(5000);
0:         assertEquals("system", message.getHeaders().get(Stomp.Headers.Message.USERID));
0:     }
0: 
0:     public void testClientSetMessageIdIsIgnored() throws Exception {
0:         HashMap<String, String> headers = new HashMap<String, String>();
0:         headers.put(Stomp.Headers.Message.MESSAGE_ID, "Thisisnotallowed");
0:         headers.put(Stomp.Headers.Message.TIMESTAMP, "1234");
0:         headers.put(Stomp.Headers.Message.REDELIVERED, "true");
0:         headers.put(Stomp.Headers.Message.SUBSCRIPTION, "Thisisnotallowed");
0:         headers.put(Stomp.Headers.Message.USERID, "Thisisnotallowed");
0: 
0:         stompConnection.connect("system", "manager");
0: 
0:         stompConnection.send("/queue/" + getQueueName(), "msg", null, headers);
0: 
0:         stompConnection.subscribe("/queue/" + getQueueName());
0:         StompFrame stompMessage = stompConnection.receive();
0: 
0:         Map<String, String> mess_headers = new HashMap<String, String>();
0:         mess_headers = stompMessage.getHeaders();
0: 
0:         assertFalse("Thisisnotallowed".equals(mess_headers.get(Stomp.Headers.Message.MESSAGE_ID)
0:                 ));
0:         assertFalse("1234".equals(mess_headers.get(Stomp.Headers.Message.TIMESTAMP)));
0:         assertNull(mess_headers.get(Stomp.Headers.Message.REDELIVERED));
0:         assertNull(mess_headers.get(Stomp.Headers.Message.SUBSCRIPTION));
0:         assertEquals("system", mess_headers.get(Stomp.Headers.Message.USERID));
0:     }
0: 
0:     public void testExpire() throws Exception {
0:         stompConnection.connect("system", "manager");
0: 
0:         HashMap<String, String> headers = new HashMap<String, String>();
0:         long timestamp = System.currentTimeMillis();
0:         headers.put(Stomp.Headers.Message.EXPIRATION_TIME, String.valueOf(timestamp));
0:         headers.put(Stomp.Headers.Send.PERSISTENT, "true");
0: 
0:         stompConnection.send("/queue/" + getQueueName(), "msg", null, headers);
0: 
0:         stompConnection.subscribe("/queue/ActiveMQ.DLQ");
0:         StompFrame stompMessage = stompConnection.receive(1000);
0:         assertNotNull(stompMessage);
0:         assertEquals(stompMessage.getHeaders().get(Stomp.Headers.Message.ORIGINAL_DESTINATION), "/queue/" + getQueueName());
0:     }
0: 
0:     public void testDefaultJMSReplyToDest() throws Exception {
0:         stompConnection.connect("system", "manager");
0: 
0:         HashMap<String, String> headers = new HashMap<String, String>();
0:         headers.put(Stomp.Headers.Send.REPLY_TO, "JustAString");
0:         headers.put(Stomp.Headers.Send.PERSISTENT, "true");
0: 
0:         stompConnection.send("/queue/" + getQueueName(), "msg-with-reply-to", null, headers);
0: 
0:         stompConnection.subscribe("/queue/" + getQueueName());
0:         StompFrame stompMessage = stompConnection.receive(1000);
0:         assertNotNull(stompMessage);
0:         assertEquals(""  + stompMessage, stompMessage.getHeaders().get(Stomp.Headers.Send.REPLY_TO), "JustAString");
0:     }
0: 
0:     public void testPersistent() throws Exception {
0:         stompConnection.connect("system", "manager");
0: 
0:         HashMap<String, String> headers = new HashMap<String, String>();
0:         headers.put(Stomp.Headers.Message.PERSISTENT, "true");
0: 
0:         stompConnection.send("/queue/" + getQueueName(), "hello", null, headers);
0: 
0:         stompConnection.subscribe("/queue/" + getQueueName());
0: 
0:         StompFrame stompMessage = stompConnection.receive();
0:         assertNotNull(stompMessage);
0:         assertNotNull(stompMessage.getHeaders().get(Stomp.Headers.Message.PERSISTENT));
0:         assertEquals(stompMessage.getHeaders().get(Stomp.Headers.Message.PERSISTENT), "true");
0:     }
0: 
0:     public void testPersistentDefaultValue() throws Exception {
0:         stompConnection.connect("system", "manager");
0: 
0:         HashMap<String, String> headers = new HashMap<String, String>();
0: 
0:         stompConnection.send("/queue/" + getQueueName(), "hello", null, headers);
0: 
0:         stompConnection.subscribe("/queue/" + getQueueName());
0: 
0:         StompFrame stompMessage = stompConnection.receive();
0:         assertNotNull(stompMessage);
0:         assertNull(stompMessage.getHeaders().get(Stomp.Headers.Message.PERSISTENT));
0:     }
0: 
0:     public void testReceiptNewQueue() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + 1234 + "\n" + "id:8fee4b8-4e5c9f66-4703-e936-3" + "\n" + "receipt:8fee4b8-4e5c9f66-4703-e936-2" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         StompFrame receipt = stompConnection.receive();
0:         assertTrue(receipt.getAction().startsWith("RECEIPT"));
0:         assertEquals("8fee4b8-4e5c9f66-4703-e936-2", receipt.getHeaders().get("receipt-id"));
0: 
0:         frame = "SEND\n destination:/queue/" + getQueueName() + 123 + "\ncontent-length:0" + " \n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + 123 + "\n" + "id:8fee4b8-4e5c9f66-4703-e936-2" + "\n" + "receipt:8fee4b8-4e5c9f66-4703-e936-1" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         receipt = stompConnection.receive();
0:         assertTrue(receipt.getAction().startsWith("RECEIPT"));
0:         assertEquals("8fee4b8-4e5c9f66-4703-e936-1", receipt.getHeaders().get("receipt-id"));
0: 
0:         StompFrame message = stompConnection.receive();
0:         assertTrue(message.getAction().startsWith("MESSAGE"));
0: 
0:         String length = message.getHeaders().get("content-length");
0:         assertEquals("0", length);
0:         assertEquals(0, message.getContent().length);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     public void testTransactedClientAckBrokerStats() throws Exception {
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         sendMessage(getName());
0:         sendMessage(getName());
0: 
0:         stompConnection.begin("tx1");
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:client\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         StompFrame message = stompConnection.receive();
0:         assertTrue(message.getAction().equals("MESSAGE"));
0:         stompConnection.ack(message, "tx1");
0: 
0:         message = stompConnection.receive();
0:         assertTrue(message.getAction().equals("MESSAGE"));
0:         stompConnection.ack(message, "tx1");
0: 
0:         stompConnection.commit("tx1");
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         final QueueViewMBean queueView = getProxyToQueue(getQueueName());
0:         Wait.waitFor(new Wait.Condition(){
0:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return queueView.getDequeueCount() == 2;
0:             }
0:         });
0:         assertEquals(2, queueView.getDispatchCount());
0:         assertEquals(2, queueView.getDequeueCount());
0:         assertEquals(0, queueView.getQueueSize());
0:     }
0: 
0:     public void testReplytoModification() throws Exception {
0:         String replyto = "some destination";
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = "SEND\n" + "destination:/queue/" + getQueueName() + "\n" + "reply-to:" + replyto + "\n\nhello world" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         StompFrame message = stompConnection.receive();
0:         assertTrue(message.getAction().equals("MESSAGE"));
0:         assertEquals(replyto, message.getHeaders().get("reply-to"));
0: 
0:         stompConnection.sendFrame("DISCONNECT\n" + "\n\n" + Stomp.NULL);
0:     }
0: 
0:     public void testReplyToDestinationNaming() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         doTestActiveMQReplyToTempDestination("topic");
0:         doTestActiveMQReplyToTempDestination("queue");
0:     }
0: 
0:     public void testSendNullBodyTextMessage() throws Exception {
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/" + getQueueName() + "\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         sendMessage(null);
0:         frame = stompConnection.receiveFrame();
0:         assertNotNull("Message not received", frame);
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0:     }
0: 
0:     private void doTestActiveMQReplyToTempDestination(String type) throws Exception {
0:         LOG.info("Starting test on Temp Destinations using a temporary: " + type);
0: 
0:         final String dest = "/" + type + "/" + getQueueName();
0:         final String tempDest = String.format("/temp-%s/2C26441740C0ECC9tt1", type);
0:         LOG.info("Test is using out-bound topic: " + dest + ", and replyTo dest: " + tempDest);
0: 
0:         // Subscribe both to the out-bound destination and the response tempt destination
0:         stompConnection.subscribe(dest);
0:         stompConnection.subscribe(tempDest);
0: 
0:         // Send a Message with the ReplyTo value set.
0:         HashMap<String, String> properties = new HashMap<String, String>();
0:         properties.put(Stomp.Headers.Send.REPLY_TO, tempDest);
0:         LOG.info(String.format("Sending request message: SEND with %s=%s", Stomp.Headers.Send.REPLY_TO, tempDest));
0:         stompConnection.send(dest, "REQUEST", null, properties);
0: 
0:         // The subscription should receive a response with the ReplyTo property set.
0:         StompFrame received = stompConnection.receive();
0:         assertNotNull(received);
0:         String remoteReplyTo = received.getHeaders().get(Stomp.Headers.Send.REPLY_TO);
0:         assertNotNull(remoteReplyTo);
0:         assertTrue(remoteReplyTo.startsWith(String.format("/temp-%s/", type)));
0:         LOG.info(String.format("Received request message: %s with %s=%s", received.getAction(), Stomp.Headers.Send.REPLY_TO, remoteReplyTo));
0: 
0:         // Reply to the request using the given ReplyTo destination
0:         stompConnection.send(remoteReplyTo, "RESPONSE");
0: 
0:         // The response should be received by the Temporary Destination subscription
0:         StompFrame reply = stompConnection.receive();
0:         assertNotNull(reply);
0:         assertEquals("MESSAGE", reply.getAction());
0:         LOG.info(String.format("Response %s received", reply.getAction()));
0: 
0:         BrokerViewMBean broker = getProxyToBroker();
0:         if (type.equals("topic")) {
0:             assertEquals(1, broker.getTemporaryTopics().length);
0:         } else {
0:             assertEquals(1, broker.getTemporaryQueues().length);
0:         }
0:     }
0: 
0:     public void testReplyToAcrossConnections() throws Exception {
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         doReplyToAcrossConnections("topic");
0:         doReplyToAcrossConnections("queue");
0:     }
0: 
0:     private void doReplyToAcrossConnections(String type) throws Exception {
0:         LOG.info("Starting test on Temp Destinations using a temporary: " + type);
0: 
0:         StompConnection responder = new StompConnection();
0:         stompConnect(responder);
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         responder.sendFrame(frame);
0: 
0:         frame = responder.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         final String dest = "/" + type + "/" + getQueueName();
0:         final String tempDest = String.format("/temp-%s/2C26441740C0ECC9tt1:1:0:1", type);
0:         LOG.info("Test is using out-bound topic: " + dest + ", and replyTo dest: " + tempDest);
0: 
0:         // Subscribe to the temp destination, this is where we get our response.
0:         stompConnection.subscribe(tempDest);
0: 
0:         // Subscribe to the Queue, this is where we get our request.
0:         responder.subscribe(dest);
0: 
0:         // Send a Message with the ReplyTo value set.
0:         HashMap<String, String> properties = new HashMap<String, String>();
0:         properties.put(Stomp.Headers.Send.REPLY_TO, tempDest);
0:         properties.put(Stomp.Headers.RECEIPT_REQUESTED, "send-1");
0:         LOG.info(String.format("Sending request message: SEND with %s=%s", Stomp.Headers.Send.REPLY_TO, tempDest));
0:         stompConnection.send(dest, "REQUEST", null, properties);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue("Receipt Frame: " + frame, frame.trim().startsWith("RECEIPT"));
0:         assertTrue("Receipt contains correct receipt-id " + frame, frame.indexOf(Stomp.Headers.Response.RECEIPT_ID) >= 0);
0: 
0: 
0:         // The subscription should receive a response with the ReplyTo property set.
0:         StompFrame received = responder.receive();
0:         assertNotNull(received);
0:         String remoteReplyTo = received.getHeaders().get(Stomp.Headers.Send.REPLY_TO);
0:         assertNotNull(remoteReplyTo);
0:         assertTrue(remoteReplyTo.startsWith(String.format("/remote-temp-%s/", type)));
0:         LOG.info(String.format("Received request message: %s with %s=%s", received.getAction(), Stomp.Headers.Send.REPLY_TO, remoteReplyTo));
0: 
0:         // Reply to the request using the given ReplyTo destination
0:         responder.send(remoteReplyTo, "RESPONSE");
0: 
0:         // The response should be received by the Temporary Destination subscription
0:         StompFrame reply = stompConnection.receive();
0:         assertNotNull(reply);
0:         assertEquals("MESSAGE", reply.getAction());
0:         assertTrue(reply.getBody().contains("RESPONSE"));
0:         LOG.info(String.format("Response %s received", reply.getAction()));
0: 
0:         BrokerViewMBean broker = getProxyToBroker();
0:         if (type.equals("topic")) {
0:             assertEquals(1, broker.getTemporaryTopics().length);
0:         } else {
0:             assertEquals(1, broker.getTemporaryQueues().length);
0:         }
0:     }
0: 
0:     private BrokerViewMBean getProxyToBroker() throws MalformedObjectNameException, JMSException {
0:         ObjectName brokerViewMBean = new ObjectName(
0:             "org.apache.activemq:Type=Broker,BrokerName=localhost");
0:         BrokerViewMBean proxy = (BrokerViewMBean) broker.getManagementContext()
0:                 .newProxyInstance(brokerViewMBean, BrokerViewMBean.class, true);
0:         return proxy;
0:     }
0: 
0:     private QueueViewMBean getProxyToQueue(String name) throws MalformedObjectNameException, JMSException {
0:         ObjectName queueViewMBeanName = new ObjectName("org.apache.activemq"
0:                 + ":Type=Queue,Destination=" + name
0:                 + ",BrokerName=localhost");
0:         QueueViewMBean proxy = (QueueViewMBean) broker.getManagementContext()
0:                 .newProxyInstance(queueViewMBeanName, QueueViewMBean.class, true);
0:         return proxy;
0:     }
0: 
0:     protected void assertClients(final int expected) throws Exception {
0:         Wait.waitFor(new Wait.Condition()
1:         {
0:             @Override
1:             public boolean isSatisified() throws Exception {
0:                 return broker.getBroker().getClients().length == expected;
0:             }
0:         });
0:         org.apache.activemq.broker.Connection[] clients = broker.getBroker().getClients();
0:         int actual = clients.length;
0: 
0:         assertEquals("Number of clients", expected, actual);
0:     }
0: 
0:     public void testDisconnectDoesNotDeadlockBroker() throws Exception {
0:         for (int i = 0; i < 20; ++i) {
0:             doTestConnectionLeak();
0:         }
0:     }
0: 
0:     private void doTestConnectionLeak() throws Exception {
0:         stompConnect();
0: 
0:         String frame = "CONNECT\n" + "login: system\n" + "passcode: manager\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         frame = stompConnection.receiveFrame();
0:         assertTrue(frame.startsWith("CONNECTED"));
0: 
0:         boolean gotMessage = false;
0:         boolean gotReceipt = false;
0: 
0:         char[] payload = new char[1024];
0:         Arrays.fill(payload, 'A');
0: 
0:         String test = "SEND\n" +
0:                 "x-type:DEV-3485\n"  +
0:                 "x-uuid:" + UUID.randomUUID() + "\n"  +
0:                 "persistent:true\n"  +
0:                 "receipt:" + UUID.randomUUID() + "\n" +
0:                 "destination:/queue/test.DEV-3485" +
0:                 "\n\n" +
0:                 new String(payload) + Stomp.NULL;
0: 
0:         frame = "SUBSCRIBE\n" + "destination:/queue/test.DEV-3485\n" + "ack:auto\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         stompConnection.sendFrame(test);
0: 
0:         // We only want one of them, to trigger the shutdown and potentially
0:         // see a deadlock.
0:         while (!gotMessage && !gotReceipt) {
0:             frame = stompConnection.receiveFrame();
0: 
0:             LOG.debug("Received the frame: " + frame);
0: 
0:             if (frame.startsWith("RECEIPT")) {
0:                 gotReceipt = true;
0:             } else if(frame.startsWith("MESSAGE")) {
0:                 gotMessage = true;
0:             } else {
0:                 fail("Received a frame that we were not expecting.");
0:             }
0:         }
0: 
0:         frame = "DISCONNECT\n" + "\n\n" + Stomp.NULL;
0:         stompConnection.sendFrame(frame);
0: 
0:         stompConnection.close();
0:     }
0: }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:e2b932e
/////////////////////////////////////////////////////////////////////////
0:         byte[] payload = new byte[1024 * 32];
0:         for (int i = 0; i < payload.length; i++){
1:             payload[i] = '2';
1:         int numberOfRuns = 100;
1:         int messagesPerRun = 2;
0:         addMQTTConnector("trace=true");
0:         brokerService.start();
0:         MQTT mqttPub = createMQTTConnection();
0:         mqttPub.setClientId("MQTT-Pub-Client");
0:         MQTT mqttSub = createMQTTConnection();
0:         mqttSub.setClientId("MQTT-Sub-Client");
0:         mqttSub.setCleanSession(false);
0: 
1:         final BlockingConnection connectionPub = mqttPub.blockingConnection();
0:         connectionPub.connect();
0: 
0:         BlockingConnection connectionSub = mqttSub.blockingConnection();
0:         connectionSub.connect();
0: 
0:         Topic[] topics = {new Topic("TopicA", QoS.EXACTLY_ONCE)};
1:         connectionSub.subscribe(topics);
0: 
1:         for (int i = 0; i < messagesPerRun; ++i) {
1:             connectionPub.publish(topics[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
0:         }
0: 
1:         int received = 0;
1:         for (int i = 0; i < messagesPerRun; ++i) {
1:             Message message = connectionSub.receive(5, TimeUnit.SECONDS);
1:             received++;
1:             payload = message.getPayload();
0:             LOG.info("Received message from topic: " + message.getTopic() +
0:                      " Message content: " + messageContent);
1:         connectionSub.disconnect();
0:         for(int j = 0; j < numberOfRuns; j++) {
0: 
1:             for (int i = 0; i < messagesPerRun; ++i) {
1:                 connectionPub.publish(topics[0].name().toString(), payload, QoS.AT_LEAST_ONCE, false);
0:             }
0: 
0:             mqttSub = createMQTTConnection();
0:             mqttSub.setClientId("MQTT-Sub-Client");
0:             mqttSub.setCleanSession(false);
0: 
0:             connectionSub = mqttSub.blockingConnection();
0:             connectionSub.connect();
1:             connectionSub.subscribe(topics);
0: 
1:             for (int i = 0; i < messagesPerRun; ++i) {
1:                 Message message = connectionSub.receive(5, TimeUnit.SECONDS);
0:                 assertNotNull(message);
1:                 received++;
1:                 payload = message.getPayload();
1:                 String messageContent = new String(payload);
0:                 LOG.info("Received message from topic: " + message.getTopic() +
0:                          " Message content: " + messageContent);
0:                 message.ack();
0:             }
1:             connectionSub.disconnect();
0:         }
1:         assertEquals("Should have received " + (messagesPerRun * (numberOfRuns + 1)) + " messages", (messagesPerRun * (numberOfRuns + 1)), received);
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Client Received:\n"+frame);
0:                 LOG.info("Client Sent:\n" + frame);
commit:2484c67
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.TimeUnit;
0: 
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=300000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=300000)
1:     public void testReceiveMessageSentWhileOffline() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
0:         final MQTTClientProvider publisher = getMQTTClientProvider();
0:         initializeConnection(publisher);
0: 
0:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("MQTT-Client");
1:         mqtt.setCleanSession(false);
0: 
1:         {
0:             final BlockingConnection subscriber = mqtt.blockingConnection();
0:             subscriber.connect();
0:             Topic[] topic = {new Topic("foo", QoS.EXACTLY_ONCE)};
0:             subscriber.subscribe(topic);
0: 
0:             for (int i = 0; i < numberOfMessages; i++) {
0:                 String payload = "Test Message: " + i;
0:                 publisher.publish("foo", payload.getBytes(), EXACTLY_ONCE);
0:             }
0: 
0:             for (int i = 0; i < numberOfMessages / 2; i++) {
0:                 Message message = subscriber.receive(5, TimeUnit.SECONDS);
0:                 assertNotNull(message);
0:                 byte[] payload = message.getPayload();
0:                 String messageContent = new String(payload);
0:                 if (i % 100 == 0) {
0:                     LOG.debug("Received message from topic: " + message.getTopic() +
0:                               " Message content: " + messageContent);
0:                 }
0:                 message.ack();
0:             }
0: 
0:             subscriber.disconnect();
0:         }
0: 
0:         publisher.disconnect();
0: 
0:         final BlockingConnection subscriber = mqtt.blockingConnection();
0:         subscriber.connect();
0:         Topic[] topic = {new Topic("foo", QoS.EXACTLY_ONCE)};
0:         subscriber.subscribe(topic);
0: 
0:         for (int i = 0; i < numberOfMessages / 2; i++) {
0:             Message message = subscriber.receive(5, TimeUnit.SECONDS);
0:             assertNotNull(message);
0:             byte[] payload = message.getPayload();
0:             String messageContent = new String(payload);
0:             if (i % 100 == 0) {
0:                 LOG.debug("Received message from topic: " + message.getTopic() +
0:                           " Message content: " + messageContent);
0:             }
0:             message.ack();
0:         }
0: 
0:         subscriber.disconnect();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         return createMQTTConnection(null, false);
0:     }
0: 
0:     protected MQTT createMQTTConnection(String clientId, boolean clean) throws Exception {
0:         if (clientId != null) {
0:             mqtt.setClientId(clientId);
0:         }
0:         mqtt.setCleanSession(clean);
commit:3845c7c
/////////////////////////////////////////////////////////////////////////
0: import org.fusesource.mqtt.client.Message;
0: import org.fusesource.mqtt.client.QoS;
0: import org.fusesource.mqtt.client.Topic;
/////////////////////////////////////////////////////////////////////////
1:     public void testSubscribeMultipleTopics() throws Exception {
0:         byte[] payload = new byte[1024 * 32];
0:         for (int i = 0; i < payload.length; i++){
0:             payload[i] = '2';
0:         }
0: 
0:         addMQTTConnector();
0:         brokerService.start();
0:         MQTT mqtt = createMQTTConnection();
0:         mqtt.setClientId("MQTT-Client");
0:         mqtt.setCleanSession(false);
0: 
0:         final BlockingConnection connection = mqtt.blockingConnection();
0:         connection.connect();
0: 
0:         Topic[] topics = {new Topic("TopicA", QoS.EXACTLY_ONCE), new Topic("TopicB", QoS.EXACTLY_ONCE)};
0:         connection.subscribe(topics);
0: 
1:         for (Topic topic : topics) {
1:             connection.publish(topic.name().toString(), payload, QoS.AT_LEAST_ONCE, false);
0:         }
0: 
1:         int received = 0;
1:         for (int i = 0; i < topics.length; ++i) {
0:             Message message = connection.receive();
0:             assertNotNull(message);
0:             received++;
0:             payload = message.getPayload();
0:             String messageContent = new String(payload);
0:             LOG.info("Received message from topic: " + message.getTopic() +
0:                      " Message content: " + messageContent);
0:             message.ack();
0:         }
0: 
1:         assertEquals("Should have received " + topics.length + " messages", topics.length, received);
0:     }
0: 
commit:7b5f956
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=300000)
1:     public void testReuseConnection() throws Exception {
0:         addMQTTConnector();
0:         brokerService.start();
0: 
0:         MQTT mqtt = createMQTTConnection();
1:         mqtt.setClientId("Test-Client");
0: 
0:         {
0:             BlockingConnection connection = mqtt.blockingConnection();
0:             connection.connect();
0:             connection.disconnect();
0:             Thread.sleep(1000);
0:         }
0:         {
0:             BlockingConnection connection = mqtt.blockingConnection();
0:             connection.connect();
0:             connection.disconnect();
0:             Thread.sleep(1000);
0:         }
0:     }
0: 
commit:f60da98
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertTrue;
0: 
0:     @Test(timeout=300000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=300000)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:     @Override
0:     @Override
0:         mqttConnector = brokerService.addConnector(getProtocolScheme()+"://localhost:0" + config);
commit:6e8bd45
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
/////////////////////////////////////////////////////////////////////////
0:     @Test(timeout=30000)
commit:d3571a6
/////////////////////////////////////////////////////////////////////////
0: import static org.fusesource.hawtbuf.UTF8Buffer.utf8;
0: import static org.junit.Assert.assertArrayEquals;
0: import static org.junit.Assert.assertEquals;
0: import static org.junit.Assert.assertNotNull;
0: import static org.junit.Assert.assertTrue;
0: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.Wait;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final TransportConnector mqttConnector = brokerService.getTransportConnectorByScheme("mqtt");
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("MQTT Connection should be registered.", Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return mqttConnector.getConnections().size() > 0;
0:             }
0:         }));
0: 
0:         // wait for broker to time out the MQTT connection due to inactivity
0:         assertTrue("MQTT Connection should be timed out.", Wait.waitFor(new Wait.Condition() {
0: 
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return mqttConnector.getConnections().size() == 0;
0:             }
0:         }));
0: 
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
1:                 return connection.isConnected();
0:             }
0:         }));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
1:                 return connection.isConnected();
0:             }
0:         }));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
1:                 return connection.isConnected();
0:             }
0:         }));
/////////////////////////////////////////////////////////////////////////
0:         assertTrue("KeepAlive didn't work properly", Wait.waitFor(new Wait.Condition() {
0:             @Override
0:             public boolean isSatisified() throws Exception {
0:                 return connection.isConnected();
0:             }
0:         }));
/////////////////////////////////////////////////////////////////////////
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:f20e17a
/////////////////////////////////////////////////////////////////////////
0:         mqtt.setReconnectAttemptsMax(0);
/////////////////////////////////////////////////////////////////////////
0: //                LOG.info("Client Received:\n"+frame);
0: //                LOG.info("Client Sent:\n" + frame);
commit:d2d4180
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector("transport.useInactivityMonitor=false");
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector("transport.defaultKeepAlive=2000");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 LOG.info("Client Received:\n"+frame);
0:                 LOG.info("Client Sent:\n" + frame);
commit:e0ae445
/////////////////////////////////////////////////////////////////////////
1: import org.fusesource.mqtt.client.Tracer;
1: import org.fusesource.mqtt.codec.MQTTFrame;
0: import org.slf4j.Logger;
0: import org.slf4j.LoggerFactory;
0:     private static final Logger LOG = LoggerFactory.getLogger(MQTTTest.class);
0: 
/////////////////////////////////////////////////////////////////////////
0:         mqtt.setConnectAttemptsMax(1);
0:         mqtt.setTracer(createTracer());
0: 
0:     protected Tracer createTracer() {
0:         return new Tracer(){
0:             @Override
0:             public void onReceive(MQTTFrame frame) {
0:                 LOG.info("recv: "+frame);
0:             }
0: 
0:             @Override
0:             public void onSend(MQTTFrame frame) {
0:                 LOG.info("send: " + frame);
0:             }
0: 
0:             @Override
0:             public void debug(String message, Object... args) {
0:                 LOG.info(message, args);
0:             }
0:         };
0:     }
0: 
commit:a68916d
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
0: import java.net.URL;
0: import java.security.ProtectionDomain;
/////////////////////////////////////////////////////////////////////////
0: import org.junit.Ignore;
0: 
0:     public File basedir() throws IOException {
0:         ProtectionDomain protectionDomain = getClass().getProtectionDomain();
0:         return new File(new File(protectionDomain.getCodeSource().getLocation().getPath()), "../..").getCanonicalFile();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
0:         MQTT mqtt = createMQTTConnection();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
0:         TransportConnector openwireTransport = brokerService.addConnector("tcp://localhost:0");
0:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory(openwireTransport.getConnectUri()).createConnection();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
0:         TransportConnector openwireTransport = brokerService.addConnector("tcp://localhost:0");
0:         ActiveMQConnection activeMQConnection = (ActiveMQConnection) new ActiveMQConnectionFactory(openwireTransport.getConnectUri()).createConnection();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
/////////////////////////////////////////////////////////////////////////
0:                 new URI("tcp://localhost:"+mqttConnector.getConnectUri().getPort()), null);
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector();
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector("?transport.useInactivityMonitor=false");
/////////////////////////////////////////////////////////////////////////
0:         addMQTTConnector("?transport.defaultKeepAlive=2000");
/////////////////////////////////////////////////////////////////////////
0:     TransportConnector mqttConnector;
0: 
0:     protected String getProtocolScheme() {
0:         return "mqtt";
0:     protected void addMQTTConnector() throws Exception {
0:         addMQTTConnector("");
0:     }
0: 
0:     protected void addMQTTConnector(String config) throws Exception {
0:         mqttConnector= brokerService.addConnector(getProtocolScheme()+"://localhost:0" + config);
0:         mqtt.setHost("localhost", mqttConnector.getConnectUri().getPort());
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:5b63698
/////////////////////////////////////////////////////////////////////////
0: import static org.junit.Assert.assertNotNull;
/////////////////////////////////////////////////////////////////////////
0:         brokerService.setUseJmx(false);
/////////////////////////////////////////////////////////////////////////
0:                         Message message = subscribeConnection.receive(5, TimeUnit.SECONDS);
0:                         assertNotNull("Should get a message", message);
/////////////////////////////////////////////////////////////////////////
0:             connection.publish("foo2", payload.getBytes(), QoS.AT_MOST_ONCE, false);
0:             Message message = connection.receive(5, TimeUnit.SECONDS);
0:             assertNotNull("Should get a message", message);
/////////////////////////////////////////////////////////////////////////
0:             Message message = connection.receive(5, TimeUnit.SECONDS);
0:             assertNotNull("Should get a message", message);
/////////////////////////////////////////////////////////////////////////
0:             Message message = subConnection.receive(5, TimeUnit.SECONDS);
0:             assertNotNull("Should get a message", message);
0:             LOG.debug(payload);
/////////////////////////////////////////////////////////////////////////
0:             Message message = subConnection.receive(5, TimeUnit.SECONDS);
0:             assertNotNull("Should get a message", message);
/////////////////////////////////////////////////////////////////////////
0:             ActiveMQMessage message = (ActiveMQMessage) consumer.receive(5000);
0:             assertNotNull("Should get a message", message);
/////////////////////////////////////////////////////////////////////////
0:             Message message = connection.receive(5, TimeUnit.SECONDS);
0:             assertNotNull("Should get a message", message);
author:Gary Tully
-------------------------------------------------------------------------------
commit:e32d6f6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.AutoFailTestSupport;
/////////////////////////////////////////////////////////////////////////
0:     AutoFailTestSupport autoFailTestSupport = new AutoFailTestSupport() {};
0:         autoFailTestSupport.startAutoFailThread();
/////////////////////////////////////////////////////////////////////////
0:         autoFailTestSupport.stopAutoFailThread();
============================================================================