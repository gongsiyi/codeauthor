1:3f32507: /*
1:3f32507:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:3f32507:  *  contributor license agreements.  See the NOTICE file distributed with
1:3f32507:  *  this work for additional information regarding copyright ownership.
1:3f32507:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:3f32507:  *  (the "License"); you may not use this file except in compliance with
1:3f32507:  *  the License.  You may obtain a copy of the License at
1:3f32507:  *
1:3f32507:  *      http://www.apache.org/licenses/LICENSE-2.0
1:3f32507:  *
1:3f32507:  *  Unless required by applicable law or agreed to in writing, software
1:3f32507:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:3f32507:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3f32507:  *  See the License for the specific language governing permissions and
1:3f32507:  *  limitations under the License.
1:3f32507:  *
1:3f32507:  */
1:3f32507: 
1:3f32507: /*
1:3f32507:  * This package is based on the work done by Timothy Gerard Endres
1:3f32507:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
1:3f32507:  */
1:3f32507: 
1:3f32507: package org.apache.activemq.console.command.store.tar;
1:3f32507: 
1:3f32507: import java.io.FilterOutputStream;
1:3f32507: import java.io.OutputStream;
1:3f32507: import java.io.IOException;
1:3f32507: 
1:3f32507: /**
1:3f32507:  * The TarOutputStream writes a UNIX tar archive as an OutputStream.
1:3f32507:  * Methods are provided to put entries, and then write their contents
1:3f32507:  * by writing to this stream using write().
1:3f32507:  *
1:3f32507:  */
1:3f32507: public class TarOutputStream extends FilterOutputStream {
1:3f32507:     /** Fail if a long file name is required in the archive. */
1:3f32507:     public static final int LONGFILE_ERROR = 0;
1:3f32507: 
1:3f32507:     /** Long paths will be truncated in the archive. */
1:3f32507:     public static final int LONGFILE_TRUNCATE = 1;
1:3f32507: 
1:3f32507:     /** GNU tar extensions are used to store long file names in the archive. */
1:3f32507:     public static final int LONGFILE_GNU = 2;
1:3f32507: 
1:3f32507:     // CheckStyle:VisibilityModifier OFF - bc
1:3f32507:     protected boolean   debug;
1:3f32507:     protected long      currSize;
1:3f32507:     protected String    currName;
1:3f32507:     protected long      currBytes;
1:3f32507:     protected byte[]    oneBuf;
1:3f32507:     protected byte[]    recordBuf;
1:3f32507:     protected int       assemLen;
1:3f32507:     protected byte[]    assemBuf;
1:3f32507:     protected TarBuffer buffer;
1:3f32507:     protected int       longFileMode = LONGFILE_ERROR;
1:3f32507:     // CheckStyle:VisibilityModifier ON
1:3f32507: 
1:3f32507:     private boolean closed = false;
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Constructor for TarInputStream.
1:3f32507:      * @param os the output stream to use
1:3f32507:      */
1:3f32507:     public TarOutputStream(OutputStream os) {
1:3f32507:         this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Constructor for TarInputStream.
1:3f32507:      * @param os the output stream to use
1:3f32507:      * @param blockSize the block size to use
1:3f32507:      */
1:3f32507:     public TarOutputStream(OutputStream os, int blockSize) {
1:3f32507:         this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Constructor for TarInputStream.
1:3f32507:      * @param os the output stream to use
1:3f32507:      * @param blockSize the block size to use
1:3f32507:      * @param recordSize the record size to use
1:3f32507:      */
1:3f32507:     public TarOutputStream(OutputStream os, int blockSize, int recordSize) {
1:3f32507:         super(os);
1:3f32507: 
1:3f32507:         this.buffer = new TarBuffer(os, blockSize, recordSize);
1:3f32507:         this.debug = false;
1:3f32507:         this.assemLen = 0;
1:3f32507:         this.assemBuf = new byte[recordSize];
1:3f32507:         this.recordBuf = new byte[recordSize];
1:3f32507:         this.oneBuf = new byte[1];
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Set the long file mode.
1:3f32507:      * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).
1:3f32507:      * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).
1:3f32507:      * Default is LONGFILE_ERROR.
1:3f32507:      * @param longFileMode the mode to use
1:3f32507:      */
1:3f32507:     public void setLongFileMode(int longFileMode) {
1:3f32507:         this.longFileMode = longFileMode;
1:3f32507:     }
1:3f32507: 
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Sets the debugging flag.
1:3f32507:      *
1:3f32507:      * @param debugF True to turn on debugging.
1:3f32507:      */
1:3f32507:     public void setDebug(boolean debugF) {
1:3f32507:         this.debug = debugF;
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Sets the debugging flag in this stream's TarBuffer.
1:3f32507:      *
1:3f32507:      * @param debug True to turn on debugging.
1:3f32507:      */
1:3f32507:     public void setBufferDebug(boolean debug) {
1:3f32507:         buffer.setDebug(debug);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Ends the TAR archive without closing the underlying OutputStream.
1:3f32507:      * The result is that the two EOF records of nulls are written.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void finish() throws IOException {
1:3f32507:         // See Bugzilla 28776 for a discussion on this
1:3f32507:         // http://issues.apache.org/bugzilla/show_bug.cgi?id=28776
1:3f32507:         writeEOFRecord();
1:3f32507:         writeEOFRecord();
1:3f32507:         buffer.flushBlock();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Ends the TAR archive and closes the underlying OutputStream.
1:3f32507:      * This means that finish() is called followed by calling the
1:3f32507:      * TarBuffer's close().
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void close() throws IOException {
1:3f32507:         if (!closed) {
1:3f32507:             finish();
1:3f32507:             buffer.close();
1:3f32507:             out.close();
1:3f32507:             closed = true;
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Get the record size being used by this stream's TarBuffer.
1:3f32507:      *
1:3f32507:      * @return The TarBuffer record size.
1:3f32507:      */
1:3f32507:     public int getRecordSize() {
1:3f32507:         return buffer.getRecordSize();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Put an entry on the output stream. This writes the entry's
1:3f32507:      * header record and positions the output stream for writing
1:3f32507:      * the contents of the entry. Once this method is called, the
1:3f32507:      * stream is ready for calls to write() to write the entry's
1:3f32507:      * contents. Once the contents are written, closeEntry()
1:3f32507:      * <B>MUST</B> be called to ensure that all buffered data
1:3f32507:      * is completely written to the output stream.
1:3f32507:      *
1:3f32507:      * @param entry The TarEntry to be written to the archive.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void putNextEntry(TarEntry entry) throws IOException {
1:3f32507:         if (entry.getName().length() >= TarConstants.NAMELEN) {
1:3f32507: 
1:3f32507:             if (longFileMode == LONGFILE_GNU) {
1:3f32507:                 // create a TarEntry for the LongLink, the contents
1:3f32507:                 // of which are the entry's name
1:3f32507:                 TarEntry longLinkEntry = new TarEntry(TarConstants.GNU_LONGLINK,
1:3f32507:                                                       TarConstants.LF_GNUTYPE_LONGNAME);
1:3f32507: 
1:3f32507:                 longLinkEntry.setSize(entry.getName().length() + 1);
1:3f32507:                 putNextEntry(longLinkEntry);
1:3f32507:                 write(entry.getName().getBytes());
1:3f32507:                 write(0);
1:3f32507:                 closeEntry();
1:3f32507:             } else if (longFileMode != LONGFILE_TRUNCATE) {
1:3f32507:                 throw new RuntimeException("file name '" + entry.getName()
1:3f32507:                                              + "' is too long ( > "
1:3f32507:                                              + TarConstants.NAMELEN + " bytes)");
1:3f32507:             }
1:3f32507:         }
1:3f32507: 
1:3f32507:         entry.writeEntryHeader(recordBuf);
1:3f32507:         buffer.writeRecord(recordBuf);
1:3f32507: 
1:3f32507:         currBytes = 0;
1:3f32507: 
1:3f32507:         if (entry.isDirectory()) {
1:3f32507:             currSize = 0;
1:3f32507:         } else {
1:3f32507:             currSize = entry.getSize();
1:3f32507:         }
1:3f32507:         currName = entry.getName();
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Close an entry. This method MUST be called for all file
1:3f32507:      * entries that contain data. The reason is that we must
1:3f32507:      * buffer data written to the stream in order to satisfy
1:3f32507:      * the buffer's record based writes. Thus, there may be
1:3f32507:      * data fragments still being assembled that must be written
1:3f32507:      * to the output stream before this entry is closed and the
1:3f32507:      * next entry written.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void closeEntry() throws IOException {
1:3f32507:         if (assemLen > 0) {
1:3f32507:             for (int i = assemLen; i < assemBuf.length; ++i) {
1:3f32507:                 assemBuf[i] = 0;
1:3f32507:             }
1:3f32507: 
1:3f32507:             buffer.writeRecord(assemBuf);
1:3f32507: 
1:3f32507:             currBytes += assemLen;
1:3f32507:             assemLen = 0;
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (currBytes < currSize) {
1:3f32507:             throw new IOException("entry '" + currName + "' closed at '"
1:3f32507:                                   + currBytes
1:3f32507:                                   + "' before the '" + currSize
1:3f32507:                                   + "' bytes specified in the header were written");
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Writes a byte to the current tar archive entry.
1:3f32507:      *
1:3f32507:      * This method simply calls read( byte[], int, int ).
1:3f32507:      *
1:3f32507:      * @param b The byte written.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void write(int b) throws IOException {
1:3f32507:         oneBuf[0] = (byte) b;
1:3f32507: 
1:3f32507:         write(oneBuf, 0, 1);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Writes bytes to the current tar archive entry.
1:3f32507:      *
1:3f32507:      * This method simply calls write( byte[], int, int ).
1:3f32507:      *
1:3f32507:      * @param wBuf The buffer to write to the archive.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void write(byte[] wBuf) throws IOException {
1:3f32507:         write(wBuf, 0, wBuf.length);
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Writes bytes to the current tar archive entry. This method
1:3f32507:      * is aware of the current entry and will throw an exception if
1:3f32507:      * you attempt to write bytes past the length specified for the
1:3f32507:      * current entry. The method is also (painfully) aware of the
1:3f32507:      * record buffering required by TarBuffer, and manages buffers
1:3f32507:      * that are not a multiple of recordsize in length, including
1:3f32507:      * assembling records from small buffers.
1:3f32507:      *
1:3f32507:      * @param wBuf The buffer to write to the archive.
1:3f32507:      * @param wOffset The offset in the buffer from which to get bytes.
1:3f32507:      * @param numToWrite The number of bytes to write.
1:3f32507:      * @throws IOException on error
1:3f32507:      */
1:3f32507:     public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
1:3f32507:         if ((currBytes + numToWrite) > currSize) {
1:3f32507:             throw new IOException("request to write '" + numToWrite
1:3f32507:                                   + "' bytes exceeds size in header of '"
1:3f32507:                                   + currSize + "' bytes for entry '"
1:3f32507:                                   + currName + "'");
1:3f32507: 
1:3f32507:             //
1:3f32507:             // We have to deal with assembly!!!
1:3f32507:             // The programmer can be writing little 32 byte chunks for all
1:3f32507:             // we know, and we must assemble complete records for writing.
1:3f32507:             // REVIEW Maybe this should be in TarBuffer? Could that help to
1:3f32507:             // eliminate some of the buffer copying.
1:3f32507:             //
1:3f32507:         }
1:3f32507: 
1:3f32507:         if (assemLen > 0) {
1:3f32507:             if ((assemLen + numToWrite) >= recordBuf.length) {
1:3f32507:                 int aLen = recordBuf.length - assemLen;
1:3f32507: 
1:3f32507:                 System.arraycopy(assemBuf, 0, recordBuf, 0,
1:3f32507:                                  assemLen);
1:3f32507:                 System.arraycopy(wBuf, wOffset, recordBuf,
1:3f32507:                                  assemLen, aLen);
1:3f32507:                 buffer.writeRecord(recordBuf);
1:3f32507: 
1:3f32507:                 currBytes += recordBuf.length;
1:3f32507:                 wOffset += aLen;
1:3f32507:                 numToWrite -= aLen;
1:3f32507:                 assemLen = 0;
1:3f32507:             } else {
1:3f32507:                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
1:3f32507:                                  numToWrite);
1:3f32507: 
1:3f32507:                 wOffset += numToWrite;
1:3f32507:                 assemLen += numToWrite;
1:3f32507:                 numToWrite = 0;
1:3f32507:             }
1:3f32507:         }
1:3f32507: 
1:3f32507:         //
1:3f32507:         // When we get here we have EITHER:
1:3f32507:         // o An empty "assemble" buffer.
1:3f32507:         // o No bytes to write (numToWrite == 0)
1:3f32507:         //
1:3f32507:         while (numToWrite > 0) {
1:3f32507:             if (numToWrite < recordBuf.length) {
1:3f32507:                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
1:3f32507:                                  numToWrite);
1:3f32507: 
1:3f32507:                 assemLen += numToWrite;
1:3f32507: 
1:3f32507:                 break;
1:3f32507:             }
1:3f32507: 
1:3f32507:             buffer.writeRecord(wBuf, wOffset);
1:3f32507: 
1:3f32507:             int num = recordBuf.length;
1:3f32507: 
1:3f32507:             currBytes += num;
1:3f32507:             numToWrite -= num;
1:3f32507:             wOffset += num;
1:3f32507:         }
1:3f32507:     }
1:3f32507: 
1:3f32507:     /**
1:3f32507:      * Write an EOF (end of archive) record to the tar archive.
1:3f32507:      * An EOF record consists of a record of all zeros.
1:3f32507:      */
1:3f32507:     private void writeEOFRecord() throws IOException {
1:3f32507:         for (int i = 0; i < recordBuf.length; ++i) {
1:3f32507:             recordBuf[i] = 0;
1:3f32507:         }
1:3f32507: 
1:3f32507:         buffer.writeRecord(recordBuf);
1:3f32507:     }
1:3f32507: }
1:3f32507: 
1:3f32507: 
============================================================================
author:Hadrian Zbarcea
-------------------------------------------------------------------------------
commit:3f32507
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *  Licensed to the Apache Software Foundation (ASF) under one or more
1:  *  contributor license agreements.  See the NOTICE file distributed with
1:  *  this work for additional information regarding copyright ownership.
1:  *  The ASF licenses this file to You under the Apache License, Version 2.0
1:  *  (the "License"); you may not use this file except in compliance with
1:  *  the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  *  Unless required by applicable law or agreed to in writing, software
1:  *  distributed under the License is distributed on an "AS IS" BASIS,
1:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  *  See the License for the specific language governing permissions and
1:  *  limitations under the License.
1:  *
1:  */
1: 
1: /*
1:  * This package is based on the work done by Timothy Gerard Endres
1:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
1:  */
1: 
1: package org.apache.activemq.console.command.store.tar;
1: 
1: import java.io.FilterOutputStream;
1: import java.io.OutputStream;
1: import java.io.IOException;
1: 
1: /**
1:  * The TarOutputStream writes a UNIX tar archive as an OutputStream.
1:  * Methods are provided to put entries, and then write their contents
1:  * by writing to this stream using write().
1:  *
1:  */
1: public class TarOutputStream extends FilterOutputStream {
1:     /** Fail if a long file name is required in the archive. */
1:     public static final int LONGFILE_ERROR = 0;
1: 
1:     /** Long paths will be truncated in the archive. */
1:     public static final int LONGFILE_TRUNCATE = 1;
1: 
1:     /** GNU tar extensions are used to store long file names in the archive. */
1:     public static final int LONGFILE_GNU = 2;
1: 
1:     // CheckStyle:VisibilityModifier OFF - bc
1:     protected boolean   debug;
1:     protected long      currSize;
1:     protected String    currName;
1:     protected long      currBytes;
1:     protected byte[]    oneBuf;
1:     protected byte[]    recordBuf;
1:     protected int       assemLen;
1:     protected byte[]    assemBuf;
1:     protected TarBuffer buffer;
1:     protected int       longFileMode = LONGFILE_ERROR;
1:     // CheckStyle:VisibilityModifier ON
1: 
1:     private boolean closed = false;
1: 
1:     /**
1:      * Constructor for TarInputStream.
1:      * @param os the output stream to use
1:      */
1:     public TarOutputStream(OutputStream os) {
1:         this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
1:     }
1: 
1:     /**
1:      * Constructor for TarInputStream.
1:      * @param os the output stream to use
1:      * @param blockSize the block size to use
1:      */
1:     public TarOutputStream(OutputStream os, int blockSize) {
1:         this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);
1:     }
1: 
1:     /**
1:      * Constructor for TarInputStream.
1:      * @param os the output stream to use
1:      * @param blockSize the block size to use
1:      * @param recordSize the record size to use
1:      */
1:     public TarOutputStream(OutputStream os, int blockSize, int recordSize) {
1:         super(os);
1: 
1:         this.buffer = new TarBuffer(os, blockSize, recordSize);
1:         this.debug = false;
1:         this.assemLen = 0;
1:         this.assemBuf = new byte[recordSize];
1:         this.recordBuf = new byte[recordSize];
1:         this.oneBuf = new byte[1];
1:     }
1: 
1:     /**
1:      * Set the long file mode.
1:      * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).
1:      * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).
1:      * Default is LONGFILE_ERROR.
1:      * @param longFileMode the mode to use
1:      */
1:     public void setLongFileMode(int longFileMode) {
1:         this.longFileMode = longFileMode;
1:     }
1: 
1: 
1:     /**
1:      * Sets the debugging flag.
1:      *
1:      * @param debugF True to turn on debugging.
1:      */
1:     public void setDebug(boolean debugF) {
1:         this.debug = debugF;
1:     }
1: 
1:     /**
1:      * Sets the debugging flag in this stream's TarBuffer.
1:      *
1:      * @param debug True to turn on debugging.
1:      */
1:     public void setBufferDebug(boolean debug) {
1:         buffer.setDebug(debug);
1:     }
1: 
1:     /**
1:      * Ends the TAR archive without closing the underlying OutputStream.
1:      * The result is that the two EOF records of nulls are written.
1:      * @throws IOException on error
1:      */
1:     public void finish() throws IOException {
1:         // See Bugzilla 28776 for a discussion on this
1:         // http://issues.apache.org/bugzilla/show_bug.cgi?id=28776
1:         writeEOFRecord();
1:         writeEOFRecord();
1:         buffer.flushBlock();
1:     }
1: 
1:     /**
1:      * Ends the TAR archive and closes the underlying OutputStream.
1:      * This means that finish() is called followed by calling the
1:      * TarBuffer's close().
1:      * @throws IOException on error
1:      */
1:     public void close() throws IOException {
1:         if (!closed) {
1:             finish();
1:             buffer.close();
1:             out.close();
1:             closed = true;
1:         }
1:     }
1: 
1:     /**
1:      * Get the record size being used by this stream's TarBuffer.
1:      *
1:      * @return The TarBuffer record size.
1:      */
1:     public int getRecordSize() {
1:         return buffer.getRecordSize();
1:     }
1: 
1:     /**
1:      * Put an entry on the output stream. This writes the entry's
1:      * header record and positions the output stream for writing
1:      * the contents of the entry. Once this method is called, the
1:      * stream is ready for calls to write() to write the entry's
1:      * contents. Once the contents are written, closeEntry()
1:      * <B>MUST</B> be called to ensure that all buffered data
1:      * is completely written to the output stream.
1:      *
1:      * @param entry The TarEntry to be written to the archive.
1:      * @throws IOException on error
1:      */
1:     public void putNextEntry(TarEntry entry) throws IOException {
1:         if (entry.getName().length() >= TarConstants.NAMELEN) {
1: 
1:             if (longFileMode == LONGFILE_GNU) {
1:                 // create a TarEntry for the LongLink, the contents
1:                 // of which are the entry's name
1:                 TarEntry longLinkEntry = new TarEntry(TarConstants.GNU_LONGLINK,
1:                                                       TarConstants.LF_GNUTYPE_LONGNAME);
1: 
1:                 longLinkEntry.setSize(entry.getName().length() + 1);
1:                 putNextEntry(longLinkEntry);
1:                 write(entry.getName().getBytes());
1:                 write(0);
1:                 closeEntry();
1:             } else if (longFileMode != LONGFILE_TRUNCATE) {
1:                 throw new RuntimeException("file name '" + entry.getName()
1:                                              + "' is too long ( > "
1:                                              + TarConstants.NAMELEN + " bytes)");
1:             }
1:         }
1: 
1:         entry.writeEntryHeader(recordBuf);
1:         buffer.writeRecord(recordBuf);
1: 
1:         currBytes = 0;
1: 
1:         if (entry.isDirectory()) {
1:             currSize = 0;
1:         } else {
1:             currSize = entry.getSize();
1:         }
1:         currName = entry.getName();
1:     }
1: 
1:     /**
1:      * Close an entry. This method MUST be called for all file
1:      * entries that contain data. The reason is that we must
1:      * buffer data written to the stream in order to satisfy
1:      * the buffer's record based writes. Thus, there may be
1:      * data fragments still being assembled that must be written
1:      * to the output stream before this entry is closed and the
1:      * next entry written.
1:      * @throws IOException on error
1:      */
1:     public void closeEntry() throws IOException {
1:         if (assemLen > 0) {
1:             for (int i = assemLen; i < assemBuf.length; ++i) {
1:                 assemBuf[i] = 0;
1:             }
1: 
1:             buffer.writeRecord(assemBuf);
1: 
1:             currBytes += assemLen;
1:             assemLen = 0;
1:         }
1: 
1:         if (currBytes < currSize) {
1:             throw new IOException("entry '" + currName + "' closed at '"
1:                                   + currBytes
1:                                   + "' before the '" + currSize
1:                                   + "' bytes specified in the header were written");
1:         }
1:     }
1: 
1:     /**
1:      * Writes a byte to the current tar archive entry.
1:      *
1:      * This method simply calls read( byte[], int, int ).
1:      *
1:      * @param b The byte written.
1:      * @throws IOException on error
1:      */
1:     public void write(int b) throws IOException {
1:         oneBuf[0] = (byte) b;
1: 
1:         write(oneBuf, 0, 1);
1:     }
1: 
1:     /**
1:      * Writes bytes to the current tar archive entry.
1:      *
1:      * This method simply calls write( byte[], int, int ).
1:      *
1:      * @param wBuf The buffer to write to the archive.
1:      * @throws IOException on error
1:      */
1:     public void write(byte[] wBuf) throws IOException {
1:         write(wBuf, 0, wBuf.length);
1:     }
1: 
1:     /**
1:      * Writes bytes to the current tar archive entry. This method
1:      * is aware of the current entry and will throw an exception if
1:      * you attempt to write bytes past the length specified for the
1:      * current entry. The method is also (painfully) aware of the
1:      * record buffering required by TarBuffer, and manages buffers
1:      * that are not a multiple of recordsize in length, including
1:      * assembling records from small buffers.
1:      *
1:      * @param wBuf The buffer to write to the archive.
1:      * @param wOffset The offset in the buffer from which to get bytes.
1:      * @param numToWrite The number of bytes to write.
1:      * @throws IOException on error
1:      */
1:     public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
1:         if ((currBytes + numToWrite) > currSize) {
1:             throw new IOException("request to write '" + numToWrite
1:                                   + "' bytes exceeds size in header of '"
1:                                   + currSize + "' bytes for entry '"
1:                                   + currName + "'");
1: 
1:             //
1:             // We have to deal with assembly!!!
1:             // The programmer can be writing little 32 byte chunks for all
1:             // we know, and we must assemble complete records for writing.
1:             // REVIEW Maybe this should be in TarBuffer? Could that help to
1:             // eliminate some of the buffer copying.
1:             //
1:         }
1: 
1:         if (assemLen > 0) {
1:             if ((assemLen + numToWrite) >= recordBuf.length) {
1:                 int aLen = recordBuf.length - assemLen;
1: 
1:                 System.arraycopy(assemBuf, 0, recordBuf, 0,
1:                                  assemLen);
1:                 System.arraycopy(wBuf, wOffset, recordBuf,
1:                                  assemLen, aLen);
1:                 buffer.writeRecord(recordBuf);
1: 
1:                 currBytes += recordBuf.length;
1:                 wOffset += aLen;
1:                 numToWrite -= aLen;
1:                 assemLen = 0;
1:             } else {
1:                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
1:                                  numToWrite);
1: 
1:                 wOffset += numToWrite;
1:                 assemLen += numToWrite;
1:                 numToWrite = 0;
1:             }
1:         }
1: 
1:         //
1:         // When we get here we have EITHER:
1:         // o An empty "assemble" buffer.
1:         // o No bytes to write (numToWrite == 0)
1:         //
1:         while (numToWrite > 0) {
1:             if (numToWrite < recordBuf.length) {
1:                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
1:                                  numToWrite);
1: 
1:                 assemLen += numToWrite;
1: 
1:                 break;
1:             }
1: 
1:             buffer.writeRecord(wBuf, wOffset);
1: 
1:             int num = recordBuf.length;
1: 
1:             currBytes += num;
1:             numToWrite -= num;
1:             wOffset += num;
1:         }
1:     }
1: 
1:     /**
1:      * Write an EOF (end of archive) record to the tar archive.
1:      * An EOF record consists of a record of all zeros.
1:      */
1:     private void writeEOFRecord() throws IOException {
1:         for (int i = 0; i < recordBuf.length; ++i) {
1:             recordBuf[i] = 0;
1:         }
1: 
1:         buffer.writeRecord(recordBuf);
1:     }
1: }
1: 
1: 
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:cfe5e98
/////////////////////////////////////////////////////////////////////////
0: /*
0:  *  Licensed to the Apache Software Foundation (ASF) under one or more
0:  *  contributor license agreements.  See the NOTICE file distributed with
0:  *  this work for additional information regarding copyright ownership.
0:  *  The ASF licenses this file to You under the Apache License, Version 2.0
0:  *  (the "License"); you may not use this file except in compliance with
0:  *  the License.  You may obtain a copy of the License at
0:  *
0:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  *  Unless required by applicable law or agreed to in writing, software
0:  *  distributed under the License is distributed on an "AS IS" BASIS,
0:  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  *  See the License for the specific language governing permissions and
0:  *  limitations under the License.
0:  *
0:  */
0: 
0: /*
0:  * This package is based on the work done by Timothy Gerard Endres
0:  * (time@ice.com) to whom the Ant project is very grateful for his great code.
0:  */
0: 
0: package org.apache.activemq.console.command.store.tar;
0: 
0: import java.io.FilterOutputStream;
0: import java.io.OutputStream;
0: import java.io.IOException;
0: 
0: /**
0:  * The TarOutputStream writes a UNIX tar archive as an OutputStream.
0:  * Methods are provided to put entries, and then write their contents
0:  * by writing to this stream using write().
0:  *
0:  */
0: public class TarOutputStream extends FilterOutputStream {
0:     /** Fail if a long file name is required in the archive. */
0:     public static final int LONGFILE_ERROR = 0;
0: 
0:     /** Long paths will be truncated in the archive. */
0:     public static final int LONGFILE_TRUNCATE = 1;
0: 
0:     /** GNU tar extensions are used to store long file names in the archive. */
0:     public static final int LONGFILE_GNU = 2;
0: 
0:     // CheckStyle:VisibilityModifier OFF - bc
0:     protected boolean   debug;
0:     protected long      currSize;
0:     protected String    currName;
0:     protected long      currBytes;
0:     protected byte[]    oneBuf;
0:     protected byte[]    recordBuf;
0:     protected int       assemLen;
0:     protected byte[]    assemBuf;
0:     protected TarBuffer buffer;
0:     protected int       longFileMode = LONGFILE_ERROR;
0:     // CheckStyle:VisibilityModifier ON
0: 
0:     private boolean closed = false;
0: 
0:     /**
0:      * Constructor for TarInputStream.
0:      * @param os the output stream to use
0:      */
0:     public TarOutputStream(OutputStream os) {
0:         this(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);
0:     }
0: 
0:     /**
0:      * Constructor for TarInputStream.
0:      * @param os the output stream to use
0:      * @param blockSize the block size to use
0:      */
0:     public TarOutputStream(OutputStream os, int blockSize) {
0:         this(os, blockSize, TarBuffer.DEFAULT_RCDSIZE);
0:     }
0: 
0:     /**
0:      * Constructor for TarInputStream.
0:      * @param os the output stream to use
0:      * @param blockSize the block size to use
0:      * @param recordSize the record size to use
0:      */
0:     public TarOutputStream(OutputStream os, int blockSize, int recordSize) {
0:         super(os);
0: 
0:         this.buffer = new TarBuffer(os, blockSize, recordSize);
0:         this.debug = false;
0:         this.assemLen = 0;
0:         this.assemBuf = new byte[recordSize];
0:         this.recordBuf = new byte[recordSize];
0:         this.oneBuf = new byte[1];
0:     }
0: 
0:     /**
0:      * Set the long file mode.
0:      * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).
0:      * This specifies the treatment of long file names (names >= TarConstants.NAMELEN).
0:      * Default is LONGFILE_ERROR.
0:      * @param longFileMode the mode to use
0:      */
0:     public void setLongFileMode(int longFileMode) {
0:         this.longFileMode = longFileMode;
0:     }
0: 
0: 
0:     /**
0:      * Sets the debugging flag.
0:      *
0:      * @param debugF True to turn on debugging.
0:      */
0:     public void setDebug(boolean debugF) {
0:         this.debug = debugF;
0:     }
0: 
0:     /**
0:      * Sets the debugging flag in this stream's TarBuffer.
0:      *
0:      * @param debug True to turn on debugging.
0:      */
0:     public void setBufferDebug(boolean debug) {
0:         buffer.setDebug(debug);
0:     }
0: 
0:     /**
0:      * Ends the TAR archive without closing the underlying OutputStream.
0:      * The result is that the two EOF records of nulls are written.
0:      * @throws IOException on error
0:      */
0:     public void finish() throws IOException {
0:         // See Bugzilla 28776 for a discussion on this
0:         // http://issues.apache.org/bugzilla/show_bug.cgi?id=28776
0:         writeEOFRecord();
0:         writeEOFRecord();
0:         buffer.flushBlock();
0:     }
0: 
0:     /**
0:      * Ends the TAR archive and closes the underlying OutputStream.
0:      * This means that finish() is called followed by calling the
0:      * TarBuffer's close().
0:      * @throws IOException on error
0:      */
0:     public void close() throws IOException {
0:         if (!closed) {
0:             finish();
0:             buffer.close();
0:             out.close();
0:             closed = true;
0:         }
0:     }
0: 
0:     /**
0:      * Get the record size being used by this stream's TarBuffer.
0:      *
0:      * @return The TarBuffer record size.
0:      */
0:     public int getRecordSize() {
0:         return buffer.getRecordSize();
0:     }
0: 
0:     /**
0:      * Put an entry on the output stream. This writes the entry's
0:      * header record and positions the output stream for writing
0:      * the contents of the entry. Once this method is called, the
0:      * stream is ready for calls to write() to write the entry's
0:      * contents. Once the contents are written, closeEntry()
0:      * <B>MUST</B> be called to ensure that all buffered data
0:      * is completely written to the output stream.
0:      *
0:      * @param entry The TarEntry to be written to the archive.
0:      * @throws IOException on error
0:      */
0:     public void putNextEntry(TarEntry entry) throws IOException {
0:         if (entry.getName().length() >= TarConstants.NAMELEN) {
0: 
0:             if (longFileMode == LONGFILE_GNU) {
0:                 // create a TarEntry for the LongLink, the contents
0:                 // of which are the entry's name
0:                 TarEntry longLinkEntry = new TarEntry(TarConstants.GNU_LONGLINK,
0:                                                       TarConstants.LF_GNUTYPE_LONGNAME);
0: 
0:                 longLinkEntry.setSize(entry.getName().length() + 1);
0:                 putNextEntry(longLinkEntry);
0:                 write(entry.getName().getBytes());
0:                 write(0);
0:                 closeEntry();
0:             } else if (longFileMode != LONGFILE_TRUNCATE) {
0:                 throw new RuntimeException("file name '" + entry.getName()
0:                                              + "' is too long ( > "
0:                                              + TarConstants.NAMELEN + " bytes)");
0:             }
0:         }
0: 
0:         entry.writeEntryHeader(recordBuf);
0:         buffer.writeRecord(recordBuf);
0: 
0:         currBytes = 0;
0: 
0:         if (entry.isDirectory()) {
0:             currSize = 0;
0:         } else {
0:             currSize = entry.getSize();
0:         }
0:         currName = entry.getName();
0:     }
0: 
0:     /**
0:      * Close an entry. This method MUST be called for all file
0:      * entries that contain data. The reason is that we must
0:      * buffer data written to the stream in order to satisfy
0:      * the buffer's record based writes. Thus, there may be
0:      * data fragments still being assembled that must be written
0:      * to the output stream before this entry is closed and the
0:      * next entry written.
0:      * @throws IOException on error
0:      */
0:     public void closeEntry() throws IOException {
0:         if (assemLen > 0) {
0:             for (int i = assemLen; i < assemBuf.length; ++i) {
0:                 assemBuf[i] = 0;
0:             }
0: 
0:             buffer.writeRecord(assemBuf);
0: 
0:             currBytes += assemLen;
0:             assemLen = 0;
0:         }
0: 
0:         if (currBytes < currSize) {
0:             throw new IOException("entry '" + currName + "' closed at '"
0:                                   + currBytes
0:                                   + "' before the '" + currSize
0:                                   + "' bytes specified in the header were written");
0:         }
0:     }
0: 
0:     /**
0:      * Writes a byte to the current tar archive entry.
0:      *
0:      * This method simply calls read( byte[], int, int ).
0:      *
0:      * @param b The byte written.
0:      * @throws IOException on error
0:      */
0:     public void write(int b) throws IOException {
0:         oneBuf[0] = (byte) b;
0: 
0:         write(oneBuf, 0, 1);
0:     }
0: 
0:     /**
0:      * Writes bytes to the current tar archive entry.
0:      *
0:      * This method simply calls write( byte[], int, int ).
0:      *
0:      * @param wBuf The buffer to write to the archive.
0:      * @throws IOException on error
0:      */
0:     public void write(byte[] wBuf) throws IOException {
0:         write(wBuf, 0, wBuf.length);
0:     }
0: 
0:     /**
0:      * Writes bytes to the current tar archive entry. This method
0:      * is aware of the current entry and will throw an exception if
0:      * you attempt to write bytes past the length specified for the
0:      * current entry. The method is also (painfully) aware of the
0:      * record buffering required by TarBuffer, and manages buffers
0:      * that are not a multiple of recordsize in length, including
0:      * assembling records from small buffers.
0:      *
0:      * @param wBuf The buffer to write to the archive.
0:      * @param wOffset The offset in the buffer from which to get bytes.
0:      * @param numToWrite The number of bytes to write.
0:      * @throws IOException on error
0:      */
0:     public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
0:         if ((currBytes + numToWrite) > currSize) {
0:             throw new IOException("request to write '" + numToWrite
0:                                   + "' bytes exceeds size in header of '"
0:                                   + currSize + "' bytes for entry '"
0:                                   + currName + "'");
0: 
0:             //
0:             // We have to deal with assembly!!!
0:             // The programmer can be writing little 32 byte chunks for all
0:             // we know, and we must assemble complete records for writing.
0:             // REVIEW Maybe this should be in TarBuffer? Could that help to
0:             // eliminate some of the buffer copying.
0:             //
0:         }
0: 
0:         if (assemLen > 0) {
0:             if ((assemLen + numToWrite) >= recordBuf.length) {
0:                 int aLen = recordBuf.length - assemLen;
0: 
0:                 System.arraycopy(assemBuf, 0, recordBuf, 0,
0:                                  assemLen);
0:                 System.arraycopy(wBuf, wOffset, recordBuf,
0:                                  assemLen, aLen);
0:                 buffer.writeRecord(recordBuf);
0: 
0:                 currBytes += recordBuf.length;
0:                 wOffset += aLen;
0:                 numToWrite -= aLen;
0:                 assemLen = 0;
0:             } else {
0:                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
0:                                  numToWrite);
0: 
0:                 wOffset += numToWrite;
0:                 assemLen += numToWrite;
0:                 numToWrite = 0;
0:             }
0:         }
0: 
0:         //
0:         // When we get here we have EITHER:
0:         // o An empty "assemble" buffer.
0:         // o No bytes to write (numToWrite == 0)
0:         //
0:         while (numToWrite > 0) {
0:             if (numToWrite < recordBuf.length) {
0:                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
0:                                  numToWrite);
0: 
0:                 assemLen += numToWrite;
0: 
0:                 break;
0:             }
0: 
0:             buffer.writeRecord(wBuf, wOffset);
0: 
0:             int num = recordBuf.length;
0: 
0:             currBytes += num;
0:             numToWrite -= num;
0:             wOffset += num;
0:         }
0:     }
0: 
0:     /**
0:      * Write an EOF (end of archive) record to the tar archive.
0:      * An EOF record consists of a record of all zeros.
0:      */
0:     private void writeEOFRecord() throws IOException {
0:         for (int i = 0; i < recordBuf.length; ++i) {
0:             recordBuf[i] = 0;
0:         }
0: 
0:         buffer.writeRecord(recordBuf);
0:     }
0: }
0: 
0: 
============================================================================