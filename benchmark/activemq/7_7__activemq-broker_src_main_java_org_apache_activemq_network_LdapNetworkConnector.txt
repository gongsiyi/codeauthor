20:a80acbb: /**
1:67e5952:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:67e5952:  * contributor license agreements.  See the NOTICE file distributed with
1:67e5952:  * this work for additional information regarding copyright ownership.
1:67e5952:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:67e5952:  * (the "License"); you may not use this file except in compliance with
1:67e5952:  * the License.  You may obtain a copy of the License at
12:a80acbb:  *
1:67e5952:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a80acbb:  *
1:67e5952:  * Unless required by applicable law or agreed to in writing, software
1:67e5952:  * distributed under the License is distributed on an "AS IS" BASIS,
1:67e5952:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:67e5952:  * See the License for the specific language governing permissions and
1:67e5952:  * limitations under the License.
19:a80acbb:  */
1:67e5952: package org.apache.activemq.network;
1:520a2de: 
1:67e5952: import java.net.URI;
1:67e5952: import java.util.Hashtable;
1:dead574: import java.util.Map;
1:dead574: import java.util.concurrent.ConcurrentHashMap;
2:67e5952: 
1:dead574: import javax.naming.CommunicationException;
1:67e5952: import javax.naming.Context;
1:67e5952: import javax.naming.NamingEnumeration;
1:67e5952: import javax.naming.directory.Attributes;
1:67e5952: import javax.naming.directory.DirContext;
1:67e5952: import javax.naming.directory.InitialDirContext;
1:67e5952: import javax.naming.directory.SearchControls;
1:67e5952: import javax.naming.directory.SearchResult;
1:dead574: import javax.naming.event.EventDirContext;
1:dead574: import javax.naming.event.NamespaceChangeListener;
1:dead574: import javax.naming.event.NamingEvent;
1:dead574: import javax.naming.event.NamingExceptionEvent;
1:dead574: import javax.naming.event.ObjectChangeListener;
1:67e5952: 
1:dead574: import org.apache.activemq.util.URISupport;
1:dead574: import org.apache.activemq.util.URISupport.CompositeData;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:67e5952: 
1:dead574: /**
1:a80acbb:  * class to create dynamic network connectors listed in an directory server
1:a80acbb:  * using the LDAP v3 protocol as defined in RFC 2251, the entries listed in the
1:a80acbb:  * directory server must implement the ipHost and ipService objectClasses as
1:a80acbb:  * defined in RFC 2307.
1:dead574:  *
1:67e5952:  * @see <a href="http://www.faqs.org/rfcs/rfc2251.html">RFC 2251</a>
1:67e5952:  * @see <a href="http://www.faqs.org/rfcs/rfc2307.html">RFC 2307</a>
1:a80acbb:  *
1:67e5952:  * @org.apache.xbean.XBean element="ldapNetworkConnector"
1:dead574:  */
1:a80acbb: public class LdapNetworkConnector extends NetworkConnector implements NamespaceChangeListener, ObjectChangeListener {
1:a80acbb:     private static final Logger LOG = LoggerFactory.getLogger(LdapNetworkConnector.class);
1:67e5952: 
1:dead574:     // force returned entries to implement the ipHost and ipService object classes (RFC 2307)
1:a80acbb:     private static final String REQUIRED_OBJECT_CLASS_FILTER =
1:a80acbb:             "(&(objectClass=ipHost)(objectClass=ipService))";
1:67e5952: 
1:dead574:     // connection
1:a80acbb:     private URI[] availableURIs = null;
1:a80acbb:     private int availableURIsIndex = 0;
1:a80acbb:     private String base = null;
1:a80acbb:     private boolean failover = false;
1:a80acbb:     private long curReconnectDelay = 1000; /* 1 sec */
1:a80acbb:     private long maxReconnectDelay = 30000; /* 30 sec */
1:67e5952: 
1:dead574:     // authentication
1:a80acbb:     private String user = null;
1:a80acbb:     private String password = null;
1:dead574:     private boolean anonymousAuthentication = false;
1:67e5952: 
1:dead574:     // search
1:a80acbb:     private SearchControls searchControls = new SearchControls(/* ONELEVEL_SCOPE */);
1:a80acbb:     private String searchFilter = REQUIRED_OBJECT_CLASS_FILTER;
1:a80acbb:     private boolean searchEventListener = false;
1:67e5952: 
1:dead574:     // connector management
1:a80acbb:     private Map<URI, NetworkConnector> connectorMap = new ConcurrentHashMap<URI, NetworkConnector>();
1:a80acbb:     private Map<URI, Integer> referenceMap = new ConcurrentHashMap<URI, Integer>();
1:a80acbb:     private Map<String, URI> uuidMap = new ConcurrentHashMap<String, URI>();
1:67e5952: 
1:dead574:     // local context
1:dead574:     private DirContext context = null;
1:a80acbb:     // currently in use URI
1:a80acbb:     private URI ldapURI = null;
1:67e5952: 
1:dead574:     /**
1:dead574:      * returns the next URI from the configured list
1:dead574:      *
1:dead574:      * @return random URI from the configured list
1:dead574:      */
1:a80acbb:     public URI getUri() {
1:a80acbb:         return availableURIs[++availableURIsIndex % availableURIs.length];
25:a80acbb:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * sets the LDAP server URI
1:dead574:      *
1:5e05df1:      * @param uri
1:a80acbb:      *            LDAP server URI
1:dead574:      */
1:a80acbb:     public void setUri(URI uri) throws Exception {
1:a80acbb:         CompositeData data = URISupport.parseComposite(uri);
1:a80acbb:         if (data.getScheme().equals("failover")) {
1:dead574:             availableURIs = data.getComponents();
1:dead574:             failover = true;
1:a80acbb:         } else {
1:a80acbb:             availableURIs = new URI[] { uri };
1:dead574:         }
1:dead574:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * sets the base LDAP dn used for lookup operations
1:dead574:      *
1:5e05df1:      * @param base
1:a80acbb:      *            LDAP base dn
1:dead574:      */
1:a80acbb:     public void setBase(String base) {
1:a80acbb:         this.base = base;
1:a80acbb:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * sets the LDAP user for access credentials
1:dead574:      *
1:5e05df1:      * @param user
1:a80acbb:      *            LDAP dn of user
1:dead574:      */
1:a80acbb:     public void setUser(String user) {
1:a80acbb:         this.user = user;
1:a80acbb:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * sets the LDAP password for access credentials
1:dead574:      *
1:5e05df1:      * @param password
1:a80acbb:      *            user password
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void setPassword(String password) {
1:a80acbb:         this.password = password;
1:a80acbb:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * sets LDAP anonymous authentication access credentials
1:dead574:      *
1:5e05df1:      * @param anonymousAuthentication
1:a80acbb:      *            set to true to use anonymous authentication
1:dead574:      */
1:a80acbb:     public void setAnonymousAuthentication(boolean anonymousAuthentication) {
1:a80acbb:         this.anonymousAuthentication = anonymousAuthentication;
1:a80acbb:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * sets the LDAP search scope
1:dead574:      *
1:5e05df1:      * @param searchScope
1:a80acbb:      *            LDAP JNDI search scope
1:dead574:      */
1:a80acbb:     public void setSearchScope(String searchScope) throws Exception {
1:dead574:         int scope;
1:a80acbb:         if (searchScope.equals("OBJECT_SCOPE")) {
1:a80acbb:             scope = SearchControls.OBJECT_SCOPE;
1:a80acbb:         } else if (searchScope.equals("ONELEVEL_SCOPE")) {
1:a80acbb:             scope = SearchControls.ONELEVEL_SCOPE;
1:a80acbb:         } else if (searchScope.equals("SUBTREE_SCOPE")) {
1:a80acbb:             scope = SearchControls.SUBTREE_SCOPE;
1:a80acbb:         } else {
1:a80acbb:             throw new Exception("ERR: unknown LDAP search scope specified: " + searchScope);
1:a80acbb:         }
1:dead574:         searchControls.setSearchScope(scope);
1:dead574:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * sets the LDAP search filter as defined in RFC 2254
1:dead574:      *
1:5e05df1:      * @param searchFilter
1:a80acbb:      *            LDAP search filter
1:dead574:      * @see <a href="http://www.faqs.org/rfcs/rfc2254.html">RFC 2254</a>
1:dead574:      */
1:a80acbb:     public void setSearchFilter(String searchFilter) {
1:a80acbb:         this.searchFilter = "(&" + REQUIRED_OBJECT_CLASS_FILTER + "(" + searchFilter + "))";
1:dead574:     }
1:67e5952: 
1:dead574:     /**
1:a80acbb:      * enables/disable a persistent search to the LDAP server as defined in
1:a80acbb:      * draft-ietf-ldapext-psearch-03.txt (2.16.840.1.113730.3.4.3)
1:dead574:      *
1:5e05df1:      * @param searchEventListener
1:a80acbb:      *            enable = true, disable = false (default)
1:a80acbb:      * @see <a
1:a80acbb:      *      href="http://www.ietf.org/proceedings/01mar/I-D/draft-ietf-ldapext-psearch-03.txt">draft-ietf-ldapext-psearch-03.txt</a>
1:dead574:      */
1:a80acbb:     public void setSearchEventListener(boolean searchEventListener) {
1:a80acbb:         this.searchEventListener = searchEventListener;
1:a80acbb:     }
1:67e5952: 
1:dead574:     /**
1:dead574:      * start the connector
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void start() throws Exception {
1:dead574:         LOG.info("connecting...");
1:a80acbb:         Hashtable<String, String> env = new Hashtable<String, String>();
1:dead574:         env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
1:a80acbb:         this.ldapURI = getUri();
1:e1bbde7:         LOG.debug("    URI [{}]", this.ldapURI);
1:a80acbb:         env.put(Context.PROVIDER_URL, this.ldapURI.toString());
1:a80acbb:         if (anonymousAuthentication) {
1:dead574:             LOG.debug("    login credentials [anonymous]");
1:dead574:             env.put(Context.SECURITY_AUTHENTICATION, "none");
1:a80acbb:         } else {
1:e1bbde7:             LOG.debug("    login credentials [{}:******]", user);
1:0b5231a:             if (user != null && !"".equals(user)) {
1:0b5231a:                 env.put(Context.SECURITY_PRINCIPAL, user);
1:0b5231a:             } else {
1:0b5231a:                 throw new Exception("Empty username is not allowed");
1:0b5231a:             }
1:0b5231a:             if (password != null && !"".equals(password)) {
1:0b5231a:                 env.put(Context.SECURITY_CREDENTIALS, password);
1:0b5231a:             } else {
1:0b5231a:                 throw new Exception("Empty password is not allowed");
1:0b5231a:             }
1:dead574:         }
1:dead574:         boolean isConnected = false;
1:a80acbb:         while (!isConnected) {
1:a80acbb:             try {
1:dead574:                 context = new InitialDirContext(env);
1:dead574:                 isConnected = true;
1:a80acbb:             } catch (CommunicationException err) {
1:a80acbb:                 if (failover) {
1:a80acbb:                     this.ldapURI = getUri();
1:e1bbde7:                     LOG.error("connection error [{}], failover connection to [{}]", env.get(Context.PROVIDER_URL), this.ldapURI.toString());
1:a80acbb:                     env.put(Context.PROVIDER_URL, this.ldapURI.toString());
1:dead574:                     Thread.sleep(curReconnectDelay);
1:dead574:                     curReconnectDelay = Math.min(curReconnectDelay * 2, maxReconnectDelay);
1:a80acbb:                 } else {
1:a80acbb:                     throw err;
1:dead574:                 }
1:dead574:             }
1:dead574:         }
1:67e5952: 
1:dead574:         // add connectors from search results
1:dead574:         LOG.info("searching for network connectors...");
1:e1bbde7:         LOG.debug("    base   [{}]", base);
1:e1bbde7:         LOG.debug("    filter [{}]", searchFilter);
1:e1bbde7:         LOG.debug("    scope  [{}]", searchControls.getSearchScope());
1:dead574:         NamingEnumeration<SearchResult> results = context.search(base, searchFilter, searchControls);
1:a80acbb:         while (results.hasMore()) {
1:a80acbb:             addConnector(results.next());
1:dead574:         }
1:67e5952: 
1:dead574:         // register persistent search event listener
1:a80acbb:         if (searchEventListener) {
1:dead574:             LOG.info("registering persistent search listener...");
1:a80acbb:             EventDirContext eventContext = (EventDirContext) context.lookup("");
1:dead574:             eventContext.addNamingListener(base, searchFilter, searchControls, this);
1:a80acbb:         } else { // otherwise close context (i.e. connection as it is no longer needed)
2:a80acbb:             context.close();
1:dead574:         }
1:dead574:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * stop the connector
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void stop() throws Exception {
1:dead574:         LOG.info("stopping context...");
1:a80acbb:         for (NetworkConnector connector : connectorMap.values()) {
2:a80acbb:             connector.stop();
1:a80acbb:         }
1:dead574:         connectorMap.clear();
1:dead574:         referenceMap.clear();
1:dead574:         uuidMap.clear();
1:dead574:         context.close();
1:dead574:     }
1:dead574: 
1:5e05df1:     @Override
1:27d0ff4:     public String toString() {
1:a80acbb:         return this.getClass().getName() + getName() + "[" + ldapURI.toString() + "]";
1:27d0ff4:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * add connector of the given URI
1:dead574:      *
1:520a2de:      * @param result
1:520a2de:      *            search result of connector to add
1:dead574:      */
1:a80acbb:     protected synchronized void addConnector(SearchResult result) throws Exception {
1:dead574:         String uuid = toUUID(result);
1:a80acbb:         if (uuidMap.containsKey(uuid)) {
1:e1bbde7:             LOG.warn("connector already regsitered for UUID [{}]", uuid);
1:dead574:             return;
1:dead574:         }
1:dead574: 
1:dead574:         URI connectorURI = toURI(result);
1:a80acbb:         if (connectorMap.containsKey(connectorURI)) {
1:dead574:             int referenceCount = referenceMap.get(connectorURI) + 1;
1:e1bbde7:             LOG.warn("connector reference added for URI [{}], UUID [{}], total reference(s) [{}]", new Object[]{ connectorURI, uuid, referenceCount });
1:dead574:             referenceMap.put(connectorURI, referenceCount);
1:dead574:             uuidMap.put(uuid, connectorURI);
1:dead574:             return;
1:dead574:         }
1:dead574: 
1:dead574:         // FIXME: disable JMX listing of LDAP managed connectors, we will
1:a80acbb:         // want to map/manage these differently in the future
1:a80acbb:         // boolean useJMX = getBrokerService().isUseJmx();
1:a80acbb:         // getBrokerService().setUseJmx(false);
1:dead574:         NetworkConnector connector = getBrokerService().addNetworkConnector(connectorURI);
1:a80acbb:         // getBrokerService().setUseJmx(useJMX);
1:dead574: 
1:a80acbb:         // Propagate standard connector properties that may have been set via XML
1:dead574:         connector.setDynamicOnly(isDynamicOnly());
1:dead574:         connector.setDecreaseNetworkConsumerPriority(isDecreaseNetworkConsumerPriority());
1:dead574:         connector.setNetworkTTL(getNetworkTTL());
1:a95c6db:         connector.setConsumerTTL(getConsumerTTL());
1:a95c6db:         connector.setMessageTTL(getMessageTTL());
1:dead574:         connector.setConduitSubscriptions(isConduitSubscriptions());
1:dead574:         connector.setExcludedDestinations(getExcludedDestinations());
1:dead574:         connector.setDynamicallyIncludedDestinations(getDynamicallyIncludedDestinations());
1:dead574:         connector.setDuplex(isDuplex());
1:dead574: 
1:dead574:         // XXX: set in the BrokerService.startAllConnectors method and is
1:a80acbb:         // required to prevent remote broker exceptions upon connection
1:dead574:         connector.setLocalUri(getBrokerService().getVmConnectorURI());
1:dead574:         connector.setBrokerName(getBrokerService().getBrokerName());
1:dead574:         connector.setDurableDestinations(getBrokerService().getBroker().getDurableDestinations());
1:dead574: 
1:dead574:         // start network connector
1:dead574:         connectorMap.put(connectorURI, connector);
1:dead574:         referenceMap.put(connectorURI, 1);
1:dead574:         uuidMap.put(uuid, connectorURI);
1:dead574:         connector.start();
1:e1bbde7:         LOG.info("connector added with URI [{}]", connectorURI);
1:dead574:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * remove connector of the given URI
1:dead574:      *
1:a80acbb:      * @param result
1:a80acbb:      *            search result of connector to remove
1:dead574:      */
1:a80acbb:     protected synchronized void removeConnector(SearchResult result) throws Exception {
1:dead574:         String uuid = toUUID(result);
1:a80acbb:         if (!uuidMap.containsKey(uuid)) {
1:e1bbde7:             LOG.warn("connector not registered for UUID [{}]", uuid);
1:dead574:             return;
1:dead574:         }
1:dead574: 
1:dead574:         URI connectorURI = uuidMap.get(uuid);
1:a80acbb:         if (!connectorMap.containsKey(connectorURI)) {
1:e1bbde7:             LOG.warn("connector not registered for URI [{}]", connectorURI);
1:dead574:             return;
1:dead574:         }
1:dead574: 
1:dead574:         int referenceCount = referenceMap.get(connectorURI) - 1;
1:dead574:         referenceMap.put(connectorURI, referenceCount);
1:dead574:         uuidMap.remove(uuid);
1:e1bbde7:         LOG.debug("connector referenced removed for URI [{}], UUID[{}], remaining reference(s) [{}]", new Object[]{ connectorURI, uuid, referenceCount });
1:dead574: 
1:a80acbb:         if (referenceCount > 0) {
5:a80acbb:             return;
1:a80acbb:         }
1:dead574: 
1:dead574:         NetworkConnector connector = connectorMap.remove(connectorURI);
1:dead574:         connector.stop();
1:e1bbde7:         LOG.info("connector removed with URI [{}]", connectorURI);
1:dead574:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * convert search result into URI
1:dead574:      *
1:a80acbb:      * @param result
1:a80acbb:      *            search result to convert to URI
1:dead574:      */
1:a80acbb:     protected URI toURI(SearchResult result) throws Exception {
1:dead574:         Attributes attributes = result.getAttributes();
1:a80acbb:         String address = (String) attributes.get("iphostnumber").get();
1:a80acbb:         String port = (String) attributes.get("ipserviceport").get();
1:a80acbb:         String protocol = (String) attributes.get("ipserviceprotocol").get();
1:dead574:         URI connectorURI = new URI("static:(" + protocol + "://" + address + ":" + port + ")");
1:e1bbde7:         LOG.debug("retrieved URI from SearchResult [{}]", connectorURI);
1:dead574:         return connectorURI;
1:dead574:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * convert search result into URI
1:dead574:      *
1:a80acbb:      * @param result
1:a80acbb:      *            search result to convert to URI
1:dead574:      */
1:a80acbb:     protected String toUUID(SearchResult result) {
1:dead574:         String uuid = result.getNameInNamespace();
1:e1bbde7:         LOG.debug("retrieved UUID from SearchResult [{}]", uuid);
1:dead574:         return uuid;
1:dead574:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * invoked when an entry has been added during a persistent search
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void objectAdded(NamingEvent event) {
1:dead574:         LOG.debug("entry added");
1:a80acbb:         try {
1:a80acbb:             addConnector((SearchResult) event.getNewBinding());
1:a80acbb:         } catch (Exception err) {
1:a80acbb:             LOG.error("ERR: caught unexpected exception", err);
1:dead574:         }
1:a80acbb:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * invoked when an entry has been removed during a persistent search
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void objectRemoved(NamingEvent event) {
1:dead574:         LOG.debug("entry removed");
1:a80acbb:         try {
1:a80acbb:             removeConnector((SearchResult) event.getOldBinding());
1:a80acbb:         } catch (Exception err) {
1:a80acbb:             LOG.error("ERR: caught unexpected exception", err);
1:dead574:         }
1:a80acbb:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * invoked when an entry has been renamed during a persistent search
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void objectRenamed(NamingEvent event) {
1:dead574:         LOG.debug("entry renamed");
1:dead574:         // XXX: getNameInNamespace method does not seem to work properly,
1:a80acbb:         // but getName seems to provide the result we want
1:dead574:         String uuidOld = event.getOldBinding().getName();
1:dead574:         String uuidNew = event.getNewBinding().getName();
1:dead574:         URI connectorURI = uuidMap.remove(uuidOld);
1:dead574:         uuidMap.put(uuidNew, connectorURI);
1:e1bbde7:         LOG.debug("connector reference renamed for URI [{}], Old UUID [{}], New UUID [{}]", new Object[]{ connectorURI, uuidOld, uuidNew });
1:dead574:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * invoked when an entry has been changed during a persistent search
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void objectChanged(NamingEvent event) {
1:dead574:         LOG.debug("entry changed");
1:a80acbb:         try {
1:a80acbb:             SearchResult result = (SearchResult) event.getNewBinding();
1:dead574:             removeConnector(result);
1:dead574:             addConnector(result);
1:a80acbb:         } catch (Exception err) {
1:a80acbb:             LOG.error("ERR: caught unexpected exception", err);
1:dead574:         }
1:dead574:     }
1:dead574: 
1:dead574:     /**
1:dead574:      * invoked when an exception has occurred during a persistent search
1:dead574:      */
1:5e05df1:     @Override
1:a80acbb:     public void namingExceptionThrown(NamingExceptionEvent event) {
1:a80acbb:         LOG.error("ERR: caught unexpected exception", event.getException());
1:a80acbb:     }
1:a80acbb: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:5e05df1
/////////////////////////////////////////////////////////////////////////
1:      * @param uri
/////////////////////////////////////////////////////////////////////////
1:      * @param base
/////////////////////////////////////////////////////////////////////////
1:      * @param user
/////////////////////////////////////////////////////////////////////////
1:      * @param password
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:      * @param anonymousAuthentication
/////////////////////////////////////////////////////////////////////////
1:      * @param searchScope
/////////////////////////////////////////////////////////////////////////
1:      * @param searchFilter
/////////////////////////////////////////////////////////////////////////
1:      * @param searchEventListener
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("    URI [{}]", this.ldapURI);
1:             LOG.debug("    login credentials [{}:******]", user);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.error("connection error [{}], failover connection to [{}]", env.get(Context.PROVIDER_URL), this.ldapURI.toString());
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("    base   [{}]", base);
1:         LOG.debug("    filter [{}]", searchFilter);
1:         LOG.debug("    scope  [{}]", searchControls.getSearchScope());
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("connector already regsitered for UUID [{}]", uuid);
1:             LOG.warn("connector reference added for URI [{}], UUID [{}], total reference(s) [{}]", new Object[]{ connectorURI, uuid, referenceCount });
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("connector added with URI [{}]", connectorURI);
/////////////////////////////////////////////////////////////////////////
1:             LOG.warn("connector not registered for UUID [{}]", uuid);
1:             LOG.warn("connector not registered for URI [{}]", connectorURI);
1:         LOG.debug("connector referenced removed for URI [{}], UUID[{}], remaining reference(s) [{}]", new Object[]{ connectorURI, uuid, referenceCount });
/////////////////////////////////////////////////////////////////////////
1:         LOG.info("connector removed with URI [{}]", connectorURI);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("retrieved URI from SearchResult [{}]", connectorURI);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("retrieved UUID from SearchResult [{}]", uuid);
/////////////////////////////////////////////////////////////////////////
1:         LOG.debug("connector reference renamed for URI [{}], Old UUID [{}], New UUID [{}]", new Object[]{ connectorURI, uuidOld, uuidNew });
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:0b5231a
/////////////////////////////////////////////////////////////////////////
1:             if (user != null && !"".equals(user)) {
1:                 env.put(Context.SECURITY_PRINCIPAL, user);
1:             } else {
1:                 throw new Exception("Empty username is not allowed");
1:             }
1:             if (password != null && !"".equals(password)) {
1:                 env.put(Context.SECURITY_CREDENTIALS, password);
1:             } else {
1:                 throw new Exception("Empty password is not allowed");
1:             }
author:Gary Tully
-------------------------------------------------------------------------------
commit:a95c6db
/////////////////////////////////////////////////////////////////////////
1:         connector.setConsumerTTL(getConsumerTTL());
1:         connector.setMessageTTL(getMessageTTL());
commit:27d0ff4
/////////////////////////////////////////////////////////////////////////
1:    public String toString() {
0:        return this.getClass().getName() + getName()  + "[" + ldapURI.toString() + "]";
1:    }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:dead574
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
0: import java.util.Random;
1: import java.util.concurrent.ConcurrentHashMap;
1: import javax.naming.CommunicationException;
/////////////////////////////////////////////////////////////////////////
1: import javax.naming.event.EventDirContext;
1: import javax.naming.event.NamespaceChangeListener;
1: import javax.naming.event.NamingEvent;
1: import javax.naming.event.NamingExceptionEvent;
1: import javax.naming.event.ObjectChangeListener;
1: import org.apache.activemq.util.URISupport;
1: import org.apache.activemq.util.URISupport.CompositeData;
/////////////////////////////////////////////////////////////////////////
0: public class      LdapNetworkConnector
0:        extends    NetworkConnector
0:        implements NamespaceChangeListener,
0:                   ObjectChangeListener
0: {
0:    private static final Log LOG = LogFactory.getLog(LdapNetworkConnector.class);
1:    // force returned entries to implement the ipHost and ipService object classes (RFC 2307)
0:    private static final String REQUIRED_OBJECT_CLASS_FILTER  = "(&(objectClass=ipHost)(objectClass=ipService))";
1:    // connection
0:    private URI[]   availableURIs      = null;
0:    private int     availableURIsIndex = 0;
0:    private String  base               = null;
0:    private boolean failover           = false;
0:    private long    curReconnectDelay  = 1000;  /* 1 sec */
0:    private long    maxReconnectDelay  = 30000; /* 30 sec */
1:    // authentication
0:    private String  user                    = null;
0:    private String  password                = null;
1:    private boolean anonymousAuthentication = false;
1:    // search
0:    private SearchControls searchControls      = new SearchControls(/* ONELEVEL_SCOPE */);
0:    private String         searchFilter        = REQUIRED_OBJECT_CLASS_FILTER;
0:    private boolean        searchEventListener = false;
1:    // connector management
0:    private Map<URI, NetworkConnector> connectorMap = new ConcurrentHashMap();
0:    private Map<URI, Integer>          referenceMap = new ConcurrentHashMap();
0:    private Map<String, URI>           uuidMap      = new ConcurrentHashMap();
1:    // local context
1:    private DirContext context = null;
1:    /**
1:     * returns the next URI from the configured list
1:     *
1:     * @return random URI from the configured list
1:     */
0:    public URI getUri()
0:       { return availableURIs[++availableURIsIndex % availableURIs.length]; }
1:    /**
1:     * sets the LDAP server URI
1:     *
0:     * @param _uri LDAP server URI
1:     */
0:    public void setUri(URI _uri)
0:       throws Exception
0:    {
0:       CompositeData data = URISupport.parseComposite(_uri);
0:       if(data.getScheme().equals("failover"))
0:       {
1:          availableURIs = data.getComponents();
1:          failover = true;
1:       }
0:       else
0:          { availableURIs = new URI[]{ _uri }; }
1:    }
1:    /**
1:     * sets the base LDAP dn used for lookup operations
1:     *
0:     * @param _base LDAP base dn
1:     */
0:    public void setBase(String _base)
0:       { base = _base; }
1:    /**
1:     * sets the LDAP user for access credentials
1:     *
0:     * @param _user LDAP dn of user
1:     */
0:    public void setUser(String _user)
0:       { user = _user; }
1:    /**
1:     * sets the LDAP password for access credentials
1:     *
0:     * @param _password user password
1:     */
0:    public void setPassword(String _password)
0:       { password = _password; }
1:    /**
1:     * sets LDAP anonymous authentication access credentials
1:     *
0:     * @param _anonymousAuthentication set to true to use anonymous authentication
1:     */
0:    public void setAnonymousAuthentication(boolean _anonymousAuthentication)
0:       { anonymousAuthentication = _anonymousAuthentication; }
1:    /**
1:     * sets the LDAP search scope
1:     *
0:     * @param _searchScope LDAP JNDI search scope
1:     */
0:    public void setSearchScope(String _searchScope)
0:       throws Exception
0:    {
1:       int scope;
0:       if(_searchScope.equals("OBJECT_SCOPE"))
0:          { scope = SearchControls.OBJECT_SCOPE; }
0:       else if(_searchScope.equals("ONELEVEL_SCOPE"))
0:          { scope = SearchControls.ONELEVEL_SCOPE; }
0:       else if(_searchScope.equals("SUBTREE_SCOPE"))
0:          { scope = SearchControls.SUBTREE_SCOPE; }
0:       else
0:          { throw new Exception("ERR: unknown LDAP search scope specified: " + _searchScope); }
1:       searchControls.setSearchScope(scope);
1:    }
1:    /**
1:     * sets the LDAP search filter as defined in RFC 2254
1:     *
0:     * @param _searchFilter LDAP search filter
1:     * @see <a href="http://www.faqs.org/rfcs/rfc2254.html">RFC 2254</a>
1:     */
0:    public void setSearchFilter(String _searchFilter)
0:       { searchFilter = "(&" + REQUIRED_OBJECT_CLASS_FILTER + "(" + _searchFilter + "))"; }
1:    /**
0:     * enables/disable a persistent search to the LDAP server as defined
0:     * in draft-ietf-ldapext-psearch-03.txt (2.16.840.1.113730.3.4.3)
1:     *
0:     * @param _searchEventListener enable = true, disable = false (default)
0:     * @see <a href="http://www.ietf.org/proceedings/01mar/I-D/draft-ietf-ldapext-psearch-03.txt">draft-ietf-ldapext-psearch-03.txt</a>
1:     */
0:    public void setSearchEventListener(boolean _searchEventListener)
0:       { searchEventListener = _searchEventListener; }
1:    /**
1:     * start the connector
1:     */
0:    public void start()
0:       throws Exception
0:    {
1:       LOG.info("connecting...");
0:       Hashtable<String, String> env = new Hashtable();
1:       env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
0:       URI uri = getUri();
0:       LOG.debug("    URI [" + uri + "]");
0:       env.put(Context.PROVIDER_URL, uri.toString());
0:       if(anonymousAuthentication)
0:       {
1:          LOG.debug("    login credentials [anonymous]");
1:          env.put(Context.SECURITY_AUTHENTICATION, "none");
1:       }
0:       else
0:       {
0:          LOG.debug("    login credentials [" + user + ":******]");
0:          env.put(Context.SECURITY_PRINCIPAL,   user);
0:          env.put(Context.SECURITY_CREDENTIALS, password);
1:       }
1:       boolean isConnected = false;
0:       while(!isConnected)
0:       {
0:          try
0:          {
1:             context = new InitialDirContext(env);
1:             isConnected = true;
1:          }
0:          catch(CommunicationException err)
0:          {
0:             if(failover)
0:             {
0:                uri = getUri();
0:                LOG.error("connection error [" + env.get(Context.PROVIDER_URL) + "], failover connection to [" + uri.toString() + "]");
0:                env.put(Context.PROVIDER_URL, uri.toString());
1:                Thread.sleep(curReconnectDelay);
1:                curReconnectDelay = Math.min(curReconnectDelay * 2, maxReconnectDelay);
1:             }
0:             else
0:                { throw err; }
1:          }
1:       }
1:       // add connectors from search results
1:       LOG.info("searching for network connectors...");
0:       LOG.debug("    base   [" + base + "]");
0:       LOG.debug("    filter [" + searchFilter + "]");
0:       LOG.debug("    scope  [" + searchControls.getSearchScope() + "]");
1:       NamingEnumeration<SearchResult> results = context.search(base, searchFilter, searchControls);
0:       while(results.hasMore())
0:          { addConnector(results.next()); }
1:       // register persistent search event listener
0:       if(searchEventListener)
0:       {
1:          LOG.info("registering persistent search listener...");
0:          EventDirContext eventContext = (EventDirContext)context.lookup("");
1:          eventContext.addNamingListener(base, searchFilter, searchControls, this);
1:       }
0:       else // otherwise close context (i.e. connection as it is no longer needed)
0:          { context.close(); }
1:    }
1: 
1:    /**
1:     * stop the connector
1:     */
0:    public void stop()
0:       throws Exception
0:    {
1:       LOG.info("stopping context...");
0:       for(NetworkConnector connector : connectorMap.values())
0:          { connector.stop(); }
1:       connectorMap.clear();
1:       referenceMap.clear();
1:       uuidMap.clear();
1:       context.close();
1:    }
1: 
1:    /**
0:     * returns the name of the connector
1:     *
0:     * @return connector name
1:     */
0:    public String getName()
0:       { return toString(); }
1: 
1:    /**
1:     * add connector of the given URI
1:     *
0:     * @param result search result of connector to add
1:     */
0:    protected synchronized void addConnector(SearchResult result)
0:       throws Exception
0:    {
1:       String uuid = toUUID(result);
0:       if(uuidMap.containsKey(uuid))
0:       {
0:          LOG.warn("connector already regsitered for UUID [" + uuid + "]");
1:          return;
1:       }
1: 
1:       URI connectorURI = toURI(result);
0:       if(connectorMap.containsKey(connectorURI))
0:       {
1:          int referenceCount = referenceMap.get(connectorURI) + 1;
0:          LOG.warn("connector reference added for URI [" + connectorURI + "], UUID [" + uuid + "], total reference(s) [" + referenceCount + "]");
1:          referenceMap.put(connectorURI, referenceCount);
1:          uuidMap.put(uuid, connectorURI);
1:          return;
1:       }
1: 
1:       // FIXME: disable JMX listing of LDAP managed connectors, we will
0:       //       want to map/manage these differently in the future
0: //      boolean useJMX = getBrokerService().isUseJmx();
0: //      getBrokerService().setUseJmx(false);
1:       NetworkConnector connector = getBrokerService().addNetworkConnector(connectorURI);
0: //      getBrokerService().setUseJmx(useJMX);
1: 
0:       // propogate std connector properties that may have been set via XML
1:       connector.setDynamicOnly(isDynamicOnly());
1:       connector.setDecreaseNetworkConsumerPriority(isDecreaseNetworkConsumerPriority());
1:       connector.setNetworkTTL(getNetworkTTL());
1:       connector.setConduitSubscriptions(isConduitSubscriptions());
1:       connector.setExcludedDestinations(getExcludedDestinations());
1:       connector.setDynamicallyIncludedDestinations(getDynamicallyIncludedDestinations());
1:       connector.setDuplex(isDuplex());
1: 
1:       // XXX: set in the BrokerService.startAllConnectors method and is 
0:       //      required to prevent remote broker exceptions upon connection
1:       connector.setLocalUri(getBrokerService().getVmConnectorURI());
1:       connector.setBrokerName(getBrokerService().getBrokerName());
1:       connector.setDurableDestinations(getBrokerService().getBroker().getDurableDestinations());
1: 
1:       // start network connector
1:       connectorMap.put(connectorURI, connector);
1:       referenceMap.put(connectorURI, 1);
1:       uuidMap.put(uuid, connectorURI);
1:       connector.start();
0:       LOG.info("connector added with URI [" + connectorURI + "]");
1:    }
1: 
1:    /**
1:     * remove connector of the given URI
1:     *
0:     * @param result search result of connector to remove
1:     */
0:    protected synchronized void removeConnector(SearchResult result)
0:       throws Exception
0:    {
1:       String uuid = toUUID(result);
0:       if(!uuidMap.containsKey(uuid))
0:       {
0:          LOG.warn("connector not regsitered for UUID [" + uuid + "]");
1:          return;
1:       }
1: 
1:       URI connectorURI = uuidMap.get(uuid);
0:       if(!connectorMap.containsKey(connectorURI))
0:       {
0:          LOG.warn("connector not regisitered for URI [" + connectorURI + "]");
1:          return;
1:       }
1: 
1:       int referenceCount = referenceMap.get(connectorURI) - 1;
1:       referenceMap.put(connectorURI, referenceCount);
1:       uuidMap.remove(uuid);
0:       LOG.debug("connector referenced removed for URI [" + connectorURI + "], UUID [" + uuid + "], remaining reference(s) [" + referenceCount + "]");
1: 
0:       if(referenceCount > 0)
0:          { return; }
1: 
1:       NetworkConnector connector = connectorMap.remove(connectorURI);
1:       connector.stop();
0:       LOG.info("connector removed with URI [" + connectorURI + "]");
1:    }
1: 
1:    /**
1:     * convert search result into URI
1:     *
0:     * @param result search result to convert to URI
1:     */
0:    protected URI toURI(SearchResult result)
0:       throws Exception
0:    {
1:       Attributes attributes = result.getAttributes();
0:       String address  = (String)attributes.get("iphostnumber").get();
0:       String port     = (String)attributes.get("ipserviceport").get();
0:       String protocol = (String)attributes.get("ipserviceprotocol").get();
1:       URI connectorURI = new URI("static:(" + protocol + "://" + address + ":" + port + ")");
0:       LOG.debug("retrieved URI from SearchResult [" + connectorURI + "]");
1:       return connectorURI;
1:    }
1: 
1:    /**
1:     * convert search result into URI
1:     *
0:     * @param result search result to convert to URI
1:     */
0:    protected String toUUID(SearchResult result)
0:    {
1:       String uuid = result.getNameInNamespace();
0:       LOG.debug("retrieved UUID from SearchResult [" + uuid + "]");
1:       return uuid;
1:    }
1: 
1:    /**
1:     * invoked when an entry has been added during a persistent search
1:     */
0:    public void objectAdded(NamingEvent event)
0:    {
1:       LOG.debug("entry added");
0:       try
0:          { addConnector((SearchResult)event.getNewBinding()); }
0:       catch(Exception err)
0:          { LOG.error("ERR: caught unexpected exception", err); }
1:    }
1: 
1:    /**
1:     * invoked when an entry has been removed during a persistent search
1:     */
0:    public void objectRemoved(NamingEvent event)
0:    {
1:       LOG.debug("entry removed");
0:       try
0:          { removeConnector((SearchResult)event.getOldBinding()); }
0:       catch(Exception err)
0:          { LOG.error("ERR: caught unexpected exception", err); }
1:    }
1: 
1:    /**
1:     * invoked when an entry has been renamed during a persistent search
1:     */
0:    public void objectRenamed(NamingEvent event)
0:    {
1:       LOG.debug("entry renamed");
1:       // XXX: getNameInNamespace method does not seem to work properly,
0:       //      but getName seems to provide the result we want
1:       String uuidOld = event.getOldBinding().getName();
1:       String uuidNew = event.getNewBinding().getName();
1:       URI connectorURI = uuidMap.remove(uuidOld);
1:       uuidMap.put(uuidNew, connectorURI);
0:       LOG.debug("connector reference renamed for URI [" + connectorURI + "], Old UUID [" + uuidOld + "], New UUID [" + uuidNew + "]");
1:    }
1: 
1:    /**
1:     * invoked when an entry has been changed during a persistent search
1:     */
0:    public void objectChanged(NamingEvent event)
0:    {
1:       LOG.debug("entry changed");
0:       try
0:       {
0:          SearchResult result = (SearchResult)event.getNewBinding();
1:          removeConnector(result);
1:          addConnector(result);
1:       }
0:       catch(Exception err)
0:          { LOG.error("ERR: caught unexpected exception", err); }
1:    }
1: 
1:    /**
1:     * invoked when an exception has occurred during a persistent search
1:     */
0:    public void namingExceptionThrown(NamingExceptionEvent event)
0:       { LOG.error("ERR: caught unexpected exception", event.getException()); }
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:a80acbb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * class to create dynamic network connectors listed in an directory server
1:  * using the LDAP v3 protocol as defined in RFC 2251, the entries listed in the
1:  * directory server must implement the ipHost and ipService objectClasses as
1:  * defined in RFC 2307.
1:  *
1: public class LdapNetworkConnector extends NetworkConnector implements NamespaceChangeListener, ObjectChangeListener {
1:     private static final Logger LOG = LoggerFactory.getLogger(LdapNetworkConnector.class);
0:     // force returned entries to implement the ipHost and ipService object classes (RFC 2307)
1:     private static final String REQUIRED_OBJECT_CLASS_FILTER =
1:             "(&(objectClass=ipHost)(objectClass=ipService))";
0:     // connection
1:     private URI[] availableURIs = null;
1:     private int availableURIsIndex = 0;
1:     private String base = null;
1:     private boolean failover = false;
1:     private long curReconnectDelay = 1000; /* 1 sec */
1:     private long maxReconnectDelay = 30000; /* 30 sec */
0:     // authentication
1:     private String user = null;
1:     private String password = null;
0:     private boolean anonymousAuthentication = false;
0:     // search
1:     private SearchControls searchControls = new SearchControls(/* ONELEVEL_SCOPE */);
1:     private String searchFilter = REQUIRED_OBJECT_CLASS_FILTER;
1:     private boolean searchEventListener = false;
0:     // connector management
1:     private Map<URI, NetworkConnector> connectorMap = new ConcurrentHashMap<URI, NetworkConnector>();
1:     private Map<URI, Integer> referenceMap = new ConcurrentHashMap<URI, Integer>();
1:     private Map<String, URI> uuidMap = new ConcurrentHashMap<String, URI>();
0:     // local context
0:     private DirContext context = null;
1:     // currently in use URI
1:     private URI ldapURI = null;
1:     /**
0:      * returns the next URI from the configured list
1:      *
0:      * @return random URI from the configured list
1:      */
1:     public URI getUri() {
1:         return availableURIs[++availableURIsIndex % availableURIs.length];
1:     }
1:     /**
0:      * sets the LDAP server URI
1:      *
0:      * @param _uri
1:      *            LDAP server URI
1:      */
1:     public void setUri(URI uri) throws Exception {
1:         CompositeData data = URISupport.parseComposite(uri);
1:         if (data.getScheme().equals("failover")) {
0:             availableURIs = data.getComponents();
0:             failover = true;
1:         } else {
1:             availableURIs = new URI[] { uri };
1:         }
1:     }
1:     /**
0:      * sets the base LDAP dn used for lookup operations
1:      *
0:      * @param _base
1:      *            LDAP base dn
1:      */
1:     public void setBase(String base) {
1:         this.base = base;
1:     }
1:     /**
0:      * sets the LDAP user for access credentials
1:      *
0:      * @param _user
1:      *            LDAP dn of user
1:      */
1:     public void setUser(String user) {
1:         this.user = user;
1:     }
1:     /**
0:      * sets the LDAP password for access credentials
1:      *
0:      * @param _password
1:      *            user password
1:      */
1:     public void setPassword(String password) {
1:         this.password = password;
1:     }
1:     /**
0:      * sets LDAP anonymous authentication access credentials
1:      *
0:      * @param _anonymousAuthentication
1:      *            set to true to use anonymous authentication
1:      */
1:     public void setAnonymousAuthentication(boolean anonymousAuthentication) {
1:         this.anonymousAuthentication = anonymousAuthentication;
1:     }
1:     /**
0:      * sets the LDAP search scope
1:      *
0:      * @param _searchScope
1:      *            LDAP JNDI search scope
1:      */
1:     public void setSearchScope(String searchScope) throws Exception {
0:         int scope;
1:         if (searchScope.equals("OBJECT_SCOPE")) {
1:             scope = SearchControls.OBJECT_SCOPE;
1:         } else if (searchScope.equals("ONELEVEL_SCOPE")) {
1:             scope = SearchControls.ONELEVEL_SCOPE;
1:         } else if (searchScope.equals("SUBTREE_SCOPE")) {
1:             scope = SearchControls.SUBTREE_SCOPE;
1:         } else {
1:             throw new Exception("ERR: unknown LDAP search scope specified: " + searchScope);
1:         }
0:         searchControls.setSearchScope(scope);
1:     }
1:     /**
0:      * sets the LDAP search filter as defined in RFC 2254
1:      *
0:      * @param _searchFilter
1:      *            LDAP search filter
0:      * @see <a href="http://www.faqs.org/rfcs/rfc2254.html">RFC 2254</a>
1:      */
1:     public void setSearchFilter(String searchFilter) {
1:         this.searchFilter = "(&" + REQUIRED_OBJECT_CLASS_FILTER + "(" + searchFilter + "))";
1:     }
1:     /**
1:      * enables/disable a persistent search to the LDAP server as defined in
1:      * draft-ietf-ldapext-psearch-03.txt (2.16.840.1.113730.3.4.3)
1:      *
0:      * @param _searchEventListener
1:      *            enable = true, disable = false (default)
1:      * @see <a
1:      *      href="http://www.ietf.org/proceedings/01mar/I-D/draft-ietf-ldapext-psearch-03.txt">draft-ietf-ldapext-psearch-03.txt</a>
1:      */
1:     public void setSearchEventListener(boolean searchEventListener) {
1:         this.searchEventListener = searchEventListener;
1:     }
1:     /**
0:      * start the connector
1:      */
1:     public void start() throws Exception {
0:         LOG.info("connecting...");
1:         Hashtable<String, String> env = new Hashtable<String, String>();
0:         env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
1:         this.ldapURI = getUri();
0:         LOG.debug("    URI [" + this.ldapURI + "]");
1:         env.put(Context.PROVIDER_URL, this.ldapURI.toString());
1:         if (anonymousAuthentication) {
0:             LOG.debug("    login credentials [anonymous]");
0:             env.put(Context.SECURITY_AUTHENTICATION, "none");
1:         } else {
0:             LOG.debug("    login credentials [" + user + ":******]");
0:             env.put(Context.SECURITY_PRINCIPAL, user);
0:             env.put(Context.SECURITY_CREDENTIALS, password);
1:         }
0:         boolean isConnected = false;
1:         while (!isConnected) {
1:             try {
0:                 context = new InitialDirContext(env);
0:                 isConnected = true;
1:             } catch (CommunicationException err) {
1:                 if (failover) {
1:                     this.ldapURI = getUri();
0:                     LOG.error("connection error [" + env.get(Context.PROVIDER_URL) + "], failover connection to [" + this.ldapURI.toString() + "]");
1:                     env.put(Context.PROVIDER_URL, this.ldapURI.toString());
0:                     Thread.sleep(curReconnectDelay);
0:                     curReconnectDelay = Math.min(curReconnectDelay * 2, maxReconnectDelay);
1:                 } else {
1:                     throw err;
1:                 }
1:         }
0:         // add connectors from search results
0:         LOG.info("searching for network connectors...");
0:         LOG.debug("    base   [" + base + "]");
0:         LOG.debug("    filter [" + searchFilter + "]");
0:         LOG.debug("    scope  [" + searchControls.getSearchScope() + "]");
0:         NamingEnumeration<SearchResult> results = context.search(base, searchFilter, searchControls);
1:         while (results.hasMore()) {
1:             addConnector(results.next());
1:         }
0:         // register persistent search event listener
1:         if (searchEventListener) {
0:             LOG.info("registering persistent search listener...");
1:             EventDirContext eventContext = (EventDirContext) context.lookup("");
0:             eventContext.addNamingListener(base, searchFilter, searchControls, this);
1:         } else { // otherwise close context (i.e. connection as it is no longer needed)
1:             context.close();
1:         }
1:     }
1:     /**
0:      * stop the connector
1:      */
1:     public void stop() throws Exception {
0:         LOG.info("stopping context...");
1:         for (NetworkConnector connector : connectorMap.values()) {
1:             connector.stop();
1:         }
0:         connectorMap.clear();
0:         referenceMap.clear();
0:         uuidMap.clear();
1:         context.close();
1:     }
0:     public String toString() {
1:         return this.getClass().getName() + getName() + "[" + ldapURI.toString() + "]";
1:     }
1:     /**
1:      *
1:     protected synchronized void addConnector(SearchResult result) throws Exception {
0:         String uuid = toUUID(result);
1:         if (uuidMap.containsKey(uuid)) {
0:             LOG.warn("connector already regsitered for UUID [" + uuid + "]");
1:             return;
1:         }
0:         URI connectorURI = toURI(result);
1:         if (connectorMap.containsKey(connectorURI)) {
0:             int referenceCount = referenceMap.get(connectorURI) + 1;
0:             LOG.warn("connector reference added for URI [" + connectorURI + "], UUID [" + uuid + "], total reference(s) [" + referenceCount + "]");
0:             referenceMap.put(connectorURI, referenceCount);
0:             uuidMap.put(uuid, connectorURI);
1:             return;
1:         }
0:         // FIXME: disable JMX listing of LDAP managed connectors, we will
1:         // want to map/manage these differently in the future
1:         // boolean useJMX = getBrokerService().isUseJmx();
1:         // getBrokerService().setUseJmx(false);
0:         NetworkConnector connector = getBrokerService().addNetworkConnector(connectorURI);
1:         // getBrokerService().setUseJmx(useJMX);
1:         // Propagate standard connector properties that may have been set via XML
0:         connector.setDynamicOnly(isDynamicOnly());
0:         connector.setDecreaseNetworkConsumerPriority(isDecreaseNetworkConsumerPriority());
0:         connector.setNetworkTTL(getNetworkTTL());
0:         connector.setConduitSubscriptions(isConduitSubscriptions());
0:         connector.setExcludedDestinations(getExcludedDestinations());
0:         connector.setDynamicallyIncludedDestinations(getDynamicallyIncludedDestinations());
0:         connector.setDuplex(isDuplex());
0:         // XXX: set in the BrokerService.startAllConnectors method and is
1:         // required to prevent remote broker exceptions upon connection
0:         connector.setLocalUri(getBrokerService().getVmConnectorURI());
0:         connector.setBrokerName(getBrokerService().getBrokerName());
0:         connector.setDurableDestinations(getBrokerService().getBroker().getDurableDestinations());
0:         // start network connector
0:         connectorMap.put(connectorURI, connector);
0:         referenceMap.put(connectorURI, 1);
0:         uuidMap.put(uuid, connectorURI);
0:         connector.start();
0:         LOG.info("connector added with URI [" + connectorURI + "]");
1:     }
1:     /**
0:      * remove connector of the given URI
1:      *
1:      * @param result
1:      *            search result of connector to remove
1:      */
1:     protected synchronized void removeConnector(SearchResult result) throws Exception {
0:         String uuid = toUUID(result);
1:         if (!uuidMap.containsKey(uuid)) {
0:             LOG.warn("connector not regsitered for UUID [" + uuid + "]");
1:             return;
1:         }
0:         URI connectorURI = uuidMap.get(uuid);
1:         if (!connectorMap.containsKey(connectorURI)) {
0:             LOG.warn("connector not regisitered for URI [" + connectorURI + "]");
1:             return;
1:         }
0:         int referenceCount = referenceMap.get(connectorURI) - 1;
0:         referenceMap.put(connectorURI, referenceCount);
0:         uuidMap.remove(uuid);
0:         LOG.debug("connector referenced removed for URI [" + connectorURI + "], UUID [" + uuid + "], remaining reference(s) [" + referenceCount + "]");
1:         if (referenceCount > 0) {
1:             return;
1:         }
0:         NetworkConnector connector = connectorMap.remove(connectorURI);
1:         connector.stop();
0:         LOG.info("connector removed with URI [" + connectorURI + "]");
1:     }
1:     /**
0:      * convert search result into URI
1:      *
1:      * @param result
1:      *            search result to convert to URI
1:      */
1:     protected URI toURI(SearchResult result) throws Exception {
0:         Attributes attributes = result.getAttributes();
1:         String address = (String) attributes.get("iphostnumber").get();
1:         String port = (String) attributes.get("ipserviceport").get();
1:         String protocol = (String) attributes.get("ipserviceprotocol").get();
0:         URI connectorURI = new URI("static:(" + protocol + "://" + address + ":" + port + ")");
0:         LOG.debug("retrieved URI from SearchResult [" + connectorURI + "]");
0:         return connectorURI;
1:     }
1:     /**
0:      * convert search result into URI
1:      *
1:      * @param result
1:      *            search result to convert to URI
1:      */
1:     protected String toUUID(SearchResult result) {
0:         String uuid = result.getNameInNamespace();
0:         LOG.debug("retrieved UUID from SearchResult [" + uuid + "]");
0:         return uuid;
1:     }
1:     /**
0:      * invoked when an entry has been added during a persistent search
1:      */
1:     public void objectAdded(NamingEvent event) {
0:         LOG.debug("entry added");
1:         try {
1:             addConnector((SearchResult) event.getNewBinding());
1:         } catch (Exception err) {
1:             LOG.error("ERR: caught unexpected exception", err);
1:         }
1:     }
1:     /**
0:      * invoked when an entry has been removed during a persistent search
1:      */
1:     public void objectRemoved(NamingEvent event) {
0:         LOG.debug("entry removed");
1:         try {
1:             removeConnector((SearchResult) event.getOldBinding());
1:         } catch (Exception err) {
1:             LOG.error("ERR: caught unexpected exception", err);
1:         }
1:     }
1:     /**
0:      * invoked when an entry has been renamed during a persistent search
1:      */
1:     public void objectRenamed(NamingEvent event) {
0:         LOG.debug("entry renamed");
0:         // XXX: getNameInNamespace method does not seem to work properly,
1:         // but getName seems to provide the result we want
0:         String uuidOld = event.getOldBinding().getName();
0:         String uuidNew = event.getNewBinding().getName();
0:         URI connectorURI = uuidMap.remove(uuidOld);
0:         uuidMap.put(uuidNew, connectorURI);
0:         LOG.debug("connector reference renamed for URI [" + connectorURI + "], Old UUID [" + uuidOld + "], New UUID [" + uuidNew + "]");
1:     }
1:     /**
0:      * invoked when an entry has been changed during a persistent search
1:      */
1:     public void objectChanged(NamingEvent event) {
0:         LOG.debug("entry changed");
1:         try {
1:             SearchResult result = (SearchResult) event.getNewBinding();
0:             removeConnector(result);
0:             addConnector(result);
1:         } catch (Exception err) {
1:             LOG.error("ERR: caught unexpected exception", err);
1:         }
1:     }
1:     /**
0:      * invoked when an exception has occurred during a persistent search
1:      */
1:     public void namingExceptionThrown(NamingExceptionEvent event) {
1:         LOG.error("ERR: caught unexpected exception", event.getException());
1:     }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
0:    private static final Logger LOG = LoggerFactory.getLogger(LdapNetworkConnector.class);
author:Robert Davies
-------------------------------------------------------------------------------
commit:520a2de
/////////////////////////////////////////////////////////////////////////
0:    //currently in use URI
0:    private URI ldapURI = null;
/////////////////////////////////////////////////////////////////////////
0:       this.ldapURI = getUri();
0:       LOG.debug("    URI [" + this.ldapURI + "]");
0:       env.put(Context.PROVIDER_URL, this.ldapURI.toString());
/////////////////////////////////////////////////////////////////////////
0:                 this.ldapURI = getUri();
0:                LOG.error("connection error [" + env.get(Context.PROVIDER_URL) + "], failover connection to [" + this.ldapURI.toString() + "]");
0:                env.put(Context.PROVIDER_URL, this.ldapURI.toString());
/////////////////////////////////////////////////////////////////////////
0:    public String getName() {
1: 
0:         String name = super.getName();
0:         if (name == null) {
0:             name = this.getClass().getName() + " [" + ldapURI.toString() + "]";
0:             super.setName(name);
0:         }
0:         return name;
0:     }
0:      * add connector of the given URI
0:      * 
1:      * @param result
1:      *            search result of connector to add
0:      */
commit:67e5952
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
0:  */
1: package org.apache.activemq.network;
1: 
1: import java.net.URI;
0: import java.util.ArrayList;
1: import java.util.Hashtable;
0: import java.util.List;
0: import java.util.concurrent.CopyOnWriteArrayList;
1: 
1: import javax.naming.Context;
1: import javax.naming.NamingEnumeration;
1: import javax.naming.directory.Attributes;
1: import javax.naming.directory.DirContext;
1: import javax.naming.directory.InitialDirContext;
1: import javax.naming.directory.SearchControls;
1: import javax.naming.directory.SearchResult;
1: 
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
0: /**
0:  * class to create dynamic network connectors listed in an directory
0:  * server using the LDAP v3 protocol as defined in RFC 2251, the
0:  * entries listed in the directory server must implement the ipHost
0:  * and ipService objectClasses as defined in RFC 2307.
0:  * 
0:  * @author Trevor Pounds
1:  * @see <a href="http://www.faqs.org/rfcs/rfc2251.html">RFC 2251</a>
1:  * @see <a href="http://www.faqs.org/rfcs/rfc2307.html">RFC 2307</a>
0:  *
1:  * @org.apache.xbean.XBean element="ldapNetworkConnector"
0:  */
0: public class LdapNetworkConnector extends NetworkConnector {
0:     private static final Log LOG = LogFactory.getLog(LdapNetworkConnector.class);
1: 
0:     // TODO: future >> LDAP JNDI event handling to update connectors?
1: 
0:     // force returned entries to implement the ipHost and ipService objectClasses (RFC 2307)
0:     private static final String REQUIRED_OBJECT_CLASS_FILTER  = "(&(objectClass=ipHost)(objectClass=ipService))";
1: 
0:     // required
0:     private URI    ldapURI;
0:     private String ldapBase;
0:     private String ldapUser;
0:     private String ldapPassword;
1: 
0:     // optional
0:     private int    ldapSearchScope  =  SearchControls.OBJECT_SCOPE;
0:     private String ldapSearchFilter =  REQUIRED_OBJECT_CLASS_FILTER;
1: 
0:     // internal configurables
0:     private DirContext ldapContext;
0:     private List<NetworkConnector> connectors = new CopyOnWriteArrayList<NetworkConnector>();
1: 
0:     /**
0:      * default constructor
0:      */
0:     public LdapNetworkConnector() {
0:     }
1: 
0:     /**
0:      * sets the LDAP server URI
0:      *
0:      * @param uri LDAP server URI
0:      */
0:     public void setUri(URI uri) {
0:         ldapURI = uri;
0:     }
1: 
0:     /**
0:      * sets the base LDAP dn used for lookup operations
0:      *
0:      * @param base LDAP base dn
0:      */
0:     public void setBase(String base) {
0:         ldapBase = base;
0:     }
1: 
0:     /**
0:      * sets the LDAP user for access credentials
0:      *
0:      * @param user LDAP dn of user
0:      */
0:     public void setUser(String user) {
0:         ldapUser = user;
0:     }
1: 
0:     /**
0:      * sets the LDAP password for access credentials
0:      *
0:      * @param password user password
0:      */
0:     public void setPassword(String password) {
0:         ldapPassword = password;
0:     }
1: 
0:     /**
0:      * sets the LDAP search scope
0:      *
0:      * @param searchScope LDAP JNDI search scope
0:      */
0:     public void setSearchScope(String searchScope) throws Exception {
0:         if(searchScope.equals("OBJECT_SCOPE")) {
0:             ldapSearchScope = SearchControls.OBJECT_SCOPE;
0:         }
0:         else if(searchScope.equals("ONELEVEL_SCOPE")) {
0:             ldapSearchScope = SearchControls.ONELEVEL_SCOPE;
0:         }
0:         else if(searchScope.equals("SUBTREE_SCOPE")) {
0:             ldapSearchScope = SearchControls.SUBTREE_SCOPE;
0:         }
0:         else {
0:           throw new Exception("ERR: unknown LDAP search scope specified: " + searchScope);
0:         }
0:     }
1: 
0:     /**
0:      * sets the LDAP search filter as defined in RFC 2254
0:      *
0:      * @param searchFilter LDAP search filter
0:      * @see <a href="http://www.faqs.org/rfcs/rfc2254.html">RFC 2254</a>
0:      */
0:     public void setSearchFilter(String searchFilter) {
0:         ldapSearchFilter = "(&" + REQUIRED_OBJECT_CLASS_FILTER + "(" + searchFilter + "))";
0:     }
1: 
0:     /**
0:      * start the connector
0:      */
0:     // XXX: this method seems awfully redundant when looking through the
0:     //      call stack when used in NetworkConnector based objects. I don't
0:     //      see why derived classes shouldn't just override the start/stop methods
0:     protected void handleStart() throws Exception {
0:         initLdapContext();
0:         for(URI uri : getLdapUris()) {
0:             NetworkConnector connector = getBrokerService().addNetworkConnector(uri);
0:             connector.start();
0:             connectors.add(connector);
0:         }
0:         super.handleStart();
0:     }
1: 
0:     /**
0:      * stop the connector
0:      *
0:      * @param stopper service stopper object
0:      */
0:     // XXX: this method seems awfully redundant when looking through the
0:     //      call stack when used in NetworkConnector based objects. I don't
0:     //      see why derived classes shouldn't just override the start/stop methods
0:     protected void handleStop(ServiceStopper stopper) throws Exception {
0:         for(NetworkConnector connector : connectors) {
0:             getBrokerService().removeNetworkConnector(connector);
0:             connector.stop();
0:         }
0:         ldapContext.close();
0:         super.handleStop(stopper);
0:     }
1: 
0:     /**
0:      * returns the name of the connector
0:      *
0:      * @return connector name
0:      */
0:     // XXX: this should probably be fixed elsewhere for all
0:     //      NetworkConnector derivatives...this impl does not
0:     //      seem to be well thought out?
0:     public String getName() {
0:         return toString();
0:     }
1: 
0:     /**
0:      * initializes the LDAP JNDI context with the configured parameters
0:      */
0:     protected void initLdapContext() throws Exception {
0:         Hashtable env = new Hashtable();
0:         env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
0:         env.put(Context.PROVIDER_URL,            ldapURI.toString());
0:         env.put(Context.SECURITY_PRINCIPAL,      ldapUser);
0:         env.put(Context.SECURITY_CREDENTIALS,    ldapPassword);
0:         ldapContext = new InitialDirContext(env);
0:     }
1: 
0:     /**
0:      * retrieves URIs matching the search filter via LDAP 
0:      * and creates network connectors based on the entries
0:      *
0:      * @returns list of retrieved URIs
0:      */
0:     protected List<URI> getLdapUris() throws Exception {
0:         SearchControls controls = new SearchControls();
0:         controls.setSearchScope(ldapSearchScope);
0:         NamingEnumeration<SearchResult> results = ldapContext.search(ldapBase, ldapSearchFilter, controls);
1: 
0:         List<URI> uriList = new ArrayList();
0:         while(results.hasMore()) {
0:             Attributes attributes = results.next().getAttributes();
0:             String address  = (String)attributes.get("iphostnumber").get();
0:             String port     = (String)attributes.get("ipserviceport").get();
0:             String protocol = (String)attributes.get("ipserviceprotocol").get();
0:             URI uri = new URI("static:(" + protocol + "://" + address + ":" + port + ")");
0:             LOG.info("Discovered URI " + uri);
0:             uriList.add(uri);
0:         }
0:         return uriList;
0:     }
0: }
============================================================================