1:d29ca2a: /**
1:7f883f6:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7f883f6:  * contributor license agreements.  See the NOTICE file distributed with
1:7f883f6:  * this work for additional information regarding copyright ownership.
1:7f883f6:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7f883f6:  * (the "License"); you may not use this file except in compliance with
1:7f883f6:  * the License.  You may obtain a copy of the License at
3:7f883f6:  *
1:230a86c:  *      http://www.apache.org/licenses/LICENSE-2.0
1:b0c2a40:  *
1:7f883f6:  * Unless required by applicable law or agreed to in writing, software
1:7f883f6:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7f883f6:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7f883f6:  * See the License for the specific language governing permissions and
1:7f883f6:  * limitations under the License.
1:d29ca2a:  */
1:d29ca2a: package org.apache.activemq.broker.jmx;
1:230a86c: 
1:d29ca2a: import java.io.IOException;
1:688c4f7: import java.lang.reflect.Method;
1:5b5bc45: import java.rmi.NoSuchObjectException;
1:d29ca2a: import java.rmi.registry.LocateRegistry;
1:688c4f7: import java.rmi.registry.Registry;
1:5b5bc45: import java.rmi.server.UnicastRemoteObject;
1:928e815: import java.util.LinkedList;
1:d29ca2a: import java.util.List;
1:688c4f7: import java.util.Map;
1:688c4f7: import java.util.Set;
1:688c4f7: import java.util.concurrent.ConcurrentHashMap;
1:5e656d3: import java.util.concurrent.CountDownLatch;
1:5e656d3: import java.util.concurrent.TimeUnit;
1:74a7a8b: import java.util.concurrent.atomic.AtomicBoolean;
1:5b5bc45: 
1:d29ca2a: import javax.management.Attribute;
1:688c4f7: import javax.management.InstanceNotFoundException;
1:d29ca2a: import javax.management.JMException;
1:d29ca2a: import javax.management.MBeanServer;
1:d29ca2a: import javax.management.MBeanServerFactory;
1:688c4f7: import javax.management.MBeanServerInvocationHandler;
1:d29ca2a: import javax.management.MalformedObjectNameException;
1:688c4f7: import javax.management.ObjectInstance;
1:d29ca2a: import javax.management.ObjectName;
1:688c4f7: import javax.management.QueryExp;
1:d29ca2a: import javax.management.remote.JMXConnectorServer;
1:d29ca2a: import javax.management.remote.JMXConnectorServerFactory;
1:d29ca2a: import javax.management.remote.JMXServiceURL;
1:74a7a8b: 
1:d29ca2a: import org.apache.activemq.Service;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:eea9fca: import org.slf4j.MDC;
1:74a7a8b: 
1:d29ca2a: /**
1:814c49f:  * An abstraction over JMX mbean registration
1:5b5bc45:  *
1:68d245f:  * @org.apache.xbean.XBean
1:5b5bc45:  *
1:d29ca2a:  */
1:230a86c: public class ManagementContext implements Service {
1:5b5bc45: 
1:d29ca2a:     /**
1:d29ca2a:      * Default activemq domain
1:d29ca2a:      */
1:230a86c:     public static final String DEFAULT_DOMAIN = "org.apache.activemq";
1:5b5bc45: 
1:84c1419:     static {
1:9d98ee2:         String option = Boolean.FALSE.toString();
1:84c1419:         try {
1:9d98ee2:             option = System.getProperty("org.apache.activemq.broker.jmx.createConnector", "false");
1:84c1419:         } catch (Exception ex) {
1:84c1419:         }
1:84c1419: 
1:84c1419:         DEFAULT_CREATE_CONNECTOR = Boolean.valueOf(option);
1:84c1419:     }
1:84c1419: 
1:84c1419:     public static final boolean DEFAULT_CREATE_CONNECTOR;
1:84c1419: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(ManagementContext.class);
1:d29ca2a:     private MBeanServer beanServer;
1:230a86c:     private String jmxDomainName = DEFAULT_DOMAIN;
1:230a86c:     private boolean useMBeanServer = true;
1:230a86c:     private boolean createMBeanServer = true;
1:230a86c:     private boolean locallyCreateMBeanServer;
1:84c1419:     private boolean createConnector = DEFAULT_CREATE_CONNECTOR;
1:76d9fcc:     private boolean findTigerMbeanServer = true;
1:dab6924:     private String connectorHost = "localhost";
1:230a86c:     private int connectorPort = 1099;
1:5b5bc45:     private Map<String, ?> environment;
1:1ad52f4:     private int rmiServerPort;
1:230a86c:     private String connectorPath = "/jmxrmi";
1:c7c8e53:     private final AtomicBoolean started = new AtomicBoolean(false);
1:5e656d3:     private final CountDownLatch connectorStarted = new CountDownLatch(1);
1:d29ca2a:     private JMXConnectorServer connectorServer;
1:d29ca2a:     private ObjectName namingServiceObjectName;
1:62e1abf:     private Registry registry;
1:eea45cc:     private final Map<ObjectName, ObjectName> registeredMBeanNames = new ConcurrentHashMap<ObjectName, ObjectName>();
1:c051381:     private boolean allowRemoteAddressInMBeanNames = true;
1:eea9fca:     private String brokerName;
1:928e815:     private String suppressMBean;
1:13c471c:     private List<ObjectName> suppressMBeanList;
1:d29ca2a: 
1:230a86c:     public ManagementContext() {
1:d29ca2a:         this(null);
1:86cbdfd:     }
1:d29ca2a: 
1:230a86c:     public ManagementContext(MBeanServer server) {
1:230a86c:         this.beanServer = server;
1:d29ca2a:     }
1:d29ca2a: 
1:928e815:     @Override
1:13c471c:     public void start() throws Exception {
1:d29ca2a:         // lets force the MBeanServer to be created if needed
1:6ce0aaa:         if (started.compareAndSet(false, true)) {
1:928e815: 
1:928e815:             populateMBeanSuppressionMap();
1:928e815: 
1:688c4f7:             // fallback and use localhost
1:688c4f7:             if (connectorHost == null) {
1:688c4f7:                 connectorHost = "localhost";
1:928e815:             }
1:928e815: 
1:f272fc1:             // force mbean server to be looked up, so we have it
1:d29ca2a:             getMBeanServer();
1:d29ca2a: 
1:6ce0aaa:             if (connectorServer != null) {
1:71d5fef:                 try {
1:f272fc1:                     if (getMBeanServer().isRegistered(namingServiceObjectName)) {
1:f272fc1:                         LOG.debug("Invoking start on mbean: {}", namingServiceObjectName);
1:d29ca2a:                         getMBeanServer().invoke(namingServiceObjectName, "start", null, null);
1:d29ca2a:                     }
1:230a86c:                 } catch (Throwable ignore) {
1:e1bbde7:                     LOG.debug("Error invoking start on MBean {}. This exception is ignored.", namingServiceObjectName, ignore);
1:d29ca2a:                 }
1:d29ca2a: 
1:d29ca2a:                 Thread t = new Thread("JMX connector") {
1:928e815:                     @Override
1:d29ca2a:                     public void run() {
1:eea9fca:                         // ensure we use MDC logging with the broker name, so people can see the logs if MDC was in use
1:eea9fca:                         if (brokerName != null) {
1:eea9fca:                             MDC.put("activemq.broker", brokerName);
1:688c4f7:                         }
1:d29ca2a:                         try {
1:6ce0aaa:                             JMXConnectorServer server = connectorServer;
1:6ce0aaa:                             if (started.get() && server != null) {
1:814c49f:                                 LOG.debug("Starting JMXConnectorServer...");
1:d29ca2a:                                 try {
1:eea9fca:                                     // need to remove MDC as we must not inherit MDC in child threads causing leaks
1:eea9fca:                                     MDC.remove("activemq.broker");
1:5b5bc45:                                     server.start();
1:c9ca34a:                                 } finally {
1:eea9fca:                                     if (brokerName != null) {
1:eea9fca:                                         MDC.put("activemq.broker", brokerName);
1:f272fc1:                                     }
1:5e656d3:                                     connectorStarted.countDown();
1:eea9fca:                                 }
1:e1bbde7:                                 LOG.info("JMX consoles can connect to {}", server.getAddress());
1:eea9fca:                             }
1:71d5fef:                         } catch (IOException e) {
1:e1bbde7:                             LOG.warn("Failed to start JMX connector {}. Will restart management to re-create JMX connector, trying to remedy this issue.", e.getMessage());
1:e1bbde7:                             LOG.debug("Reason for failed JMX connector start", e);
1:eea9fca:                         } finally {
1:eea9fca:                             MDC.remove("activemq.broker");
1:d29ca2a:                         }
1:d29ca2a:                     }
1:d29ca2a:                 };
1:d29ca2a:                 t.setDaemon(true);
1:d29ca2a:                 t.start();
1:d29ca2a:             }
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:13c471c:     private void populateMBeanSuppressionMap() throws Exception {
1:928e815:         if (suppressMBean != null) {
1:928e815:             suppressMBeanList = new LinkedList<>();
1:928e815:             for (String pair : suppressMBean.split(",")) {
1:13c471c:                 suppressMBeanList.add(new ObjectName(jmxDomainName + ":*," + pair));
1:928e815:             }
1:928e815:         }
1:928e815:     }
1:928e815: 
1:928e815:     @Override
1:1ec71bd:     public void stop() throws Exception {
1:6ce0aaa:         if (started.compareAndSet(true, false)) {
1:1ec71bd:             MBeanServer mbeanServer = getMBeanServer();
1:d29ca2a: 
1:eea45cc:             // unregister the mbeans we have registered
1:1ec71bd:             if (mbeanServer != null) {
1:eea45cc:                 for (Map.Entry<ObjectName, ObjectName> entry : registeredMBeanNames.entrySet()) {
1:eea45cc:                     ObjectName actualName = entry.getValue();
1:eea45cc:                     if (actualName != null && beanServer.isRegistered(actualName)) {
1:eea45cc:                         LOG.debug("Unregistering MBean {}", actualName);
1:eea45cc:                         mbeanServer.unregisterMBean(actualName);
1:eea45cc:                     }
1:eea9fca:                 }
1:c9ca34a:             }
1:1ec71bd:             registeredMBeanNames.clear();
1:d29ca2a: 
1:6ce0aaa:             JMXConnectorServer server = connectorServer;
1:6ce0aaa:             connectorServer = null;
1:6ce0aaa:             if (server != null) {
1:d29ca2a:                 try {
1:5e656d3:                     if (connectorStarted.await(10, TimeUnit.SECONDS)) {
1:3092051:                         LOG.debug("Stopping jmx connector");
1:3092051:                         server.stop();
1:5b5bc45:                     }
1:230a86c:                 } catch (IOException e) {
1:e1bbde7:                     LOG.warn("Failed to stop jmx connector: {}", e.getMessage());
1:c9ca34a:                 }
1:3092051:                 // stop naming service mbean
1:d29ca2a:                 try {
1:ece2e17:                     if (namingServiceObjectName != null && getMBeanServer().isRegistered(namingServiceObjectName)) {
1:3092051:                         LOG.debug("Stopping MBean {}", namingServiceObjectName);
1:d29ca2a:                         getMBeanServer().invoke(namingServiceObjectName, "stop", null, null);
1:3092051:                         LOG.debug("Unregistering MBean {}", namingServiceObjectName);
1:3092051:                         getMBeanServer().unregisterMBean(namingServiceObjectName);
1:d29ca2a:                     }
1:230a86c:                 } catch (Throwable ignore) {
1:e1bbde7:                     LOG.warn("Error stopping and unregsitering MBean {} due to {}", namingServiceObjectName, ignore.getMessage());
1:d29ca2a:                 }
1:3092051:                 namingServiceObjectName = null;
1:3092051:             }
1:5b5bc45: 
1:d29ca2a:             if (locallyCreateMBeanServer && beanServer != null) {
1:d29ca2a:                 // check to see if the factory knows about this server
1:5b5bc45:                 List<MBeanServer> list = MBeanServerFactory.findMBeanServer(null);
1:d29ca2a:                 if (list != null && !list.isEmpty() && list.contains(beanServer)) {
1:f272fc1:                     LOG.debug("Releasing MBeanServer {}", beanServer);
1:d29ca2a:                     MBeanServerFactory.releaseMBeanServer(beanServer);
1:d29ca2a:                 }
1:d29ca2a:             }
1:62e1abf:             beanServer = null;
1:71d5fef:         }
1:d29ca2a: 
1:5b5bc45:         // Un-export JMX RMI registry, if it was created
1:5b5bc45:         if (registry != null) {
1:5b5bc45:             try {
1:5b5bc45:                 UnicastRemoteObject.unexportObject(registry, true);
1:5b5bc45:                 LOG.debug("Unexported JMX RMI Registry");
1:5b5bc45:             } catch (NoSuchObjectException e) {
1:5b5bc45:                 LOG.debug("Error occurred while unexporting JMX RMI registry. This exception will be ignored.");
1:5b5bc45:             }
1:5b5bc45: 
1:5b5bc45:             registry = null;
1:5b5bc45:         }
1:71d5fef:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:eea9fca:      * Gets the broker name this context is used by, may be <tt>null</tt>
1:eea9fca:      * if the broker name was not set.
1:eea9fca:      */
1:eea9fca:     public String getBrokerName() {
1:eea9fca:         return brokerName;
1:d29ca2a:     }
1:d29ca2a: 
1:eea9fca:     /**
1:eea9fca:      * Sets the broker name this context is being used by.
1:eea9fca:      */
1:eea9fca:     public void setBrokerName(String brokerName) {
1:eea9fca:         this.brokerName = brokerName;
1:f272fc1:     }
1:d29ca2a: 
1:eea9fca:     /**
1:d29ca2a:      * @return Returns the jmxDomainName.
1:d29ca2a:      */
1:230a86c:     public String getJmxDomainName() {
1:d29ca2a:         return jmxDomainName;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * @param jmxDomainName The jmxDomainName to set.
1:d29ca2a:      */
1:230a86c:     public void setJmxDomainName(String jmxDomainName) {
1:230a86c:         this.jmxDomainName = jmxDomainName;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Get the MBeanServer
1:5b5bc45:      *
1:d29ca2a:      * @return the MBeanServer
1:d29ca2a:      */
1:13c471c:     public MBeanServer getMBeanServer() {
1:230a86c:         if (this.beanServer == null) {
1:230a86c:             this.beanServer = findMBeanServer();
1:d29ca2a:         }
1:d29ca2a:         return beanServer;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:4d9ab0c:      * Set the MBeanServer
1:5b5bc45:      *
1:4d9ab0c:      * @param beanServer
1:4d9ab0c:      */
1:230a86c:     public void setMBeanServer(MBeanServer beanServer) {
1:230a86c:         this.beanServer = beanServer;
1:f272fc1:     }
1:d29ca2a: 
1:b3873fb:     /**
1:d29ca2a:      * @return Returns the useMBeanServer.
1:d29ca2a:      */
1:230a86c:     public boolean isUseMBeanServer() {
1:d29ca2a:         return useMBeanServer;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * @param useMBeanServer The useMBeanServer to set.
1:d29ca2a:      */
1:230a86c:     public void setUseMBeanServer(boolean useMBeanServer) {
1:230a86c:         this.useMBeanServer = useMBeanServer;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @return Returns the createMBeanServer flag.
1:d29ca2a:      */
1:230a86c:     public boolean isCreateMBeanServer() {
1:d29ca2a:         return createMBeanServer;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:230a86c:      * @param enableJMX Set createMBeanServer.
1:d29ca2a:      */
1:230a86c:     public void setCreateMBeanServer(boolean enableJMX) {
1:230a86c:         this.createMBeanServer = enableJMX;
1:d29ca2a:     }
1:d29ca2a: 
1:d680ba1:     public boolean isFindTigerMbeanServer() {
1:d680ba1:         return findTigerMbeanServer;
1:d29ca2a:     }
1:d29ca2a: 
1:b3873fb:     public boolean isConnectorStarted() {
1:5e656d3:         return connectorStarted.getCount() == 0 || (connectorServer != null && connectorServer.isActive());
1:5b5bc45:     }
1:d29ca2a: 
1:5b5bc45:     /**
1:d680ba1:      * Enables/disables the searching for the Java 5 platform MBeanServer
1:d680ba1:      */
1:d680ba1:     public void setFindTigerMbeanServer(boolean findTigerMbeanServer) {
1:d680ba1:         this.findTigerMbeanServer = findTigerMbeanServer;
1:eea9fca:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * Formulate and return the MBean ObjectName of a custom control MBean
1:5b5bc45:      *
1:d29ca2a:      * @param type
1:d29ca2a:      * @param name
1:230a86c:      * @return the JMX ObjectName of the MBean, or <code>null</code> if
1:230a86c:      *         <code>customName</code> is invalid.
1:d29ca2a:      */
1:230a86c:     public ObjectName createCustomComponentMBeanName(String type, String name) {
1:230a86c:         ObjectName result = null;
1:230a86c:         String tmp = jmxDomainName + ":" + "type=" + sanitizeString(type) + ",name=" + sanitizeString(name);
1:230a86c:         try {
1:230a86c:             result = new ObjectName(tmp);
1:230a86c:         } catch (MalformedObjectNameException e) {
1:e1bbde7:             LOG.error("Couldn't create ObjectName from: {}, {}", type, name);
1:d29ca2a:         }
1:d29ca2a:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * The ':' and '/' characters are reserved in ObjectNames
1:5b5bc45:      *
1:d29ca2a:      * @param in
1:d29ca2a:      * @return sanitized String
1:d29ca2a:      */
1:230a86c:     private static String sanitizeString(String in) {
1:230a86c:         String result = null;
1:230a86c:         if (in != null) {
1:230a86c:             result = in.replace(':', '_');
1:230a86c:             result = result.replace('/', '_');
1:230a86c:             result = result.replace('\\', '_');
1:d29ca2a:         }
1:d29ca2a:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5b5bc45:      * Retrieve an System ObjectName
1:5b5bc45:      *
1:d29ca2a:      * @param domainName
1:d29ca2a:      * @param containerName
1:d29ca2a:      * @param theClass
1:d29ca2a:      * @return the ObjectName
1:d29ca2a:      * @throws MalformedObjectNameException
1:d29ca2a:      */
1:5b5bc45:     public static ObjectName getSystemObjectName(String domainName, String containerName, Class<?> theClass) throws MalformedObjectNameException, NullPointerException {
1:230a86c:         String tmp = domainName + ":" + "type=" + theClass.getName() + ",name=" + getRelativeName(containerName, theClass);
1:d29ca2a:         return new ObjectName(tmp);
1:d29ca2a:     }
1:d29ca2a: 
1:5b5bc45:     private static String getRelativeName(String containerName, Class<?> theClass) {
1:230a86c:         String name = theClass.getName();
1:230a86c:         int index = name.lastIndexOf(".");
1:230a86c:         if (index >= 0 && (index + 1) < name.length()) {
1:230a86c:             name = name.substring(index + 1);
1:d29ca2a:         }
1:230a86c:         return containerName + "." + name;
1:d29ca2a:     }
1:5b5bc45: 
1:5b5bc45:     public Object newProxyInstance(ObjectName objectName, Class<?> interfaceClass, boolean notificationBroadcaster){
1:1ec71bd:         return MBeanServerInvocationHandler.newProxyInstance(getMBeanServer(), objectName, interfaceClass, notificationBroadcaster);
1:b3873fb:     }
1:5b5bc45: 
1:1ec71bd:     public Object getAttribute(ObjectName name, String attribute) throws Exception{
1:1ec71bd:         return getMBeanServer().getAttribute(name, attribute);
1:f1fa8f9:     }
1:5b5bc45: 
1:1ec71bd:     public ObjectInstance registerMBean(Object bean, ObjectName name) throws Exception{
1:928e815:         ObjectInstance result = null;
1:928e815:         if (isAllowedToRegister(name)) {
1:928e815:             result = getMBeanServer().registerMBean(bean, name);
1:928e815:             this.registeredMBeanNames.put(name, result.getObjectName());
1:928e815:         }
1:928e815:         return result;
1:928e815:     }
1:928e815: 
1:4997427:     protected boolean isAllowedToRegister(ObjectName name) {
1:928e815:         boolean result = true;
1:928e815:         if (suppressMBean != null && suppressMBeanList != null) {
1:13c471c:             for (ObjectName attr : suppressMBeanList) {
1:13c471c:                 if (attr.apply(name)) {
1:928e815:                     result = false;
1:928e815:                     break;
1:928e815:                 }
1:928e815:             }
1:928e815:         }
1:f1fa8f9:         return result;
1:dab6924:     }
1:5b5bc45: 
1:eea45cc:     public Set<ObjectName> queryNames(ObjectName name, QueryExp query) throws Exception{
1:5b5bc45:         if (name != null) {
1:5b5bc45:             ObjectName actualName = this.registeredMBeanNames.get(name);
1:5b5bc45:             if (actualName != null) {
1:5b5bc45:                 return getMBeanServer().queryNames(actualName, query);
1:5b5bc45:             }
1:eea45cc:         }
1:ac4545b:         return getMBeanServer().queryNames(name, query);
1:eea45cc:     }
1:5b5bc45: 
1:55794fe:     public ObjectInstance getObjectInstance(ObjectName name) throws InstanceNotFoundException {
1:c7c8e53:         return getMBeanServer().getObjectInstance(name);
1:c7c8e53:     }
1:5b5bc45: 
1:d29ca2a:     /**
1:d29ca2a:      * Unregister an MBean
1:5b5bc45:      *
1:d29ca2a:      * @param name
1:d29ca2a:      * @throws JMException
1:d29ca2a:      */
1:230a86c:     public void unregisterMBean(ObjectName name) throws JMException {
1:eea45cc:         ObjectName actualName = this.registeredMBeanNames.get(name);
1:eea45cc:         if (beanServer != null && actualName != null && beanServer.isRegistered(actualName) && this.registeredMBeanNames.remove(name) != null) {
1:eea45cc:             LOG.debug("Unregistering MBean {}", actualName);
1:eea45cc:             beanServer.unregisterMBean(actualName);
1:d29ca2a:         }
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     protected synchronized MBeanServer findMBeanServer() {
1:230a86c:         MBeanServer result = null;
1:5b5bc45: 
1:230a86c:         try {
1:230a86c:             if (useMBeanServer) {
1:d680ba1:                 if (findTigerMbeanServer) {
1:d680ba1:                     result = findTigerMBeanServer();
1:ac4545b:                 }
1:d680ba1:                 if (result == null) {
1:5b5bc45:                     // lets piggy back on another MBeanServer - we could be in an appserver!
1:5b5bc45:                     List<MBeanServer> list = MBeanServerFactory.findMBeanServer(null);
1:230a86c:                     if (list != null && list.size() > 0) {
1:5b5bc45:                         result = list.get(0);
1:d29ca2a:                     }
1:d29ca2a:                 }
1:d29ca2a:             }
1:d29ca2a:             if (result == null && createMBeanServer) {
1:d29ca2a:                 result = createMBeanServer();
1:d29ca2a:             }
1:230a86c:         } catch (NoClassDefFoundError e) {
1:230a86c:             LOG.error("Could not load MBeanServer", e);
1:230a86c:         } catch (Throwable e) {
1:d29ca2a:             // probably don't have access to system properties
1:230a86c:             LOG.error("Failed to initialize MBeanServer", e);
1:d29ca2a:         }
1:d29ca2a:         return result;
1:d29ca2a:     }
1:d29ca2a: 
1:76d9fcc:     public MBeanServer findTigerMBeanServer() {
1:d680ba1:         String name = "java.lang.management.ManagementFactory";
1:5b5bc45:         Class<?> type = loadClass(name, ManagementContext.class.getClassLoader());
1:d680ba1:         if (type != null) {
1:d29ca2a:             try {
1:d680ba1:                 Method method = type.getMethod("getPlatformMBeanServer", new Class[0]);
1:d680ba1:                 if (method != null) {
1:d680ba1:                     Object answer = method.invoke(null, new Object[0]);
1:d680ba1:                     if (answer instanceof MBeanServer) {
1:5b5bc45:                         if (createConnector) {
1:5b5bc45:                             createConnector((MBeanServer)answer);
1:5b5bc45:                         }
1:230a86c:                         return (MBeanServer)answer;
1:230a86c:                     } else {
1:e1bbde7:                         LOG.warn("Could not cast: {} into an MBeanServer. There must be some classloader strangeness in town", answer);
1:d29ca2a:                     }
1:230a86c:                 } else {
1:e1bbde7:                     LOG.warn("Method getPlatformMBeanServer() does not appear visible on type: {}", type.getName());
1:76d9fcc:                 }
1:230a86c:             } catch (Exception e) {
1:e1bbde7:                 LOG.warn("Failed to call getPlatformMBeanServer() due to: ", e);
1:1ec71bd:             }
1:230a86c:         } else {
1:e1bbde7:             LOG.trace("Class not found: {} so probably running on Java 1.4", name);
1:1ec71bd:         }
1:928e815:         return null;
1:928e815:     }
1:d29ca2a: 
1:5b5bc45:     private static Class<?> loadClass(String name, ClassLoader loader) {
1:d29ca2a:         try {
1:d680ba1:             return loader.loadClass(name);
1:230a86c:         } catch (ClassNotFoundException e) {
1:d29ca2a:             try {
1:d680ba1:                 return Thread.currentThread().getContextClassLoader().loadClass(name);
1:230a86c:             } catch (ClassNotFoundException e1) {
2:d680ba1:                 return null;
1:928e815:             }
1:1ec71bd:         }
1:1ec71bd:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:5e05df1:      * @return an MBeanServer instance
1:d29ca2a:      * @throws NullPointerException
1:d29ca2a:      * @throws MalformedObjectNameException
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:230a86c:     protected MBeanServer createMBeanServer() throws MalformedObjectNameException, IOException {
1:230a86c:         MBeanServer mbeanServer = MBeanServerFactory.createMBeanServer(jmxDomainName);
1:230a86c:         locallyCreateMBeanServer = true;
1:230a86c:         if (createConnector) {
1:d29ca2a:             createConnector(mbeanServer);
1:d29ca2a:         }
1:d29ca2a:         return mbeanServer;
1:d29ca2a:     }
1:d29ca2a: 
1:d29ca2a:     /**
1:d29ca2a:      * @param mbeanServer
1:d29ca2a:      * @throws MalformedObjectNameException
1:d29ca2a:      * @throws IOException
1:d29ca2a:      */
1:f272fc1:     private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {
1:d29ca2a:         // Create the NamingService, needed by JSR 160
1:230a86c:         try {
1:62e1abf:             if (registry == null) {
1:688c4f7:                 LOG.debug("Creating RMIRegistry on port {}", connectorPort);
1:688c4f7:                 registry = LocateRegistry.createRegistry(connectorPort);
1:62e1abf:             }
1:230a86c:             namingServiceObjectName = ObjectName.getInstance("naming:type=rmiregistry");
1:71d5fef: 
1:c5f96e1:             // Do not use the createMBean as the mx4j jar may not be in the
1:d29ca2a:             // same class loader than the server
1:5b5bc45:             Class<?> cl = Class.forName("mx4j.tools.naming.NamingService");
1:230a86c:             mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);
1:5b5bc45: 
1:d29ca2a:             // set the naming port
1:230a86c:             Attribute attr = new Attribute("Port", Integer.valueOf(connectorPort));
1:230a86c:             mbeanServer.setAttribute(namingServiceObjectName, attr);
1:16b4009:         } catch(ClassNotFoundException e) {
1:e1bbde7:             LOG.debug("Probably not using JRE 1.4: {}", e.getLocalizedMessage());
1:230a86c:         } catch (Throwable e) {
1:3092051:             LOG.debug("Failed to create local registry. This exception will be ignored.", e);
1:d29ca2a:         }
1:5b5bc45: 
1:d29ca2a:         // Create the JMXConnectorServer
1:230a86c:         String rmiServer = "";
1:230a86c:         if (rmiServerPort != 0) {
1:5b5bc45:             // This is handy to use if you have a firewall and need to force JMX to use fixed ports.
1:dab6924:             rmiServer = ""+getConnectorHost()+":" + rmiServerPort;
1:230a86c:         }
1:dab6924:         String serviceURL = "service:jmx:rmi://" + rmiServer + "/jndi/rmi://" +getConnectorHost()+":" + connectorPort + connectorPath;
1:230a86c:         JMXServiceURL url = new JMXServiceURL(serviceURL);
1:fe3660d:         connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, environment, mbeanServer);
1:d29ca2a: 
1:3092051:         LOG.debug("Created JMXConnectorServer {}", connectorServer);
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public String getConnectorPath() {
1:d29ca2a:         return connectorPath;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public void setConnectorPath(String connectorPath) {
1:230a86c:         this.connectorPath = connectorPath;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public int getConnectorPort() {
1:d29ca2a:         return connectorPort;
1:d29ca2a:     }
1:d29ca2a: 
1:5edede1:     /**
1:5edede1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryIntPropertyEditor"
1:5edede1:      */
1:230a86c:     public void setConnectorPort(int connectorPort) {
1:230a86c:         this.connectorPort = connectorPort;
1:d29ca2a:     }
1:d29ca2a: 
1:230a86c:     public int getRmiServerPort() {
1:1ad52f4:         return rmiServerPort;
1:1ec71bd:     }
1:d29ca2a: 
1:5edede1:     /**
1:5edede1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryIntPropertyEditor"
1:5edede1:      */
1:230a86c:     public void setRmiServerPort(int rmiServerPort) {
1:230a86c:         this.rmiServerPort = rmiServerPort;
1:16b4009:     }
1:d29ca2a: 
1:230a86c:     public boolean isCreateConnector() {
1:d29ca2a:         return createConnector;
1:d29ca2a:     }
1:d29ca2a: 
1:c0c9259:     /**
1:c0c9259:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:c0c9259:      */
1:230a86c:     public void setCreateConnector(boolean createConnector) {
1:230a86c:         this.createConnector = createConnector;
1:d29ca2a:     }
1:d29ca2a: 
1:dab6924:     /**
1:dab6924:      * Get the connectorHost
1:dab6924:      * @return the connectorHost
1:dab6924:      */
1:dab6924:     public String getConnectorHost() {
1:dab6924:         return this.connectorHost;
1:d29ca2a:     }
1:d29ca2a: 
1:dab6924:     /**
1:dab6924:      * Set the connectorHost
1:dab6924:      * @param connectorHost the connectorHost to set
1:dab6924:      */
1:dab6924:     public void setConnectorHost(String connectorHost) {
1:dab6924:         this.connectorHost = connectorHost;
1:dab6924:     }
1:d29ca2a: 
1:5b5bc45:     public Map<String, ?> getEnvironment() {
1:fe3660d:         return environment;
1:fe3660d:     }
1:688c4f7: 
1:5b5bc45:     public void setEnvironment(Map<String, ?> environment) {
1:fe3660d:         this.environment = environment;
1:fe3660d:     }
1:688c4f7: 
1:c051381:     public boolean isAllowRemoteAddressInMBeanNames() {
1:c051381:         return allowRemoteAddressInMBeanNames;
1:c051381:     }
1:688c4f7: 
1:c051381:     public void setAllowRemoteAddressInMBeanNames(boolean allowRemoteAddressInMBeanNames) {
1:c051381:         this.allowRemoteAddressInMBeanNames = allowRemoteAddressInMBeanNames;
1:c051381:     }
1:928e815: 
1:928e815:     /**
1:928e815:      * Allow selective MBeans registration to be suppressed. Any Mbean ObjectName that matches any
1:928e815:      * of the supplied attribute values will not be registered with the MBeanServer.
1:928e815:      * eg: "endpoint=dynamicProducer,endpoint=Consumer" will suppress the registration of *all* dynamic producer and consumer mbeans.
1:928e815:      *
1:928e815:      * @param commaListOfAttributeKeyValuePairs  the comma separated list of attribute key=value pairs to match.
1:928e815:      */
1:928e815:     public void setSuppressMBean(String commaListOfAttributeKeyValuePairs) {
1:928e815:         this.suppressMBean = commaListOfAttributeKeyValuePairs;
1:928e815:     }
1:928e815: 
1:928e815:     public String getSuppressMBean() {
1:928e815:         return suppressMBean;
1:928e815:     }
5:c5f96e1: }
============================================================================
author:gtully
-------------------------------------------------------------------------------
commit:9d98ee2
/////////////////////////////////////////////////////////////////////////
1:         String option = Boolean.FALSE.toString();
1:             option = System.getProperty("org.apache.activemq.broker.jmx.createConnector", "false");
commit:928e815
/////////////////////////////////////////////////////////////////////////
1: import java.util.LinkedList;
/////////////////////////////////////////////////////////////////////////
1:     private String suppressMBean;
0:     private List<Map.Entry<String,String>> suppressMBeanList;
/////////////////////////////////////////////////////////////////////////
1:             populateMBeanSuppressionMap();
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void populateMBeanSuppressionMap() {
1:         if (suppressMBean != null) {
1:             suppressMBeanList = new LinkedList<>();
1:             for (String pair : suppressMBean.split(",")) {
0:                 final String[] keyValue = pair.split("=");
0:                 suppressMBeanList.add(new Map.Entry<String, String>() {
1:                     @Override
0:                     public String getKey() {
0:                         return keyValue[0];
1:                     }
1: 
1:                     @Override
0:                     public String getValue() {
0:                         return keyValue[1];
1:                     }
1: 
1:                     @Override
0:                     public String setValue(String value) {
1:                         return null;
1:                     }
0:                 });
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         ObjectInstance result = null;
1:         if (isAllowedToRegister(name)) {
1:             result = getMBeanServer().registerMBean(bean, name);
1:             this.registeredMBeanNames.put(name, result.getObjectName());
1:         }
1:         return result;
1:     }
1: 
0:     private boolean isAllowedToRegister(ObjectName name) {
1:         boolean result = true;
1:         if (suppressMBean != null && suppressMBeanList != null) {
0:             for (Map.Entry<String,String> attr : suppressMBeanList) {
0:                 if (attr.getValue().equals(name.getKeyProperty(attr.getKey()))) {
1:                     result = false;
1:                     break;
1:                 }
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Allow selective MBeans registration to be suppressed. Any Mbean ObjectName that matches any
1:      * of the supplied attribute values will not be registered with the MBeanServer.
1:      * eg: "endpoint=dynamicProducer,endpoint=Consumer" will suppress the registration of *all* dynamic producer and consumer mbeans.
1:      *
1:      * @param commaListOfAttributeKeyValuePairs  the comma separated list of attribute key=value pairs to match.
1:      */
1:     public void setSuppressMBean(String commaListOfAttributeKeyValuePairs) {
1:         this.suppressMBean = commaListOfAttributeKeyValuePairs;
1:     }
1: 
1:     public String getSuppressMBean() {
1:         return suppressMBean;
1:     }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:5e656d3
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
1: import java.util.concurrent.TimeUnit;
/////////////////////////////////////////////////////////////////////////
1:     private final CountDownLatch connectorStarted = new CountDownLatch(1);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                     connectorStarted.countDown();
/////////////////////////////////////////////////////////////////////////
1:                     if (connectorStarted.await(10, TimeUnit.SECONDS)) {
/////////////////////////////////////////////////////////////////////////
1:         return connectorStarted.getCount() == 0 || (connectorServer != null && connectorServer.isActive());
commit:13c471c
/////////////////////////////////////////////////////////////////////////
1:     private List<ObjectName> suppressMBeanList;
/////////////////////////////////////////////////////////////////////////
1:     public void start() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     private void populateMBeanSuppressionMap() throws Exception {
1:                 suppressMBeanList.add(new ObjectName(jmxDomainName + ":*," + pair));
/////////////////////////////////////////////////////////////////////////
1:     public MBeanServer getMBeanServer() {
/////////////////////////////////////////////////////////////////////////
1:             for (ObjectName attr : suppressMBeanList) {
1:                 if (attr.apply(name)) {
author:Jeff Genender
-------------------------------------------------------------------------------
commit:4997427
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isAllowedToRegister(ObjectName name) {
author:Timothy Bish
-------------------------------------------------------------------------------
commit:5e05df1
/////////////////////////////////////////////////////////////////////////
1:      * @return an MBeanServer instance
commit:84c1419
/////////////////////////////////////////////////////////////////////////
1:     static {
0:         String option = Boolean.TRUE.toString();
1:         try {
0:             option = System.getProperty("org.apache.activemq.broker.jmx.createConnector", "true");
1:         } catch (Exception ex) {
1:         }
1: 
1:         DEFAULT_CREATE_CONNECTOR = Boolean.valueOf(option);
1:     }
1: 
1:     public static final boolean DEFAULT_CREATE_CONNECTOR;
1: 
1:     private boolean createConnector = DEFAULT_CREATE_CONNECTOR;
commit:e1bbde7
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Error invoking start on MBean {}. This exception is ignored.", namingServiceObjectName, ignore);
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.info("JMX consoles can connect to {}", server.getAddress());
1:                             LOG.warn("Failed to start JMX connector {}. Will restart management to re-create JMX connector, trying to remedy this issue.", e.getMessage());
1:                             LOG.debug("Reason for failed JMX connector start", e);
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Failed to stop jmx connector: {}", e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                     LOG.warn("Error stopping and unregsitering MBean {} due to {}", namingServiceObjectName, ignore.getMessage());
/////////////////////////////////////////////////////////////////////////
1:             LOG.error("Couldn't create ObjectName from: {}, {}", type, name);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.warn("Could not cast: {} into an MBeanServer. There must be some classloader strangeness in town", answer);
1:                     LOG.warn("Method getPlatformMBeanServer() does not appear visible on type: {}", type.getName());
1:                 LOG.warn("Failed to call getPlatformMBeanServer() due to: ", e);
1:             LOG.trace("Class not found: {} so probably running on Java 1.4", name);
/////////////////////////////////////////////////////////////////////////
1:             LOG.debug("Probably not using JRE 1.4: {}", e.getLocalizedMessage());
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:5b5bc45
/////////////////////////////////////////////////////////////////////////
1: import java.rmi.NoSuchObjectException;
1: import java.rmi.server.UnicastRemoteObject;
1: 
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     private Map<String, ?> environment;
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
1:                                     server.start();
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:                     if (!connectorStarting.get()) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
1:                 List<MBeanServer> list = MBeanServerFactory.findMBeanServer(null);
/////////////////////////////////////////////////////////////////////////
1:         // Un-export JMX RMI registry, if it was created
1:         if (registry != null) {
1:             try {
1:                 UnicastRemoteObject.unexportObject(registry, true);
1:                 LOG.debug("Unexported JMX RMI Registry");
1:             } catch (NoSuchObjectException e) {
1:                 LOG.debug("Error occurred while unexporting JMX RMI registry. This exception will be ignored.");
1:             }
1: 
1:             registry = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
0:         return connectorStarting.get() || (connectorServer != null && connectorServer.isActive());
1:     }
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * Retrieve an System ObjectName
1:      *
1:     public static ObjectName getSystemObjectName(String domainName, String containerName, Class<?> theClass) throws MalformedObjectNameException, NullPointerException {
1:     private static String getRelativeName(String containerName, Class<?> theClass) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Object newProxyInstance(ObjectName objectName, Class<?> interfaceClass, boolean notificationBroadcaster){
1: 
1: 
1: 
1:         if (name != null) {
1:             ObjectName actualName = this.registeredMBeanNames.get(name);
1:             if (actualName != null) {
1:                 return getMBeanServer().queryNames(actualName, query);
1:             }
1: 
1: 
1:      *
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // lets piggy back on another MBeanServer - we could be in an appserver!
1:                     List<MBeanServer> list = MBeanServerFactory.findMBeanServer(null);
1:                         result = list.get(0);
/////////////////////////////////////////////////////////////////////////
1:         Class<?> type = loadClass(name, ManagementContext.class.getClassLoader());
1:                         if (createConnector) {
1:                             createConnector((MBeanServer)answer);
1:                         }
/////////////////////////////////////////////////////////////////////////
1:     private static Class<?> loadClass(String name, ClassLoader loader) {
/////////////////////////////////////////////////////////////////////////
1:             Class<?> cl = Class.forName("mx4j.tools.naming.NamingService");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             // This is handy to use if you have a firewall and need to force JMX to use fixed ports.
/////////////////////////////////////////////////////////////////////////
1:     public Map<String, ?> getEnvironment() {
1:     public void setEnvironment(Map<String, ?> environment) {
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:58aca86
commit:71d5fef
/////////////////////////////////////////////////////////////////////////
0:     private ServerSocket registrySocket;
/////////////////////////////////////////////////////////////////////////
0:             if(registrySocket!=null) {
1:                 try {
0:                     registrySocket.close();
1:                 } catch (IOException e) {
1:                 }
0:                 registrySocket = null;
1:             }
/////////////////////////////////////////////////////////////////////////
0:                         registrySocket = new ServerSocket(port);
0:                         registrySocket.setReuseAddress(true);
0:                         return registrySocket;
1: 
commit:b0c2a40
/////////////////////////////////////////////////////////////////////////
1:  * 
commit:74a7a8b
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:230a86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
/////////////////////////////////////////////////////////////////////////
1: 
1: public class ManagementContext implements Service {
1:     public static final String DEFAULT_DOMAIN = "org.apache.activemq";
0:     private static final Log LOG = LogFactory.getLog(ManagementContext.class);
1:     private String jmxDomainName = DEFAULT_DOMAIN;
1:     private boolean useMBeanServer = true;
1:     private boolean createMBeanServer = true;
1:     private boolean locallyCreateMBeanServer;
0:     private boolean createConnector = true;
0:     private boolean findTigerMbeanServer;
1:     private int connectorPort = 1099;
1:     private String connectorPath = "/jmxrmi";
0:     private AtomicBoolean started = new AtomicBoolean(false);
1:     public ManagementContext() {
1:     public ManagementContext(MBeanServer server) {
1:         this.beanServer = server;
/////////////////////////////////////////////////////////////////////////
1:                 } catch (Throwable ignore) {
/////////////////////////////////////////////////////////////////////////
0:                                 LOG.info("JMX consoles can connect to " + server.getAddress());
1:                         } catch (IOException e) {
0:                             LOG.warn("Failed to start jmx connector: " + e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                 } catch (IOException e) {
0:                     LOG.warn("Failed to stop jmx connector: " + e.getMessage());
1:                 } catch (Throwable ignore) {
/////////////////////////////////////////////////////////////////////////
1:     public String getJmxDomainName() {
1:      * @param jmxDomainName The jmxDomainName to set.
1:     public void setJmxDomainName(String jmxDomainName) {
1:         this.jmxDomainName = jmxDomainName;
/////////////////////////////////////////////////////////////////////////
0:     public MBeanServer getMBeanServer() {
1:         if (this.beanServer == null) {
1:             this.beanServer = findMBeanServer();
/////////////////////////////////////////////////////////////////////////
1:     public void setMBeanServer(MBeanServer beanServer) {
1:         this.beanServer = beanServer;
1:     public boolean isUseMBeanServer() {
1:      * @param useMBeanServer The useMBeanServer to set.
1:     public void setUseMBeanServer(boolean useMBeanServer) {
1:         this.useMBeanServer = useMBeanServer;
1:     public boolean isCreateMBeanServer() {
1:      * @param enableJMX Set createMBeanServer.
1:     public void setCreateMBeanServer(boolean enableJMX) {
1:         this.createMBeanServer = enableJMX;
/////////////////////////////////////////////////////////////////////////
1:      * @return the JMX ObjectName of the MBean, or <code>null</code> if
1:      *         <code>customName</code> is invalid.
1:     public ObjectName createCustomComponentMBeanName(String type, String name) {
1:         ObjectName result = null;
1:         String tmp = jmxDomainName + ":" + "type=" + sanitizeString(type) + ",name=" + sanitizeString(name);
1:         try {
1:             result = new ObjectName(tmp);
1:         } catch (MalformedObjectNameException e) {
0:             LOG.error("Couldn't create ObjectName from: " + type + " , " + name);
/////////////////////////////////////////////////////////////////////////
1:     private static String sanitizeString(String in) {
1:         String result = null;
1:         if (in != null) {
1:             result = in.replace(':', '_');
1:             result = result.replace('/', '_');
1:             result = result.replace('\\', '_');
/////////////////////////////////////////////////////////////////////////
0:     public static ObjectName getSystemObjectName(String domainName, String containerName, Class theClass) throws MalformedObjectNameException, NullPointerException {
1:         String tmp = domainName + ":" + "type=" + theClass.getName() + ",name=" + getRelativeName(containerName, theClass);
0:     private static String getRelativeName(String containerName, Class theClass) {
1:         String name = theClass.getName();
1:         int index = name.lastIndexOf(".");
1:         if (index >= 0 && (index + 1) < name.length()) {
1:             name = name.substring(index + 1);
1:         return containerName + "." + name;
/////////////////////////////////////////////////////////////////////////
1:     public void unregisterMBean(ObjectName name) throws JMException {
0:         if (beanServer != null && beanServer.isRegistered(name)) {
1:     protected synchronized MBeanServer findMBeanServer() {
1:         MBeanServer result = null;
1:         try {
1:             if (useMBeanServer) {
0:                     List list = MBeanServerFactory.findMBeanServer(null);
1:                     if (list != null && list.size() > 0) {
0:                         result = (MBeanServer)list.get(0);
/////////////////////////////////////////////////////////////////////////
1:         } catch (NoClassDefFoundError e) {
1:             LOG.error("Could not load MBeanServer", e);
1:         } catch (Throwable e) {
1:             LOG.error("Failed to initialize MBeanServer", e);
/////////////////////////////////////////////////////////////////////////
1:                         return (MBeanServer)answer;
1:                     } else {
0:                         LOG.warn("Could not cast: " + answer + " into an MBeanServer. There must be some classloader strangeness in town");
1:                 } else {
0:                     LOG.warn("Method getPlatformMBeanServer() does not appear visible on type: " + type.getName());
1:             } catch (Exception e) {
0:                 LOG.warn("Failed to call getPlatformMBeanServer() due to: " + e, e);
1:         } else {
0:             LOG.trace("Class not found: " + name + " so probably running on Java 1.4");
/////////////////////////////////////////////////////////////////////////
1:         } catch (ClassNotFoundException e) {
1:             } catch (ClassNotFoundException e1) {
/////////////////////////////////////////////////////////////////////////
1:     protected MBeanServer createMBeanServer() throws MalformedObjectNameException, IOException {
1:         MBeanServer mbeanServer = MBeanServerFactory.createMBeanServer(jmxDomainName);
1:         locallyCreateMBeanServer = true;
1:         if (createConnector) {
/////////////////////////////////////////////////////////////////////////
0:     private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, MalformedURLException, IOException {
1:         try {
1:             namingServiceObjectName = ObjectName.getInstance("naming:type=rmiregistry");
0:             Class cl = Class.forName("mx4j.tools.naming.NamingService");
1:             mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);
0:             // mbeanServer.createMBean("mx4j.tools.naming.NamingService",
0:             // namingServiceObjectName, null);
1:             Attribute attr = new Attribute("Port", Integer.valueOf(connectorPort));
1:             mbeanServer.setAttribute(namingServiceObjectName, attr);
1:         } catch (Throwable e) {
0:             LOG.debug("Failed to create local registry", e);
1:         String rmiServer = "";
1:         if (rmiServerPort != 0) {
0:             // This is handy to use if you have a firewall and need to
0:             // force JMX to use fixed ports.
0:             rmiServer = "localhost:" + rmiServerPort;
1:         }
0:         String serviceURL = "service:jmx:rmi://" + rmiServer + "/jndi/rmi://localhost:" + connectorPort + connectorPath;
1:         JMXServiceURL url = new JMXServiceURL(serviceURL);
0:         connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbeanServer);
1:     public String getConnectorPath() {
1:     public void setConnectorPath(String connectorPath) {
1:         this.connectorPath = connectorPath;
1:     public int getConnectorPort() {
1:     public void setConnectorPort(int connectorPort) {
1:         this.connectorPort = connectorPort;
1:     public int getRmiServerPort() {
1:     public void setRmiServerPort(int rmiServerPort) {
1:         this.rmiServerPort = rmiServerPort;
1:     public boolean isCreateConnector() {
1:     public void setCreateConnector(boolean createConnector) {
1:         this.createConnector = createConnector;
commit:86cbdfd
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1: }
commit:7f883f6
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
commit:68d245f
/////////////////////////////////////////////////////////////////////////
1:  * @org.apache.xbean.XBean
commit:ffad45e
/////////////////////////////////////////////////////////////////////////
0:     private String connectorPath = "/jmxrmi";
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:d29ca2a
/////////////////////////////////////////////////////////////////////////
1: /**
0:  *
0:  * Copyright 2004 The Apache Software Foundation
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
1:  */
1: package org.apache.activemq.broker.jmx;
1: 
1: import java.io.IOException;
0: import java.net.MalformedURLException;
1: import java.rmi.registry.LocateRegistry;
1: import java.util.List;
1: 
1: import javax.management.Attribute;
1: import javax.management.JMException;
1: import javax.management.MBeanServer;
1: import javax.management.MBeanServerFactory;
1: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectName;
1: import javax.management.remote.JMXConnectorServer;
1: import javax.management.remote.JMXConnectorServerFactory;
1: import javax.management.remote.JMXServiceURL;
1: 
1: import org.apache.activemq.Service;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: /**
0:  * A Flow provides different dispatch policies within the NMR
0:  * 
0:  * @org.xbean.XBean
0:  * 
0:  * @version $Revision$
1:  */
0: public class ManagementContext implements Service {
1:     /**
1:      * Default activemq domain
1:      */
0:     public static final String DEFAULT_DOMAIN = "org.apache.activemq";
1: 
0:     private final static Log log = LogFactory.getLog(ManagementContext.class);
1: 
1:     private MBeanServer beanServer;
0:     private String jmxDomainName = DEFAULT_DOMAIN;
0:     private boolean useMBeanServer = true;
0:     private boolean createMBeanServer = true;
0:     private boolean locallyCreateMBeanServer = false;
1: 
0:     private boolean createConnector = true;
0:     private int connectorPort = 1099;
0:     private String connectorPath = "/jmxconnector";
1: 
1:     private JMXConnectorServer connectorServer;
1: 
1:     private ObjectName namingServiceObjectName;
1: 
0:     public ManagementContext() {
1:         this(null);
1:     }
1: 
0:     public ManagementContext(MBeanServer server) {
0:         this.beanServer = server;
1:     }
1: 
0:     public void start() throws IOException {
1:         // lets force the MBeanServer to be created if needed
1:         getMBeanServer();
0:         if( connectorServer!=null ) {
1:             try {
1:                 getMBeanServer().invoke(namingServiceObjectName, "start", null, null);
0:             } catch (Throwable ignore) {
1:             }
1:             Thread t = new Thread("JMX connector") {
1:                 public void run() {
1:                     try {
0:                         connectorServer.start();     
0:                         log.info("JMX consoles can connect to " + connectorServer.getAddress());
0:                     } catch (IOException e) {
0:                         log.warn("Failed to start jmx connector: "+e.getMessage());
1:                     }
1:                 }
1:             };
1:             t.setDaemon(true);
1:             t.start();
1:         }
1:     }
1: 
0:     public void stop() throws IOException {
1:         
0:         if( connectorServer!=null ) {
1:             try {
0:                 connectorServer.stop();
0:             } catch (IOException e) {
0:                 log.warn("Failed to stop jmx connector: "+e.getMessage());
1:             }
0:             connectorServer=null;
1:             try {
1:                 getMBeanServer().invoke(namingServiceObjectName, "stop", null, null);
0:             } catch (Throwable ignore) {
1:             }
1:         }
1:         
1:         if (locallyCreateMBeanServer && beanServer != null) {
1:             // check to see if the factory knows about this server
0:             List list = MBeanServerFactory.findMBeanServer(null);
1:             if (list != null && !list.isEmpty() && list.contains(beanServer)) {
1:                 MBeanServerFactory.releaseMBeanServer(beanServer);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * @return Returns the jmxDomainName.
1:      */
0:     public String getJmxDomainName() {
1:         return jmxDomainName;
1:     }
1: 
1:     /**
0:      * @param jmxDomainName
0:      *            The jmxDomainName to set.
1:      */
0:     public void setJmxDomainName(String jmxDomainName) {
0:         this.jmxDomainName = jmxDomainName;
1:     }
1: 
1:     /**
1:      * Get the MBeanServer
0:      * 
1:      * @return the MBeanServer
1:      */
0:     public MBeanServer getMBeanServer() {
0:         if (this.beanServer == null) {
0:             this.beanServer = findMBeanServer();
1:         }
1:         return beanServer;
1:     }
1: 
1:     /**
1:      * @return Returns the useMBeanServer.
1:      */
0:     public boolean isUseMBeanServer() {
1:         return useMBeanServer;
1:     }
1: 
1:     /**
0:      * @param useMBeanServer
0:      *            The useMBeanServer to set.
1:      */
0:     public void setUseMBeanServer(boolean useMBeanServer) {
0:         this.useMBeanServer = useMBeanServer;
1:     }
1: 
1:     /**
1:      * @return Returns the createMBeanServer flag.
1:      */
0:     public boolean isCreateMBeanServer() {
1:         return createMBeanServer;
1:     }
1: 
1:     /**
0:      * @param enableJMX
0:      *            Set createMBeanServer.
1:      */
0:     public void setCreateMBeanServer(boolean enableJMX) {
0:         this.createMBeanServer = enableJMX;
1:     }
1: 
1:     /**
1:      * Formulate and return the MBean ObjectName of a custom control MBean
0:      * 
1:      * @param type
1:      * @param name
0:      * @return the JMX ObjectName of the MBean, or <code>null</code> if
0:      *         <code>customName</code> is invalid.
1:      */
0:     public ObjectName createCustomComponentMBeanName(String type, String name) {
0:         ObjectName result = null;
0:         String tmp = jmxDomainName + ":" + "type=" + sanitizeString(type) + ",name=" + sanitizeString(name);
1:         try {
0:             result = new ObjectName(tmp);
1:         }
0:         catch (MalformedObjectNameException e) {
0:             log.error("Couldn't create ObjectName from: " + type + " , " + name);
1:         }
1:         return result;
1:     }
1: 
1:     /**
1:      * The ':' and '/' characters are reserved in ObjectNames
0:      * 
1:      * @param in
1:      * @return sanitized String
1:      */
0:     private static String sanitizeString(String in) {
0:         String result = null;
0:         if (in != null) {
0:             result = in.replace(':', '_');
0:             result = result.replace('/', '_');
0:             result = result.replace('\\', '_');
1:         }
1:         return result;
1:     }
1: 
1:     /**
0:      * Retrive an System ObjectName
0:      * 
1:      * @param domainName
1:      * @param containerName
1:      * @param theClass
1:      * @return the ObjectName
1:      * @throws MalformedObjectNameException
1:      */
0:     public static ObjectName getSystemObjectName(String domainName, String containerName, Class theClass)
0:             throws MalformedObjectNameException, NullPointerException {
0:         String tmp = domainName + ":" + "type=" + theClass.getName() + ",name="
0:                 + getRelativeName(containerName, theClass);
1:         return new ObjectName(tmp);
1:     }
1: 
0:     private static String getRelativeName(String containerName, Class theClass) {
0:         String name = theClass.getName();
0:         int index = name.lastIndexOf(".");
0:         if (index >= 0 && (index + 1) < name.length()) {
0:             name = name.substring(index + 1);
1:         }
0:         return containerName + "." + name;
1:     }
1: 
1:     /**
1:      * Unregister an MBean
0:      * 
1:      * @param name
1:      * @throws JMException
1:      */
0:     public void unregisterMBean(ObjectName name) throws JMException {
0:         if (beanServer != null && beanServer.isRegistered(name)) {
0:             beanServer.unregisterMBean(name);
1:         }
1:     }
1: 
0:     protected synchronized MBeanServer findMBeanServer() {
0:         MBeanServer result = null;
0:         // create the mbean server
1:         try {
0:             if (useMBeanServer) {
0:                 // lets piggy back on another MBeanServer -
0:                 // we could be in an appserver!
0:                 List list = MBeanServerFactory.findMBeanServer(null);
0:                 if (list != null && list.size() > 0) {
0:                     result = (MBeanServer) list.get(0);
1:                 }
1:             }
1: 
1:             if (result == null && createMBeanServer) {
1:                 result = createMBeanServer();
1:             }
1:         }
0:         catch (NoClassDefFoundError e) {
0:             log.error("Couldnot load MBeanServer", e);
1:         }
0:         catch (Throwable e) {
1:             // probably don't have access to system properties
0:             log.error("Failed to initialize MBeanServer", e);
1:         }
1:         return result;
1:     }
1: 
1:     /**
0:      * @return
1:      * @throws NullPointerException 
1:      * @throws MalformedObjectNameException 
1:      * @throws IOException 
1:      */
0:     protected MBeanServer createMBeanServer() throws MalformedObjectNameException, IOException {
0:         MBeanServer mbeanServer = MBeanServerFactory.createMBeanServer(jmxDomainName);
0:         locallyCreateMBeanServer = true;
1:         
0:         if( createConnector ) {
1:             createConnector(mbeanServer);
1:         }
1:         
1: 
1:         return mbeanServer;
1:     }
1: 
1:     /**
1:      * @param mbeanServer
1:      * @throws MalformedObjectNameException
0:      * @throws MalformedURLException
1:      * @throws IOException
1:      */
0:     private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, MalformedURLException, IOException {
1:         
1:         // Create the NamingService, needed by JSR 160
1:         try {
0:             LocateRegistry.createRegistry(connectorPort);
1:             
0:             namingServiceObjectName = ObjectName.getInstance("naming:type=rmiregistry");
1:             
0: //          Do not use the createMBean as the mx4j jar may not be in the 
1:             // same class loader than the server
0:             Class cl = Class.forName("mx4j.tools.naming.NamingService");
0:             mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);
0:             //mbeanServer.createMBean("mx4j.tools.naming.NamingService", namingServiceObjectName, null);
1:             
1:             // set the naming port
0:             Attribute attr = new Attribute("Port", new Integer(connectorPort));
0:             mbeanServer.setAttribute(namingServiceObjectName, attr);
0:         } catch (Throwable e) {
0:             log.debug("Failed to create local registry", e);
1:         }
1:         
1:         // Create the JMXConnectorServer
0:         String serviceURL = "service:jmx:rmi:///jndi/rmi://localhost:" + connectorPort + connectorPath;            
0:         JMXServiceURL url = new JMXServiceURL(serviceURL);
0:         connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbeanServer);
1:         
0:         //log.info("JMX consoles can connect to serviceURL: " + serviceURL);
1:     }
1: 
0:     public String getConnectorPath() {
1:         return connectorPath;
1:     }
0:     public void setConnectorPath(String connectorPath) {
0:         this.connectorPath = connectorPath;
1:     }
1: 
0:     public int getConnectorPort() {
1:         return connectorPort;
1:     }
0:     public void setConnectorPort(int connectorPort) {
0:         this.connectorPort = connectorPort;
1:     }
1: 
0:     public boolean isCreateConnector() {
1:         return createConnector;
1:     }
0:     public void setCreateConnector(boolean createConnector) {
0:         this.createConnector = createConnector;
1:     }
1: }
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:ece2e17
/////////////////////////////////////////////////////////////////////////
1:                     if (namingServiceObjectName != null && getMBeanServer().isRegistered(namingServiceObjectName)) {
commit:688c4f7
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
1: import java.lang.reflect.Method;
0: import java.rmi.registry.LocateRegistry;
1: import java.rmi.registry.Registry;
0: import java.util.List;
1: import java.util.Map;
1: import java.util.Set;
1: import java.util.concurrent.ConcurrentHashMap;
0: import java.util.concurrent.atomic.AtomicBoolean;
0: import javax.management.Attribute;
1: import javax.management.InstanceNotFoundException;
0: import javax.management.JMException;
0: import javax.management.MBeanServer;
0: import javax.management.MBeanServerFactory;
1: import javax.management.MBeanServerInvocationHandler;
0: import javax.management.MalformedObjectNameException;
1: import javax.management.ObjectInstance;
0: import javax.management.ObjectName;
1: import javax.management.QueryExp;
0: import javax.management.remote.JMXConnectorServer;
0: import javax.management.remote.JMXConnectorServerFactory;
0: import javax.management.remote.JMXServiceURL;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             // fallback and use localhost
1:             if (connectorHost == null) {
1:                 connectorHost = "localhost";
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 LOG.debug("Creating RMIRegistry on port {}", connectorPort);
1:                 registry = LocateRegistry.createRegistry(connectorPort);
commit:f272fc1
/////////////////////////////////////////////////////////////////////////
1:             // force mbean server to be looked up, so we have it
0: 
1:                     if (getMBeanServer().isRegistered(namingServiceObjectName)) {
1:                         LOG.debug("Invoking start on mbean: {}", namingServiceObjectName);
0:                         getMBeanServer().invoke(namingServiceObjectName, "start", null, null);
1:                     }
0:                     LOG.debug("Error invoking start on mbean " + namingServiceObjectName + ". This exception is ignored.", ignore);
0: 
/////////////////////////////////////////////////////////////////////////
1:                     LOG.debug("Releasing MBeanServer {}", beanServer);
0: 
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Closing registry socket {}, is closed: {}, is bound: {}",
0:                             new Object[]{registrySocket, registrySocket.isClosed(), registrySocket.isBound()});
1:                     }
0: 
0: 
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Closed registry socket {}, is closed: {}, is bound: {}",
0:                             new Object[]{registrySocket, registrySocket.isClosed(), registrySocket.isBound()});
1:                     }
0:                     LOG.debug("Error closing registry socket " + registrySocket + ". This exception is ignored.", e);
/////////////////////////////////////////////////////////////////////////
1:     private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {
commit:eea45cc
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.ConcurrentHashMap;
/////////////////////////////////////////////////////////////////////////
1:     private final Map<ObjectName, ObjectName> registeredMBeanNames = new ConcurrentHashMap<ObjectName, ObjectName>();
/////////////////////////////////////////////////////////////////////////
0: 
1:             // unregister the mbeans we have registered
1:                 for (Map.Entry<ObjectName, ObjectName> entry : registeredMBeanNames.entrySet()) {
1:                     ObjectName actualName = entry.getValue();
1:                     if (actualName != null && beanServer.isRegistered(actualName)) {
1:                         LOG.debug("Unregistering MBean {}", actualName);
1:                         mbeanServer.unregisterMBean(actualName);
1:                     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         this.registeredMBeanNames.put(name, result.getObjectName());
1:     public Set<ObjectName> queryNames(ObjectName name, QueryExp query) throws Exception{
0:     	if (name != null) {
1:     		ObjectName actualName = this.registeredMBeanNames.get(name);
0:     		if (actualName != null) {
0:     			return getMBeanServer().queryNames(actualName, query);
1:     		}
1:         }
/////////////////////////////////////////////////////////////////////////
0:         ObjectName actualName = this.registeredMBeanNames.get(name);
1:         if (beanServer != null && actualName != null && beanServer.isRegistered(actualName) && this.registeredMBeanNames.remove(name) != null) {
1:             LOG.debug("Unregistering MBean {}", actualName);
1:             beanServer.unregisterMBean(actualName);
commit:3092051
/////////////////////////////////////////////////////////////////////////
0:                             LOG.warn("Failed to start jmx connector: " + e.getMessage() + ". Will restart management to re-create jmx connector, trying to remedy this issue.");
0:                             LOG.debug("Reason for failed jmx connector start", e);
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("Unregistering MBean {}", name);
0:                     mbeanServer.unregisterMBean(name);
/////////////////////////////////////////////////////////////////////////
1:                         LOG.debug("Stopping jmx connector");
1:                         server.stop();
1:                 // stop naming service mbean
0:                     if (getMBeanServer().isRegistered(namingServiceObjectName)) {
1:                         LOG.debug("Stopping MBean {}", namingServiceObjectName);
0:                         getMBeanServer().invoke(namingServiceObjectName, "stop", null, null);
1:                         LOG.debug("Unregistering MBean {}", namingServiceObjectName);
1:                         getMBeanServer().unregisterMBean(namingServiceObjectName);
1:                     }
0:                     LOG.warn("Error stopping and unregsitering mbean " + namingServiceObjectName + " due " + ignore.getMessage());
1:                 namingServiceObjectName = null;
/////////////////////////////////////////////////////////////////////////
0:             if (registrySocket!=null) {
/////////////////////////////////////////////////////////////////////////
0: 
0:         // clear reference to aid GC
0:         registry = null;
/////////////////////////////////////////////////////////////////////////
0:         } catch (Throwable e) {
1:             LOG.debug("Failed to create local registry. This exception will be ignored.", e);
/////////////////////////////////////////////////////////////////////////
0: 
1:         LOG.debug("Created JMXConnectorServer {}", connectorServer);
commit:eea9fca
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.MDC;
/////////////////////////////////////////////////////////////////////////
1:     private String brokerName;
/////////////////////////////////////////////////////////////////////////
1:                         // ensure we use MDC logging with the broker name, so people can see the logs if MDC was in use
1:                         if (brokerName != null) {
1:                             MDC.put("activemq.broker", brokerName);
1:                         }
1:                                     // need to remove MDC as we must not inherit MDC in child threads causing leaks
1:                                     MDC.remove("activemq.broker");
1:                                     if (brokerName != null) {
1:                                         MDC.put("activemq.broker", brokerName);
1:                                     }
0:                                     connectorStarting.set(false);
1:                         } finally {
1:                             MDC.remove("activemq.broker");
/////////////////////////////////////////////////////////////////////////
1:      * Gets the broker name this context is used by, may be <tt>null</tt>
1:      * if the broker name was not set.
1:      */
1:     public String getBrokerName() {
1:         return brokerName;
1:     }
0: 
1:     /**
1:      * Sets the broker name this context is being used by.
1:      */
1:     public void setBrokerName(String brokerName) {
1:         this.brokerName = brokerName;
1:     }
0: 
1:     /**
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:d1a0419
/////////////////////////////////////////////////////////////////////////
0: import javax.net.ServerSocketFactory;
0: import java.net.InetAddress;
/////////////////////////////////////////////////////////////////////////
0:                         registrySocket = ServerSocketFactory.getDefault().createServerSocket(connectorPort, 0, InetAddress.getByName(connectorHost));
commit:c0c9259
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.BooleanEditor"
1:      */
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(ManagementContext.class);
commit:55794fe
/////////////////////////////////////////////////////////////////////////
1:     public ObjectInstance getObjectInstance(ObjectName name) throws InstanceNotFoundException {
commit:fe3660d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.Service;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: import javax.management.*;
0: import javax.management.remote.JMXConnectorServer;
0: import javax.management.remote.JMXConnectorServerFactory;
0: import javax.management.remote.JMXServiceURL;
/////////////////////////////////////////////////////////////////////////
0: import java.util.*;
/////////////////////////////////////////////////////////////////////////
0:     private Map environment;
/////////////////////////////////////////////////////////////////////////
1:         connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(url, environment, mbeanServer);
0:         
/////////////////////////////////////////////////////////////////////////
0: 
0:     public Map getEnvironment() {
1:         return environment;
1:     }
0: 
0:     public void setEnvironment(Map environment) {
1:         this.environment = environment;
1:     }
commit:c9ca34a
/////////////////////////////////////////////////////////////////////////
0:     private AtomicBoolean connectorStarting = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
0:                                 connectorStarting.set(true);
0:                                 try {
0:                                 	server.start();
1:                                 } finally {
0:                                 	connectorStarting.set(false);
1:                                 }
/////////////////////////////////////////////////////////////////////////
0:                 	if (!connectorStarting.get()) {
0:                 		server.stop();
1:                 	}
/////////////////////////////////////////////////////////////////////////
0: 		return connectorStarting.get() || (connectorServer != null && connectorServer.isActive());
commit:bf91745
/////////////////////////////////////////////////////////////////////////
0: 		return connectorServer != null && connectorServer.isActive();
commit:b3873fb
/////////////////////////////////////////////////////////////////////////
1:     public boolean isConnectorStarted() {
0: 		return connectorServer.isActive();
1: 	}
0: 
1: 	/**
commit:472782a
/////////////////////////////////////////////////////////////////////////
0: import java.util.Set;
commit:ced6909
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:62e1abf
/////////////////////////////////////////////////////////////////////////
0: import java.rmi.registry.Registry;
/////////////////////////////////////////////////////////////////////////
1:     private Registry registry;
/////////////////////////////////////////////////////////////////////////
1:             beanServer = null;
/////////////////////////////////////////////////////////////////////////
1:         	if (registry == null) {
0:         		registry = LocateRegistry.createRegistry(connectorPort);
1:         	}
commit:76d9fcc
/////////////////////////////////////////////////////////////////////////
1:     private boolean findTigerMbeanServer = true;
/////////////////////////////////////////////////////////////////////////
1:     public MBeanServer findTigerMBeanServer() {
/////////////////////////////////////////////////////////////////////////
0:                     	if (createConnector) {
0:                     		createConnector((MBeanServer)answer);
1:                     	}
author:Gary Tully
-------------------------------------------------------------------------------
commit:c051381
/////////////////////////////////////////////////////////////////////////
1:     private boolean allowRemoteAddressInMBeanNames = true;
/////////////////////////////////////////////////////////////////////////
0:     public Set<ObjectName>  queryNames(ObjectName name, QueryExp query) throws Exception{
/////////////////////////////////////////////////////////////////////////
0: 
1:     public boolean isAllowRemoteAddressInMBeanNames() {
1:         return allowRemoteAddressInMBeanNames;
1:     }
0: 
1:     public void setAllowRemoteAddressInMBeanNames(boolean allowRemoteAddressInMBeanNames) {
1:         this.allowRemoteAddressInMBeanNames = allowRemoteAddressInMBeanNames;
1:     }
commit:5edede1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryIntPropertyEditor"
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @org.apache.xbean.Property propertyEditor="org.apache.activemq.util.MemoryIntPropertyEditor"
1:      */
commit:814c49f
/////////////////////////////////////////////////////////////////////////
1:  * An abstraction over JMX mbean registration
/////////////////////////////////////////////////////////////////////////
1:                                 LOG.debug("Starting JMXConnectorServer...");
commit:f1fa8f9
/////////////////////////////////////////////////////////////////////////
0: import java.net.ServerSocket;
0: import java.rmi.server.RMIServerSocketFactory;
/////////////////////////////////////////////////////////////////////////
0:                     LOG.debug("ignored error on start invocation", ignore);
0:                                 LOG.debug("Starting JMX JMXConnectorServer...");
0:                             LOG.debug("Reason for failed jms connector start", e);
/////////////////////////////////////////////////////////////////////////
0:             if (registry == null) {
0:                 registry = LocateRegistry.createRegistry(connectorPort, null, new RMIServerSocketFactory() {
0:                     public ServerSocket createServerSocket(int port)
0:                             throws IOException {
0:                         ServerSocket result = new ServerSocket(port);
0:                         result.setReuseAddress(true);
1:                         return result;
0:                     }});
1:             }
author:Robert Davies
-------------------------------------------------------------------------------
commit:c7c8e53
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean started = new AtomicBoolean(false);
0:     private final AtomicBoolean connectorStarting = new AtomicBoolean(false);
0:     private final List<ObjectName> registeredMBeanNames = new CopyOnWriteArrayList<ObjectName>();
/////////////////////////////////////////////////////////////////////////
0:                     @Override
/////////////////////////////////////////////////////////////////////////
0:     public ObjectInstance getObjectInstance(ObjectName name) throws Exception {
1:         return getMBeanServer().getObjectInstance(name);
1:     }
0:     
commit:dab6924
/////////////////////////////////////////////////////////////////////////
1:     private String connectorHost = "localhost";
/////////////////////////////////////////////////////////////////////////
1:             rmiServer = ""+getConnectorHost()+":" + rmiServerPort;
1:         String serviceURL = "service:jmx:rmi://" + rmiServer + "/jndi/rmi://" +getConnectorHost()+":" + connectorPort + connectorPath;
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Get the connectorHost
1:      * @return the connectorHost
1:      */
1:     public String getConnectorHost() {
1:         return this.connectorHost;
1:     }
0: 
1:     /**
1:      * Set the connectorHost
1:      * @param connectorHost the connectorHost to set
1:      */
1:     public void setConnectorHost(String connectorHost) {
1:         this.connectorHost = connectorHost;
1:     }
commit:ac4545b
/////////////////////////////////////////////////////////////////////////
0: import javax.management.QueryExp;
/////////////////////////////////////////////////////////////////////////
0:     public Set queryNames(ObjectName name, QueryExp query) throws Exception{
1:         return getMBeanServer().queryNames(name, query);
1:     }
0:     
commit:1ec71bd
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.Set;
0: import java.util.concurrent.CopyOnWriteArrayList;
0: import javax.management.InstanceAlreadyExistsException;
0: import javax.management.InstanceNotFoundException;
0: import javax.management.MBeanRegistrationException;
0: import javax.management.MBeanServerInvocationHandler;
0: import javax.management.NotCompliantMBeanException;
0: import javax.management.ObjectInstance;
/////////////////////////////////////////////////////////////////////////
0: import sun.security.action.GetBooleanAction;
/////////////////////////////////////////////////////////////////////////
0:     private List<ObjectName> registeredMBeanNames = new CopyOnWriteArrayList<ObjectName>();
/////////////////////////////////////////////////////////////////////////
1:     public void stop() throws Exception {
1:             MBeanServer mbeanServer = getMBeanServer();
1:             if (mbeanServer != null) {
0:                 for (Iterator<ObjectName> iter = registeredMBeanNames.iterator(); iter.hasNext();) {
0:                     ObjectName name = iter.next();
0:                     
0:                         mbeanServer.unregisterMBean(name);
0:                     
1:                 }
1:             }
1:             registeredMBeanNames.clear();
/////////////////////////////////////////////////////////////////////////
0:     protected MBeanServer getMBeanServer() {
/////////////////////////////////////////////////////////////////////////
0:     
0:     public Object newProxyInstance( ObjectName objectName,
0:                       Class interfaceClass,
0:                       boolean notificationBroadcaster){
1:         return MBeanServerInvocationHandler.newProxyInstance(getMBeanServer(), objectName, interfaceClass, notificationBroadcaster);
0:         
1:     }
0:     
1:     public Object getAttribute(ObjectName name, String attribute) throws Exception{
1:         return getMBeanServer().getAttribute(name, attribute);
1:     }
0:     
1:     public ObjectInstance registerMBean(Object bean, ObjectName name) throws Exception{
0:         ObjectInstance result = getMBeanServer().registerMBean(bean, name);
0:         this.registeredMBeanNames.add(name);
0:         return result;
1:     }
0:     
/////////////////////////////////////////////////////////////////////////
0:         if (beanServer != null && beanServer.isRegistered(name) && this.registeredMBeanNames.remove(name)) {
commit:16b4009
/////////////////////////////////////////////////////////////////////////
1:         } catch(ClassNotFoundException e) {
0:             LOG.debug("Probably not using JRE 1.4: " + e.getLocalizedMessage());
1:         }
0:         catch (Throwable e) {
commit:d36c0d4
/////////////////////////////////////////////////////////////////////////
0:             Attribute attr=new Attribute("Port",Integer.valueOf(connectorPort));
commit:c5f96e1
/////////////////////////////////////////////////////////////////////////
0:  * 
0:  * 
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
0:  * the License. You may obtain a copy of the License at
0:  * 
0:  * 
0:  * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
0:  * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
0:  * specific language governing permissions and limitations under the License.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
0: public class ManagementContext implements Service{
0:     public static final String DEFAULT_DOMAIN="org.apache.activemq";
0:     private final static Log log=LogFactory.getLog(ManagementContext.class);
0:     private String jmxDomainName=DEFAULT_DOMAIN;
0:     private boolean useMBeanServer=true;
0:     private boolean createMBeanServer=true;
0:     private boolean locallyCreateMBeanServer=false;
0:     private boolean createConnector=true;
0:     private int connectorPort=1099;
0:     private String connectorPath="/jmxrmi";
0:     private AtomicBoolean started=new AtomicBoolean(false);
0:     public ManagementContext(){
0:     public ManagementContext(MBeanServer server){
0:         this.beanServer=server;
0:     public void start() throws IOException{
0:         if(started.compareAndSet(false,true)){
0:             getMBeanServer();
0:             if(connectorServer!=null){
0:                 try{
0:                     getMBeanServer().invoke(namingServiceObjectName,"start",null,null);
0:                 }catch(Throwable ignore){}
0:                 Thread t=new Thread("JMX connector"){
0:                     public void run(){
0:                         try{
0:                             if(started.get()&&connectorServer!=null){
0:                                 connectorServer.start();
0:                                 log.info("JMX consoles can connect to "+connectorServer.getAddress());
1:                             }
0:                         }catch(IOException e){
0:                             log.warn("Failed to start jmx connector: "+e.getMessage());
1:                         }
0:                 };
0:                 t.setDaemon(true);
0:                 t.start();
1:             }
0:     public void stop() throws IOException{
0:         if(started.compareAndSet(true,false)){
0:             if(connectorServer!=null){
0:                 try{
0:                     connectorServer.stop();
0:                 }catch(IOException e){
0:                     log.warn("Failed to stop jmx connector: "+e.getMessage());
1:                 }
0:                 connectorServer=null;
0:                 try{
0:                     getMBeanServer().invoke(namingServiceObjectName,"stop",null,null);
0:                 }catch(Throwable ignore){}
0:             if(locallyCreateMBeanServer&&beanServer!=null){
0:                 // check to see if the factory knows about this server
0:                 List list=MBeanServerFactory.findMBeanServer(null);
0:                 if(list!=null&&!list.isEmpty()&&list.contains(beanServer)){
0:                     MBeanServerFactory.releaseMBeanServer(beanServer);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:     public String getJmxDomainName(){
/////////////////////////////////////////////////////////////////////////
0:     public void setJmxDomainName(String jmxDomainName){
0:         this.jmxDomainName=jmxDomainName;
/////////////////////////////////////////////////////////////////////////
0:     public MBeanServer getMBeanServer(){
0:         if(this.beanServer==null){
0:             this.beanServer=findMBeanServer();
0: 
0:      * 
0:         this.beanServer=beanServer;
0:     public boolean isUseMBeanServer(){
/////////////////////////////////////////////////////////////////////////
0:     public void setUseMBeanServer(boolean useMBeanServer){
0:         this.useMBeanServer=useMBeanServer;
0:     public boolean isCreateMBeanServer(){
/////////////////////////////////////////////////////////////////////////
0:     public void setCreateMBeanServer(boolean enableJMX){
0:         this.createMBeanServer=enableJMX;
/////////////////////////////////////////////////////////////////////////
0:      * @return the JMX ObjectName of the MBean, or <code>null</code> if <code>customName</code> is invalid.
0:     public ObjectName createCustomComponentMBeanName(String type,String name){
0:         ObjectName result=null;
0:         String tmp=jmxDomainName+":"+"type="+sanitizeString(type)+",name="+sanitizeString(name);
0:         try{
0:             result=new ObjectName(tmp);
0:         }catch(MalformedObjectNameException e){
0:             log.error("Couldn't create ObjectName from: "+type+" , "+name);
/////////////////////////////////////////////////////////////////////////
0:     private static String sanitizeString(String in){
0:         String result=null;
0:         if(in!=null){
0:             result=in.replace(':','_');
0:             result=result.replace('/','_');
0:             result=result.replace('\\','_');
/////////////////////////////////////////////////////////////////////////
0:     public static ObjectName getSystemObjectName(String domainName,String containerName,Class theClass)
0:                     throws MalformedObjectNameException,NullPointerException{
0:         String tmp=domainName+":"+"type="+theClass.getName()+",name="+getRelativeName(containerName,theClass);
0:     private static String getRelativeName(String containerName,Class theClass){
0:         String name=theClass.getName();
0:         int index=name.lastIndexOf(".");
0:         if(index>=0&&(index+1)<name.length()){
0:             name=name.substring(index+1);
0:         return containerName+"."+name;
/////////////////////////////////////////////////////////////////////////
0:     public void unregisterMBean(ObjectName name) throws JMException{
0:         if(beanServer!=null&&beanServer.isRegistered(name)){
0:     protected synchronized MBeanServer findMBeanServer(){
0:         MBeanServer result=null;
0:         try{
0:             if(useMBeanServer){
0:                 List list=MBeanServerFactory.findMBeanServer(null);
0:                 if(list!=null&&list.size()>0){
0:                     result=(MBeanServer) list.get(0);
0:             if(result==null&&createMBeanServer){
0:                 result=createMBeanServer();
0:         }catch(NoClassDefFoundError e){
0:             log.error("Couldnot load MBeanServer",e);
0:         }catch(Throwable e){
0:             log.error("Failed to initialize MBeanServer",e);
0:      * @throws NullPointerException
0:      * @throws MalformedObjectNameException
0:      * @throws IOException
0:     protected MBeanServer createMBeanServer() throws MalformedObjectNameException,IOException{
0:         MBeanServer mbeanServer=MBeanServerFactory.createMBeanServer(jmxDomainName);
0:         locallyCreateMBeanServer=true;
0:         if(createConnector){
/////////////////////////////////////////////////////////////////////////
0:     private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException,MalformedURLException,
0:                     IOException{
0:         try{
0:             namingServiceObjectName=ObjectName.getInstance("naming:type=rmiregistry");
1:             // Do not use the createMBean as the mx4j jar may not be in the
0:             Class cl=Class.forName("mx4j.tools.naming.NamingService");
0:             mbeanServer.registerMBean(cl.newInstance(),namingServiceObjectName);
0:             // mbeanServer.createMBean("mx4j.tools.naming.NamingService", namingServiceObjectName, null);
0:             Attribute attr=new Attribute("Port",new Integer(connectorPort));
0:             mbeanServer.setAttribute(namingServiceObjectName,attr);
0:         }catch(Throwable e){
0:             log.debug("Failed to create local registry",e);
0:         String serviceURL="service:jmx:rmi:///jndi/rmi://localhost:"+connectorPort+connectorPath;
0:         JMXServiceURL url=new JMXServiceURL(serviceURL);
0:         connectorServer=JMXConnectorServerFactory.newJMXConnectorServer(url,null,mbeanServer);
0:         // log.info("JMX consoles can connect to serviceURL: " + serviceURL);
0:     public String getConnectorPath(){
0: 
0:     public void setConnectorPath(String connectorPath){
0:         this.connectorPath=connectorPath;
0:     public int getConnectorPort(){
0: 
0:     public void setConnectorPort(int connectorPort){
0:         this.connectorPort=connectorPort;
0:     public boolean isCreateConnector(){
0: 
0:     public void setCreateConnector(boolean createConnector){
0:         this.createConnector=createConnector;
commit:4d9ab0c
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
1:      * Set the MBeanServer
1:      * @param beanServer
1:      */
0:     public void setMBeanServer(MBeanServer beanServer){
0:         this.beanServer = beanServer;
0:     }
author:David Jencks
-------------------------------------------------------------------------------
commit:eee37fb
/////////////////////////////////////////////////////////////////////////
author:James Strachan
-------------------------------------------------------------------------------
commit:917927f
/////////////////////////////////////////////////////////////////////////
0: 
0:             if (result != null && createConnector) {
commit:1ad52f4
/////////////////////////////////////////////////////////////////////////
1:     private int rmiServerPort;
/////////////////////////////////////////////////////////////////////////
0:             if (result == null && createMBeanServer) {
0:                 result = createMBeanServer();
0:             else {
0:                 createConnector(result);
0:             }
0:         }
0:         catch (NoClassDefFoundError e) {
0:             log.error("Could not load MBeanServer", e);
0:         }
0:         catch (Throwable e) {
0:             log.error("Failed to initialize MBeanServer", e);
/////////////////////////////////////////////////////////////////////////
0: 	String rmiServer = "";
0: 	if (rmiServerPort != 0) {
0: 	    // This is handy to use if you have a firewall and need to
0: 	    // force JMX to use fixed ports.
0: 	    rmiServer = "localhost:" + rmiServerPort;
0: 	}
0: 	String serviceURL = "service:jmx:rmi://"+rmiServer+"/jndi/rmi://localhost:"+connectorPort+connectorPath;
/////////////////////////////////////////////////////////////////////////
0:     public int getRmiServerPort(){
1:         return rmiServerPort;
0:     }
0: 
0:     public void setRmiServerPort(int rmiServerPort){
0:         this.rmiServerPort=rmiServerPort;
0:     }
0: 
commit:d680ba1
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ClassLoading;
/////////////////////////////////////////////////////////////////////////
0:     private boolean findTigerMbeanServer=false;
/////////////////////////////////////////////////////////////////////////
1:     public boolean isFindTigerMbeanServer() {
1:         return findTigerMbeanServer;
0:     }
0: 
0:     /**
1:      * Enables/disables the searching for the Java 5 platform MBeanServer
1:      */
1:     public void setFindTigerMbeanServer(boolean findTigerMbeanServer) {
1:         this.findTigerMbeanServer = findTigerMbeanServer;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:                 if (findTigerMbeanServer) {
1:                     result = findTigerMBeanServer();
0:                 }
1:                 if (result == null) {
0:                     // lets piggy back on another MBeanServer -
0:                     // we could be in an appserver!
0:                     List list=MBeanServerFactory.findMBeanServer(null);
0:                     if(list!=null&&list.size()>0){
0:                         result=(MBeanServer) list.get(0);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:     public static MBeanServer findTigerMBeanServer() {
1:         String name = "java.lang.management.ManagementFactory";
0:         Class type = loadClass(name, ManagementContext.class.getClassLoader());
1:         if (type != null) {
0:             try {
1:                 Method method = type.getMethod("getPlatformMBeanServer", new Class[0]);
1:                 if (method != null) {
1:                     Object answer = method.invoke(null, new Object[0]);
1:                     if (answer instanceof MBeanServer) {
0:                         return (MBeanServer) answer;
0:                     }
0:                     else {
0:                         log.warn("Could not cast: " + answer + " into an MBeanServer. There must be some classloader strangeness in town");
0:                     }
0:                 }
0:                 else {
0:                     log.warn("Method getPlatformMBeanServer() does not appear visible on type: " + type.getName());
0:                 }
0:             }
0:             catch (Exception e) {
0:                 log.warn("Failed to call getPlatformMBeanServer() due to: " + e, e);
0:             }
0:         }
0:         else {
0:             log.trace("Class not found: " + name + " so probably running on Java 1.4");
0:         }
1:         return null;
0:     }
0: 
0:     private static Class loadClass(String name, ClassLoader loader) {
0:         try {
1:             return loader.loadClass(name);
0:         }
0:         catch (ClassNotFoundException e) {
0:             try {
1:                 return Thread.currentThread().getContextClassLoader().loadClass(name);
0:             }
0:             catch (ClassNotFoundException e1) {
1:                 return null;
0:             }
0:         }
0:     }
0: 
commit:6ce0aaa
/////////////////////////////////////////////////////////////////////////
0:     public void start() throws IOException {
1:         if (started.compareAndSet(false, true)) {
1:             if (connectorServer != null) {
0:                 try {
0:                     getMBeanServer().invoke(namingServiceObjectName, "start", null, null);
0:                 }
0:                 catch (Throwable ignore) {
0:                 }
0:                 Thread t = new Thread("JMX connector") {
0:                     public void run() {
0:                         try {
1:                             JMXConnectorServer server = connectorServer;
1:                             if (started.get() && server != null) {
0:                                 server.start();
0:                                 log.info("JMX consoles can connect to " + server.getAddress());
0:                         }
0:                         catch (IOException e) {
0:                             log.warn("Failed to start jmx connector: " + e.getMessage());
/////////////////////////////////////////////////////////////////////////
0:     public void stop() throws IOException {
1:         if (started.compareAndSet(true, false)) {
1:             JMXConnectorServer server = connectorServer;
1:             connectorServer = null;
1:             if (server != null) {
0:                 try {
0:                     server.stop();
0:                 catch (IOException e) {
0:                     log.warn("Failed to stop jmx connector: " + e.getMessage());
0:                 }
0:                 try {
0:                     getMBeanServer().invoke(namingServiceObjectName, "stop", null, null);
0:                 }
0:                 catch (Throwable ignore) {
0:                 }
0:             if (locallyCreateMBeanServer && beanServer != null) {
0:                 List list = MBeanServerFactory.findMBeanServer(null);
0:                 if (list != null && !list.isEmpty() && list.contains(beanServer)) {
============================================================================