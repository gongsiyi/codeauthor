1:a107823: /**
1:57b4941:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:57b4941:  * contributor license agreements.  See the NOTICE file distributed with
1:57b4941:  * this work for additional information regarding copyright ownership.
1:57b4941:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:57b4941:  * (the "License"); you may not use this file except in compliance with
1:57b4941:  * the License.  You may obtain a copy of the License at
3:a107823:  *
1:5f1adbe:  *      http://www.apache.org/licenses/LICENSE-2.0
1:a107823:  *
1:a107823:  * Unless required by applicable law or agreed to in writing, software
1:a107823:  * distributed under the License is distributed on an "AS IS" BASIS,
1:a107823:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a107823:  * See the License for the specific language governing permissions and
1:a107823:  * limitations under the License.
1:a107823:  */
1:a107823: package org.apache.activemq.jaas;
1:540dd5c: 
1:a107823: import java.io.IOException;
1:20747ee: import java.net.URI;
1:20747ee: import java.net.URISyntaxException;
1:540dd5c: import java.security.Principal;
1:a107823: import java.text.MessageFormat;
1:0a8e505: import java.util.*;
17:a107823: 
1:0a8e505: import javax.naming.*;
1:a107823: import javax.naming.directory.Attribute;
1:a107823: import javax.naming.directory.Attributes;
1:a107823: import javax.naming.directory.DirContext;
1:a107823: import javax.naming.directory.InitialDirContext;
1:a107823: import javax.naming.directory.SearchControls;
1:a107823: import javax.naming.directory.SearchResult;
1:a107823: import javax.security.auth.Subject;
1:a107823: import javax.security.auth.callback.Callback;
1:a107823: import javax.security.auth.callback.CallbackHandler;
1:a107823: import javax.security.auth.callback.NameCallback;
1:a107823: import javax.security.auth.callback.PasswordCallback;
1:a107823: import javax.security.auth.callback.UnsupportedCallbackException;
1:a107823: import javax.security.auth.login.FailedLoginException;
1:540dd5c: import javax.security.auth.login.LoginException;
1:a107823: import javax.security.auth.spi.LoginModule;
1:a107823: 
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:a107823: 
1:a107823: /**
1:a107823:  * @version $Rev: $ $Date: $
1:a107823:  */
1:a107823: public class LDAPLoginModule implements LoginModule {
1:a107823: 
1:a107823:     private static final String INITIAL_CONTEXT_FACTORY = "initialContextFactory";
1:a107823:     private static final String CONNECTION_URL = "connectionURL";
1:a107823:     private static final String CONNECTION_USERNAME = "connectionUsername";
1:a107823:     private static final String CONNECTION_PASSWORD = "connectionPassword";
1:a107823:     private static final String CONNECTION_PROTOCOL = "connectionProtocol";
1:a107823:     private static final String AUTHENTICATION = "authentication";
1:a107823:     private static final String USER_BASE = "userBase";
1:a107823:     private static final String USER_SEARCH_MATCHING = "userSearchMatching";
1:a107823:     private static final String USER_SEARCH_SUBTREE = "userSearchSubtree";
1:a107823:     private static final String ROLE_BASE = "roleBase";
1:a107823:     private static final String ROLE_NAME = "roleName";
1:a107823:     private static final String ROLE_SEARCH_MATCHING = "roleSearchMatching";
1:a107823:     private static final String ROLE_SEARCH_SUBTREE = "roleSearchSubtree";
1:a107823:     private static final String USER_ROLE_NAME = "userRoleName";
1:0a8e505:     private static final String EXPAND_ROLES = "expandRoles";
1:0a8e505:     private static final String EXPAND_ROLES_MATCHING = "expandRolesMatching";
1:540dd5c: 
1:8bf987b:     private static Logger log = LoggerFactory.getLogger(LDAPLoginModule.class);
1:a107823: 
1:540dd5c:     protected DirContext context;
1:540dd5c: 
1:540dd5c:     private Subject subject;
1:6999a02:     private CallbackHandler handler;  
1:6999a02:     private LDAPLoginProperty [] config;
1:a107823:     private String username;
1:540dd5c:     private Set<GroupPrincipal> groups = new HashSet<GroupPrincipal>();
1:a107823: 
1:1667d80:     @Override
1:a107823:     public void initialize(Subject subject, CallbackHandler callbackHandler, Map sharedState, Map options) {
1:a107823:         this.subject = subject;
1:a107823:         this.handler = callbackHandler;
1:6999a02:         
1:6999a02:         config = new LDAPLoginProperty [] {
1:6999a02:         		new LDAPLoginProperty (INITIAL_CONTEXT_FACTORY, (String)options.get(INITIAL_CONTEXT_FACTORY)),
1:6999a02:         		new LDAPLoginProperty (CONNECTION_URL, (String)options.get(CONNECTION_URL)),
1:6999a02:         		new LDAPLoginProperty (CONNECTION_USERNAME, (String)options.get(CONNECTION_USERNAME)),
1:6999a02:         		new LDAPLoginProperty (CONNECTION_PASSWORD, (String)options.get(CONNECTION_PASSWORD)),
1:6999a02:         		new LDAPLoginProperty (CONNECTION_PROTOCOL, (String)options.get(CONNECTION_PROTOCOL)),
1:6999a02:         		new LDAPLoginProperty (AUTHENTICATION, (String)options.get(AUTHENTICATION)),
1:6999a02:         		new LDAPLoginProperty (USER_BASE, (String)options.get(USER_BASE)),
1:6999a02:         		new LDAPLoginProperty (USER_SEARCH_MATCHING, (String)options.get(USER_SEARCH_MATCHING)),
1:6999a02:         		new LDAPLoginProperty (USER_SEARCH_SUBTREE, (String)options.get(USER_SEARCH_SUBTREE)),
1:6999a02:         		new LDAPLoginProperty (ROLE_BASE, (String)options.get(ROLE_BASE)),
1:6999a02:         		new LDAPLoginProperty (ROLE_NAME, (String)options.get(ROLE_NAME)),
1:6999a02:         		new LDAPLoginProperty (ROLE_SEARCH_MATCHING, (String)options.get(ROLE_SEARCH_MATCHING)),
1:6999a02:         		new LDAPLoginProperty (ROLE_SEARCH_SUBTREE, (String)options.get(ROLE_SEARCH_SUBTREE)),
1:6999a02:         		new LDAPLoginProperty (USER_ROLE_NAME, (String)options.get(USER_ROLE_NAME)),
1:0a8e505:                 new LDAPLoginProperty (EXPAND_ROLES, (String) options.get(EXPAND_ROLES)),
1:0a8e505:                 new LDAPLoginProperty (EXPAND_ROLES_MATCHING, (String) options.get(EXPAND_ROLES_MATCHING)),
1:0a8e505: 
1:0a8e505:         };
5:a107823:     }
1:a107823: 
1:1667d80:     @Override
1:a107823:     public boolean login() throws LoginException {
1:6999a02: 
1:a107823:         Callback[] callbacks = new Callback[2];
1:a107823: 
1:a107823:         callbacks[0] = new NameCallback("User name");
1:a107823:         callbacks[1] = new PasswordCallback("Password", false);
2:a107823:         try {
1:a107823:             handler.handle(callbacks);
1:a107823:         } catch (IOException ioe) {
1:540dd5c:             throw (LoginException)new LoginException().initCause(ioe);
1:a107823:         } catch (UnsupportedCallbackException uce) {
1:540dd5c:             throw (LoginException)new LoginException().initCause(uce);
1:a107823:         }
1:6999a02:         
1:6999a02:         String password;
1:6999a02:         
1:540dd5c:         username = ((NameCallback)callbacks[0]).getName();
1:6999a02:         if (username == null)
1:6999a02:         	return false;
1:6999a02:         	
1:6999a02:         if (((PasswordCallback)callbacks[1]).getPassword() != null)
1:6999a02:         	password = new String(((PasswordCallback)callbacks[1]).getPassword());
1:6999a02:         else
1:6999a02:         	password="";
1:a107823: 
1:e1ce619:         // authenticate will throw LoginException
1:e1ce619:         // in case of failed authentication
1:e1ce619:         authenticate(username, password);
1:e1ce619:         return true;
1:a107823:     }
1:a107823: 
1:1667d80:     @Override
1:a107823:     public boolean logout() throws LoginException {
1:a107823:         username = null;
2:a107823:         return true;
1:a107823:     }
1:a107823: 
1:1667d80:     @Override
1:a107823:     public boolean commit() throws LoginException {
1:540dd5c:         Set<Principal> principals = subject.getPrincipals();
1:a107823:         principals.add(new UserPrincipal(username));
1:1667d80:         for (GroupPrincipal gp : groups) {
1:1667d80:             principals.add(gp);
1:a107823:         }
1:a107823:         return true;
1:a107823:     }
1:a107823: 
1:1667d80:     @Override
1:a107823:     public boolean abort() throws LoginException {
1:a107823:         username = null;
1:a107823:         return true;
1:a107823:     }
1:a107823: 
1:a107823:     protected void close(DirContext context) {
1:a107823:         try {
1:a107823:             context.close();
2:a107823:         } catch (Exception e) {
1:8bf987b:             log.error(e.toString());
1:a107823:         }
1:a107823:     }
1:a107823: 
1:e1ce619:     protected boolean authenticate(String username, String password) throws LoginException {
1:a107823: 
1:6999a02:         MessageFormat userSearchMatchingFormat;
1:6999a02:         boolean userSearchSubtreeBool;
1:6999a02:         
1:a107823:         DirContext context = null;
1:e1ce619: 
1:e1ce619:         if (log.isDebugEnabled()) {
1:e1ce619:             log.debug("Create the LDAP initial context.");
1:e1ce619:         }
1:e1ce619:         try {
1:e1ce619:             context = open();
1:e1ce619:         } catch (NamingException ne) {
1:e1ce619:             FailedLoginException ex = new FailedLoginException("Error opening LDAP connection");
1:e1ce619:             ex.initCause(ne);
1:e1ce619:             throw ex;
1:e1ce619:         }
1:6999a02:         
1:6999a02:         if (!isLoginPropertySet(USER_SEARCH_MATCHING))
1:6999a02:         	return false;
1:6999a02: 
1:6999a02:         userSearchMatchingFormat = new MessageFormat(getLDAPPropertyValue(USER_SEARCH_MATCHING));
1:6999a02:         userSearchSubtreeBool = Boolean.valueOf(getLDAPPropertyValue(USER_SEARCH_SUBTREE)).booleanValue();
1:a107823: 
1:a107823:         try {
1:a107823: 
1:540dd5c:             String filter = userSearchMatchingFormat.format(new String[] {
1:0b5231a:                 doRFC2254Encoding(username)
1:540dd5c:             });
1:a107823:             SearchControls constraints = new SearchControls();
1:a107823:             if (userSearchSubtreeBool) {
1:a107823:                 constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
2:a107823:             } else {
1:a107823:                 constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
1:a107823:             }
1:a107823: 
1:540dd5c:             // setup attributes
1:1667d80:             List<String> list = new ArrayList<String>();
1:6999a02:             if (isLoginPropertySet(USER_ROLE_NAME)) {
1:6999a02:                 list.add(getLDAPPropertyValue(USER_ROLE_NAME));
1:a107823:             }
1:a107823:             String[] attribs = new String[list.size()];
1:a107823:             list.toArray(attribs);
1:a107823:             constraints.setReturningAttributes(attribs);
1:a107823: 
1:e1ce619:             if (log.isDebugEnabled()) {
1:e1ce619:                 log.debug("Get the user DN.");
1:e1ce619:                 log.debug("Looking for the user in LDAP with ");
1:e1ce619:                 log.debug("  base DN: " + getLDAPPropertyValue(USER_BASE));
1:e1ce619:                 log.debug("  filter: " + filter);
1:e1ce619:             }
1:e1ce619: 
1:1667d80:             NamingEnumeration<SearchResult> results = context.search(getLDAPPropertyValue(USER_BASE), filter, constraints);
1:a107823: 
1:a107823:             if (results == null || !results.hasMore()) {
1:e1ce619:                 log.warn("User " + username + " not found in LDAP.");
1:e1ce619:                 throw new FailedLoginException("User " + username + " not found in LDAP.");
1:a107823:             }
1:a107823: 
1:1667d80:             SearchResult result = results.next();
1:a107823: 
1:a107823:             if (results.hasMore()) {
1:540dd5c:                 // ignore for now
1:a107823:             }
1:20747ee: 
1:20747ee:             String dn;
1:20747ee:             if (result.isRelative()) {
1:20747ee:                 log.debug("LDAP returned a relative name: {}", result.getName());
1:20747ee: 
1:20747ee:                 NameParser parser = context.getNameParser("");
1:20747ee:                 Name contextName = parser.parse(context.getNameInNamespace());
1:20747ee:                 Name baseName = parser.parse(getLDAPPropertyValue(USER_BASE));
1:20747ee:                 Name entryName = parser.parse(result.getName());
1:20747ee:                 Name name = contextName.addAll(baseName);
1:20747ee:                 name = name.addAll(entryName);
1:20747ee:                 dn = name.toString();
1:20747ee:             } else {
1:20747ee:                 log.debug("LDAP returned an absolute name: {}", result.getName());
1:20747ee: 
1:20747ee:                 try {
1:20747ee:                     URI uri = new URI(result.getName());
1:20747ee:                     String path = uri.getPath();
1:20747ee: 
1:20747ee:                     if (path.startsWith("/")) {
1:20747ee:                         dn = path.substring(1);
1:20747ee:                     } else {
1:20747ee:                         dn = path;
1:20747ee:                     }
1:20747ee:                 } catch (URISyntaxException e) {
1:20747ee:                     if (context != null) {
1:20747ee:                         close(context);
1:20747ee:                     }
1:20747ee:                     FailedLoginException ex = new FailedLoginException("Error parsing absolute name as URI.");
1:20747ee:                     ex.initCause(e);
1:20747ee:                     throw ex;
1:20747ee:                 }
1:20747ee:             }
1:20747ee: 
1:20747ee:             if (log.isDebugEnabled()) {
1:20747ee:                 log.debug("Using DN [" + dn + "] for binding.");
1:20747ee:             }
1:a107823: 
1:a107823:             Attributes attrs = result.getAttributes();
1:a107823:             if (attrs == null) {
1:e1ce619:                 throw new FailedLoginException("User found, but LDAP entry malformed: " + username);
1:a107823:             }
1:1667d80:             List<String> roles = null;
1:6999a02:             if (isLoginPropertySet(USER_ROLE_NAME)) {
1:6999a02:                 roles = addAttributeValues(getLDAPPropertyValue(USER_ROLE_NAME), attrs, roles);
1:a107823:             }
1:a107823: 
1:540dd5c:             // check the credentials by binding to server
1:a107823:             if (bindUser(context, dn, password)) {
1:540dd5c:                 // if authenticated add more roles
1:a107823:                 roles = getRoles(context, dn, username, roles);
1:e1ce619:                 if (log.isDebugEnabled()) {
1:e1ce619:                     log.debug("Roles " + roles + " for user " + username);
1:e1ce619:                 }
1:a107823:                 for (int i = 0; i < roles.size(); i++) {
1:540dd5c:                     groups.add(new GroupPrincipal(roles.get(i)));
1:a107823:                 }
1:a107823:             } else {
1:e1ce619:                 throw new FailedLoginException("Password does not match for user: " + username);
1:a107823:             }
1:a107823:         } catch (CommunicationException e) {
1:e1ce619:             FailedLoginException ex = new FailedLoginException("Error contacting LDAP");
1:e1ce619:             ex.initCause(e);
1:e1ce619:             throw ex;
1:a107823:         } catch (NamingException e) {
2:a107823:             if (context != null) {
1:a107823:                 close(context);
1:a107823:             }
1:e1ce619:             FailedLoginException ex = new FailedLoginException("Error contacting LDAP");
1:e1ce619:             ex.initCause(e);
1:e1ce619:             throw ex;
1:a107823:         }
1:a107823: 
1:a107823:         return true;
1:a107823:     }
1:a107823: 
1:1667d80:     protected List<String> getRoles(DirContext context, String dn, String username, List<String> currentRoles) throws NamingException {
1:1667d80:         List<String> list = currentRoles;
1:6999a02:         MessageFormat roleSearchMatchingFormat;
1:6999a02:         boolean roleSearchSubtreeBool;
1:0a8e505:         boolean expandRolesBool;
1:6999a02:         roleSearchMatchingFormat = new MessageFormat(getLDAPPropertyValue(ROLE_SEARCH_MATCHING));
1:6999a02:         roleSearchSubtreeBool = Boolean.valueOf(getLDAPPropertyValue(ROLE_SEARCH_SUBTREE)).booleanValue();
1:0a8e505:         expandRolesBool = Boolean.valueOf(getLDAPPropertyValue(EXPAND_ROLES)).booleanValue();
1:6999a02:         
1:a107823:         if (list == null) {
1:540dd5c:             list = new ArrayList<String>();
1:a107823:         }
1:6999a02:         if (!isLoginPropertySet(ROLE_NAME)) {
1:a107823:             return list;
1:a107823:         }
1:540dd5c:         String filter = roleSearchMatchingFormat.format(new String[] {
1:0b5231a:             doRFC2254Encoding(dn), doRFC2254Encoding(username)
1:540dd5c:         });
1:a107823: 
1:a107823:         SearchControls constraints = new SearchControls();
1:a107823:         if (roleSearchSubtreeBool) {
1:a107823:             constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
1:a107823:         } else {
1:a107823:             constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
1:a107823:         }
1:e1ce619:         if (log.isDebugEnabled()) {
1:e1ce619:             log.debug("Get user roles.");
1:e1ce619:             log.debug("Looking for the user roles in LDAP with ");
1:e1ce619:             log.debug("  base DN: " + getLDAPPropertyValue(ROLE_BASE));
1:e1ce619:             log.debug("  filter: " + filter);
1:e1ce619:         }
1:0a8e505:         HashSet<String> haveSeenNames = new HashSet<String>();
1:0a8e505:         Queue<String> pendingNameExpansion = new LinkedList<String>();
1:1667d80:         NamingEnumeration<SearchResult> results = context.search(getLDAPPropertyValue(ROLE_BASE), filter, constraints);
1:a107823:         while (results.hasMore()) {
1:1667d80:             SearchResult result = results.next();
1:a107823:             Attributes attrs = result.getAttributes();
1:0a8e505:             if (expandRolesBool) {
1:0a8e505:                 haveSeenNames.add(result.getNameInNamespace());
1:0a8e505:                 pendingNameExpansion.add(result.getNameInNamespace());
1:0a8e505:             }
1:a107823:             if (attrs == null) {
1:a107823:                 continue;
1:a107823:             }
1:6999a02:             list = addAttributeValues(getLDAPPropertyValue(ROLE_NAME), attrs, list);
1:a107823:         }
1:0a8e505:         if (expandRolesBool) {
1:0a8e505:             MessageFormat expandRolesMatchingFormat = new MessageFormat(getLDAPPropertyValue(EXPAND_ROLES_MATCHING));
1:0a8e505:             while (!pendingNameExpansion.isEmpty()) {
1:0a8e505:                 String name = pendingNameExpansion.remove();
1:0a8e505:                 filter = expandRolesMatchingFormat.format(new String[]{name});
1:0a8e505:                 results = context.search(getLDAPPropertyValue(ROLE_BASE), filter, constraints);
1:0a8e505:                 while (results.hasMore()) {
1:0a8e505:                     SearchResult result = results.next();
1:0a8e505:                     name = result.getNameInNamespace();
1:0a8e505:                     if (!haveSeenNames.contains(name)) {
1:0a8e505:                         Attributes attrs = result.getAttributes();
1:0a8e505:                         list = addAttributeValues(getLDAPPropertyValue(ROLE_NAME), attrs, list);
1:0a8e505:                         haveSeenNames.add(name);
1:0a8e505:                         pendingNameExpansion.add(name);
1:0a8e505:                     }
1:0a8e505:                 }
1:0a8e505:             }
1:0a8e505:         }
1:a107823:         return list;
1:a107823:     }
1:a107823: 
1:a107823:     protected String doRFC2254Encoding(String inputString) {
1:a107823:         StringBuffer buf = new StringBuffer(inputString.length());
1:a107823:         for (int i = 0; i < inputString.length(); i++) {
1:a107823:             char c = inputString.charAt(i);
1:a107823:             switch (c) {
1:540dd5c:             case '\\':
1:540dd5c:                 buf.append("\\5c");
1:540dd5c:                 break;
1:540dd5c:             case '*':
1:540dd5c:                 buf.append("\\2a");
1:540dd5c:                 break;
1:540dd5c:             case '(':
1:540dd5c:                 buf.append("\\28");
1:540dd5c:                 break;
1:540dd5c:             case ')':
1:540dd5c:                 buf.append("\\29");
1:540dd5c:                 break;
1:540dd5c:             case '\0':
1:540dd5c:                 buf.append("\\00");
1:540dd5c:                 break;
1:540dd5c:             default:
1:540dd5c:                 buf.append(c);
1:540dd5c:                 break;
1:a107823:             }
1:a107823:         }
1:a107823:         return buf.toString();
1:a107823:     }
1:a107823: 
1:a107823:     protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {
1:a107823:         boolean isValid = false;
1:a107823: 
1:e1ce619:         if (log.isDebugEnabled()) {
1:e1ce619:             log.debug("Binding the user.");
1:e1ce619:         }
1:a107823:         context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);
1:a107823:         context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);
1:a107823:         try {
1:a107823:             context.getAttributes("", null);
1:a107823:             isValid = true;
1:e1ce619:             if (log.isDebugEnabled()) {
1:e1ce619:                 log.debug("User " + dn + " successfully bound.");
1:e1ce619:             }
1:a107823:         } catch (AuthenticationException e) {
1:a107823:             isValid = false;
1:e1ce619:             if (log.isDebugEnabled()) {
1:e1ce619:                 log.debug("Authentication failed for dn=" + dn);
1:e1ce619:             }
1:a107823:         }
1:a107823: 
1:6999a02:         if (isLoginPropertySet(CONNECTION_USERNAME)) {
1:6999a02:             context.addToEnvironment(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));
1:a107823:         } else {
1:a107823:             context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);
1:a107823:         }
1:6999a02:         if (isLoginPropertySet(CONNECTION_PASSWORD)) {
1:6999a02:             context.addToEnvironment(Context.SECURITY_CREDENTIALS, getLDAPPropertyValue(CONNECTION_PASSWORD));
1:a107823:         } else {
1:a107823:             context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);
1:a107823:         }
1:a107823: 
1:a107823:         return isValid;
1:a107823:     }
1:a107823: 
1:1667d80:     private List<String> addAttributeValues(String attrId, Attributes attrs, List<String> values) throws NamingException {
1:a107823: 
1:a107823:         if (attrId == null || attrs == null) {
1:a107823:             return values;
1:a107823:         }
1:a107823:         if (values == null) {
1:540dd5c:             values = new ArrayList<String>();
1:a107823:         }
1:a107823:         Attribute attr = attrs.get(attrId);
1:a107823:         if (attr == null) {
1:540dd5c:             return values;
1:a107823:         }
1:1667d80:         NamingEnumeration<?> e = attr.getAll();
1:a107823:         while (e.hasMore()) {
1:540dd5c:             String value = (String)e.next();
1:a107823:             values.add(value);
1:a107823:         }
1:a107823:         return values;
1:a107823:     }
1:a107823: 
1:a107823:     protected DirContext open() throws NamingException {
1:a107823:         try {
1:540dd5c:             Hashtable<String, String> env = new Hashtable<String, String>();
1:6999a02:             env.put(Context.INITIAL_CONTEXT_FACTORY, getLDAPPropertyValue(INITIAL_CONTEXT_FACTORY));
1:6999a02:             if (isLoginPropertySet(CONNECTION_USERNAME)) {
1:6999a02:                 env.put(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));
1:0b5231a:             } else {
1:0b5231a:                 throw new NamingException("Empty username is not allowed");
1:a107823:             }
1:0b5231a: 
1:6999a02:             if (isLoginPropertySet(CONNECTION_PASSWORD)) {
1:6999a02:                 env.put(Context.SECURITY_CREDENTIALS, getLDAPPropertyValue(CONNECTION_PASSWORD));
1:0b5231a:             } else {
1:0b5231a:                 throw new NamingException("Empty password is not allowed");
1:a107823:             }
1:6999a02:             env.put(Context.SECURITY_PROTOCOL, getLDAPPropertyValue(CONNECTION_PROTOCOL));
1:6999a02:             env.put(Context.PROVIDER_URL, getLDAPPropertyValue(CONNECTION_URL));
1:6999a02:             env.put(Context.SECURITY_AUTHENTICATION, getLDAPPropertyValue(AUTHENTICATION));
1:a107823:             context = new InitialDirContext(env);
1:a107823: 
1:a107823:         } catch (NamingException e) {
1:8bf987b:             log.error(e.toString());
1:a107823:             throw e;
1:a107823:         }
2:a107823:         return context;
1:a107823:     }
1:6999a02:     
1:6999a02:     private String getLDAPPropertyValue (String propertyName){
1:6999a02:     	for (int i=0; i < config.length; i++ )
1:6999a02:     		if (config[i].getPropertyName() == propertyName)
1:6999a02:     			return config[i].getPropertyValue();
1:6999a02:     	return null;
1:6999a02:     }
1:6999a02:     
1:6999a02:     private boolean isLoginPropertySet(String propertyName) {
1:6999a02:     	for (int i=0; i < config.length; i++ ) {
1:0b5231a:     		if (config[i].getPropertyName() == propertyName && (config[i].getPropertyValue() != null && !"".equals(config[i].getPropertyValue())))
1:6999a02:     				return true;
1:6999a02:     	}
1:6999a02:     	return false;
1:6999a02:     }
1:a107823: 
1:a107823: }
============================================================================
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:0b5231a
/////////////////////////////////////////////////////////////////////////
1:                 doRFC2254Encoding(username)
/////////////////////////////////////////////////////////////////////////
1:             doRFC2254Encoding(dn), doRFC2254Encoding(username)
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 throw new NamingException("Empty username is not allowed");
1: 
1:             } else {
1:                 throw new NamingException("Empty password is not allowed");
/////////////////////////////////////////////////////////////////////////
1:     		if (config[i].getPropertyName() == propertyName && (config[i].getPropertyValue() != null && !"".equals(config[i].getPropertyValue())))
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:20747ee
/////////////////////////////////////////////////////////////////////////
1: import java.net.URI;
1: import java.net.URISyntaxException;
/////////////////////////////////////////////////////////////////////////
1: 
1:             String dn;
1:             if (result.isRelative()) {
1:                 log.debug("LDAP returned a relative name: {}", result.getName());
1: 
1:                 NameParser parser = context.getNameParser("");
1:                 Name contextName = parser.parse(context.getNameInNamespace());
1:                 Name baseName = parser.parse(getLDAPPropertyValue(USER_BASE));
1:                 Name entryName = parser.parse(result.getName());
1:                 Name name = contextName.addAll(baseName);
1:                 name = name.addAll(entryName);
1:                 dn = name.toString();
1:             } else {
1:                 log.debug("LDAP returned an absolute name: {}", result.getName());
1: 
1:                 try {
1:                     URI uri = new URI(result.getName());
1:                     String path = uri.getPath();
1: 
1:                     if (path.startsWith("/")) {
1:                         dn = path.substring(1);
1:                     } else {
1:                         dn = path;
1:                     }
1:                 } catch (URISyntaxException e) {
1:                     if (context != null) {
1:                         close(context);
1:                     }
1:                     FailedLoginException ex = new FailedLoginException("Error parsing absolute name as URI.");
1:                     ex.initCause(e);
1:                     throw ex;
1:                 }
1:             }
1: 
1:             if (log.isDebugEnabled()) {
1:                 log.debug("Using DN [" + dn + "] for binding.");
1:             }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:0a8e505
/////////////////////////////////////////////////////////////////////////
1: import java.util.*;
1: import javax.naming.*;
/////////////////////////////////////////////////////////////////////////
1:     private static final String EXPAND_ROLES = "expandRoles";
1:     private static final String EXPAND_ROLES_MATCHING = "expandRolesMatching";
/////////////////////////////////////////////////////////////////////////
1:                 new LDAPLoginProperty (EXPAND_ROLES, (String) options.get(EXPAND_ROLES)),
1:                 new LDAPLoginProperty (EXPAND_ROLES_MATCHING, (String) options.get(EXPAND_ROLES_MATCHING)),
1: 
1:         };
/////////////////////////////////////////////////////////////////////////
1:         boolean expandRolesBool;
1:         expandRolesBool = Boolean.valueOf(getLDAPPropertyValue(EXPAND_ROLES)).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:         HashSet<String> haveSeenNames = new HashSet<String>();
1:         Queue<String> pendingNameExpansion = new LinkedList<String>();
1:             if (expandRolesBool) {
1:                 haveSeenNames.add(result.getNameInNamespace());
1:                 pendingNameExpansion.add(result.getNameInNamespace());
1:             }
1:         if (expandRolesBool) {
1:             MessageFormat expandRolesMatchingFormat = new MessageFormat(getLDAPPropertyValue(EXPAND_ROLES_MATCHING));
1:             while (!pendingNameExpansion.isEmpty()) {
1:                 String name = pendingNameExpansion.remove();
1:                 filter = expandRolesMatchingFormat.format(new String[]{name});
1:                 results = context.search(getLDAPPropertyValue(ROLE_BASE), filter, constraints);
1:                 while (results.hasMore()) {
1:                     SearchResult result = results.next();
1:                     name = result.getNameInNamespace();
1:                     if (!haveSeenNames.contains(name)) {
1:                         Attributes attrs = result.getAttributes();
1:                         list = addAttributeValues(getLDAPPropertyValue(ROLE_NAME), attrs, list);
1:                         haveSeenNames.add(name);
1:                         pendingNameExpansion.add(name);
1:                     }
1:                 }
1:             }
1:         }
commit:e1ce619
/////////////////////////////////////////////////////////////////////////
1:         // authenticate will throw LoginException
1:         // in case of failed authentication
1:         authenticate(username, password);
1:         return true;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean authenticate(String username, String password) throws LoginException {
1: 
1:         if (log.isDebugEnabled()) {
1:             log.debug("Create the LDAP initial context.");
1:         }
1:         try {
1:             context = open();
1:         } catch (NamingException ne) {
1:             FailedLoginException ex = new FailedLoginException("Error opening LDAP connection");
1:             ex.initCause(ne);
1:             throw ex;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (log.isDebugEnabled()) {
1:                 log.debug("Get the user DN.");
1:                 log.debug("Looking for the user in LDAP with ");
1:                 log.debug("  base DN: " + getLDAPPropertyValue(USER_BASE));
1:                 log.debug("  filter: " + filter);
1:             }
1: 
1:                 log.warn("User " + username + " not found in LDAP.");
1:                 throw new FailedLoginException("User " + username + " not found in LDAP.");
/////////////////////////////////////////////////////////////////////////
1:                 throw new FailedLoginException("User found, but LDAP entry malformed: " + username);
/////////////////////////////////////////////////////////////////////////
1:                 if (log.isDebugEnabled()) {
1:                     log.debug("Roles " + roles + " for user " + username);
1:                 }
1:                 throw new FailedLoginException("Password does not match for user: " + username);
1:             FailedLoginException ex = new FailedLoginException("Error contacting LDAP");
1:             ex.initCause(e);
1:             throw ex;
1:             FailedLoginException ex = new FailedLoginException("Error contacting LDAP");
1:             ex.initCause(e);
1:             throw ex;
/////////////////////////////////////////////////////////////////////////
1:         if (log.isDebugEnabled()) {
1:             log.debug("Get user roles.");
1:             log.debug("Looking for the user roles in LDAP with ");
1:             log.debug("  base DN: " + getLDAPPropertyValue(ROLE_BASE));
1:             log.debug("  filter: " + filter);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (log.isDebugEnabled()) {
1:             log.debug("Binding the user.");
1:         }
1:             if (log.isDebugEnabled()) {
1:                 log.debug("User " + dn + " successfully bound.");
1:             }
1:             if (log.isDebugEnabled()) {
1:                 log.debug("Authentication failed for dn=" + dn);
1:             }
/////////////////////////////////////////////////////////////////////////
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static Logger log = LoggerFactory.getLogger(LDAPLoginModule.class);
/////////////////////////////////////////////////////////////////////////
1:             log.error(e.toString());
/////////////////////////////////////////////////////////////////////////
1:             log.error(e.toString());
commit:6999a02
/////////////////////////////////////////////////////////////////////////
1:     private CallbackHandler handler;  
1:     private LDAPLoginProperty [] config;
1:         
1:         config = new LDAPLoginProperty [] {
1:         		new LDAPLoginProperty (INITIAL_CONTEXT_FACTORY, (String)options.get(INITIAL_CONTEXT_FACTORY)),
1:         		new LDAPLoginProperty (CONNECTION_URL, (String)options.get(CONNECTION_URL)),
1:         		new LDAPLoginProperty (CONNECTION_USERNAME, (String)options.get(CONNECTION_USERNAME)),
1:         		new LDAPLoginProperty (CONNECTION_PASSWORD, (String)options.get(CONNECTION_PASSWORD)),
1:         		new LDAPLoginProperty (CONNECTION_PROTOCOL, (String)options.get(CONNECTION_PROTOCOL)),
1:         		new LDAPLoginProperty (AUTHENTICATION, (String)options.get(AUTHENTICATION)),
1:         		new LDAPLoginProperty (USER_BASE, (String)options.get(USER_BASE)),
1:         		new LDAPLoginProperty (USER_SEARCH_MATCHING, (String)options.get(USER_SEARCH_MATCHING)),
1:         		new LDAPLoginProperty (USER_SEARCH_SUBTREE, (String)options.get(USER_SEARCH_SUBTREE)),
1:         		new LDAPLoginProperty (ROLE_BASE, (String)options.get(ROLE_BASE)),
1:         		new LDAPLoginProperty (ROLE_NAME, (String)options.get(ROLE_NAME)),
1:         		new LDAPLoginProperty (ROLE_SEARCH_MATCHING, (String)options.get(ROLE_SEARCH_MATCHING)),
1:         		new LDAPLoginProperty (ROLE_SEARCH_SUBTREE, (String)options.get(ROLE_SEARCH_SUBTREE)),
1:         		new LDAPLoginProperty (USER_ROLE_NAME, (String)options.get(USER_ROLE_NAME)),
0:         		};
1: 
/////////////////////////////////////////////////////////////////////////
1:         
1:         String password;
1:         
1:         if (username == null)
1:         	return false;
1:         	
1:         if (((PasswordCallback)callbacks[1]).getPassword() != null)
1:         	password = new String(((PasswordCallback)callbacks[1]).getPassword());
1:         else
1:         	password="";
/////////////////////////////////////////////////////////////////////////
1:         MessageFormat userSearchMatchingFormat;
1:         boolean userSearchSubtreeBool;
1:         
1:         
1:         if (!isLoginPropertySet(USER_SEARCH_MATCHING))
1:         	return false;
1: 
1:         userSearchMatchingFormat = new MessageFormat(getLDAPPropertyValue(USER_SEARCH_MATCHING));
1:         userSearchSubtreeBool = Boolean.valueOf(getLDAPPropertyValue(USER_SEARCH_SUBTREE)).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:             if (isLoginPropertySet(USER_ROLE_NAME)) {
1:                 list.add(getLDAPPropertyValue(USER_ROLE_NAME));
0:             NamingEnumeration results = context.search(getLDAPPropertyValue(USER_BASE), filter, constraints);
/////////////////////////////////////////////////////////////////////////
0:             Name baseName = parser.parse(getLDAPPropertyValue(USER_BASE));
/////////////////////////////////////////////////////////////////////////
1:             if (isLoginPropertySet(USER_ROLE_NAME)) {
1:                 roles = addAttributeValues(getLDAPPropertyValue(USER_ROLE_NAME), attrs, roles);
/////////////////////////////////////////////////////////////////////////
1:         MessageFormat roleSearchMatchingFormat;
1:         boolean roleSearchSubtreeBool;
1:         roleSearchMatchingFormat = new MessageFormat(getLDAPPropertyValue(ROLE_SEARCH_MATCHING));
1:         roleSearchSubtreeBool = Boolean.valueOf(getLDAPPropertyValue(ROLE_SEARCH_SUBTREE)).booleanValue();
1:         
1:         if (!isLoginPropertySet(ROLE_NAME)) {
/////////////////////////////////////////////////////////////////////////
0:         NamingEnumeration results = context.search(getLDAPPropertyValue(ROLE_BASE), filter, constraints);
1:             list = addAttributeValues(getLDAPPropertyValue(ROLE_NAME), attrs, list);
/////////////////////////////////////////////////////////////////////////
1:         if (isLoginPropertySet(CONNECTION_USERNAME)) {
1:             context.addToEnvironment(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));
1:         if (isLoginPropertySet(CONNECTION_PASSWORD)) {
1:             context.addToEnvironment(Context.SECURITY_CREDENTIALS, getLDAPPropertyValue(CONNECTION_PASSWORD));
/////////////////////////////////////////////////////////////////////////
1:             env.put(Context.INITIAL_CONTEXT_FACTORY, getLDAPPropertyValue(INITIAL_CONTEXT_FACTORY));
1:             if (isLoginPropertySet(CONNECTION_USERNAME)) {
1:                 env.put(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));
1:             if (isLoginPropertySet(CONNECTION_PASSWORD)) {
1:                 env.put(Context.SECURITY_CREDENTIALS, getLDAPPropertyValue(CONNECTION_PASSWORD));
1:             env.put(Context.SECURITY_PROTOCOL, getLDAPPropertyValue(CONNECTION_PROTOCOL));
1:             env.put(Context.PROVIDER_URL, getLDAPPropertyValue(CONNECTION_URL));
1:             env.put(Context.SECURITY_AUTHENTICATION, getLDAPPropertyValue(AUTHENTICATION));
/////////////////////////////////////////////////////////////////////////
1:     
1:     private String getLDAPPropertyValue (String propertyName){
1:     	for (int i=0; i < config.length; i++ )
1:     		if (config[i].getPropertyName() == propertyName)
1:     			return config[i].getPropertyValue();
1:     	return null;
1:     }
1:     
1:     private boolean isLoginPropertySet(String propertyName) {
1:     	for (int i=0; i < config.length; i++ ) {
0:     		if (config[i].getPropertyName() == propertyName && config[i].getPropertyValue() != null)
1:     				return true;
1:     	}
1:     	return false;
1:     }
author:Gary Tully
-------------------------------------------------------------------------------
commit:1667d80
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
1:         for (GroupPrincipal gp : groups) {
1:             principals.add(gp);
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             List<String> list = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:             NamingEnumeration<SearchResult> results = context.search(getLDAPPropertyValue(USER_BASE), filter, constraints);
1:             SearchResult result = results.next();
/////////////////////////////////////////////////////////////////////////
1:             List<String> roles = null;
/////////////////////////////////////////////////////////////////////////
1:     protected List<String> getRoles(DirContext context, String dn, String username, List<String> currentRoles) throws NamingException {
1:         List<String> list = currentRoles;
/////////////////////////////////////////////////////////////////////////
1:         NamingEnumeration<SearchResult> results = context.search(getLDAPPropertyValue(ROLE_BASE), filter, constraints);
1:             SearchResult result = results.next();
/////////////////////////////////////////////////////////////////////////
1:     private List<String> addAttributeValues(String attrId, Attributes attrs, List<String> values) throws NamingException {
/////////////////////////////////////////////////////////////////////////
1:         NamingEnumeration<?> e = attr.getAll();
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:540dd5c
/////////////////////////////////////////////////////////////////////////
1: import java.security.Principal;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import javax.security.auth.login.LoginException;
/////////////////////////////////////////////////////////////////////////
0:     private static Log log = LogFactory.getLog(LDAPLoginModule.class);
1: 
1:     protected DirContext context;
1: 
1:     private Subject subject;
0:     private CallbackHandler handler;
/////////////////////////////////////////////////////////////////////////
0:     private boolean userSearchSubtreeBool;
0:     private boolean roleSearchSubtreeBool;
1:     private Set<GroupPrincipal> groups = new HashSet<GroupPrincipal>();
0:         initialContextFactory = (String)options.get(INITIAL_CONTEXT_FACTORY);
0:         connectionURL = (String)options.get(CONNECTION_URL);
0:         connectionUsername = (String)options.get(CONNECTION_USERNAME);
0:         connectionPassword = (String)options.get(CONNECTION_PASSWORD);
0:         connectionProtocol = (String)options.get(CONNECTION_PROTOCOL);
0:         authentication = (String)options.get(AUTHENTICATION);
0:         userBase = (String)options.get(USER_BASE);
0:         String userSearchMatching = (String)options.get(USER_SEARCH_MATCHING);
0:         String userSearchSubtree = (String)options.get(USER_SEARCH_SUBTREE);
0:         roleBase = (String)options.get(ROLE_BASE);
0:         roleName = (String)options.get(ROLE_NAME);
0:         String roleSearchMatching = (String)options.get(ROLE_SEARCH_MATCHING);
0:         String roleSearchSubtree = (String)options.get(ROLE_SEARCH_SUBTREE);
0:         userRoleName = (String)options.get(USER_ROLE_NAME);
/////////////////////////////////////////////////////////////////////////
1:             throw (LoginException)new LoginException().initCause(ioe);
1:             throw (LoginException)new LoginException().initCause(uce);
1:         username = ((NameCallback)callbacks[0]).getName();
0:         String password = new String(((PasswordCallback)callbacks[1]).getPassword());
/////////////////////////////////////////////////////////////////////////
0:             if (!result) {
0:             throw (LoginException)new LoginException("LDAP Error").initCause(e);
/////////////////////////////////////////////////////////////////////////
1:         Set<Principal> principals = subject.getPrincipals();
0:         Iterator<GroupPrincipal> iter = groups.iterator();
/////////////////////////////////////////////////////////////////////////
1:             String filter = userSearchMatchingFormat.format(new String[] {
0:                 username
1:             });
/////////////////////////////////////////////////////////////////////////
1:             // setup attributes
0:             ArrayList<String> list = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
0:             SearchResult result = (SearchResult)results.next();
1:                 // ignore for now
/////////////////////////////////////////////////////////////////////////
0:             ArrayList<String> roles = null;
1:             // check the credentials by binding to server
1:                 // if authenticated add more roles
1:                     groups.add(new GroupPrincipal(roles.get(i)));
/////////////////////////////////////////////////////////////////////////
0:     protected ArrayList<String> getRoles(DirContext context, String dn, String username, ArrayList<String> currentRoles) throws NamingException {
0:         ArrayList<String> list = currentRoles;
1:             list = new ArrayList<String>();
1:         String filter = roleSearchMatchingFormat.format(new String[] {
0:             doRFC2254Encoding(dn), username
1:         });
/////////////////////////////////////////////////////////////////////////
0:         NamingEnumeration results = context.search(roleBase, filter, constraints);
0:             SearchResult result = (SearchResult)results.next();
/////////////////////////////////////////////////////////////////////////
1:             case '\\':
1:                 buf.append("\\5c");
1:                 break;
1:             case '*':
1:                 buf.append("\\2a");
1:                 break;
1:             case '(':
1:                 buf.append("\\28");
1:                 break;
1:             case ')':
1:                 buf.append("\\29");
1:                 break;
1:             case '\0':
1:                 buf.append("\\00");
1:                 break;
1:             default:
1:                 buf.append(c);
1:                 break;
/////////////////////////////////////////////////////////////////////////
0:             context.addToEnvironment(Context.SECURITY_PRINCIPAL, connectionUsername);
0:             context.addToEnvironment(Context.SECURITY_CREDENTIALS, connectionPassword);
/////////////////////////////////////////////////////////////////////////
0:     private ArrayList<String> addAttributeValues(String attrId, Attributes attrs, ArrayList<String> values) throws NamingException {
1:             values = new ArrayList<String>();
1:             return values;
1:             String value = (String)e.next();
/////////////////////////////////////////////////////////////////////////
1:             Hashtable<String, String> env = new Hashtable<String, String>();
commit:5f1adbe
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  *      http://www.apache.org/licenses/LICENSE-2.0
commit:57b4941
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:a107823
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
0:  * Copyright 2005-2006 The Apache Software Foundation
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.jaas;
1: 
1: import java.io.IOException;
1: import java.text.MessageFormat;
0: import java.util.ArrayList;
0: import java.util.HashSet;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.Map;
0: import java.util.Set;
0: import javax.naming.AuthenticationException;
0: import javax.naming.CommunicationException;
0: import javax.naming.Context;
0: import javax.naming.Name;
0: import javax.naming.NameParser;
0: import javax.naming.NamingEnumeration;
0: import javax.naming.NamingException;
1: import javax.naming.directory.Attribute;
1: import javax.naming.directory.Attributes;
1: import javax.naming.directory.DirContext;
1: import javax.naming.directory.InitialDirContext;
1: import javax.naming.directory.SearchControls;
1: import javax.naming.directory.SearchResult;
1: import javax.security.auth.Subject;
1: import javax.security.auth.callback.Callback;
1: import javax.security.auth.callback.CallbackHandler;
1: import javax.security.auth.callback.NameCallback;
1: import javax.security.auth.callback.PasswordCallback;
1: import javax.security.auth.callback.UnsupportedCallbackException;
0: import javax.security.auth.login.LoginException;
1: import javax.security.auth.login.FailedLoginException;
1: import javax.security.auth.spi.LoginModule;
1: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
1: 
1: 
1: /**
1:  * @version $Rev: $ $Date: $
1:  */
1: public class LDAPLoginModule implements LoginModule {
1: 
0:     private static Log log = LogFactory.getLog(LDAPLoginModule.class);
1: 
0:     private Subject subject;
0:     private CallbackHandler handler;
1: 
1:     private static final String INITIAL_CONTEXT_FACTORY = "initialContextFactory";
1:     private static final String CONNECTION_URL = "connectionURL";
1:     private static final String CONNECTION_USERNAME = "connectionUsername";
1:     private static final String CONNECTION_PASSWORD = "connectionPassword";
1:     private static final String CONNECTION_PROTOCOL = "connectionProtocol";
1:     private static final String AUTHENTICATION = "authentication";
1:     private static final String USER_BASE = "userBase";
1:     private static final String USER_SEARCH_MATCHING = "userSearchMatching";
1:     private static final String USER_SEARCH_SUBTREE = "userSearchSubtree";
1:     private static final String ROLE_BASE = "roleBase";
1:     private static final String ROLE_NAME = "roleName";
1:     private static final String ROLE_SEARCH_MATCHING = "roleSearchMatching";
1:     private static final String ROLE_SEARCH_SUBTREE = "roleSearchSubtree";
1:     private static final String USER_ROLE_NAME = "userRoleName";
1: 
0:     private String initialContextFactory;
0:     private String connectionURL;
0:     private String connectionUsername;
0:     private String connectionPassword;
0:     private String connectionProtocol;
0:     private String authentication;
0:     private String userBase;
0:     private String roleBase;
0:     private String roleName;
0:     private String userRoleName;
1: 
1:     private String username;
1: 
0:     protected DirContext context = null;
1: 
0:     private MessageFormat userSearchMatchingFormat;
0:     private MessageFormat roleSearchMatchingFormat;
1: 
0:     private boolean userSearchSubtreeBool = false;
0:     private boolean roleSearchSubtreeBool = false;
1: 
0:     Set groups = new HashSet();
1: 
1:     public void initialize(Subject subject, CallbackHandler callbackHandler, Map sharedState, Map options) {
1:         this.subject = subject;
1:         this.handler = callbackHandler;
0:         initialContextFactory = (String) options.get(INITIAL_CONTEXT_FACTORY);
0:         connectionURL = (String) options.get(CONNECTION_URL);
0:         connectionUsername = (String) options.get(CONNECTION_USERNAME);
0:         connectionPassword = (String) options.get(CONNECTION_PASSWORD);
0:         connectionProtocol = (String) options.get(CONNECTION_PROTOCOL);
0:         authentication = (String) options.get(AUTHENTICATION);
0:         userBase = (String) options.get(USER_BASE);
0:         String userSearchMatching = (String) options.get(USER_SEARCH_MATCHING);
0:         String userSearchSubtree = (String) options.get(USER_SEARCH_SUBTREE);
0:         roleBase = (String) options.get(ROLE_BASE);
0:         roleName = (String) options.get(ROLE_NAME);
0:         String roleSearchMatching = (String) options.get(ROLE_SEARCH_MATCHING);
0:         String roleSearchSubtree = (String) options.get(ROLE_SEARCH_SUBTREE);
0:         userRoleName = (String) options.get(USER_ROLE_NAME);
0:         userSearchMatchingFormat = new MessageFormat(userSearchMatching);
0:         roleSearchMatchingFormat = new MessageFormat(roleSearchMatching);
0:         userSearchSubtreeBool = new Boolean(userSearchSubtree).booleanValue();
0:         roleSearchSubtreeBool = new Boolean(roleSearchSubtree).booleanValue();
1:     }
1: 
1:     public boolean login() throws LoginException {
1:         Callback[] callbacks = new Callback[2];
1: 
1:         callbacks[0] = new NameCallback("User name");
1:         callbacks[1] = new PasswordCallback("Password", false);
1:         try {
1:             handler.handle(callbacks);
1:         } catch (IOException ioe) {
0:             throw (LoginException) new LoginException().initCause(ioe);
1:         } catch (UnsupportedCallbackException uce) {
0:             throw (LoginException) new LoginException().initCause(uce);
1:         }
0:         username = ((NameCallback) callbacks[0]).getName();
0:         String password = new String(((PasswordCallback) callbacks[1]).getPassword());
1: 
0:         if (username == null || "".equals(username) || password == null || "".equals(password)) {
0:             return false;
1:         }
1: 
1:         try {
0:             boolean result = authenticate(username, password);
0:             if(!result) {
0:                 throw new FailedLoginException();
1:             } else {
1:                 return true;
1:             }
1:         } catch (Exception e) {
0:             throw (LoginException) new LoginException("LDAP Error").initCause(e);
1:         }
1:     }
1: 
1:     public boolean logout() throws LoginException {
1:         username = null;
1:         return true;
1:     }
1: 
1:     public boolean commit() throws LoginException {
0:         Set principals = subject.getPrincipals();
1:         principals.add(new UserPrincipal(username));
0:         Iterator iter = groups.iterator();
0:         while (iter.hasNext()) {
0:             principals.add(iter.next());
1:         }
1:         return true;
1:     }
1: 
1:     public boolean abort() throws LoginException {
1:         username = null;
1:         return true;
1:     }
1: 
1:     protected void close(DirContext context) {
1:         try {
1:             context.close();
1:         } catch (Exception e) {
0:             log.error(e);
1:         }
1:     }
1: 
0:     protected boolean authenticate(String username, String password) throws Exception {
1: 
1:         DirContext context = null;
0:         context = open();
1: 
1:         try {
1: 
0:             String filter = userSearchMatchingFormat.format(new String[]{username});
1:             SearchControls constraints = new SearchControls();
1:             if (userSearchSubtreeBool) {
1:                 constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
1:             } else {
1:                 constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
1:             }
1: 
0:             //setup attributes
0:             ArrayList list = new ArrayList();
0:             if (userRoleName != null) {
0:                 list.add(userRoleName);
1:             }
1:             String[] attribs = new String[list.size()];
1:             list.toArray(attribs);
1:             constraints.setReturningAttributes(attribs);
1: 
1: 
0:             NamingEnumeration results = context.search(userBase, filter, constraints);
1: 
1:             if (results == null || !results.hasMore()) {
0:                 return false;
1:             }
1: 
0:             SearchResult result = (SearchResult) results.next();
1: 
1:             if (results.hasMore()) {
0:                 //ignore for now
1:             }
0:             NameParser parser = context.getNameParser("");
0:             Name contextName = parser.parse(context.getNameInNamespace());
0:             Name baseName = parser.parse(userBase);
0:             Name entryName = parser.parse(result.getName());
0:             Name name = contextName.addAll(baseName);
0:             name = name.addAll(entryName);
0:             String dn = name.toString();
1: 
1:             Attributes attrs = result.getAttributes();
1:             if (attrs == null) {
0:                 return false;
1:             }
0:             ArrayList roles = null;
0:             if (userRoleName != null) {
0:                 roles = addAttributeValues(userRoleName, attrs, roles);
1:             }
1: 
0:             //check the credentials by binding to server
1:             if (bindUser(context, dn, password)) {
0:                 //if authenticated add more roles
1:                 roles = getRoles(context, dn, username, roles);
1:                 for (int i = 0; i < roles.size(); i++) {
0:                     groups.add(new GroupPrincipal((String) roles.get(i)));
1:                 }
1:             } else {
0:                 return false;
1:             }
1:         } catch (CommunicationException e) {
1: 
1:         } catch (NamingException e) {
1:             if (context != null) {
1:                 close(context);
1:             }
0:             return false;
1:         }
1: 
1: 
1:         return true;
1:     }
1: 
0:     protected ArrayList getRoles(DirContext context, String dn, String username, ArrayList currentRoles) throws NamingException {
0:         ArrayList list = currentRoles;
1:         if (list == null) {
0:             list = new ArrayList();
1:         }
0:         if (roleName == null || "".equals(roleName)) {
1:             return list;
1:         }
0:         String filter = roleSearchMatchingFormat.format(new String[]{doRFC2254Encoding(dn), username});
1: 
1:         SearchControls constraints = new SearchControls();
1:         if (roleSearchSubtreeBool) {
1:             constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
1:         } else {
1:             constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
1:         }
0:         NamingEnumeration results =
0:                 context.search(roleBase, filter, constraints);
1:         while (results.hasMore()) {
0:             SearchResult result = (SearchResult) results.next();
1:             Attributes attrs = result.getAttributes();
1:             if (attrs == null) {
1:                 continue;
1:             }
0:             list = addAttributeValues(roleName, attrs, list);
1:         }
1:         return list;
1: 
1:     }
1: 
1: 
1:     protected String doRFC2254Encoding(String inputString) {
1:         StringBuffer buf = new StringBuffer(inputString.length());
1:         for (int i = 0; i < inputString.length(); i++) {
1:             char c = inputString.charAt(i);
1:             switch (c) {
0:                 case '\\':
0:                     buf.append("\\5c");
0:                     break;
0:                 case '*':
0:                     buf.append("\\2a");
0:                     break;
0:                 case '(':
0:                     buf.append("\\28");
0:                     break;
0:                 case ')':
0:                     buf.append("\\29");
0:                     break;
0:                 case '\0':
0:                     buf.append("\\00");
0:                     break;
0:                 default:
0:                     buf.append(c);
0:                     break;
1:             }
1:         }
1:         return buf.toString();
1:     }
1: 
1:     protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {
1:         boolean isValid = false;
1: 
1:         context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);
1:         context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);
1:         try {
1:             context.getAttributes("", null);
1:             isValid = true;
1:         } catch (AuthenticationException e) {
1:             isValid = false;
0:             log.debug("Authentication failed for dn=" + dn);
1:         }
1: 
0:         if (connectionUsername != null) {
0:             context.addToEnvironment(Context.SECURITY_PRINCIPAL,
0:                     connectionUsername);
1:         } else {
1:             context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);
1:         }
1: 
0:         if (connectionPassword != null) {
0:             context.addToEnvironment(Context.SECURITY_CREDENTIALS,
0:                     connectionPassword);
1:         } else {
1:             context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);
1:         }
1: 
1:         return isValid;
1:     }
1: 
0:     private ArrayList addAttributeValues(String attrId, Attributes attrs, ArrayList values)
0:             throws NamingException
0:     {
1: 
1:         if (attrId == null || attrs == null) {
1:             return values;
1:         }
1:         if (values == null) {
0:             values = new ArrayList();
1:         }
1:         Attribute attr = attrs.get(attrId);
1:         if (attr == null) {
0:             return (values);
1:         }
0:         NamingEnumeration e = attr.getAll();
1:         while (e.hasMore()) {
0:             String value = (String) e.next();
1:             values.add(value);
1:         }
1:         return values;
1:     }
1: 
1:     protected DirContext open() throws NamingException {
1:         if (context != null) {
1:             return context;
1:         }
1: 
1:         try {
0:             Hashtable env = new Hashtable();
0:             env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactory);
0:             if (connectionUsername != null || !"".equals(connectionUsername)) {
0:                 env.put(Context.SECURITY_PRINCIPAL, connectionUsername);
1:             }
0:             if (connectionPassword != null || !"".equals(connectionPassword)) {
0:                 env.put(Context.SECURITY_CREDENTIALS, connectionPassword);
1:             }
0:             env.put(Context.SECURITY_PROTOCOL, connectionProtocol);
0:             env.put(Context.PROVIDER_URL, connectionURL);
0:             env.put(Context.SECURITY_AUTHENTICATION, authentication);
1:             context = new InitialDirContext(env);
1: 
1:         } catch (NamingException e) {
0:             log.error(e);
1:             throw e;
1:         }
1:         return context;
1:     }
1: 
1: }
commit:48b4869
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2005-2006 The Apache Software Foundation
commit:2d0361b
/////////////////////////////////////////////////////////////////////////
0: package org.apache.activemq.jaas;
author:Robert Davies
-------------------------------------------------------------------------------
commit:b266786
/////////////////////////////////////////////////////////////////////////
0:         userSearchSubtreeBool = Boolean.valueOf(userSearchSubtree).booleanValue();
0:         roleSearchSubtreeBool = Boolean.valueOf(roleSearchSubtree).booleanValue();
author:Jonas B. Lim
-------------------------------------------------------------------------------
commit:92a698f
/////////////////////////////////////////////////////////////////////////
0:  * Copyright 2004 The Apache Software Foundation
author:James Strachan
-------------------------------------------------------------------------------
commit:40a7d3b
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * <a href="http://activemq.org">ActiveMQ: The Open Source Message Fabric</a>
0:  *
0:  * Copyright 2005 (C) LogicBlaze, Inc. http://www.logicblaze.com
0:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
0:  *
0:  * http://www.apache.org/licenses/LICENSE-2.0
0:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  * See the License for the specific language governing permissions and
0:  * limitations under the License.
0:  */
0: package org.activemq.jaas;
0: 
0: import java.io.IOException;
0: import java.text.MessageFormat;
0: import java.util.ArrayList;
0: import java.util.HashSet;
0: import java.util.Hashtable;
0: import java.util.Iterator;
0: import java.util.Map;
0: import java.util.Set;
0: import javax.naming.AuthenticationException;
0: import javax.naming.CommunicationException;
0: import javax.naming.Context;
0: import javax.naming.Name;
0: import javax.naming.NameParser;
0: import javax.naming.NamingEnumeration;
0: import javax.naming.NamingException;
0: import javax.naming.directory.Attribute;
0: import javax.naming.directory.Attributes;
0: import javax.naming.directory.DirContext;
0: import javax.naming.directory.InitialDirContext;
0: import javax.naming.directory.SearchControls;
0: import javax.naming.directory.SearchResult;
0: import javax.security.auth.Subject;
0: import javax.security.auth.callback.Callback;
0: import javax.security.auth.callback.CallbackHandler;
0: import javax.security.auth.callback.NameCallback;
0: import javax.security.auth.callback.PasswordCallback;
0: import javax.security.auth.callback.UnsupportedCallbackException;
0: import javax.security.auth.login.LoginException;
0: import javax.security.auth.login.FailedLoginException;
0: import javax.security.auth.spi.LoginModule;
0: 
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: 
0: 
0: /**
0:  * @version $Rev: $ $Date: $
0:  */
0: public class LDAPLoginModule implements LoginModule {
0: 
0:     private static Log log = LogFactory.getLog(LDAPLoginModule.class);
0: 
0:     private Subject subject;
0:     private CallbackHandler handler;
0: 
0:     private static final String INITIAL_CONTEXT_FACTORY = "initialContextFactory";
0:     private static final String CONNECTION_URL = "connectionURL";
0:     private static final String CONNECTION_USERNAME = "connectionUsername";
0:     private static final String CONNECTION_PASSWORD = "connectionPassword";
0:     private static final String CONNECTION_PROTOCOL = "connectionProtocol";
0:     private static final String AUTHENTICATION = "authentication";
0:     private static final String USER_BASE = "userBase";
0:     private static final String USER_SEARCH_MATCHING = "userSearchMatching";
0:     private static final String USER_SEARCH_SUBTREE = "userSearchSubtree";
0:     private static final String ROLE_BASE = "roleBase";
0:     private static final String ROLE_NAME = "roleName";
0:     private static final String ROLE_SEARCH_MATCHING = "roleSearchMatching";
0:     private static final String ROLE_SEARCH_SUBTREE = "roleSearchSubtree";
0:     private static final String USER_ROLE_NAME = "userRoleName";
0: 
0:     private String initialContextFactory;
0:     private String connectionURL;
0:     private String connectionUsername;
0:     private String connectionPassword;
0:     private String connectionProtocol;
0:     private String authentication;
0:     private String userBase;
0:     private String roleBase;
0:     private String roleName;
0:     private String userRoleName;
0: 
0:     private String username;
0: 
0:     protected DirContext context = null;
0: 
0:     private MessageFormat userSearchMatchingFormat;
0:     private MessageFormat roleSearchMatchingFormat;
0: 
0:     private boolean userSearchSubtreeBool = false;
0:     private boolean roleSearchSubtreeBool = false;
0: 
0:     Set groups = new HashSet();
0: 
0:     public void initialize(Subject subject, CallbackHandler callbackHandler, Map sharedState, Map options) {
0:         this.subject = subject;
0:         this.handler = callbackHandler;
0:         initialContextFactory = (String) options.get(INITIAL_CONTEXT_FACTORY);
0:         connectionURL = (String) options.get(CONNECTION_URL);
0:         connectionUsername = (String) options.get(CONNECTION_USERNAME);
0:         connectionPassword = (String) options.get(CONNECTION_PASSWORD);
0:         connectionProtocol = (String) options.get(CONNECTION_PROTOCOL);
0:         authentication = (String) options.get(AUTHENTICATION);
0:         userBase = (String) options.get(USER_BASE);
0:         String userSearchMatching = (String) options.get(USER_SEARCH_MATCHING);
0:         String userSearchSubtree = (String) options.get(USER_SEARCH_SUBTREE);
0:         roleBase = (String) options.get(ROLE_BASE);
0:         roleName = (String) options.get(ROLE_NAME);
0:         String roleSearchMatching = (String) options.get(ROLE_SEARCH_MATCHING);
0:         String roleSearchSubtree = (String) options.get(ROLE_SEARCH_SUBTREE);
0:         userRoleName = (String) options.get(USER_ROLE_NAME);
0:         userSearchMatchingFormat = new MessageFormat(userSearchMatching);
0:         roleSearchMatchingFormat = new MessageFormat(roleSearchMatching);
0:         userSearchSubtreeBool = new Boolean(userSearchSubtree).booleanValue();
0:         roleSearchSubtreeBool = new Boolean(roleSearchSubtree).booleanValue();
0:     }
0: 
0:     public boolean login() throws LoginException {
0:         Callback[] callbacks = new Callback[2];
0: 
0:         callbacks[0] = new NameCallback("User name");
0:         callbacks[1] = new PasswordCallback("Password", false);
0:         try {
0:             handler.handle(callbacks);
0:         } catch (IOException ioe) {
0:             throw (LoginException) new LoginException().initCause(ioe);
0:         } catch (UnsupportedCallbackException uce) {
0:             throw (LoginException) new LoginException().initCause(uce);
0:         }
0:         username = ((NameCallback) callbacks[0]).getName();
0:         String password = new String(((PasswordCallback) callbacks[1]).getPassword());
0: 
0:         if (username == null || "".equals(username) || password == null || "".equals(password)) {
0:             return false;
0:         }
0: 
0:         try {
0:             boolean result = authenticate(username, password);
0:             if(!result) {
0:                 throw new FailedLoginException();
0:             } else {
0:                 return true;
0:             }
0:         } catch (Exception e) {
0:             throw (LoginException) new LoginException("LDAP Error").initCause(e);
0:         }
0:     }
0: 
0:     public boolean logout() throws LoginException {
0:         username = null;
0:         return true;
0:     }
0: 
0:     public boolean commit() throws LoginException {
0:         Set principals = subject.getPrincipals();
0:         principals.add(new UserPrincipal(username));
0:         Iterator iter = groups.iterator();
0:         while (iter.hasNext()) {
0:             principals.add(iter.next());
0:         }
0:         return true;
0:     }
0: 
0:     public boolean abort() throws LoginException {
0:         username = null;
0:         return true;
0:     }
0: 
0:     protected void close(DirContext context) {
0:         try {
0:             context.close();
0:         } catch (Exception e) {
0:             log.error(e);
0:         }
0:     }
0: 
0:     protected boolean authenticate(String username, String password) throws Exception {
0: 
0:         DirContext context = null;
0:         context = open();
0: 
0:         try {
0: 
0:             String filter = userSearchMatchingFormat.format(new String[]{username});
0:             SearchControls constraints = new SearchControls();
0:             if (userSearchSubtreeBool) {
0:                 constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
0:             } else {
0:                 constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
0:             }
0: 
0:             //setup attributes
0:             ArrayList list = new ArrayList();
0:             if (userRoleName != null) {
0:                 list.add(userRoleName);
0:             }
0:             String[] attribs = new String[list.size()];
0:             list.toArray(attribs);
0:             constraints.setReturningAttributes(attribs);
0: 
0: 
0:             NamingEnumeration results = context.search(userBase, filter, constraints);
0: 
0:             if (results == null || !results.hasMore()) {
0:                 return false;
0:             }
0: 
0:             SearchResult result = (SearchResult) results.next();
0: 
0:             if (results.hasMore()) {
0:                 //ignore for now
0:             }
0:             NameParser parser = context.getNameParser("");
0:             Name contextName = parser.parse(context.getNameInNamespace());
0:             Name baseName = parser.parse(userBase);
0:             Name entryName = parser.parse(result.getName());
0:             Name name = contextName.addAll(baseName);
0:             name = name.addAll(entryName);
0:             String dn = name.toString();
0: 
0:             Attributes attrs = result.getAttributes();
0:             if (attrs == null) {
0:                 return false;
0:             }
0:             ArrayList roles = null;
0:             if (userRoleName != null) {
0:                 roles = addAttributeValues(userRoleName, attrs, roles);
0:             }
0: 
0:             //check the credentials by binding to server
0:             if (bindUser(context, dn, password)) {
0:                 //if authenticated add more roles
0:                 roles = getRoles(context, dn, username, roles);
0:                 for (int i = 0; i < roles.size(); i++) {
0:                     groups.add(new GroupPrincipal((String) roles.get(i)));
0:                 }
0:             } else {
0:                 return false;
0:             }
0:         } catch (CommunicationException e) {
0: 
0:         } catch (NamingException e) {
0:             if (context != null) {
0:                 close(context);
0:             }
0:             return false;
0:         }
0: 
0: 
0:         return true;
0:     }
0: 
0:     protected ArrayList getRoles(DirContext context, String dn, String username, ArrayList currentRoles) throws NamingException {
0:         ArrayList list = currentRoles;
0:         if (list == null) {
0:             list = new ArrayList();
0:         }
0:         if (roleName == null || "".equals(roleName)) {
0:             return list;
0:         }
0:         String filter = roleSearchMatchingFormat.format(new String[]{doRFC2254Encoding(dn), username});
0: 
0:         SearchControls constraints = new SearchControls();
0:         if (roleSearchSubtreeBool) {
0:             constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
0:         } else {
0:             constraints.setSearchScope(SearchControls.ONELEVEL_SCOPE);
0:         }
0:         NamingEnumeration results =
0:                 context.search(roleBase, filter, constraints);
0:         while (results.hasMore()) {
0:             SearchResult result = (SearchResult) results.next();
0:             Attributes attrs = result.getAttributes();
0:             if (attrs == null) {
0:                 continue;
0:             }
0:             list = addAttributeValues(roleName, attrs, list);
0:         }
0:         return list;
0: 
0:     }
0: 
0: 
0:     protected String doRFC2254Encoding(String inputString) {
0:         StringBuffer buf = new StringBuffer(inputString.length());
0:         for (int i = 0; i < inputString.length(); i++) {
0:             char c = inputString.charAt(i);
0:             switch (c) {
0:                 case '\\':
0:                     buf.append("\\5c");
0:                     break;
0:                 case '*':
0:                     buf.append("\\2a");
0:                     break;
0:                 case '(':
0:                     buf.append("\\28");
0:                     break;
0:                 case ')':
0:                     buf.append("\\29");
0:                     break;
0:                 case '\0':
0:                     buf.append("\\00");
0:                     break;
0:                 default:
0:                     buf.append(c);
0:                     break;
0:             }
0:         }
0:         return buf.toString();
0:     }
0: 
0:     protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {
0:         boolean isValid = false;
0: 
0:         context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);
0:         context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);
0:         try {
0:             context.getAttributes("", null);
0:             isValid = true;
0:         } catch (AuthenticationException e) {
0:             isValid = false;
0:             log.debug("Authentication failed for dn=" + dn);
0:         }
0: 
0:         if (connectionUsername != null) {
0:             context.addToEnvironment(Context.SECURITY_PRINCIPAL,
0:                     connectionUsername);
0:         } else {
0:             context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);
0:         }
0: 
0:         if (connectionPassword != null) {
0:             context.addToEnvironment(Context.SECURITY_CREDENTIALS,
0:                     connectionPassword);
0:         } else {
0:             context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);
0:         }
0: 
0:         return isValid;
0:     }
0: 
0:     private ArrayList addAttributeValues(String attrId, Attributes attrs, ArrayList values)
0:             throws NamingException
0:     {
0: 
0:         if (attrId == null || attrs == null) {
0:             return values;
0:         }
0:         if (values == null) {
0:             values = new ArrayList();
0:         }
0:         Attribute attr = attrs.get(attrId);
0:         if (attr == null) {
0:             return (values);
0:         }
0:         NamingEnumeration e = attr.getAll();
0:         while (e.hasMore()) {
0:             String value = (String) e.next();
0:             values.add(value);
0:         }
0:         return values;
0:     }
0: 
0:     protected DirContext open() throws NamingException {
0:         if (context != null) {
0:             return context;
0:         }
0: 
0:         try {
0:             Hashtable env = new Hashtable();
0:             env.put(Context.INITIAL_CONTEXT_FACTORY, initialContextFactory);
0:             if (connectionUsername != null || !"".equals(connectionUsername)) {
0:                 env.put(Context.SECURITY_PRINCIPAL, connectionUsername);
0:             }
0:             if (connectionPassword != null || !"".equals(connectionPassword)) {
0:                 env.put(Context.SECURITY_CREDENTIALS, connectionPassword);
0:             }
0:             env.put(Context.SECURITY_PROTOCOL, connectionProtocol);
0:             env.put(Context.PROVIDER_URL, connectionURL);
0:             env.put(Context.SECURITY_AUTHENTICATION, authentication);
0:             context = new InitialDirContext(env);
0: 
0:         } catch (NamingException e) {
0:             log.error(e);
0:             throw e;
0:         }
0:         return context;
0:     }
0: 
0: }
============================================================================