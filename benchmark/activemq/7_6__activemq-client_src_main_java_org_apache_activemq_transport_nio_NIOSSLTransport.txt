1:e504086: /**
1:e504086:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:e504086:  * contributor license agreements.  See the NOTICE file distributed with
1:e504086:  * this work for additional information regarding copyright ownership.
1:e504086:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:e504086:  * (the "License"); you may not use this file except in compliance with
1:e504086:  * the License.  You may obtain a copy of the License at
1:e504086:  *
1:e504086:  *      http://www.apache.org/licenses/LICENSE-2.0
1:e504086:  *
1:e504086:  * Unless required by applicable law or agreed to in writing, software
1:e504086:  * distributed under the License is distributed on an "AS IS" BASIS,
1:e504086:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e504086:  * See the License for the specific language governing permissions and
1:e504086:  * limitations under the License.
1:e504086:  */
24:e504086: 
1:e504086: package org.apache.activemq.transport.nio;
1:a26f03f: 
1:e504086: import java.io.DataInputStream;
1:e504086: import java.io.DataOutputStream;
1:036f2a8: import java.io.EOFException;
1:e504086: import java.io.IOException;
1:e504086: import java.net.Socket;
1:52e4527: import java.net.SocketTimeoutException;
1:e504086: import java.net.URI;
1:e504086: import java.net.UnknownHostException;
1:e504086: import java.nio.ByteBuffer;
1:52e4527: import java.nio.channels.SelectionKey;
1:52e4527: import java.nio.channels.Selector;
1:6175dc4: import java.security.cert.X509Certificate;
1:ed0e786: import java.util.concurrent.CountDownLatch;
1:6175dc4: 
1:6175dc4: import javax.net.SocketFactory;
1:6175dc4: import javax.net.ssl.SSLContext;
1:6175dc4: import javax.net.ssl.SSLEngine;
1:6175dc4: import javax.net.ssl.SSLEngineResult;
1:52e4527: import javax.net.ssl.SSLEngineResult.HandshakeStatus;
1:69fad2a: import javax.net.ssl.SSLParameters;
1:6175dc4: import javax.net.ssl.SSLPeerUnverifiedException;
1:6175dc4: import javax.net.ssl.SSLSession;
1:6175dc4: 
1:6175dc4: import org.apache.activemq.command.ConnectionInfo;
1:6175dc4: import org.apache.activemq.openwire.OpenWireFormat;
1:8a01c5d: import org.apache.activemq.thread.TaskRunnerFactory;
1:6175dc4: import org.apache.activemq.util.IOExceptionSupport;
1:6175dc4: import org.apache.activemq.util.ServiceStopper;
1:6175dc4: import org.apache.activemq.wireformat.WireFormat;
1:65af81e: import org.slf4j.Logger;
1:65af81e: import org.slf4j.LoggerFactory;
1:e504086: 
1:65af81e: public class NIOSSLTransport extends NIOTransport {
1:65af81e: 
1:65af81e:     private static final Logger LOG = LoggerFactory.getLogger(NIOSSLTransport.class);
1:e504086: 
1:036f2a8:     protected boolean needClientAuth;
1:036f2a8:     protected boolean wantClientAuth;
1:036f2a8:     protected String[] enabledCipherSuites;
1:1948fe4:     protected String[] enabledProtocols;
1:1e31df9:     protected boolean verifyHostName = false;
1:e504086: 
1:e504086:     protected SSLContext sslContext;
1:e504086:     protected SSLEngine sslEngine;
1:e504086:     protected SSLSession sslSession;
1:e504086: 
1:8a01c5d:     protected volatile boolean handshakeInProgress = false;
1:036f2a8:     protected SSLEngineResult.Status status = null;
1:036f2a8:     protected SSLEngineResult.HandshakeStatus handshakeStatus = null;
1:8a01c5d:     protected TaskRunnerFactory taskRunnerFactory;
1:e504086: 
1:e504086:     public NIOSSLTransport(WireFormat wireFormat, SocketFactory socketFactory, URI remoteLocation, URI localLocation) throws UnknownHostException, IOException {
1:e504086:         super(wireFormat, socketFactory, remoteLocation, localLocation);
25:e504086:     }
1:04ee70a: 
1:04ee70a:     public NIOSSLTransport(WireFormat wireFormat, Socket socket, SSLEngine engine, InitBuffer initBuffer,
1:04ee70a:             ByteBuffer inputBuffer) throws IOException {
1:04ee70a:         super(wireFormat, socket, initBuffer);
1:04ee70a:         this.sslEngine = engine;
1:e14aca8:         if (engine != null) {
1:04ee70a:             this.sslSession = engine.getSession();
1:e14aca8:         }
1:04ee70a:         this.inputBuffer = inputBuffer;
1:e504086:     }
1:e504086: 
1:e504086:     public void setSslContext(SSLContext sslContext) {
1:e504086:         this.sslContext = sslContext;
1:e504086:     }
1:e504086: 
1:04ee70a:     volatile boolean hasSslEngine = false;
1:04ee70a: 
1:69e35d6:     @Override
1:e504086:     protected void initializeStreams() throws IOException {
1:04ee70a:         if (sslEngine != null) {
1:04ee70a:             hasSslEngine = true;
1:04ee70a:         }
1:69e35d6:         NIOOutputStream outputStream = null;
1:e504086:         try {
1:e504086:             channel = socket.getChannel();
1:e504086:             channel.configureBlocking(false);
1:e504086: 
1:e504086:             if (sslContext == null) {
1:e504086:                 sslContext = SSLContext.getDefault();
1:65af81e:             }
1:65af81e: 
1:65af81e:             String remoteHost = null;
1:65af81e:             int remotePort = -1;
1:65af81e: 
1:65af81e:             try {
1:65af81e:                 URI remoteAddress = new URI(this.getRemoteAddress());
1:65af81e:                 remoteHost = remoteAddress.getHost();
1:65af81e:                 remotePort = remoteAddress.getPort();
1:65af81e:             } catch (Exception e) {
1:65af81e:             }
1:65af81e: 
1:324ab99:             // initialize engine, the initial sslSession we get will need to be
1:324ab99:             // updated once the ssl handshake process is completed.
1:04ee70a:             if (!hasSslEngine) {
1:04ee70a:                 if (remoteHost != null && remotePort != -1) {
1:04ee70a:                     sslEngine = sslContext.createSSLEngine(remoteHost, remotePort);
1:04ee70a:                 } else {
1:04ee70a:                     sslEngine = sslContext.createSSLEngine();
1:04ee70a:                 }
1:04ee70a: 
1:69fad2a:                 if (verifyHostName) {
1:69fad2a:                     SSLParameters sslParams = new SSLParameters();
1:69fad2a:                     sslParams.setEndpointIdentificationAlgorithm("HTTPS");
1:69fad2a:                     sslEngine.setSSLParameters(sslParams);
1:69fad2a:                 }
1:69fad2a: 
1:04ee70a:                 sslEngine.setUseClientMode(false);
1:04ee70a:                 if (enabledCipherSuites != null) {
1:04ee70a:                     sslEngine.setEnabledCipherSuites(enabledCipherSuites);
1:04ee70a:                 }
1:04ee70a: 
1:04ee70a:                 if (enabledProtocols != null) {
1:04ee70a:                     sslEngine.setEnabledProtocols(enabledProtocols);
1:04ee70a:                 }
1:04ee70a: 
1:04ee70a:                 if (wantClientAuth) {
1:04ee70a:                     sslEngine.setWantClientAuth(wantClientAuth);
1:04ee70a:                 }
1:04ee70a: 
1:04ee70a:                 if (needClientAuth) {
1:04ee70a:                     sslEngine.setNeedClientAuth(needClientAuth);
1:04ee70a:                 }
1:04ee70a: 
1:04ee70a:                 sslSession = sslEngine.getSession();
1:04ee70a: 
1:04ee70a:                 inputBuffer = ByteBuffer.allocate(sslSession.getPacketBufferSize());
1:04ee70a:                 inputBuffer.clear();
1:1948fe4:             }
1:1948fe4: 
1:69e35d6:             outputStream = new NIOOutputStream(channel);
1:e504086:             outputStream.setEngine(sslEngine);
1:e504086:             this.dataOut = new DataOutputStream(outputStream);
1:e504086:             this.buffOut = outputStream;
1:04ee70a: 
1:04ee70a:             //If the sslEngine was not passed in, then handshake
1:e14aca8:             if (!hasSslEngine) {
1:04ee70a:                 sslEngine.beginHandshake();
1:e14aca8:             }
1:e504086:             handshakeStatus = sslEngine.getHandshakeStatus();
1:e14aca8:             if (!hasSslEngine) {
1:04ee70a:                 doHandshake();
1:e14aca8:             }
1:04ee70a: 
1:04ee70a:             selection = SelectorManager.getInstance().register(channel, new SelectorManager.Listener() {
1:04ee70a:                 @Override
1:04ee70a:                 public void onSelect(SelectorSelection selection) {
1:ed0e786:                     try {
1:ed0e786:                         initialized.await();
1:ed0e786:                     } catch (InterruptedException error) {
1:ed0e786:                         onException(IOExceptionSupport.create(error));
1:ed0e786:                     }
1:04ee70a:                     serviceRead();
1:04ee70a:                 }
1:04ee70a: 
1:04ee70a:                 @Override
1:04ee70a:                 public void onError(SelectorSelection selection, Throwable error) {
1:04ee70a:                     if (error instanceof IOException) {
1:04ee70a:                         onException((IOException) error);
1:04ee70a:                     } else {
1:04ee70a:                         onException(IOExceptionSupport.create(error));
1:04ee70a:                     }
1:04ee70a:                 }
1:04ee70a:             });
1:04ee70a:             doInit();
1:04ee70a: 
1:e504086:         } catch (Exception e) {
1:69e35d6:             try {
1:69e35d6:                 if(outputStream != null) {
1:69e35d6:                     outputStream.close();
1:69e35d6:                 }
1:69e35d6:                 super.closeStreams();
1:69e35d6:             } catch (Exception ex) {}
1:e504086:             throw new IOException(e);
1:65af81e:         }
1:65af81e:     }
1:65af81e: 
1:ed0e786:     final protected CountDownLatch initialized = new CountDownLatch(1);
1:65af81e: 
1:ed0e786:     protected void doInit() throws Exception {
1:ed0e786:         taskRunnerFactory.execute(new Runnable() {
1:ed0e786: 
1:ed0e786:             @Override
1:ed0e786:             public void run() {
1:ed0e786:                 //Need to start in new thread to let startup finish first
1:ed0e786:                 //We can trigger a read because we know the channel is ready since the SSL handshake
1:ed0e786:                 //already happened
1:ed0e786:                 serviceRead();
1:ed0e786:                 initialized.countDown();
1:ed0e786:             }
1:ed0e786:         });
1:04ee70a:     }
1:04ee70a: 
1:ed0e786:     //Only used for the auto transport to abort the openwire init method early if already initialized
1:ed0e786:     boolean openWireInititialized = false;
1:ed0e786: 
1:04ee70a:     protected void doOpenWireInit() throws Exception {
1:04ee70a:         //Do this later to let wire format negotiation happen
1:ed0e786:         if (initBuffer != null && !openWireInititialized && this.wireFormat instanceof OpenWireFormat) {
1:04ee70a:             initBuffer.buffer.flip();
1:04ee70a:             if (initBuffer.buffer.hasRemaining()) {
1:04ee70a:                 nextFrameSize = -1;
1:04ee70a:                 receiveCounter += initBuffer.readSize;
1:04ee70a:                 processCommand(initBuffer.buffer);
1:04ee70a:                 processCommand(initBuffer.buffer);
1:04ee70a:                 initBuffer.buffer.clear();
1:ed0e786:                 openWireInititialized = true;
1:04ee70a:             }
1:04ee70a:         }
1:04ee70a:     }
1:04ee70a: 
1:65af81e:     protected void finishHandshake() throws Exception {
1:65af81e:         if (handshakeInProgress) {
1:65af81e:             handshakeInProgress = false;
1:838206f:             nextFrameSize = -1;
1:a26f03f: 
1:65af81e:             // Once handshake completes we need to ask for the now real sslSession
1:65af81e:             // otherwise the session would return 'SSL_NULL_WITH_NULL_NULL' for the
1:65af81e:             // cipher suite.
1:65af81e:             sslSession = sslEngine.getSession();
1:65af81e:         }
1:65af81e:     }
1:324ab99: 
1:69e35d6:     @Override
1:04ee70a:     public void serviceRead() {
1:e504086:         try {
2:e504086:             if (handshakeInProgress) {
2:e504086:                 doHandshake();
1:65af81e:             }
1:e504086: 
1:04ee70a:             doOpenWireInit();
1:04ee70a: 
1:e504086:             ByteBuffer plain = ByteBuffer.allocate(sslSession.getApplicationBufferSize());
1:e504086:             plain.position(plain.limit());
1:e504086: 
1:65af81e:             while (true) {
1:036f2a8:                 if (!plain.hasRemaining()) {
1:e504086: 
1:036f2a8:                     int readCount = secureRead(plain);
1:036f2a8: 
1:78265ea:                     if (readCount == 0) {
2:65af81e:                         break;
1:78265ea:                     }
1:036f2a8: 
1:036f2a8:                     // channel is closed, cleanup
1:65af81e:                     if (readCount == -1) {
1:036f2a8:                         onException(new EOFException());
1:036f2a8:                         selection.close();
1:65af81e:                         break;
1:65af81e:                     }
1:78265ea: 
1:78265ea:                     receiveCounter += readCount;
1:65af81e:                 }
1:036f2a8: 
1:e96eab5:                 if (status == SSLEngineResult.Status.OK && handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
1:e96eab5:                     processCommand(plain);
1:e96eab5:                 }
1:036f2a8:             }
1:e504086:         } catch (IOException e) {
1:e504086:             onException(e);
1:e504086:         } catch (Throwable e) {
1:e504086:             onException(IOExceptionSupport.create(e));
1:036f2a8:         }
1:48fa20a:     }
1:e504086: 
1:036f2a8:     protected void processCommand(ByteBuffer plain) throws Exception {
1:838206f: 
1:838206f:         // Are we waiting for the next Command or are we building on the current one
1:838206f:         if (nextFrameSize == -1) {
1:838206f: 
1:838206f:             // We can get small packets that don't give us enough for the frame size
1:838206f:             // so allocate enough for the initial size value and
1:838206f:             if (plain.remaining() < Integer.SIZE) {
1:838206f:                 if (currentBuffer == null) {
1:838206f:                     currentBuffer = ByteBuffer.allocate(4);
1:838206f:                 }
1:838206f: 
1:838206f:                 // Go until we fill the integer sized current buffer.
1:838206f:                 while (currentBuffer.hasRemaining() && plain.hasRemaining()) {
1:838206f:                     currentBuffer.put(plain.get());
1:838206f:                 }
1:838206f: 
1:838206f:                 // Didn't we get enough yet to figure out next frame size.
1:838206f:                 if (currentBuffer.hasRemaining()) {
1:838206f:                     return;
1:838206f:                 } else {
1:838206f:                     currentBuffer.flip();
1:838206f:                     nextFrameSize = currentBuffer.getInt();
1:838206f:                 }
1:838206f: 
1:838206f:             } else {
1:838206f: 
1:838206f:                 // Either we are completing a previous read of the next frame size or its
1:838206f:                 // fully contained in plain already.
1:838206f:                 if (currentBuffer != null) {
1:838206f: 
1:838206f:                     // Finish the frame size integer read and get from the current buffer.
1:838206f:                     while (currentBuffer.hasRemaining()) {
1:838206f:                         currentBuffer.put(plain.get());
1:838206f:                     }
1:838206f: 
1:838206f:                     currentBuffer.flip();
1:838206f:                     nextFrameSize = currentBuffer.getInt();
1:838206f: 
1:838206f:                 } else {
1:838206f:                     nextFrameSize = plain.getInt();
1:838206f:                 }
1:036f2a8:             }
1:838206f: 
1:838206f:             if (wireFormat instanceof OpenWireFormat) {
1:838206f:                 long maxFrameSize = ((OpenWireFormat) wireFormat).getMaxFrameSize();
1:838206f:                 if (nextFrameSize > maxFrameSize) {
1:838206f:                     throw new IOException("Frame size of " + (nextFrameSize / (1024 * 1024)) +
1:838206f:                                           " MB larger than max allowed " + (maxFrameSize / (1024 * 1024)) + " MB");
1:838206f:                 }
1:838206f:             }
1:838206f: 
1:838206f:             // now we got the data, lets reallocate and store the size for the marshaler.
1:838206f:             // if there's more data in plain, then the next call will start processing it.
1:838206f:             currentBuffer = ByteBuffer.allocate(nextFrameSize + 4);
1:838206f:             currentBuffer.putInt(nextFrameSize);
1:838206f: 
1:838206f:         } else {
1:838206f:             // If its all in one read then we can just take it all, otherwise take only
1:838206f:             // the current frame size and the next iteration starts a new command.
1:e14aca8:             if (currentBuffer != null) {
1:e14aca8:                 if (currentBuffer.remaining() >= plain.remaining()) {
1:e14aca8:                     currentBuffer.put(plain);
1:e14aca8:                 } else {
1:e14aca8:                     byte[] fill = new byte[currentBuffer.remaining()];
1:e14aca8:                     plain.get(fill);
1:e14aca8:                     currentBuffer.put(fill);
1:e14aca8:                 }
1:838206f: 
1:e14aca8:                 // Either we have enough data for a new command or we have to wait for some more.
1:e14aca8:                 if (currentBuffer.hasRemaining()) {
1:e14aca8:                     return;
1:e14aca8:                 } else {
1:e14aca8:                     currentBuffer.flip();
1:e14aca8:                     Object command = wireFormat.unmarshal(new DataInputStream(new NIOInputStream(currentBuffer)));
1:e14aca8:                     doConsume(command);
1:e14aca8:                     nextFrameSize = -1;
1:e14aca8:                     currentBuffer = null;
1:e14aca8:                }
1:e14aca8:             }
1:04ee70a:         }
1:838206f:     }
1:e504086: 
1:036f2a8:     protected int secureRead(ByteBuffer plain) throws Exception {
1:036f2a8: 
1:e96eab5:         if (!(inputBuffer.position() != 0 && inputBuffer.hasRemaining()) || status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
1:036f2a8:             int bytesRead = channel.read(inputBuffer);
1:036f2a8: 
1:52e4527:             if (bytesRead == 0 && !(sslEngine.getHandshakeStatus().equals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP))) {
1:838206f:                 return 0;
1:838206f:             }
1:838206f: 
1:036f2a8:             if (bytesRead == -1) {
2:e504086:                 sslEngine.closeInbound();
1:65af81e:                 if (inputBuffer.position() == 0 || status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
2:e504086:                     return -1;
1:036f2a8:                 }
1:036f2a8:             }
1:036f2a8:         }
1:e504086: 
1:e96eab5:         plain.clear();
1:e504086: 
1:e504086:         inputBuffer.flip();
1:e504086:         SSLEngineResult res;
1:e504086:         do {
1:e504086:             res = sslEngine.unwrap(inputBuffer, plain);
1:65af81e:         } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP
1:65af81e:                 && res.bytesProduced() == 0);
1:e504086: 
1:e504086:         if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
1:65af81e:             finishHandshake();
1:e96eab5:         }
1:e504086: 
1:e504086:         status = res.getStatus();
1:e504086:         handshakeStatus = res.getHandshakeStatus();
1:036f2a8: 
1:65af81e:         // TODO deal with BUFFER_OVERFLOW
1:e504086: 
1:e504086:         if (status == SSLEngineResult.Status.CLOSED) {
1:036f2a8:             sslEngine.closeInbound();
1:036f2a8:             return -1;
1:036f2a8:         }
1:e504086: 
1:e504086:         inputBuffer.compact();
1:e504086:         plain.flip();
1:e504086: 
1:e504086:         return plain.remaining();
1:036f2a8:     }
1:e504086: 
1:e504086:     protected void doHandshake() throws Exception {
1:e504086:         handshakeInProgress = true;
1:52e4527:         Selector selector = null;
1:52e4527:         SelectionKey key = null;
1:52e4527:         boolean readable = true;
1:52e4527:         try {
1:52e4527:             while (true) {
1:52e4527:                 HandshakeStatus handshakeStatus = sslEngine.getHandshakeStatus();
1:52e4527:                 switch (handshakeStatus) {
1:52e4527:                     case NEED_UNWRAP:
1:52e4527:                         if (readable) {
1:52e4527:                             secureRead(ByteBuffer.allocate(sslSession.getApplicationBufferSize()));
1:52e4527:                         }
1:52e4527:                         if (this.status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
1:52e4527:                             long now = System.currentTimeMillis();
1:52e4527:                             if (selector == null) {
1:52e4527:                                 selector = Selector.open();
1:52e4527:                                 key = channel.register(selector, SelectionKey.OP_READ);
1:52e4527:                             } else {
1:52e4527:                                 key.interestOps(SelectionKey.OP_READ);
1:52e4527:                             }
1:ad8879d:                             int keyCount = selector.select(this.getSoTimeout());
1:ad8879d:                             if (keyCount == 0 && this.getSoTimeout() > 0 && ((System.currentTimeMillis() - now) >= this.getSoTimeout())) {
1:52e4527:                                 throw new SocketTimeoutException("Timeout during handshake");
1:52e4527:                             }
1:52e4527:                             readable = key.isReadable();
1:52e4527:                         }
1:52e4527:                         break;
1:52e4527:                     case NEED_TASK:
1:52e4527:                         Runnable task;
1:52e4527:                         while ((task = sslEngine.getDelegatedTask()) != null) {
1:52e4527:                             task.run();
1:52e4527:                         }
1:52e4527:                         break;
1:52e4527:                     case NEED_WRAP:
1:52e4527:                         ((NIOOutputStream) buffOut).write(ByteBuffer.allocate(0));
1:52e4527:                         break;
1:52e4527:                     case FINISHED:
1:52e4527:                     case NOT_HANDSHAKING:
1:52e4527:                         finishHandshake();
1:52e4527:                         return;
1:e504086:                 }
1:e504086:             }
1:52e4527:         } finally {
1:52e4527:             if (key!=null) try {key.cancel();} catch (Exception ignore) {}
1:52e4527:             if (selector!=null) try {selector.close();} catch (Exception ignore) {}
1:e504086:         }
1:e504086:     }
1:e504086: 
1:69e35d6:     @Override
1:8a01c5d:     protected void doStart() throws Exception {
1:8a01c5d:         taskRunnerFactory = new TaskRunnerFactory("ActiveMQ NIOSSLTransport Task");
1:8a01c5d:         // no need to init as we can delay that until demand (eg in doHandshake)
1:8a01c5d:         super.doStart();
1:8a01c5d:     }
1:8a01c5d: 
1:8a01c5d:     @Override
1:e504086:     protected void doStop(ServiceStopper stopper) throws Exception {
1:ed0e786:         initialized.countDown();
1:ed0e786: 
1:8a01c5d:         if (taskRunnerFactory != null) {
1:8a01c5d:             taskRunnerFactory.shutdownNow();
1:8a01c5d:             taskRunnerFactory = null;
1:8a01c5d:         }
1:e504086:         if (channel != null) {
1:e504086:             channel.close();
1:036f2a8:             channel = null;
1:e504086:         }
1:e504086:         super.doStop(stopper);
1:e504086:     }
1:a26f03f: 
1:6175dc4:     /**
1:65af81e:      * Overriding in order to add the client's certificates to ConnectionInfo Commands.
1:6175dc4:      *
1:65af81e:      * @param command
1:65af81e:      *            The Command coming in.
1:6175dc4:      */
1:6175dc4:     @Override
1:6175dc4:     public void doConsume(Object command) {
1:6175dc4:         if (command instanceof ConnectionInfo) {
1:65af81e:             ConnectionInfo connectionInfo = (ConnectionInfo) command;
1:6175dc4:             connectionInfo.setTransportContext(getPeerCertificates());
1:6175dc4:         }
1:6175dc4:         super.doConsume(command);
1:6175dc4:     }
1:6175dc4: 
1:6175dc4:     /**
1:6175dc4:      * @return peer certificate chain associated with the ssl socket
1:6175dc4:      */
1:ed0e786:     @Override
1:6175dc4:     public X509Certificate[] getPeerCertificates() {
1:6175dc4: 
1:6175dc4:         X509Certificate[] clientCertChain = null;
1:6175dc4:         try {
1:65af81e:             if (sslEngine.getSession() != null) {
1:65af81e:                 clientCertChain = (X509Certificate[]) sslEngine.getSession().getPeerCertificates();
1:6175dc4:             }
1:6175dc4:         } catch (SSLPeerUnverifiedException e) {
1:65af81e:             if (LOG.isTraceEnabled()) {
1:65af81e:                 LOG.trace("Failed to get peer certificates.", e);
1:65af81e:             }
1:6175dc4:         }
1:6175dc4: 
1:6175dc4:         return clientCertChain;
1:6175dc4:     }
1:6175dc4: 
1:a26f03f:     public boolean isNeedClientAuth() {
1:a26f03f:         return needClientAuth;
1:a26f03f:     }
1:a26f03f: 
1:a26f03f:     public void setNeedClientAuth(boolean needClientAuth) {
1:a26f03f:         this.needClientAuth = needClientAuth;
1:a26f03f:     }
1:a26f03f: 
1:a26f03f:     public boolean isWantClientAuth() {
1:a26f03f:         return wantClientAuth;
1:a26f03f:     }
1:a26f03f: 
1:a26f03f:     public void setWantClientAuth(boolean wantClientAuth) {
1:a26f03f:         this.wantClientAuth = wantClientAuth;
1:a26f03f:     }
1:a26f03f: 
1:a26f03f:     public String[] getEnabledCipherSuites() {
1:a26f03f:         return enabledCipherSuites;
1:a26f03f:     }
1:a26f03f: 
1:a26f03f:     public void setEnabledCipherSuites(String[] enabledCipherSuites) {
1:a26f03f:         this.enabledCipherSuites = enabledCipherSuites;
1:a26f03f:     }
1:1948fe4: 
1:1948fe4:     public String[] getEnabledProtocols() {
1:1948fe4:         return enabledProtocols;
1:1948fe4:     }
1:1948fe4: 
1:1948fe4:     public void setEnabledProtocols(String[] enabledProtocols) {
1:1948fe4:         this.enabledProtocols = enabledProtocols;
1:1948fe4:     }
1:69fad2a: 
1:69fad2a:     public boolean isVerifyHostName() {
1:69fad2a:         return verifyHostName;
1:69fad2a:     }
1:69fad2a: 
1:69fad2a:     public void setVerifyHostName(boolean verifyHostName) {
1:69fad2a:         this.verifyHostName = verifyHostName;
1:69fad2a:     }
1:e504086: }
============================================================================
author:Christopher L. Shannon (cshannon)
-------------------------------------------------------------------------------
commit:1e31df9
/////////////////////////////////////////////////////////////////////////
1:     protected boolean verifyHostName = false;
commit:69fad2a
/////////////////////////////////////////////////////////////////////////
1: import javax.net.ssl.SSLParameters;
/////////////////////////////////////////////////////////////////////////
0:     protected boolean verifyHostName = true;
/////////////////////////////////////////////////////////////////////////
1:                 if (verifyHostName) {
1:                     SSLParameters sslParams = new SSLParameters();
1:                     sslParams.setEndpointIdentificationAlgorithm("HTTPS");
1:                     sslEngine.setSSLParameters(sslParams);
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isVerifyHostName() {
1:         return verifyHostName;
1:     }
1: 
1:     public void setVerifyHostName(boolean verifyHostName) {
1:         this.verifyHostName = verifyHostName;
1:     }
commit:27238b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ed0e786
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.CountDownLatch;
/////////////////////////////////////////////////////////////////////////
1:                     try {
1:                         initialized.await();
1:                     } catch (InterruptedException error) {
1:                         onException(IOExceptionSupport.create(error));
1:                     }
/////////////////////////////////////////////////////////////////////////
1:     final protected CountDownLatch initialized = new CountDownLatch(1);
1:     protected void doInit() throws Exception {
1:         taskRunnerFactory.execute(new Runnable() {
1: 
1:             @Override
1:             public void run() {
1:                 //Need to start in new thread to let startup finish first
1:                 //We can trigger a read because we know the channel is ready since the SSL handshake
1:                 //already happened
1:                 serviceRead();
1:                 initialized.countDown();
1:             }
1:         });
1:     //Only used for the auto transport to abort the openwire init method early if already initialized
1:     boolean openWireInititialized = false;
1: 
1:         if (initBuffer != null && !openWireInititialized && this.wireFormat instanceof OpenWireFormat) {
/////////////////////////////////////////////////////////////////////////
1:                 openWireInititialized = true;
/////////////////////////////////////////////////////////////////////////
1:         initialized.countDown();
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:e14aca8
/////////////////////////////////////////////////////////////////////////
1:         if (engine != null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (!hasSslEngine) {
1:             }
1:             if (!hasSslEngine) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (currentBuffer != null) {
1:                 if (currentBuffer.remaining() >= plain.remaining()) {
1:                     currentBuffer.put(plain);
1:                 } else {
1:                     byte[] fill = new byte[currentBuffer.remaining()];
1:                     plain.get(fill);
1:                     currentBuffer.put(fill);
1:                 }
1:                 // Either we have enough data for a new command or we have to wait for some more.
1:                 if (currentBuffer.hasRemaining()) {
1:                     return;
1:                 } else {
1:                     currentBuffer.flip();
1:                     Object command = wireFormat.unmarshal(new DataInputStream(new NIOInputStream(currentBuffer)));
1:                     doConsume(command);
1:                     nextFrameSize = -1;
1:                     currentBuffer = null;
1:                }
1:             }
commit:04ee70a
/////////////////////////////////////////////////////////////////////////
1:     public NIOSSLTransport(WireFormat wireFormat, Socket socket, SSLEngine engine, InitBuffer initBuffer,
1:             ByteBuffer inputBuffer) throws IOException {
1:         super(wireFormat, socket, initBuffer);
1:         this.sslEngine = engine;
0:         if (engine != null)
1:             this.sslSession = engine.getSession();
1:         this.inputBuffer = inputBuffer;
1:     volatile boolean hasSslEngine = false;
1: 
1:         if (sslEngine != null) {
1:             hasSslEngine = true;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if (!hasSslEngine) {
1:                 if (remoteHost != null && remotePort != -1) {
1:                     sslEngine = sslContext.createSSLEngine(remoteHost, remotePort);
1:                 } else {
1:                     sslEngine = sslContext.createSSLEngine();
1:                 }
1: 
1:                 sslEngine.setUseClientMode(false);
1:                 if (enabledCipherSuites != null) {
1:                     sslEngine.setEnabledCipherSuites(enabledCipherSuites);
1:                 }
1: 
1:                 if (enabledProtocols != null) {
1:                     sslEngine.setEnabledProtocols(enabledProtocols);
1:                 }
1: 
1:                 if (wantClientAuth) {
1:                     sslEngine.setWantClientAuth(wantClientAuth);
1:                 }
1: 
1:                 if (needClientAuth) {
1:                     sslEngine.setNeedClientAuth(needClientAuth);
1:                 }
1: 
1:                 sslSession = sslEngine.getSession();
1: 
1:                 inputBuffer = ByteBuffer.allocate(sslSession.getPacketBufferSize());
1:                 inputBuffer.clear();
1: 
1:             //If the sslEngine was not passed in, then handshake
0:             if (!hasSslEngine)
1:                 sslEngine.beginHandshake();
0:             if (!hasSslEngine)
1:                 doHandshake();
1: 
0:            // if (hasSslEngine) {
1:             selection = SelectorManager.getInstance().register(channel, new SelectorManager.Listener() {
1:                 @Override
1:                 public void onSelect(SelectorSelection selection) {
1:                     serviceRead();
1:                 }
1: 
1:                 @Override
1:                 public void onError(SelectorSelection selection, Throwable error) {
1:                     if (error instanceof IOException) {
1:                         onException((IOException) error);
1:                     } else {
1:                         onException(IOExceptionSupport.create(error));
1:                     }
1:                 }
1:             });
1:             doInit();
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected void doInit() throws Exception {
1: 
1:     }
1: 
1:     protected void doOpenWireInit() throws Exception {
1:         //Do this later to let wire format negotiation happen
0:         if (initBuffer != null && this.wireFormat instanceof OpenWireFormat) {
1:             initBuffer.buffer.flip();
1:             if (initBuffer.buffer.hasRemaining()) {
1:                 nextFrameSize = -1;
1:                 receiveCounter += initBuffer.readSize;
1:                 processCommand(initBuffer.buffer);
1:                 processCommand(initBuffer.buffer);
1:                 initBuffer.buffer.clear();
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void serviceRead() {
1:             doOpenWireInit();
1: 
/////////////////////////////////////////////////////////////////////////
1:            }
author:Dejan Bosanac
-------------------------------------------------------------------------------
commit:ad8879d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             int keyCount = selector.select(this.getSoTimeout());
1:                             if (keyCount == 0 && this.getSoTimeout() > 0 && ((System.currentTimeMillis() - now) >= this.getSoTimeout())) {
commit:52e4527
/////////////////////////////////////////////////////////////////////////
1: import java.net.SocketTimeoutException;
1: import java.nio.channels.SelectionKey;
1: import java.nio.channels.Selector;
1: import javax.net.ssl.SSLEngineResult.HandshakeStatus;
/////////////////////////////////////////////////////////////////////////
1:             if (bytesRead == 0 && !(sslEngine.getHandshakeStatus().equals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP))) {
/////////////////////////////////////////////////////////////////////////
1:         Selector selector = null;
1:         SelectionKey key = null;
1:         boolean readable = true;
0:         int timeout = 100;
1:         try {
1:             while (true) {
1:                 HandshakeStatus handshakeStatus = sslEngine.getHandshakeStatus();
1:                 switch (handshakeStatus) {
1:                     case NEED_UNWRAP:
1:                         if (readable) {
1:                             secureRead(ByteBuffer.allocate(sslSession.getApplicationBufferSize()));
1:                         }
1:                         if (this.status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
1:                             long now = System.currentTimeMillis();
1:                             if (selector == null) {
1:                                 selector = Selector.open();
1:                                 key = channel.register(selector, SelectionKey.OP_READ);
1:                             } else {
1:                                 key.interestOps(SelectionKey.OP_READ);
1:                             }
0:                             int keyCount = selector.select(timeout);
0:                             if (keyCount == 0 && ((System.currentTimeMillis() - now) >= timeout)) {
1:                                 throw new SocketTimeoutException("Timeout during handshake");
1:                             }
1:                             readable = key.isReadable();
1:                         }
1:                         break;
1:                     case NEED_TASK:
1:                         Runnable task;
1:                         while ((task = sslEngine.getDelegatedTask()) != null) {
1:                             task.run();
1:                         }
1:                         break;
1:                     case NEED_WRAP:
1:                         ((NIOOutputStream) buffOut).write(ByteBuffer.allocate(0));
1:                         break;
1:                     case FINISHED:
1:                     case NOT_HANDSHAKING:
1:                         finishHandshake();
1:                         return;
1:         } finally {
1:             if (key!=null) try {key.cancel();} catch (Exception ignore) {}
1:             if (selector!=null) try {selector.close();} catch (Exception ignore) {}
author:Timothy Bish
-------------------------------------------------------------------------------
commit:1948fe4
/////////////////////////////////////////////////////////////////////////
1:     protected String[] enabledProtocols;
/////////////////////////////////////////////////////////////////////////
0:             if (enabledProtocols != null) {
0:                 sslEngine.setEnabledProtocols(enabledProtocols);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String[] getEnabledProtocols() {
1:         return enabledProtocols;
1:     }
1: 
1:     public void setEnabledProtocols(String[] enabledProtocols) {
1:         this.enabledProtocols = enabledProtocols;
1:     }
commit:69e35d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         NIOOutputStream outputStream = null;
/////////////////////////////////////////////////////////////////////////
1:             outputStream = new NIOOutputStream(channel);
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 if(outputStream != null) {
1:                     outputStream.close();
1:                 }
1:                 super.closeStreams();
1:             } catch (Exception ex) {}
/////////////////////////////////////////////////////////////////////////
1:                 @Override
1:                 @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:                 doConsume(command);
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:838206f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Are we waiting for the next Command or are we building on the current one
1:         if (nextFrameSize == -1) {
1: 
1:             // We can get small packets that don't give us enough for the frame size
1:             // so allocate enough for the initial size value and
1:             if (plain.remaining() < Integer.SIZE) {
1:                 if (currentBuffer == null) {
1:                     currentBuffer = ByteBuffer.allocate(4);
1:                 }
1: 
1:                 // Go until we fill the integer sized current buffer.
1:                 while (currentBuffer.hasRemaining() && plain.hasRemaining()) {
1:                     currentBuffer.put(plain.get());
1:                 }
1: 
1:                 // Didn't we get enough yet to figure out next frame size.
1:                 if (currentBuffer.hasRemaining()) {
1:                     return;
1:                 } else {
1:                     currentBuffer.flip();
1:                     nextFrameSize = currentBuffer.getInt();
1:                 }
1: 
1:             } else {
1: 
1:                 // Either we are completing a previous read of the next frame size or its
1:                 // fully contained in plain already.
1:                 if (currentBuffer != null) {
1: 
1:                     // Finish the frame size integer read and get from the current buffer.
1:                     while (currentBuffer.hasRemaining()) {
1:                         currentBuffer.put(plain.get());
1:                     }
1: 
1:                     currentBuffer.flip();
1:                     nextFrameSize = currentBuffer.getInt();
1: 
1:                 } else {
1:                     nextFrameSize = plain.getInt();
1:                 }
1: 
1:             if (wireFormat instanceof OpenWireFormat) {
1:                 long maxFrameSize = ((OpenWireFormat) wireFormat).getMaxFrameSize();
1:                 if (nextFrameSize > maxFrameSize) {
1:                     throw new IOException("Frame size of " + (nextFrameSize / (1024 * 1024)) +
1:                                           " MB larger than max allowed " + (maxFrameSize / (1024 * 1024)) + " MB");
1:                 }
1:             }
1: 
1:             // now we got the data, lets reallocate and store the size for the marshaler.
1:             // if there's more data in plain, then the next call will start processing it.
1:             currentBuffer = ByteBuffer.allocate(nextFrameSize + 4);
1:             currentBuffer.putInt(nextFrameSize);
1: 
1:         } else {
1: 
1:             // If its all in one read then we can just take it all, otherwise take only
1:             // the current frame size and the next iteration starts a new command.
/////////////////////////////////////////////////////////////////////////
0:             // Either we have enough data for a new command or we have to wait for some more.
0:             if (currentBuffer.hasRemaining()) {
0:                 return;
0:             } else {
0:                 currentBuffer.flip();
0:                 Object command = wireFormat.unmarshal(new DataInputStream(new NIOInputStream(currentBuffer)));
0:                 doConsume((Command) command);
1:                 nextFrameSize = -1;
0:                 currentBuffer = null;
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (bytesRead == 0) {
1:                 return 0;
1:             }
1: 
commit:78265ea
/////////////////////////////////////////////////////////////////////////
1:                     if (readCount == 0) {
1:                     }
/////////////////////////////////////////////////////////////////////////
1: 
1:                     receiveCounter += readCount;
commit:65af81e
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: public class NIOSSLTransport extends NIOTransport {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(NIOSSLTransport.class);
/////////////////////////////////////////////////////////////////////////
1:             String remoteHost = null;
1:             int remotePort = -1;
1: 
1:             try {
1:                 URI remoteAddress = new URI(this.getRemoteAddress());
1:                 remoteHost = remoteAddress.getHost();
1:                 remotePort = remoteAddress.getPort();
1:             } catch (Exception e) {
1:             }
1: 
0:             if (remoteHost != null && remotePort != -1) {
0:                 sslEngine = sslContext.createSSLEngine(remoteHost, remotePort);
0:             } else {
0:                 sslEngine = sslContext.createSSLEngine();
1:             }
1: 
1: 
0:             if (wantClientAuth) {
0:                 sslEngine.setWantClientAuth(wantClientAuth);
1:             }
1: 
0:             if (needClientAuth) {
0:                 sslEngine.setNeedClientAuth(needClientAuth);
1:             }
/////////////////////////////////////////////////////////////////////////
1:     protected void finishHandshake() throws Exception {
1:         if (handshakeInProgress) {
1:             handshakeInProgress = false;
0:             nextFrameSize = -1;
1:             // Once handshake completes we need to ask for the now real sslSession
1:             // otherwise the session would return 'SSL_NULL_WITH_NULL_NULL' for the
1:             // cipher suite.
1:             sslSession = sslEngine.getSession();
0:             // listen for events telling us when the socket is readable.
0:             selection = SelectorManager.getInstance().register(channel, new SelectorManager.Listener() {
0:                 public void onSelect(SelectorSelection selection) {
0:                     serviceRead();
1:                 }
0:                 public void onError(SelectorSelection selection, Throwable error) {
0:                     if (error instanceof IOException) {
0:                         onException((IOException) error);
0:                     } else {
0:                         onException(IOExceptionSupport.create(error));
1:                     }
1:                 }
0:             });
1:         }
/////////////////////////////////////////////////////////////////////////
1:             while (true) {
/////////////////////////////////////////////////////////////////////////
1:                     if (readCount == -1) {
/////////////////////////////////////////////////////////////////////////
0:                 throw new IOException("Frame size of " + (nextFrameSize / (1024 * 1024)) +
0:                                        " MB larger than max allowed " + (maxFrameSize / (1024 * 1024)) + " MB");
/////////////////////////////////////////////////////////////////////////
1:                 if (inputBuffer.position() == 0 || status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
/////////////////////////////////////////////////////////////////////////
1:         } while (res.getStatus() == SSLEngineResult.Status.OK && res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP
1:                 && res.bytesProduced() == 0);
1:             finishHandshake();
1:         // TODO deal with BUFFER_OVERFLOW
/////////////////////////////////////////////////////////////////////////
0:             case NEED_UNWRAP:
0:                 secureRead(ByteBuffer.allocate(sslSession.getApplicationBufferSize()));
1:                 break;
0:             case NEED_TASK:
0:                 Runnable task;
0:                 while ((task = sslEngine.getDelegatedTask()) != null) {
0:                     taskRunnerFactory.execute(task);
1:                 }
1:                 break;
0:             case NEED_WRAP:
0:                 ((NIOOutputStream) buffOut).write(ByteBuffer.allocate(0));
1:                 break;
0:             case FINISHED:
0:             case NOT_HANDSHAKING:
0:                 finishHandshake();
0:                 return;
/////////////////////////////////////////////////////////////////////////
1:      * Overriding in order to add the client's certificates to ConnectionInfo Commands.
1:      * @param command
1:      *            The Command coming in.
1:             ConnectionInfo connectionInfo = (ConnectionInfo) command;
/////////////////////////////////////////////////////////////////////////
1:             if (sslEngine.getSession() != null) {
1:                 clientCertChain = (X509Certificate[]) sslEngine.getSession().getPeerCertificates();
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("Failed to get peer certificates.", e);
1:             }
commit:324ab99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // initialize engine, the initial sslSession we get will need to be
1:             // updated once the ssl handshake process is completed.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:               // Once handshake completes we need to ask for the now real sslSession
0:               // otherwise the session would return 'SSL_NULL_WITH_NULL_NULL' for the
0:               // cipher suite.
0:               sslSession = sslEngine.getSession();
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * Overriding in order to add the client's certificates to ConnectionInfo Commmands.
commit:6175dc4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.security.cert.X509Certificate;
1: 
1: import javax.net.SocketFactory;
1: import javax.net.ssl.SSLContext;
1: import javax.net.ssl.SSLEngine;
1: import javax.net.ssl.SSLEngineResult;
1: import javax.net.ssl.SSLPeerUnverifiedException;
1: import javax.net.ssl.SSLSession;
1: 
0: import org.apache.activemq.command.Command;
1: import org.apache.activemq.command.ConnectionInfo;
1: import org.apache.activemq.openwire.OpenWireFormat;
0: import org.apache.activemq.thread.DefaultThreadPools;
1: import org.apache.activemq.util.IOExceptionSupport;
1: import org.apache.activemq.util.ServiceStopper;
1: import org.apache.activemq.wireformat.WireFormat;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Overriding in order to add the client's certificates to ConnectionInfo
0:      * Commmands.
1:      *
0:      * @param command The Command coming in.
1:      */
1:     @Override
1:     public void doConsume(Object command) {
1:         if (command instanceof ConnectionInfo) {
0:             ConnectionInfo connectionInfo = (ConnectionInfo)command;
1:             connectionInfo.setTransportContext(getPeerCertificates());
1:         }
1:         super.doConsume(command);
1:     }
1: 
1:     /**
1:      * @return peer certificate chain associated with the ssl socket
1:      */
1:     public X509Certificate[] getPeerCertificates() {
1: 
1:         X509Certificate[] clientCertChain = null;
1:         try {
0:             if (sslSession != null) {
0:                 clientCertChain = (X509Certificate[])sslSession.getPeerCertificates();
1:             }
1:         } catch (SSLPeerUnverifiedException e) {
1:         }
1: 
1:         return clientCertChain;
1:     }
1: 
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:8a01c5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.thread.TaskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
1:     protected volatile boolean handshakeInProgress = false;
1:     protected TaskRunnerFactory taskRunnerFactory;
/////////////////////////////////////////////////////////////////////////
0:                         taskRunnerFactory.execute(task);
/////////////////////////////////////////////////////////////////////////
1:     protected void doStart() throws Exception {
1:         taskRunnerFactory = new TaskRunnerFactory("ActiveMQ NIOSSLTransport Task");
1:         // no need to init as we can delay that until demand (eg in doHandshake)
1:         super.doStart();
1:     }
1: 
1:     @Override
1:         if (taskRunnerFactory != null) {
1:             taskRunnerFactory.shutdownNow();
1:             taskRunnerFactory = null;
1:         }
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:e96eab5
/////////////////////////////////////////////////////////////////////////
1:                     if (status == SSLEngineResult.Status.OK && handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
1:                         plain.clear();
0:                     } else {
0:                         plain.compact();
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                 if (status == SSLEngineResult.Status.OK && handshakeStatus != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {
1:                     processCommand(plain);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         if (!(inputBuffer.position() != 0 && inputBuffer.hasRemaining()) || status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
commit:036f2a8
/////////////////////////////////////////////////////////////////////////
1: import java.io.EOFException;
/////////////////////////////////////////////////////////////////////////
1:     protected boolean needClientAuth;
1:     protected boolean wantClientAuth;
1:     protected String[] enabledCipherSuites;
0:     protected boolean handshakeInProgress = false;
1:     protected SSLEngineResult.Status status = null;
1:     protected SSLEngineResult.HandshakeStatus handshakeStatus = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             while(true) {
1:                 if (!plain.hasRemaining()) {
0:                     plain.clear();
1:                     int readCount = secureRead(plain);
1: 
0:                     if (readCount == 0)
0:                         break;
1: 
1:                     // channel is closed, cleanup
0:                     if (readCount== -1) {
1:                         onException(new EOFException());
1:                         selection.close();
0:                         break;
0:                 processCommand(plain);
1: 
1:             }
1:     protected void processCommand(ByteBuffer plain) throws Exception {
0:         nextFrameSize = plain.getInt();
0:         if (wireFormat instanceof OpenWireFormat) {
0:             long maxFrameSize = ((OpenWireFormat) wireFormat).getMaxFrameSize();
0:             if (nextFrameSize > maxFrameSize) {
0:                 throw new IOException("Frame size of " + (nextFrameSize / (1024 * 1024)) + " MB larger than max allowed " + (maxFrameSize / (1024 * 1024)) + " MB");
1:             }
1:         }
0:         currentBuffer = ByteBuffer.allocate(nextFrameSize + 4);
0:         currentBuffer.putInt(nextFrameSize);
0:         if (currentBuffer.hasRemaining()) {
0:             if (currentBuffer.remaining() >= plain.remaining()) {
0:                 currentBuffer.put(plain);
0:             } else {
0:                 byte[] fill = new byte[currentBuffer.remaining()];
0:                 plain.get(fill);
0:                 currentBuffer.put(fill);
1:             }
1:         }
0:         if (currentBuffer.hasRemaining()) {
0:             return;
0:         } else {
0:             currentBuffer.flip();
0:             Object command = wireFormat.unmarshal(new DataInputStream(new NIOInputStream(currentBuffer)));
0:             doConsume((Command) command);
0:             nextFrameSize = -1;
1:         }
1:     }
1:     protected int secureRead(ByteBuffer plain) throws Exception {
1: 
0:         if (!(inputBuffer.position() != 0 && inputBuffer.hasRemaining())) {
1:             int bytesRead = channel.read(inputBuffer);
1: 
1:             if (bytesRead == -1) {
1:                 sslEngine.closeInbound();
0:                 if (inputBuffer.position() == 0 ||
0:                         status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
1:                     return -1;
1:                 }
/////////////////////////////////////////////////////////////////////////
0:            finishHandshake();
1: 
/////////////////////////////////////////////////////////////////////////
1:             channel = null;
commit:48fa20a
/////////////////////////////////////////////////////////////////////////
0:             if (enabledCipherSuites != null) {
0:                 sslEngine.setEnabledCipherSuites(enabledCipherSuites);
1:             }
commit:a26f03f
/////////////////////////////////////////////////////////////////////////
0:     private boolean needClientAuth;
0:     private boolean wantClientAuth;
0:     private String[] enabledCipherSuites;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // initialize engine
0:             sslEngine.setEnabledCipherSuites(enabledCipherSuites);
0:             sslEngine.setNeedClientAuth(needClientAuth);
0:             sslEngine.setWantClientAuth(wantClientAuth);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean isNeedClientAuth() {
1:         return needClientAuth;
1:     }
1: 
1:     public void setNeedClientAuth(boolean needClientAuth) {
1:         this.needClientAuth = needClientAuth;
1:     }
1: 
1:     public boolean isWantClientAuth() {
1:         return wantClientAuth;
1:     }
1: 
1:     public void setWantClientAuth(boolean wantClientAuth) {
1:         this.wantClientAuth = wantClientAuth;
1:     }
1: 
1:     public String[] getEnabledCipherSuites() {
1:         return enabledCipherSuites;
1:     }
1: 
1:     public void setEnabledCipherSuites(String[] enabledCipherSuites) {
1:         this.enabledCipherSuites = enabledCipherSuites;
1:     }
commit:cdf2e79
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.thread.DefaultThreadPools;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                         DefaultThreadPools.getDefaultTaskRunnerFactory().execute(task);
commit:e504086
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: 
1: package org.apache.activemq.transport.nio;
1: 
0: import org.apache.activemq.command.Command;
0: import org.apache.activemq.openwire.OpenWireFormat;
0: import org.apache.activemq.util.IOExceptionSupport;
0: import org.apache.activemq.util.ServiceStopper;
0: import org.apache.activemq.wireformat.WireFormat;
1: 
0: import javax.net.SocketFactory;
0: import javax.net.ssl.*;
1: import java.io.DataInputStream;
1: import java.io.DataOutputStream;
1: import java.io.IOException;
1: import java.net.Socket;
1: import java.net.URI;
1: import java.net.UnknownHostException;
1: import java.nio.ByteBuffer;
1: 
0: public class NIOSSLTransport extends NIOTransport  {
1: 
1:     protected SSLContext sslContext;
1:     protected SSLEngine sslEngine;
1:     protected SSLSession sslSession;
1: 
1: 
0:     boolean handshakeInProgress = false;
0:     SSLEngineResult.Status status = null;
0:     SSLEngineResult.HandshakeStatus handshakeStatus = null;
1: 
1:     public NIOSSLTransport(WireFormat wireFormat, SocketFactory socketFactory, URI remoteLocation, URI localLocation) throws UnknownHostException, IOException {
1:         super(wireFormat, socketFactory, remoteLocation, localLocation);
1:     }
1: 
0:     public NIOSSLTransport(WireFormat wireFormat, Socket socket) throws IOException {
0:         super(wireFormat, socket);
1:     }
1: 
1:     public void setSslContext(SSLContext sslContext) {
1:         this.sslContext = sslContext;
1:     }
1: 
0:     @Override
1:     protected void initializeStreams() throws IOException {
1: 
1:         try {
1:             channel = socket.getChannel();
1:             channel.configureBlocking(false);
1: 
1:             if (sslContext == null) {
1:                 sslContext = SSLContext.getDefault();
1:             }
1: 
0:             sslEngine = sslContext.createSSLEngine();
0:             sslEngine.setUseClientMode(false);
0:             sslSession = sslEngine.getSession();
1: 
0:             inputBuffer = ByteBuffer.allocate(sslSession.getPacketBufferSize());
0:             inputBuffer.clear();
0:             currentBuffer = ByteBuffer.allocate(sslSession.getApplicationBufferSize());
1: 
0:             NIOOutputStream outputStream = new NIOOutputStream(channel);
1:             outputStream.setEngine(sslEngine);
1:             this.dataOut = new DataOutputStream(outputStream);
1:             this.buffOut = outputStream;
1: 
0:             sslEngine.beginHandshake();
1:             handshakeStatus = sslEngine.getHandshakeStatus();
1: 
1: 
1:             doHandshake();
1: 
1:         } catch (Exception e) {
1:             throw new IOException(e);
1:         }
1: 
1:     }
1: 
0:     protected void finishHandshake() throws Exception  {
1:           if (handshakeInProgress) {
0:               handshakeInProgress = false;
0:               nextFrameSize = -1;
1: 
0:               // listen for events telling us when the socket is readable.
0:               selection = SelectorManager.getInstance().register(channel, new SelectorManager.Listener() {
0:                   public void onSelect(SelectorSelection selection) {
0:                       serviceRead();
1:                   }
1: 
0:                   public void onError(SelectorSelection selection, Throwable error) {
0:                       if (error instanceof IOException) {
0:                           onException((IOException) error);
0:                       } else {
0:                           onException(IOExceptionSupport.create(error));
1:                       }
1:                   }
0:               });
1:           }
1:     }
1: 
1: 
1: 
0:     protected void serviceRead() {
1:         try {
1:             if (handshakeInProgress) {
1:                 doHandshake();
1:             }
1: 
1:             ByteBuffer plain = ByteBuffer.allocate(sslSession.getApplicationBufferSize());
1:             plain.position(plain.limit());
1: 
0:             while (true) {
0:                 if (nextFrameSize == -1) {
0:                     if (!plain.hasRemaining()) {
0:                         plain.clear();
0:                         int readCount = secureRead(plain);
0:                         if (readCount == 0)
0:                             break;
1:                     }
0:                     nextFrameSize = plain.getInt();
0:                     if (wireFormat instanceof OpenWireFormat) {
0:                         long maxFrameSize = ((OpenWireFormat)wireFormat).getMaxFrameSize();
0:                         if (nextFrameSize > maxFrameSize) {
0:                             throw new IOException("Frame size of " + (nextFrameSize / (1024 * 1024)) + " MB larger than max allowed " + (maxFrameSize / (1024 * 1024)) + " MB");
1:                         }
1:                     }
0:                     currentBuffer = ByteBuffer.allocate(nextFrameSize + 4);
0:                     currentBuffer.putInt(nextFrameSize);
0:                     if (currentBuffer.hasRemaining()) {
0:                         if (currentBuffer.remaining() >= plain.remaining()) {
0:                             currentBuffer.put(plain);
0:                         } else {
0:                             byte[] fill = new byte[currentBuffer.remaining()];
0:                             plain.get(fill);
0:                             currentBuffer.put(fill);
1:                         }
1:                     }
1: 
0:                     if (currentBuffer.hasRemaining()) {
0:                         continue;
0:                     } else {
0:                         currentBuffer.flip();
0:                         Object command = wireFormat.unmarshal(new DataInputStream(new NIOInputStream(currentBuffer)));
0:                         doConsume((Command) command);
1: 
0:                         nextFrameSize = -1;
1:                     }
1:                 }
1:             }
1: 
1:         } catch (IOException e) {
1:             onException(e);
1:         } catch (Throwable e) {
1:             onException(IOExceptionSupport.create(e));
1:         }
1: 
1:     }
1: 
1: 
1: 
0:     private int secureRead(ByteBuffer plain) throws Exception {
0:         int bytesRead = channel.read(inputBuffer);
0:         if (bytesRead == -1) {
1:             sslEngine.closeInbound();
0:             if (inputBuffer.position() == 0 ||
0:                     status == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
1:                 return -1;
1:             }
1:         }
1: 
0:         plain.clear();
1: 
1:         inputBuffer.flip();
1:         SSLEngineResult res;
1:         do {
1:             res = sslEngine.unwrap(inputBuffer, plain);
0:         } while (res.getStatus() == SSLEngineResult.Status.OK &&
0:                 res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP &&
0:                 res.bytesProduced() == 0);
1: 
1:         if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) {
0:             finishHandshake();
1:         }
1: 
1:         status = res.getStatus();
1:         handshakeStatus = res.getHandshakeStatus();
1: 
0:         //TODO deal with BUFFER_OVERFLOW
1: 
1:         if (status == SSLEngineResult.Status.CLOSED) {
0:             //TODO do shutdown
1:             sslEngine.closeInbound();
1:             return -1;
1:         }
1: 
1:         inputBuffer.compact();
1:         plain.flip();
1: 
1:         return plain.remaining();
1:     }
1: 
1:     protected void doHandshake() throws Exception {
1:         handshakeInProgress = true;
0:         while (true) {
0:             switch (sslEngine.getHandshakeStatus()) {
0:                 case NEED_UNWRAP:
0:                     secureRead(ByteBuffer.allocate(sslSession.getApplicationBufferSize()));
0:                     break;
0:                 case NEED_TASK:
0:                     //TODO use the pool
0:                     Runnable task;
0:                     while ((task = sslEngine.getDelegatedTask()) != null) {
0:                         task.run();
1:                     }
0:                     break;
0:                 case NEED_WRAP:
0:                     ((NIOOutputStream)buffOut).write(ByteBuffer.allocate(0));
0:                     break;
0:                 case FINISHED:
0:                 case NOT_HANDSHAKING:
0:                     finishHandshake();
0:                     return;
1:             }
1:         }
1:     }
1: 
0:     @Override
1:     protected void doStop(ServiceStopper stopper) throws Exception {
1:         if (channel != null) {
1:             channel.close();
1:         }
1:         super.doStop(stopper);
1:     }
1: }
============================================================================