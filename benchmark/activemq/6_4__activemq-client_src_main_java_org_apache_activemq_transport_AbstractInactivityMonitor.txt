1:0885c60: /**
1:0885c60:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:0885c60:  * contributor license agreements.  See the NOTICE file distributed with
1:0885c60:  * this work for additional information regarding copyright ownership.
1:0885c60:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:0885c60:  * (the "License"); you may not use this file except in compliance with
1:0885c60:  * the License.  You may obtain a copy of the License at
1:0885c60:  *
1:0885c60:  *      http://www.apache.org/licenses/LICENSE-2.0
1:0885c60:  *
1:0885c60:  * Unless required by applicable law or agreed to in writing, software
1:0885c60:  * distributed under the License is distributed on an "AS IS" BASIS,
1:0885c60:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0885c60:  * See the License for the specific language governing permissions and
1:0885c60:  * limitations under the License.
1:0885c60:  */
1:0885c60: package org.apache.activemq.transport;
3:0885c60: 
1:0885c60: import java.io.IOException;
1:0885c60: import java.util.Timer;
1:32e009d: import java.util.concurrent.RejectedExecutionException;
1:0885c60: import java.util.concurrent.SynchronousQueue;
1:0885c60: import java.util.concurrent.ThreadFactory;
1:0885c60: import java.util.concurrent.ThreadPoolExecutor;
1:0885c60: import java.util.concurrent.TimeUnit;
1:0885c60: import java.util.concurrent.atomic.AtomicBoolean;
1:0885c60: import java.util.concurrent.atomic.AtomicInteger;
1:f33f32e: import java.util.concurrent.locks.ReentrantReadWriteLock;
1:0885c60: 
1:0885c60: import org.apache.activemq.command.KeepAliveInfo;
1:0885c60: import org.apache.activemq.command.WireFormatInfo;
1:0885c60: import org.apache.activemq.thread.SchedulerTimerTask;
1:d1f42bd: import org.apache.activemq.util.ThreadPoolUtils;
1:0885c60: import org.apache.activemq.wireformat.WireFormat;
1:0885c60: import org.slf4j.Logger;
1:0885c60: import org.slf4j.LoggerFactory;
1:0885c60: 
1:0885c60: /**
1:0885c60:  * Used to make sure that commands are arriving periodically from the peer of
1:0885c60:  * the transport.
1:0885c60:  */
1:0885c60: public abstract class AbstractInactivityMonitor extends TransportFilter {
1:0885c60: 
1:0885c60:     private static final Logger LOG = LoggerFactory.getLogger(AbstractInactivityMonitor.class);
1:0885c60: 
1:3125cae:     private static final long DEFAULT_CHECK_TIME_MILLS = 30000;
1:3125cae: 
1:0885c60:     private static ThreadPoolExecutor ASYNC_TASKS;
1:0885c60:     private static int CHECKER_COUNTER;
1:0885c60:     private static Timer READ_CHECK_TIMER;
1:0885c60:     private static Timer WRITE_CHECK_TIMER;
1:0885c60: 
1:0885c60:     private final AtomicBoolean monitorStarted = new AtomicBoolean(false);
1:0885c60: 
1:0885c60:     private final AtomicBoolean commandSent = new AtomicBoolean(false);
1:0885c60:     private final AtomicBoolean inSend = new AtomicBoolean(false);
1:0885c60:     private final AtomicBoolean failed = new AtomicBoolean(false);
1:0885c60: 
1:0885c60:     private final AtomicBoolean commandReceived = new AtomicBoolean(true);
1:0885c60:     private final AtomicBoolean inReceive = new AtomicBoolean(false);
1:0885c60:     private final AtomicInteger lastReceiveCounter = new AtomicInteger(0);
1:0885c60: 
1:f33f32e:     private final ReentrantReadWriteLock sendLock = new ReentrantReadWriteLock();
1:f33f32e: 
1:3125cae:     private SchedulerTimerTask connectCheckerTask;
1:0885c60:     private SchedulerTimerTask writeCheckerTask;
1:0885c60:     private SchedulerTimerTask readCheckerTask;
1:0885c60: 
1:3125cae:     private long connectAttemptTimeout = DEFAULT_CHECK_TIME_MILLS;
1:0885c60:     private long readCheckTime = DEFAULT_CHECK_TIME_MILLS;
1:0885c60:     private long writeCheckTime = DEFAULT_CHECK_TIME_MILLS;
1:0885c60:     private long initialDelayTime = DEFAULT_CHECK_TIME_MILLS;
1:0885c60:     private boolean useKeepAlive = true;
1:0885c60:     private boolean keepAliveResponseRequired;
1:0885c60: 
1:0885c60:     protected WireFormat wireFormat;
1:0885c60: 
1:3125cae:     private final Runnable connectChecker = new Runnable() {
1:3125cae: 
1:3125cae:         private final long startTime = System.currentTimeMillis();
1:3125cae: 
1:3125cae:         @Override
1:3125cae:         public void run() {
1:3125cae:             long now = System.currentTimeMillis();
1:3125cae: 
1:3125cae:             if ((now - startTime) >= connectAttemptTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {
1:3125cae:                 LOG.debug("No connection attempt made in time for {}! Throwing InactivityIOException.", AbstractInactivityMonitor.this.toString());
1:3125cae:                 try {
1:3125cae:                     ASYNC_TASKS.execute(new Runnable() {
1:3125cae:                         @Override
1:3125cae:                         public void run() {
1:3125cae:                             onException(new InactivityIOException(
1:e5a94bf:                                 "Channel was inactive (no connection attempt made) for too (>" + (connectAttemptTimeout) + ") long: " + next.getRemoteAddress()));
1:3125cae:                         }
1:3125cae:                     });
1:3125cae:                 } catch (RejectedExecutionException ex) {
1:3125cae:                     if (!ASYNC_TASKS.isShutdown()) {
1:3125cae:                         LOG.error("Async connection timeout task was rejected from the executor: ", ex);
1:3125cae:                         throw ex;
1:3125cae:                     }
1:3125cae:                 }
1:3125cae:             }
1:3125cae:         }
1:3125cae:     };
1:3125cae: 
1:0885c60:     private final Runnable readChecker = new Runnable() {
1:0885c60:         long lastRunTime;
1:80d0605: 
1:80d0605:         @Override
3:0885c60:         public void run() {
1:0885c60:             long now = System.currentTimeMillis();
1:80d0605:             long elapsed = (now - lastRunTime);
1:f33f32e: 
1:c7d33ad:             if (lastRunTime != 0) {
1:c7d33ad:                 LOG.debug("{}ms elapsed since last read check.", elapsed);
11:0885c60:             }
1:0885c60: 
1:0885c60:             // Perhaps the timer executed a read check late.. and then executes
1:0885c60:             // the next read check on time which causes the time elapsed between
1:0885c60:             // read checks to be small..
1:0885c60: 
1:80d0605:             // If less than 90% of the read check Time elapsed then abort this
1:c7d33ad:             // read check.
1:c7d33ad:             if (!allowReadCheck(elapsed)) {
1:c7d33ad:                 LOG.debug("Aborting read check...Not enough time elapsed since last read check.");
1:0885c60:                 return;
1:32e009d:             }
1:32e009d: 
1:0885c60:             lastRunTime = now;
1:0885c60:             readCheck();
1:0885c60:         }
1:32e009d: 
1:80d0605:         @Override
1:c659506:         public String toString() {
1:c659506:             return "ReadChecker";
1:0885c60:         }
3:0885c60:     };
1:32e009d: 
1:0885c60:     private boolean allowReadCheck(long elapsed) {
1:0885c60:         return elapsed > (readCheckTime * 9 / 10);
1:0885c60:     }
1:0885c60: 
1:0885c60:     private final Runnable writeChecker = new Runnable() {
1:0885c60:         long lastRunTime;
1:32e009d: 
1:80d0605:         @Override
1:32e009d:         public void run() {
1:0885c60:             long now = System.currentTimeMillis();
1:c7d33ad:             if (lastRunTime != 0) {
1:c7d33ad:                 LOG.debug("{}: {}ms elapsed since last write check.", this, (now - lastRunTime));
1:0885c60:             }
1:0885c60:             lastRunTime = now;
1:0885c60:             writeCheck();
1:0885c60:         }
1:0885c60: 
1:80d0605:         @Override
1:c659506:         public String toString() {
1:c659506:             return "WriteChecker";
1:0885c60:         }
1:0885c60:     };
1:0885c60: 
1:0885c60:     public AbstractInactivityMonitor(Transport next, WireFormat wireFormat) {
1:0885c60:         super(next);
1:0885c60:         this.wireFormat = wireFormat;
1:0885c60:     }
1:0885c60: 
1:80d0605:     @Override
1:0885c60:     public void start() throws Exception {
1:0885c60:         next.start();
1:0885c60:         startMonitorThreads();
1:0885c60:     }
1:0885c60: 
1:80d0605:     @Override
1:0885c60:     public void stop() throws Exception {
1:0885c60:         stopMonitorThreads();
1:0885c60:         next.stop();
1:0885c60:     }
1:0885c60: 
1:0885c60:     final void writeCheck() {
1:0885c60:         if (inSend.get()) {
1:c7d33ad:             LOG.trace("Send in progress. Skipping write check.");
1:0885c60:             return;
1:0885c60:         }
1:0885c60: 
1:3125cae:         if (!commandSent.get() && useKeepAlive && monitorStarted.get() && !ASYNC_TASKS.isShutdown()) {
1:c7d33ad:             LOG.trace("{} no message sent since last write check, sending a KeepAliveInfo", this);
1:0885c60: 
1:32e009d:             try {
1:32e009d:                 ASYNC_TASKS.execute(new Runnable() {
1:80d0605:                     @Override
1:32e009d:                     public void run() {
1:c7d33ad:                         LOG.debug("Running {}", this);
1:32e009d:                         if (monitorStarted.get()) {
1:32e009d:                             try {
1:80d0605:                                 // If we can't get the lock it means another
1:80d0605:                                 // write beat us into the
1:32e009d:                                 // send and we don't need to heart beat now.
1:32e009d:                                 if (sendLock.writeLock().tryLock()) {
1:32e009d:                                     KeepAliveInfo info = new KeepAliveInfo();
1:32e009d:                                     info.setResponseRequired(keepAliveResponseRequired);
1:32e009d:                                     doOnewaySend(info);
1:32e009d:                                 }
1:32e009d:                             } catch (IOException e) {
1:32e009d:                                 onException(e);
1:32e009d:                             } finally {
1:80d0605:                                 if (sendLock.writeLock().isHeldByCurrentThread()) {
1:32e009d:                                     sendLock.writeLock().unlock();
1:80d0605:                                 }
1:32e009d:                             }
1:32e009d:                         }
1:32e009d:                     }
1:32e009d: 
1:32e009d:                     @Override
1:32e009d:                     public String toString() {
1:32e009d:                         return "WriteCheck[" + getRemoteAddress() + "]";
1:32e009d:                     };
1:32e009d:                 });
1:32e009d:             } catch (RejectedExecutionException ex) {
1:3125cae:                 if (!ASYNC_TASKS.isShutdown()) {
1:32e009d:                     LOG.error("Async write check was rejected from the executor: ", ex);
1:32e009d:                     throw ex;
1:32e009d:                 }
1:32e009d:             }
1:0885c60:         } else {
1:c7d33ad:             LOG.trace("{} message sent since last write check, resetting flag.", this);
1:f33f32e:         }
1:0885c60: 
1:0885c60:         commandSent.set(false);
1:0885c60:     }
1:0885c60: 
1:0885c60:     final void readCheck() {
1:0885c60:         int currentCounter = next.getReceiveCounter();
1:0885c60:         int previousCounter = lastReceiveCounter.getAndSet(currentCounter);
1:80d0605:         if (inReceive.get() || currentCounter != previousCounter) {
1:c7d33ad:             LOG.trace("A receive is in progress, skipping read check.");
1:0885c60:             return;
1:0885c60:         }
1:3125cae:         if (!commandReceived.get() && monitorStarted.get() && !ASYNC_TASKS.isShutdown()) {
1:c7d33ad:             LOG.debug("No message received since last read check for {}. Throwing InactivityIOException.", this);
1:0885c60: 
1:32e009d:             try {
1:32e009d:                 ASYNC_TASKS.execute(new Runnable() {
1:32e009d:                     @Override
1:0885c60:                     public void run() {
1:c7d33ad:                         LOG.debug("Running {}", this);
1:80d0605:                         onException(new InactivityIOException("Channel was inactive for too (>" + readCheckTime + ") long: " + next.getRemoteAddress()));
1:0885c60:                     }
1:0885c60: 
1:c659506:                     @Override
1:32e009d:                     public String toString() {
1:32e009d:                         return "ReadCheck[" + getRemoteAddress() + "]";
1:32e009d:                     };
1:32e009d:                 });
1:32e009d:             } catch (RejectedExecutionException ex) {
1:3125cae:                 if (!ASYNC_TASKS.isShutdown()) {
1:32e009d:                     LOG.error("Async read check was rejected from the executor: ", ex);
1:32e009d:                     throw ex;
1:32e009d:                 }
1:32e009d:             }
1:0885c60:         } else {
5:0885c60:             if (LOG.isTraceEnabled()) {
1:0885c60:                 LOG.trace("Message received since last read check, resetting flag: ");
1:0885c60:             }
1:0885c60:         }
1:0885c60:         commandReceived.set(false);
1:0885c60:     }
1:0885c60: 
1:0885c60:     protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;
1:80d0605: 
1:0885c60:     protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;
1:0885c60: 
1:80d0605:     @Override
1:0885c60:     public void onCommand(Object command) {
1:0885c60:         commandReceived.set(true);
1:0885c60:         inReceive.set(true);
3:0885c60:         try {
1:0885c60:             if (command.getClass() == KeepAliveInfo.class) {
1:0885c60:                 KeepAliveInfo info = (KeepAliveInfo) command;
1:0885c60:                 if (info.isResponseRequired()) {
1:f33f32e:                     sendLock.readLock().lock();
1:0885c60:                     try {
1:0885c60:                         info.setResponseRequired(false);
2:0885c60:                         oneway(info);
2:0885c60:                     } catch (IOException e) {
2:0885c60:                         onException(e);
1:f33f32e:                     } finally {
1:f33f32e:                         sendLock.readLock().unlock();
1:0885c60:                     }
1:0885c60:                 }
1:0885c60:             } else {
1:0885c60:                 if (command.getClass() == WireFormatInfo.class) {
2:0885c60:                     synchronized (this) {
1:0885c60:                         try {
1:0885c60:                             processInboundWireFormatInfo((WireFormatInfo) command);
1:0885c60:                         } catch (IOException e) {
1:0885c60:                             onException(e);
1:0885c60:                         }
1:0885c60:                     }
1:0885c60:                 }
1:0885c60: 
1:f33f32e:                 transportListener.onCommand(command);
1:0885c60:             }
1:f33f32e:         } finally {
1:0885c60:             inReceive.set(false);
1:0885c60:         }
1:0885c60:     }
1:0885c60: 
1:c659506:     @Override
1:0885c60:     public void oneway(Object o) throws IOException {
1:f33f32e:         // To prevent the inactivity monitor from sending a message while we
1:80d0605:         // are performing a send we take a read lock. The inactivity monitor
1:80d0605:         // sends its Heart-beat commands under a write lock. This means that
1:f33f32e:         // the MutexTransport is still responsible for synchronizing sends
1:3125cae:         sendLock.readLock().lock();
1:f33f32e:         inSend.set(true);
1:f33f32e:         try {
1:f33f32e:             doOnewaySend(o);
1:f33f32e:         } finally {
1:f33f32e:             commandSent.set(true);
1:f33f32e:             inSend.set(false);
1:3125cae:             sendLock.readLock().unlock();
1:f33f32e:         }
1:f33f32e:     }
1:0885c60: 
1:f33f32e:     // Must be called under lock, either read or write on sendLock.
1:f33f32e:     private void doOnewaySend(Object command) throws IOException {
1:32e009d:         if (failed.get()) {
1:32e009d:             throw new InactivityIOException("Cannot send, channel has already failed: " + next.getRemoteAddress());
1:f33f32e:         }
1:f33f32e:         if (command.getClass() == WireFormatInfo.class) {
1:f33f32e:             synchronized (this) {
1:f33f32e:                 processOutboundWireFormatInfo((WireFormatInfo) command);
1:0885c60:             }
1:0885c60:         }
1:f33f32e:         next.oneway(command);
1:0885c60:     }
1:0885c60: 
1:80d0605:     @Override
1:0885c60:     public void onException(IOException error) {
1:0885c60:         if (failed.compareAndSet(false, true)) {
1:0885c60:             stopMonitorThreads();
1:80d0605:             if (sendLock.writeLock().isHeldByCurrentThread()) {
1:80d0605:                 sendLock.writeLock().unlock();
1:80d0605:             }
1:0885c60:             transportListener.onException(error);
1:0885c60:         }
1:0885c60:     }
1:0885c60: 
1:0885c60:     public void setUseKeepAlive(boolean val) {
1:0885c60:         useKeepAlive = val;
1:0885c60:     }
1:0885c60: 
1:3125cae:     public long getConnectAttemptTimeout() {
1:3125cae:         return connectAttemptTimeout;
1:3125cae:     }
1:3125cae: 
1:3125cae:     public void setConnectAttemptTimeout(long connectionTimeout) {
1:3125cae:         this.connectAttemptTimeout = connectionTimeout;
1:3125cae:     }
1:3125cae: 
1:0885c60:     public long getReadCheckTime() {
1:0885c60:         return readCheckTime;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public void setReadCheckTime(long readCheckTime) {
1:0885c60:         this.readCheckTime = readCheckTime;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public long getWriteCheckTime() {
1:0885c60:         return writeCheckTime;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public void setWriteCheckTime(long writeCheckTime) {
1:0885c60:         this.writeCheckTime = writeCheckTime;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public long getInitialDelayTime() {
1:0885c60:         return initialDelayTime;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public void setInitialDelayTime(long initialDelayTime) {
1:0885c60:         this.initialDelayTime = initialDelayTime;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public boolean isKeepAliveResponseRequired() {
1:0885c60:         return this.keepAliveResponseRequired;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public void setKeepAliveResponseRequired(boolean value) {
1:0885c60:         this.keepAliveResponseRequired = value;
1:0885c60:     }
1:0885c60: 
1:0885c60:     public boolean isMonitorStarted() {
1:0885c60:         return this.monitorStarted.get();
1:0885c60:     }
1:0885c60: 
1:3125cae:     abstract protected boolean configuredOk() throws IOException;
1:3125cae: 
1:3125cae:     public synchronized void startConnectCheckTask() {
1:3125cae:         startConnectCheckTask(getConnectAttemptTimeout());
1:3125cae:     }
1:3125cae: 
1:3125cae:     public synchronized void startConnectCheckTask(long connectionTimeout) {
1:3125cae:         if (connectionTimeout <= 0) {
1:3125cae:             return;
1:3125cae:         }
1:3125cae: 
1:8e183db:         LOG.trace("Starting connection check task for: {}", this);
1:3125cae: 
1:3125cae:         this.connectAttemptTimeout = connectionTimeout;
1:3125cae: 
1:3125cae:         if (connectCheckerTask == null) {
1:3125cae:             connectCheckerTask = new SchedulerTimerTask(connectChecker);
1:3125cae: 
1:3125cae:             synchronized (AbstractInactivityMonitor.class) {
1:3125cae:                 if (CHECKER_COUNTER == 0) {
1:3125cae:                     if (ASYNC_TASKS == null || ASYNC_TASKS.isShutdown()) {
1:3125cae:                         ASYNC_TASKS = createExecutor();
1:3125cae:                     }
1:3125cae:                     if (READ_CHECK_TIMER == null) {
1:3125cae:                         READ_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor ReadCheckTimer", true);
1:3125cae:                     }
1:3125cae:                 }
1:3125cae:                 CHECKER_COUNTER++;
1:3125cae:                 READ_CHECK_TIMER.schedule(connectCheckerTask, connectionTimeout);
1:3125cae:             }
1:3125cae:         }
1:3125cae:     }
1:3125cae: 
1:3125cae:     public synchronized void stopConnectCheckTask() {
1:3125cae:         if (connectCheckerTask != null) {
1:8e183db:             LOG.trace("Stopping connection check task for: {}", this);
1:3125cae:             connectCheckerTask.cancel();
1:3125cae:             connectCheckerTask = null;
1:3125cae: 
1:3125cae:             synchronized (AbstractInactivityMonitor.class) {
1:3125cae:                 READ_CHECK_TIMER.purge();
1:3125cae:                 CHECKER_COUNTER--;
1:3125cae:             }
1:3125cae:         }
1:3125cae:     }
1:3125cae: 
1:0885c60:     protected synchronized void startMonitorThreads() throws IOException {
2:0885c60:         if (monitorStarted.get()) {
1:0885c60:             return;
1:3125cae:         }
1:0885c60: 
1:0885c60:         if (!configuredOk()) {
1:0885c60:             return;
1:0885c60:         }
1:0885c60: 
1:0885c60:         if (readCheckTime > 0) {
1:0885c60:             readCheckerTask = new SchedulerTimerTask(readChecker);
1:0885c60:         }
1:0885c60: 
1:0885c60:         if (writeCheckTime > 0) {
1:0885c60:             writeCheckerTask = new SchedulerTimerTask(writeChecker);
1:0885c60:         }
1:0885c60: 
1:0885c60:         if (writeCheckTime > 0 || readCheckTime > 0) {
1:0885c60:             monitorStarted.set(true);
1:80d0605:             synchronized (AbstractInactivityMonitor.class) {
1:3125cae:                 if (ASYNC_TASKS == null || ASYNC_TASKS.isShutdown()) {
1:0885c60:                     ASYNC_TASKS = createExecutor();
1:3125cae:                 }
1:3125cae:                 if (READ_CHECK_TIMER == null) {
1:80d0605:                     READ_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor ReadCheckTimer", true);
1:0885c60:                 }
1:3125cae:                 if (WRITE_CHECK_TIMER == null) {
1:80d0605:                     WRITE_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor WriteCheckTimer", true);
1:0885c60:                 }
1:3125cae: 
1:0885c60:                 CHECKER_COUNTER++;
1:0885c60:                 if (readCheckTime > 0) {
1:0885c60:                     READ_CHECK_TIMER.schedule(readCheckerTask, initialDelayTime, readCheckTime);
1:0885c60:                 }
1:0885c60:                 if (writeCheckTime > 0) {
1:0885c60:                     WRITE_CHECK_TIMER.schedule(writeCheckerTask, initialDelayTime, writeCheckTime);
1:0885c60:                 }
1:0885c60:             }
1:0885c60:         }
1:0885c60:     }
1:0885c60: 
1:0885c60:     protected synchronized void stopMonitorThreads() {
1:3125cae:         stopConnectCheckTask();
1:0885c60:         if (monitorStarted.compareAndSet(true, false)) {
1:0885c60:             if (readCheckerTask != null) {
1:0885c60:                 readCheckerTask.cancel();
1:0885c60:             }
1:0885c60:             if (writeCheckerTask != null) {
1:0885c60:                 writeCheckerTask.cancel();
1:0885c60:             }
1:3125cae: 
1:32e009d:             synchronized (AbstractInactivityMonitor.class) {
1:0885c60:                 WRITE_CHECK_TIMER.purge();
1:0885c60:                 READ_CHECK_TIMER.purge();
1:0885c60:                 CHECKER_COUNTER--;
1:80d0605:                 if (CHECKER_COUNTER == 0) {
1:32e009d:                     WRITE_CHECK_TIMER.cancel();
1:32e009d:                     READ_CHECK_TIMER.cancel();
1:0885c60:                     WRITE_CHECK_TIMER = null;
1:0885c60:                     READ_CHECK_TIMER = null;
1:d1f42bd:                     try {
1:d1f42bd:                         ThreadPoolUtils.shutdownGraceful(ASYNC_TASKS, TimeUnit.SECONDS.toMillis(10));
1:d1f42bd:                     } finally {
1:d1f42bd:                         ASYNC_TASKS = null;
1:d1f42bd:                     }
1:0885c60:                 }
1:0885c60:             }
1:0885c60:         }
1:0885c60:     }
1:0885c60: 
1:80d0605:     private final ThreadFactory factory = new ThreadFactory() {
1:80d0605:         @Override
1:0885c60:         public Thread newThread(Runnable runnable) {
1:c659506:             Thread thread = new Thread(runnable, "ActiveMQ InactivityMonitor Worker");
1:0885c60:             thread.setDaemon(true);
1:0885c60:             return thread;
1:0885c60:         }
1:0885c60:     };
1:0885c60: 
1:0885c60:     private ThreadPoolExecutor createExecutor() {
1:ce5d2a9:         ThreadPoolExecutor exec = new ThreadPoolExecutor(0, Integer.MAX_VALUE, getDefaultKeepAliveTime(), TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), factory);
1:0885c60:         exec.allowCoreThreadTimeOut(true);
1:0885c60:         return exec;
1:0885c60:     }
1:ce5d2a9: 
1:ce5d2a9:     private static int getDefaultKeepAliveTime() {
1:ce5d2a9:         return Integer.getInteger("org.apache.activemq.transport.AbstractInactivityMonitor.keepAliveTime", 30);
1:ce5d2a9:     }
1:0885c60: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:d1f42bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
1:                     try {
1:                         ThreadPoolUtils.shutdownGraceful(ASYNC_TASKS, TimeUnit.SECONDS.toMillis(10));
1:                     } finally {
1:                         ASYNC_TASKS = null;
1:                     }
commit:8e183db
/////////////////////////////////////////////////////////////////////////
1:         LOG.trace("Starting connection check task for: {}", this);
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("Stopping connection check task for: {}", this);
commit:3125cae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final long DEFAULT_CHECK_TIME_MILLS = 30000;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private SchedulerTimerTask connectCheckerTask;
1:     private long connectAttemptTimeout = DEFAULT_CHECK_TIME_MILLS;
/////////////////////////////////////////////////////////////////////////
1:     private final Runnable connectChecker = new Runnable() {
1: 
1:         private final long startTime = System.currentTimeMillis();
1: 
1:         @Override
1:         public void run() {
1:             long now = System.currentTimeMillis();
1: 
1:             if ((now - startTime) >= connectAttemptTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {
1:                 LOG.debug("No connection attempt made in time for {}! Throwing InactivityIOException.", AbstractInactivityMonitor.this.toString());
1:                 try {
1:                     ASYNC_TASKS.execute(new Runnable() {
1:                         @Override
1:                         public void run() {
1:                             onException(new InactivityIOException(
0:                                 "Channel was inactive for too (>" + (connectAttemptTimeout) + ") long: " + next.getRemoteAddress()));
1:                         }
1:                     });
1:                 } catch (RejectedExecutionException ex) {
1:                     if (!ASYNC_TASKS.isShutdown()) {
1:                         LOG.error("Async connection timeout task was rejected from the executor: ", ex);
1:                         throw ex;
1:                     }
1:                 }
1:             }
1:         }
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (!commandSent.get() && useKeepAlive && monitorStarted.get() && !ASYNC_TASKS.isShutdown()) {
/////////////////////////////////////////////////////////////////////////
1:                 if (!ASYNC_TASKS.isShutdown()) {
/////////////////////////////////////////////////////////////////////////
1:         if (!commandReceived.get() && monitorStarted.get() && !ASYNC_TASKS.isShutdown()) {
/////////////////////////////////////////////////////////////////////////
1:                 if (!ASYNC_TASKS.isShutdown()) {
/////////////////////////////////////////////////////////////////////////
1:         sendLock.readLock().lock();
1:             sendLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1:     public long getConnectAttemptTimeout() {
1:         return connectAttemptTimeout;
1:     }
1: 
1:     public void setConnectAttemptTimeout(long connectionTimeout) {
1:         this.connectAttemptTimeout = connectionTimeout;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     abstract protected boolean configuredOk() throws IOException;
1: 
1:     public synchronized void startConnectCheckTask() {
1:         startConnectCheckTask(getConnectAttemptTimeout());
1:     }
1: 
1:     public synchronized void startConnectCheckTask(long connectionTimeout) {
1:         if (connectionTimeout <= 0) {
1:             return;
1:         }
1: 
0:         LOG.info("Starting connection check task for: {}", this);
1: 
1:         this.connectAttemptTimeout = connectionTimeout;
1: 
1:         if (connectCheckerTask == null) {
1:             connectCheckerTask = new SchedulerTimerTask(connectChecker);
1: 
1:             synchronized (AbstractInactivityMonitor.class) {
1:                 if (CHECKER_COUNTER == 0) {
1:                     if (ASYNC_TASKS == null || ASYNC_TASKS.isShutdown()) {
1:                         ASYNC_TASKS = createExecutor();
1:                     }
1:                     if (READ_CHECK_TIMER == null) {
1:                         READ_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor ReadCheckTimer", true);
1:                     }
1:                 }
1:                 CHECKER_COUNTER++;
1:                 READ_CHECK_TIMER.schedule(connectCheckerTask, connectionTimeout);
1:             }
1:         }
1:     }
1: 
1:     public synchronized void stopConnectCheckTask() {
1:         if (connectCheckerTask != null) {
0:             LOG.info("Stopping connection check task for: {}", this);
1:             connectCheckerTask.cancel();
1:             connectCheckerTask = null;
1: 
1:             synchronized (AbstractInactivityMonitor.class) {
1:                 READ_CHECK_TIMER.purge();
1:                 CHECKER_COUNTER--;
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 if (ASYNC_TASKS == null || ASYNC_TASKS.isShutdown()) {
1:                 }
1:                 if (READ_CHECK_TIMER == null) {
1:                 }
1:                 if (WRITE_CHECK_TIMER == null) {
1: 
/////////////////////////////////////////////////////////////////////////
1:         stopConnectCheckTask();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:c7d33ad
/////////////////////////////////////////////////////////////////////////
1:             if (lastRunTime != 0) {
1:                 LOG.debug("{}ms elapsed since last read check.", elapsed);
/////////////////////////////////////////////////////////////////////////
1:             // read check.
1:             if (!allowReadCheck(elapsed)) {
1:                 LOG.debug("Aborting read check...Not enough time elapsed since last read check.");
/////////////////////////////////////////////////////////////////////////
1:             if (lastRunTime != 0) {
1:                 LOG.debug("{}: {}ms elapsed since last write check.", this, (now - lastRunTime));
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("Send in progress. Skipping write check.");
1:             LOG.trace("{} no message sent since last write check, sending a KeepAliveInfo", this);
1:                         LOG.debug("Running {}", this);
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("{} message sent since last write check, resetting flag.", this);
/////////////////////////////////////////////////////////////////////////
1:             LOG.trace("A receive is in progress, skipping read check.");
1:             LOG.debug("No message received since last read check for {}. Throwing InactivityIOException.", this);
1:                         LOG.debug("Running {}", this);
commit:ce5d2a9
/////////////////////////////////////////////////////////////////////////
1:         ThreadPoolExecutor exec = new ThreadPoolExecutor(0, Integer.MAX_VALUE, getDefaultKeepAliveTime(), TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), factory);
1: 
1:     private static int getDefaultKeepAliveTime() {
1:         return Integer.getInteger("org.apache.activemq.transport.AbstractInactivityMonitor.keepAliveTime", 30);
1:     }
author:gtully
-------------------------------------------------------------------------------
commit:e5a94bf
/////////////////////////////////////////////////////////////////////////
1:                                 "Channel was inactive (no connection attempt made) for too (>" + (connectAttemptTimeout) + ") long: " + next.getRemoteAddress()));
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:80d0605
/////////////////////////////////////////////////////////////////////////
1: 
1:         @Override
1:             long elapsed = (now - lastRunTime);
0:             if (lastRunTime != 0 && LOG.isDebugEnabled()) {
0:                 LOG.debug("" + elapsed + " ms elapsed since last read check.");
1:             // If less than 90% of the read check Time elapsed then abort this
0:             // readcheck.
0:             if (!allowReadCheck(elapsed)) { // FUNKY qdox bug does not allow me
0:                                             // to inline this expression.
/////////////////////////////////////////////////////////////////////////
1:         @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         if (!commandSent.get() && useKeepAlive && monitorStarted.get() && !ASYNC_TASKS.isTerminating() && !ASYNC_TASKS.isTerminated()) {
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                                 // If we can't get the lock it means another
1:                                 // write beat us into the
/////////////////////////////////////////////////////////////////////////
1:                                 if (sendLock.writeLock().isHeldByCurrentThread()) {
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:         if (inReceive.get() || currentCounter != previousCounter) {
0:         if (!commandReceived.get() && monitorStarted.get() && !ASYNC_TASKS.isTerminating() && !ASYNC_TASKS.isTerminated()) {
/////////////////////////////////////////////////////////////////////////
1:                     @Override
1:                         onException(new InactivityIOException("Channel was inactive for too (>" + readCheckTime + ") long: " + next.getRemoteAddress()));
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         // are performing a send we take a read lock. The inactivity monitor
1:         // sends its Heart-beat commands under a write lock. This means that
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             if (sendLock.writeLock().isHeldByCurrentThread()) {
1:                 sendLock.writeLock().unlock();
1:             }
/////////////////////////////////////////////////////////////////////////
1:             synchronized (AbstractInactivityMonitor.class) {
1:                 if (CHECKER_COUNTER == 0) {
1:                     READ_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor ReadCheckTimer", true);
1:                     WRITE_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor WriteCheckTimer", true);
/////////////////////////////////////////////////////////////////////////
1:     private final ThreadFactory factory = new ThreadFactory() {
1:         @Override
commit:32e009d
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.RejectedExecutionException;
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (lastRunTime != 0 && LOG.isDebugEnabled()) {
0:                 LOG.debug(this + " " + (now - lastRunTime) + " ms elapsed since last write check.");
/////////////////////////////////////////////////////////////////////////
0:         if (!commandSent.get() && useKeepAlive && monitorStarted.get() &&
0:             !ASYNC_TASKS.isTerminating() && !ASYNC_TASKS.isTerminated()) {
1: 
1: 
1:             try {
1:                 ASYNC_TASKS.execute(new Runnable() {
1:                     public void run() {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Running {}", this);
1:                         }
1:                         if (monitorStarted.get()) {
1:                             try {
0:                                 // If we can't get the lock it means another write beat us into the
1:                                 // send and we don't need to heart beat now.
1:                                 if (sendLock.writeLock().tryLock()) {
1:                                     KeepAliveInfo info = new KeepAliveInfo();
1:                                     info.setResponseRequired(keepAliveResponseRequired);
1:                                     doOnewaySend(info);
1:                                 }
1:                             } catch (IOException e) {
1:                                 onException(e);
1:                             } finally {
0:                                  if (sendLock.writeLock().isHeldByCurrentThread()) {
1:                                     sendLock.writeLock().unlock();
1:                                  }
1:                     @Override
1:                     public String toString() {
1:                         return "WriteCheck[" + getRemoteAddress() + "]";
1:                     };
1:                 });
1:             } catch (RejectedExecutionException ex) {
0:                 if (!ASYNC_TASKS.isTerminating() && !ASYNC_TASKS.isTerminated()) {
1:                     LOG.error("Async write check was rejected from the executor: ", ex);
1:                     throw ex;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if (!commandReceived.get() && monitorStarted.get() &&
0:             !ASYNC_TASKS.isTerminating() && !ASYNC_TASKS.isTerminated()) {
1: 
1:             try {
1:                 ASYNC_TASKS.execute(new Runnable() {
1:                     public void run() {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Running {}", this);
1:                         }
0:                         onException(new InactivityIOException("Channel was inactive for too (>" + readCheckTime + ") long: "+next.getRemoteAddress()));
1:                     }
1: 
1:                     @Override
1:                     public String toString() {
1:                         return "ReadCheck[" + getRemoteAddress() + "]";
1:                     };
1:                 });
1:             } catch (RejectedExecutionException ex) {
0:                 if (!ASYNC_TASKS.isTerminating() && !ASYNC_TASKS.isTerminated()) {
1:                     LOG.error("Async read check was rejected from the executor: ", ex);
1:                     throw ex;
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (failed.get()) {
1:             throw new InactivityIOException("Cannot send, channel has already failed: " + next.getRemoteAddress());
/////////////////////////////////////////////////////////////////////////
1:             synchronized (AbstractInactivityMonitor.class) {
0:                 if (CHECKER_COUNTER == 0) {
1:                     WRITE_CHECK_TIMER.cancel();
1:                     READ_CHECK_TIMER.cancel();
commit:c4c9cf2
/////////////////////////////////////////////////////////////////////////
0:         if (!commandSent.get() && useKeepAlive && monitorStarted.get() && !ASYNC_TASKS.isTerminating()) {
/////////////////////////////////////////////////////////////////////////
0:         if (!commandReceived.get() && monitorStarted.get() && !ASYNC_TASKS.isTerminating()) {
commit:e6909d8
/////////////////////////////////////////////////////////////////////////
0:                     ASYNC_TASKS.shutdown();
commit:f33f32e
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.locks.ReentrantReadWriteLock;
/////////////////////////////////////////////////////////////////////////
1:     private final ReentrantReadWriteLock sendLock = new ReentrantReadWriteLock();
1: 
/////////////////////////////////////////////////////////////////////////
0:                             // If we can't get the lock it means another write beat us into the
0:                             // send and we don't need to heart beat now.
0:                             if (sendLock.writeLock().tryLock()) {
0:                                 KeepAliveInfo info = new KeepAliveInfo();
0:                                 info.setResponseRequired(keepAliveResponseRequired);
0:                                 doOnewaySend(info);
1:                             }
1:                         } finally {
0:                             sendLock.writeLock().unlock();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     sendLock.readLock().lock();
1:                     } finally {
1:                         sendLock.readLock().unlock();
/////////////////////////////////////////////////////////////////////////
1: 
1:                 transportListener.onCommand(command);
1:         // To prevent the inactivity monitor from sending a message while we
0:         // are performing a send we take a read lock.  The inactivity monitor
0:         // sends its Heart-beat commands under a write lock.  This means that
1:         // the MutexTransport is still responsible for synchronizing sends
0:         this.sendLock.readLock().lock();
1:         inSend.set(true);
1:         try {
1:             doOnewaySend(o);
1:         } finally {
1:             commandSent.set(true);
1:             inSend.set(false);
0:             this.sendLock.readLock().unlock();
1:         }
1:     }
1:     // Must be called under lock, either read or write on sendLock.
1:     private void doOnewaySend(Object command) throws IOException {
0:         if( failed.get() ) {
0:             throw new InactivityIOException("Cannot send, channel has already failed: "+next.getRemoteAddress());
1:         }
1:         if (command.getClass() == WireFormatInfo.class) {
1:             synchronized (this) {
1:                 processOutboundWireFormatInfo((WireFormatInfo) command);
1:         next.oneway(command);
commit:0885c60
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.transport;
1: 
1: import java.io.IOException;
1: import java.util.Timer;
1: import java.util.concurrent.SynchronousQueue;
1: import java.util.concurrent.ThreadFactory;
1: import java.util.concurrent.ThreadPoolExecutor;
1: import java.util.concurrent.TimeUnit;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import java.util.concurrent.atomic.AtomicInteger;
1: 
1: import org.apache.activemq.command.KeepAliveInfo;
1: import org.apache.activemq.command.WireFormatInfo;
1: import org.apache.activemq.thread.SchedulerTimerTask;
1: import org.apache.activemq.wireformat.WireFormat;
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
1: 
1: /**
1:  * Used to make sure that commands are arriving periodically from the peer of
1:  * the transport.
1:  */
1: public abstract class AbstractInactivityMonitor extends TransportFilter {
1: 
1:     private static final Logger LOG = LoggerFactory.getLogger(AbstractInactivityMonitor.class);
1: 
1:     private static ThreadPoolExecutor ASYNC_TASKS;
1:     private static int CHECKER_COUNTER;
0:     private static long DEFAULT_CHECK_TIME_MILLS = 30000;
1:     private static Timer READ_CHECK_TIMER;
1:     private static Timer WRITE_CHECK_TIMER;
1: 
1:     private final AtomicBoolean monitorStarted = new AtomicBoolean(false);
1: 
1:     private final AtomicBoolean commandSent = new AtomicBoolean(false);
1:     private final AtomicBoolean inSend = new AtomicBoolean(false);
1:     private final AtomicBoolean failed = new AtomicBoolean(false);
1: 
1:     private final AtomicBoolean commandReceived = new AtomicBoolean(true);
1:     private final AtomicBoolean inReceive = new AtomicBoolean(false);
1:     private final AtomicInteger lastReceiveCounter = new AtomicInteger(0);
1: 
1:     private SchedulerTimerTask writeCheckerTask;
1:     private SchedulerTimerTask readCheckerTask;
1: 
1:     private long readCheckTime = DEFAULT_CHECK_TIME_MILLS;
1:     private long writeCheckTime = DEFAULT_CHECK_TIME_MILLS;
1:     private long initialDelayTime = DEFAULT_CHECK_TIME_MILLS;
1:     private boolean useKeepAlive = true;
1:     private boolean keepAliveResponseRequired;
1: 
1:     protected WireFormat wireFormat;
1: 
1:     private final Runnable readChecker = new Runnable() {
1:         long lastRunTime;
1:         public void run() {
1:             long now = System.currentTimeMillis();
0:             long elapsed = (now-lastRunTime);
1: 
0:             if( lastRunTime != 0 && LOG.isDebugEnabled() ) {
0:                 LOG.debug(""+elapsed+" ms elapsed since last read check.");
1:             }
1: 
1:             // Perhaps the timer executed a read check late.. and then executes
1:             // the next read check on time which causes the time elapsed between
1:             // read checks to be small..
1: 
0:             // If less than 90% of the read check Time elapsed then abort this readcheck.
0:             if( !allowReadCheck(elapsed) ) { // FUNKY qdox bug does not allow me to inline this expression.
0:                 LOG.debug("Aborting read check.. Not enough time elapsed since last read check.");
1:                 return;
1:             }
1: 
1:             lastRunTime = now;
1:             readCheck();
1:         }
1:     };
1: 
1:     private boolean allowReadCheck(long elapsed) {
1:         return elapsed > (readCheckTime * 9 / 10);
1:     }
1: 
1:     private final Runnable writeChecker = new Runnable() {
1:         long lastRunTime;
1:         public void run() {
1:             long now = System.currentTimeMillis();
0:             if( lastRunTime != 0 && LOG.isDebugEnabled() ) {
0:                 LOG.debug(this + " "+(now-lastRunTime)+" ms elapsed since last write check.");
1: 
1:             }
1:             lastRunTime = now;
1:             writeCheck();
1:         }
1:     };
1: 
1:     public AbstractInactivityMonitor(Transport next, WireFormat wireFormat) {
1:         super(next);
1:         this.wireFormat = wireFormat;
1:     }
1: 
1:     public void start() throws Exception {
1:         next.start();
1:         startMonitorThreads();
1:     }
1: 
1:     public void stop() throws Exception {
1:         stopMonitorThreads();
1:         next.stop();
1:     }
1: 
1:     final void writeCheck() {
1:         if (inSend.get()) {
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("A send is in progress");
1:             }
1:             return;
1:         }
1: 
0:         if (!commandSent.get() && useKeepAlive) {
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(this + " no message sent since last write check, sending a KeepAliveInfo");
1:             }
0:             ASYNC_TASKS.execute(new Runnable() {
1:                 public void run() {
1:                     if (monitorStarted.get()) {
1:                         try {
0:                             KeepAliveInfo info = new KeepAliveInfo();
0:                             info.setResponseRequired(keepAliveResponseRequired);
1:                             oneway(info);
1:                         } catch (IOException e) {
1:                             onException(e);
1:                         }
1:                     }
1:                 };
0:             });
1:         } else {
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace(this + " message sent since last write check, resetting flag");
1:             }
1:         }
1: 
1:         commandSent.set(false);
1:     }
1: 
1:     final void readCheck() {
1:         int currentCounter = next.getReceiveCounter();
1:         int previousCounter = lastReceiveCounter.getAndSet(currentCounter);
0:         if (inReceive.get() || currentCounter!=previousCounter ) {
1:             if (LOG.isTraceEnabled()) {
0:                 LOG.trace("A receive is in progress");
1:             }
1:             return;
1:         }
0:         if (!commandReceived.get()) {
0:             if (LOG.isDebugEnabled()) {
0:                 LOG.debug("No message received since last read check for " + toString() + "! Throwing InactivityIOException.");
1:             }
0:             ASYNC_TASKS.execute(new Runnable() {
1:                 public void run() {
0:                     onException(new InactivityIOException("Channel was inactive for too (>" + readCheckTime + ") long: "+next.getRemoteAddress()));
1:                 };
1: 
0:             });
1:         } else {
1:             if (LOG.isTraceEnabled()) {
1:                 LOG.trace("Message received since last read check, resetting flag: ");
1:             }
1:         }
1:         commandReceived.set(false);
1:     }
1: 
1:     protected abstract void processInboundWireFormatInfo(WireFormatInfo info) throws IOException;
1:     protected abstract void processOutboundWireFormatInfo(WireFormatInfo info) throws IOException;
1: 
1:     public void onCommand(Object command) {
1:         commandReceived.set(true);
1:         inReceive.set(true);
1:         try {
1:             if (command.getClass() == KeepAliveInfo.class) {
1:                 KeepAliveInfo info = (KeepAliveInfo) command;
1:                 if (info.isResponseRequired()) {
1:                     try {
1:                         info.setResponseRequired(false);
1:                         oneway(info);
1:                     } catch (IOException e) {
1:                         onException(e);
1:                     }
1:                 }
1:             } else {
1:                 if (command.getClass() == WireFormatInfo.class) {
1:                     synchronized (this) {
1:                         try {
1:                             processInboundWireFormatInfo((WireFormatInfo) command);
1:                         } catch (IOException e) {
1:                             onException(e);
1:                         }
1:                     }
1:                 }
0:                 synchronized (readChecker) {
0:                     transportListener.onCommand(command);
1:                 }
1:             }
0:         } finally {
1: 
1:             inReceive.set(false);
1:         }
1:     }
1: 
1:     public void oneway(Object o) throws IOException {
0:         // Disable inactivity monitoring while processing a command.
0:         // synchronize this method - its not synchronized
0:         // further down the transport stack and gets called by more
0:         // than one thread  by this class
0:         synchronized(inSend) {
0:             inSend.set(true);
1:             try {
1: 
0:                 if( failed.get() ) {
0:                     throw new InactivityIOException("Cannot send, channel has already failed: "+next.getRemoteAddress());
1:                 }
0:                 if (o.getClass() == WireFormatInfo.class) {
1:                     synchronized (this) {
0:                         processOutboundWireFormatInfo((WireFormatInfo) o);
1:                     }
1:                 }
0:                 next.oneway(o);
0:             } finally {
0:                 commandSent.set(true);
0:                 inSend.set(false);
1:             }
1:         }
1:     }
1: 
1:     public void onException(IOException error) {
1:         if (failed.compareAndSet(false, true)) {
1:             stopMonitorThreads();
1:             transportListener.onException(error);
1:         }
1:     }
1: 
1:     public void setUseKeepAlive(boolean val) {
1:         useKeepAlive = val;
1:     }
1: 
1:     public long getReadCheckTime() {
1:         return readCheckTime;
1:     }
1: 
1:     public void setReadCheckTime(long readCheckTime) {
1:         this.readCheckTime = readCheckTime;
1:     }
1: 
1:     public long getWriteCheckTime() {
1:         return writeCheckTime;
1:     }
1: 
1:     public void setWriteCheckTime(long writeCheckTime) {
1:         this.writeCheckTime = writeCheckTime;
1:     }
1: 
1:     public long getInitialDelayTime() {
1:         return initialDelayTime;
1:     }
1: 
1:     public void setInitialDelayTime(long initialDelayTime) {
1:         this.initialDelayTime = initialDelayTime;
1:     }
1: 
1:     public boolean isKeepAliveResponseRequired() {
1:         return this.keepAliveResponseRequired;
1:     }
1: 
1:     public void setKeepAliveResponseRequired(boolean value) {
1:         this.keepAliveResponseRequired = value;
1:     }
1: 
1:     public boolean isMonitorStarted() {
1:         return this.monitorStarted.get();
1:     }
1: 
1:     protected synchronized void startMonitorThreads() throws IOException {
1:         if (monitorStarted.get()) {
1:             return;
1:         }
1: 
1:         if (!configuredOk()) {
1:             return;
1:         }
1: 
1:         if (readCheckTime > 0) {
1:             readCheckerTask = new SchedulerTimerTask(readChecker);
1:         }
1: 
1:         if (writeCheckTime > 0) {
1:             writeCheckerTask = new SchedulerTimerTask(writeChecker);
1:         }
1: 
1:         if (writeCheckTime > 0 || readCheckTime > 0) {
1:             monitorStarted.set(true);
0:             synchronized(AbstractInactivityMonitor.class) {
0:                 if( CHECKER_COUNTER == 0 ) {
1:                     ASYNC_TASKS = createExecutor();
0:                     READ_CHECK_TIMER = new Timer("InactivityMonitor ReadCheck",true);
0:                     WRITE_CHECK_TIMER = new Timer("InactivityMonitor WriteCheck",true);
1:                 }
1:                 CHECKER_COUNTER++;
1:                 if (readCheckTime > 0) {
1:                     READ_CHECK_TIMER.schedule(readCheckerTask, initialDelayTime, readCheckTime);
1:                 }
1:                 if (writeCheckTime > 0) {
1:                     WRITE_CHECK_TIMER.schedule(writeCheckerTask, initialDelayTime, writeCheckTime);
1:                 }
1:             }
1:         }
1:     }
1: 
0:     abstract protected boolean configuredOk() throws IOException;
1: 
1:     protected synchronized void stopMonitorThreads() {
1:         if (monitorStarted.compareAndSet(true, false)) {
1:             if (readCheckerTask != null) {
1:                 readCheckerTask.cancel();
1:             }
1:             if (writeCheckerTask != null) {
1:                 writeCheckerTask.cancel();
1:             }
0:             synchronized( AbstractInactivityMonitor.class ) {
1:                 WRITE_CHECK_TIMER.purge();
1:                 READ_CHECK_TIMER.purge();
1:                 CHECKER_COUNTER--;
0:                 if(CHECKER_COUNTER==0) {
0:                   WRITE_CHECK_TIMER.cancel();
0:                   READ_CHECK_TIMER.cancel();
1:                     WRITE_CHECK_TIMER = null;
1:                     READ_CHECK_TIMER = null;
0:                     ASYNC_TASKS.shutdownNow();
0:                     ASYNC_TASKS = null;
1:                 }
1:             }
1:         }
1:     }
1: 
0:     private ThreadFactory factory = new ThreadFactory() {
1:         public Thread newThread(Runnable runnable) {
0:             Thread thread = new Thread(runnable, "InactivityMonitor Async Task: "+runnable);
1:             thread.setDaemon(true);
1:             return thread;
1:         }
1:     };
1: 
1:     private ThreadPoolExecutor createExecutor() {
0:         ThreadPoolExecutor exec = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 10, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), factory);
1:         exec.allowCoreThreadTimeOut(true);
1:         return exec;
1:     }
1: }
author:Gary Tully
-------------------------------------------------------------------------------
commit:e3626e1
/////////////////////////////////////////////////////////////////////////
commit:c9b49d8
/////////////////////////////////////////////////////////////////////////
0:                 LOG.debug("No message received since last read check for " + toString() + ". Throwing InactivityIOException.");
commit:1250163
/////////////////////////////////////////////////////////////////////////
0:                              if (sendLock.writeLock().isHeldByCurrentThread()) {
0:                                 sendLock.writeLock().unlock();
0:                              }
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:9a8f6e4
author:Claus Ibsen
-------------------------------------------------------------------------------
commit:c659506
/////////////////////////////////////////////////////////////////////////
0: 
1:         @Override
1:         public String toString() {
1:             return "ReadChecker";
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
1:         @Override
1:         public String toString() {
1:             return "WriteChecker";
0:         }
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Running {}", this);
0:                     }
/////////////////////////////////////////////////////////////////////////
0:                 }
0: 
0:                 @Override
0:                 public String toString() {
0:                     return "WriteCheck[" + getRemoteAddress() + "]";
/////////////////////////////////////////////////////////////////////////
0:                     if (LOG.isDebugEnabled()) {
0:                         LOG.debug("Running {}", this);
0:                     }
0:                 }
0: 
0:                 @Override
0:                 public String toString() {
0:                     return "ReadCheck[" + getRemoteAddress() + "]";
/////////////////////////////////////////////////////////////////////////
0:                     READ_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor ReadCheckTimer",true);
0:                     WRITE_CHECK_TIMER = new Timer("ActiveMQ InactivityMonitor WriteCheckTimer",true);
/////////////////////////////////////////////////////////////////////////
1:             Thread thread = new Thread(runnable, "ActiveMQ InactivityMonitor Worker");
0:         // TODO: This value of 10 seconds seems to low, see discussion at
0:         // http://activemq.2283324.n4.nabble.com/InactivityMonitor-Creating-too-frequent-threads-tp4656752.html;cid=1348142445209-351
commit:6c1676b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.util.ThreadPoolUtils;
/////////////////////////////////////////////////////////////////////////
0:                     ThreadPoolUtils.shutdown(ASYNC_TASKS);
============================================================================