1:7ae2055: /**
1:7ae2055:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7ae2055:  * contributor license agreements.  See the NOTICE file distributed with
1:7ae2055:  * this work for additional information regarding copyright ownership.
1:7ae2055:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7ae2055:  * (the "License"); you may not use this file except in compliance with
1:7ae2055:  * the License.  You may obtain a copy of the License at
3:85bb229:  *
1:7ae2055:  *      http://www.apache.org/licenses/LICENSE-2.0
1:85bb229:  *
1:7ae2055:  * Unless required by applicable law or agreed to in writing, software
1:7ae2055:  * distributed under the License is distributed on an "AS IS" BASIS,
1:7ae2055:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ae2055:  * See the License for the specific language governing permissions and
1:7ae2055:  * limitations under the License.
8:7ae2055:  */
1:0484af1: package org.apache.activemq.store.kahadb.scheduler;
1:8280417: 
1:7ae2055: import java.io.DataInput;
1:7ae2055: import java.io.DataOutput;
1:7ae2055: import java.io.IOException;
1:7ae2055: import java.util.ArrayList;
1:7ae2055: import java.util.Iterator;
1:7ae2055: import java.util.List;
1:7ae2055: import java.util.Map;
1:7ae2055: import java.util.concurrent.CopyOnWriteArrayList;
1:7ae2055: import java.util.concurrent.atomic.AtomicBoolean;
1:85bb229: 
1:e3154c3: import javax.jms.MessageFormatException;
1:fab6ba1: 
1:0484af1: import org.apache.activemq.broker.scheduler.CronParser;
1:0484af1: import org.apache.activemq.broker.scheduler.Job;
1:0484af1: import org.apache.activemq.broker.scheduler.JobListener;
1:0484af1: import org.apache.activemq.broker.scheduler.JobScheduler;
1:74846bb: import org.apache.activemq.protobuf.Buffer;
1:74846bb: import org.apache.activemq.store.kahadb.data.KahaAddScheduledJobCommand;
1:74846bb: import org.apache.activemq.store.kahadb.data.KahaRemoveScheduledJobCommand;
1:74846bb: import org.apache.activemq.store.kahadb.data.KahaRemoveScheduledJobsCommand;
1:74846bb: import org.apache.activemq.store.kahadb.data.KahaRescheduleJobCommand;
1:85bb229: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;
1:85bb229: import org.apache.activemq.store.kahadb.disk.journal.Location;
1:85bb229: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1:85bb229: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
1:85bb229: import org.apache.activemq.util.ByteSequence;
1:e3154c3: import org.apache.activemq.util.IdGenerator;
1:7ae2055: import org.apache.activemq.util.ServiceStopper;
1:7ae2055: import org.apache.activemq.util.ServiceSupport;
1:8bf987b: import org.slf4j.Logger;
1:8bf987b: import org.slf4j.LoggerFactory;
1:fab6ba1: 
1:74846bb: public class JobSchedulerImpl extends ServiceSupport implements Runnable, JobScheduler {
1:74846bb: 
1:8bf987b:     private static final Logger LOG = LoggerFactory.getLogger(JobSchedulerImpl.class);
1:74846bb:     private final JobSchedulerStoreImpl store;
1:7ae2055:     private final AtomicBoolean running = new AtomicBoolean();
1:7ae2055:     private String name;
1:74846bb:     private BTreeIndex<Long, List<JobLocation>> index;
1:7ae2055:     private Thread thread;
1:2d861da:     private final AtomicBoolean started = new AtomicBoolean(false);
1:9801622:     private final List<JobListener> jobListeners = new CopyOnWriteArrayList<>();
1:e3154c3:     private static final IdGenerator ID_GENERATOR = new IdGenerator();
1:e3154c3:     private final ScheduleTime scheduleTime = new ScheduleTime();
40:7ae2055: 
1:0484af1:     JobSchedulerImpl(JobSchedulerStoreImpl store) {
1:7ae2055:         this.store = store;
1:fab6ba1:     }
1:85bb229: 
1:7ae2055:     public void setName(String name) {
1:7ae2055:         this.name = name;
1:fab6ba1:     }
1:e3154c3: 
1:85bb229:     @Override
1:7ae2055:     public String getName() {
1:7ae2055:         return this.name;
1:85bb229:     }
1:e3154c3: 
1:85bb229:     @Override
1:7ae2055:     public void addListener(JobListener l) {
1:7ae2055:         this.jobListeners.add(l);
1:85bb229:     }
1:c7c8e53: 
1:85bb229:     @Override
1:7ae2055:     public void removeListener(JobListener l) {
1:7ae2055:         this.jobListeners.remove(l);
1:c7c8e53:     }
1:c7c8e53: 
1:85bb229:     @Override
1:74846bb:     public void schedule(final String jobId, final ByteSequence payload, final long delay) throws IOException {
1:74846bb:         doSchedule(jobId, payload, "", 0, delay, 0);
1:c7c8e53:     }
1:7ae2055: 
1:85bb229:     @Override
1:74846bb:     public void schedule(final String jobId, final ByteSequence payload, final String cronEntry) throws Exception {
1:74846bb:         doSchedule(jobId, payload, cronEntry, 0, 0, 0);
1:c7c8e53:     }
1:7ae2055: 
1:85bb229:     @Override
1:74846bb:     public void schedule(final String jobId, final ByteSequence payload, final String cronEntry, final long delay, final long period, final int repeat) throws IOException {
1:74846bb:         doSchedule(jobId, payload, cronEntry, delay, period, repeat);
1:c7c8e53:     }
1:7ae2055: 
1:85bb229:     @Override
1:74846bb:     public void remove(final long time) throws IOException {
1:74846bb:         doRemoveRange(time, time);
1:c7c8e53:     }
1:7ae2055: 
1:85bb229:     @Override
1:74846bb:     public void remove(final String jobId) throws IOException {
1:74846bb:         doRemove(-1, jobId);
1:74846bb:     }
1:74846bb: 
1:74846bb:     @Override
1:74846bb:     public void removeAllJobs() throws IOException {
1:74846bb:         doRemoveRange(0, Long.MAX_VALUE);
1:74846bb:     }
1:74846bb: 
1:74846bb:     @Override
1:74846bb:     public void removeAllJobs(final long start, final long finish) throws IOException {
1:74846bb:         doRemoveRange(start, finish);
1:74846bb:     }
1:74846bb: 
1:74846bb:     @Override
1:74846bb:     public long getNextScheduleTime() throws IOException {
1:74846bb:         this.store.readLockIndex();
1:74846bb:         try {
1:74846bb:             Map.Entry<Long, List<JobLocation>> first = this.index.getFirst(this.store.getPageFile().tx());
1:74846bb:             return first != null ? first.getKey() : -1l;
1:74846bb:         } finally {
1:74846bb:             this.store.readUnlockIndex();
1:74846bb:         }
1:74846bb:     }
1:74846bb: 
1:74846bb:     @Override
1:74846bb:     public List<Job> getNextScheduleJobs() throws IOException {
1:9801622:         final List<Job> result = new ArrayList<>();
1:74846bb:         this.store.readLockIndex();
1:74846bb:         try {
1:74846bb:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:74846bb:                 @Override
1:74846bb:                 public void execute(Transaction tx) throws IOException {
1:74846bb:                     Map.Entry<Long, List<JobLocation>> first = index.getFirst(tx);
1:74846bb:                     if (first != null) {
1:74846bb:                         for (JobLocation jl : first.getValue()) {
1:e3154c3:                             ByteSequence bs = getPayload(jl.getLocation());
1:c7c8e53:                             Job job = new JobImpl(jl, bs);
1:d1446c3:                             result.add(job);
1:3d82d74:                         }
1:e3154c3:                     }
1:e3154c3:                 }
1:74846bb:             });
1:74846bb:         } finally {
1:74846bb:             this.store.readUnlockIndex();
1:74846bb:         }
1:e3154c3:         return result;
1:d1446c3:     }
1:d1446c3: 
1:74846bb:     private Map.Entry<Long, List<JobLocation>> getNextToSchedule() throws IOException {
1:74846bb:         this.store.readLockIndex();
1:74846bb:         try {
1:74846bb:             if (!this.store.isStopped() && !this.store.isStopping()) {
1:74846bb:                 Map.Entry<Long, List<JobLocation>> first = this.index.getFirst(this.store.getPageFile().tx());
1:74846bb:                 return first;
1:74846bb:             }
1:74846bb:         } finally {
1:74846bb:             this.store.readUnlockIndex();
1:74846bb:         }
1:74846bb:         return null;
1:74846bb:     }
1:74846bb: 
1:d1446c3:     @Override
1:74846bb:     public List<Job> getAllJobs() throws IOException {
1:9801622:         final List<Job> result = new ArrayList<>();
1:74846bb:         this.store.readLockIndex();
1:74846bb:         try {
1:74846bb:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:74846bb:                 @Override
1:74846bb:                 public void execute(Transaction tx) throws IOException {
1:74846bb:                     Iterator<Map.Entry<Long, List<JobLocation>>> iter = index.iterator(store.getPageFile().tx());
1:74846bb:                     while (iter.hasNext()) {
1:74846bb:                         Map.Entry<Long, List<JobLocation>> next = iter.next();
1:74846bb:                         if (next != null) {
1:74846bb:                             for (JobLocation jl : next.getValue()) {
1:74846bb:                                 ByteSequence bs = getPayload(jl.getLocation());
1:74846bb:                                 Job job = new JobImpl(jl, bs);
1:74846bb:                                 result.add(job);
1:74846bb:                             }
1:74846bb:                         } else {
1:74846bb:                             break;
1:74846bb:                         }
1:d1446c3:                     }
1:d1446c3:                 }
1:74846bb:             });
1:74846bb:         } finally {
1:74846bb:             this.store.readUnlockIndex();
1:d1446c3:         }
1:e3154c3:         return result;
1:d1446c3:     }
1:d1446c3: 
1:85bb229:     @Override
1:74846bb:     public List<Job> getAllJobs(final long start, final long finish) throws IOException {
1:9801622:         final List<Job> result = new ArrayList<>();
1:74846bb:         this.store.readLockIndex();
1:74846bb:         try {
1:74846bb:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:74846bb:                 @Override
1:74846bb:                 public void execute(Transaction tx) throws IOException {
1:74846bb:                     Iterator<Map.Entry<Long, List<JobLocation>>> iter = index.iterator(tx, start);
1:74846bb:                     while (iter.hasNext()) {
1:74846bb:                         Map.Entry<Long, List<JobLocation>> next = iter.next();
1:74846bb:                         if (next != null && next.getKey().longValue() <= finish) {
1:74846bb:                             for (JobLocation jl : next.getValue()) {
1:74846bb:                                 ByteSequence bs = getPayload(jl.getLocation());
1:74846bb:                                 Job job = new JobImpl(jl, bs);
1:74846bb:                                 result.add(job);
1:74846bb:                             }
1:74846bb:                         } else {
1:74846bb:                             break;
1:74846bb:                         }
1:74846bb:                     }
1:74846bb:                 }
1:74846bb:             });
1:74846bb:         } finally {
1:74846bb:             this.store.readUnlockIndex();
1:74846bb:         }
1:74846bb:         return result;
1:fab6ba1:     }
1:85bb229: 
1:74846bb:     private void doSchedule(final String jobId, final ByteSequence payload, final String cronEntry, long delay, long period, int repeat) throws IOException {
1:e3154c3:         long startTime = System.currentTimeMillis();
1:2c828b2:         // round startTime - so we can schedule more jobs at the same time
1:2c828b2:         startTime = ((startTime + 500) / 500) * 500;
1:2c828b2: 
1:e3154c3:         long time = 0;
1:e3154c3:         if (cronEntry != null && cronEntry.length() > 0) {
1:e3154c3:             try {
1:e3154c3:                 time = CronParser.getNextScheduledTime(cronEntry, startTime);
1:e3154c3:             } catch (MessageFormatException e) {
1:e3154c3:                 throw new IOException(e.getMessage());
1:e3154c3:             }
1:e3154c3:         }
1:3d82d74: 
1:e3154c3:         if (time == 0) {
1:e3154c3:             // start time not set by CRON - so it it to the current time
1:e3154c3:             time = startTime;
1:e3154c3:         }
1:74846bb: 
1:e3154c3:         if (delay > 0) {
1:e3154c3:             time += delay;
1:3d82d74:         } else {
1:e3154c3:             time += period;
1:e3154c3:         }
1:e3154c3: 
1:74846bb:         KahaAddScheduledJobCommand newJob = new KahaAddScheduledJobCommand();
1:74846bb:         newJob.setScheduler(name);
1:74846bb:         newJob.setJobId(jobId);
1:74846bb:         newJob.setStartTime(startTime);
1:74846bb:         newJob.setCronEntry(cronEntry);
1:74846bb:         newJob.setDelay(delay);
1:74846bb:         newJob.setPeriod(period);
1:74846bb:         newJob.setRepeat(repeat);
1:74846bb:         newJob.setNextExecutionTime(time);
1:74846bb:         newJob.setPayload(new Buffer(payload.getData(), payload.getOffset(), payload.getLength()));
1:74846bb: 
1:74846bb:         this.store.store(newJob);
1:74846bb:     }
1:74846bb: 
1:74846bb:     private void doReschedule(final String jobId, long executionTime, long nextExecutionTime, int rescheduledCount) throws IOException {
1:74846bb:         KahaRescheduleJobCommand update = new KahaRescheduleJobCommand();
1:74846bb:         update.setScheduler(name);
1:74846bb:         update.setJobId(jobId);
1:74846bb:         update.setExecutionTime(executionTime);
1:74846bb:         update.setNextExecutionTime(nextExecutionTime);
1:74846bb:         update.setRescheduledCount(rescheduledCount);
1:74846bb:         this.store.store(update);
1:74846bb:     }
1:74846bb: 
1:74846bb:     private void doRemove(final long executionTime, final List<JobLocation> jobs) throws IOException {
1:74846bb:         for (JobLocation job : jobs) {
1:74846bb:             doRemove(executionTime, job.getJobId());
1:e3154c3:         }
1:e3154c3:     }
1:e3154c3: 
1:74846bb:     private void doRemove(long executionTime, final String jobId) throws IOException {
1:74846bb:         KahaRemoveScheduledJobCommand remove = new KahaRemoveScheduledJobCommand();
1:74846bb:         remove.setScheduler(name);
1:74846bb:         remove.setJobId(jobId);
1:74846bb:         remove.setNextExecutionTime(executionTime);
1:74846bb:         this.store.store(remove);
1:e3154c3:     }
1:e3154c3: 
1:74846bb:     private void doRemoveRange(long start, long end) throws IOException {
1:74846bb:         KahaRemoveScheduledJobsCommand destroy = new KahaRemoveScheduledJobsCommand();
1:74846bb:         destroy.setScheduler(name);
1:74846bb:         destroy.setStartTime(start);
1:74846bb:         destroy.setEndTime(end);
1:74846bb:         this.store.store(destroy);
1:74846bb:     }
1:74846bb: 
1:74846bb:     /**
1:74846bb:      * Adds a new Scheduled job to the index.  Must be called under index lock.
1:74846bb:      *
1:74846bb:      * This method must ensure that a duplicate add is not processed into the scheduler.  On index
1:74846bb:      * recover some adds may be replayed and we don't allow more than one instance of a JobId to
1:74846bb:      * exist at any given scheduled time, so filter these out to ensure idempotence.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *      Transaction in which the update is performed.
1:74846bb:      * @param command
1:74846bb:      *      The new scheduled job command to process.
1:74846bb:      * @param location
1:74846bb:      *      The location where the add command is stored in the journal.
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs updating the index.
1:74846bb:      */
1:74846bb:     protected void process(final Transaction tx, final KahaAddScheduledJobCommand command, Location location) throws IOException {
1:74846bb:         JobLocation jobLocation = new JobLocation(location);
1:74846bb:         jobLocation.setJobId(command.getJobId());
1:74846bb:         jobLocation.setStartTime(command.getStartTime());
1:74846bb:         jobLocation.setCronEntry(command.getCronEntry());
1:74846bb:         jobLocation.setDelay(command.getDelay());
1:74846bb:         jobLocation.setPeriod(command.getPeriod());
1:74846bb:         jobLocation.setRepeat(command.getRepeat());
1:74846bb: 
1:74846bb:         long nextExecutionTime = command.getNextExecutionTime();
1:74846bb: 
1:e3154c3:         List<JobLocation> values = null;
1:e3154c3:         jobLocation.setNextTime(nextExecutionTime);
1:e3154c3:         if (this.index.containsKey(tx, nextExecutionTime)) {
1:e3154c3:             values = this.index.remove(tx, nextExecutionTime);
1:e3154c3:         }
1:e3154c3:         if (values == null) {
1:9801622:             values = new ArrayList<>();
1:e3154c3:         }
1:e3154c3: 
1:74846bb:         // There can never be more than one instance of the same JobId scheduled at any
1:74846bb:         // given time, when it happens its probably the result of index recovery and this
1:74846bb:         // method must be idempotent so check for it first.
1:74846bb:         if (!values.contains(jobLocation)) {
1:74846bb:             values.add(jobLocation);
1:74846bb: 
1:74846bb:             // Reference the log file where the add command is stored to prevent GC.
1:74846bb:             this.store.incrementJournalCount(tx, location);
1:74846bb:             this.index.put(tx, nextExecutionTime, values);
1:74846bb:             this.scheduleTime.newJob();
1:74846bb:         } else {
1:74846bb:             this.index.put(tx, nextExecutionTime, values);
1:74846bb:             LOG.trace("Job {} already in scheduler at this time {}",
1:74846bb:                       jobLocation.getJobId(), jobLocation.getNextTime());
1:e3154c3:         }
1:e3154c3:     }
1:e3154c3: 
1:74846bb:     /**
1:74846bb:      * Reschedules a Job after it has be fired.
1:74846bb:      *
1:74846bb:      * For jobs that are repeating this method updates the job in the index by adding it to the
1:74846bb:      * jobs list for the new execution time.  If the job is not a cron type job then this method
1:74846bb:      * will reduce the repeat counter if the job has a fixed number of repeats set.  The Job will
1:74846bb:      * be removed from the jobs list it just executed on.
1:74846bb:      *
1:74846bb:      * This method must also update the value of the last update location in the JobLocation
1:74846bb:      * instance so that the checkpoint worker doesn't drop the log file in which that command lives.
1:74846bb:      *
1:74846bb:      * This method must ensure that an reschedule command that references a job that doesn't exist
1:74846bb:      * does not cause an error since it's possible that on recover the original add might be gone
1:74846bb:      * and so the job should not reappear in the scheduler.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *      The TX under which the index is updated.
1:74846bb:      * @param command
1:74846bb:      *      The reschedule command to process.
1:74846bb:      * @param location
1:74846bb:      *      The location in the index where the reschedule command was stored.
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs during the reschedule.
1:74846bb:      */
1:74846bb:     protected void process(final Transaction tx, final KahaRescheduleJobCommand command, Location location) throws IOException {
1:e3154c3:         JobLocation result = null;
1:74846bb:         final List<JobLocation> current = this.index.remove(tx, command.getExecutionTime());
1:74846bb:         if (current != null) {
1:74846bb:             for (int i = 0; i < current.size(); i++) {
1:74846bb:                 JobLocation jl = current.get(i);
1:74846bb:                 if (jl.getJobId().equals(command.getJobId())) {
1:74846bb:                     current.remove(i);
1:74846bb:                     if (!current.isEmpty()) {
1:74846bb:                         this.index.put(tx, command.getExecutionTime(), current);
1:e3154c3:                     }
1:e3154c3:                     result = jl;
1:c7c8e53:                     break;
1:e3154c3:                 }
1:c7c8e53:             }
1:74846bb:         } else {
1:74846bb:             LOG.debug("Process reschedule command for job {} non-existent executime time {}.",
1:74846bb:                       command.getJobId(), command.getExecutionTime());
1:c7c8e53:         }
1:e3154c3: 
1:d1446c3:         if (result != null) {
1:74846bb:             Location previousUpdate = result.getLastUpdate();
1:74846bb: 
1:74846bb:             List<JobLocation> target = null;
1:74846bb:             result.setNextTime(command.getNextExecutionTime());
1:74846bb:             result.setLastUpdate(location);
1:74846bb:             result.setRescheduledCount(command.getRescheduledCount());
1:74846bb:             if (!result.isCron() && result.getRepeat() > 0) {
1:74846bb:                 result.setRepeat(result.getRepeat() - 1);
1:d1446c3:             }
1:74846bb:             if (this.index.containsKey(tx, command.getNextExecutionTime())) {
1:74846bb:                 target = this.index.remove(tx, command.getNextExecutionTime());
1:74846bb:             }
1:74846bb:             if (target == null) {
1:9801622:                 target = new ArrayList<>();
1:74846bb:             }
1:74846bb:             target.add(result);
1:74846bb: 
1:74846bb:             // Track the location of the last reschedule command and release the log file
1:74846bb:             // reference for the previous one if there was one.
1:74846bb:             this.store.incrementJournalCount(tx, location);
1:74846bb:             if (previousUpdate != null) {
1:74846bb:                 this.store.decrementJournalCount(tx, previousUpdate);
1:74846bb:             }
1:74846bb: 
1:74846bb:             this.index.put(tx, command.getNextExecutionTime(), target);
1:74846bb:             this.scheduleTime.newJob();
1:74846bb:         } else {
1:74846bb:             LOG.debug("Process reschedule command for non-scheduled job {} at executime time {}.",
1:74846bb:                       command.getJobId(), command.getExecutionTime());
1:d1446c3:         }
1:c7c8e53:     }
1:d1446c3: 
1:74846bb:     /**
1:74846bb:      * Removes a scheduled job from the scheduler.
1:74846bb:      *
1:74846bb:      * The remove operation can be of two forms.  The first is that there is a job Id but no set time
1:74846bb:      * (-1) in which case the jobs index is searched until the target job Id is located.  The alternate
1:74846bb:      * form is that a job Id and execution time are both set in which case the given time is checked
1:74846bb:      * for a job matching that Id.  In either case once an execution time is identified the job is
1:74846bb:      * removed and the index updated.
1:74846bb:      *
1:74846bb:      * This method should ensure that if the matching job is not found that no error results as it
1:74846bb:      * is possible that on a recover the initial add command could be lost so the job may not be
1:74846bb:      * rescheduled.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *      The transaction under which the index is updated.
1:74846bb:      * @param command
1:74846bb:      *      The remove command to process.
1:74846bb:      * @param location
1:74846bb:      *      The location of the remove command in the Journal.
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs while updating the scheduler index.
1:74846bb:      */
1:74846bb:     void process(final Transaction tx, final KahaRemoveScheduledJobCommand command, Location location) throws IOException {
1:d1446c3: 
1:74846bb:         // Case 1: JobId and no time value means find the job and remove it.
1:74846bb:         // Case 2: JobId and a time value means find exactly this scheduled job.
1:74846bb: 
1:74846bb:         Long executionTime = command.getNextExecutionTime();
1:74846bb: 
1:74846bb:         List<JobLocation> values = null;
1:74846bb: 
1:74846bb:         if (executionTime == -1) {
1:74846bb:             for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx); i.hasNext();) {
1:74846bb:                 Map.Entry<Long, List<JobLocation>> entry = i.next();
1:74846bb:                 List<JobLocation> candidates = entry.getValue();
1:74846bb:                 if (candidates != null) {
1:74846bb:                     for (JobLocation jl : candidates) {
1:74846bb:                         if (jl.getJobId().equals(command.getJobId())) {
1:74846bb:                             LOG.trace("Entry {} contains the remove target: {}", entry.getKey(), command.getJobId());
1:74846bb:                             executionTime = entry.getKey();
1:74846bb:                             values = this.index.remove(tx, executionTime);
1:74846bb:                             break;
1:74846bb:                         }
1:74846bb:                     }
1:74846bb:                 }
1:74846bb:             }
1:74846bb:         } else {
1:74846bb:             values = this.index.remove(tx, executionTime);
1:74846bb:         }
1:74846bb: 
1:74846bb:         JobLocation removed = null;
1:74846bb: 
1:74846bb:         // Remove the job and update the index if there are any other jobs scheduled at this time.
1:74846bb:         if (values != null) {
1:74846bb:             for (JobLocation job : values) {
1:74846bb:                 if (job.getJobId().equals(command.getJobId())) {
1:74846bb:                     removed = job;
1:74846bb:                     values.remove(removed);
1:74846bb:                     break;
1:c7c8e53:                 }
1:c7c8e53:             }
1:e3154c3: 
1:d1446c3:             if (!values.isEmpty()) {
1:74846bb:                 this.index.put(tx, executionTime, values);
1:d1446c3:             }
1:d1446c3:         }
1:d1446c3: 
1:74846bb:         if (removed != null) {
1:74846bb:             LOG.trace("{} removed from scheduler {}", removed, this);
1:74846bb: 
1:74846bb:             // Remove the references for add and reschedule commands for this job
1:74846bb:             // so that those logs can be GC'd when free.
1:74846bb:             this.store.decrementJournalCount(tx, removed.getLocation());
1:74846bb:             if (removed.getLastUpdate() != null) {
1:74846bb:                 this.store.decrementJournalCount(tx, removed.getLastUpdate());
1:d1446c3:             }
1:74846bb: 
1:74846bb:             // now that the job is removed from the index we can store the remove info and
1:74846bb:             // then dereference the log files that hold the initial add command and the most
1:8c4b5f4:             // recent update command.  If the remove and the add that created the job are in
1:8c4b5f4:             // the same file we don't need to track it and just let a normal GC of the logs
1:8c4b5f4:             // remove it when the log is unreferenced.
1:8c4b5f4:             if (removed.getLocation().getDataFileId() != location.getDataFileId()) {
1:8c4b5f4:                 this.store.referenceRemovedLocation(tx, location, removed);
1:8c4b5f4:             }
1:c7c8e53:         }
1:c7c8e53:     }
1:e3154c3: 
1:74846bb:     /**
1:74846bb:      * Removes all scheduled jobs within a given time range.
1:74846bb:      *
1:74846bb:      * The method can be used to clear the entire scheduler index by specifying a range that
1:74846bb:      * encompasses all time [0...Long.MAX_VALUE] or a single execution time can be removed by
1:74846bb:      * setting start and end time to the same value.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *      The transaction under which the index is updated.
1:74846bb:      * @param command
1:74846bb:      *      The remove command to process.
1:74846bb:      * @param location
1:74846bb:      *      The location of the remove command in the Journal.
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs while updating the scheduler index.
1:74846bb:      */
1:74846bb:     protected void process(final Transaction tx, final KahaRemoveScheduledJobsCommand command, Location location) throws IOException {
1:74846bb:         removeInRange(tx, command.getStartTime(), command.getEndTime(), location);
1:c7c8e53:     }
1:c7c8e53: 
1:74846bb:     /**
1:74846bb:      * Removes all jobs from the schedulers index.  Must be called with the index locked.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *      The transaction under which the index entries for this scheduler are removed.
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs removing the jobs from the scheduler index.
1:74846bb:      */
1:74846bb:     protected void removeAll(Transaction tx) throws IOException {
1:74846bb:         this.removeInRange(tx, 0, Long.MAX_VALUE, null);
1:c7c8e53:     }
1:c7c8e53: 
1:74846bb:     /**
1:74846bb:      * Removes all scheduled jobs within the target range.
1:74846bb:      *
1:74846bb:      * This method can be used to remove all the stored jobs by passing a range of [0...Long.MAX_VALUE]
1:74846bb:      * or it can be used to remove all jobs at a given scheduled time by passing the same time value
1:74846bb:      * for both start and end.  If the optional location parameter is set then this method will update
1:74846bb:      * the store's remove location tracker with the location value and the Jobs that are being removed.
1:74846bb:      *
1:74846bb:      * This method must be called with the store index locked for writes.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *      The transaction under which the index is to be updated.
1:74846bb:      * @param start
1:74846bb:      *      The start time for the remove operation.
1:74846bb:      * @param finish
1:74846bb:      *      The end time for the remove operation.
1:74846bb:      * @param location (optional)
1:74846bb:      *      The location of the remove command that triggered this remove.
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs during the remove operation.
1:74846bb:      */
1:74846bb:     protected void removeInRange(Transaction tx, long start, long finish, Location location) throws IOException {
1:9801622:         List<Long> keys = new ArrayList<>();
1:c7c8e53:         for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx, start); i.hasNext();) {
1:c7c8e53:             Map.Entry<Long, List<JobLocation>> entry = i.next();
1:c7c8e53:             if (entry.getKey().longValue() <= finish) {
2:c7c8e53:                 keys.add(entry.getKey());
1:e3154c3:             } else {
1:c7c8e53:                 break;
1:dd0c9c4:             }
1:dd0c9c4:         }
1:dd0c9c4: 
1:74846bb:         for (Long executionTime : keys) {
1:74846bb:             List<JobLocation> values = this.index.remove(tx, executionTime);
1:74846bb:             if (location != null) {
1:74846bb:                 for (JobLocation job : values) {
1:74846bb:                     LOG.trace("Removing {} scheduled at: {}", job, executionTime);
1:74846bb: 
1:74846bb:                     // Remove the references for add and reschedule commands for this job
1:74846bb:                     // so that those logs can be GC'd when free.
1:74846bb:                     this.store.decrementJournalCount(tx, job.getLocation());
1:74846bb:                     if (job.getLastUpdate() != null) {
1:74846bb:                         this.store.decrementJournalCount(tx, job.getLastUpdate());
1:74846bb:                     }
1:74846bb: 
1:74846bb:                     // now that the job is removed from the index we can store the remove info and
1:74846bb:                     // then dereference the log files that hold the initial add command and the most
1:8c4b5f4:                     // recent update command.  If the remove and the add that created the job are in
1:8c4b5f4:                     // the same file we don't need to track it and just let a normal GC of the logs
1:8c4b5f4:                     // remove it when the log is unreferenced.
1:8c4b5f4:                     if (job.getLocation().getDataFileId() != location.getDataFileId()) {
1:8c4b5f4:                         this.store.referenceRemovedLocation(tx, location, job);
1:8c4b5f4:                     }
1:dd0c9c4:                 }
1:c7c8e53:             }
1:c7c8e53:         }
1:c7c8e53:     }
1:c7c8e53: 
1:74846bb:     /**
1:74846bb:      * Removes a Job from the index using it's Id value and the time it is currently set to
1:74846bb:      * be executed.  This method will only remove the Job if it is found at the given execution
1:74846bb:      * time.
1:74846bb:      *
1:74846bb:      * This method must be called under index lock.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *        the transaction under which this method is being executed.
1:74846bb:      * @param jobId
1:74846bb:      *        the target Job Id to remove.
1:74846bb:      * @param executionTime
1:74846bb:      *        the scheduled time that for the Job Id that is being removed.
1:74846bb:      *
1:74846bb:      * @returns true if the Job was removed or false if not found at the given time.
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs while removing the Job.
1:74846bb:      */
1:74846bb:     protected boolean removeJobAtTime(Transaction tx, String jobId, long executionTime) throws IOException {
1:74846bb:         boolean result = false;
1:74846bb: 
1:74846bb:         List<JobLocation> jobs = this.index.remove(tx, executionTime);
1:74846bb:         Iterator<JobLocation> jobsIter = jobs.iterator();
1:74846bb:         while (jobsIter.hasNext()) {
1:74846bb:             JobLocation job = jobsIter.next();
1:74846bb:             if (job.getJobId().equals(jobId)) {
1:74846bb:                 jobsIter.remove();
1:74846bb:                 // Remove the references for add and reschedule commands for this job
1:74846bb:                 // so that those logs can be GC'd when free.
1:74846bb:                 this.store.decrementJournalCount(tx, job.getLocation());
1:74846bb:                 if (job.getLastUpdate() != null) {
1:74846bb:                     this.store.decrementJournalCount(tx, job.getLastUpdate());
1:74846bb:                 }
1:74846bb:                 result = true;
1:74846bb:                 break;
1:74846bb:             }
1:c7c8e53:         }
1:74846bb: 
1:74846bb:         // Return the list to the index modified or unmodified.
1:74846bb:         this.index.put(tx, executionTime, jobs);
1:74846bb: 
1:74846bb:         return result;
1:c7c8e53:     }
1:c7c8e53: 
1:74846bb:     /**
1:74846bb:      * Walks the Scheduled Job Tree and collects the add location and last update location
1:74846bb:      * for all scheduled jobs.
1:74846bb:      *
1:74846bb:      * This method must be called with the index locked.
1:74846bb:      *
1:74846bb:      * @param tx
1:74846bb:      *        the transaction under which this operation was invoked.
1:74846bb:      *
1:74846bb:      * @return a list of all referenced Location values for this JobSchedulerImpl
1:74846bb:      *
1:74846bb:      * @throws IOException if an error occurs walking the scheduler tree.
1:74846bb:      */
1:74846bb:     protected List<JobLocation> getAllScheduledJobs(Transaction tx) throws IOException {
1:9801622:         List<JobLocation> references = new ArrayList<>();
1:74846bb: 
1:74846bb:         for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx); i.hasNext();) {
1:74846bb:             Map.Entry<Long, List<JobLocation>> entry = i.next();
1:74846bb:             List<JobLocation> scheduled = entry.getValue();
1:74846bb:             for (JobLocation job : scheduled) {
1:74846bb:                 references.add(job);
1:74846bb:             }
1:c7c8e53:         }
1:74846bb: 
1:74846bb:         return references;
1:c7c8e53:     }
1:c7c8e53: 
1:85bb229:     @Override
1:7ae2055:     public void run() {
2:7ae2055:         try {
1:7ae2055:             mainLoop();
1:7ae2055:         } catch (Throwable e) {
1:7ae2055:             if (this.running.get() && isStarted()) {
1:74846bb:                 LOG.error("{} Caught exception in mainloop", this, e);
67:7ae2055:             }
1:7ae2055:         } finally {
1:7ae2055:             if (running.get()) {
1:7ae2055:                 try {
1:7ae2055:                     stop();
1:7ae2055:                 } catch (Exception e) {
1:74846bb:                     LOG.error("Failed to stop {}", this);
1:7ae2055:                 }
1:7ae2055:             }
1:7ae2055:         }
1:7ae2055:     }
1:c7c8e53: 
1:85bb229:     @Override
1:7ae2055:     public String toString() {
1:74846bb:         return "JobScheduler: " + this.name;
1:7ae2055:     }
1:7ae2055: 
1:7ae2055:     protected void mainLoop() {
1:7ae2055:         while (this.running.get()) {
1:e3154c3:             this.scheduleTime.clearNewJob();
1:85bb229:             try {
1:7ae2055:                 long currentTime = System.currentTimeMillis();
1:85bb229: 
1:74846bb:                 // Read the list of scheduled events and fire the jobs, reschedule repeating jobs as
1:74846bb:                 // needed before firing the job event.
1:d1446c3:                 Map.Entry<Long, List<JobLocation>> first = getNextToSchedule();
1:d1446c3:                 if (first != null) {
1:9801622:                     List<JobLocation> list = new ArrayList<>(first.getValue());
1:9801622:                     List<JobLocation> toRemove = new ArrayList<>(list.size());
1:d1446c3:                     final long executionTime = first.getKey();
1:d1446c3:                     long nextExecutionTime = 0;
1:d1446c3:                     if (executionTime <= currentTime) {
1:d1446c3:                         for (final JobLocation job : list) {
1:74846bb: 
1:74846bb:                             if (!running.get()) {
1:74846bb:                                 break;
1:74846bb:                             }
1:74846bb: 
1:d1446c3:                             int repeat = job.getRepeat();
1:d1446c3:                             nextExecutionTime = calculateNextExecutionTime(job, currentTime, repeat);
1:d1446c3:                             long waitTime = nextExecutionTime - currentTime;
1:d1446c3:                             this.scheduleTime.setWaitTime(waitTime);
1:74846bb:                             if (!job.isCron()) {
1:d1446c3:                                 fireJob(job);
1:d1446c3:                                 if (repeat != 0) {
1:74846bb:                                     // Reschedule for the next time, the scheduler will take care of
1:74846bb:                                     // updating the repeat counter on the update.
1:74846bb:                                     doReschedule(job.getJobId(), executionTime, nextExecutionTime, job.getRescheduledCount() + 1);
1:d1446c3:                                 } else {
1:74846bb:                                     toRemove.add(job);
1:d1446c3:                                 }
1:d1446c3:                             } else {
1:d1446c3:                                 if (repeat == 0) {
1:74846bb:                                     // This is a non-repeating Cron entry so we can fire and forget it.
1:3d82d74:                                     fireJob(job);
1:d1446c3:                                 }
1:d1446c3: 
1:d1446c3:                                 if (nextExecutionTime > currentTime) {
1:74846bb:                                     // Reschedule the cron job as a new event, if the cron entry signals
1:74846bb:                                     // a repeat then it will be stored separately and fired as a normal
1:74846bb:                                     // event with decrementing repeat.
1:74846bb:                                     doReschedule(job.getJobId(), executionTime, nextExecutionTime, job.getRescheduledCount() + 1);
1:74846bb: 
1:3d82d74:                                     if (repeat != 0) {
1:d1446c3:                                         // we have a separate schedule to run at this time
1:d1446c3:                                         // so the cron job is used to set of a separate schedule
1:d1446c3:                                         // hence we won't fire the original cron job to the
1:d1446c3:                                         // listeners but we do need to start a separate schedule
1:d1446c3:                                         String jobId = ID_GENERATOR.generateId();
1:d1446c3:                                         ByteSequence payload = getPayload(job.getLocation());
1:d1446c3:                                         schedule(jobId, payload, "", job.getDelay(), job.getPeriod(), job.getRepeat());
1:d1446c3:                                         waitTime = job.getDelay() != 0 ? job.getDelay() : job.getPeriod();
1:d1446c3:                                         this.scheduleTime.setWaitTime(waitTime);
1:85bb229:                                     }
1:3d82d74:                                 } else {
1:74846bb:                                     toRemove.add(job);
1:85bb229:                                 }
1:85bb229:                             }
1:3d82d74:                         }
1:d1446c3: 
1:d1446c3:                         // now remove all jobs that have not been rescheduled from this execution
1:d1446c3:                         // time, if there are no more entries in that time it will be removed.
1:74846bb:                         doRemove(executionTime, toRemove);
1:d1446c3: 
1:d1446c3:                         // If there is a job that should fire before the currently set wait time
1:d1446c3:                         // we need to reset wait time otherwise we'll miss it.
1:d1446c3:                         Map.Entry<Long, List<JobLocation>> nextUp = getNextToSchedule();
1:d1446c3:                         if (nextUp != null) {
1:d1446c3:                             final long timeUntilNextScheduled = nextUp.getKey() - currentTime;
1:d1446c3:                             if (timeUntilNextScheduled < this.scheduleTime.getWaitTime()) {
1:d1446c3:                                 this.scheduleTime.setWaitTime(timeUntilNextScheduled);
1:d1446c3:                             }
1:d1446c3:                         }
1:d1446c3:                     } else {
1:d1446c3:                         this.scheduleTime.setWaitTime(executionTime - currentTime);
1:d1446c3:                     }
1:85bb229:                 }
1:d1446c3: 
1:e3154c3:                 this.scheduleTime.pause();
1:e3154c3:             } catch (Exception ioe) {
1:74846bb:                 LOG.error("{} Failed to schedule job", this.name, ioe);
1:7ae2055:                 try {
1:7ae2055:                     this.store.stop();
1:7ae2055:                 } catch (Exception e) {
1:74846bb:                     LOG.error("{} Failed to shutdown JobSchedulerStore", this.name, e);
1:8280417:                 }
1:8280417:             }
1:3d82d74:         }
1:3d82d74:     }
1:85bb229: 
1:74846bb:     void fireJob(JobLocation job) throws IllegalStateException, IOException {
1:74846bb:         LOG.debug("Firing: {}", job);
1:74846bb:         ByteSequence bs = this.store.getPayload(job.getLocation());
1:74846bb:         for (JobListener l : jobListeners) {
1:74846bb:             l.scheduledJob(job.getJobId(), bs);
1:74846bb:         }
1:74846bb:     }
1:74846bb: 
1:85bb229:     @Override
1:2d861da:     public void startDispatching() throws Exception {
1:2d861da:         if (!this.running.get()) {
1:2d861da:             return;
1:2d861da:         }
1:2d861da: 
1:2d861da:         if (started.compareAndSet(false, true)) {
1:2d861da:             this.thread = new Thread(this, "JobScheduler:" + this.name);
1:2d861da:             this.thread.setDaemon(true);
1:2d861da:             this.thread.start();
1:2d861da:         }
1:2d861da:     }
1:2d861da: 
1:2d861da:     @Override
1:2d861da:     public void stopDispatching() throws Exception {
1:2d861da:         if (started.compareAndSet(true, false)) {
1:2d861da:             this.scheduleTime.wakeup();
1:2d861da:             Thread t = this.thread;
1:2d861da:             this.thread = null;
1:2d861da:             if (t != null) {
1:74846bb:                 t.join(3000);
1:2d861da:             }
1:2d861da:         }
1:2d861da:     }
1:2d861da: 
1:2d861da:     @Override
1:7ae2055:     protected void doStart() throws Exception {
1:7ae2055:         this.running.set(true);
1:e3154c3:     }
1:8280417: 
1:85bb229:     @Override
1:7ae2055:     protected void doStop(ServiceStopper stopper) throws Exception {
1:7ae2055:         this.running.set(false);
1:2d861da:         stopDispatching();
1:e3154c3:     }
1:e3154c3: 
1:74846bb:     private ByteSequence getPayload(Location location) throws IllegalStateException, IOException {
1:74846bb:         return this.store.getPayload(location);
1:74846bb:     }
1:74846bb: 
1:e3154c3:     long calculateNextExecutionTime(final JobLocation job, long currentTime, int repeat) throws MessageFormatException {
1:e3154c3:         long result = currentTime;
1:e3154c3:         String cron = job.getCronEntry();
1:e3154c3:         if (cron != null && cron.length() > 0) {
1:e3154c3:             result = CronParser.getNextScheduledTime(cron, result);
1:e3154c3:         } else if (job.getRepeat() != 0) {
1:e3154c3:             result += job.getPeriod();
1:e3154c3:         }
1:d1446c3:         return result;
1:7ae2055:     }
1:e3154c3: 
1:7ae2055:     void createIndexes(Transaction tx) throws IOException {
1:9801622:         this.index = new BTreeIndex<>(this.store.getPageFile(), tx.allocate().getPageId());
1:7ae2055:     }
1:7ae2055: 
1:7ae2055:     void load(Transaction tx) throws IOException {
1:7ae2055:         this.index.setKeyMarshaller(LongMarshaller.INSTANCE);
1:74846bb:         this.index.setValueMarshaller(JobLocationsMarshaller.INSTANCE);
1:7ae2055:         this.index.load(tx);
1:7ae2055:     }
1:7ae2055: 
1:7ae2055:     void read(DataInput in) throws IOException {
1:7ae2055:         this.name = in.readUTF();
1:9801622:         this.index = new BTreeIndex<>(this.store.getPageFile(), in.readLong());
1:7ae2055:         this.index.setKeyMarshaller(LongMarshaller.INSTANCE);
1:74846bb:         this.index.setValueMarshaller(JobLocationsMarshaller.INSTANCE);
1:7ae2055:     }
1:7ae2055: 
1:7ae2055:     public void write(DataOutput out) throws IOException {
1:7ae2055:         out.writeUTF(name);
1:7ae2055:         out.writeLong(this.index.getPageId());
1:7ae2055:     }
1:7ae2055: 
1:e3154c3:     static class ScheduleTime {
1:e3154c3:         private final int DEFAULT_WAIT = 500;
1:e3154c3:         private final int DEFAULT_NEW_JOB_WAIT = 100;
1:e3154c3:         private boolean newJob;
1:e3154c3:         private long waitTime = DEFAULT_WAIT;
1:e3154c3:         private final Object mutex = new Object();
1:e3154c3: 
1:e3154c3:         /**
1:e3154c3:          * @return the waitTime
1:e3154c3:          */
1:e3154c3:         long getWaitTime() {
1:e3154c3:             return this.waitTime;
1:e3154c3:         }
1:85bb229: 
1:e3154c3:         /**
1:e3154c3:          * @param waitTime
1:e3154c3:          *            the waitTime to set
1:e3154c3:          */
1:e3154c3:         void setWaitTime(long waitTime) {
1:e3154c3:             if (!this.newJob) {
1:e3154c3:                 this.waitTime = waitTime > 0 ? waitTime : DEFAULT_WAIT;
1:e3154c3:             }
1:e3154c3:         }
1:e3154c3: 
1:e3154c3:         void pause() {
1:e3154c3:             synchronized (mutex) {
1:e3154c3:                 try {
1:e3154c3:                     mutex.wait(this.waitTime);
1:85bb229:                 } catch (InterruptedException e) {
1:e3154c3:                 }
1:e3154c3:             }
1:e3154c3:         }
1:e3154c3: 
1:e3154c3:         void newJob() {
1:e3154c3:             this.newJob = true;
1:e3154c3:             this.waitTime = DEFAULT_NEW_JOB_WAIT;
1:e3154c3:             wakeup();
1:e3154c3:         }
1:e3154c3: 
1:e3154c3:         void clearNewJob() {
1:e3154c3:             this.newJob = false;
1:e3154c3:         }
1:e3154c3: 
1:e3154c3:         void wakeup() {
1:e3154c3:             synchronized (this.mutex) {
1:e3154c3:                 mutex.notifyAll();
1:e3154c3:             }
1:e3154c3:         }
1:e3154c3:     }
1:7ae2055: }
============================================================================
author:Timothy Bish
-------------------------------------------------------------------------------
commit:2c828b2
/////////////////////////////////////////////////////////////////////////
1:         // round startTime - so we can schedule more jobs at the same time
1:         startTime = ((startTime + 500) / 500) * 500;
1: 
commit:9801622
/////////////////////////////////////////////////////////////////////////
1:     private final List<JobListener> jobListeners = new CopyOnWriteArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         final List<Job> result = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         final List<Job> result = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         final List<Job> result = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
0:         startTime = ((startTime + 500) / 1000) * 1000;
/////////////////////////////////////////////////////////////////////////
1:             values = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:                 target = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         List<Long> keys = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:         List<JobLocation> references = new ArrayList<>();
/////////////////////////////////////////////////////////////////////////
1:                     List<JobLocation> list = new ArrayList<>(first.getValue());
1:                     List<JobLocation> toRemove = new ArrayList<>(list.size());
/////////////////////////////////////////////////////////////////////////
1:         this.index = new BTreeIndex<>(this.store.getPageFile(), tx.allocate().getPageId());
/////////////////////////////////////////////////////////////////////////
1:         this.index = new BTreeIndex<>(this.store.getPageFile(), in.readLong());
commit:8c4b5f4
/////////////////////////////////////////////////////////////////////////
1:             // recent update command.  If the remove and the add that created the job are in
1:             // the same file we don't need to track it and just let a normal GC of the logs
1:             // remove it when the log is unreferenced.
1:             if (removed.getLocation().getDataFileId() != location.getDataFileId()) {
1:                 this.store.referenceRemovedLocation(tx, location, removed);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                     // recent update command.  If the remove and the add that created the job are in
1:                     // the same file we don't need to track it and just let a normal GC of the logs
1:                     // remove it when the log is unreferenced.
1:                     if (job.getLocation().getDataFileId() != location.getDataFileId()) {
1:                         this.store.referenceRemovedLocation(tx, location, job);
1:                     }
commit:74846bb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.protobuf.Buffer;
1: import org.apache.activemq.store.kahadb.data.KahaAddScheduledJobCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveScheduledJobCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRemoveScheduledJobsCommand;
1: import org.apache.activemq.store.kahadb.data.KahaRescheduleJobCommand;
/////////////////////////////////////////////////////////////////////////
1: public class JobSchedulerImpl extends ServiceSupport implements Runnable, JobScheduler {
1: 
1:     private final JobSchedulerStoreImpl store;
1:     private BTreeIndex<Long, List<JobLocation>> index;
/////////////////////////////////////////////////////////////////////////
1:     public void schedule(final String jobId, final ByteSequence payload, final long delay) throws IOException {
1:         doSchedule(jobId, payload, "", 0, delay, 0);
1:     public void schedule(final String jobId, final ByteSequence payload, final String cronEntry) throws Exception {
1:         doSchedule(jobId, payload, cronEntry, 0, 0, 0);
1:     public void schedule(final String jobId, final ByteSequence payload, final String cronEntry, final long delay, final long period, final int repeat) throws IOException {
1:         doSchedule(jobId, payload, cronEntry, delay, period, repeat);
1:     public void remove(final long time) throws IOException {
1:         doRemoveRange(time, time);
1:     public void remove(final String jobId) throws IOException {
1:         doRemove(-1, jobId);
1:     }
1: 
1:     @Override
1:     public void removeAllJobs() throws IOException {
1:         doRemoveRange(0, Long.MAX_VALUE);
1:     }
1: 
1:     @Override
1:     public void removeAllJobs(final long start, final long finish) throws IOException {
1:         doRemoveRange(start, finish);
1:     }
1: 
1:     @Override
1:     public long getNextScheduleTime() throws IOException {
1:         this.store.readLockIndex();
1:         try {
1:             Map.Entry<Long, List<JobLocation>> first = this.index.getFirst(this.store.getPageFile().tx());
1:             return first != null ? first.getKey() : -1l;
1:         } finally {
1:             this.store.readUnlockIndex();
1:         }
1:     }
1: 
1:     @Override
1:     public List<Job> getNextScheduleJobs() throws IOException {
1:         this.store.readLockIndex();
1:         try {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 @Override
1:                 public void execute(Transaction tx) throws IOException {
1:                     Map.Entry<Long, List<JobLocation>> first = index.getFirst(tx);
1:                     if (first != null) {
1:                         for (JobLocation jl : first.getValue()) {
1:             });
1:         } finally {
1:             this.store.readUnlockIndex();
1:         }
1:     private Map.Entry<Long, List<JobLocation>> getNextToSchedule() throws IOException {
1:         this.store.readLockIndex();
1:         try {
1:             if (!this.store.isStopped() && !this.store.isStopping()) {
1:                 Map.Entry<Long, List<JobLocation>> first = this.index.getFirst(this.store.getPageFile().tx());
1:                 return first;
1:             }
1:         } finally {
1:             this.store.readUnlockIndex();
1:         }
1:         return null;
1:     }
1: 
1:     public List<Job> getAllJobs() throws IOException {
1:         this.store.readLockIndex();
1:         try {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 @Override
1:                 public void execute(Transaction tx) throws IOException {
1:                     Iterator<Map.Entry<Long, List<JobLocation>>> iter = index.iterator(store.getPageFile().tx());
1:                     while (iter.hasNext()) {
1:                         Map.Entry<Long, List<JobLocation>> next = iter.next();
1:                         if (next != null) {
1:                             for (JobLocation jl : next.getValue()) {
1:                                 ByteSequence bs = getPayload(jl.getLocation());
1:                                 Job job = new JobImpl(jl, bs);
1:                                 result.add(job);
1:                             }
1:                         } else {
1:                             break;
1:             });
1:         } finally {
1:             this.store.readUnlockIndex();
1:         }
1:     public List<Job> getAllJobs(final long start, final long finish) throws IOException {
0:         final List<Job> result = new ArrayList<Job>();
1:         this.store.readLockIndex();
1:         try {
1:             this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:                 @Override
1:                 public void execute(Transaction tx) throws IOException {
1:                     Iterator<Map.Entry<Long, List<JobLocation>>> iter = index.iterator(tx, start);
1:                     while (iter.hasNext()) {
1:                         Map.Entry<Long, List<JobLocation>> next = iter.next();
1:                         if (next != null && next.getKey().longValue() <= finish) {
1:                             for (JobLocation jl : next.getValue()) {
1:                                 ByteSequence bs = getPayload(jl.getLocation());
1:                                 Job job = new JobImpl(jl, bs);
1:                                 result.add(job);
1:                             }
1:                         } else {
1:                             break;
1:                         }
1:                     }
1:                 }
1:             });
1:         } finally {
1:             this.store.readUnlockIndex();
1:         }
1:         return result;
1:     private void doSchedule(final String jobId, final ByteSequence payload, final String cronEntry, long delay, long period, int repeat) throws IOException {
/////////////////////////////////////////////////////////////////////////
1: 
1:         KahaAddScheduledJobCommand newJob = new KahaAddScheduledJobCommand();
1:         newJob.setScheduler(name);
1:         newJob.setJobId(jobId);
1:         newJob.setStartTime(startTime);
1:         newJob.setCronEntry(cronEntry);
1:         newJob.setDelay(delay);
1:         newJob.setPeriod(period);
1:         newJob.setRepeat(repeat);
1:         newJob.setNextExecutionTime(time);
1:         newJob.setPayload(new Buffer(payload.getData(), payload.getOffset(), payload.getLength()));
1: 
1:         this.store.store(newJob);
1:     }
1: 
1:     private void doReschedule(final String jobId, long executionTime, long nextExecutionTime, int rescheduledCount) throws IOException {
1:         KahaRescheduleJobCommand update = new KahaRescheduleJobCommand();
1:         update.setScheduler(name);
1:         update.setJobId(jobId);
1:         update.setExecutionTime(executionTime);
1:         update.setNextExecutionTime(nextExecutionTime);
1:         update.setRescheduledCount(rescheduledCount);
1:         this.store.store(update);
1:     }
1: 
1:     private void doRemove(final long executionTime, final List<JobLocation> jobs) throws IOException {
1:         for (JobLocation job : jobs) {
1:             doRemove(executionTime, job.getJobId());
1:     private void doRemove(long executionTime, final String jobId) throws IOException {
1:         KahaRemoveScheduledJobCommand remove = new KahaRemoveScheduledJobCommand();
1:         remove.setScheduler(name);
1:         remove.setJobId(jobId);
1:         remove.setNextExecutionTime(executionTime);
1:         this.store.store(remove);
1:     private void doRemoveRange(long start, long end) throws IOException {
1:         KahaRemoveScheduledJobsCommand destroy = new KahaRemoveScheduledJobsCommand();
1:         destroy.setScheduler(name);
1:         destroy.setStartTime(start);
1:         destroy.setEndTime(end);
1:         this.store.store(destroy);
1:     }
1: 
1:     /**
1:      * Adds a new Scheduled job to the index.  Must be called under index lock.
1:      *
1:      * This method must ensure that a duplicate add is not processed into the scheduler.  On index
1:      * recover some adds may be replayed and we don't allow more than one instance of a JobId to
1:      * exist at any given scheduled time, so filter these out to ensure idempotence.
1:      *
1:      * @param tx
1:      *      Transaction in which the update is performed.
1:      * @param command
1:      *      The new scheduled job command to process.
1:      * @param location
1:      *      The location where the add command is stored in the journal.
1:      *
1:      * @throws IOException if an error occurs updating the index.
1:      */
1:     protected void process(final Transaction tx, final KahaAddScheduledJobCommand command, Location location) throws IOException {
1:         JobLocation jobLocation = new JobLocation(location);
1:         jobLocation.setJobId(command.getJobId());
1:         jobLocation.setStartTime(command.getStartTime());
1:         jobLocation.setCronEntry(command.getCronEntry());
1:         jobLocation.setDelay(command.getDelay());
1:         jobLocation.setPeriod(command.getPeriod());
1:         jobLocation.setRepeat(command.getRepeat());
1: 
1:         long nextExecutionTime = command.getNextExecutionTime();
1: 
/////////////////////////////////////////////////////////////////////////
1:         // There can never be more than one instance of the same JobId scheduled at any
1:         // given time, when it happens its probably the result of index recovery and this
1:         // method must be idempotent so check for it first.
1:         if (!values.contains(jobLocation)) {
1:             values.add(jobLocation);
1: 
1:             // Reference the log file where the add command is stored to prevent GC.
1:             this.store.incrementJournalCount(tx, location);
1:             this.index.put(tx, nextExecutionTime, values);
1:             this.scheduleTime.newJob();
1:         } else {
1:             this.index.put(tx, nextExecutionTime, values);
1:             LOG.trace("Job {} already in scheduler at this time {}",
1:                       jobLocation.getJobId(), jobLocation.getNextTime());
1:     /**
1:      * Reschedules a Job after it has be fired.
1:      *
1:      * For jobs that are repeating this method updates the job in the index by adding it to the
1:      * jobs list for the new execution time.  If the job is not a cron type job then this method
1:      * will reduce the repeat counter if the job has a fixed number of repeats set.  The Job will
1:      * be removed from the jobs list it just executed on.
1:      *
1:      * This method must also update the value of the last update location in the JobLocation
1:      * instance so that the checkpoint worker doesn't drop the log file in which that command lives.
1:      *
1:      * This method must ensure that an reschedule command that references a job that doesn't exist
1:      * does not cause an error since it's possible that on recover the original add might be gone
1:      * and so the job should not reappear in the scheduler.
1:      *
1:      * @param tx
1:      *      The TX under which the index is updated.
1:      * @param command
1:      *      The reschedule command to process.
1:      * @param location
1:      *      The location in the index where the reschedule command was stored.
1:      *
1:      * @throws IOException if an error occurs during the reschedule.
1:      */
1:     protected void process(final Transaction tx, final KahaRescheduleJobCommand command, Location location) throws IOException {
1:         final List<JobLocation> current = this.index.remove(tx, command.getExecutionTime());
1:         if (current != null) {
1:             for (int i = 0; i < current.size(); i++) {
1:                 JobLocation jl = current.get(i);
1:                 if (jl.getJobId().equals(command.getJobId())) {
1:                     current.remove(i);
1:                     if (!current.isEmpty()) {
1:                         this.index.put(tx, command.getExecutionTime(), current);
1:         } else {
1:             LOG.debug("Process reschedule command for job {} non-existent executime time {}.",
1:                       command.getJobId(), command.getExecutionTime());
1:             Location previousUpdate = result.getLastUpdate();
1: 
1:             List<JobLocation> target = null;
1:             result.setNextTime(command.getNextExecutionTime());
1:             result.setLastUpdate(location);
1:             result.setRescheduledCount(command.getRescheduledCount());
1:             if (!result.isCron() && result.getRepeat() > 0) {
1:                 result.setRepeat(result.getRepeat() - 1);
1:             if (this.index.containsKey(tx, command.getNextExecutionTime())) {
1:                 target = this.index.remove(tx, command.getNextExecutionTime());
1:             }
1:             if (target == null) {
0:                 target = new ArrayList<JobLocation>();
1:             }
1:             target.add(result);
1: 
1:             // Track the location of the last reschedule command and release the log file
1:             // reference for the previous one if there was one.
1:             this.store.incrementJournalCount(tx, location);
1:             if (previousUpdate != null) {
1:                 this.store.decrementJournalCount(tx, previousUpdate);
1:             }
1: 
1:             this.index.put(tx, command.getNextExecutionTime(), target);
1:             this.scheduleTime.newJob();
1:         } else {
1:             LOG.debug("Process reschedule command for non-scheduled job {} at executime time {}.",
1:                       command.getJobId(), command.getExecutionTime());
1:     /**
1:      * Removes a scheduled job from the scheduler.
1:      *
1:      * The remove operation can be of two forms.  The first is that there is a job Id but no set time
1:      * (-1) in which case the jobs index is searched until the target job Id is located.  The alternate
1:      * form is that a job Id and execution time are both set in which case the given time is checked
1:      * for a job matching that Id.  In either case once an execution time is identified the job is
1:      * removed and the index updated.
1:      *
1:      * This method should ensure that if the matching job is not found that no error results as it
1:      * is possible that on a recover the initial add command could be lost so the job may not be
1:      * rescheduled.
1:      *
1:      * @param tx
1:      *      The transaction under which the index is updated.
1:      * @param command
1:      *      The remove command to process.
1:      * @param location
1:      *      The location of the remove command in the Journal.
1:      *
1:      * @throws IOException if an error occurs while updating the scheduler index.
1:      */
1:     void process(final Transaction tx, final KahaRemoveScheduledJobCommand command, Location location) throws IOException {
1:         // Case 1: JobId and no time value means find the job and remove it.
1:         // Case 2: JobId and a time value means find exactly this scheduled job.
1: 
1:         Long executionTime = command.getNextExecutionTime();
1: 
1:         List<JobLocation> values = null;
1: 
1:         if (executionTime == -1) {
1:             for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx); i.hasNext();) {
1:                 Map.Entry<Long, List<JobLocation>> entry = i.next();
1:                 List<JobLocation> candidates = entry.getValue();
1:                 if (candidates != null) {
1:                     for (JobLocation jl : candidates) {
1:                         if (jl.getJobId().equals(command.getJobId())) {
1:                             LOG.trace("Entry {} contains the remove target: {}", entry.getKey(), command.getJobId());
1:                             executionTime = entry.getKey();
1:                             values = this.index.remove(tx, executionTime);
1:                             break;
1:                         }
1:                     }
1:                 }
1:             }
1:         } else {
1:             values = this.index.remove(tx, executionTime);
1:         }
1: 
1:         JobLocation removed = null;
1: 
1:         // Remove the job and update the index if there are any other jobs scheduled at this time.
1:         if (values != null) {
1:             for (JobLocation job : values) {
1:                 if (job.getJobId().equals(command.getJobId())) {
1:                     removed = job;
1:                     values.remove(removed);
1:                     break;
1:                 this.index.put(tx, executionTime, values);
1:         if (removed != null) {
1:             LOG.trace("{} removed from scheduler {}", removed, this);
1: 
1:             // Remove the references for add and reschedule commands for this job
1:             // so that those logs can be GC'd when free.
1:             this.store.decrementJournalCount(tx, removed.getLocation());
1:             if (removed.getLastUpdate() != null) {
1:                 this.store.decrementJournalCount(tx, removed.getLastUpdate());
1: 
1:             // now that the job is removed from the index we can store the remove info and
1:             // then dereference the log files that hold the initial add command and the most
0:             // recent update command.
0:             this.store.referenceRemovedLocation(tx, location, removed);
1:     /**
1:      * Removes all scheduled jobs within a given time range.
1:      *
1:      * The method can be used to clear the entire scheduler index by specifying a range that
1:      * encompasses all time [0...Long.MAX_VALUE] or a single execution time can be removed by
1:      * setting start and end time to the same value.
1:      *
1:      * @param tx
1:      *      The transaction under which the index is updated.
1:      * @param command
1:      *      The remove command to process.
1:      * @param location
1:      *      The location of the remove command in the Journal.
1:      *
1:      * @throws IOException if an error occurs while updating the scheduler index.
1:      */
1:     protected void process(final Transaction tx, final KahaRemoveScheduledJobsCommand command, Location location) throws IOException {
1:         removeInRange(tx, command.getStartTime(), command.getEndTime(), location);
1:     /**
1:      * Removes all jobs from the schedulers index.  Must be called with the index locked.
1:      *
1:      * @param tx
1:      *      The transaction under which the index entries for this scheduler are removed.
1:      *
1:      * @throws IOException if an error occurs removing the jobs from the scheduler index.
1:      */
1:     protected void removeAll(Transaction tx) throws IOException {
1:         this.removeInRange(tx, 0, Long.MAX_VALUE, null);
1:     /**
1:      * Removes all scheduled jobs within the target range.
1:      *
1:      * This method can be used to remove all the stored jobs by passing a range of [0...Long.MAX_VALUE]
1:      * or it can be used to remove all jobs at a given scheduled time by passing the same time value
1:      * for both start and end.  If the optional location parameter is set then this method will update
1:      * the store's remove location tracker with the location value and the Jobs that are being removed.
1:      *
1:      * This method must be called with the store index locked for writes.
1:      *
1:      * @param tx
1:      *      The transaction under which the index is to be updated.
1:      * @param start
1:      *      The start time for the remove operation.
1:      * @param finish
1:      *      The end time for the remove operation.
1:      * @param location (optional)
1:      *      The location of the remove command that triggered this remove.
1:      *
1:      * @throws IOException if an error occurs during the remove operation.
1:      */
1:     protected void removeInRange(Transaction tx, long start, long finish, Location location) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         for (Long executionTime : keys) {
1:             List<JobLocation> values = this.index.remove(tx, executionTime);
1:             if (location != null) {
1:                 for (JobLocation job : values) {
1:                     LOG.trace("Removing {} scheduled at: {}", job, executionTime);
1: 
1:                     // Remove the references for add and reschedule commands for this job
1:                     // so that those logs can be GC'd when free.
1:                     this.store.decrementJournalCount(tx, job.getLocation());
1:                     if (job.getLastUpdate() != null) {
1:                         this.store.decrementJournalCount(tx, job.getLastUpdate());
1:                     }
1: 
1:                     // now that the job is removed from the index we can store the remove info and
1:                     // then dereference the log files that hold the initial add command and the most
0:                     // recent update command.
0:                     this.store.referenceRemovedLocation(tx, location, job);
1:     /**
1:      * Removes a Job from the index using it's Id value and the time it is currently set to
1:      * be executed.  This method will only remove the Job if it is found at the given execution
1:      * time.
1:      *
1:      * This method must be called under index lock.
1:      *
1:      * @param tx
1:      *        the transaction under which this method is being executed.
1:      * @param jobId
1:      *        the target Job Id to remove.
1:      * @param executionTime
1:      *        the scheduled time that for the Job Id that is being removed.
1:      *
1:      * @returns true if the Job was removed or false if not found at the given time.
1:      *
1:      * @throws IOException if an error occurs while removing the Job.
1:      */
1:     protected boolean removeJobAtTime(Transaction tx, String jobId, long executionTime) throws IOException {
1:         boolean result = false;
1: 
1:         List<JobLocation> jobs = this.index.remove(tx, executionTime);
1:         Iterator<JobLocation> jobsIter = jobs.iterator();
1:         while (jobsIter.hasNext()) {
1:             JobLocation job = jobsIter.next();
1:             if (job.getJobId().equals(jobId)) {
1:                 jobsIter.remove();
1:                 // Remove the references for add and reschedule commands for this job
1:                 // so that those logs can be GC'd when free.
1:                 this.store.decrementJournalCount(tx, job.getLocation());
1:                 if (job.getLastUpdate() != null) {
1:                     this.store.decrementJournalCount(tx, job.getLastUpdate());
1:                 }
1:                 result = true;
1:                 break;
1:             }
1: 
1:         // Return the list to the index modified or unmodified.
1:         this.index.put(tx, executionTime, jobs);
1: 
1:         return result;
1:     /**
1:      * Walks the Scheduled Job Tree and collects the add location and last update location
1:      * for all scheduled jobs.
1:      *
1:      * This method must be called with the index locked.
1:      *
1:      * @param tx
1:      *        the transaction under which this operation was invoked.
1:      *
1:      * @return a list of all referenced Location values for this JobSchedulerImpl
1:      *
1:      * @throws IOException if an error occurs walking the scheduler tree.
1:      */
1:     protected List<JobLocation> getAllScheduledJobs(Transaction tx) throws IOException {
0:         List<JobLocation> references = new ArrayList<JobLocation>();
1: 
1:         for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx); i.hasNext();) {
1:             Map.Entry<Long, List<JobLocation>> entry = i.next();
1:             List<JobLocation> scheduled = entry.getValue();
1:             for (JobLocation job : scheduled) {
1:                 references.add(job);
1:             }
1: 
1:         return references;
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("{} Caught exception in mainloop", this, e);
1:                     LOG.error("Failed to stop {}", this);
/////////////////////////////////////////////////////////////////////////
1:         return "JobScheduler: " + this.name;
1:                 // Read the list of scheduled events and fire the jobs, reschedule repeating jobs as
1:                 // needed before firing the job event.
0:                     List<JobLocation> toRemove = new ArrayList<JobLocation>(list.size());
1: 
1:                             if (!running.get()) {
1:                                 break;
1:                             }
1: 
1:                             if (!job.isCron()) {
1:                                     // Reschedule for the next time, the scheduler will take care of
1:                                     // updating the repeat counter on the update.
1:                                     doReschedule(job.getJobId(), executionTime, nextExecutionTime, job.getRescheduledCount() + 1);
1:                                     toRemove.add(job);
1:                                     // This is a non-repeating Cron entry so we can fire and forget it.
1:                                     // Reschedule the cron job as a new event, if the cron entry signals
1:                                     // a repeat then it will be stored separately and fired as a normal
1:                                     // event with decrementing repeat.
1:                                     doReschedule(job.getJobId(), executionTime, nextExecutionTime, job.getRescheduledCount() + 1);
1: 
/////////////////////////////////////////////////////////////////////////
1:                                     toRemove.add(job);
1:                         doRemove(executionTime, toRemove);
/////////////////////////////////////////////////////////////////////////
1:                 LOG.error("{} Failed to schedule job", this.name, ioe);
1:                     LOG.error("{} Failed to shutdown JobSchedulerStore", this.name, e);
1:     void fireJob(JobLocation job) throws IllegalStateException, IOException {
1:         LOG.debug("Firing: {}", job);
1:         ByteSequence bs = this.store.getPayload(job.getLocation());
1:         for (JobListener l : jobListeners) {
1:             l.scheduledJob(job.getJobId(), bs);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 t.join(3000);
/////////////////////////////////////////////////////////////////////////
1:     private ByteSequence getPayload(Location location) throws IllegalStateException, IOException {
1:         return this.store.getPayload(location);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.index.setValueMarshaller(JobLocationsMarshaller.INSTANCE);
/////////////////////////////////////////////////////////////////////////
1:         this.index.setValueMarshaller(JobLocationsMarshaller.INSTANCE);
/////////////////////////////////////////////////////////////////////////
commit:dd0c9c4
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
0:         for (Long l : keys) {
0:             List<JobLocation> values = this.index.remove(tx, l);
/////////////////////////////////////////////////////////////////////////
0:             List<JobLocation> values = this.index.remove(tx, l);
0:             if (values != null) {
0:                 for (JobLocation jl : values) {
0:                     this.store.decrementJournalCount(tx, jl.getLocation());
1:                 }
1:             }
commit:d1446c3
/////////////////////////////////////////////////////////////////////////
0:     synchronized void remove(final long time, final List<JobLocation> jobIds) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
1:             @Override
0:             public void execute(Transaction tx) throws IOException {
0:                 remove(tx, time, jobIds);
1:             }
0:         });
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void remove(Transaction tx, long time, List<JobLocation> jobIds) throws IOException {
0:         List<JobLocation> result = removeFromIndex(tx, time, jobIds);
1:         if (result != null) {
0:             for (JobLocation jl : result) {
0:                 this.store.decrementJournalCount(tx, jl.getLocation());
1:             }
1:         }
1:     }
1: 
0:     private List<JobLocation> removeFromIndex(Transaction tx, long time, List<JobLocation> Jobs) throws IOException {
0:         List<JobLocation> result = null;
0:         List<JobLocation> values = this.index.remove(tx, time);
0:         if (values != null) {
0:             result = new ArrayList<JobLocation>(values.size());
1: 
0:             for (JobLocation job : Jobs) {
0:                 if (values.remove(job)) {
1:                     result.add(job);
1:                 }
1:             }
1: 
1:             if (!values.isEmpty()) {
0:                 this.index.put(tx, time, values);
1:             }
1:         }
1:         return result;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 // Read the list of scheduled events and fire the jobs.  Once done with the batch
0:                 // remove all that were fired, and reschedule as needed.
1:                 Map.Entry<Long, List<JobLocation>> first = getNextToSchedule();
1:                 if (first != null) {
0:                     List<JobLocation> list = new ArrayList<JobLocation>(first.getValue());
0:                     List<JobLocation> fired = new ArrayList<JobLocation>(list.size());
1:                     final long executionTime = first.getKey();
1:                     long nextExecutionTime = 0;
1:                     if (executionTime <= currentTime) {
1:                         for (final JobLocation job : list) {
1:                             int repeat = job.getRepeat();
1:                             nextExecutionTime = calculateNextExecutionTime(job, currentTime, repeat);
1:                             long waitTime = nextExecutionTime - currentTime;
1:                             this.scheduleTime.setWaitTime(waitTime);
0:                             if (job.isCron() == false) {
1:                                 fireJob(job);
1:                                 if (repeat != 0) {
0:                                     repeat--;
0:                                     job.setRepeat(repeat);
0:                                     // remove this job from the index so it doesn't get destroyed
0:                                     removeFromIndex(executionTime, job.getJobId());
0:                                     // and re-store it
0:                                     storeJob(job, nextExecutionTime);
1:                                 } else {
0:                                     fired.add(job);
1:                                 }
1:                             } else {
0:                                 // cron job will have a repeat time.
1:                                 if (repeat == 0) {
0:                                     // we haven't got a separate scheduler to execute at
0:                                     // this time - just a cron job - so fire it
1:                                 }
1: 
1:                                 if (nextExecutionTime > currentTime) {
0:                                     // we will run again ...
0:                                     // remove this job from the index - so it doesn't get destroyed
0:                                     removeFromIndex(executionTime, job.getJobId());
0:                                     // and re-store it
0:                                     storeJob(job, nextExecutionTime);
1:                                         // we have a separate schedule to run at this time
1:                                         // so the cron job is used to set of a separate schedule
1:                                         // hence we won't fire the original cron job to the
1:                                         // listeners but we do need to start a separate schedule
1:                                         String jobId = ID_GENERATOR.generateId();
1:                                         ByteSequence payload = getPayload(job.getLocation());
1:                                         schedule(jobId, payload, "", job.getDelay(), job.getPeriod(), job.getRepeat());
1:                                         waitTime = job.getDelay() != 0 ? job.getDelay() : job.getPeriod();
1:                                         this.scheduleTime.setWaitTime(waitTime);
0:                                     fired.add(job);
1: 
1:                         // now remove all jobs that have not been rescheduled from this execution
1:                         // time, if there are no more entries in that time it will be removed.
0:                         remove(executionTime, fired);
1: 
1:                         // If there is a job that should fire before the currently set wait time
1:                         // we need to reset wait time otherwise we'll miss it.
1:                         Map.Entry<Long, List<JobLocation>> nextUp = getNextToSchedule();
1:                         if (nextUp != null) {
1:                             final long timeUntilNextScheduled = nextUp.getKey() - currentTime;
1:                             if (timeUntilNextScheduled < this.scheduleTime.getWaitTime()) {
1:                                 this.scheduleTime.setWaitTime(timeUntilNextScheduled);
1:                             }
1:                         }
1:                     } else {
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Not yet time to execute the job, waiting " + (executionTime - currentTime) + " ms");
1:                         }
1:                         this.scheduleTime.setWaitTime(executionTime - currentTime);
1: 
author:Timothy A. Bish
-------------------------------------------------------------------------------
commit:2d861da
/////////////////////////////////////////////////////////////////////////
1:     private final AtomicBoolean started = new AtomicBoolean(false);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void startDispatching() throws Exception {
1:         if (!this.running.get()) {
1:             return;
1:         }
1: 
1:         if (started.compareAndSet(false, true)) {
1:             this.thread = new Thread(this, "JobScheduler:" + this.name);
1:             this.thread.setDaemon(true);
1:             this.thread.start();
1:         }
1:     }
1: 
1:     @Override
1:     public void stopDispatching() throws Exception {
1:         if (started.compareAndSet(true, false)) {
1:             this.scheduleTime.wakeup();
1:             Thread t = this.thread;
1:             this.thread = null;
1:             if (t != null) {
0:                 t.join(1000);
1:             }
1:         }
1:     }
1: 
1:     @Override
1:         stopDispatching();
commit:85bb229
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;
1: import org.apache.activemq.store.kahadb.disk.journal.Location;
1: import org.apache.activemq.store.kahadb.disk.page.Transaction;
1: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
0: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
1: import org.apache.activemq.util.ByteSequence;
/////////////////////////////////////////////////////////////////////////
0:     private final Object listenerLock = new Object();
/////////////////////////////////////////////////////////////////////////
1:      *
1:     @Override
1:      *
0:      * @see org.apache.activemq.beanstalk.JobScheduler#addListener(org.apache.activemq .beanstalk.JobListener)
1:     @Override
0:         synchronized (this.listenerLock) {
0:             this.listenerLock.notify();
1:         }
1:      *
0:      * @see org.apache.activemq.beanstalk.JobScheduler#removeListener(org.apache. activemq.beanstalk.JobListener)
1:     @Override
1:     @Override
1:             @Override
1:     @Override
1:             @Override
1:     @Override
0:     public synchronized void schedule(final String jobId, final ByteSequence payload, final String cronEntry, final long delay, final long period,
0:         final int repeat) throws IOException {
1:             @Override
1:      *
1:     @Override
1:             @Override
/////////////////////////////////////////////////////////////////////////
1:             @Override
/////////////////////////////////////////////////////////////////////////
0:      *
0:      * @see org.apache.activemq.beanstalk.JobScheduler#remove(long, java.lang.String)
1:             @Override
/////////////////////////////////////////////////////////////////////////
0:      *
0:     @Override
0:             @Override
0:     @Override
/////////////////////////////////////////////////////////////////////////
0:      *
0:     @Override
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:             @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
0:             @Override
0:     @Override
0:             @Override
0:     void schedule(Transaction tx, String jobId, ByteSequence payload, String cronEntry, long delay, long period, int repeat) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:             @Override
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
0:             // Can't start pumping messages until a listener is added otherwise we'd discard messages
0:             // without any warning.
0:             synchronized (listenerLock) {
0:                 while (this.running.get() && this.jobListeners.isEmpty()) {
1:                     try {
0:                         LOG.debug("Scheduled Message dispatch paused while awaiting a Job Listener");
0:                         this.listenerLock.wait();
1:                     } catch (InterruptedException e) {
1:                     }
1:                 }
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
0:                                         // remove this job from the index so it doesn't get destroyed
/////////////////////////////////////////////////////////////////////////
0:                                         // we haven't got a separate scheduler to execute at
0:                                         // remove this job from the index - so it doesn't get destroyed
0:                                             // we have a separate schedule to run at this time
0:                                             // so the cron job is used to set of a separate schedule
0:                                             // hence we won't fire the original cron job to the
0:                                             // listeners but we do need to start a separate schedule
/////////////////////////////////////////////////////////////////////////
0:                                 final long timeUntilNextScheduled = nextUp.getKey() - currentTime;
0:                                 if (timeUntilNextScheduled < this.scheduleTime.getWaitTime()) {
0:                                     this.scheduleTime.setWaitTime(timeUntilNextScheduled);
1:                                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         synchronized (this.listenerLock) {
0:             this.listenerLock.notify();
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:         @Override
/////////////////////////////////////////////////////////////////////////
0:         @Override
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:8280417
/////////////////////////////////////////////////////////////////////////
0:                 // Prevents race conditions on short delays, when storeJob() tries to append new items to the
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                                         //this.scheduleTime.setWaitTime(this.scheduleTime.DEFAULT_WAIT);
/////////////////////////////////////////////////////////////////////////
1: 
0:                             // If there is a job that should fire before the currently set wait time
0:                             // we need to reset wait time otherwise we'll miss it.
0:                             Map.Entry<Long, List<JobLocation>> nextUp = getNextToSchedule();
0:                             if (nextUp != null) {
0: 	                            final long timeUntilNextScheduled = nextUp.getKey() - currentTime;
0: 	                            if (timeUntilNextScheduled < this.scheduleTime.getWaitTime()) {
0: 	                            	this.scheduleTime.setWaitTime(timeUntilNextScheduled);
1: 	                            }
1:                             }
1: 
commit:3d82d74
/////////////////////////////////////////////////////////////////////////
0:                 // Reads the list of the next entries and removes them from the store in one atomic step.
0:                 // Prevents race conditions on short delays, when storeJob() tries to append new items to the 
0:                 // existing list during this read operation (see AMQ-3141).
0:                 synchronized (this) {
0:                     Map.Entry<Long, List<JobLocation>> first = getNextToSchedule();
0:                     if (first != null) {
0:                         List<JobLocation> list = new ArrayList<JobLocation>(first.getValue());
0:                         final long executionTime = first.getKey();
0:                         long nextExecutionTime = 0;
0:                         if (executionTime <= currentTime) {
1:     
0:                             for (final JobLocation job : list) {
0:                                 int repeat = job.getRepeat();
0:                                 nextExecutionTime = calculateNextExecutionTime(job, currentTime, repeat);
0:                                 long waitTime = nextExecutionTime - currentTime;
0:                                 this.scheduleTime.setWaitTime(waitTime);
0:                                 if (job.isCron() == false) {
0:                                         repeat--;
0:                                         job.setRepeat(repeat);
0:                                         // remove this job from the index - so it
0:                                         // doesn't get destroyed
0:                                         removeFromIndex(executionTime, job.getJobId());
0:                                         // and re-store it
0:                                         storeJob(job, nextExecutionTime);
1:                                     }
1:                                 } else {
0:                                     // cron job
0:                                     if (repeat == 0) {
0:                                         // we haven't got a separate scheduler to
0:                                         // execute at
0:                                         // this time - just a cron job - so fire it
1:                                         fireJob(job);
1:                                     }
0:                                     if (nextExecutionTime > currentTime) {
0:                                         // we will run again ...
0:                                         // remove this job from the index - so it
0:                                         // doesn't get destroyed
0:                                         removeFromIndex(executionTime, job.getJobId());
0:                                         // and re-store it
0:                                         storeJob(job, nextExecutionTime);
1:                                         if (repeat != 0) {
0:                                             // we have a separate schedule to run at
0:                                             // this time
0:                                             // so the cron job is used to set of a
0:                                             // seperate scheule
0:                                             // hence we won't fire the original cron
0:                                             // job to the listeners
0:                                             // but we do need to start a separate
0:                                             // schedule
0:                                             String jobId = ID_GENERATOR.generateId();
0:                                             ByteSequence payload = getPayload(job.getLocation());
0:                                             schedule(jobId, payload, "", job.getDelay(), job.getPeriod(), job.getRepeat());
0:                                             waitTime = job.getDelay() != 0 ? job.getDelay() : job.getPeriod();
0:                                             this.scheduleTime.setWaitTime(waitTime);
1:                                         }
0:                             // now remove all jobs that have not been
0:                             // rescheduled from this execution time
0:                             remove(executionTime);
1:                         } else {
0:                             if (LOG.isDebugEnabled()) {
0:                                 LOG.debug("Not yet time to execute the job, waiting " + (executionTime - currentTime) + " ms");
1:                             }
0:                             this.scheduleTime.setWaitTime(executionTime - currentTime);
commit:595e44c
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void schedule(final String jobId, final ByteSequence payload, final long delay) throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void schedule(final String jobId, final ByteSequence payload, final String cronEntry) throws Exception {
/////////////////////////////////////////////////////////////////////////
0:     public synchronized void schedule(final String jobId, final ByteSequence payload, final String cronEntry, final long delay,
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:c5cf038
commit:0484af1
/////////////////////////////////////////////////////////////////////////
1: package org.apache.activemq.store.kahadb.scheduler;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.activemq.broker.scheduler.CronParser;
1: import org.apache.activemq.broker.scheduler.Job;
1: import org.apache.activemq.broker.scheduler.JobListener;
1: import org.apache.activemq.broker.scheduler.JobScheduler;
/////////////////////////////////////////////////////////////////////////
0:     final JobSchedulerStoreImpl store;
/////////////////////////////////////////////////////////////////////////
1:     JobSchedulerImpl(JobSchedulerStoreImpl store) {
commit:1aab71b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;
0: import org.apache.activemq.store.kahadb.disk.journal.Location;
0: import org.apache.activemq.store.kahadb.disk.page.Transaction;
0: import org.apache.activemq.util.ByteSequence;
0: import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;
0: import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;
author:Bosanac Dejan
-------------------------------------------------------------------------------
commit:8bf987b
/////////////////////////////////////////////////////////////////////////
1: import org.slf4j.Logger;
1: import org.slf4j.LoggerFactory;
/////////////////////////////////////////////////////////////////////////
1:     private static final Logger LOG = LoggerFactory.getLogger(JobSchedulerImpl.class);
commit:fab6ba1
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Scheduling " + jobLocation);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (LOG.isDebugEnabled()) {
0:             LOG.debug("Firing " + job);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                         if (LOG.isDebugEnabled()) {
0:                             LOG.debug("Not yet time to execute the job, waiting " + (executionTime - currentTime) + " ms");
1:                         }
author:Robert Davies
-------------------------------------------------------------------------------
commit:e3154c3
/////////////////////////////////////////////////////////////////////////
1: import javax.jms.MessageFormatException;
1: import org.apache.activemq.util.IdGenerator;
/////////////////////////////////////////////////////////////////////////
1:     private static final IdGenerator ID_GENERATOR = new IdGenerator();
1:     private final ScheduleTime scheduleTime = new ScheduleTime();
/////////////////////////////////////////////////////////////////////////
0:                 schedule(tx, jobId, payload, "", 0, delay, 0);
0:     public void schedule(final String jobId, final ByteSequence payload, final String cronEntry) throws Exception {
0:                 schedule(tx, jobId, payload, cronEntry, 0, 0, 0);
1:             }
0:         });
1: 
1:     }
1: 
0:     public void schedule(final String jobId, final ByteSequence payload, final String cronEntry, final long delay,
0:             final long period, final int repeat) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 schedule(tx, jobId, payload, cronEntry, delay, period, repeat);
/////////////////////////////////////////////////////////////////////////
0:     synchronized void removeFromIndex(final long time, final String jobId) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 removeFromIndex(tx, time, jobId);
1:             }
0:         });
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         ByteSequence bs = getPayload(jl.getLocation());
/////////////////////////////////////////////////////////////////////////
0:                             ByteSequence bs = getPayload(jl.getLocation());
/////////////////////////////////////////////////////////////////////////
0:                             ByteSequence bs = getPayload(jl.getLocation());
/////////////////////////////////////////////////////////////////////////
0:                 destroy(tx, start, finish);
0:     ByteSequence getPayload(Location location) throws IllegalStateException, IOException {
0:         return this.store.getPayload(location);
0:     void schedule(Transaction tx, String jobId, ByteSequence payload, String cronEntry, long delay, long period,
0:             int repeat) throws IOException {
1:         long startTime = System.currentTimeMillis();
0:         // round startTime - so we can schedule more jobs
0:         // at the same time
0:         startTime = (startTime / 1000) * 1000;
1:         long time = 0;
1:         if (cronEntry != null && cronEntry.length() > 0) {
1:             try {
1:                 time = CronParser.getNextScheduledTime(cronEntry, startTime);
1:             } catch (MessageFormatException e) {
1:                 throw new IOException(e.getMessage());
1:             }
1:         }
1: 
1:         if (time == 0) {
1:             // start time not set by CRON - so it it to the current time
1:             time = startTime;
1:         }
1:         if (delay > 0) {
1:             time += delay;
1:             time += period;
0:         this.store.incrementJournalCount(tx, location);
0:         jobLocation.setStartTime(startTime);
0:         jobLocation.setCronEntry(cronEntry);
0:         jobLocation.setDelay(delay);
0:         storeJob(tx, jobLocation, time);
0:         this.scheduleTime.newJob();
1:     }
1: 
0:     synchronized void storeJob(final JobLocation jobLocation, final long nextExecutionTime) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 storeJob(tx, jobLocation, nextExecutionTime);
1:             }
0:         });
1:     }
1: 
0:     void storeJob(final Transaction tx, final JobLocation jobLocation, final long nextExecutionTime) throws IOException {
1:         List<JobLocation> values = null;
1:         jobLocation.setNextTime(nextExecutionTime);
1:         if (this.index.containsKey(tx, nextExecutionTime)) {
1:             values = this.index.remove(tx, nextExecutionTime);
1:         }
1:         if (values == null) {
0:             values = new ArrayList<JobLocation>();
1:         }
0:         this.index.put(tx, nextExecutionTime, values);
1: 
0:         JobLocation result = removeFromIndex(tx, time, jobId);
0:         if (result != null) {
0:             this.store.decrementJournalCount(tx, result.getLocation());
1:         }
1:     }
1: 
0:     JobLocation removeFromIndex(Transaction tx, long time, String jobId) throws IOException {
1:         JobLocation result = null;
/////////////////////////////////////////////////////////////////////////
1:                     result = jl;
1:         return result;
/////////////////////////////////////////////////////////////////////////
0:     private synchronized Map.Entry<Long, List<JobLocation>> getNextToSchedule() throws IOException {
/////////////////////////////////////////////////////////////////////////
0:     void fireJob(JobLocation job) throws IllegalStateException, IOException {
0:         ByteSequence bs = this.store.getPayload(job.getLocation());
0:         for (JobListener l : jobListeners) {
0:             l.scheduledJob(job.getJobId(), bs);
/////////////////////////////////////////////////////////////////////////
1:             this.scheduleTime.clearNewJob();
/////////////////////////////////////////////////////////////////////////
0:                     final long executionTime = first.getKey();
0:                     long nextExecutionTime = 0;
1: 
0:                         for (final JobLocation job : list) {
0:                             int repeat = job.getRepeat();
0:                             nextExecutionTime = calculateNextExecutionTime(job, currentTime, repeat);
0:                             long waitTime = nextExecutionTime - currentTime;
0:                             this.scheduleTime.setWaitTime(waitTime);
0:                             if (job.isCron() == false) {
0:                                 fireJob(job);
0:                                 if (repeat != 0) {
0:                                     repeat--;
0:                                     job.setRepeat(repeat);
0:                                     // remove this job from the index - so it
0:                                     // doesn't get destroyed
0:                                     removeFromIndex(executionTime, job.getJobId());
0:                                     // and re-store it
0:                                     storeJob(job, nextExecutionTime);
1:                                 }
1:                             } else {
0:                                 // cron job
0:                                 if (repeat == 0) {
0:                                     // we haven't got a separate scheduler to
0:                                     // execute at
0:                                     // this time - just a cron job - so fire it
0:                                     fireJob(job);
1:                                 }
0:                                 if (nextExecutionTime > currentTime) {
0:                                     // we will run again ...
0:                                     // remove this job from the index - so it
0:                                     // doesn't get destroyed
0:                                     removeFromIndex(executionTime, job.getJobId());
0:                                     // and re-store it
0:                                     storeJob(job, nextExecutionTime);
0:                                     if (repeat != 0) {
0:                                         // we have a separate schedule to run at
0:                                         // this time
0:                                         // so the cron job is used to set of a
0:                                         // seperate scheule
0:                                         // hence we won't fire the original cron
0:                                         // job to the listeners
0:                                         // but we do need to start a separate
0:                                         // schedule
0:                                         String jobId = ID_GENERATOR.generateId();
0:                                         ByteSequence payload = getPayload(job.getLocation());
0:                                         schedule(jobId, payload, "", job.getDelay(), job.getPeriod(), job.getRepeat());
0:                                         waitTime = job.getDelay() != 0 ? job.getDelay() : job.getPeriod();
0:                                         this.scheduleTime.setWaitTime(waitTime);
1:                                     }
1:                                 }
0:                         // now remove all jobs that have not been
0:                         // rescheduled from this execution time
0:                         this.scheduleTime.setWaitTime(executionTime - currentTime);
1:                 this.scheduleTime.pause();
1: 
1:             } catch (Exception ioe) {
/////////////////////////////////////////////////////////////////////////
0:         this.scheduleTime.wakeup();
/////////////////////////////////////////////////////////////////////////
1:     long calculateNextExecutionTime(final JobLocation job, long currentTime, int repeat) throws MessageFormatException {
1:         long result = currentTime;
1:         String cron = job.getCronEntry();
1:         if (cron != null && cron.length() > 0) {
1:             result = CronParser.getNextScheduledTime(cron, result);
1:         } else if (job.getRepeat() != 0) {
1:             result += job.getPeriod();
1:         return result;
/////////////////////////////////////////////////////////////////////////
1: 
1:     static class ScheduleTime {
1:         private final int DEFAULT_WAIT = 500;
1:         private final int DEFAULT_NEW_JOB_WAIT = 100;
1:         private boolean newJob;
1:         private long waitTime = DEFAULT_WAIT;
1:         private final Object mutex = new Object();
1: 
1:         /**
1:          * @return the waitTime
1:          */
1:         long getWaitTime() {
1:             return this.waitTime;
1:         }
1:         /**
1:          * @param waitTime
1:          *            the waitTime to set
1:          */
1:         void setWaitTime(long waitTime) {
1:             if (!this.newJob) {
1:                 this.waitTime = waitTime > 0 ? waitTime : DEFAULT_WAIT;
1:             }
1:         }
1: 
1:         void pause() {
1:             synchronized (mutex) {
1:                 try {
1:                     mutex.wait(this.waitTime);
0:                 } catch (InterruptedException e) {
1:                 }
1:             }
1:         }
1: 
1:         void newJob() {
1:             this.newJob = true;
1:             this.waitTime = DEFAULT_NEW_JOB_WAIT;
1:             wakeup();
1:         }
1: 
1:         void clearNewJob() {
1:             this.newJob = false;
1:         }
1: 
1:         void wakeup() {
1:             synchronized (this.mutex) {
1:                 mutex.notifyAll();
1:             }
1:         }
1: 
1:     }
commit:c7c8e53
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void schedule(final String jobId, final ByteSequence payload, final long start, final long period,
0:             final int repeat) throws IOException {
1: 
/////////////////////////////////////////////////////////////////////////
0:     public synchronized List<Job> getNextScheduleJobs() throws IOException {
0:         final List<Job> result = new ArrayList<Job>();
/////////////////////////////////////////////////////////////////////////
1:                         Job job = new JobImpl(jl, bs);
0:                         result.add(job);
/////////////////////////////////////////////////////////////////////////
0:     public synchronized List<Job> getAllJobs() throws IOException {
0:         final List<Job> result = new ArrayList<Job>();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 Iterator<Map.Entry<Long, List<JobLocation>>> iter = index.iterator(store.getPageFile().tx());
0:                 while (iter.hasNext()) {
0:                     Map.Entry<Long, List<JobLocation>> next = iter.next();
0:                     if (next != null) {
0:                         for (JobLocation jl : next.getValue()) {
0:                             ByteSequence bs = getJob(jl.getLocation());
0:                             Job job = new JobImpl(jl, bs);
0:                             result.add(job);
1:                         }
0:                     } else {
1:                         break;
1:                     }
1:                 }
1: 
1:             }
0:         });
0:         return result;
1:     }
1: 
0:     public synchronized List<Job> getAllJobs(final long start, final long finish) throws IOException {
0:         final List<Job> result = new ArrayList<Job>();
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 Iterator<Map.Entry<Long, List<JobLocation>>> iter = index.iterator(store.getPageFile().tx(), start);
0:                 while (iter.hasNext()) {
0:                     Map.Entry<Long, List<JobLocation>> next = iter.next();
0:                     if (next != null && next.getKey().longValue() <= finish) {
0:                         for (JobLocation jl : next.getValue()) {
0:                             ByteSequence bs = getJob(jl.getLocation());
0:                             Job job = new JobImpl(jl, bs);
0:                             result.add(job);
1:                         }
0:                     } else {
1:                         break;
1:                     }
1:                 }
1: 
1:             }
0:         });
0:         return result;
1:     }
1: 
0:     public synchronized void removeAllJobs() throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 destroy(tx);
1:             }
0:         });
1:     }
1: 
0:     public synchronized void removeAllJobs(final long start, final long finish) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 destroy(tx,start,finish);
1:             }
0:         });
1: 
1:     }
1: 
0:     void schedule(Transaction tx, String jobId, ByteSequence payload, long start, long period, int repeat)
0:         } else {
/////////////////////////////////////////////////////////////////////////
0:         List<Long> keys = new ArrayList<Long>();
1:             keys.add(entry.getKey());
1:         }
0:         for (Long l : keys) {
0:             this.index.remove(tx, l);
1:         }
1:     }
0:     synchronized void destroy(Transaction tx, long start, long finish) throws IOException {
0:         List<Long> keys = new ArrayList<Long>();
1:         for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx, start); i.hasNext();) {
1:             Map.Entry<Long, List<JobLocation>> entry = i.next();
1:             if (entry.getKey().longValue() <= finish) {
1:                 keys.add(entry.getKey());
0:                 List<JobLocation> values = entry.getValue();
0:                 if (values != null) {
0:                     for (JobLocation jl : values) {
0:                         this.store.decrementJournalCount(tx, jl.getLocation());
1:                     }
1:                 }
0:             } else {
0:                 break;
1:             }
1:         }
0:         for (Long l : keys) {
0:             this.index.remove(tx, l);
/////////////////////////////////////////////////////////////////////////
0:                                 schedule(jobId, payload, 0, period, repeat);
/////////////////////////////////////////////////////////////////////////
commit:7ae2055
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
0:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
0:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
0: package org.apache.activemq.broker.scheduler;
1: 
1: import java.io.DataInput;
1: import java.io.DataOutput;
1: import java.io.IOException;
1: import java.util.ArrayList;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: import org.apache.activemq.util.ServiceStopper;
1: import org.apache.activemq.util.ServiceSupport;
0: import org.apache.commons.logging.Log;
0: import org.apache.commons.logging.LogFactory;
0: import org.apache.kahadb.index.BTreeIndex;
0: import org.apache.kahadb.journal.Location;
0: import org.apache.kahadb.page.Transaction;
0: import org.apache.kahadb.util.ByteSequence;
0: import org.apache.kahadb.util.LongMarshaller;
0: import org.apache.kahadb.util.VariableMarshaller;
1: 
0: class JobSchedulerImpl extends ServiceSupport implements Runnable, JobScheduler {
0:     private static final Log LOG = LogFactory.getLog(JobSchedulerImpl.class);
0:     final JobSchedulerStore store;
1:     private final AtomicBoolean running = new AtomicBoolean();
1:     private String name;
0:     BTreeIndex<Long, List<JobLocation>> index;
1:     private Thread thread;
0:     private final List<JobListener> jobListeners = new CopyOnWriteArrayList<JobListener>();
1: 
0:     JobSchedulerImpl(JobSchedulerStore store) {
1: 
1:         this.store = store;
1:     }
1: 
1:     public void setName(String name) {
1:         this.name = name;
1:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see org.apache.activemq.beanstalk.JobScheduler#getName()
1:      */
1:     public String getName() {
1:         return this.name;
1:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see
0:      * org.apache.activemq.beanstalk.JobScheduler#addListener(org.apache.activemq
0:      * .beanstalk.JobListener)
1:      */
1:     public void addListener(JobListener l) {
1:         this.jobListeners.add(l);
1:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see
0:      * org.apache.activemq.beanstalk.JobScheduler#removeListener(org.apache.
0:      * activemq.beanstalk.JobListener)
1:      */
1:     public void removeListener(JobListener l) {
1:         this.jobListeners.remove(l);
1:     }
1: 
1:    
0:     public void schedule(final String jobId, final ByteSequence payload, final long delay) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 schedule(tx, jobId, payload, 0, delay, 0);
1:             }
0:         });
1:     }
1: 
1:    
0:     public void schedule(final String jobId, final ByteSequence payload, final long start, final long period, final int repeat) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 schedule(tx, jobId, payload, start, period, repeat);
1:             }
0:         });
1:        
1:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see org.apache.activemq.beanstalk.JobScheduler#remove(long)
1:      */
0:     public synchronized void remove(final long time) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 remove(tx, time);
1:             }
0:         });
1:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see org.apache.activemq.beanstalk.JobScheduler#remove(long,
0:      * java.lang.String)
1:      */
0:     public synchronized void remove(final long time, final String jobId) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 remove(tx, time, jobId);
1:             }
0:         });
1:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see org.apache.activemq.beanstalk.JobScheduler#remove(java.lang.String)
1:      */
0:     public synchronized void remove(final String jobId) throws IOException {
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 remove(tx, jobId);
1:             }
0:         });
1:     }
1: 
0:     public synchronized long getNextScheduleTime() throws IOException {
0:         Map.Entry<Long, List<JobLocation>> first = this.index.getFirst(this.store.getPageFile().tx());
0:         return first != null ? first.getKey() : -1l;
1:     }
1: 
0:     /*
0:      * (non-Javadoc)
0:      * @see org.apache.activemq.beanstalk.JobScheduler#getNextScheduleJobs()
1:      */
0:     public synchronized List<ByteSequence> getNextScheduleJobs() throws IOException {
0:         final List<ByteSequence> result = new ArrayList<ByteSequence>();
1: 
0:         this.store.getPageFile().tx().execute(new Transaction.Closure<IOException>() {
0:             public void execute(Transaction tx) throws IOException {
0:                 Map.Entry<Long, List<JobLocation>> first = index.getFirst(store.getPageFile().tx());
0:                 if (first != null) {
0:                     for (JobLocation jl : first.getValue()) {
0:                         ByteSequence bs = getJob(jl.getLocation());
0:                         result.add(bs);
1:                     }
1:                 }
1:             }
0:         });
0:         return result;
1:     }
1: 
0:     ByteSequence getJob(Location location) throws IllegalStateException, IOException {
0:         return this.store.getJob(location);
1:     }
1: 
0:     void schedule(Transaction tx,  String jobId, ByteSequence payload,long start, long period, int repeat)
0:             throws IOException {
0:         List<JobLocation> values = null;
0:         long startTime;
0:         long time;
0:         if (start > 0) {
0:             time = startTime = start;
0:         }else {
0:             startTime = System.currentTimeMillis();
0:             time = startTime + period;
1:         }
0:         if (this.index.containsKey(tx, time)) {
0:             values = this.index.remove(tx, time);
1:         }
0:         if (values == null) {
0:             values = new ArrayList<JobLocation>();
1:         }
1: 
0:         Location location = this.store.write(payload, false);
0:         JobLocation jobLocation = new JobLocation(location);
0:         jobLocation.setJobId(jobId);
0:         jobLocation.setPeriod(period);
0:         jobLocation.setRepeat(repeat);
0:         values.add(jobLocation);
0:         this.index.put(tx, time, values);
0:         this.store.incrementJournalCount(tx, location);
0:         poke();
1:     }
1: 
0:     void remove(Transaction tx, long time, String jobId) throws IOException {
0:         List<JobLocation> values = this.index.remove(tx, time);
0:         if (values != null) {
0:             for (int i = 0; i < values.size(); i++) {
0:                 JobLocation jl = values.get(i);
0:                 if (jl.getJobId().equals(jobId)) {
0:                     values.remove(i);
0:                     if (!values.isEmpty()) {
0:                         this.index.put(tx, time, values);
1:                     }
0:                     this.store.decrementJournalCount(tx, jl.getLocation());
0:                     break;
1:                 }
1:             }
1:         }
1:     }
1: 
0:     void remove(Transaction tx, long time) throws IOException {
0:         List<JobLocation> values = this.index.remove(tx, time);
0:         if (values != null) {
0:             for (JobLocation jl : values) {
0:                 this.store.decrementJournalCount(tx, jl.getLocation());
1:             }
1:         }
1:     }
1: 
0:     void remove(Transaction tx, String id) throws IOException {
0:         for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx); i.hasNext();) {
0:             Map.Entry<Long, List<JobLocation>> entry = i.next();
0:             List<JobLocation> values = entry.getValue();
0:             if (values != null) {
0:                 for (JobLocation jl : values) {
0:                     if (jl.getJobId().equals(id)) {
0:                         remove(tx, entry.getKey(), id);
0:                         return;
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
0:     synchronized void destroy(Transaction tx) throws IOException {
0:         for (Iterator<Map.Entry<Long, List<JobLocation>>> i = this.index.iterator(tx); i.hasNext();) {
0:             Map.Entry<Long, List<JobLocation>> entry = i.next();
0:             List<JobLocation> values = entry.getValue();
0:             if (values != null) {
0:                 for (JobLocation jl : values) {
0:                     this.store.decrementJournalCount(tx, jl.getLocation());
1:                 }
1:             }
1: 
1:         }
1:     }
1: 
0:     synchronized Map.Entry<Long, List<JobLocation>> getNextToSchedule() throws IOException {
0:         if (!this.store.isStopped() && !this.store.isStopping()) {
0:             Map.Entry<Long, List<JobLocation>> first = this.index.getFirst(this.store.getPageFile().tx());
0:             return first;
1:         }
0:         return null;
1: 
1:     }
1: 
0:     void fireJobs(List<JobLocation> list) throws IllegalStateException, IOException {
0:         for (JobLocation jl : list) {
0:             ByteSequence bs = this.store.getJob(jl.getLocation());
0:             for (JobListener l : jobListeners) {
0:                 l.scheduledJob(jl.getJobId(), bs);
1:             }
1:         }
1:     }
1: 
1:     public void run() {
1:         try {
1:             mainLoop();
1:         } catch (Throwable e) {
1:             if (this.running.get() && isStarted()) {
0:                 LOG.error(this + " Caught exception in mainloop", e);
1:             }
1:         } finally {
1:             if (running.get()) {
1:                 try {
1:                     stop();
1:                 } catch (Exception e) {
0:                     LOG.error("Failed to stop " + this);
1:                 }
1:             }
1:         }
1:     }
1: 
0:     @Override
1:     public String toString() {
0:         return "JobScheduler:" + this.name;
1:     }
1: 
1:     protected void mainLoop() {
1:         while (this.running.get()) {
1:             try {
0:                 // peek the next job
1:                 long currentTime = System.currentTimeMillis();
1: 
0:                 Map.Entry<Long, List<JobLocation>> first = getNextToSchedule();
0:                 if (first != null) {
0:                     List<JobLocation> list = new ArrayList<JobLocation>(first.getValue());
0:                     long executionTime = first.getKey();
0:                     if (executionTime <= currentTime) {
0:                         fireJobs(list);
0:                         for (JobLocation jl : list) {
0:                             int repeat = jl.getRepeat();
0:                             if (repeat != 0) {
0:                                 repeat--;
0:                                 ByteSequence payload = this.store.getJob(jl.getLocation());
0:                                 String jobId = jl.getJobId();
0:                                 long period = jl.getPeriod();
0:                                 schedule(jobId, payload,0, period, repeat);
1:                             }
1:                         }
0:                         // now remove jobs from this execution time
0:                         remove(executionTime);
0:                     } else {
0:                         long waitTime = executionTime - currentTime;
0:                         synchronized (this.running) {
0:                             this.running.wait(waitTime);
1:                         }
1:                     }
0:                 } else {
0:                     synchronized (this.running) {
0:                         this.running.wait(250);
1:                     }
1:                 }
1: 
0:             } catch (InterruptedException e) {
0:             } catch (IOException ioe) {
0:                 LOG.error(this.name + " Failed to schedule job", ioe);
1:                 try {
1:                     this.store.stop();
1:                 } catch (Exception e) {
0:                     LOG.error(this.name + " Failed to shutdown JobSchedulerStore", e);
1:                 }
1:             }
1:         }
1:     }
1: 
0:     @Override
1:     protected void doStart() throws Exception {
1:         this.running.set(true);
0:         this.thread = new Thread(this, "JobScheduler:" + this.name);
0:         this.thread.setDaemon(true);
0:         this.thread.start();
1: 
1:     }
1: 
0:     @Override
1:     protected void doStop(ServiceStopper stopper) throws Exception {
1:         this.running.set(false);
0:         poke();
0:         Thread t = this.thread;
0:         if (t != null) {
0:             t.join(1000);
1:         }
1: 
1:     }
1: 
0:     protected void poke() {
0:         synchronized (this.running) {
0:             this.running.notifyAll();
1:         }
1:     }
1: 
1:     void createIndexes(Transaction tx) throws IOException {
0:         this.index = new BTreeIndex<Long, List<JobLocation>>(this.store.getPageFile(), tx.allocate().getPageId());
1:     }
1: 
1:     void load(Transaction tx) throws IOException {
1:         this.index.setKeyMarshaller(LongMarshaller.INSTANCE);
0:         this.index.setValueMarshaller(ValueMarshaller.INSTANCE);
1:         this.index.load(tx);
1:     }
1: 
1:     void read(DataInput in) throws IOException {
1:         this.name = in.readUTF();
0:         this.index = new BTreeIndex<Long, List<JobLocation>>(this.store.getPageFile(), in.readLong());
1:         this.index.setKeyMarshaller(LongMarshaller.INSTANCE);
0:         this.index.setValueMarshaller(ValueMarshaller.INSTANCE);
1:     }
1: 
1:     public void write(DataOutput out) throws IOException {
1:         out.writeUTF(name);
1:         out.writeLong(this.index.getPageId());
1:     }
1: 
0:     static class ValueMarshaller extends VariableMarshaller<List<JobLocation>> {
0:         static ValueMarshaller INSTANCE = new ValueMarshaller();
0:         public List<JobLocation> readPayload(DataInput dataIn) throws IOException {
0:             List<JobLocation> result = new ArrayList<JobLocation>();
0:             int size = dataIn.readInt();
0:             for (int i = 0; i < size; i++) {
0:                 JobLocation jobLocation = new JobLocation();
0:                 jobLocation.readExternal(dataIn);
0:                 result.add(jobLocation);
1:             }
0:             return result;
1:         }
1: 
0:         public void writePayload(List<JobLocation> value, DataOutput dataOut) throws IOException {
0:             dataOut.writeInt(value.size());
0:             for (JobLocation jobLocation : value) {
0:                 jobLocation.writeExternal(dataOut);
1:             }
1:         }
1:     }
1: 
1:  
1: 
1: }
============================================================================