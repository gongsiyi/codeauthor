1:86e2426: /**
1:86e2426:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:86e2426:  * contributor license agreements.  See the NOTICE file distributed with
1:86e2426:  * this work for additional information regarding copyright ownership.
1:86e2426:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:86e2426:  * (the "License"); you may not use this file except in compliance with
1:86e2426:  * the License.  You may obtain a copy of the License at
1:86e2426:  *
1:86e2426:  *      http://www.apache.org/licenses/LICENSE-2.0
1:86e2426:  *
1:86e2426:  * Unless required by applicable law or agreed to in writing, software
1:86e2426:  * distributed under the License is distributed on an "AS IS" BASIS,
1:86e2426:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:86e2426:  * See the License for the specific language governing permissions and
1:86e2426:  * limitations under the License.
1:86e2426:  */
1:86e2426: package org.apache.activemq.leveldb.replicated.groups;
1:86e2426: 
1:86e2426: import java.io.UnsupportedEncodingException;
1:86e2426: import java.lang.reflect.Field;
1:86e2426: import java.lang.reflect.Method;
1:86e2426: import java.util.*;
1:86e2426: import java.util.concurrent.BlockingQueue;
1:86e2426: import java.util.concurrent.CopyOnWriteArrayList;
1:86e2426: import java.util.concurrent.LinkedBlockingQueue;
1:86e2426: import java.util.concurrent.TimeoutException;
1:86e2426: import java.util.concurrent.atomic.AtomicBoolean;
1:86e2426: 
1:86e2426: import org.apache.zookeeper.CreateMode;
1:86e2426: import org.apache.zookeeper.KeeperException;
1:86e2426: import org.apache.zookeeper.WatchedEvent;
1:86e2426: import org.apache.zookeeper.Watcher;
1:86e2426: import org.apache.zookeeper.ZooDefs;
1:86e2426: import org.apache.zookeeper.data.ACL;
1:86e2426: import org.apache.zookeeper.data.Id;
1:86e2426: import org.apache.zookeeper.data.Stat;
1:86e2426: import org.linkedin.util.clock.Clock;
1:86e2426: import org.linkedin.util.clock.SystemClock;
1:86e2426: import org.linkedin.util.clock.Timespan;
1:86e2426: import org.linkedin.util.concurrent.ConcurrentUtils;
1:86e2426: import org.linkedin.util.io.PathUtils;
1:86e2426: import org.linkedin.zookeeper.client.ChrootedZKClient;
1:86e2426: import org.linkedin.zookeeper.client.IZooKeeper;
1:86e2426: import org.linkedin.zookeeper.client.IZooKeeperFactory;
1:86e2426: import org.linkedin.zookeeper.client.LifecycleListener;
1:86e2426: import org.linkedin.zookeeper.client.ZooKeeperFactory;
1:86e2426: import org.osgi.framework.InvalidSyntaxException;
1:86e2426: import org.osgi.service.cm.ConfigurationException;
1:86e2426: import org.slf4j.Logger;
1:86e2426: 
1:86e2426: public class ZKClient extends org.linkedin.zookeeper.client.AbstractZKClient implements Watcher {
1:86e2426: 
1:86e2426:     private static final Logger LOG = org.slf4j.LoggerFactory.getLogger(ZKClient.class.getName());
1:86e2426: 
1:86e2426:     private Map<String, String> acls;
1:86e2426:     private String password;
1:86e2426: 
1:86e2426: 
1:86e2426:     public void start() throws Exception {
1:86e2426:         // Grab the lock to make sure that the registration of the ManagedService
1:86e2426:         // won't be updated immediately but that the initial update will happen first
1:86e2426:         synchronized (_lock) {
1:86e2426:             _stateChangeDispatcher.setDaemon(true);
1:86e2426:             _stateChangeDispatcher.start();
1:86e2426: 
1:86e2426:             doStart();
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void setACLs(Map<String, String> acls) {
1:86e2426:         this.acls = acls;
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void setPassword(String password) {
1:86e2426:         this.password = password;
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected void doStart() throws InvalidSyntaxException, ConfigurationException, UnsupportedEncodingException {
1:86e2426:         connect();
1:86e2426:     }
1:86e2426: 
1:86e2426:     @Override
1:86e2426:     public void close() {
1:86e2426:         if (_stateChangeDispatcher != null) {
1:86e2426:             _stateChangeDispatcher.end();
1:86e2426:             try {
1:86e2426:                 _stateChangeDispatcher.join(1000);
1:86e2426:             } catch(Exception e) {
1:86e2426:                 LOG.debug("ignored exception", e);
1:86e2426:             }
1:86e2426:         }
1:86e2426:         synchronized(_lock) {
1:86e2426:             if (_zk != null) {
1:86e2426:                 try {
1:86e2426:                     changeState(State.NONE);
1:86e2426:                     _zk.close();
1:86e2426:                     // We try to avoid a NPE when shutting down fabric:
1:86e2426:                     // java.lang.NullPointerException
1:86e2426:                     //     at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1433)
1:86e2426:                     //     at org.apache.felix.framework.BundleWiringImpl.access$400(BundleWiringImpl.java:73)
1:86e2426:                     //     at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:1844)
1:86e2426:                     //     at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
1:86e2426:                     //     at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1089)
1:86e2426:                     Thread th = getSendThread();
1:86e2426:                     if (th != null) {
1:86e2426:                         th.join(1000);
1:86e2426:                     }
1:86e2426:                     _zk = null;
1:86e2426:                 } catch(Exception e) {
1:86e2426:                     LOG.debug("ignored exception", e);
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected Thread getSendThread() {
1:86e2426:         try {
1:86e2426:             return (Thread) getField(_zk, "_zk", "cnxn", "sendThread");
1:86e2426:         } catch (Throwable e) {
1:86e2426:             return null;
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected Object getField(Object obj, String... names) throws Exception {
1:86e2426:         for (String name : names) {
1:86e2426:             obj = getField(obj, name);
1:86e2426:         }
1:86e2426:         return obj;
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected Object getField(Object obj, String name) throws Exception {
1:86e2426:         Class clazz = obj.getClass();
1:86e2426:         while (clazz != null) {
1:86e2426:             for (Field f : clazz.getDeclaredFields()) {
1:86e2426:                 if (f.getName().equals(name)) {
1:86e2426:                     f.setAccessible(true);
1:86e2426:                     return f.get(obj);
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:         throw new NoSuchFieldError(name);
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected void changeState(State newState) {
1:86e2426:         synchronized (_lock) {
1:86e2426:             State oldState = _state;
1:86e2426:             if (oldState != newState) {
1:86e2426:                 _stateChangeDispatcher.addEvent(oldState, newState);
1:86e2426:                 _state = newState;
1:86e2426:                 _lock.notifyAll();
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void testGenerateConnectionLoss() throws Exception {
1:86e2426:         waitForConnected();
1:86e2426:         Object clientCnxnSocket  = getField(_zk, "_zk", "cnxn", "sendThread", "clientCnxnSocket");
1:86e2426:         callMethod(clientCnxnSocket, "testableCloseSocket");
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected Object callMethod(Object obj, String name, Object... args) throws Exception {
1:86e2426:         Class clazz = obj.getClass();
1:86e2426:         while (clazz != null) {
1:86e2426:             for (Method m : clazz.getDeclaredMethods()) {
1:86e2426:                 if (m.getName().equals(name)) {
1:86e2426:                     m.setAccessible(true);
1:86e2426:                     return m.invoke(obj, args);
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:         throw new NoSuchMethodError(name);
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected void tryConnect() {
1:86e2426:         synchronized (_lock) {
1:86e2426:             try {
1:86e2426:                 connect();
1:86e2426:             } catch (Throwable e) {
1:86e2426:                 LOG.warn("Error while restarting:", e);
1:86e2426:                 if (_expiredSessionRecovery == null) {
1:86e2426:                     _expiredSessionRecovery = new ExpiredSessionRecovery();
1:86e2426:                     _expiredSessionRecovery.setDaemon(true);
1:86e2426:                     _expiredSessionRecovery.start();
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void connect() throws UnsupportedEncodingException {
1:86e2426:         synchronized (_lock) {
1:86e2426:             changeState(State.CONNECTING);
1:86e2426:             _zk = _factory.createZooKeeper(this);
1:86e2426:             if (password != null) {
1:86e2426:                 _zk.addAuthInfo("digest", ("fabric:" + password).getBytes("UTF-8"));
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void process(WatchedEvent event) {
1:86e2426:         if (event.getState() != null) {
1:86e2426:             LOG.debug("event: {}", event.getState());
1:86e2426:             synchronized (_lock) {
1:86e2426:                 switch(event.getState())
1:86e2426:                 {
1:86e2426:                     case SyncConnected:
1:86e2426:                         changeState(State.CONNECTED);
1:86e2426:                         break;
1:86e2426: 
1:86e2426:                     case Disconnected:
1:86e2426:                         if(_state != State.NONE) {
1:86e2426:                             changeState(State.RECONNECTING);
1:86e2426:                         }
1:86e2426:                         break;
1:86e2426: 
1:86e2426:                     case Expired:
1:86e2426:                         // when expired, the zookeeper object is invalid and we need to recreate a new one
1:86e2426:                         _zk = null;
1:86e2426:                         LOG.warn("Expiration detected: trying to restart...");
1:86e2426:                         tryConnect();
1:86e2426:                         break;
1:86e2426:                     default:
1:86e2426:                         LOG.warn("unprocessed event state: {}", event.getState());
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     @Override
1:86e2426:     protected IZooKeeper getZk() {
1:86e2426:         State state = _state;
1:86e2426:         if (state == State.NONE) {
1:86e2426:             throw new IllegalStateException("ZooKeeper client has not been configured yet. You need to either create an ensemble or join one.");
1:86e2426:         } else if (state != State.CONNECTED) {
1:86e2426:             try {
1:86e2426:                 waitForConnected();
1:86e2426:             } catch (Exception e) {
1:86e2426:                 throw new IllegalStateException("Error waiting for ZooKeeper connection", e);
1:86e2426:             }
1:86e2426:         }
1:86e2426:         IZooKeeper zk = _zk;
1:86e2426:         if (zk == null) {
1:86e2426:             throw new IllegalStateException("No ZooKeeper connection available");
1:86e2426:         }
1:86e2426:         return zk;
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void waitForConnected(Timespan timeout) throws InterruptedException, TimeoutException {
1:86e2426:         waitForState(State.CONNECTED, timeout);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void waitForConnected() throws InterruptedException, TimeoutException {
1:86e2426:         waitForConnected(null);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void waitForState(State state, Timespan timeout) throws TimeoutException, InterruptedException {
1:86e2426:         long endTime = (timeout == null ? sessionTimeout : timeout).futureTimeMillis(_clock);
1:86e2426:         if (_state != state) {
1:86e2426:             synchronized (_lock) {
1:86e2426:                 while (_state != state) {
1:86e2426:                     ConcurrentUtils.awaitUntil(_clock, _lock, endTime);
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     @Override
1:86e2426:     public void registerListener(LifecycleListener listener) {
1:86e2426:         if (listener == null) {
1:86e2426:             throw new IllegalStateException("listener is null");
1:86e2426:         }
1:86e2426:         if (!_listeners.contains(listener)) {
1:86e2426:             _listeners.add(listener);
1:86e2426: 
1:86e2426:         }
1:86e2426:         if (_state == State.CONNECTED) {
1:86e2426:             listener.onConnected();
1:86e2426:             //_stateChangeDispatcher.addEvent(null, State.CONNECTED);
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     @Override
1:86e2426:     public void removeListener(LifecycleListener listener) {
1:86e2426:         if (listener == null) {
1:86e2426:             throw new IllegalStateException("listener is null");
1:86e2426:         }
1:86e2426:         _listeners.remove(listener);
1:86e2426:     }
1:86e2426: 
1:86e2426:     @Override
1:86e2426:     public org.linkedin.zookeeper.client.IZKClient chroot(String path) {
1:86e2426:         return new ChrootedZKClient(this, adjustPath(path));
1:86e2426:     }
1:86e2426: 
1:86e2426:     @Override
1:86e2426:     public boolean isConnected() {
1:86e2426:         return _state == State.CONNECTED;
1:86e2426:     }
1:86e2426: 
1:86e2426:     public boolean isConfigured() {
1:86e2426:         return _state != State.NONE;
1:86e2426:     }
1:86e2426: 
1:86e2426:     @Override
1:86e2426:     public String getConnectString() {
1:86e2426:         return _factory.getConnectString();
1:86e2426:     }
1:86e2426: 
1:86e2426:     public static enum State {
1:86e2426:         NONE,
1:86e2426:         CONNECTING,
1:86e2426:         CONNECTED,
1:86e2426:         RECONNECTING
1:86e2426:     }
1:86e2426: 
1:86e2426:     private final static String CHARSET = "UTF-8";
1:86e2426: 
1:86e2426:     private final Clock _clock = SystemClock.instance();
1:86e2426:     private final List<LifecycleListener> _listeners = new CopyOnWriteArrayList<LifecycleListener>();
1:86e2426: 
1:86e2426:     protected final Object _lock = new Object();
1:86e2426:     protected volatile State _state = State.NONE;
1:86e2426: 
1:86e2426:     private final StateChangeDispatcher _stateChangeDispatcher = new StateChangeDispatcher();
1:86e2426: 
1:86e2426:     protected IZooKeeperFactory _factory;
1:86e2426:     protected IZooKeeper _zk;
1:86e2426:     protected Timespan _reconnectTimeout = Timespan.parse("20s");
1:86e2426:     protected Timespan sessionTimeout = new Timespan(30, Timespan.TimeUnit.SECOND);
1:86e2426: 
1:86e2426:     private ExpiredSessionRecovery _expiredSessionRecovery = null;
1:86e2426: 
1:86e2426:     private class StateChangeDispatcher extends Thread {
1:86e2426:         private final AtomicBoolean _running = new AtomicBoolean(true);
1:86e2426:         private final BlockingQueue<Boolean> _events = new LinkedBlockingQueue<Boolean>();
1:86e2426: 
1:86e2426:         private StateChangeDispatcher() {
1:86e2426:             super("ZooKeeper state change dispatcher thread");
1:86e2426:         }
1:86e2426: 
1:86e2426:         @Override
1:86e2426:         public void run() {
1:86e2426:             Map<Object, Boolean> history = new IdentityHashMap<Object, Boolean>();
1:86e2426:             LOG.info("Starting StateChangeDispatcher");
1:86e2426:             while (_running.get()) {
1:86e2426:                 Boolean isConnectedEvent;
1:86e2426:                 try {
1:86e2426:                     isConnectedEvent = _events.take();
1:86e2426:                 } catch (InterruptedException e) {
1:86e2426:                     continue;
1:86e2426:                 }
1:86e2426:                 if (!_running.get() || isConnectedEvent == null) {
1:86e2426:                     continue;
1:86e2426:                 }
1:86e2426:                 Map<Object, Boolean> newHistory = callListeners(history, isConnectedEvent);
1:86e2426:                 // we save which event each listener has seen last
1:86e2426:                 // we don't update the map in place because we need to get rid of unregistered listeners
1:86e2426:                 history = newHistory;
1:86e2426:             }
1:86e2426:             LOG.info("StateChangeDispatcher terminated.");
1:86e2426:         }
1:86e2426: 
1:86e2426:         public void end() {
1:86e2426:             _running.set(false);
1:86e2426:             _events.add(false);
1:86e2426:         }
1:86e2426: 
1:86e2426:         public void addEvent(ZKClient.State oldState, ZKClient.State newState) {
1:86e2426:             LOG.debug("addEvent: {} => {}", oldState, newState);
1:86e2426:             if (newState == ZKClient.State.CONNECTED) {
1:86e2426:                 _events.add(true);
1:86e2426:             } else if (oldState == ZKClient.State.CONNECTED) {
1:86e2426:                 _events.add(false);
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected Map<Object, Boolean> callListeners(Map<Object, Boolean> history, Boolean connectedEvent) {
1:86e2426:         Map<Object, Boolean> newHistory = new IdentityHashMap<Object, Boolean>();
1:86e2426:         for (LifecycleListener listener : _listeners) {
1:86e2426:             Boolean previousEvent = history.get(listener);
1:86e2426:             // we propagate the event only if it was not already sent
1:86e2426:             if (previousEvent == null || previousEvent != connectedEvent) {
1:86e2426:                 try {
1:86e2426:                     if (connectedEvent) {
1:86e2426:                         listener.onConnected();
1:86e2426:                     } else {
1:86e2426:                         listener.onDisconnected();
1:86e2426:                     }
1:86e2426:                 } catch (Throwable e) {
1:86e2426:                     LOG.warn("Exception while executing listener (ignored)", e);
1:86e2426:                 }
1:86e2426:             }
1:86e2426:             newHistory.put(listener, connectedEvent);
1:86e2426:         }
1:86e2426:         return newHistory;
1:86e2426:     }
1:86e2426: 
1:86e2426:     private class ExpiredSessionRecovery extends Thread {
1:86e2426:         private ExpiredSessionRecovery() {
1:86e2426:             super("ZooKeeper expired session recovery thread");
1:86e2426:         }
1:86e2426: 
1:86e2426:         @Override
1:86e2426:         public void run() {
1:86e2426:             LOG.info("Entering recovery mode");
1:86e2426:             synchronized(_lock) {
1:86e2426:                 try {
1:86e2426:                     int count = 0;
1:86e2426:                     while (_state == ZKClient.State.NONE) {
1:86e2426:                         try {
1:86e2426:                             count++;
1:86e2426:                             LOG.warn("Recovery mode: trying to reconnect to zookeeper [" + count + "]");
1:86e2426:                             ZKClient.this.connect();
1:86e2426:                         } catch (Throwable e) {
1:86e2426:                             LOG.warn("Recovery mode: reconnect attempt failed [" + count + "]... waiting for " + _reconnectTimeout, e);
1:86e2426:                             try {
1:86e2426:                                 _lock.wait(_reconnectTimeout.getDurationInMilliseconds());
1:86e2426:                             } catch(InterruptedException e1) {
1:86e2426:                                 throw new RuntimeException("Recovery mode: wait interrupted... bailing out", e1);
1:86e2426:                             }
1:86e2426:                         }
1:86e2426:                     }
1:86e2426:                 } finally {
1:86e2426:                     _expiredSessionRecovery = null;
1:86e2426:                     LOG.info("Exiting recovery mode.");
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     /**
1:86e2426:      * Constructor
1:86e2426:      */
1:86e2426:     public ZKClient(String connectString, Timespan sessionTimeout, Watcher watcher)
1:86e2426:     {
1:86e2426:         this(new ZooKeeperFactory(connectString, sessionTimeout, watcher));
1:86e2426:     }
1:86e2426: 
1:86e2426:     /**
1:86e2426:      * Constructor
1:86e2426:      */
1:86e2426:     public ZKClient(IZooKeeperFactory factory)
1:86e2426:     {
1:86e2426:         this(factory, null);
1:86e2426:     }
1:86e2426: 
1:86e2426:     /**
1:86e2426:      * Constructor
1:86e2426:      */
1:86e2426:     public ZKClient(IZooKeeperFactory factory, String chroot)
1:86e2426:     {
1:86e2426:         super(chroot);
1:86e2426:         _factory = factory;
1:86e2426:         Map<String, String> acls = new HashMap<String, String>();
1:86e2426:         acls.put("/", "world:anyone:acdrw");
1:86e2426:         setACLs(acls);
1:86e2426:     }
1:86e2426: 
1:86e2426:     static private int getPermFromString(String permString) {
1:86e2426:         int perm = 0;
1:86e2426:         for (int i = 0; i < permString.length(); i++) {
1:86e2426:             switch (permString.charAt(i)) {
1:86e2426:                 case 'r':
1:86e2426:                     perm |= ZooDefs.Perms.READ;
1:86e2426:                     break;
1:86e2426:                 case 'w':
1:86e2426:                     perm |= ZooDefs.Perms.WRITE;
1:86e2426:                     break;
1:86e2426:                 case 'c':
1:86e2426:                     perm |= ZooDefs.Perms.CREATE;
1:86e2426:                     break;
1:86e2426:                 case 'd':
1:86e2426:                     perm |= ZooDefs.Perms.DELETE;
1:86e2426:                     break;
1:86e2426:                 case 'a':
1:86e2426:                     perm |= ZooDefs.Perms.ADMIN;
1:86e2426:                     break;
1:86e2426:                 default:
1:86e2426:                     System.err
1:86e2426:                             .println("Unknown perm type: " + permString.charAt(i));
1:86e2426:             }
1:86e2426:         }
1:86e2426:         return perm;
1:86e2426:     }
1:86e2426: 
1:86e2426:     private static List<ACL> parseACLs(String aclString) {
1:86e2426:         List<ACL> acl;
1:86e2426:         String acls[] = aclString.split(",");
1:86e2426:         acl = new ArrayList<ACL>();
1:86e2426:         for (String a : acls) {
1:86e2426:             int firstColon = a.indexOf(':');
1:86e2426:             int lastColon = a.lastIndexOf(':');
1:86e2426:             if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {
1:86e2426:                 System.err
1:86e2426:                         .println(a + " does not have the form scheme:id:perm");
1:86e2426:                 continue;
1:86e2426:             }
1:86e2426:             ACL newAcl = new ACL();
1:86e2426:             newAcl.setId(new Id(a.substring(0, firstColon), a.substring(
1:86e2426:                     firstColon + 1, lastColon)));
1:86e2426:             newAcl.setPerms(getPermFromString(a.substring(lastColon + 1)));
1:86e2426:             acl.add(newAcl);
1:86e2426:         }
1:86e2426:         return acl;
1:86e2426:     }
1:86e2426: 
1:86e2426:     public Stat createOrSetByteWithParents(String path, byte[] data, List<ACL> acl, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         if (exists(path) != null) {
1:86e2426:             return setByteData(path, data);
1:86e2426:         }
1:86e2426:         try {
1:86e2426:             createBytesNodeWithParents(path, data, acl, createMode);
1:86e2426:             return null;
1:86e2426:         } catch(KeeperException.NodeExistsException e) {
1:86e2426:             // this should not happen very often (race condition)
1:86e2426:             return setByteData(path, data);
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     public String create(String path, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         return create(path, (byte[]) null, createMode);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public String create(String path, String data, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         return create(path, toByteData(data), createMode);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public String create(String path, byte[] data, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         return getZk().create(adjustPath(path), data, getNodeACLs(path), createMode);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public String createWithParents(String path, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         return createWithParents(path, (byte[]) null, createMode);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public String createWithParents(String path, String data, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         return createWithParents(path, toByteData(data), createMode);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public String createWithParents(String path, byte[] data, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         createParents(path);
1:86e2426:         return create(path, data, createMode);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public Stat createOrSetWithParents(String path, String data, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         return createOrSetWithParents(path, toByteData(data), createMode);
1:86e2426:     }
1:86e2426: 
1:86e2426:     public Stat createOrSetWithParents(String path, byte[] data, CreateMode createMode) throws InterruptedException, KeeperException {
1:86e2426:         if (exists(path) != null) {
1:86e2426:             return setByteData(path, data);
1:86e2426:         }
1:86e2426:         try {
1:86e2426:             createWithParents(path, data, createMode);
1:86e2426:             return null;
1:86e2426:         } catch (KeeperException.NodeExistsException e) {
1:86e2426:             // this should not happen very often (race condition)
1:86e2426:             return setByteData(path, data);
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     public void fixACLs(String path, boolean recursive) throws InterruptedException, KeeperException {
1:86e2426:         if (exists(path) != null) {
1:86e2426:             doFixACLs(path, recursive);
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     private void doFixACLs(String path, boolean recursive) throws KeeperException, InterruptedException {
1:86e2426:         setACL(path, getNodeACLs(path), -1);
1:86e2426:         if (recursive) {
1:86e2426:             for (String child : getChildren(path)) {
1:86e2426:                 doFixACLs(path.equals("/") ? "/" + child : path + "/" + child, recursive);
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     private List<ACL> getNodeACLs(String path) {
1:86e2426:         String acl = doGetNodeACLs(adjustPath(path));
1:86e2426:         if (acl == null) {
1:86e2426:             throw new IllegalStateException("Could not find matching ACLs for " + path);
1:86e2426:         }
1:86e2426:         return parseACLs(acl);
1:86e2426:     }
1:86e2426: 
1:86e2426:     protected String doGetNodeACLs(String path) {
1:86e2426:         String longestPath = "";
1:86e2426:         for (String acl : acls.keySet()) {
1:86e2426:             if (acl.length() > longestPath.length() && path.startsWith(acl)) {
1:86e2426:                 longestPath = acl;
1:86e2426:             }
1:86e2426:         }
1:86e2426:         return acls.get(longestPath);
1:86e2426:     }
1:86e2426: 
1:86e2426:     private void createParents(String path) throws InterruptedException, KeeperException {
1:86e2426:         path = PathUtils.getParentPath(adjustPath(path));
1:86e2426:         path = PathUtils.removeTrailingSlash(path);
1:86e2426:         List<String> paths = new ArrayList<String>();
1:86e2426:         while(!path.equals("") && getZk().exists(path, false) == null) {
1:86e2426:             paths.add(path);
1:86e2426:             path = PathUtils.getParentPath(path);
1:86e2426:             path = PathUtils.removeTrailingSlash(path);
1:86e2426:         }
1:86e2426:         Collections.reverse(paths);
1:86e2426:         for(String p : paths) {
1:86e2426:             try {
1:86e2426:                 getZk().create(p,
1:86e2426:                         null,
1:86e2426:                         getNodeACLs(p),
1:86e2426:                         CreateMode.PERSISTENT);
1:86e2426:             } catch(KeeperException.NodeExistsException e) {
1:86e2426:                 // ok we continue...
1:86e2426:                 if (LOG.isDebugEnabled()) {
1:86e2426:                     LOG.debug("parent already exists " + p);
1:86e2426:                 }
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: 
1:86e2426:     private byte[] toByteData(String data) {
1:86e2426:         if (data == null) {
1:86e2426:             return null;
1:86e2426:         } else {
1:86e2426:             try {
1:86e2426:                 return data.getBytes(CHARSET);
1:86e2426:             } catch(UnsupportedEncodingException e) {
1:86e2426:                 throw new RuntimeException(e);
1:86e2426:             }
1:86e2426:         }
1:86e2426:     }
1:86e2426: }
============================================================================
author:Hiram R. Chirino
-------------------------------------------------------------------------------
commit:86e2426
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *      http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, software
1:  * distributed under the License is distributed on an "AS IS" BASIS,
1:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  * See the License for the specific language governing permissions and
1:  * limitations under the License.
1:  */
1: package org.apache.activemq.leveldb.replicated.groups;
1: 
1: import java.io.UnsupportedEncodingException;
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Method;
1: import java.util.*;
1: import java.util.concurrent.BlockingQueue;
1: import java.util.concurrent.CopyOnWriteArrayList;
1: import java.util.concurrent.LinkedBlockingQueue;
1: import java.util.concurrent.TimeoutException;
1: import java.util.concurrent.atomic.AtomicBoolean;
1: 
1: import org.apache.zookeeper.CreateMode;
1: import org.apache.zookeeper.KeeperException;
1: import org.apache.zookeeper.WatchedEvent;
1: import org.apache.zookeeper.Watcher;
1: import org.apache.zookeeper.ZooDefs;
1: import org.apache.zookeeper.data.ACL;
1: import org.apache.zookeeper.data.Id;
1: import org.apache.zookeeper.data.Stat;
1: import org.linkedin.util.clock.Clock;
1: import org.linkedin.util.clock.SystemClock;
1: import org.linkedin.util.clock.Timespan;
1: import org.linkedin.util.concurrent.ConcurrentUtils;
1: import org.linkedin.util.io.PathUtils;
1: import org.linkedin.zookeeper.client.ChrootedZKClient;
1: import org.linkedin.zookeeper.client.IZooKeeper;
1: import org.linkedin.zookeeper.client.IZooKeeperFactory;
1: import org.linkedin.zookeeper.client.LifecycleListener;
1: import org.linkedin.zookeeper.client.ZooKeeperFactory;
1: import org.osgi.framework.InvalidSyntaxException;
1: import org.osgi.service.cm.ConfigurationException;
1: import org.slf4j.Logger;
1: 
1: public class ZKClient extends org.linkedin.zookeeper.client.AbstractZKClient implements Watcher {
1: 
1:     private static final Logger LOG = org.slf4j.LoggerFactory.getLogger(ZKClient.class.getName());
1: 
1:     private Map<String, String> acls;
1:     private String password;
1: 
1: 
1:     public void start() throws Exception {
1:         // Grab the lock to make sure that the registration of the ManagedService
1:         // won't be updated immediately but that the initial update will happen first
1:         synchronized (_lock) {
1:             _stateChangeDispatcher.setDaemon(true);
1:             _stateChangeDispatcher.start();
1: 
1:             doStart();
1:         }
1:     }
1: 
1:     public void setACLs(Map<String, String> acls) {
1:         this.acls = acls;
1:     }
1: 
1:     public void setPassword(String password) {
1:         this.password = password;
1:     }
1: 
1:     protected void doStart() throws InvalidSyntaxException, ConfigurationException, UnsupportedEncodingException {
1:         connect();
1:     }
1: 
1:     @Override
1:     public void close() {
1:         if (_stateChangeDispatcher != null) {
1:             _stateChangeDispatcher.end();
1:             try {
1:                 _stateChangeDispatcher.join(1000);
1:             } catch(Exception e) {
1:                 LOG.debug("ignored exception", e);
1:             }
1:         }
1:         synchronized(_lock) {
1:             if (_zk != null) {
1:                 try {
1:                     changeState(State.NONE);
1:                     _zk.close();
1:                     // We try to avoid a NPE when shutting down fabric:
1:                     // java.lang.NullPointerException
1:                     //     at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1433)
1:                     //     at org.apache.felix.framework.BundleWiringImpl.access$400(BundleWiringImpl.java:73)
1:                     //     at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:1844)
1:                     //     at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
1:                     //     at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1089)
1:                     Thread th = getSendThread();
1:                     if (th != null) {
1:                         th.join(1000);
1:                     }
1:                     _zk = null;
1:                 } catch(Exception e) {
1:                     LOG.debug("ignored exception", e);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     protected Thread getSendThread() {
1:         try {
1:             return (Thread) getField(_zk, "_zk", "cnxn", "sendThread");
1:         } catch (Throwable e) {
1:             return null;
1:         }
1:     }
1: 
1:     protected Object getField(Object obj, String... names) throws Exception {
1:         for (String name : names) {
1:             obj = getField(obj, name);
1:         }
1:         return obj;
1:     }
1: 
1:     protected Object getField(Object obj, String name) throws Exception {
1:         Class clazz = obj.getClass();
1:         while (clazz != null) {
1:             for (Field f : clazz.getDeclaredFields()) {
1:                 if (f.getName().equals(name)) {
1:                     f.setAccessible(true);
1:                     return f.get(obj);
1:                 }
1:             }
1:         }
1:         throw new NoSuchFieldError(name);
1:     }
1: 
1:     protected void changeState(State newState) {
1:         synchronized (_lock) {
1:             State oldState = _state;
1:             if (oldState != newState) {
1:                 _stateChangeDispatcher.addEvent(oldState, newState);
1:                 _state = newState;
1:                 _lock.notifyAll();
1:             }
1:         }
1:     }
1: 
1:     public void testGenerateConnectionLoss() throws Exception {
1:         waitForConnected();
1:         Object clientCnxnSocket  = getField(_zk, "_zk", "cnxn", "sendThread", "clientCnxnSocket");
1:         callMethod(clientCnxnSocket, "testableCloseSocket");
1:     }
1: 
1:     protected Object callMethod(Object obj, String name, Object... args) throws Exception {
1:         Class clazz = obj.getClass();
1:         while (clazz != null) {
1:             for (Method m : clazz.getDeclaredMethods()) {
1:                 if (m.getName().equals(name)) {
1:                     m.setAccessible(true);
1:                     return m.invoke(obj, args);
1:                 }
1:             }
1:         }
1:         throw new NoSuchMethodError(name);
1:     }
1: 
1:     protected void tryConnect() {
1:         synchronized (_lock) {
1:             try {
1:                 connect();
1:             } catch (Throwable e) {
1:                 LOG.warn("Error while restarting:", e);
1:                 if (_expiredSessionRecovery == null) {
1:                     _expiredSessionRecovery = new ExpiredSessionRecovery();
1:                     _expiredSessionRecovery.setDaemon(true);
1:                     _expiredSessionRecovery.start();
1:                 }
1:             }
1:         }
1:     }
1: 
1:     public void connect() throws UnsupportedEncodingException {
1:         synchronized (_lock) {
1:             changeState(State.CONNECTING);
1:             _zk = _factory.createZooKeeper(this);
1:             if (password != null) {
1:                 _zk.addAuthInfo("digest", ("fabric:" + password).getBytes("UTF-8"));
1:             }
1:         }
1:     }
1: 
1:     public void process(WatchedEvent event) {
1:         if (event.getState() != null) {
1:             LOG.debug("event: {}", event.getState());
1:             synchronized (_lock) {
1:                 switch(event.getState())
1:                 {
1:                     case SyncConnected:
1:                         changeState(State.CONNECTED);
1:                         break;
1: 
1:                     case Disconnected:
1:                         if(_state != State.NONE) {
1:                             changeState(State.RECONNECTING);
1:                         }
1:                         break;
1: 
1:                     case Expired:
1:                         // when expired, the zookeeper object is invalid and we need to recreate a new one
1:                         _zk = null;
1:                         LOG.warn("Expiration detected: trying to restart...");
1:                         tryConnect();
1:                         break;
1:                     default:
1:                         LOG.warn("unprocessed event state: {}", event.getState());
1:                 }
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     protected IZooKeeper getZk() {
1:         State state = _state;
1:         if (state == State.NONE) {
1:             throw new IllegalStateException("ZooKeeper client has not been configured yet. You need to either create an ensemble or join one.");
1:         } else if (state != State.CONNECTED) {
1:             try {
1:                 waitForConnected();
1:             } catch (Exception e) {
1:                 throw new IllegalStateException("Error waiting for ZooKeeper connection", e);
1:             }
1:         }
1:         IZooKeeper zk = _zk;
1:         if (zk == null) {
1:             throw new IllegalStateException("No ZooKeeper connection available");
1:         }
1:         return zk;
1:     }
1: 
1:     public void waitForConnected(Timespan timeout) throws InterruptedException, TimeoutException {
1:         waitForState(State.CONNECTED, timeout);
1:     }
1: 
1:     public void waitForConnected() throws InterruptedException, TimeoutException {
1:         waitForConnected(null);
1:     }
1: 
1:     public void waitForState(State state, Timespan timeout) throws TimeoutException, InterruptedException {
1:         long endTime = (timeout == null ? sessionTimeout : timeout).futureTimeMillis(_clock);
1:         if (_state != state) {
1:             synchronized (_lock) {
1:                 while (_state != state) {
1:                     ConcurrentUtils.awaitUntil(_clock, _lock, endTime);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     @Override
1:     public void registerListener(LifecycleListener listener) {
1:         if (listener == null) {
1:             throw new IllegalStateException("listener is null");
1:         }
1:         if (!_listeners.contains(listener)) {
1:             _listeners.add(listener);
1: 
1:         }
1:         if (_state == State.CONNECTED) {
1:             listener.onConnected();
1:             //_stateChangeDispatcher.addEvent(null, State.CONNECTED);
1:         }
1:     }
1: 
1:     @Override
1:     public void removeListener(LifecycleListener listener) {
1:         if (listener == null) {
1:             throw new IllegalStateException("listener is null");
1:         }
1:         _listeners.remove(listener);
1:     }
1: 
1:     @Override
1:     public org.linkedin.zookeeper.client.IZKClient chroot(String path) {
1:         return new ChrootedZKClient(this, adjustPath(path));
1:     }
1: 
1:     @Override
1:     public boolean isConnected() {
1:         return _state == State.CONNECTED;
1:     }
1: 
1:     public boolean isConfigured() {
1:         return _state != State.NONE;
1:     }
1: 
1:     @Override
1:     public String getConnectString() {
1:         return _factory.getConnectString();
1:     }
1: 
1:     public static enum State {
1:         NONE,
1:         CONNECTING,
1:         CONNECTED,
1:         RECONNECTING
1:     }
1: 
1:     private final static String CHARSET = "UTF-8";
1: 
1:     private final Clock _clock = SystemClock.instance();
1:     private final List<LifecycleListener> _listeners = new CopyOnWriteArrayList<LifecycleListener>();
1: 
1:     protected final Object _lock = new Object();
1:     protected volatile State _state = State.NONE;
1: 
1:     private final StateChangeDispatcher _stateChangeDispatcher = new StateChangeDispatcher();
1: 
1:     protected IZooKeeperFactory _factory;
1:     protected IZooKeeper _zk;
1:     protected Timespan _reconnectTimeout = Timespan.parse("20s");
1:     protected Timespan sessionTimeout = new Timespan(30, Timespan.TimeUnit.SECOND);
1: 
1:     private ExpiredSessionRecovery _expiredSessionRecovery = null;
1: 
1:     private class StateChangeDispatcher extends Thread {
1:         private final AtomicBoolean _running = new AtomicBoolean(true);
1:         private final BlockingQueue<Boolean> _events = new LinkedBlockingQueue<Boolean>();
1: 
1:         private StateChangeDispatcher() {
1:             super("ZooKeeper state change dispatcher thread");
1:         }
1: 
1:         @Override
1:         public void run() {
1:             Map<Object, Boolean> history = new IdentityHashMap<Object, Boolean>();
1:             LOG.info("Starting StateChangeDispatcher");
1:             while (_running.get()) {
1:                 Boolean isConnectedEvent;
1:                 try {
1:                     isConnectedEvent = _events.take();
1:                 } catch (InterruptedException e) {
1:                     continue;
1:                 }
1:                 if (!_running.get() || isConnectedEvent == null) {
1:                     continue;
1:                 }
1:                 Map<Object, Boolean> newHistory = callListeners(history, isConnectedEvent);
1:                 // we save which event each listener has seen last
1:                 // we don't update the map in place because we need to get rid of unregistered listeners
1:                 history = newHistory;
1:             }
1:             LOG.info("StateChangeDispatcher terminated.");
1:         }
1: 
1:         public void end() {
1:             _running.set(false);
1:             _events.add(false);
1:         }
1: 
1:         public void addEvent(ZKClient.State oldState, ZKClient.State newState) {
1:             LOG.debug("addEvent: {} => {}", oldState, newState);
1:             if (newState == ZKClient.State.CONNECTED) {
1:                 _events.add(true);
1:             } else if (oldState == ZKClient.State.CONNECTED) {
1:                 _events.add(false);
1:             }
1:         }
1:     }
1: 
1:     protected Map<Object, Boolean> callListeners(Map<Object, Boolean> history, Boolean connectedEvent) {
1:         Map<Object, Boolean> newHistory = new IdentityHashMap<Object, Boolean>();
1:         for (LifecycleListener listener : _listeners) {
1:             Boolean previousEvent = history.get(listener);
1:             // we propagate the event only if it was not already sent
1:             if (previousEvent == null || previousEvent != connectedEvent) {
1:                 try {
1:                     if (connectedEvent) {
1:                         listener.onConnected();
1:                     } else {
1:                         listener.onDisconnected();
1:                     }
1:                 } catch (Throwable e) {
1:                     LOG.warn("Exception while executing listener (ignored)", e);
1:                 }
1:             }
1:             newHistory.put(listener, connectedEvent);
1:         }
1:         return newHistory;
1:     }
1: 
1:     private class ExpiredSessionRecovery extends Thread {
1:         private ExpiredSessionRecovery() {
1:             super("ZooKeeper expired session recovery thread");
1:         }
1: 
1:         @Override
1:         public void run() {
1:             LOG.info("Entering recovery mode");
1:             synchronized(_lock) {
1:                 try {
1:                     int count = 0;
1:                     while (_state == ZKClient.State.NONE) {
1:                         try {
1:                             count++;
1:                             LOG.warn("Recovery mode: trying to reconnect to zookeeper [" + count + "]");
1:                             ZKClient.this.connect();
1:                         } catch (Throwable e) {
1:                             LOG.warn("Recovery mode: reconnect attempt failed [" + count + "]... waiting for " + _reconnectTimeout, e);
1:                             try {
1:                                 _lock.wait(_reconnectTimeout.getDurationInMilliseconds());
1:                             } catch(InterruptedException e1) {
1:                                 throw new RuntimeException("Recovery mode: wait interrupted... bailing out", e1);
1:                             }
1:                         }
1:                     }
1:                 } finally {
1:                     _expiredSessionRecovery = null;
1:                     LOG.info("Exiting recovery mode.");
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Constructor
1:      */
1:     public ZKClient(String connectString, Timespan sessionTimeout, Watcher watcher)
1:     {
1:         this(new ZooKeeperFactory(connectString, sessionTimeout, watcher));
1:     }
1: 
1:     /**
1:      * Constructor
1:      */
1:     public ZKClient(IZooKeeperFactory factory)
1:     {
1:         this(factory, null);
1:     }
1: 
1:     /**
1:      * Constructor
1:      */
1:     public ZKClient(IZooKeeperFactory factory, String chroot)
1:     {
1:         super(chroot);
1:         _factory = factory;
1:         Map<String, String> acls = new HashMap<String, String>();
1:         acls.put("/", "world:anyone:acdrw");
1:         setACLs(acls);
1:     }
1: 
1:     static private int getPermFromString(String permString) {
1:         int perm = 0;
1:         for (int i = 0; i < permString.length(); i++) {
1:             switch (permString.charAt(i)) {
1:                 case 'r':
1:                     perm |= ZooDefs.Perms.READ;
1:                     break;
1:                 case 'w':
1:                     perm |= ZooDefs.Perms.WRITE;
1:                     break;
1:                 case 'c':
1:                     perm |= ZooDefs.Perms.CREATE;
1:                     break;
1:                 case 'd':
1:                     perm |= ZooDefs.Perms.DELETE;
1:                     break;
1:                 case 'a':
1:                     perm |= ZooDefs.Perms.ADMIN;
1:                     break;
1:                 default:
1:                     System.err
1:                             .println("Unknown perm type: " + permString.charAt(i));
1:             }
1:         }
1:         return perm;
1:     }
1: 
1:     private static List<ACL> parseACLs(String aclString) {
1:         List<ACL> acl;
1:         String acls[] = aclString.split(",");
1:         acl = new ArrayList<ACL>();
1:         for (String a : acls) {
1:             int firstColon = a.indexOf(':');
1:             int lastColon = a.lastIndexOf(':');
1:             if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {
1:                 System.err
1:                         .println(a + " does not have the form scheme:id:perm");
1:                 continue;
1:             }
1:             ACL newAcl = new ACL();
1:             newAcl.setId(new Id(a.substring(0, firstColon), a.substring(
1:                     firstColon + 1, lastColon)));
1:             newAcl.setPerms(getPermFromString(a.substring(lastColon + 1)));
1:             acl.add(newAcl);
1:         }
1:         return acl;
1:     }
1: 
1:     public Stat createOrSetByteWithParents(String path, byte[] data, List<ACL> acl, CreateMode createMode) throws InterruptedException, KeeperException {
1:         if (exists(path) != null) {
1:             return setByteData(path, data);
1:         }
1:         try {
1:             createBytesNodeWithParents(path, data, acl, createMode);
1:             return null;
1:         } catch(KeeperException.NodeExistsException e) {
1:             // this should not happen very often (race condition)
1:             return setByteData(path, data);
1:         }
1:     }
1: 
1:     public String create(String path, CreateMode createMode) throws InterruptedException, KeeperException {
1:         return create(path, (byte[]) null, createMode);
1:     }
1: 
1:     public String create(String path, String data, CreateMode createMode) throws InterruptedException, KeeperException {
1:         return create(path, toByteData(data), createMode);
1:     }
1: 
1:     public String create(String path, byte[] data, CreateMode createMode) throws InterruptedException, KeeperException {
1:         return getZk().create(adjustPath(path), data, getNodeACLs(path), createMode);
1:     }
1: 
1:     public String createWithParents(String path, CreateMode createMode) throws InterruptedException, KeeperException {
1:         return createWithParents(path, (byte[]) null, createMode);
1:     }
1: 
1:     public String createWithParents(String path, String data, CreateMode createMode) throws InterruptedException, KeeperException {
1:         return createWithParents(path, toByteData(data), createMode);
1:     }
1: 
1:     public String createWithParents(String path, byte[] data, CreateMode createMode) throws InterruptedException, KeeperException {
1:         createParents(path);
1:         return create(path, data, createMode);
1:     }
1: 
1:     public Stat createOrSetWithParents(String path, String data, CreateMode createMode) throws InterruptedException, KeeperException {
1:         return createOrSetWithParents(path, toByteData(data), createMode);
1:     }
1: 
1:     public Stat createOrSetWithParents(String path, byte[] data, CreateMode createMode) throws InterruptedException, KeeperException {
1:         if (exists(path) != null) {
1:             return setByteData(path, data);
1:         }
1:         try {
1:             createWithParents(path, data, createMode);
1:             return null;
1:         } catch (KeeperException.NodeExistsException e) {
1:             // this should not happen very often (race condition)
1:             return setByteData(path, data);
1:         }
1:     }
1: 
1:     public void fixACLs(String path, boolean recursive) throws InterruptedException, KeeperException {
1:         if (exists(path) != null) {
1:             doFixACLs(path, recursive);
1:         }
1:     }
1: 
1:     private void doFixACLs(String path, boolean recursive) throws KeeperException, InterruptedException {
1:         setACL(path, getNodeACLs(path), -1);
1:         if (recursive) {
1:             for (String child : getChildren(path)) {
1:                 doFixACLs(path.equals("/") ? "/" + child : path + "/" + child, recursive);
1:             }
1:         }
1:     }
1: 
1:     private List<ACL> getNodeACLs(String path) {
1:         String acl = doGetNodeACLs(adjustPath(path));
1:         if (acl == null) {
1:             throw new IllegalStateException("Could not find matching ACLs for " + path);
1:         }
1:         return parseACLs(acl);
1:     }
1: 
1:     protected String doGetNodeACLs(String path) {
1:         String longestPath = "";
1:         for (String acl : acls.keySet()) {
1:             if (acl.length() > longestPath.length() && path.startsWith(acl)) {
1:                 longestPath = acl;
1:             }
1:         }
1:         return acls.get(longestPath);
1:     }
1: 
1:     private void createParents(String path) throws InterruptedException, KeeperException {
1:         path = PathUtils.getParentPath(adjustPath(path));
1:         path = PathUtils.removeTrailingSlash(path);
1:         List<String> paths = new ArrayList<String>();
1:         while(!path.equals("") && getZk().exists(path, false) == null) {
1:             paths.add(path);
1:             path = PathUtils.getParentPath(path);
1:             path = PathUtils.removeTrailingSlash(path);
1:         }
1:         Collections.reverse(paths);
1:         for(String p : paths) {
1:             try {
1:                 getZk().create(p,
1:                         null,
1:                         getNodeACLs(p),
1:                         CreateMode.PERSISTENT);
1:             } catch(KeeperException.NodeExistsException e) {
1:                 // ok we continue...
1:                 if (LOG.isDebugEnabled()) {
1:                     LOG.debug("parent already exists " + p);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     private byte[] toByteData(String data) {
1:         if (data == null) {
1:             return null;
1:         } else {
1:             try {
1:                 return data.getBytes(CHARSET);
1:             } catch(UnsupportedEncodingException e) {
1:                 throw new RuntimeException(e);
1:             }
1:         }
1:     }
1: }
============================================================================